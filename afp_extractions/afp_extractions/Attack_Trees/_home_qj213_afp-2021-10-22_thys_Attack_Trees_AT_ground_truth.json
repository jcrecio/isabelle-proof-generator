{"file_name": "/home/qj213/afp-2021-10-22/thys/Attack_Trees/AT.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Attack_Trees", "problem_names": ["lemma att_and_one: assumes \"\\<turnstile> a\" and  \"attack a = s\"\n  shows  \"\\<turnstile>([a] \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>)\"", "lemma att_and_empty[rule_format] : \" \\<turnstile>([] \\<oplus>\\<^sub>\\<and>\\<^bsup>(s', s'')\\<^esup>) \\<longrightarrow> s' \\<subseteq> s''\"", "lemma att_and_empty2: \" \\<turnstile>([] \\<oplus>\\<^sub>\\<and>\\<^bsup>(s, s)\\<^esup>)\"", "lemma att_or_empty[rule_format] : \" \\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>(s', s'')\\<^esup>) \\<longrightarrow> s' \\<subseteq> s''\"", "lemma att_or_empty_back[rule_format]: \" s' \\<subseteq> s'' \\<longrightarrow>  \\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>(s', s'')\\<^esup>)\"", "lemma att_or_empty_rev: assumes \"\\<turnstile>(l \\<oplus>\\<^sub>\\<or>\\<^bsup>(s, s')\\<^esup>)\" and \"\\<not>(s \\<subseteq> s')\" shows \"l \\<noteq> []\"", "lemma att_or_empty2: \"\\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>(s, s)\\<^esup>)\"", "lemma att_andD1: \" \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>) \\<Longrightarrow> \\<turnstile> x1\"", "lemma att_and_nonemptyD2[rule_format]: \n       \"(x2 \\<noteq> [] \\<longrightarrow> \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>) \\<longrightarrow> \\<turnstile> (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd(attack x1),snd s)\\<^esup>))\"", "lemma att_andD2 : \" \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>) \\<Longrightarrow> \\<turnstile> (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd(attack x1),snd s)\\<^esup>)\"", "lemma att_and_fst_lem[rule_format]: \n   \"\\<turnstile>(x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>) \\<longrightarrow> xa \\<in> fst (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\n                     \\<longrightarrow> xa \\<in> fst (attack x1)\"", "lemma att_orD1: \" \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>) \\<Longrightarrow> \\<turnstile> x1\"", "lemma att_or_snd_hd: \" \\<turnstile>(a # list \\<oplus>\\<^sub>\\<or>\\<^bsup>(aa, b)\\<^esup>) \\<Longrightarrow> snd(attack a) \\<subseteq> b\"", "lemma att_or_singleton[rule_format]: \n   \" \\<turnstile>([x1] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>) \\<longrightarrow> \\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>(fst x - fst (attack x1), snd x)\\<^esup>)\"", "lemma att_orD2[rule_format]: \n     \" \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>) \\<longrightarrow>  \\<turnstile> (x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>(fst x - fst(attack x1), snd x)\\<^esup>)\"", "lemma att_or_snd_att[rule_format]: \"\\<forall> x. \\<turnstile> (x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>) \\<longrightarrow> (\\<forall> a \\<in> (set x2). snd(attack a) \\<subseteq> snd x )\"", "lemma singleton_or_lem: \" \\<turnstile>([x1] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>)  \\<Longrightarrow> fst x \\<subseteq> fst(attack x1)\"", "lemma or_att_fst_sup0[rule_format]: \"x2 \\<noteq> [] \\<longrightarrow> (\\<forall> x. (\\<turnstile> ((x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>):: ('s :: state) attree)) \\<longrightarrow>\n                      ((\\<Union> y::'s attree\\<in> set x2. fst (attack y)) \\<supseteq> fst(x))) \"", "lemma or_att_fst_sup: \n    assumes \"(\\<turnstile> ((x1 # x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>):: ('s :: state) attree))\"\n    shows   \"((\\<Union> y::'s attree\\<in> set (x1 # x2). fst (attack y)) \\<supseteq> fst(x))\"", "lemma att_elem_seq[rule_format]: \"\\<turnstile> x1 \\<longrightarrow> (\\<forall> x \\<in> fst(attack x1).\n                     (\\<exists> y. y \\<in> snd(attack x1) \\<and> x \\<rightarrow>\\<^sub>i* y))\"", "lemma att_elem_seq0: \"\\<turnstile> x1 \\<Longrightarrow> (\\<forall> x \\<in> fst(attack x1).\n                     (\\<exists> y. y \\<in> snd(attack x1) \\<and> x \\<rightarrow>\\<^sub>i* y))\"", "lemma ref_valI: \" A \\<sqsubseteq> A'\\<Longrightarrow>  \\<turnstile> A' \\<Longrightarrow> \\<turnstile>\\<^sub>V A\"", "lemma nth_app_eq[rule_format]: \n              \"\\<forall> sl x. sl \\<noteq> [] \\<longrightarrow> sl ! (length sl - Suc (0)) = x\n              \\<longrightarrow> (l @ sl) ! (length l + length sl - Suc (0)) = x\"", "lemma nth_app_eq1[rule_format]: \"i < length sla \\<Longrightarrow> (sla @ sl) ! i = sla ! i\"", "lemma nth_app_eq1_rev:   \"i < length sla \\<Longrightarrow>  sla ! i = (sla @ sl) ! i\"", "lemma nth_app_eq2[rule_format]: \"\\<forall> sl i. length sla \\<le> i \\<and> i < length (sla @ sl)\n                     \\<longrightarrow> (sla @ sl) ! i = sl ! (i - (length sla))\"", "lemma tl_ne_ex[rule_format]: \"l \\<noteq> [] \\<longrightarrow> (? x . l = x # (tl l))\"", "lemma tl_nempty_lngth[rule_format]: \"tl sl \\<noteq> [] \\<longrightarrow> 2 \\<le> length(sl)\"", "lemma list_app_one_length: \"length l = n \\<Longrightarrow> (l @ [s]) ! n = s\"", "lemma tl_lem1[rule_format]: \"l \\<noteq> [] \\<longrightarrow> tl l = [] \\<longrightarrow> length l = 1\"", "lemma nth_tl_length[rule_format]: \"tl sl \\<noteq> [] \\<longrightarrow>\n      tl sl ! (length (tl sl) - Suc (0)) = sl ! (length sl - Suc (0))\"", "lemma nth_tl_length1[rule_format]: \"tl sl \\<noteq> [] \\<longrightarrow>\n      tl sl ! n = sl ! (n + 1)\"", "lemma ineq1: \"i < length sla - n  \\<Longrightarrow>\n       (0) \\<le> n \\<Longrightarrow> i < length sla\"", "lemma ineq2[rule_format]: \"length sla \\<le> i \\<longrightarrow> i + (1) - length sla = i - length sla + 1\"", "lemma ineq3: \"tl sl \\<noteq> []  \\<Longrightarrow> length sla \\<le> i \\<Longrightarrow> i < length (sla @ tl sl) - (1)\n              \\<Longrightarrow> i - length sla + (1) < length sl - (1)\"", "lemma tl_eq1[rule_format]: \"sl \\<noteq> [] \\<longrightarrow> tl sl ! (0) = sl ! Suc (0)\"", "lemma tl_eq2[rule_format]: \"tl sl = [] \\<longrightarrow> sl ! (0) = sl ! (length sl - (1))\"", "lemma tl_eq3[rule_format]: \"tl sl \\<noteq> [] \\<longrightarrow>\n    tl sl ! (length sl - Suc (Suc (0))) = sl ! (length sl - Suc (0))\"", "lemma nth_app_eq3: assumes \"tl sl \\<noteq> []\"\n  shows \"(sla @ tl sl) ! (length (sla @ tl sl) - (1)) = sl ! (length sl - (1))\"", "lemma not_empty_ex: \"A \\<noteq> {} \\<Longrightarrow> ? x. x \\<in> A\"", "lemma fst_att_eq: \"(fst x # sl) ! (0) = fst (attack (al \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\"", "lemma list_eq1[rule_format]: \"sl \\<noteq> [] \\<longrightarrow>\n     (fst x # sl) ! (length (fst x # sl) - (1)) = sl ! (length sl - (1))\"", "lemma attack_eq1: \"snd (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) = snd (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1), snd x)\\<^esup>))\"", "lemma fst_lem1[rule_format]: \"\\<forall> (a:: 's set) b (c :: 's set) d. (a, c) = (b, d) \\<longrightarrow> a = b\"", "lemma fst_eq1: \"(sla ! (0), y) = attack x1 \\<Longrightarrow>\n       sla ! (0) = fst (attack x1)\"", "lemma base_att_lem1: \" y0 \\<subseteq> y1 \\<Longrightarrow> \\<turnstile> \\<N>\\<^bsub>(y1, y)\\<^esub> \\<Longrightarrow>\\<turnstile> \\<N>\\<^bsub>(y0, y)\\<^esub>\"", "lemma ref_pres_att: \"A \\<sqsubseteq> A' \\<Longrightarrow> attack A = attack A'\"", "lemma  base_subset: \n    assumes \"xa \\<subseteq> xc\"\n    shows  \"\\<turnstile>\\<N>\\<^bsub>(x, xa)\\<^esub> \\<Longrightarrow> \\<turnstile>\\<N>\\<^bsub>(x, xc)\\<^esub>\"", "theorem AT_EF: assumes \" \\<turnstile> (A :: ('s :: state) attree)\"\n               and  \"attack A = (I,s)\"\n               shows \"Kripke {s :: ('s :: state). \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} (I :: ('s :: state)set)  \\<turnstile> EF s\"", "theorem ATV_EF: \"\\<lbrakk> \\<turnstile>\\<^sub>V A; (I,s) = attack A \\<rbrakk> \\<Longrightarrow>\n (Kripke {s. \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s) } I  \\<turnstile> EF s)\"", "lemma Compl_step1: \n\"Kripke {s :: ('s :: state). \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} I  \\<turnstile> EF s \n\\<Longrightarrow> \\<forall> x \\<in> I. \\<exists> y \\<in> s. x \\<rightarrow>\\<^sub>i* y\"", "lemma rtrancl_imp_singleton_seq2: \"x \\<rightarrow>\\<^sub>i* y \\<Longrightarrow> \n          x = y \\<or> (\\<exists> s. s \\<noteq> [] \\<and> (tl s \\<noteq> []) \\<and> s ! 0 = x \\<and> s ! (length s - 1) = y \\<and> \n               (\\<forall> i < (length s - 1). (s ! i) \\<rightarrow>\\<^sub>i (s ! (Suc i))))\"", "lemma tl_nempty_length[rule_format]: \"s \\<noteq> [] \\<longrightarrow> tl s \\<noteq> [] \\<longrightarrow> 0 < length s - 1\"", "lemma tl_nempty_length2[rule_format]: \"s \\<noteq> [] \\<longrightarrow> tl s \\<noteq> [] \\<longrightarrow> Suc 0 < length s\"", "lemma length_last[rule_format]: \"(l @ [x]) ! (length (l @ [x]) - 1) = x\"", "lemma Compl_step2: \"\\<forall> x \\<in> I. \\<exists> y \\<in> s. x \\<rightarrow>\\<^sub>i* y \\<Longrightarrow> \n                   ( \\<forall> x \\<in> I.  x \\<in> s \\<or> (\\<exists> (sl :: ((('s :: state) set)list)). \n                  (sl \\<noteq> []) \\<and> (tl sl \\<noteq> []) \\<and>\n                 (sl ! 0, sl ! (length sl - 1)) = ({x},s) \\<and>\n                 (\\<forall> i < (length sl - 1).  \\<turnstile> \\<N>\\<^bsub>(sl ! i,sl ! (i+1) )\\<^esub>\n                         )))\"", "lemma map_hd_lem[rule_format] : \"n > 0 \\<longrightarrow> (f 0 #  map (\\<lambda>i. f i) [1..<n]) = map  (\\<lambda>i. f i) [0..<n]\"", "lemma map_Suc_lem[rule_format] : \"n > 0 \\<longrightarrow> map (\\<lambda> i:: nat. f i)[1..<n] =\n                                  map (\\<lambda> i:: nat. f(Suc i))[0..<(n - 1)]\"", "lemma forall_ex_fun: \"finite S \\<Longrightarrow> (\\<forall> x \\<in> S. (\\<exists> y. P y x)) \\<longrightarrow> (\\<exists> f. \\<forall> x \\<in> S. P (f x) x)\"", "lemma nodup_all_lem[rule_format]: \n  \"nodup_all (x1 # a # l) \\<longrightarrow> (insert x1 (insert a (set l)) - {x1}) = insert a (set l)\"", "lemma nodup_all_tl[rule_format]: \"nodup_all (x # l) \\<longrightarrow> nodup_all l\"", "lemma finite_nodup: \"finite I \\<Longrightarrow> \\<exists> l. set l = I \\<and> nodup_all l\"", "lemma Compl_step3: \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow>\n     ( \\<forall> x \\<in> I.  x \\<in> s \\<or> (\\<exists> (sl :: ((('s :: state) set)list)). \n                  (sl \\<noteq> []) \\<and> (tl sl \\<noteq> []) \\<and>\n                 (sl ! 0, sl ! (length sl - 1)) = ({x},s) \\<and>\n                 (\\<forall> i < (length sl - 1).  \\<turnstile> \\<N>\\<^bsub>(sl ! i,sl ! (i+1) )\\<^esub>\n                         )) \\<Longrightarrow> \n     (\\<exists> lI. set lI = {x :: 's :: state. x \\<in> I \\<and> x \\<notin> s} \\<and> (\\<exists> Sj :: ((('s :: state) set)list) list. \n               length Sj = length lI \\<and> nodup_all lI \\<and>\n            (\\<forall> j < length Sj. (((Sj ! j)  \\<noteq> []) \\<and> (tl (Sj ! j) \\<noteq> []) \\<and>\n                 ((Sj ! j) ! 0, (Sj ! j) ! (length (Sj ! j) - 1)) = ({lI ! j},s) \\<and>\n                 (\\<forall> i < (length (Sj ! j) - 1).  \\<turnstile> \\<N>\\<^bsub>((Sj ! j) ! i, (Sj ! j) ! (i+1) )\\<^esub>\n                         ))))))\"", "lemma list_one_tl_empty[rule_format]: \"length l = Suc (0 :: nat) \\<longrightarrow> tl l = []\"", "lemma list_two_tl_not_empty[rule_format]: \"\\<forall> list. length l = Suc (Suc (length list)) \\<longrightarrow> tl l \\<noteq> []\"", "lemma or_empty: \"\\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>({}, s)\\<^esup>)\"", "lemma list_or_upt[rule_format]:\n \"\\<forall> l . lI \\<noteq> [] \\<longrightarrow> length l = length lI \\<longrightarrow> nodup_all lI \\<longrightarrow>\n  (\\<forall> i < length lI. (\\<turnstile> (l ! i)) \\<and> (attack (l ! i) = ({lI ! i}, s))) \n                \\<longrightarrow> ( \\<turnstile> (l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set lI, s)\\<^esup>))\"", "lemma app_tl_empty_hd[rule_format]: \"tl (l @ [a]) = [] \\<longrightarrow> hd (l @ [a]) = a\"", "lemma tl_hd_empty[rule_format]: \"tl (l @ [a]) = [] \\<longrightarrow> l = []\"", "lemma tl_hd_not_empty[rule_format]: \"tl (l @ [a]) \\<noteq> [] \\<longrightarrow> l \\<noteq> []\"", "lemma app_tl_empty_length[rule_format]: \"tl (map f [0..<length l] @ [a]) = []  \n                                        \\<Longrightarrow> l = []\"", "lemma not_empty_hd_fst[rule_format]: \"l \\<noteq> [] \\<longrightarrow> hd(l @ [a]) = l ! 0\"", "lemma app_tl_hd_list[rule_format]: \"tl (map f [0..<length l] @ [a]) \\<noteq> []  \n                             \\<Longrightarrow> hd(map f [0..<length l] @ [a]) = (map f [0..<length l]) ! 0\"", "lemma tl_app_in[rule_format]: \"l \\<noteq> [] \\<longrightarrow>\n   map f [0..<(length l - (Suc 0:: nat))] @ [f(length l - (Suc 0 :: nat))] = map f [0..<length l]\"", "lemma map_fst[rule_format]: \"n > 0 \\<longrightarrow> map f [0..<n] = f 0 # (map f [1..<n])\"", "lemma step_lem[rule_format]:  \"l \\<noteq> [] \\<Longrightarrow>\n       tl (map (\\<lambda> i. f((x1 # a # l) ! i)((a # l) ! i)) [0..<length l]) =\n       map (\\<lambda>i. f((a # l) ! i)(l ! i)) [0..<length l - (1)]\"", "lemma step_lem2a[rule_format]: \"0 < length list \\<Longrightarrow> map (\\<lambda>i. \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>)\n        [0..<length list] @\n       [\\<N>\\<^bsub>((x1 # a # list) ! length list, (a # list) ! length list)\\<^esub>] =\n       aa # listb \\<longrightarrow> \\<N>\\<^bsub>((x1, a))\\<^esub> = aa\"", "lemma step_lem2b[rule_format]: \"0 = length list \\<Longrightarrow> map (\\<lambda>i. \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>)\n        [0..<length list] @\n       [\\<N>\\<^bsub>((x1 # a # list) ! length list, (a # list) ! length list)\\<^esub>] =\n       aa # listb \\<longrightarrow> \\<N>\\<^bsub>((x1, a))\\<^esub> = aa\"", "lemma step_lem2: \"map (\\<lambda>i. \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>)\n        [0..<length list] @\n       [\\<N>\\<^bsub>((x1 # a # list) ! length list, (a # list) ! length list)\\<^esub>] =\n       aa # listb \\<Longrightarrow> \\<N>\\<^bsub>((x1, a))\\<^esub> = aa\"", "lemma base_list_and[rule_format]: \"Sji \\<noteq> [] \\<longrightarrow> tl Sji \\<noteq> [] \\<longrightarrow>\n         (\\<forall> li.  Sji ! (0) = li \\<longrightarrow>\n        Sji! (length (Sji) - 1) = s \\<longrightarrow>\n       (\\<forall>i<length (Sji) - 1. \\<turnstile>\\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n       \\<turnstile> (map (\\<lambda>i. \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n          [0..<length (Sji) - Suc (0)] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>))\"", "lemma Compl_step4: \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow> \\<not> I \\<subseteq> s \\<Longrightarrow>\n(\\<exists> lI. set lI = {x. x \\<in> I \\<and> x \\<notin> s} \\<and> (\\<exists> Sj :: ((('s :: state) set)list) list. \n               length Sj = length lI \\<and> nodup_all lI \\<and>\n            (\\<forall> j < length Sj. (((Sj ! j)  \\<noteq> []) \\<and> (tl (Sj ! j) \\<noteq> []) \\<and>\n                 ((Sj ! j) ! 0, (Sj ! j) ! (length (Sj ! j) - 1)) = ({lI ! j},s) \\<and>\n                 (\\<forall> i < (length (Sj ! j) - 1).  \\<turnstile> \\<N>\\<^bsub>((Sj ! j) ! i, (Sj ! j) ! (i+1) )\\<^esub>\n                         )))))\n \\<Longrightarrow>  \\<exists> (A :: ('s :: state) attree).  \\<turnstile> A \\<and> attack A = (I,s)\"", "theorem Completeness: \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow> \nKripke {s :: ('s :: state). \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} (I :: ('s :: state)set)  \\<turnstile> EF s \n\\<Longrightarrow> \\<exists> (A :: ('s :: state) attree). \\<turnstile> A \\<and> attack A = (I,s)\"", "lemma contrapos_compl: \n  \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow> \n  (\\<not> (\\<exists> (A :: ('s :: state) attree). \\<turnstile> A \\<and> attack A = (I, - s))) \\<Longrightarrow>\n\\<not> (Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s} I \\<turnstile> EF (- s))\"", "lemma contrapos_corr:   \n\"(\\<not>(Kripke {s :: ('s :: state). \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} I  \\<turnstile> EF s))\n\\<Longrightarrow> attack A = (I,s) \n\\<Longrightarrow> \\<not> (\\<turnstile> A)\""], "translations": [["", "lemma att_and_one: assumes \"\\<turnstile> a\" and  \"attack a = s\"\n  shows  \"\\<turnstile>([a] \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[a] \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>[a] \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>", "show \" \\<turnstile>([a] \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[a] \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>", "using assms"], ["proof (prove)\nusing this:\n  \\<turnstile>a\n  attack a = s\n\ngoal (1 subgoal):\n 1. \\<turnstile>[a] \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>", "by (subst att_and, simp del: att_and att_or)"], ["proof (state)\nthis:\n  \\<turnstile>[a] \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>\n\ngoal:\nNo subgoals!", "qed"], ["", "declare is_attack_tree.simps[simp del]"], ["", "lemma att_and_empty[rule_format] : \" \\<turnstile>([] \\<oplus>\\<^sub>\\<and>\\<^bsup>(s', s'')\\<^esup>) \\<longrightarrow> s' \\<subseteq> s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[] \\<oplus>\\<^sub>\\<and>\\<^bsup>(s',\n           s'')\\<^esup> \\<longrightarrow>\n    s' \\<subseteq> s''", "by (simp add: is_attack_tree.simps(2))"], ["", "lemma att_and_empty2: \" \\<turnstile>([] \\<oplus>\\<^sub>\\<and>\\<^bsup>(s, s)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[] \\<oplus>\\<^sub>\\<and>\\<^bsup>(s, s)\\<^esup>", "by (simp add: is_attack_tree.simps(2))"], ["", "lemma att_or_empty[rule_format] : \" \\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>(s', s'')\\<^esup>) \\<longrightarrow> s' \\<subseteq> s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>(s',\n          s'')\\<^esup> \\<longrightarrow>\n    s' \\<subseteq> s''", "by (simp add: is_attack_tree.simps(3))"], ["", "lemma att_or_empty_back[rule_format]: \" s' \\<subseteq> s'' \\<longrightarrow>  \\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>(s', s'')\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<subseteq> s'' \\<longrightarrow>\n    \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>(s', s'')\\<^esup>", "by (simp add: is_attack_tree.simps(3))"], ["", "lemma att_or_empty_rev: assumes \"\\<turnstile>(l \\<oplus>\\<^sub>\\<or>\\<^bsup>(s, s')\\<^esup>)\" and \"\\<not>(s \\<subseteq> s')\" shows \"l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> []", "using assms att_or_empty"], ["proof (prove)\nusing this:\n  \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(s, s')\\<^esup>\n  \\<not> s \\<subseteq> s'\n  \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>(?s',\n        ?s'')\\<^esup> \\<Longrightarrow>\n  ?s' \\<subseteq> ?s''\n\ngoal (1 subgoal):\n 1. l \\<noteq> []", "by blast"], ["", "lemma att_or_empty2: \"\\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>(s, s)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>(s, s)\\<^esup>", "by (simp add: att_or_empty_back)"], ["", "lemma att_andD1: \" \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>) \\<Longrightarrow> \\<turnstile> x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>x1 #\n                x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup> \\<Longrightarrow>\n    \\<turnstile>x1", "by (metis (no_types, lifting) is_attack_tree.simps(2) list.exhaust list.simps(4) list.simps(5))"], ["", "lemma att_and_nonemptyD2[rule_format]: \n       \"(x2 \\<noteq> [] \\<longrightarrow> \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>) \\<longrightarrow> \\<turnstile> (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd(attack x1),snd s)\\<^esup>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x2 \\<noteq> [] \\<longrightarrow>\n    \\<turnstile>x1 #\n                x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup> \\<longrightarrow>\n    \\<turnstile>x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n           snd s)\\<^esup>", "by (metis (no_types, lifting) is_attack_tree.simps(2) list.exhaust list.simps(5))"], ["", "lemma att_andD2 : \" \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup>) \\<Longrightarrow> \\<turnstile> (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd(attack x1),snd s)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>x1 #\n                x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>s\\<^esup> \\<Longrightarrow>\n    \\<turnstile>x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n           snd s)\\<^esup>", "by (metis (mono_tags, lifting) att_and_empty2 att_and_nonemptyD2 is_attack_tree.simps(2) list.simps(4) list.simps(5))"], ["", "lemma att_and_fst_lem[rule_format]: \n   \"\\<turnstile>(x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>) \\<longrightarrow> xa \\<in> fst (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\n                     \\<longrightarrow> xa \\<in> fst (attack x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>x1 #\n                x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n    xa \\<in> fst (attack\n                   (x1 #\n                    x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<longrightarrow>\n    xa \\<in> fst (attack x1)", "by (induction x2a, (subst att_and, simp)+)"], ["", "lemma att_orD1: \" \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>) \\<Longrightarrow> \\<turnstile> x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>x1 #\n                x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<Longrightarrow>\n    \\<turnstile>x1", "by (case_tac x2, (subst (asm) att_or, simp)+)"], ["", "lemma att_or_snd_hd: \" \\<turnstile>(a # list \\<oplus>\\<^sub>\\<or>\\<^bsup>(aa, b)\\<^esup>) \\<Longrightarrow> snd(attack a) \\<subseteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>a #\n                list \\<oplus>\\<^sub>\\<or>\\<^bsup>(aa,\n            b)\\<^esup> \\<Longrightarrow>\n    snd (attack a) \\<subseteq> b", "by (case_tac list,  (subst (asm) att_or, simp)+)"], ["", "lemma att_or_singleton[rule_format]: \n   \" \\<turnstile>([x1] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>) \\<longrightarrow> \\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>(fst x - fst (attack x1), snd x)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[x1] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n    \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>(fst x - fst (attack x1),\n          snd x)\\<^esup>", "by (subst att_or, simp, rule impI, rule att_or_empty_back, blast)"], ["", "lemma att_orD2[rule_format]: \n     \" \\<turnstile>(x1 # x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>) \\<longrightarrow>  \\<turnstile> (x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>(fst x - fst(attack x1), snd x)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>x1 #\n                x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n    \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>(fst x - fst (attack x1),\n          snd x)\\<^esup>", "by (case_tac x2, simp add: att_or_singleton, simp, subst att_or, simp)"], ["", "lemma att_or_snd_att[rule_format]: \"\\<forall> x. \\<turnstile> (x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>) \\<longrightarrow> (\\<forall> a \\<in> (set x2). snd(attack a) \\<subseteq> snd x )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n       (\\<forall>a\\<in>set x2. snd (attack a) \\<subseteq> snd x)", "proof (induction x2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n       (\\<forall>a\\<in>set []. snd (attack a) \\<subseteq> snd x)\n 2. \\<And>a x2.\n       \\<forall>x.\n          \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set x2.\n              snd (attack a) \\<subseteq> snd x) \\<Longrightarrow>\n       \\<forall>x.\n          \\<turnstile>a #\n                      x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set (a # x2). snd (attack a) \\<subseteq> snd x)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>x.\n       \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n       (\\<forall>a\\<in>set []. snd (attack a) \\<subseteq> snd x)\n 2. \\<And>a x2.\n       \\<forall>x.\n          \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set x2.\n              snd (attack a) \\<subseteq> snd x) \\<Longrightarrow>\n       \\<forall>x.\n          \\<turnstile>a #\n                      x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set (a # x2). snd (attack a) \\<subseteq> snd x)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n       (\\<forall>a\\<in>set []. snd (attack a) \\<subseteq> snd x)", "by (simp add: att_or)"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n     (\\<forall>a\\<in>set []. snd (attack a) \\<subseteq> snd x)\n\ngoal (1 subgoal):\n 1. \\<And>a x2.\n       \\<forall>x.\n          \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set x2.\n              snd (attack a) \\<subseteq> snd x) \\<Longrightarrow>\n       \\<forall>x.\n          \\<turnstile>a #\n                      x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set (a # x2). snd (attack a) \\<subseteq> snd x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x2.\n       \\<forall>x.\n          \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set x2.\n              snd (attack a) \\<subseteq> snd x) \\<Longrightarrow>\n       \\<forall>x.\n          \\<turnstile>a #\n                      x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set (a # x2). snd (attack a) \\<subseteq> snd x)", "case (Cons a x2)"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n     (\\<forall>a\\<in>set x2. snd (attack a) \\<subseteq> snd x)\n\ngoal (1 subgoal):\n 1. \\<And>a x2.\n       \\<forall>x.\n          \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set x2.\n              snd (attack a) \\<subseteq> snd x) \\<Longrightarrow>\n       \\<forall>x.\n          \\<turnstile>a #\n                      x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n          (\\<forall>a\\<in>set (a # x2). snd (attack a) \\<subseteq> snd x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n     (\\<forall>a\\<in>set x2. snd (attack a) \\<subseteq> snd x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n     (\\<forall>a\\<in>set x2. snd (attack a) \\<subseteq> snd x)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<turnstile>a #\n                   x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n       (\\<forall>a\\<in>set (a # x2). snd (attack a) \\<subseteq> snd x)", "using att_orD2 att_or_snd_hd"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n     (\\<forall>a\\<in>set x2. snd (attack a) \\<subseteq> snd x)\n  \\<turnstile>?x1.0 #\n              ?x2.0 \\<oplus>\\<^sub>\\<or>\\<^bsup>?x\\<^esup> \\<Longrightarrow>\n  \\<turnstile>?x2.0 \\<oplus>\\<^sub>\\<or>\\<^bsup>(fst ?x -\n           fst (attack ?x1.0),\n           snd ?x)\\<^esup>\n  \\<turnstile>?a #\n              ?list \\<oplus>\\<^sub>\\<or>\\<^bsup>(?aa,\n           ?b)\\<^esup> \\<Longrightarrow>\n  snd (attack ?a) \\<subseteq> ?b\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<turnstile>a #\n                   x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n       (\\<forall>a\\<in>set (a # x2). snd (attack a) \\<subseteq> snd x)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<turnstile>a #\n                 x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n     (\\<forall>a\\<in>set (a # x2). snd (attack a) \\<subseteq> snd x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_or_lem: \" \\<turnstile>([x1] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>)  \\<Longrightarrow> fst x \\<subseteq> fst(attack x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[x1] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<Longrightarrow>\n    fst x \\<subseteq> fst (attack x1)", "by (subst (asm) att_or, simp)+"], ["", "lemma or_att_fst_sup0[rule_format]: \"x2 \\<noteq> [] \\<longrightarrow> (\\<forall> x. (\\<turnstile> ((x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>):: ('s :: state) attree)) \\<longrightarrow>\n                      ((\\<Union> y::'s attree\\<in> set x2. fst (attack y)) \\<supseteq> fst(x))) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. x2 \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x.\n        \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n        fst x \\<subseteq> (\\<Union>y\\<in>set x2. fst (attack y)))", "proof (induction x2)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x.\n        \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n        fst x \\<subseteq> (\\<Union>y\\<in>set []. fst (attack y)))\n 2. \\<And>a x2.\n       x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x\n           \\<subseteq> (\\<Union>y\\<in>set x2.\n                           fst (attack y))) \\<Longrightarrow>\n       a # x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>a #\n                       x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x \\<subseteq> (\\<Union>y\\<in>set (a # x2). fst (attack y)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x.\n        \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n        fst x \\<subseteq> (\\<Union>y\\<in>set []. fst (attack y)))\n 2. \\<And>a x2.\n       x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x\n           \\<subseteq> (\\<Union>y\\<in>set x2.\n                           fst (attack y))) \\<Longrightarrow>\n       a # x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>a #\n                       x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x \\<subseteq> (\\<Union>y\\<in>set (a # x2). fst (attack y)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x.\n        \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n        fst x \\<subseteq> (\\<Union>y\\<in>set []. fst (attack y)))", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x.\n      \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n      fst x \\<subseteq> (\\<Union>y\\<in>set []. fst (attack y)))\n\ngoal (1 subgoal):\n 1. \\<And>a x2.\n       x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x\n           \\<subseteq> (\\<Union>y\\<in>set x2.\n                           fst (attack y))) \\<Longrightarrow>\n       a # x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>a #\n                       x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x \\<subseteq> (\\<Union>y\\<in>set (a # x2). fst (attack y)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x2.\n       x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x\n           \\<subseteq> (\\<Union>y\\<in>set x2.\n                           fst (attack y))) \\<Longrightarrow>\n       a # x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>a #\n                       x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x \\<subseteq> (\\<Union>y\\<in>set (a # x2). fst (attack y)))", "case (Cons a x2)"], ["proof (state)\nthis:\n  x2 \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x.\n      \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n      fst x \\<subseteq> (\\<Union>y\\<in>set x2. fst (attack y)))\n\ngoal (1 subgoal):\n 1. \\<And>a x2.\n       x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x\n           \\<subseteq> (\\<Union>y\\<in>set x2.\n                           fst (attack y))) \\<Longrightarrow>\n       a # x2 \\<noteq> [] \\<longrightarrow>\n       (\\<forall>x.\n           \\<turnstile>a #\n                       x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           fst x \\<subseteq> (\\<Union>y\\<in>set (a # x2). fst (attack y)))", "then"], ["proof (chain)\npicking this:\n  x2 \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x.\n      \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n      fst x \\<subseteq> (\\<Union>y\\<in>set x2. fst (attack y)))", "show ?case"], ["proof (prove)\nusing this:\n  x2 \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x.\n      \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n      fst x \\<subseteq> (\\<Union>y\\<in>set x2. fst (attack y)))\n\ngoal (1 subgoal):\n 1. a # x2 \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x.\n        \\<turnstile>a #\n                    x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n        fst x \\<subseteq> (\\<Union>y\\<in>set (a # x2). fst (attack y)))", "using att_orD2 singleton_or_lem"], ["proof (prove)\nusing this:\n  x2 \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x.\n      \\<turnstile>x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n      fst x \\<subseteq> (\\<Union>y\\<in>set x2. fst (attack y)))\n  \\<turnstile>?x1.0 #\n              ?x2.0 \\<oplus>\\<^sub>\\<or>\\<^bsup>?x\\<^esup> \\<Longrightarrow>\n  \\<turnstile>?x2.0 \\<oplus>\\<^sub>\\<or>\\<^bsup>(fst ?x -\n           fst (attack ?x1.0),\n           snd ?x)\\<^esup>\n  \\<turnstile>[?x1.0] \\<oplus>\\<^sub>\\<or>\\<^bsup>?x\\<^esup> \\<Longrightarrow>\n  fst ?x \\<subseteq> fst (attack ?x1.0)\n\ngoal (1 subgoal):\n 1. a # x2 \\<noteq> [] \\<longrightarrow>\n    (\\<forall>x.\n        \\<turnstile>a #\n                    x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n        fst x \\<subseteq> (\\<Union>y\\<in>set (a # x2). fst (attack y)))", "by fastforce"], ["proof (state)\nthis:\n  a # x2 \\<noteq> [] \\<longrightarrow>\n  (\\<forall>x.\n      \\<turnstile>a #\n                  x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup> \\<longrightarrow>\n      fst x \\<subseteq> (\\<Union>y\\<in>set (a # x2). fst (attack y)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma or_att_fst_sup: \n    assumes \"(\\<turnstile> ((x1 # x2 \\<oplus>\\<^sub>\\<or>\\<^bsup>x\\<^esup>):: ('s :: state) attree))\"\n    shows   \"((\\<Union> y::'s attree\\<in> set (x1 # x2). fst (attack y)) \\<supseteq> fst(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x \\<subseteq> (\\<Union>y\\<in>set (x1 # x2). fst (attack y))", "by (rule or_att_fst_sup0, simp, rule assms)"], ["", "text \\<open>The lemma @{text \\<open>att_elem_seq\\<close>} is the main lemma for Correctness.\n  It shows that for a given attack tree x1, for each element in the set of start sets \n  of the first attack, we can reach in zero or more steps a state in the states in which \n  the attack is successful (the final attack state @{text \\<open>snd(attack x1)\\<close>}).\n  This proof is a big alternative to an earlier version of the proof with\n  @{text \\<open>first_step\\<close>} etc that mapped first on a sequence of sets of states.\\<close>"], ["", "lemma att_elem_seq[rule_format]: \"\\<turnstile> x1 \\<longrightarrow> (\\<forall> x \\<in> fst(attack x1).\n                     (\\<exists> y. y \\<in> snd(attack x1) \\<and> x \\<rightarrow>\\<^sub>i* y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>x1 \\<longrightarrow>\n    (\\<forall>x\\<in>fst (attack x1).\n        \\<exists>y.\n           y \\<in> snd (attack x1) \\<and> x \\<rightarrow>\\<^sub>i* y)", "text \\<open>First attack tree induction\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>x1 \\<longrightarrow>\n    (\\<forall>x\\<in>fst (attack x1).\n        \\<exists>y.\n           y \\<in> snd (attack x1) \\<and> x \\<rightarrow>\\<^sub>i* y)", "proof (induction x1)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<turnstile>\\<N>\\<^bsub>x\\<^esub> \\<longrightarrow>\n       (\\<forall>xa\\<in>fst (attack \\<N>\\<^bsub>x\\<^esub>).\n           \\<exists>y.\n              y \\<in> snd (attack \\<N>\\<^bsub>x\\<^esub>) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y)\n 2. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)\n 3. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)", "case (BaseAttack x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<turnstile>\\<N>\\<^bsub>x\\<^esub> \\<longrightarrow>\n       (\\<forall>xa\\<in>fst (attack \\<N>\\<^bsub>x\\<^esub>).\n           \\<exists>y.\n              y \\<in> snd (attack \\<N>\\<^bsub>x\\<^esub>) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y)\n 2. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)\n 3. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<N>\\<^bsub>x\\<^esub> \\<longrightarrow>\n    (\\<forall>xa\\<in>fst (attack \\<N>\\<^bsub>x\\<^esub>).\n        \\<exists>y.\n           y \\<in> snd (attack \\<N>\\<^bsub>x\\<^esub>) \\<and>\n           xa \\<rightarrow>\\<^sub>i* y)", "by (metis AT.att_base EF_step EF_step_star_rev attack.simps(1))"], ["proof (state)\nthis:\n  \\<turnstile>\\<N>\\<^bsub>x\\<^esub> \\<longrightarrow>\n  (\\<forall>xa\\<in>fst (attack \\<N>\\<^bsub>x\\<^esub>).\n      \\<exists>y.\n         y \\<in> snd (attack \\<N>\\<^bsub>x\\<^esub>) \\<and>\n         xa \\<rightarrow>\\<^sub>i* y)\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)\n 2. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)\n 2. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)", "case (AndAttack x1a x2)"], ["proof (state)\nthis:\n  ?x1aa \\<in> set x1a \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)\n\ngoal (2 subgoals):\n 1. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)\n 2. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)", "then"], ["proof (chain)\npicking this:\n  ?x1aa \\<in> set x1a \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "show ?case"], ["proof (prove)\nusing this:\n  ?x1aa \\<in> set x1a \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)\n\ngoal (1 subgoal):\n 1. \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n    (\\<forall>x\\<in>fst (attack\n                          (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)).\n        \\<exists>y.\n           y \\<in> snd (attack\n                         (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)) \\<and>\n           x \\<rightarrow>\\<^sub>i* y)", "apply (rule_tac x = x2 in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x.\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n       (\\<forall>xa\\<in>fst (attack\n                              (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y)", "apply (subgoal_tac \"(\\<forall> x1aa::'a attree.\n                              x1aa \\<in> set x1a \\<longrightarrow>\n                               \\<turnstile>x1aa \\<longrightarrow>\n                               (\\<forall>x::'a\\<in>fst (attack x1aa). \\<exists>y::'a. y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                         (\\<forall>xa\\<in>fst\n     (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                             \\<exists>y.\n                                y \\<in> snd\n   (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                xa \\<rightarrow>\\<^sub>i* y)\n 2. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "apply (rule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> ?P4 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                          (\\<forall>xa\\<in>fst\n      (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                              \\<exists>y.\n                                 y \\<in> snd\n    (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                 xa \\<rightarrow>\\<^sub>i* y))\n 2. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> ?P4\n 3. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> ?P4\n 2. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> ?P4 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                          (\\<forall>xa\\<in>fst\n      (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                              \\<exists>y.\n                                 y \\<in> snd\n    (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                 xa \\<rightarrow>\\<^sub>i* y))\n 3. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x1aa.\n                x1aa \\<in> set x1a \\<longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> ?P4\n 2. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> ?P4 \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                          (\\<forall>xa\\<in>fst\n      (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                              \\<exists>y.\n                                 y \\<in> snd\n    (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                 xa \\<rightarrow>\\<^sub>i* y))\n 3. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x1aa.\n                          x1aa \\<in> set x1a \\<longrightarrow>\n                          \\<turnstile>x1aa \\<longrightarrow>\n                          (\\<forall>x\\<in>fst (attack x1aa).\n                              \\<exists>y.\n                                 y \\<in> snd (attack x1aa) \\<and>\n                                 x \\<rightarrow>\\<^sub>i*\n                                 y)) \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                          (\\<forall>xa\\<in>fst\n      (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                              \\<exists>y.\n                                 y \\<in> snd\n    (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                 xa \\<rightarrow>\\<^sub>i* y))\n 2. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "text \\<open>Induction for @{text \\<open>\\<and>\\<close>}: the manual instantiation seems tedious but in the @{text \\<open>\\<and>\\<close>} \n            case necessary to get the right induction hypothesis.\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x1aa.\n                          x1aa \\<in> set x1a \\<longrightarrow>\n                          \\<turnstile>x1aa \\<longrightarrow>\n                          (\\<forall>x\\<in>fst (attack x1aa).\n                              \\<exists>y.\n                                 y \\<in> snd (attack x1aa) \\<and>\n                                 x \\<rightarrow>\\<^sub>i*\n                                 y)) \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                          (\\<forall>xa\\<in>fst\n      (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                              \\<exists>y.\n                                 y \\<in> snd\n    (attack (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                 xa \\<rightarrow>\\<^sub>i* y))\n 2. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "proof (rule_tac list = \"x1a\" in list.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x1aa.\n                          x1aa \\<in> set [] \\<longrightarrow>\n                          \\<turnstile>x1aa \\<longrightarrow>\n                          (\\<forall>x\\<in>fst (attack x1aa).\n                              \\<exists>y.\n                                 y \\<in> snd (attack x1aa) \\<and>\n                                 x \\<rightarrow>\\<^sub>i*\n                                 y)) \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<turnstile>[] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                          (\\<forall>xa\\<in>fst\n      (attack ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                              \\<exists>y.\n                                 y \\<in> snd\n    (attack ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                 xa \\<rightarrow>\\<^sub>i* y))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2 \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1aa.\n                             x1aa \\<in> set (x1 # x2) \\<longrightarrow>\n                             \\<turnstile>x1aa \\<longrightarrow>\n                             (\\<forall>x\\<in>fst (attack x1aa).\n                                 \\<exists>y.\n                                    y \\<in> snd (attack x1aa) \\<and>\n                                    x \\<rightarrow>\\<^sub>i*\n                                    y)) \\<longrightarrow>\n                         (\\<forall>x.\n                             \\<turnstile>x1 #\n   x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                             (\\<forall>xa\n \\<in>fst (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                                 \\<exists>y.\n                                    y \\<in> snd\n       (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                    xa \\<rightarrow>\\<^sub>i* y))\n 3. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "text \\<open>The @{text \\<open>\\<and>\\<close>} induction empty case\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x1aa.\n                x1aa \\<in> set x1a \\<Longrightarrow>\n                \\<turnstile>x1aa \\<longrightarrow>\n                (\\<forall>x\\<in>fst (attack x1aa).\n                    \\<exists>y.\n                       y \\<in> snd (attack x1aa) \\<and>\n                       x \\<rightarrow>\\<^sub>i* y);\n     \\<forall>x1aa.\n        x1aa \\<in> set x1a \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x1aa.\n                          x1aa \\<in> set [] \\<longrightarrow>\n                          \\<turnstile>x1aa \\<longrightarrow>\n                          (\\<forall>x\\<in>fst (attack x1aa).\n                              \\<exists>y.\n                                 y \\<in> snd (attack x1aa) \\<and>\n                                 x \\<rightarrow>\\<^sub>i*\n                                 y)) \\<longrightarrow>\n                      (\\<forall>x.\n                          \\<turnstile>[] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                          (\\<forall>xa\\<in>fst\n      (attack ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                              \\<exists>y.\n                                 y \\<in> snd\n    (attack ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                 xa \\<rightarrow>\\<^sub>i* y))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2 \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1aa.\n                             x1aa \\<in> set (x1 # x2) \\<longrightarrow>\n                             \\<turnstile>x1aa \\<longrightarrow>\n                             (\\<forall>x\\<in>fst (attack x1aa).\n                                 \\<exists>y.\n                                    y \\<in> snd (attack x1aa) \\<and>\n                                    x \\<rightarrow>\\<^sub>i*\n                                    y)) \\<longrightarrow>\n                         (\\<forall>x.\n                             \\<turnstile>x1 #\n   x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                             (\\<forall>xa\n \\<in>fst (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                                 \\<exists>y.\n                                    y \\<in> snd\n       (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                    xa \\<rightarrow>\\<^sub>i* y))\n 3. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "show \"(\\<forall>x1aa::'a attree.\n           x1aa \\<in> set [] \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow> (\\<forall>x::'a\\<in>fst (attack x1aa). \\<exists>y::'a. y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n       (\\<forall>x::'a set \\<times> 'a set.\n           \\<turnstile>([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>) \\<longrightarrow>\n           (\\<forall>xa::'a\\<in>fst (attack ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)). \\<exists>y::'a. y \\<in> snd (attack ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and> xa \\<rightarrow>\\<^sub>i* y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x1aa.\n        x1aa \\<in> set [] \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n    (\\<forall>x.\n        \\<turnstile>[] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n        (\\<forall>xa\\<in>fst (attack\n                               ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n            \\<exists>y.\n               y \\<in> snd (attack\n                             ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n               xa \\<rightarrow>\\<^sub>i* y))", "using att_and_empty state_transition_refl_def"], ["proof (prove)\nusing this:\n  \\<turnstile>[] \\<oplus>\\<^sub>\\<and>\\<^bsup>(?s',\n         ?s'')\\<^esup> \\<Longrightarrow>\n  ?s' \\<subseteq> ?s''\n  ?s \\<rightarrow>\\<^sub>i* ?s' \\<equiv>\n  (?s, ?s') \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<forall>x1aa.\n        x1aa \\<in> set [] \\<longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n    (\\<forall>x.\n        \\<turnstile>[] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n        (\\<forall>xa\\<in>fst (attack\n                               ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n            \\<exists>y.\n               y \\<in> snd (attack\n                             ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n               xa \\<rightarrow>\\<^sub>i* y))", "by fastforce"], ["proof (state)\nthis:\n  (\\<forall>x1aa.\n      x1aa \\<in> set [] \\<longrightarrow>\n      \\<turnstile>x1aa \\<longrightarrow>\n      (\\<forall>x\\<in>fst (attack x1aa).\n          \\<exists>y.\n             y \\<in> snd (attack x1aa) \\<and>\n             x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n  (\\<forall>x.\n      \\<turnstile>[] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n      (\\<forall>xa\\<in>fst (attack\n                             ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n          \\<exists>y.\n             y \\<in> snd (attack\n                           ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n             xa \\<rightarrow>\\<^sub>i* y))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2 \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1aa.\n                             x1aa \\<in> set (x1 # x2) \\<longrightarrow>\n                             \\<turnstile>x1aa \\<longrightarrow>\n                             (\\<forall>x\\<in>fst (attack x1aa).\n                                 \\<exists>y.\n                                    y \\<in> snd (attack x1aa) \\<and>\n                                    x \\<rightarrow>\\<^sub>i*\n                                    y)) \\<longrightarrow>\n                         (\\<forall>x.\n                             \\<turnstile>x1 #\n   x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                             (\\<forall>xa\n \\<in>fst (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                                 \\<exists>y.\n                                    y \\<in> snd\n       (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                    xa \\<rightarrow>\\<^sub>i* y))\n 2. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "text \\<open>The @{text \\<open>\\<and>\\<close>} induction case nonempty\\<close>"], ["proof (state)\nthis:\n  (\\<forall>x1aa.\n      x1aa \\<in> set [] \\<longrightarrow>\n      \\<turnstile>x1aa \\<longrightarrow>\n      (\\<forall>x\\<in>fst (attack x1aa).\n          \\<exists>y.\n             y \\<in> snd (attack x1aa) \\<and>\n             x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n  (\\<forall>x.\n      \\<turnstile>[] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n      (\\<forall>xa\\<in>fst (attack\n                             ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n          \\<exists>y.\n             y \\<in> snd (attack\n                           ([] \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n             xa \\<rightarrow>\\<^sub>i* y))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2 \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1aa.\n                             x1aa \\<in> set (x1 # x2) \\<longrightarrow>\n                             \\<turnstile>x1aa \\<longrightarrow>\n                             (\\<forall>x\\<in>fst (attack x1aa).\n                                 \\<exists>y.\n                                    y \\<in> snd (attack x1aa) \\<and>\n                                    x \\<rightarrow>\\<^sub>i*\n                                    y)) \\<longrightarrow>\n                         (\\<forall>x.\n                             \\<turnstile>x1 #\n   x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                             (\\<forall>xa\n \\<in>fst (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                                 \\<exists>y.\n                                    y \\<in> snd\n       (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                    xa \\<rightarrow>\\<^sub>i* y))\n 2. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2 \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1aa.\n                             x1aa \\<in> set (x1 # x2) \\<longrightarrow>\n                             \\<turnstile>x1aa \\<longrightarrow>\n                             (\\<forall>x\\<in>fst (attack x1aa).\n                                 \\<exists>y.\n                                    y \\<in> snd (attack x1aa) \\<and>\n                                    x \\<rightarrow>\\<^sub>i*\n                                    y)) \\<longrightarrow>\n                         (\\<forall>x.\n                             \\<turnstile>x1 #\n   x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                             (\\<forall>xa\n \\<in>fst (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                                 \\<exists>y.\n                                    y \\<in> snd\n       (attack (x1 # x2 \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                    xa \\<rightarrow>\\<^sub>i* y))\n 2. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "show \"\\<And>(x1a::'a attree list) (x2::'a set \\<times> 'a set) (x1::'a attree) (x2a::'a attree list).\n       (\\<And>x1aa::'a attree.\n           (x1aa \\<in> set x1a) \\<Longrightarrow>\n           ((\\<turnstile>x1aa) \\<longrightarrow> (\\<forall>x::'a\\<in>fst (attack x1aa). \\<exists>y::'a. y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y))) \\<Longrightarrow>\n       \\<forall>x1aa::'a attree.\n          (x1aa \\<in> set x1a) \\<longrightarrow>\n          (\\<turnstile>x1aa) \\<longrightarrow> ((\\<forall>x::'a\\<in>fst (attack x1aa). \\<exists>y::'a. y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       (\\<forall>x1aa::'a attree.\n           (x1aa \\<in> set x2a) \\<longrightarrow>\n           (\\<turnstile>x1aa) \\<longrightarrow> (\\<forall>x::'a\\<in>fst (attack x1aa). \\<exists>y::'a. y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n       (\\<forall>x::'a set \\<times> 'a set.\n           (\\<turnstile>(x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<longrightarrow>\n           ((\\<forall>xa::'a\\<in>fst (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)). \\<exists>y::'a. y \\<in> snd (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and> xa \\<rightarrow>\\<^sub>i* y))) \\<Longrightarrow>\n       ((\\<forall>x1aa::'a attree.\n           (x1aa \\<in> set (x1 # x2a)) \\<longrightarrow>\n           (\\<turnstile>x1aa) \\<longrightarrow> ((\\<forall>x::'a\\<in>fst (attack x1aa). \\<exists>y::'a. y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y))) \\<longrightarrow>\n       (\\<forall>x::'a set \\<times> 'a set.\n          ( \\<turnstile>(x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<longrightarrow>\n           (\\<forall>xa::'a\\<in>fst (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               (\\<exists>y::'a. y \\<in> snd (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and> (xa \\<rightarrow>\\<^sub>i* y)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1aa.\n                             x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                             \\<turnstile>x1aa \\<longrightarrow>\n                             (\\<forall>x\\<in>fst (attack x1aa).\n                                 \\<exists>y.\n                                    y \\<in> snd (attack x1aa) \\<and>\n                                    x \\<rightarrow>\\<^sub>i*\n                                    y)) \\<longrightarrow>\n                         (\\<forall>x.\n                             \\<turnstile>x1 #\n   x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                             (\\<forall>xa\n \\<in>fst (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                                 \\<exists>y.\n                                    y \\<in> snd\n       (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                    xa \\<rightarrow>\\<^sub>i* y))", "apply (rule impI, rule allI, rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y));\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>fst\n    (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                            \\<exists>y.\n                               y \\<in> snd\n  (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                               xa \\<rightarrow>\\<^sub>i* y", "text \\<open>Set free the Induction Hypothesis: this is necessary to provide the grounds for specific \n              instantiations in the step.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y));\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>fst\n    (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                            \\<exists>y.\n                               y \\<in> snd\n  (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                               xa \\<rightarrow>\\<^sub>i* y", "apply (subgoal_tac \"(\\<forall>x::'a set \\<times> 'a set.\n                             \\<turnstile>(x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>) \\<longrightarrow>\n                             (\\<forall>xa::'a\\<in>fst (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                              \\<exists>y::'a. y \\<in> snd (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and> xa \\<rightarrow>\\<^sub>i* y))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y));\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        \\<forall>x.\n           \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           (\\<forall>xa\\<in>fst (attack\n                                  (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               \\<exists>y.\n                  y \\<in> snd (attack\n                                (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                  xa \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>fst\n    (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                            \\<exists>y.\n                               y \\<in> snd\n  (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                               xa \\<rightarrow>\\<^sub>i* y\n 2. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y));\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                            (\\<forall>xa\n\\<in>fst (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                                \\<exists>y.\n                                   y \\<in> snd\n      (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                   xa \\<rightarrow>\\<^sub>i* y)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y));\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                            (\\<forall>xa\n\\<in>fst (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                                \\<exists>y.\n                                   y \\<in> snd\n      (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                                   xa \\<rightarrow>\\<^sub>i* y)\n 2. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y));\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        \\<forall>x.\n           \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           (\\<forall>xa\\<in>fst (attack\n                                  (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               \\<exists>y.\n                  y \\<in> snd (attack\n                                (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                  xa \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>fst\n    (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                            \\<exists>y.\n                               y \\<in> snd\n  (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                               xa \\<rightarrow>\\<^sub>i* y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y));\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        \\<forall>x.\n           \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           (\\<forall>xa\\<in>fst (attack\n                                  (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               \\<exists>y.\n                  y \\<in> snd (attack\n                                (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                  xa \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>fst\n    (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                            \\<exists>y.\n                               y \\<in> snd\n  (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                               xa \\<rightarrow>\\<^sub>i* y", "text \\<open>The following induction step for @{text \\<open>\\<and>\\<close>} needs a number of manual instantiations \n              so that the proof is not found automatically. In the subsequent case for @{text \\<open>\\<or>\\<close>}, \n              sledgehammer finds the proof.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y));\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        \\<forall>x.\n           \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           (\\<forall>xa\\<in>fst (attack\n                                  (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               \\<exists>y.\n                  y \\<in> snd (attack\n                                (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                  xa \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>fst\n    (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                            \\<exists>y.\n                               y \\<in> snd\n  (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                               xa \\<rightarrow>\\<^sub>i* y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<And>x1aa.\n                   x1aa \\<in> set x1a \\<Longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set x1a \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        (\\<forall>x1aa.\n            x1aa \\<in> set x2a \\<longrightarrow>\n            \\<turnstile>x1aa \\<longrightarrow>\n            (\\<forall>x\\<in>fst (attack x1aa).\n                \\<exists>y.\n                   y \\<in> snd (attack x1aa) \\<and>\n                   x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n        (\\<forall>x.\n            \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n            (\\<forall>xa\\<in>fst (attack\n                                   (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                \\<exists>y.\n                   y \\<in> snd (attack\n                                 (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                   xa \\<rightarrow>\\<^sub>i* y));\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        \\<forall>x.\n           \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           (\\<forall>xa\\<in>fst (attack\n                                  (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               \\<exists>y.\n                  y \\<in> snd (attack\n                                (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                  xa \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>fst\n    (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                            \\<exists>y.\n                               y \\<in> snd\n  (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                               xa \\<rightarrow>\\<^sub>i* y", "show \"\\<And>(x1a::'a attree list) (x2::'a set \\<times> 'a set) (x1::'a attree) (x2a::'a attree list) x::'a set \\<times> 'a set.\n       \\<forall>x1aa::'a attree.\n          x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n          \\<turnstile>x1aa \\<longrightarrow> (\\<forall>x::'a\\<in>fst (attack x1aa). \\<exists>y::'a. y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y) \\<Longrightarrow>\n       \\<turnstile>(x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>) \\<Longrightarrow>\n       \\<forall>x::'a set \\<times> 'a set.\n          \\<turnstile>(x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>) \\<longrightarrow>\n          (\\<forall>xa::'a\\<in>fst (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)). \\<exists>y::'a. y \\<in> snd (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and> xa \\<rightarrow>\\<^sub>i* y) \\<Longrightarrow>\n       \\<forall>xa::'a\\<in>fst (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)). \\<exists>y::'a. y \\<in> snd (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and> xa \\<rightarrow>\\<^sub>i* y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x.\n       \\<lbrakk>\\<forall>x1aa.\n                   x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        \\<forall>x.\n           \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           (\\<forall>xa\\<in>fst (attack\n                                  (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               \\<exists>y.\n                  y \\<in> snd (attack\n                                (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                  xa \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>xa\\<in>fst\n    (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                            \\<exists>y.\n                               y \\<in> snd\n  (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                               xa \\<rightarrow>\\<^sub>i* y", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<forall>x1aa.\n                   x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        \\<forall>x.\n           \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           (\\<forall>xa\\<in>fst (attack\n                                  (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               \\<exists>y.\n                  y \\<in> snd (attack\n                                (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                  xa \\<rightarrow>\\<^sub>i* y);\n        xa \\<in> fst (attack\n                       (x1 #\n                        x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (rename_tac xa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<forall>x1aa.\n                   x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        \\<forall>x.\n           \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           (\\<forall>xa\\<in>fst (attack\n                                  (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               \\<exists>y.\n                  y \\<in> snd (attack\n                                (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                  xa \\<rightarrow>\\<^sub>i* y);\n        xa \\<in> fst (attack\n                       (x1 #\n                        x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "text \\<open>Prepare the steps\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<forall>x1aa.\n                   x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        \\<forall>x.\n           \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n           (\\<forall>xa\\<in>fst (attack\n                                  (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n               \\<exists>y.\n                  y \\<in> snd (attack\n                                (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                  xa \\<rightarrow>\\<^sub>i* y);\n        xa \\<in> fst (attack\n                       (x1 #\n                        x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (drule_tac x = \"(snd(attack x1), snd x)\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<forall>x1aa.\n                   x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n                snd x)\\<^esup> \\<longrightarrow>\n        (\\<forall>xa\\<in>fst (attack\n                               (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                             (attack x1),\n                            snd x)\\<^esup>)).\n            \\<exists>y.\n               y \\<in> snd (attack\n                             (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                           (attack x1),\n                          snd x)\\<^esup>)) \\<and>\n               xa \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                         (attack x1),\n                        snd x)\\<^esup> \\<longrightarrow>\n                (\\<forall>xa\\<in>fst (attack\n (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1), snd x)\\<^esup>)).\n                    \\<exists>y.\n                       y \\<in> snd (attack\n                                     (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                                   (attack x1),\n                                  snd x)\\<^esup>)) \\<and>\n                       xa \\<rightarrow>\\<^sub>i* y);\n        \\<forall>x1aa.\n           x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 #\n                        x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<forall>x1aa.\n                   x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 #\n                        x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                                  (attack x1),\n                                 snd x)\\<^esup>\n 2. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<forall>x1aa.\n                   x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (erule att_andD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<forall>x1aa.\n                   x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "text \\<open>Premise for x1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<forall>x1aa.\n                   x1aa \\<in> set (x1 # x2a) \\<longrightarrow>\n                   \\<turnstile>x1aa \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack x1aa).\n                       \\<exists>y.\n                          y \\<in> snd (attack x1aa) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (drule_tac x = x1 in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        x1 \\<in> set (x1 # x2a) \\<longrightarrow>\n        \\<turnstile>x1 \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1).\n            \\<exists>y.\n               y \\<in> snd (attack x1) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> x1 \\<in> set (x1 # x2a)\n 2. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        \\<turnstile>x1 \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1).\n            \\<exists>y.\n               y \\<in> snd (attack x1) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        \\<turnstile>x1 \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1).\n            \\<exists>y.\n               y \\<in> snd (attack x1) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (drule mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>x1\n 2. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        \\<forall>x\\<in>fst (attack x1).\n           \\<exists>y.\n              y \\<in> snd (attack x1) \\<and>\n              x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (erule att_andD1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        \\<forall>x\\<in>fst (attack x1).\n           \\<exists>y.\n              y \\<in> snd (attack x1) \\<and>\n              x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "text \\<open>Instantiate first step for xa\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        \\<forall>x\\<in>fst (attack x1).\n           \\<exists>y.\n              y \\<in> snd (attack x1) \\<and>\n              x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<forall>x\\<in>fst (attack x1).\n                   \\<exists>y.\n                      y \\<in> snd (attack x1) \\<and>\n                      x \\<rightarrow>\\<^sub>i* y;\n        \\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (drule_tac x = xa in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> fst (attack x1)\n 2. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        \\<exists>y.\n           y \\<in> snd (attack x1) \\<and>\n           xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (erule att_and_fst_lem, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        \\<exists>y.\n           y \\<in> snd (attack x1) \\<and>\n           xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa y.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        y \\<in> snd (attack x1) \\<and> xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa y.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "text \\<open>Take this y and put it as first into the second part\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa y.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        \\<forall>xa\\<in>fst (attack\n                              (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                            (attack x1),\n                           snd x)\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                          (attack x1),\n                         snd x)\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y;\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (drule_tac x = y in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x1 x2a x xa y.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> y \\<in> fst (attack\n (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1), snd x)\\<^esup>))\n 2. \\<And>x1a x2 x1 x2a x xa y.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y;\n        \\<exists>ya.\n           ya \\<in> snd (attack\n                          (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                        (attack x1),\n                       snd x)\\<^esup>)) \\<and>\n           y \\<rightarrow>\\<^sub>i* ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa y.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y;\n        \\<exists>ya.\n           ya \\<in> snd (attack\n                          (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                        (attack x1),\n                       snd x)\\<^esup>)) \\<and>\n           y \\<rightarrow>\\<^sub>i* ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa y ya.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y;\n        ya \\<in> snd (attack\n                       (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n                    snd x)\\<^esup>)) \\<and>\n        y \\<rightarrow>\\<^sub>i* ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (erule conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa y ya.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y;\n        ya \\<in> snd (attack\n                       (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n                    snd x)\\<^esup>));\n        y \\<rightarrow>\\<^sub>i* ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "text \\<open>Bind the first @{text \\<open>xa \\<rightarrow>\\<^sub>i* y\\<close>} and second @{text \\<open>y \\<rightarrow>\\<^sub>i* ya\\<close>} together for solution\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa y ya.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y;\n        ya \\<in> snd (attack\n                       (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n                    snd x)\\<^esup>));\n        y \\<rightarrow>\\<^sub>i* ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            y \\<in> snd (attack\n    (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                            xa \\<rightarrow>\\<^sub>i* y", "apply (rule_tac x = ya in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa y ya.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y;\n        ya \\<in> snd (attack\n                       (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n                    snd x)\\<^esup>));\n        y \\<rightarrow>\\<^sub>i* ya\\<rbrakk>\n       \\<Longrightarrow> ya \\<in> snd (attack\n  (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                         xa \\<rightarrow>\\<^sub>i* ya", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x2 x1 x2a x xa y ya.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y;\n        ya \\<in> snd (attack\n                       (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n                    snd x)\\<^esup>));\n        y \\<rightarrow>\\<^sub>i* ya\\<rbrakk>\n       \\<Longrightarrow> ya \\<in> snd (attack\n  (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\n 2. \\<And>x1a x2 x1 x2a x xa y ya.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y;\n        ya \\<in> snd (attack\n                       (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n                    snd x)\\<^esup>));\n        y \\<rightarrow>\\<^sub>i* ya\\<rbrakk>\n       \\<Longrightarrow> xa \\<rightarrow>\\<^sub>i* ya", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x2 x1 x2a x xa y ya.\n       \\<lbrakk>\\<turnstile>x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>;\n        xa \\<in> fst (attack\n                       (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>));\n        y \\<in> snd (attack x1); xa \\<rightarrow>\\<^sub>i* y;\n        ya \\<in> snd (attack\n                       (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n                    snd x)\\<^esup>));\n        y \\<rightarrow>\\<^sub>i* ya\\<rbrakk>\n       \\<Longrightarrow> xa \\<rightarrow>\\<^sub>i* ya", "by (simp add: state_transition_refl_def)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x1aa.\n              x1aa \\<in> set (?x1.0 # ?x2a) \\<longrightarrow>\n              \\<turnstile>x1aa \\<longrightarrow>\n              (\\<forall>x\\<in>fst (attack x1aa).\n                  \\<exists>y.\n                     y \\<in> snd (attack x1aa) \\<and>\n                     x \\<rightarrow>\\<^sub>i* y);\n   \\<turnstile>?x1.0 # ?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>?x\\<^esup>;\n   \\<forall>x.\n      \\<turnstile>?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n      (\\<forall>xa\\<in>fst (attack\n                             (?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n          \\<exists>y.\n             y \\<in> snd (attack\n                           (?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n             xa \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>xa\\<in>fst (attack\n    (?x1.0 # ?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>?x\\<^esup>)).\n                       \\<exists>y.\n                          y \\<in> snd (attack\n  (?x1.0 # ?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>?x\\<^esup>)) \\<and>\n                          xa \\<rightarrow>\\<^sub>i* y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x1aa.\n              x1aa \\<in> set ?x1a \\<Longrightarrow>\n              \\<turnstile>x1aa \\<longrightarrow>\n              (\\<forall>x\\<in>fst (attack x1aa).\n                  \\<exists>y.\n                     y \\<in> snd (attack x1aa) \\<and>\n                     x \\<rightarrow>\\<^sub>i* y);\n   \\<forall>x1aa.\n      x1aa \\<in> set ?x1a \\<longrightarrow>\n      \\<turnstile>x1aa \\<longrightarrow>\n      (\\<forall>x\\<in>fst (attack x1aa).\n          \\<exists>y.\n             y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y);\n   (\\<forall>x1aa.\n       x1aa \\<in> set ?x2a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)) \\<longrightarrow>\n   (\\<forall>x.\n       \\<turnstile>?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n       (\\<forall>xa\\<in>fst (attack\n                              (?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n              xa \\<rightarrow>\\<^sub>i* y))\\<rbrakk>\n  \\<Longrightarrow> (\\<forall>x1aa.\n                        x1aa \\<in> set (?x1.0 # ?x2a) \\<longrightarrow>\n                        \\<turnstile>x1aa \\<longrightarrow>\n                        (\\<forall>x\\<in>fst (attack x1aa).\n                            \\<exists>y.\n                               y \\<in> snd (attack x1aa) \\<and>\n                               x \\<rightarrow>\\<^sub>i*\n                               y)) \\<longrightarrow>\n                    (\\<forall>x.\n                        \\<turnstile>?x1.0 #\n                                    ?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup> \\<longrightarrow>\n                        (\\<forall>xa\\<in>fst\n    (attack (?x1.0 # ?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)).\n                            \\<exists>y.\n                               y \\<in> snd\n  (attack (?x1.0 # ?x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) \\<and>\n                               xa \\<rightarrow>\\<^sub>i* y))\n\ngoal (1 subgoal):\n 1. (\\<And>x1aa.\n        x1aa \\<in> set x1a \\<Longrightarrow>\n        \\<turnstile>x1aa \\<longrightarrow>\n        (\\<forall>x\\<in>fst (attack x1aa).\n            \\<exists>y.\n               y \\<in> snd (attack x1aa) \\<and>\n               x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n    \\<forall>x1aa.\n       x1aa \\<in> set x1a \\<longrightarrow>\n       \\<turnstile>x1aa \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack x1aa).\n           \\<exists>y.\n              y \\<in> snd (attack x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "qed auto"], ["proof (state)\nthis:\n  \\<turnstile>x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack\n                        (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)).\n      \\<exists>y.\n         y \\<in> snd (attack\n                       (x1a \\<oplus>\\<^sub>\\<and>\\<^bsup>x2\\<^esup>)) \\<and>\n         x \\<rightarrow>\\<^sub>i* y)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)", "case (OrAttack x1a x2)"], ["proof (state)\nthis:\n  ?x1aa \\<in> set x1a \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set x1a \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)", "then"], ["proof (chain)\npicking this:\n  ?x1aa \\<in> set x1a \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "show ?case"], ["proof (prove)\nusing this:\n  ?x1aa \\<in> set x1a \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)\n\ngoal (1 subgoal):\n 1. \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n    (\\<forall>x\\<in>fst (attack\n                          (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n        \\<exists>y.\n           y \\<in> snd (attack\n                         (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n           x \\<rightarrow>\\<^sub>i* y)", "proof (induction x1a arbitrary: x2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set [] \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             ([] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            ([] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)\n 2. \\<And>a x1a x2.\n       \\<lbrakk>\\<And>x2.\n                   (\\<And>x1aa.\n                       x1aa \\<in> set x1a \\<Longrightarrow>\n                       \\<turnstile>x1aa \\<longrightarrow>\n                       (\\<forall>x\\<in>fst (attack x1aa).\n                           \\<exists>y.\n                              y \\<in> snd (attack x1aa) \\<and>\n                              x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n                   \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack\n   (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                       \\<exists>y.\n                          y \\<in> snd (attack\n  (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<And>x1aa.\n           x1aa \\<in> set (a # x1a) \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>a #\n                                     x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                         (\\<forall>x\\<in>fst\n    (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                             \\<exists>y.\n                                y \\<in> snd\n   (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                                x \\<rightarrow>\\<^sub>i* y)", "case Nil"], ["proof (state)\nthis:\n  ?x1aa \\<in> set [] \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       (\\<And>x1aa.\n           x1aa \\<in> set [] \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n       \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n       (\\<forall>x\\<in>fst (attack\n                             ([] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n           \\<exists>y.\n              y \\<in> snd (attack\n                            ([] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n              x \\<rightarrow>\\<^sub>i* y)\n 2. \\<And>a x1a x2.\n       \\<lbrakk>\\<And>x2.\n                   (\\<And>x1aa.\n                       x1aa \\<in> set x1a \\<Longrightarrow>\n                       \\<turnstile>x1aa \\<longrightarrow>\n                       (\\<forall>x\\<in>fst (attack x1aa).\n                           \\<exists>y.\n                              y \\<in> snd (attack x1aa) \\<and>\n                              x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n                   \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack\n   (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                       \\<exists>y.\n                          y \\<in> snd (attack\n  (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<And>x1aa.\n           x1aa \\<in> set (a # x1a) \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>a #\n                                     x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                         (\\<forall>x\\<in>fst\n    (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                             \\<exists>y.\n                                y \\<in> snd\n   (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                                x \\<rightarrow>\\<^sub>i* y)", "then"], ["proof (chain)\npicking this:\n  ?x1aa \\<in> set [] \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "show ?case"], ["proof (prove)\nusing this:\n  ?x1aa \\<in> set [] \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)\n\ngoal (1 subgoal):\n 1. \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n    (\\<forall>x\\<in>fst (attack\n                          ([] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n        \\<exists>y.\n           y \\<in> snd (attack\n                         ([] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n           x \\<rightarrow>\\<^sub>i* y)", "by (metis EF_lem2a EF_step_star_rev att_or_empty attack.simps(3) subsetD surjective_pairing)"], ["proof (state)\nthis:\n  \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ([] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n      \\<exists>y.\n         y \\<in> snd (attack\n                       ([] \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n         x \\<rightarrow>\\<^sub>i* y)\n\ngoal (1 subgoal):\n 1. \\<And>a x1a x2.\n       \\<lbrakk>\\<And>x2.\n                   (\\<And>x1aa.\n                       x1aa \\<in> set x1a \\<Longrightarrow>\n                       \\<turnstile>x1aa \\<longrightarrow>\n                       (\\<forall>x\\<in>fst (attack x1aa).\n                           \\<exists>y.\n                              y \\<in> snd (attack x1aa) \\<and>\n                              x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n                   \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack\n   (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                       \\<exists>y.\n                          y \\<in> snd (attack\n  (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<And>x1aa.\n           x1aa \\<in> set (a # x1a) \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>a #\n                                     x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                         (\\<forall>x\\<in>fst\n    (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                             \\<exists>y.\n                                y \\<in> snd\n   (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                                x \\<rightarrow>\\<^sub>i* y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x1a x2.\n       \\<lbrakk>\\<And>x2.\n                   (\\<And>x1aa.\n                       x1aa \\<in> set x1a \\<Longrightarrow>\n                       \\<turnstile>x1aa \\<longrightarrow>\n                       (\\<forall>x\\<in>fst (attack x1aa).\n                           \\<exists>y.\n                              y \\<in> snd (attack x1aa) \\<and>\n                              x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n                   \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack\n   (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                       \\<exists>y.\n                          y \\<in> snd (attack\n  (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<And>x1aa.\n           x1aa \\<in> set (a # x1a) \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>a #\n                                     x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                         (\\<forall>x\\<in>fst\n    (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                             \\<exists>y.\n                                y \\<in> snd\n   (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                                x \\<rightarrow>\\<^sub>i* y)", "case (Cons a x1a)"], ["proof (state)\nthis:\n  (\\<And>x1aaa.\n      x1aaa \\<in> set x1a \\<Longrightarrow>\n      \\<turnstile>x1aaa \\<longrightarrow>\n      (\\<forall>x\\<in>fst (attack x1aaa).\n          \\<exists>y.\n             y \\<in> snd (attack x1aaa) \\<and>\n             x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n  \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>?x2.0\\<^esup> \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack\n                        (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>?x2.0\\<^esup>)).\n      \\<exists>y.\n         y \\<in> snd (attack\n                       (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>?x2.0\\<^esup>)) \\<and>\n         x \\<rightarrow>\\<^sub>i* y)\n  ?x1aa \\<in> set (a # x1a) \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)\n\ngoal (1 subgoal):\n 1. \\<And>a x1a x2.\n       \\<lbrakk>\\<And>x2.\n                   (\\<And>x1aa.\n                       x1aa \\<in> set x1a \\<Longrightarrow>\n                       \\<turnstile>x1aa \\<longrightarrow>\n                       (\\<forall>x\\<in>fst (attack x1aa).\n                           \\<exists>y.\n                              y \\<in> snd (attack x1aa) \\<and>\n                              x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n                   \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                   (\\<forall>x\\<in>fst (attack\n   (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                       \\<exists>y.\n                          y \\<in> snd (attack\n  (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                          x \\<rightarrow>\\<^sub>i* y);\n        \\<And>x1aa.\n           x1aa \\<in> set (a # x1a) \\<Longrightarrow>\n           \\<turnstile>x1aa \\<longrightarrow>\n           (\\<forall>x\\<in>fst (attack x1aa).\n               \\<exists>y.\n                  y \\<in> snd (attack x1aa) \\<and>\n                  x \\<rightarrow>\\<^sub>i* y)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>a #\n                                     x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n                         (\\<forall>x\\<in>fst\n    (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n                             \\<exists>y.\n                                y \\<in> snd\n   (attack (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n                                x \\<rightarrow>\\<^sub>i* y)", "then"], ["proof (chain)\npicking this:\n  (\\<And>x1aaa.\n      x1aaa \\<in> set x1a \\<Longrightarrow>\n      \\<turnstile>x1aaa \\<longrightarrow>\n      (\\<forall>x\\<in>fst (attack x1aaa).\n          \\<exists>y.\n             y \\<in> snd (attack x1aaa) \\<and>\n             x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n  \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>?x2.0\\<^esup> \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack\n                        (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>?x2.0\\<^esup>)).\n      \\<exists>y.\n         y \\<in> snd (attack\n                       (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>?x2.0\\<^esup>)) \\<and>\n         x \\<rightarrow>\\<^sub>i* y)\n  ?x1aa \\<in> set (a # x1a) \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x1aaa.\n      x1aaa \\<in> set x1a \\<Longrightarrow>\n      \\<turnstile>x1aaa \\<longrightarrow>\n      (\\<forall>x\\<in>fst (attack x1aaa).\n          \\<exists>y.\n             y \\<in> snd (attack x1aaa) \\<and>\n             x \\<rightarrow>\\<^sub>i* y)) \\<Longrightarrow>\n  \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>?x2.0\\<^esup> \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack\n                        (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>?x2.0\\<^esup>)).\n      \\<exists>y.\n         y \\<in> snd (attack\n                       (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>?x2.0\\<^esup>)) \\<and>\n         x \\<rightarrow>\\<^sub>i* y)\n  ?x1aa \\<in> set (a # x1a) \\<Longrightarrow>\n  \\<turnstile>?x1aa \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack ?x1aa).\n      \\<exists>y.\n         y \\<in> snd (attack ?x1aa) \\<and> x \\<rightarrow>\\<^sub>i* y)\n\ngoal (1 subgoal):\n 1. \\<turnstile>a #\n                x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n    (\\<forall>x\\<in>fst (attack\n                          (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n        \\<exists>y.\n           y \\<in> snd (attack\n                         (a #\n                          x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n           x \\<rightarrow>\\<^sub>i* y)", "by (smt DiffI att_orD1 att_orD2 att_or_snd_att attack.simps(3) insert_iff list.set(2) prod.sel(1) snd_conv subset_iff)"], ["proof (state)\nthis:\n  \\<turnstile>a #\n              x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack\n                        (a # x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n      \\<exists>y.\n         y \\<in> snd (attack\n                       (a #\n                        x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n         x \\<rightarrow>\\<^sub>i* y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile>x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup> \\<longrightarrow>\n  (\\<forall>x\\<in>fst (attack (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)).\n      \\<exists>y.\n         y \\<in> snd (attack\n                       (x1a \\<oplus>\\<^sub>\\<or>\\<^bsup>x2\\<^esup>)) \\<and>\n         x \\<rightarrow>\\<^sub>i* y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma att_elem_seq0: \"\\<turnstile> x1 \\<Longrightarrow> (\\<forall> x \\<in> fst(attack x1).\n                     (\\<exists> y. y \\<in> snd(attack x1) \\<and> x \\<rightarrow>\\<^sub>i* y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>x1 \\<Longrightarrow>\n    \\<forall>x\\<in>fst (attack x1).\n       \\<exists>y. y \\<in> snd (attack x1) \\<and> x \\<rightarrow>\\<^sub>i* y", "by (simp add: att_elem_seq)"], ["", "subsection \\<open>Valid refinements\\<close>"], ["", "definition valid_ref :: \"[('s :: state) attree, 's attree] \\<Rightarrow> bool\" (\"_ \\<sqsubseteq>\\<^sub>V _\" 50)\n  where\n\"A \\<sqsubseteq>\\<^sub>V A' \\<equiv>  ( (A \\<sqsubseteq> A') \\<and>  \\<turnstile> A')\""], ["", "definition ref_validity :: \"[('s :: state) attree] \\<Rightarrow> bool\" (\"\\<turnstile>\\<^sub>V _\" 50)\n  where\n\"\\<turnstile>\\<^sub>V A  \\<equiv>  (\\<exists> A'. (A \\<sqsubseteq>\\<^sub>V A'))\""], ["", "lemma ref_valI: \" A \\<sqsubseteq> A'\\<Longrightarrow>  \\<turnstile> A' \\<Longrightarrow> \\<turnstile>\\<^sub>V A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<sqsubseteq> A'; \\<turnstile>A'\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>V A", "using ref_validity_def valid_ref_def"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>V ?A \\<equiv> \\<exists>A'. ?A \\<sqsubseteq>\\<^sub>V A'\n  ?A \\<sqsubseteq>\\<^sub>V ?A' \\<equiv>\n  ?A \\<sqsubseteq> ?A' \\<and> \\<turnstile>?A'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<sqsubseteq> A'; \\<turnstile>A'\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<^sub>V A", "by blast"], ["", "section \"Correctness and Completeness\""], ["", "text \\<open>This section presents the main theorems of Correctness and Completeness\n      between AT and Kripke, essentially: \n\n@{text \\<open>\\<turnstile> (init K, p) \\<equiv>  K \\<turnstile> EF p\\<close>}.\n\nFirst, we proof a number of lemmas needed for both directions before we \nshow the Correctness theorem followed by the Completeness theorem.\n\\<close>"], ["", "subsection \\<open>Lemma for Correctness and Completeness\\<close>"], ["", "lemma nth_app_eq[rule_format]: \n              \"\\<forall> sl x. sl \\<noteq> [] \\<longrightarrow> sl ! (length sl - Suc (0)) = x\n              \\<longrightarrow> (l @ sl) ! (length l + length sl - Suc (0)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sl x.\n       sl \\<noteq> [] \\<longrightarrow>\n       sl ! (length sl - Suc 0) = x \\<longrightarrow>\n       (l @ sl) ! (length l + length sl - Suc 0) = x", "by (induction l) auto"], ["", "lemma nth_app_eq1[rule_format]: \"i < length sla \\<Longrightarrow> (sla @ sl) ! i = sla ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length sla \\<Longrightarrow> (sla @ sl) ! i = sla ! i", "by (simp add: nth_append)"], ["", "lemma nth_app_eq1_rev:   \"i < length sla \\<Longrightarrow>  sla ! i = (sla @ sl) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length sla \\<Longrightarrow> sla ! i = (sla @ sl) ! i", "by (simp add: nth_append)"], ["", "lemma nth_app_eq2[rule_format]: \"\\<forall> sl i. length sla \\<le> i \\<and> i < length (sla @ sl)\n                     \\<longrightarrow> (sla @ sl) ! i = sl ! (i - (length sla))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sl i.\n       length sla \\<le> i \\<and> i < length (sla @ sl) \\<longrightarrow>\n       (sla @ sl) ! i = sl ! (i - length sla)", "by (simp add: nth_append)"], ["", "lemma tl_ne_ex[rule_format]: \"l \\<noteq> [] \\<longrightarrow> (? x . l = x # (tl l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<longrightarrow> (\\<exists>x. l = x # tl l)", "by (induction l, auto)"], ["", "lemma tl_nempty_lngth[rule_format]: \"tl sl \\<noteq> [] \\<longrightarrow> 2 \\<le> length(sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl sl \\<noteq> [] \\<longrightarrow> 2 \\<le> length sl", "using le_less"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. tl sl \\<noteq> [] \\<longrightarrow> 2 \\<le> length sl", "by fastforce"], ["", "lemma list_app_one_length: \"length l = n \\<Longrightarrow> (l @ [s]) ! n = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = n \\<Longrightarrow> (l @ [s]) ! n = s", "by (erule subst, simp)"], ["", "lemma tl_lem1[rule_format]: \"l \\<noteq> [] \\<longrightarrow> tl l = [] \\<longrightarrow> length l = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<longrightarrow> tl l = [] \\<longrightarrow> length l = 1", "by (induction l, simp+)"], ["", "lemma nth_tl_length[rule_format]: \"tl sl \\<noteq> [] \\<longrightarrow>\n      tl sl ! (length (tl sl) - Suc (0)) = sl ! (length sl - Suc (0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl sl \\<noteq> [] \\<longrightarrow>\n    tl sl ! (length (tl sl) - Suc 0) = sl ! (length sl - Suc 0)", "by (induction sl, simp+)"], ["", "lemma nth_tl_length1[rule_format]: \"tl sl \\<noteq> [] \\<longrightarrow>\n      tl sl ! n = sl ! (n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl sl \\<noteq> [] \\<longrightarrow> tl sl ! n = sl ! (n + 1)", "by (induction sl, simp+)"], ["", "lemma ineq1: \"i < length sla - n  \\<Longrightarrow>\n       (0) \\<le> n \\<Longrightarrow> i < length sla\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length sla - n; 0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> i < length sla", "by simp"], ["", "lemma ineq2[rule_format]: \"length sla \\<le> i \\<longrightarrow> i + (1) - length sla = i - length sla + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length sla \\<le> i \\<longrightarrow>\n    i + 1 - length sla = i - length sla + 1", "by arith"], ["", "lemma ineq3: \"tl sl \\<noteq> []  \\<Longrightarrow> length sla \\<le> i \\<Longrightarrow> i < length (sla @ tl sl) - (1)\n              \\<Longrightarrow> i - length sla + (1) < length sl - (1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tl sl \\<noteq> []; length sla \\<le> i;\n     i < length (sla @ tl sl) - 1\\<rbrakk>\n    \\<Longrightarrow> i - length sla + 1 < length sl - 1", "by simp"], ["", "lemma tl_eq1[rule_format]: \"sl \\<noteq> [] \\<longrightarrow> tl sl ! (0) = sl ! Suc (0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<longrightarrow> tl sl ! 0 = sl ! Suc 0", "by (induction sl, simp+)"], ["", "lemma tl_eq2[rule_format]: \"tl sl = [] \\<longrightarrow> sl ! (0) = sl ! (length sl - (1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl sl = [] \\<longrightarrow> sl ! 0 = sl ! (length sl - 1)", "by (induction sl, simp+)"], ["", "lemma tl_eq3[rule_format]: \"tl sl \\<noteq> [] \\<longrightarrow>\n    tl sl ! (length sl - Suc (Suc (0))) = sl ! (length sl - Suc (0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl sl \\<noteq> [] \\<longrightarrow>\n    tl sl ! (length sl - Suc (Suc 0)) = sl ! (length sl - Suc 0)", "by (induction sl, simp+)"], ["", "lemma nth_app_eq3: assumes \"tl sl \\<noteq> []\"\n  shows \"(sla @ tl sl) ! (length (sla @ tl sl) - (1)) = sl ! (length sl - (1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sla @ tl sl) ! (length (sla @ tl sl) - 1) = sl ! (length sl - 1)", "using assms nth_app_eq nth_tl_length"], ["proof (prove)\nusing this:\n  tl sl \\<noteq> []\n  \\<lbrakk>?sl \\<noteq> []; ?sl ! (length ?sl - Suc 0) = ?x\\<rbrakk>\n  \\<Longrightarrow> (?l @ ?sl) ! (length ?l + length ?sl - Suc 0) = ?x\n  tl ?sl \\<noteq> [] \\<Longrightarrow>\n  tl ?sl ! (length (tl ?sl) - Suc 0) = ?sl ! (length ?sl - Suc 0)\n\ngoal (1 subgoal):\n 1. (sla @ tl sl) ! (length (sla @ tl sl) - 1) = sl ! (length sl - 1)", "by fastforce"], ["", "lemma not_empty_ex: \"A \\<noteq> {} \\<Longrightarrow> ? x. x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow> \\<exists>x. x \\<in> A", "by force"], ["", "lemma fst_att_eq: \"(fst x # sl) ! (0) = fst (attack (al \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst x # sl) ! 0 =\n    fst (attack (al \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>))", "by simp"], ["", "lemma list_eq1[rule_format]: \"sl \\<noteq> [] \\<longrightarrow>\n     (fst x # sl) ! (length (fst x # sl) - (1)) = sl ! (length sl - (1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<longrightarrow>\n    (fst x # sl) ! (length (fst x # sl) - 1) = sl ! (length sl - 1)", "by (induction sl, auto)"], ["", "lemma attack_eq1: \"snd (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) = snd (attack (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1), snd x)\\<^esup>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (attack (x1 # x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>x\\<^esup>)) =\n    snd (attack\n          (x2a \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack x1),\n       snd x)\\<^esup>))", "by simp"], ["", "lemma fst_lem1[rule_format]: \"\\<forall> (a:: 's set) b (c :: 's set) d. (a, c) = (b, d) \\<longrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b c d. (a, c) = (b, d) \\<longrightarrow> a = b", "by auto"], ["", "lemma fst_eq1: \"(sla ! (0), y) = attack x1 \\<Longrightarrow>\n       sla ! (0) = fst (attack x1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sla ! 0, y) = attack x1 \\<Longrightarrow> sla ! 0 = fst (attack x1)", "by (rule_tac c = y and d = \"snd(attack  x1)\" in fst_lem1, simp)"], ["", "lemma base_att_lem1: \" y0 \\<subseteq> y1 \\<Longrightarrow> \\<turnstile> \\<N>\\<^bsub>(y1, y)\\<^esub> \\<Longrightarrow>\\<turnstile> \\<N>\\<^bsub>(y0, y)\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y0 \\<subseteq> y1;\n     \\<turnstile>\\<N>\\<^bsub>(y1, y)\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>\\<N>\\<^bsub>(y0, y)\\<^esub>", "by (simp add: att_base, blast)"], ["", "lemma ref_pres_att: \"A \\<sqsubseteq> A' \\<Longrightarrow> attack A = attack A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sqsubseteq> A' \\<Longrightarrow> attack A = attack A'", "proof (erule refines_to.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>A l si' si'' l'' si si''' A' l' A''.\n       \\<lbrakk>A =\n                l @\n                [\\<N>\\<^bsub>(si', si'')\\<^esub>] @\n                l'' \\<oplus>\\<^sub>\\<and>\\<^bsup>(si, si''')\\<^esup>;\n        A' = l' \\<oplus>\\<^sub>\\<and>\\<^bsup>(si', si'')\\<^esup>;\n        A'' =\n        l @\n        l' @ l'' \\<oplus>\\<^sub>\\<and>\\<^bsup>(si, si''')\\<^esup>\\<rbrakk>\n       \\<Longrightarrow> attack A = attack A''\n 2. \\<And>as A s.\n       \\<lbrakk>as \\<noteq> [];\n        \\<forall>A'\\<in>set as.\n           (A \\<sqsubseteq> A' \\<and> attack A = attack A') \\<and>\n           attack A = s\\<rbrakk>\n       \\<Longrightarrow> attack A =\n                         attack (as \\<oplus>\\<^sub>\\<or>\\<^bsup>s\\<^esup>)\n 3. \\<And>A A' A''.\n       \\<lbrakk>A \\<sqsubseteq> A'; attack A = attack A';\n        A' \\<sqsubseteq> A''; attack A' = attack A''\\<rbrakk>\n       \\<Longrightarrow> attack A = attack A''\n 4. \\<And>A. attack A = attack A", "show \"\\<And>(A::'a attree) (l::'a attree list) (si'::'a set) (si''::'a set) (l''::'a attree list) (si::'a set)\n       (si'''::'a set) (A'::'a attree) (l'::'a attree list) A''::'a attree.\n       A = (l @ [\\<N>\\<^bsub>(si', si'')\\<^esub>] @ l'' \\<oplus>\\<^sub>\\<and>\\<^bsup>(si, si''')\\<^esup>) \\<Longrightarrow>\n       A' = (l' \\<oplus>\\<^sub>\\<and>\\<^bsup>(si', si'')\\<^esup>) \\<Longrightarrow> A'' = (l @ l' @ l'' \\<oplus>\\<^sub>\\<and>\\<^bsup>(si, si''')\\<^esup>) \\<Longrightarrow> attack A = attack A''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A l si' si'' l'' si si''' A' l' A''.\n       \\<lbrakk>A =\n                l @\n                [\\<N>\\<^bsub>(si', si'')\\<^esub>] @\n                l'' \\<oplus>\\<^sub>\\<and>\\<^bsup>(si, si''')\\<^esup>;\n        A' = l' \\<oplus>\\<^sub>\\<and>\\<^bsup>(si', si'')\\<^esup>;\n        A'' =\n        l @\n        l' @ l'' \\<oplus>\\<^sub>\\<and>\\<^bsup>(si, si''')\\<^esup>\\<rbrakk>\n       \\<Longrightarrow> attack A = attack A''", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?A =\n           ?l @\n           [\\<N>\\<^bsub>(?si', ?si'')\\<^esub>] @\n           ?l'' \\<oplus>\\<^sub>\\<and>\\<^bsup>(?si, ?si''')\\<^esup>;\n   ?A' = ?l' \\<oplus>\\<^sub>\\<and>\\<^bsup>(?si', ?si'')\\<^esup>;\n   ?A'' =\n   ?l @\n   ?l' @ ?l'' \\<oplus>\\<^sub>\\<and>\\<^bsup>(?si, ?si''')\\<^esup>\\<rbrakk>\n  \\<Longrightarrow> attack ?A = attack ?A''\n\ngoal (3 subgoals):\n 1. \\<And>as A s.\n       \\<lbrakk>as \\<noteq> [];\n        \\<forall>A'\\<in>set as.\n           (A \\<sqsubseteq> A' \\<and> attack A = attack A') \\<and>\n           attack A = s\\<rbrakk>\n       \\<Longrightarrow> attack A =\n                         attack (as \\<oplus>\\<^sub>\\<or>\\<^bsup>s\\<^esup>)\n 2. \\<And>A A' A''.\n       \\<lbrakk>A \\<sqsubseteq> A'; attack A = attack A';\n        A' \\<sqsubseteq> A''; attack A' = attack A''\\<rbrakk>\n       \\<Longrightarrow> attack A = attack A''\n 3. \\<And>A. attack A = attack A", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>as A s.\n       \\<lbrakk>as \\<noteq> [];\n        \\<forall>A'\\<in>set as.\n           (A \\<sqsubseteq> A' \\<and> attack A = attack A') \\<and>\n           attack A = s\\<rbrakk>\n       \\<Longrightarrow> attack A =\n                         attack (as \\<oplus>\\<^sub>\\<or>\\<^bsup>s\\<^esup>)\n 2. \\<And>A A' A''.\n       \\<lbrakk>A \\<sqsubseteq> A'; attack A = attack A';\n        A' \\<sqsubseteq> A''; attack A' = attack A''\\<rbrakk>\n       \\<Longrightarrow> attack A = attack A''\n 3. \\<And>A. attack A = attack A", "show \"\\<And>(as::'a attree list) (A::'a attree) (s::'a set \\<times> 'a set).\n       as \\<noteq> [] \\<Longrightarrow>\n       (\\<forall>A'::'a attree\\<in> (set as). ((A \\<sqsubseteq> A') \\<and> (attack A = attack A')) \\<and> attack A = s) \\<Longrightarrow>\n       attack A = attack (as \\<oplus>\\<^sub>\\<or>\\<^bsup>s\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>as A s.\n       \\<lbrakk>as \\<noteq> [];\n        \\<forall>A'\\<in>set as.\n           (A \\<sqsubseteq> A' \\<and> attack A = attack A') \\<and>\n           attack A = s\\<rbrakk>\n       \\<Longrightarrow> attack A =\n                         attack (as \\<oplus>\\<^sub>\\<or>\\<^bsup>s\\<^esup>)", "using last_in_set"], ["proof (prove)\nusing this:\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. \\<And>as A s.\n       \\<lbrakk>as \\<noteq> [];\n        \\<forall>A'\\<in>set as.\n           (A \\<sqsubseteq> A' \\<and> attack A = attack A') \\<and>\n           attack A = s\\<rbrakk>\n       \\<Longrightarrow> attack A =\n                         attack (as \\<oplus>\\<^sub>\\<or>\\<^bsup>s\\<^esup>)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?as \\<noteq> [];\n   \\<forall>A'\\<in>set ?as.\n      (?A \\<sqsubseteq> A' \\<and> attack ?A = attack A') \\<and>\n      attack ?A = ?s\\<rbrakk>\n  \\<Longrightarrow> attack ?A =\n                    attack (?as \\<oplus>\\<^sub>\\<or>\\<^bsup>?s\\<^esup>)\n\ngoal (2 subgoals):\n 1. \\<And>A A' A''.\n       \\<lbrakk>A \\<sqsubseteq> A'; attack A = attack A';\n        A' \\<sqsubseteq> A''; attack A' = attack A''\\<rbrakk>\n       \\<Longrightarrow> attack A = attack A''\n 2. \\<And>A. attack A = attack A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A A' A''.\n       \\<lbrakk>A \\<sqsubseteq> A'; attack A = attack A';\n        A' \\<sqsubseteq> A''; attack A' = attack A''\\<rbrakk>\n       \\<Longrightarrow> attack A = attack A''\n 2. \\<And>A. attack A = attack A", "show \"\\<And>(A::'a attree) (A'::'a attree) A''::'a attree.\n       A \\<sqsubseteq> A' \\<Longrightarrow> attack A = attack A' \\<Longrightarrow> A' \\<sqsubseteq> A'' \\<Longrightarrow> attack A' = attack A'' \\<Longrightarrow> attack A = attack A''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A A' A''.\n       \\<lbrakk>A \\<sqsubseteq> A'; attack A = attack A';\n        A' \\<sqsubseteq> A''; attack A' = attack A''\\<rbrakk>\n       \\<Longrightarrow> attack A = attack A''", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?A \\<sqsubseteq> ?A'; attack ?A = attack ?A';\n   ?A' \\<sqsubseteq> ?A''; attack ?A' = attack ?A''\\<rbrakk>\n  \\<Longrightarrow> attack ?A = attack ?A''\n\ngoal (1 subgoal):\n 1. \\<And>A. attack A = attack A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A. attack A = attack A", "show \"\\<And>A::'a attree. attack A = attack A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. attack A = attack A", "by (rule refl)"], ["proof (state)\nthis:\n  attack ?A = attack ?A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  base_subset: \n    assumes \"xa \\<subseteq> xc\"\n    shows  \"\\<turnstile>\\<N>\\<^bsub>(x, xa)\\<^esub> \\<Longrightarrow> \\<turnstile>\\<N>\\<^bsub>(x, xc)\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<N>\\<^bsub>(x, xa)\\<^esub> \\<Longrightarrow>\n    \\<turnstile>\\<N>\\<^bsub>(x, xc)\\<^esub>", "proof (simp add: att_base)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>x.\n       \\<exists>xa\\<in>xa. x \\<rightarrow>\\<^sub>i xa \\<Longrightarrow>\n    \\<forall>x\\<in>x. \\<exists>xa\\<in>xc. x \\<rightarrow>\\<^sub>i xa", "show \" \\<forall>x::'a\\<in>x. \\<exists>xa::'a\\<in>xa. x \\<rightarrow>\\<^sub>i xa \\<Longrightarrow> \\<forall>x::'a\\<in>x. \\<exists>xa::'a\\<in>xc. x \\<rightarrow>\\<^sub>i xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>x.\n       \\<exists>xa\\<in>xa. x \\<rightarrow>\\<^sub>i xa \\<Longrightarrow>\n    \\<forall>x\\<in>x. \\<exists>xa\\<in>xc. x \\<rightarrow>\\<^sub>i xa", "by (meson assms in_mono)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>x.\n     \\<exists>xa\\<in>xa. x \\<rightarrow>\\<^sub>i xa \\<Longrightarrow>\n  \\<forall>x\\<in>x. \\<exists>xa\\<in>xc. x \\<rightarrow>\\<^sub>i xa\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Correctness Theorem\""], ["", "text \\<open>Proof with induction over the definition of EF using the main \nlemma @{text \\<open>att_elem_seq0\\<close>}. \n\nThere is also a second version of Correctness for valid refinements.\\<close>"], ["", "theorem AT_EF: assumes \" \\<turnstile> (A :: ('s :: state) attree)\"\n               and  \"attack A = (I,s)\"\n               shows \"Kripke {s :: ('s :: state). \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} (I :: ('s :: state)set)  \\<turnstile> EF s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n     I \\<turnstile> EF s", "proof (simp add:check_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. I \\<subseteq> {sa.\n                   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                   sa \\<in> EF s}", "show \"I \\<subseteq> {sa::('s :: state). (\\<exists>i::'s\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and> sa \\<in> EF s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> {sa.\n                   (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                   sa \\<in> EF s}", "proof (rule subsetI, rule CollectI, rule conjI, simp add: state_transition_refl_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       \\<exists>i\\<in>I.\n          (i, x) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*\n 2. \\<And>x. x \\<in> I \\<Longrightarrow> x \\<in> EF s", "show \"\\<And>x::'s. x \\<in> I \\<Longrightarrow> \\<exists>i::'s\\<in>I. (i, x) \\<in> {(x::'s, y::'s). x \\<rightarrow>\\<^sub>i y}\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       \\<exists>i\\<in>I.\n          (i, x) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*", "by (rule_tac x = x in bexI, simp)"], ["proof (state)\nthis:\n  ?x \\<in> I \\<Longrightarrow>\n  \\<exists>i\\<in>I.\n     (i, ?x) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> I \\<Longrightarrow> x \\<in> EF s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> I \\<Longrightarrow> x \\<in> EF s", "show \"\\<And>x::'s. x \\<in> I \\<Longrightarrow> x \\<in> EF s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> I \\<Longrightarrow> x \\<in> EF s", "using assms"], ["proof (prove)\nusing this:\n  \\<turnstile>A\n  attack A = (I, s)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> I \\<Longrightarrow> x \\<in> EF s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> I; \\<turnstile>A; attack A = (I, s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> EF s", "have a: \"\\<forall> x \\<in> I. \\<exists> y \\<in> s. x \\<rightarrow>\\<^sub>i* y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "using assms"], ["proof (prove)\nusing this:\n  \\<turnstile>A\n  attack A = (I, s)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<turnstile>A; attack A = (I, s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>I.\n                         \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "have \"\\<forall>x::'s\\<in>fst (attack A). \\<exists>y::'s. y \\<in> snd (attack A) \\<and> x \\<rightarrow>\\<^sub>i* y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>fst (attack A).\n       \\<exists>y. y \\<in> snd (attack A) \\<and> x \\<rightarrow>\\<^sub>i* y", "by (rule att_elem_seq0, rule assms)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>fst (attack A).\n     \\<exists>y. y \\<in> snd (attack A) \\<and> x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<turnstile>A; attack A = (I, s)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>I.\n                         \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "thus \" \\<forall>x::'s\\<in>I. \\<exists>y::'s\\<in>s. x \\<rightarrow>\\<^sub>i* y\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>fst (attack A).\n     \\<exists>y. y \\<in> snd (attack A) \\<and> x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>fst (attack A).\n     \\<exists>y. y \\<in> snd (attack A) \\<and> x \\<rightarrow>\\<^sub>i* y\n  \\<turnstile>A\n  attack A = (I, s)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> I; \\<turnstile>A; attack A = (I, s)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> EF s", "thus \"\\<And>x::'s. x \\<in> I \\<Longrightarrow> x \\<in> EF s\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> I \\<Longrightarrow> x \\<in> EF s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> I;\n        \\<forall>x\\<in>I.\n           \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> EF s", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> I;\n        \\<forall>x\\<in>I.\n           \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> EF s", "assume b: \"x \\<in> I\""], ["proof (state)\nthis:\n  x \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> I;\n        \\<forall>x\\<in>I.\n           \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> EF s", "have \"\\<exists>y::'s\\<in>s::('s :: state) set. x \\<rightarrow>\\<^sub>i* y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "by (rule_tac x = x and A = I in bspec, rule a, rule b)"], ["proof (state)\nthis:\n  \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> I;\n        \\<forall>x\\<in>I.\n           \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> EF s", "from this"], ["proof (chain)\npicking this:\n  \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "obtain y where \"y \\<in> s\" and \"x \\<rightarrow>\\<^sub>i* y\""], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> s; x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule bexE)"], ["proof (state)\nthis:\n  y \\<in> s\n  x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> I;\n        \\<forall>x\\<in>I.\n           \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> EF s", "thus \"x \\<in> EF s\""], ["proof (prove)\nusing this:\n  y \\<in> s\n  x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. x \\<in> EF s", "by (erule_tac f = s in EF_step_star)"], ["proof (state)\nthis:\n  x \\<in> EF s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> I \\<Longrightarrow> ?x \\<in> EF s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> I \\<Longrightarrow> ?x \\<in> EF s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  I \\<subseteq> {sa.\n                 (\\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* sa) \\<and>\n                 sa \\<in> EF s}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ATV_EF: \"\\<lbrakk> \\<turnstile>\\<^sub>V A; (I,s) = attack A \\<rbrakk> \\<Longrightarrow>\n (Kripke {s. \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s) } I  \\<turnstile> EF s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<turnstile>\\<^sub>V A; (I, s) = attack A\\<rbrakk>\n    \\<Longrightarrow> Kripke\n                       {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n                       I \\<turnstile> EF s", "by (metis (full_types) AT_EF ref_pres_att ref_validity_def valid_ref_def)"], ["", "subsection \"Completeness Theorem\""], ["", "text \\<open>This section contains the completeness direction, informally:\n\n@{text \\<open>\\<turnstile> EF s \\<Longrightarrow> \\<exists> A. \\<turnstile> A \\<and> attack A = (I,s)\\<close>}.\n\nThe main theorem is presented last since its\nproof just summarises a number of main lemmas @{text \\<open>Compl_step1, Compl_step2,\nCompl_step3, Compl_step4\\<close>} which are presented first together with other\nauxiliary lemmas.\\<close>"], ["", "subsubsection \"Lemma @{text \\<open>Compl_step1\\<close>}\""], ["", "lemma Compl_step1: \n\"Kripke {s :: ('s :: state). \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} I  \\<turnstile> EF s \n\\<Longrightarrow> \\<forall> x \\<in> I. \\<exists> y \\<in> s. x \\<rightarrow>\\<^sub>i* y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n     I \\<turnstile> EF s \\<Longrightarrow>\n    \\<forall>x\\<in>I. \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y", "by (simp add: EF_step_star_rev valEF_E)"], ["", "subsubsection \"Lemma @{text \\<open>Compl_step2\\<close>}\""], ["", "text \\<open>First, we prove some auxiliary lemmas.\\<close>"], ["", "lemma rtrancl_imp_singleton_seq2: \"x \\<rightarrow>\\<^sub>i* y \\<Longrightarrow> \n          x = y \\<or> (\\<exists> s. s \\<noteq> [] \\<and> (tl s \\<noteq> []) \\<and> s ! 0 = x \\<and> s ! (length s - 1) = y \\<and> \n               (\\<forall> i < (length s - 1). (s ! i) \\<rightarrow>\\<^sub>i (s ! (Suc i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<rightarrow>\\<^sub>i* y \\<Longrightarrow>\n    x = y \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = y \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "unfolding state_transition_refl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>* \\<Longrightarrow>\n    x = y \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = y \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "proof (induction rule: rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = x \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = x \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n        (y, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n        x = y \\<or>\n        (\\<exists>s.\n            s \\<noteq> [] \\<and>\n            tl s \\<noteq> [] \\<and>\n            s ! 0 = x \\<and>\n            s ! (length s - 1) = y \\<and>\n            (\\<forall>i<length s - 1.\n                s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. x = x \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = x \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n        (y, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n        x = y \\<or>\n        (\\<exists>s.\n            s \\<noteq> [] \\<and>\n            tl s \\<noteq> [] \\<and>\n            s ! 0 = x \\<and>\n            s ! (length s - 1) = y \\<and>\n            (\\<forall>i<length s - 1.\n                s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = x \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "by simp"], ["proof (state)\nthis:\n  x = x \\<or>\n  (\\<exists>s.\n      s \\<noteq> [] \\<and>\n      tl s \\<noteq> [] \\<and>\n      s ! 0 = x \\<and>\n      s ! (length s - 1) = x \\<and>\n      (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n        (y, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n        x = y \\<or>\n        (\\<exists>s.\n            s \\<noteq> [] \\<and>\n            tl s \\<noteq> [] \\<and>\n            s ! 0 = x \\<and>\n            s ! (length s - 1) = y \\<and>\n            (\\<forall>i<length s - 1.\n                s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n        (y, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n        x = y \\<or>\n        (\\<exists>s.\n            s \\<noteq> [] \\<and>\n            tl s \\<noteq> [] \\<and>\n            s ! 0 = x \\<and>\n            s ! (length s - 1) = y \\<and>\n            (\\<forall>i<length s - 1.\n                s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "case (step y z)"], ["proof (state)\nthis:\n  (x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*\n  (y, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\n  x = y \\<or>\n  (\\<exists>s.\n      s \\<noteq> [] \\<and>\n      tl s \\<noteq> [] \\<and>\n      s ! 0 = x \\<and>\n      s ! (length s - 1) = y \\<and>\n      (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*;\n        (y, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y};\n        x = y \\<or>\n        (\\<exists>s.\n            s \\<noteq> [] \\<and>\n            tl s \\<noteq> [] \\<and>\n            s ! 0 = x \\<and>\n            s ! (length s - 1) = y \\<and>\n            (\\<forall>i<length s - 1.\n                s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = z \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = z \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "using step.IH"], ["proof (prove)\nusing this:\n  x = y \\<or>\n  (\\<exists>s.\n      s \\<noteq> [] \\<and>\n      tl s \\<noteq> [] \\<and>\n      s ! 0 = x \\<and>\n      s ! (length s - 1) = y \\<and>\n      (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n\ngoal (1 subgoal):\n 1. x = z \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = z \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "proof (elim disjE exE conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    x = z \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = z \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n 2. \\<And>s.\n       \\<lbrakk>s \\<noteq> []; tl s \\<noteq> []; s ! 0 = x;\n        s ! (length s - 1) = y;\n        \\<forall>i<length s - 1.\n           s ! i \\<rightarrow>\\<^sub>i s ! Suc i\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "assume \"x=y\""], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    x = z \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = z \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n 2. \\<And>s.\n       \\<lbrakk>s \\<noteq> []; tl s \\<noteq> []; s ! 0 = x;\n        s ! (length s - 1) = y;\n        \\<forall>i<length s - 1.\n           s ! i \\<rightarrow>\\<^sub>i s ! Suc i\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "with step.hyps"], ["proof (chain)\npicking this:\n  (x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*\n  (y, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\n  x = y", "show ?case"], ["proof (prove)\nusing this:\n  (x, y) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\\<^sup>*\n  (y, z) \\<in> {(x, y). x \\<rightarrow>\\<^sub>i y}\n  x = y\n\ngoal (1 subgoal):\n 1. x = z \\<or>\n    (\\<exists>s.\n        s \\<noteq> [] \\<and>\n        tl s \\<noteq> [] \\<and>\n        s ! 0 = x \\<and>\n        s ! (length s - 1) = z \\<and>\n        (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "by (force intro!: exI [where x=\"[y,z]\"])"], ["proof (state)\nthis:\n  x = z \\<or>\n  (\\<exists>s.\n      s \\<noteq> [] \\<and>\n      tl s \\<noteq> [] \\<and>\n      s ! 0 = x \\<and>\n      s ! (length s - 1) = z \\<and>\n      (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<noteq> []; tl s \\<noteq> []; s ! 0 = x;\n        s ! (length s - 1) = y;\n        \\<forall>i<length s - 1.\n           s ! i \\<rightarrow>\\<^sub>i s ! Suc i\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<noteq> []; tl s \\<noteq> []; s ! 0 = x;\n        s ! (length s - 1) = y;\n        \\<forall>i<length s - 1.\n           s ! i \\<rightarrow>\\<^sub>i s ! Suc i\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "show \"\\<And>s. \\<lbrakk>s \\<noteq> []; tl s \\<noteq> []; s ! 0 = x;\n          s ! (length s - 1) = y;\n          \\<forall>i<length s - 1.\n             s ! i \\<rightarrow>\\<^sub>i s ! Suc i\\<rbrakk>\n         \\<Longrightarrow> x = z \\<or>\n             (\\<exists>s. s \\<noteq> [] \\<and>\n                  tl s \\<noteq> [] \\<and> s ! 0 = x \\<and>\n                  s ! (length s - 1) = z \\<and>\n                  (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<noteq> []; tl s \\<noteq> []; s ! 0 = x;\n        s ! (length s - 1) = y;\n        \\<forall>i<length s - 1.\n           s ! i \\<rightarrow>\\<^sub>i s ! Suc i\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or>\n                         (\\<exists>s.\n                             s \\<noteq> [] \\<and>\n                             tl s \\<noteq> [] \\<and>\n                             s ! 0 = x \\<and>\n                             s ! (length s - 1) = z \\<and>\n                             (\\<forall>i<length s - 1.\n                                 s ! i \\<rightarrow>\\<^sub>i s ! Suc i))", "apply (rule disjI2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<noteq> []; tl s \\<noteq> []; s ! 0 = x;\n        s ! (length s - 1) = y;\n        \\<forall>i<length s - 1.\n           s ! i \\<rightarrow>\\<^sub>i s ! Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            s \\<noteq> [] \\<and>\n                            tl s \\<noteq> [] \\<and>\n                            s ! 0 = x \\<and>\n                            s ! (length s - 1) = z \\<and>\n                            (\\<forall>i<length s - 1.\n                                s ! i \\<rightarrow>\\<^sub>i s ! Suc i)", "apply (rule_tac x=\"s @ [z]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<noteq> []; tl s \\<noteq> []; s ! 0 = x;\n        s ! (length s - 1) = y;\n        \\<forall>i<length s - 1.\n           s ! i \\<rightarrow>\\<^sub>i s ! Suc i\\<rbrakk>\n       \\<Longrightarrow> s @ [z] \\<noteq> [] \\<and>\n                         tl (s @ [z]) \\<noteq> [] \\<and>\n                         (s @ [z]) ! 0 = x \\<and>\n                         (s @ [z]) ! (length (s @ [z]) - 1) = z \\<and>\n                         (\\<forall>i<length (s @ [z]) - 1.\n                             (s @ [z]) ! i \\<rightarrow>\\<^sub>i\n                             (s @ [z]) ! Suc i)", "apply (auto simp: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       \\<lbrakk>s \\<noteq> []; tl s \\<noteq> [];\n        \\<forall>i<length s - Suc 0. s ! i \\<rightarrow>\\<^sub>i s ! Suc i;\n        x = s ! 0; y = s ! (length s - Suc 0); \\<not> Suc i < length s;\n        i < length s\\<rbrakk>\n       \\<Longrightarrow> s ! i \\<rightarrow>\\<^sub>i z", "by (metis One_nat_def Suc_lessI diff_Suc_1 mem_Collect_eq old.prod.case step.hyps(2))"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<noteq> []; tl ?s \\<noteq> []; ?s ! 0 = x;\n   ?s ! (length ?s - 1) = y;\n   \\<forall>i<length ?s - 1.\n      ?s ! i \\<rightarrow>\\<^sub>i ?s ! Suc i\\<rbrakk>\n  \\<Longrightarrow> x = z \\<or>\n                    (\\<exists>s.\n                        s \\<noteq> [] \\<and>\n                        tl s \\<noteq> [] \\<and>\n                        s ! 0 = x \\<and>\n                        s ! (length s - 1) = z \\<and>\n                        (\\<forall>i<length s - 1.\n                            s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = z \\<or>\n  (\\<exists>s.\n      s \\<noteq> [] \\<and>\n      tl s \\<noteq> [] \\<and>\n      s ! 0 = x \\<and>\n      s ! (length s - 1) = z \\<and>\n      (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tl_nempty_length[rule_format]: \"s \\<noteq> [] \\<longrightarrow> tl s \\<noteq> [] \\<longrightarrow> 0 < length s - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<longrightarrow>\n    tl s \\<noteq> [] \\<longrightarrow> 0 < length s - 1", "by (induction s, simp+)"], ["", "lemma tl_nempty_length2[rule_format]: \"s \\<noteq> [] \\<longrightarrow> tl s \\<noteq> [] \\<longrightarrow> Suc 0 < length s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<noteq> [] \\<longrightarrow>\n    tl s \\<noteq> [] \\<longrightarrow> Suc 0 < length s", "by (induction s, simp+)"], ["", "lemma length_last[rule_format]: \"(l @ [x]) ! (length (l @ [x]) - 1) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l @ [x]) ! (length (l @ [x]) - 1) = x", "by (induction l, simp+)"], ["", "lemma Compl_step2: \"\\<forall> x \\<in> I. \\<exists> y \\<in> s. x \\<rightarrow>\\<^sub>i* y \\<Longrightarrow> \n                   ( \\<forall> x \\<in> I.  x \\<in> s \\<or> (\\<exists> (sl :: ((('s :: state) set)list)). \n                  (sl \\<noteq> []) \\<and> (tl sl \\<noteq> []) \\<and>\n                 (sl ! 0, sl ! (length sl - 1)) = ({x},s) \\<and>\n                 (\\<forall> i < (length sl - 1).  \\<turnstile> \\<N>\\<^bsub>(sl ! i,sl ! (i+1) )\\<^esub>\n                         )))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I.\n       \\<exists>y\\<in>s. x \\<rightarrow>\\<^sub>i* y \\<Longrightarrow>\n    \\<forall>x\\<in>I.\n       x \\<in> s \\<or>\n       (\\<exists>sl.\n           sl \\<noteq> [] \\<and>\n           tl sl \\<noteq> [] \\<and>\n           (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n           (\\<forall>i<length sl - 1.\n               \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))", "proof (rule ballI, drule_tac x = x in bspec, assumption, erule bexE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> s; x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> s \\<or>\n                         (\\<exists>sl.\n                             sl \\<noteq> [] \\<and>\n                             tl sl \\<noteq> [] \\<and>\n                             (sl ! 0, sl ! (length sl - 1)) =\n                             ({x}, s) \\<and>\n                             (\\<forall>i<length sl - 1.\n                                 \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n                    sl ! (i + 1))\\<^esub>))", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> s; x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> s \\<or>\n                         (\\<exists>sl.\n                             sl \\<noteq> [] \\<and>\n                             tl sl \\<noteq> [] \\<and>\n                             (sl ! 0, sl ! (length sl - 1)) =\n                             ({x}, s) \\<and>\n                             (\\<forall>i<length sl - 1.\n                                 \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n                    sl ! (i + 1))\\<^esub>))", "assume a: \"x \\<in> I\" and b: \"y \\<in> s\" and  c: \"x \\<rightarrow>\\<^sub>i* y\""], ["proof (state)\nthis:\n  x \\<in> I\n  y \\<in> s\n  x \\<rightarrow>\\<^sub>i* y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> s; x \\<rightarrow>\\<^sub>i* y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> s \\<or>\n                         (\\<exists>sl.\n                             sl \\<noteq> [] \\<and>\n                             tl sl \\<noteq> [] \\<and>\n                             (sl ! 0, sl ! (length sl - 1)) =\n                             ({x}, s) \\<and>\n                             (\\<forall>i<length sl - 1.\n                                 \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n                    sl ! (i + 1))\\<^esub>))", "show \"x \\<in> s \\<or>\n       (\\<exists>sl::'s set list.\n           sl \\<noteq> [] \\<and>\n           tl sl \\<noteq> [] \\<and>\n           (sl ! (0), sl ! (length sl - (1))) = ({x}, s) \\<and>\n           (\\<forall>i<length sl - (1). \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + (1)))\\<^esub>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> s \\<or>\n    (\\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> s \\<or>\n    (\\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))", "have d : \"x = y \\<or>\n       (\\<exists>s'. s' \\<noteq> [] \\<and>\n           tl s' \\<noteq> [] \\<and>\n           s' ! (0) = x \\<and>\n           s' ! (length s' - (1)) = y \\<and> (\\<forall>i<length s' - (1). s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<or>\n    (\\<exists>s'.\n        s' \\<noteq> [] \\<and>\n        tl s' \\<noteq> [] \\<and>\n        s' ! 0 = x \\<and>\n        s' ! (length s' - 1) = y \\<and>\n        (\\<forall>i<length s' - 1. s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i))", "using c rtrancl_imp_singleton_seq2"], ["proof (prove)\nusing this:\n  x \\<rightarrow>\\<^sub>i* y\n  ?x \\<rightarrow>\\<^sub>i* ?y \\<Longrightarrow>\n  ?x = ?y \\<or>\n  (\\<exists>s.\n      s \\<noteq> [] \\<and>\n      tl s \\<noteq> [] \\<and>\n      s ! 0 = ?x \\<and>\n      s ! (length s - 1) = ?y \\<and>\n      (\\<forall>i<length s - 1. s ! i \\<rightarrow>\\<^sub>i s ! Suc i))\n\ngoal (1 subgoal):\n 1. x = y \\<or>\n    (\\<exists>s'.\n        s' \\<noteq> [] \\<and>\n        tl s' \\<noteq> [] \\<and>\n        s' ! 0 = x \\<and>\n        s' ! (length s' - 1) = y \\<and>\n        (\\<forall>i<length s' - 1. s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i))", "by blast"], ["proof (state)\nthis:\n  x = y \\<or>\n  (\\<exists>s'.\n      s' \\<noteq> [] \\<and>\n      tl s' \\<noteq> [] \\<and>\n      s' ! 0 = x \\<and>\n      s' ! (length s' - 1) = y \\<and>\n      (\\<forall>i<length s' - 1. s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i))\n\ngoal (1 subgoal):\n 1. x \\<in> s \\<or>\n    (\\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))", "thus \"x \\<in> s \\<or>\n       (\\<exists>sl::'s set list.\n           sl \\<noteq> [] \\<and>\n           tl sl \\<noteq> [] \\<and>\n           (sl ! (0), sl ! (length sl - (1))) = ({x}, s) \\<and>\n           (\\<forall>i<length sl - (1). \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + (1)))\\<^esub>))\""], ["proof (prove)\nusing this:\n  x = y \\<or>\n  (\\<exists>s'.\n      s' \\<noteq> [] \\<and>\n      tl s' \\<noteq> [] \\<and>\n      s' ! 0 = x \\<and>\n      s' ! (length s' - 1) = y \\<and>\n      (\\<forall>i<length s' - 1. s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i))\n\ngoal (1 subgoal):\n 1. x \\<in> s \\<or>\n    (\\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))", "apply (rule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    x \\<in> s \\<or>\n    (\\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))\n 2. \\<exists>s'.\n       s' \\<noteq> [] \\<and>\n       tl s' \\<noteq> [] \\<and>\n       s' ! 0 = x \\<and>\n       s' ! (length s' - 1) = y \\<and>\n       (\\<forall>i<length s' - 1.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i) \\<Longrightarrow>\n    x \\<in> s \\<or>\n    (\\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))", "using b"], ["proof (prove)\nusing this:\n  y \\<in> s\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow>\n    x \\<in> s \\<or>\n    (\\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))\n 2. \\<exists>s'.\n       s' \\<noteq> [] \\<and>\n       tl s' \\<noteq> [] \\<and>\n       s' ! 0 = x \\<and>\n       s' ! (length s' - 1) = y \\<and>\n       (\\<forall>i<length s' - 1.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i) \\<Longrightarrow>\n    x \\<in> s \\<or>\n    (\\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       s' \\<noteq> [] \\<and>\n       tl s' \\<noteq> [] \\<and>\n       s' ! 0 = x \\<and>\n       s' ! (length s' - 1) = y \\<and>\n       (\\<forall>i<length s' - 1.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i) \\<Longrightarrow>\n    x \\<in> s \\<or>\n    (\\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))", "apply (rule disjI2, elim conjE exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>s' \\<noteq> []; tl s' \\<noteq> []; s' ! 0 = x;\n        s' ! (length s' - 1) = y;\n        \\<forall>i<length s' - 1.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl.\n                            sl \\<noteq> [] \\<and>\n                            tl sl \\<noteq> [] \\<and>\n                            (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                            (\\<forall>i<length sl - 1.\n                                \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n                   sl ! (i + 1))\\<^esub>)", "apply (rule_tac x = \"[{s' ! j}. j \\<leftarrow> [0..<(length s' - 1)]] @ [s]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>s' \\<noteq> []; tl s' \\<noteq> []; s' ! 0 = x;\n        s' ! (length s' - 1) = y;\n        \\<forall>i<length s' - 1.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>j. {s' ! j}) [0..<length s' - 1] @\n                         [s] \\<noteq>\n                         [] \\<and>\n                         tl (map (\\<lambda>j. {s' ! j})\n                              [0..<length s' - 1] @\n                             [s]) \\<noteq>\n                         [] \\<and>\n                         ((map (\\<lambda>j. {s' ! j}) [0..<length s' - 1] @\n                           [s]) !\n                          0,\n                          (map (\\<lambda>j. {s' ! j}) [0..<length s' - 1] @\n                           [s]) !\n                          (length\n                            (map (\\<lambda>j. {s' ! j})\n                              [0..<length s' - 1] @\n                             [s]) -\n                           1)) =\n                         ({x}, s) \\<and>\n                         (\\<forall>i<length\n(map (\\<lambda>j. {s' ! j}) [0..<length s' - 1] @ [s]) -\n                                     1.\n                             \\<turnstile>\\<N>\\<^bsub>((map\n                  (\\<lambda>j. {s' ! j}) [0..<length s' - 1] @\n                 [s]) !\n                i,\n                (map (\\<lambda>j. {s' ! j}) [0..<length s' - 1] @ [s]) !\n                (i + 1))\\<^esub>)", "apply (auto simp: nth_append)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s' i.\n       \\<lbrakk>s' \\<noteq> []; tl s' \\<noteq> [];\n        \\<forall>i<length s' - Suc 0.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i;\n        x = s' ! 0; y = s' ! (length s' - Suc 0); Suc 0 < length s';\n        Suc i < length s' - Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<N>\\<^bsub>({s' ! i},\n            {s' ! Suc i})\\<^esub>\n 2. \\<And>s' i.\n       \\<lbrakk>s' \\<noteq> []; tl s' \\<noteq> [];\n        \\<forall>i<length s' - Suc 0.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i;\n        x = s' ! 0; y = s' ! (length s' - Suc 0); Suc 0 < length s';\n        \\<not> Suc i < length s' - Suc 0; i < length s' - Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<N>\\<^bsub>({s' ! i}, s)\\<^esub>\n 3. \\<And>s'.\n       \\<lbrakk>s' \\<noteq> []; tl s' \\<noteq> [];\n        \\<forall>i<length s' - Suc 0.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i;\n        x = s' ! 0; y = s' ! (length s' - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 < length s'", "apply (metis AT.att_base Suc_lessD fst_conv prod.sel(2) singletonD singletonI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s' i.\n       \\<lbrakk>s' \\<noteq> []; tl s' \\<noteq> [];\n        \\<forall>i<length s' - Suc 0.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i;\n        x = s' ! 0; y = s' ! (length s' - Suc 0); Suc 0 < length s';\n        \\<not> Suc i < length s' - Suc 0; i < length s' - Suc 0\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>\\<N>\\<^bsub>({s' ! i}, s)\\<^esub>\n 2. \\<And>s'.\n       \\<lbrakk>s' \\<noteq> []; tl s' \\<noteq> [];\n        \\<forall>i<length s' - Suc 0.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i;\n        x = s' ! 0; y = s' ! (length s' - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 < length s'", "apply (metis AT.att_base Suc_lessI b fst_conv prod.sel(2) singletonD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>s' \\<noteq> []; tl s' \\<noteq> [];\n        \\<forall>i<length s' - Suc 0.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i;\n        x = s' ! 0; y = s' ! (length s' - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 < length s'", "using tl_nempty_length2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<noteq> []; tl ?s \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> Suc 0 < length ?s\n\ngoal (1 subgoal):\n 1. \\<And>s'.\n       \\<lbrakk>s' \\<noteq> []; tl s' \\<noteq> [];\n        \\<forall>i<length s' - Suc 0.\n           s' ! i \\<rightarrow>\\<^sub>i s' ! Suc i;\n        x = s' ! 0; y = s' ! (length s' - Suc 0)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 < length s'", "by blast"], ["proof (state)\nthis:\n  x \\<in> s \\<or>\n  (\\<exists>sl.\n      sl \\<noteq> [] \\<and>\n      tl sl \\<noteq> [] \\<and>\n      (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n      (\\<forall>i<length sl - 1.\n          \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> s \\<or>\n  (\\<exists>sl.\n      sl \\<noteq> [] \\<and>\n      tl sl \\<noteq> [] \\<and>\n      (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n      (\\<forall>i<length sl - 1.\n          \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Lemma @{text \\<open>Compl_step3\\<close>}\""], ["", "text \\<open>First, we need a few lemmas.\\<close>"], ["", "lemma map_hd_lem[rule_format] : \"n > 0 \\<longrightarrow> (f 0 #  map (\\<lambda>i. f i) [1..<n]) = map  (\\<lambda>i. f i) [0..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> f 0 # map f [1..<n] = map f [0..<n]", "by (simp add : hd_map upt_rec)"], ["", "lemma map_Suc_lem[rule_format] : \"n > 0 \\<longrightarrow> map (\\<lambda> i:: nat. f i)[1..<n] =\n                                  map (\\<lambda> i:: nat. f(Suc i))[0..<(n - 1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow>\n    map f [1..<n] = map (\\<lambda>i. f (Suc i)) [0..<n - 1]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow>\n    map f [1..<n] = map (\\<lambda>i. f (Suc i)) [0..<n - 1]", "have \"(f 0 # map (\\<lambda>n. f (Suc n)) [0..<n - 1] = f 0 # map f [1..<n]) = (map (\\<lambda>n. f (Suc n)) [0..<n - 1] = map f [1..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f 0 # map (\\<lambda>n. f (Suc n)) [0..<n - 1] = f 0 # map f [1..<n]) =\n    (map (\\<lambda>n. f (Suc n)) [0..<n - 1] = map f [1..<n])", "by blast"], ["proof (state)\nthis:\n  (f 0 # map (\\<lambda>n. f (Suc n)) [0..<n - 1] = f 0 # map f [1..<n]) =\n  (map (\\<lambda>n. f (Suc n)) [0..<n - 1] = map f [1..<n])\n\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow>\n    map f [1..<n] = map (\\<lambda>i. f (Suc i)) [0..<n - 1]", "then"], ["proof (chain)\npicking this:\n  (f 0 # map (\\<lambda>n. f (Suc n)) [0..<n - 1] = f 0 # map f [1..<n]) =\n  (map (\\<lambda>n. f (Suc n)) [0..<n - 1] = map f [1..<n])", "show ?thesis"], ["proof (prove)\nusing this:\n  (f 0 # map (\\<lambda>n. f (Suc n)) [0..<n - 1] = f 0 # map f [1..<n]) =\n  (map (\\<lambda>n. f (Suc n)) [0..<n - 1] = map f [1..<n])\n\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow>\n    map f [1..<n] = map (\\<lambda>i. f (Suc i)) [0..<n - 1]", "by (metis Suc_pred' map_hd_lem map_upt_Suc)"], ["proof (state)\nthis:\n  0 < n \\<longrightarrow>\n  map f [1..<n] = map (\\<lambda>i. f (Suc i)) [0..<n - 1]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma forall_ex_fun: \"finite S \\<Longrightarrow> (\\<forall> x \\<in> S. (\\<exists> y. P y x)) \\<longrightarrow> (\\<exists> f. \\<forall> x \\<in> S. P (f x) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<Longrightarrow>\n    (\\<forall>x\\<in>S. \\<exists>y. P y x) \\<longrightarrow>\n    (\\<exists>f. \\<forall>x\\<in>S. P (f x) x)", "proof (induction rule: finite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<forall>x\\<in>{}. \\<exists>y. P y x) \\<longrightarrow>\n    (\\<exists>f. \\<forall>x\\<in>{}. P (f x) x)\n 2. \\<And>A a.\n       \\<lbrakk>finite A;\n        (\\<forall>x\\<in>A. \\<exists>y. P y x) \\<longrightarrow>\n        (\\<exists>f. \\<forall>x\\<in>A. P (f x) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>insert a A.\n                             \\<exists>y. P y x) \\<longrightarrow>\n                         (\\<exists>f. \\<forall>x\\<in>insert a A. P (f x) x)", "case emptyI"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<forall>x\\<in>{}. \\<exists>y. P y x) \\<longrightarrow>\n    (\\<exists>f. \\<forall>x\\<in>{}. P (f x) x)\n 2. \\<And>A a.\n       \\<lbrakk>finite A;\n        (\\<forall>x\\<in>A. \\<exists>y. P y x) \\<longrightarrow>\n        (\\<exists>f. \\<forall>x\\<in>A. P (f x) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>insert a A.\n                             \\<exists>y. P y x) \\<longrightarrow>\n                         (\\<exists>f. \\<forall>x\\<in>insert a A. P (f x) x)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{}. \\<exists>y. P y x) \\<longrightarrow>\n    (\\<exists>f. \\<forall>x\\<in>{}. P (f x) x)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>{}. \\<exists>y. P y x) \\<longrightarrow>\n  (\\<exists>f. \\<forall>x\\<in>{}. P (f x) x)\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        (\\<forall>x\\<in>A. \\<exists>y. P y x) \\<longrightarrow>\n        (\\<exists>f. \\<forall>x\\<in>A. P (f x) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>insert a A.\n                             \\<exists>y. P y x) \\<longrightarrow>\n                         (\\<exists>f. \\<forall>x\\<in>insert a A. P (f x) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        (\\<forall>x\\<in>A. \\<exists>y. P y x) \\<longrightarrow>\n        (\\<exists>f. \\<forall>x\\<in>A. P (f x) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>insert a A.\n                             \\<exists>y. P y x) \\<longrightarrow>\n                         (\\<exists>f. \\<forall>x\\<in>insert a A. P (f x) x)", "case (insertI F x)"], ["proof (state)\nthis:\n  finite F\n  (\\<forall>x\\<in>F. \\<exists>y. P y x) \\<longrightarrow>\n  (\\<exists>f. \\<forall>x\\<in>F. P (f x) x)\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        (\\<forall>x\\<in>A. \\<exists>y. P y x) \\<longrightarrow>\n        (\\<exists>f. \\<forall>x\\<in>A. P (f x) x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>insert a A.\n                             \\<exists>y. P y x) \\<longrightarrow>\n                         (\\<exists>f. \\<forall>x\\<in>insert a A. P (f x) x)", "then"], ["proof (chain)\npicking this:\n  finite F\n  (\\<forall>x\\<in>F. \\<exists>y. P y x) \\<longrightarrow>\n  (\\<exists>f. \\<forall>x\\<in>F. P (f x) x)", "show ?case"], ["proof (prove)\nusing this:\n  finite F\n  (\\<forall>x\\<in>F. \\<exists>y. P y x) \\<longrightarrow>\n  (\\<exists>f. \\<forall>x\\<in>F. P (f x) x)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>insert x F. \\<exists>y. P y x) \\<longrightarrow>\n    (\\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x)", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F;\n     (\\<forall>x\\<in>F. \\<exists>y. P y x) \\<longrightarrow>\n     (\\<exists>f. \\<forall>x\\<in>F. P (f x) x);\n     \\<forall>x\\<in>insert x F. \\<exists>y. P y x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x", "assume d: \"(\\<forall>x::'a\\<in>insert x F. \\<exists>y::'b. P y x)\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>insert x F. \\<exists>y. P y x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F;\n     (\\<forall>x\\<in>F. \\<exists>y. P y x) \\<longrightarrow>\n     (\\<exists>f. \\<forall>x\\<in>F. P (f x) x);\n     \\<forall>x\\<in>insert x F. \\<exists>y. P y x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x", "have \"(\\<forall>x::'a\\<in>F. \\<exists>y::'b. P y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>F. \\<exists>y. P y x", "using d"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>insert x F. \\<exists>y. P y x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>F. \\<exists>y. P y x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>F. \\<exists>y. P y x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F;\n     (\\<forall>x\\<in>F. \\<exists>y. P y x) \\<longrightarrow>\n     (\\<exists>f. \\<forall>x\\<in>F. P (f x) x);\n     \\<forall>x\\<in>insert x F. \\<exists>y. P y x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>F. \\<exists>y. P y x", "obtain f where f: \"\\<forall>x::'a\\<in>F. P (f x) x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>F. \\<exists>y. P y x\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>x\\<in>F. P (f x) x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using insertI.IH"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>F. \\<exists>y. P y x\n  (\\<forall>x\\<in>F. \\<exists>y. P y x) \\<longrightarrow>\n  (\\<exists>f. \\<forall>x\\<in>F. P (f x) x)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>x\\<in>F. P (f x) x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>F. P (f x) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F;\n     (\\<forall>x\\<in>F. \\<exists>y. P y x) \\<longrightarrow>\n     (\\<exists>f. \\<forall>x\\<in>F. P (f x) x);\n     \\<forall>x\\<in>insert x F. \\<exists>y. P y x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x", "from d"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>insert x F. \\<exists>y. P y x", "obtain y where \"P y x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>insert x F. \\<exists>y. P y x\n\ngoal (1 subgoal):\n 1. (\\<And>y. P y x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  P y x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite F;\n     (\\<forall>x\\<in>F. \\<exists>y. P y x) \\<longrightarrow>\n     (\\<exists>f. \\<forall>x\\<in>F. P (f x) x);\n     \\<forall>x\\<in>insert x F. \\<exists>y. P y x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x", "thus \"(\\<exists>f::'a \\<Rightarrow> 'b. \\<forall>x::'a\\<in>insert x F. P (f x) x)\""], ["proof (prove)\nusing this:\n  P y x\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x", "using f"], ["proof (prove)\nusing this:\n  P y x\n  \\<forall>x\\<in>F. P (f x) x\n\ngoal (1 subgoal):\n 1. \\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x", "by (rule_tac x = \"\\<lambda> z. if z = x then y else f z\" in exI, simp)"], ["proof (state)\nthis:\n  \\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>insert x F. \\<exists>y. P y x) \\<longrightarrow>\n  (\\<exists>f. \\<forall>x\\<in>insert x F. P (f x) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec nodup :: \"['a, 'a list] \\<Rightarrow> bool\"\n  where \n    nodup_nil: \"nodup a [] = True\" |\n    nodup_step: \"nodup a (x # ls) = (if x = a then (a \\<notin> (set ls)) else nodup a ls)\""], ["", "definition nodup_all:: \"'a list \\<Rightarrow> bool\"\n  where\n    \"nodup_all l \\<equiv> \\<forall> x \\<in> set l. nodup x l\""], ["", "lemma nodup_all_lem[rule_format]: \n  \"nodup_all (x1 # a # l) \\<longrightarrow> (insert x1 (insert a (set l)) - {x1}) = insert a (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodup_all (x1 # a # l) \\<longrightarrow>\n    insert x1 (insert a (set l)) - {x1} = insert a (set l)", "by (induction l, (simp add: nodup_all_def)+)"], ["", "lemma nodup_all_tl[rule_format]: \"nodup_all (x # l) \\<longrightarrow> nodup_all l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodup_all (x # l) \\<longrightarrow> nodup_all l", "by (induction l, (simp add: nodup_all_def)+)"], ["", "lemma finite_nodup: \"finite I \\<Longrightarrow> \\<exists> l. set l = I \\<and> nodup_all l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I \\<Longrightarrow> \\<exists>l. set l = I \\<and> nodup_all l", "proof (induction rule: finite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>l. set l = {} \\<and> nodup_all l\n 2. \\<And>A a.\n       \\<lbrakk>finite A; \\<exists>l. set l = A \\<and> nodup_all l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert a A \\<and> nodup_all l", "case emptyI"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>l. set l = {} \\<and> nodup_all l\n 2. \\<And>A a.\n       \\<lbrakk>finite A; \\<exists>l. set l = A \\<and> nodup_all l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert a A \\<and> nodup_all l", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. set l = {} \\<and> nodup_all l", "by (simp add: nodup_all_def)"], ["proof (state)\nthis:\n  \\<exists>l. set l = {} \\<and> nodup_all l\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A; \\<exists>l. set l = A \\<and> nodup_all l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert a A \\<and> nodup_all l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A; \\<exists>l. set l = A \\<and> nodup_all l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert a A \\<and> nodup_all l", "case (insertI A a)"], ["proof (state)\nthis:\n  finite A\n  \\<exists>l. set l = A \\<and> nodup_all l\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A; \\<exists>l. set l = A \\<and> nodup_all l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l. set l = insert a A \\<and> nodup_all l", "then"], ["proof (chain)\npicking this:\n  finite A\n  \\<exists>l. set l = A \\<and> nodup_all l", "show ?case"], ["proof (prove)\nusing this:\n  finite A\n  \\<exists>l. set l = A \\<and> nodup_all l\n\ngoal (1 subgoal):\n 1. \\<exists>l. set l = insert a A \\<and> nodup_all l", "by (metis insertE insert_absorb list.simps(15) nodup_all_def nodup_step)"], ["proof (state)\nthis:\n  \\<exists>l. set l = insert a A \\<and> nodup_all l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Compl_step3: \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow>\n     ( \\<forall> x \\<in> I.  x \\<in> s \\<or> (\\<exists> (sl :: ((('s :: state) set)list)). \n                  (sl \\<noteq> []) \\<and> (tl sl \\<noteq> []) \\<and>\n                 (sl ! 0, sl ! (length sl - 1)) = ({x},s) \\<and>\n                 (\\<forall> i < (length sl - 1).  \\<turnstile> \\<N>\\<^bsub>(sl ! i,sl ! (i+1) )\\<^esub>\n                         )) \\<Longrightarrow> \n     (\\<exists> lI. set lI = {x :: 's :: state. x \\<in> I \\<and> x \\<notin> s} \\<and> (\\<exists> Sj :: ((('s :: state) set)list) list. \n               length Sj = length lI \\<and> nodup_all lI \\<and>\n            (\\<forall> j < length Sj. (((Sj ! j)  \\<noteq> []) \\<and> (tl (Sj ! j) \\<noteq> []) \\<and>\n                 ((Sj ! j) ! 0, (Sj ! j) ! (length (Sj ! j) - 1)) = ({lI ! j},s) \\<and>\n                 (\\<forall> i < (length (Sj ! j) - 1).  \\<turnstile> \\<N>\\<^bsub>((Sj ! j) ! i, (Sj ! j) ! (i+1) )\\<^esub>\n                         ))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     \\<forall>x\\<in>I.\n        x \\<in> s \\<or>\n        (\\<exists>sl.\n            sl \\<noteq> [] \\<and>\n            tl sl \\<noteq> [] \\<and>\n            (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n            (\\<forall>i<length sl - 1.\n                \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n   sl ! (i + 1))\\<^esub>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lI.\n                         set lI = {x \\<in> I. x \\<notin> s} \\<and>\n                         (\\<exists>Sj.\n                             length Sj = length lI \\<and>\n                             nodup_all lI \\<and>\n                             (\\<forall>j<length Sj.\n                                 Sj ! j \\<noteq> [] \\<and>\n                                 tl (Sj ! j) \\<noteq> [] \\<and>\n                                 (Sj ! j ! 0,\n                                  Sj ! j ! (length (Sj ! j) - 1)) =\n                                 ({lI ! j}, s) \\<and>\n                                 (\\<forall>i<length (Sj ! j) - 1.\n                                     \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                        Sj ! j ! (i + 1))\\<^esub>)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     \\<forall>x\\<in>I.\n        x \\<in> s \\<or>\n        (\\<exists>sl.\n            sl \\<noteq> [] \\<and>\n            tl sl \\<noteq> [] \\<and>\n            (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n            (\\<forall>i<length sl - 1.\n                \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n   sl ! (i + 1))\\<^esub>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lI.\n                         set lI = {x \\<in> I. x \\<notin> s} \\<and>\n                         (\\<exists>Sj.\n                             length Sj = length lI \\<and>\n                             nodup_all lI \\<and>\n                             (\\<forall>j<length Sj.\n                                 Sj ! j \\<noteq> [] \\<and>\n                                 tl (Sj ! j) \\<noteq> [] \\<and>\n                                 (Sj ! j ! 0,\n                                  Sj ! j ! (length (Sj ! j) - 1)) =\n                                 ({lI ! j}, s) \\<and>\n                                 (\\<forall>i<length (Sj ! j) - 1.\n                                     \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                        Sj ! j ! (i + 1))\\<^esub>)))", "assume i: \"I \\<noteq> {}\" and f: \"finite I\" and\n      fa: \"\\<forall>x::'s\\<in>I.\n       x \\<in> s \\<or>\n       (\\<exists>sl::'s set list.\n           sl \\<noteq> [] \\<and>\n           tl sl \\<noteq> [] \\<and>\n           (sl ! (0), sl ! (length sl - (1))) = ({x}, s) \\<and>\n           (\\<forall>i<length sl - (1). \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + (1)))\\<^esub>))\""], ["proof (state)\nthis:\n  I \\<noteq> {}\n  finite I\n  \\<forall>x\\<in>I.\n     x \\<in> s \\<or>\n     (\\<exists>sl.\n         sl \\<noteq> [] \\<and>\n         tl sl \\<noteq> [] \\<and>\n         (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n         (\\<forall>i<length sl - 1.\n             \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     \\<forall>x\\<in>I.\n        x \\<in> s \\<or>\n        (\\<exists>sl.\n            sl \\<noteq> [] \\<and>\n            tl sl \\<noteq> [] \\<and>\n            (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n            (\\<forall>i<length sl - 1.\n                \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n   sl ! (i + 1))\\<^esub>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lI.\n                         set lI = {x \\<in> I. x \\<notin> s} \\<and>\n                         (\\<exists>Sj.\n                             length Sj = length lI \\<and>\n                             nodup_all lI \\<and>\n                             (\\<forall>j<length Sj.\n                                 Sj ! j \\<noteq> [] \\<and>\n                                 tl (Sj ! j) \\<noteq> [] \\<and>\n                                 (Sj ! j ! 0,\n                                  Sj ! j ! (length (Sj ! j) - 1)) =\n                                 ({lI ! j}, s) \\<and>\n                                 (\\<forall>i<length (Sj ! j) - 1.\n                                     \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                        Sj ! j ! (i + 1))\\<^esub>)))", "have a: \"\\<exists> lI. set lI = {x::'s \\<in> I. x \\<notin> s} \\<and> nodup_all lI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lI. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI", "by (simp add: f finite_nodup)"], ["proof (state)\nthis:\n  \\<exists>lI. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     \\<forall>x\\<in>I.\n        x \\<in> s \\<or>\n        (\\<exists>sl.\n            sl \\<noteq> [] \\<and>\n            tl sl \\<noteq> [] \\<and>\n            (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n            (\\<forall>i<length sl - 1.\n                \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n   sl ! (i + 1))\\<^esub>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lI.\n                         set lI = {x \\<in> I. x \\<notin> s} \\<and>\n                         (\\<exists>Sj.\n                             length Sj = length lI \\<and>\n                             nodup_all lI \\<and>\n                             (\\<forall>j<length Sj.\n                                 Sj ! j \\<noteq> [] \\<and>\n                                 tl (Sj ! j) \\<noteq> [] \\<and>\n                                 (Sj ! j ! 0,\n                                  Sj ! j ! (length (Sj ! j) - 1)) =\n                                 ({lI ! j}, s) \\<and>\n                                 (\\<forall>i<length (Sj ! j) - 1.\n                                     \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                        Sj ! j ! (i + 1))\\<^esub>)))", "from this"], ["proof (chain)\npicking this:\n  \\<exists>lI. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI", "obtain lI where b: \"set lI = {x::'s \\<in> I. x \\<notin> s} \\<and> nodup_all lI\""], ["proof (prove)\nusing this:\n  \\<exists>lI. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\n\ngoal (1 subgoal):\n 1. (\\<And>lI.\n        set lI = {x \\<in> I. x \\<notin> s} \\<and>\n        nodup_all lI \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (erule exE)"], ["proof (state)\nthis:\n  set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     \\<forall>x\\<in>I.\n        x \\<in> s \\<or>\n        (\\<exists>sl.\n            sl \\<noteq> [] \\<and>\n            tl sl \\<noteq> [] \\<and>\n            (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n            (\\<forall>i<length sl - 1.\n                \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n   sl ! (i + 1))\\<^esub>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lI.\n                         set lI = {x \\<in> I. x \\<notin> s} \\<and>\n                         (\\<exists>Sj.\n                             length Sj = length lI \\<and>\n                             nodup_all lI \\<and>\n                             (\\<forall>j<length Sj.\n                                 Sj ! j \\<noteq> [] \\<and>\n                                 tl (Sj ! j) \\<noteq> [] \\<and>\n                                 (Sj ! j ! 0,\n                                  Sj ! j ! (length (Sj ! j) - 1)) =\n                                 ({lI ! j}, s) \\<and>\n                                 (\\<forall>i<length (Sj ! j) - 1.\n                                     \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                        Sj ! j ! (i + 1))\\<^esub>)))", "thus \"\\<exists>lI::'s list.\n       set lI = {x::'s \\<in> I. x \\<notin> s} \\<and>\n       (\\<exists>Sj::'s set list list.\n           length Sj = length lI \\<and>\n           nodup_all lI \\<and>\n           (\\<forall>j<length Sj.\n               Sj ! j \\<noteq> [] \\<and>\n               tl (Sj ! j) \\<noteq> [] \\<and>\n               (Sj ! j ! (0), Sj ! j ! (length (Sj ! j) - (1))) = ({lI ! j}, s) \\<and>\n               (\\<forall>i<length (Sj ! j) - (1). \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! (i + (1)))\\<^esub>)))\""], ["proof (prove)\nusing this:\n  set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\n\ngoal (1 subgoal):\n 1. \\<exists>lI.\n       set lI = {x \\<in> I. x \\<notin> s} \\<and>\n       (\\<exists>Sj.\n           length Sj = length lI \\<and>\n           nodup_all lI \\<and>\n           (\\<forall>j<length Sj.\n               Sj ! j \\<noteq> [] \\<and>\n               tl (Sj ! j) \\<noteq> [] \\<and>\n               (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n               ({lI ! j}, s) \\<and>\n               (\\<forall>i<length (Sj ! j) - 1.\n                   \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n      Sj ! j ! (i + 1))\\<^esub>)))", "apply (rule_tac x = lI in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI \\<Longrightarrow>\n    set lI = {x \\<in> I. x \\<notin> s} \\<and>\n    (\\<exists>Sj.\n        length Sj = length lI \\<and>\n        nodup_all lI \\<and>\n        (\\<forall>j<length Sj.\n            Sj ! j \\<noteq> [] \\<and>\n            tl (Sj ! j) \\<noteq> [] \\<and>\n            (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n            ({lI ! j}, s) \\<and>\n            (\\<forall>i<length (Sj ! j) - 1.\n                \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n   Sj ! j ! (i + 1))\\<^esub>)))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI \\<Longrightarrow>\n    set lI = {x \\<in> I. x \\<notin> s}\n 2. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI \\<Longrightarrow>\n    \\<exists>Sj.\n       length Sj = length lI \\<and>\n       nodup_all lI \\<and>\n       (\\<forall>j<length Sj.\n           Sj ! j \\<noteq> [] \\<and>\n           tl (Sj ! j) \\<noteq> [] \\<and>\n           (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n           ({lI ! j}, s) \\<and>\n           (\\<forall>i<length (Sj ! j) - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n  Sj ! j ! (i + 1))\\<^esub>))", "apply (erule conjE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI \\<Longrightarrow>\n    \\<exists>Sj.\n       length Sj = length lI \\<and>\n       nodup_all lI \\<and>\n       (\\<forall>j<length Sj.\n           Sj ! j \\<noteq> [] \\<and>\n           tl (Sj ! j) \\<noteq> [] \\<and>\n           (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n           ({lI ! j}, s) \\<and>\n           (\\<forall>i<length (Sj ! j) - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n  Sj ! j ! (i + 1))\\<^esub>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI \\<Longrightarrow>\n    \\<exists>Sj.\n       length Sj = length lI \\<and>\n       nodup_all lI \\<and>\n       (\\<forall>j<length Sj.\n           Sj ! j \\<noteq> [] \\<and>\n           tl (Sj ! j) \\<noteq> [] \\<and>\n           (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n           ({lI ! j}, s) \\<and>\n           (\\<forall>i<length (Sj ! j) - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n  Sj ! j ! (i + 1))\\<^esub>))", "have c:  \"\\<forall> x \\<in> set(lI). (\\<exists> sl::'s set list.\n              sl \\<noteq> [] \\<and>\n              tl sl \\<noteq> [] \\<and>\n              (sl ! (0), sl ! (length sl - (1))) = ({x}, s) \\<and>\n              (\\<forall>i<length sl - (1). \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + (1)))\\<^esub>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>)", "using b fa"], ["proof (prove)\nusing this:\n  set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\n  \\<forall>x\\<in>I.\n     x \\<in> s \\<or>\n     (\\<exists>sl.\n         sl \\<noteq> [] \\<and>\n         tl sl \\<noteq> [] \\<and>\n         (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n         (\\<forall>i<length sl - 1.\n             \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set lI.\n     \\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>)\n\ngoal (1 subgoal):\n 1. set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI \\<Longrightarrow>\n    \\<exists>Sj.\n       length Sj = length lI \\<and>\n       nodup_all lI \\<and>\n       (\\<forall>j<length Sj.\n           Sj ! j \\<noteq> [] \\<and>\n           tl (Sj ! j) \\<noteq> [] \\<and>\n           (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n           ({lI ! j}, s) \\<and>\n           (\\<forall>i<length (Sj ! j) - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n  Sj ! j ! (i + 1))\\<^esub>))", "thus \"\\<exists>Sj::'s set list list.\n       length Sj = length lI \\<and>\n       nodup_all lI \\<and>\n       (\\<forall>j<length Sj.\n           Sj ! j \\<noteq> [] \\<and>\n           tl (Sj ! j) \\<noteq> [] \\<and>\n           (Sj ! j ! (0), Sj ! j ! (length (Sj ! j) - (1))) = ({lI ! j}, s) \\<and>\n           (\\<forall>i<length (Sj ! j) - (1). \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! (i + (1)))\\<^esub>))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set lI.\n     \\<exists>sl.\n        sl \\<noteq> [] \\<and>\n        tl sl \\<noteq> [] \\<and>\n        (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n        (\\<forall>i<length sl - 1.\n            \\<turnstile>\\<N>\\<^bsub>(sl ! i, sl ! (i + 1))\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<exists>Sj.\n       length Sj = length lI \\<and>\n       nodup_all lI \\<and>\n       (\\<forall>j<length Sj.\n           Sj ! j \\<noteq> [] \\<and>\n           tl (Sj ! j) \\<noteq> [] \\<and>\n           (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n           ({lI ! j}, s) \\<and>\n           (\\<forall>i<length (Sj ! j) - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n  Sj ! j ! (i + 1))\\<^esub>))", "apply (subgoal_tac \"finite (set lI)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set lI.\n                \\<exists>sl.\n                   sl \\<noteq> [] \\<and>\n                   tl sl \\<noteq> [] \\<and>\n                   (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                   (\\<forall>i<length sl - 1.\n                       \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n          sl ! (i + 1))\\<^esub>);\n     finite (set lI)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Sj.\n                         length Sj = length lI \\<and>\n                         nodup_all lI \\<and>\n                         (\\<forall>j<length Sj.\n                             Sj ! j \\<noteq> [] \\<and>\n                             tl (Sj ! j) \\<noteq> [] \\<and>\n                             (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n                             ({lI ! j}, s) \\<and>\n                             (\\<forall>i<length (Sj ! j) - 1.\n                                 \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                    Sj ! j ! (i + 1))\\<^esub>))\n 2. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n sl ! (i + 1))\\<^esub>) \\<Longrightarrow>\n    finite (set lI)", "apply (rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite (set lI);\n     \\<forall>x\\<in>set lI.\n        \\<exists>sl.\n           sl \\<noteq> [] \\<and>\n           tl sl \\<noteq> [] \\<and>\n           (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n           (\\<forall>i<length sl - 1.\n               \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n  sl ! (i + 1))\\<^esub>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Sj.\n                         length Sj = length lI \\<and>\n                         nodup_all lI \\<and>\n                         (\\<forall>j<length Sj.\n                             Sj ! j \\<noteq> [] \\<and>\n                             tl (Sj ! j) \\<noteq> [] \\<and>\n                             (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n                             ({lI ! j}, s) \\<and>\n                             (\\<forall>i<length (Sj ! j) - 1.\n                                 \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                    Sj ! j ! (i + 1))\\<^esub>))\n 2. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n sl ! (i + 1))\\<^esub>) \\<Longrightarrow>\n    finite (set lI)", "apply (drule forall_ex_fun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set lI.\n                \\<exists>sl.\n                   sl \\<noteq> [] \\<and>\n                   tl sl \\<noteq> [] \\<and>\n                   (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                   (\\<forall>i<length sl - 1.\n                       \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n          sl ! (i + 1))\\<^esub>);\n     (\\<forall>x\\<in>set lI. \\<exists>y. ?P2 y x) \\<longrightarrow>\n     (\\<exists>f. \\<forall>x\\<in>set lI. ?P2 (f x) x)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Sj.\n                         length Sj = length lI \\<and>\n                         nodup_all lI \\<and>\n                         (\\<forall>j<length Sj.\n                             Sj ! j \\<noteq> [] \\<and>\n                             tl (Sj ! j) \\<noteq> [] \\<and>\n                             (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n                             ({lI ! j}, s) \\<and>\n                             (\\<forall>i<length (Sj ! j) - 1.\n                                 \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                    Sj ! j ! (i + 1))\\<^esub>))\n 2. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n sl ! (i + 1))\\<^esub>) \\<Longrightarrow>\n    finite (set lI)", "apply (drule mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n sl ! (i + 1))\\<^esub>) \\<Longrightarrow>\n    \\<forall>x\\<in>set lI. \\<exists>y. ?P2 y x\n 2. \\<lbrakk>\\<forall>x\\<in>set lI.\n                \\<exists>sl.\n                   sl \\<noteq> [] \\<and>\n                   tl sl \\<noteq> [] \\<and>\n                   (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                   (\\<forall>i<length sl - 1.\n                       \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n          sl ! (i + 1))\\<^esub>);\n     \\<exists>f. \\<forall>x\\<in>set lI. ?P2 (f x) x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Sj.\n                         length Sj = length lI \\<and>\n                         nodup_all lI \\<and>\n                         (\\<forall>j<length Sj.\n                             Sj ! j \\<noteq> [] \\<and>\n                             tl (Sj ! j) \\<noteq> [] \\<and>\n                             (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n                             ({lI ! j}, s) \\<and>\n                             (\\<forall>i<length (Sj ! j) - 1.\n                                 \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                    Sj ! j ! (i + 1))\\<^esub>))\n 3. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n sl ! (i + 1))\\<^esub>) \\<Longrightarrow>\n    finite (set lI)", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set lI.\n                \\<exists>sl.\n                   sl \\<noteq> [] \\<and>\n                   tl sl \\<noteq> [] \\<and>\n                   (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                   (\\<forall>i<length sl - 1.\n                       \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n          sl ! (i + 1))\\<^esub>);\n     \\<exists>f.\n        \\<forall>x\\<in>set lI.\n           f x \\<noteq> [] \\<and>\n           tl (f x) \\<noteq> [] \\<and>\n           (f x ! 0, f x ! (length (f x) - 1)) = ({x}, s) \\<and>\n           (\\<forall>i<length (f x) - 1.\n               \\<turnstile>\\<N>\\<^bsub>(f x ! i,\n  f x ! (i + 1))\\<^esub>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Sj.\n                         length Sj = length lI \\<and>\n                         nodup_all lI \\<and>\n                         (\\<forall>j<length Sj.\n                             Sj ! j \\<noteq> [] \\<and>\n                             tl (Sj ! j) \\<noteq> [] \\<and>\n                             (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n                             ({lI ! j}, s) \\<and>\n                             (\\<forall>i<length (Sj ! j) - 1.\n                                 \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                    Sj ! j ! (i + 1))\\<^esub>))\n 2. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n sl ! (i + 1))\\<^esub>) \\<Longrightarrow>\n    finite (set lI)", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>x\\<in>set lI.\n                   \\<exists>sl.\n                      sl \\<noteq> [] \\<and>\n                      tl sl \\<noteq> [] \\<and>\n                      (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                      (\\<forall>i<length sl - 1.\n                          \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n             sl ! (i + 1))\\<^esub>);\n        \\<forall>x\\<in>set lI.\n           f x \\<noteq> [] \\<and>\n           tl (f x) \\<noteq> [] \\<and>\n           (f x ! 0, f x ! (length (f x) - 1)) = ({x}, s) \\<and>\n           (\\<forall>i<length (f x) - 1.\n               \\<turnstile>\\<N>\\<^bsub>(f x ! i,\n  f x ! (i + 1))\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Sj.\n                            length Sj = length lI \\<and>\n                            nodup_all lI \\<and>\n                            (\\<forall>j<length Sj.\n                                Sj ! j \\<noteq> [] \\<and>\n                                tl (Sj ! j) \\<noteq> [] \\<and>\n                                (Sj ! j ! 0,\n                                 Sj ! j ! (length (Sj ! j) - 1)) =\n                                ({lI ! j}, s) \\<and>\n                                (\\<forall>i<length (Sj ! j) - 1.\n                                    \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n                       Sj ! j ! (i + 1))\\<^esub>))\n 2. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n sl ! (i + 1))\\<^esub>) \\<Longrightarrow>\n    finite (set lI)", "apply (rule_tac x = \"[f (lI ! j). j \\<leftarrow> [0..<(length lI)]]\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>x\\<in>set lI.\n                   \\<exists>sl.\n                      sl \\<noteq> [] \\<and>\n                      tl sl \\<noteq> [] \\<and>\n                      (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                      (\\<forall>i<length sl - 1.\n                          \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n             sl ! (i + 1))\\<^esub>);\n        \\<forall>x\\<in>set lI.\n           f x \\<noteq> [] \\<and>\n           tl (f x) \\<noteq> [] \\<and>\n           (f x ! 0, f x ! (length (f x) - 1)) = ({x}, s) \\<and>\n           (\\<forall>i<length (f x) - 1.\n               \\<turnstile>\\<N>\\<^bsub>(f x ! i,\n  f x ! (i + 1))\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> length\n                          (map (\\<lambda>j. f (lI ! j)) [0..<length lI]) =\n                         length lI \\<and>\n                         nodup_all lI \\<and>\n                         (\\<forall>j<length\n(map (\\<lambda>j. f (lI ! j)) [0..<length lI]).\n                             map (\\<lambda>j. f (lI ! j)) [0..<length lI] !\n                             j \\<noteq>\n                             [] \\<and>\n                             tl (map (\\<lambda>j. f (lI ! j))\n                                  [0..<length lI] !\n                                 j) \\<noteq>\n                             [] \\<and>\n                             (map (\\<lambda>j. f (lI ! j)) [0..<length lI] !\n                              j !\n                              0,\n                              map (\\<lambda>j. f (lI ! j)) [0..<length lI] !\n                              j !\n                              (length\n                                (map (\\<lambda>j. f (lI ! j))\n                                  [0..<length lI] !\n                                 j) -\n                               1)) =\n                             ({lI ! j}, s) \\<and>\n                             (\\<forall>i<length\n    (map (\\<lambda>j. f (lI ! j)) [0..<length lI] ! j) -\n   1.\n                                 \\<turnstile>\\<N>\\<^bsub>(map\n                     (\\<lambda>j. f (lI ! j)) [0..<length lI] !\n                    j !\n                    i,\n                    map (\\<lambda>j. f (lI ! j)) [0..<length lI] ! j !\n                    (i + 1))\\<^esub>))\n 2. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n sl ! (i + 1))\\<^esub>) \\<Longrightarrow>\n    finite (set lI)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>x\\<in>set lI.\n                   \\<exists>sl.\n                      sl \\<noteq> [] \\<and>\n                      tl sl \\<noteq> [] \\<and>\n                      sl ! 0 = {x} \\<and>\n                      sl ! (length sl - Suc 0) = s \\<and>\n                      (\\<forall>i<length sl - Suc 0.\n                          \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n             sl ! Suc i)\\<^esub>);\n        \\<forall>x\\<in>set lI.\n           f x \\<noteq> [] \\<and>\n           tl (f x) \\<noteq> [] \\<and>\n           f x ! 0 = {x} \\<and>\n           f x ! (length (f x) - Suc 0) = s \\<and>\n           (\\<forall>i<length (f x) - Suc 0.\n               \\<turnstile>\\<N>\\<^bsub>(f x ! i,\n  f x ! Suc i)\\<^esub>)\\<rbrakk>\n       \\<Longrightarrow> nodup_all lI\n 2. \\<forall>x\\<in>set lI.\n       \\<exists>sl.\n          sl \\<noteq> [] \\<and>\n          tl sl \\<noteq> [] \\<and>\n          (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n          (\\<forall>i<length sl - 1.\n              \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n sl ! (i + 1))\\<^esub>) \\<Longrightarrow>\n    finite (set lI)", "apply (insert b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>x\\<in>set lI.\n                   \\<exists>sl.\n                      sl \\<noteq> [] \\<and>\n                      tl sl \\<noteq> [] \\<and>\n                      sl ! 0 = {x} \\<and>\n                      sl ! (length sl - Suc 0) = s \\<and>\n                      (\\<forall>i<length sl - Suc 0.\n                          \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n             sl ! Suc i)\\<^esub>);\n        \\<forall>x\\<in>set lI.\n           f x \\<noteq> [] \\<and>\n           tl (f x) \\<noteq> [] \\<and>\n           f x ! 0 = {x} \\<and>\n           f x ! (length (f x) - Suc 0) = s \\<and>\n           (\\<forall>i<length (f x) - Suc 0.\n               \\<turnstile>\\<N>\\<^bsub>(f x ! i, f x ! Suc i)\\<^esub>);\n        set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\\<rbrakk>\n       \\<Longrightarrow> nodup_all lI\n 2. \\<lbrakk>\\<forall>x\\<in>set lI.\n                \\<exists>sl.\n                   sl \\<noteq> [] \\<and>\n                   tl sl \\<noteq> [] \\<and>\n                   (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                   (\\<forall>i<length sl - 1.\n                       \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n          sl ! (i + 1))\\<^esub>);\n     set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\\<rbrakk>\n    \\<Longrightarrow> finite (set lI)", "apply (erule conjE, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set lI.\n                \\<exists>sl.\n                   sl \\<noteq> [] \\<and>\n                   tl sl \\<noteq> [] \\<and>\n                   (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                   (\\<forall>i<length sl - 1.\n                       \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n          sl ! (i + 1))\\<^esub>);\n     set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\\<rbrakk>\n    \\<Longrightarrow> finite (set lI)", "apply (rule_tac A = \"set lI\" and B = I in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set lI.\n                \\<exists>sl.\n                   sl \\<noteq> [] \\<and>\n                   tl sl \\<noteq> [] \\<and>\n                   (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                   (\\<forall>i<length sl - 1.\n                       \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n          sl ! (i + 1))\\<^esub>);\n     set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\\<rbrakk>\n    \\<Longrightarrow> set lI \\<subseteq> I\n 2. \\<lbrakk>\\<forall>x\\<in>set lI.\n                \\<exists>sl.\n                   sl \\<noteq> [] \\<and>\n                   tl sl \\<noteq> [] \\<and>\n                   (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                   (\\<forall>i<length sl - 1.\n                       \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n          sl ! (i + 1))\\<^esub>);\n     set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\\<rbrakk>\n    \\<Longrightarrow> finite I", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set lI.\n                \\<exists>sl.\n                   sl \\<noteq> [] \\<and>\n                   tl sl \\<noteq> [] \\<and>\n                   (sl ! 0, sl ! (length sl - 1)) = ({x}, s) \\<and>\n                   (\\<forall>i<length sl - 1.\n                       \\<turnstile>\\<N>\\<^bsub>(sl ! i,\n          sl ! (i + 1))\\<^esub>);\n     set lI = {x \\<in> I. x \\<notin> s} \\<and> nodup_all lI\\<rbrakk>\n    \\<Longrightarrow> finite I", "by (rule f)"], ["proof (state)\nthis:\n  \\<exists>Sj.\n     length Sj = length lI \\<and>\n     nodup_all lI \\<and>\n     (\\<forall>j<length Sj.\n         Sj ! j \\<noteq> [] \\<and>\n         tl (Sj ! j) \\<noteq> [] \\<and>\n         (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) = ({lI ! j}, s) \\<and>\n         (\\<forall>i<length (Sj ! j) - 1.\n             \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\nSj ! j ! (i + 1))\\<^esub>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>lI.\n     set lI = {x \\<in> I. x \\<notin> s} \\<and>\n     (\\<exists>Sj.\n         length Sj = length lI \\<and>\n         nodup_all lI \\<and>\n         (\\<forall>j<length Sj.\n             Sj ! j \\<noteq> [] \\<and>\n             tl (Sj ! j) \\<noteq> [] \\<and>\n             (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n             ({lI ! j}, s) \\<and>\n             (\\<forall>i<length (Sj ! j) - 1.\n                 \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n    Sj ! j ! (i + 1))\\<^esub>)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lemma @{text \\<open>Compl_step4\\<close>}\\<close>"], ["", "text \\<open>Again, we need some additional lemmas first.\\<close>"], ["", "lemma list_one_tl_empty[rule_format]: \"length l = Suc (0 :: nat) \\<longrightarrow> tl l = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = Suc 0 \\<longrightarrow> tl l = []", "by (induction l, simp+)"], ["", "lemma list_two_tl_not_empty[rule_format]: \"\\<forall> list. length l = Suc (Suc (length list)) \\<longrightarrow> tl l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>list.\n       length l = Suc (Suc (length list)) \\<longrightarrow> tl l \\<noteq> []", "by (induction l, simp+, force)"], ["", "lemma or_empty: \"\\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>({}, s)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({}, s)\\<^esup>", "by (simp add: att_or)"], ["", "text \\<open>Note, this is not valid for any l, i.e., @{text \\<open>\\<turnstile> l \\<oplus>\\<^sub>\\<or>\\<^bsup>({}, s)\\<^esup>\\<close>} is not a theorem.\\<close>"], ["", "lemma list_or_upt[rule_format]:\n \"\\<forall> l . lI \\<noteq> [] \\<longrightarrow> length l = length lI \\<longrightarrow> nodup_all lI \\<longrightarrow>\n  (\\<forall> i < length lI. (\\<turnstile> (l ! i)) \\<and> (attack (l ! i) = ({lI ! i}, s))) \n                \\<longrightarrow> ( \\<turnstile> (l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set lI, s)\\<^esup>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       lI \\<noteq> [] \\<longrightarrow>\n       length l = length lI \\<longrightarrow>\n       nodup_all lI \\<longrightarrow>\n       (\\<forall>i<length lI.\n           \\<turnstile>l ! i \\<and>\n           attack (l ! i) = ({lI ! i}, s)) \\<longrightarrow>\n       \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set lI, s)\\<^esup>", "proof (induction lI, simp, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lI l.\n       \\<lbrakk>\\<forall>l.\n                   lI \\<noteq> [] \\<longrightarrow>\n                   length l = length lI \\<longrightarrow>\n                   nodup_all lI \\<longrightarrow>\n                   (\\<forall>i<length lI.\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) = ({lI ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set lI,\n                        s)\\<^esup>;\n        a # lI \\<noteq> []; length l = length (a # lI); nodup_all (a # lI);\n        \\<forall>i<length (a # lI).\n           \\<turnstile>l ! i \\<and>\n           attack (l ! i) = ({(a # lI) ! i}, s)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set\n                               (a # lI),\n                              s)\\<^esup>", "fix x1 x2 l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lI l.\n       \\<lbrakk>\\<forall>l.\n                   lI \\<noteq> [] \\<longrightarrow>\n                   length l = length lI \\<longrightarrow>\n                   nodup_all lI \\<longrightarrow>\n                   (\\<forall>i<length lI.\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) = ({lI ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set lI,\n                        s)\\<^esup>;\n        a # lI \\<noteq> []; length l = length (a # lI); nodup_all (a # lI);\n        \\<forall>i<length (a # lI).\n           \\<turnstile>l ! i \\<and>\n           attack (l ! i) = ({(a # lI) ! i}, s)\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set\n                               (a # lI),\n                              s)\\<^esup>", "show \"\\<forall>l::'a attree list.\n          x2 \\<noteq> [] \\<longrightarrow>\n          length l = length x2 \\<longrightarrow>\n          nodup_all x2 \\<longrightarrow>\n          (\\<forall>i<length x2. \\<turnstile>(l ! i) \\<and> attack (l ! i) = ({x2 ! i}, s)) \\<longrightarrow> \\<turnstile>(l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set x2, s)\\<^esup>) \\<Longrightarrow>\n       x1 # x2 \\<noteq> [] \\<Longrightarrow>\n       length l = length (x1 # x2) \\<Longrightarrow>\n       nodup_all (x1 # x2) \\<Longrightarrow>\n       \\<forall>i<length (x1 # x2). \\<turnstile>(l ! i) \\<and> attack (l ! i) = ({(x1 # x2) ! i}, s) \\<Longrightarrow> \\<turnstile>(l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set (x1 # x2), s)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>l.\n                x2 \\<noteq> [] \\<longrightarrow>\n                length l = length x2 \\<longrightarrow>\n                nodup_all x2 \\<longrightarrow>\n                (\\<forall>i<length x2.\n                    \\<turnstile>l ! i \\<and>\n                    attack (l ! i) = ({x2 ! i}, s)) \\<longrightarrow>\n                \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set x2,\n                     s)\\<^esup>;\n     x1 # x2 \\<noteq> []; length l = length (x1 # x2); nodup_all (x1 # x2);\n     \\<forall>i<length (x1 # x2).\n        \\<turnstile>l ! i \\<and>\n        attack (l ! i) = ({(x1 # x2) ! i}, s)\\<rbrakk>\n    \\<Longrightarrow> \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set\n                            (x1 # x2),\n                           s)\\<^esup>", "apply (case_tac x2, simp, subst att_or, case_tac l, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length l = Suc (Suc (length list)); nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>l ! i \\<and>\n           attack (l ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                               x1 (insert a (set list)),\n                              s)\\<^esup>", "text \\<open>Case @{text \\<open>\\<forall>i<Suc (Suc (length list)). \\<turnstile>l ! i \\<and> attack (l ! i) = ({(x1 # a # list) ! i}, s) \\<Longrightarrow>\n       x2 = a # list \\<Longrightarrow>  \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert x1 (insert a (set list)), s)\\<^esup>\\<close>}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length l = Suc (Suc (length list)); nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>l ! i \\<and>\n           attack (l ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                               x1 (insert a (set list)),\n                              s)\\<^esup>", "apply (subst att_or, case_tac l, simp, clarify, simp, rename_tac lista, case_tac lista, simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>aa \\<and>\n                         fst (attack aa)\n                         \\<subseteq> insert x1 (insert a (set list)) \\<and>\n                         snd (attack aa) \\<subseteq> s \\<and>\n                         \\<turnstile>ab #\n                                     listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                                   x1 (insert a (set list)) -\n                                  fst (attack aa),\n                                  s)\\<^esup>", "text \\<open>Remaining conjunct of three conditions: @{text \\<open> \\<turnstile>aa \\<and>\n       fst (attack aa) \\<subseteq> insert x1 (insert a (set list)) \\<and>\n       snd (attack aa) \\<subseteq> s \\<and> \\<turnstile>ab # listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert x1 (insert a (set list)) - fst (attack aa), s)\\<^esup>\\<close>}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>aa \\<and>\n                         fst (attack aa)\n                         \\<subseteq> insert x1 (insert a (set list)) \\<and>\n                         snd (attack aa) \\<subseteq> s \\<and>\n                         \\<turnstile>ab #\n                                     listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                                   x1 (insert a (set list)) -\n                                  fst (attack aa),\n                                  s)\\<^esup>", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>aa\n 2. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> fst (attack aa)\n                         \\<subseteq> insert x1 (insert a (set list)) \\<and>\n                         snd (attack aa) \\<subseteq> s \\<and>\n                         \\<turnstile>ab #\n                                     listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                                   x1 (insert a (set list)) -\n                                  fst (attack aa),\n                                  s)\\<^esup>", "text \\<open>First condition @{text \\<open> \\<turnstile>aa\\<close>}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>aa\n 2. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> fst (attack aa)\n                         \\<subseteq> insert x1 (insert a (set list)) \\<and>\n                         snd (attack aa) \\<subseteq> s \\<and>\n                         \\<turnstile>ab #\n                                     listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                                   x1 (insert a (set list)) -\n                                  fst (attack aa),\n                                  s)\\<^esup>", "apply (drule_tac x = 0 in spec, drule mp, simp, (erule conjE)+, simp, rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> fst (attack aa)\n                         \\<subseteq> insert x1 (insert a (set list))\n 2. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> snd (attack aa) \\<subseteq> s \\<and>\n                         \\<turnstile>ab #\n                                     listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                                   x1 (insert a (set list)) -\n                                  fst (attack aa),\n                                  s)\\<^esup>", "text \\<open>Second condition @{text \\<open>fst (attack aa) \\<subseteq> insert x1 (insert a (set list))\\<close>}\\<close>"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> fst (attack aa)\n                         \\<subseteq> insert x1 (insert a (set list))\n 2. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> snd (attack aa) \\<subseteq> s \\<and>\n                         \\<turnstile>ab #\n                                     listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                                   x1 (insert a (set list)) -\n                                  fst (attack aa),\n                                  s)\\<^esup>", "apply (drule_tac x = 0 in spec, drule mp, simp, erule conjE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> snd (attack aa) \\<subseteq> s \\<and>\n                         \\<turnstile>ab #\n                                     listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                                   x1 (insert a (set list)) -\n                                  fst (attack aa),\n                                  s)\\<^esup>", "text \\<open>The remaining conditions \n\n          @{text \\<open>snd (attack aa) \\<subseteq> s \\<and> \\<turnstile>ab # listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert x1 (insert a (set list)) - fst (attack aa), s)\\<^esup>\\<close>}\n \n          are solved automatically!\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista ab listb.\n       \\<lbrakk>\\<forall>l.\n                   length l = Suc (length list) \\<longrightarrow>\n                   nodup_all (a # list) \\<longrightarrow>\n                   (\\<forall>i<Suc (length list).\n                       \\<turnstile>l ! i \\<and>\n                       attack (l ! i) =\n                       ({(a # list) ! i}, s)) \\<longrightarrow>\n                   \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert a\n                         (set list),\n                        s)\\<^esup>;\n        length listb = length list; nodup_all (x1 # a # list);\n        \\<forall>i<Suc (Suc (length list)).\n           \\<turnstile>(aa # ab # listb) ! i \\<and>\n           attack ((aa # ab # listb) ! i) = ({(x1 # a # list) ! i}, s);\n        x2 = a # list; l = aa # ab # listb; lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> snd (attack aa) \\<subseteq> s \\<and>\n                         \\<turnstile>ab #\n                                     listb \\<oplus>\\<^sub>\\<or>\\<^bsup>(insert\n                                   x1 (insert a (set list)) -\n                                  fst (attack aa),\n                                  s)\\<^esup>", "by (metis Suc_mono add.right_neutral add_Suc_right list.size(4) nodup_all_lem nodup_all_tl nth_Cons_0 nth_Cons_Suc order_refl prod.sel(1) prod.sel(2) zero_less_Suc)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>l.\n              x2 \\<noteq> [] \\<longrightarrow>\n              length l = length x2 \\<longrightarrow>\n              nodup_all x2 \\<longrightarrow>\n              (\\<forall>i<length x2.\n                  \\<turnstile>l ! i \\<and>\n                  attack (l ! i) = ({x2 ! i}, s)) \\<longrightarrow>\n              \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set x2, s)\\<^esup>;\n   x1 # x2 \\<noteq> []; length l = length (x1 # x2); nodup_all (x1 # x2);\n   \\<forall>i<length (x1 # x2).\n      \\<turnstile>l ! i \\<and>\n      attack (l ! i) = ({(x1 # x2) ! i}, s)\\<rbrakk>\n  \\<Longrightarrow> \\<turnstile>l \\<oplus>\\<^sub>\\<or>\\<^bsup>(set\n                          (x1 # x2),\n                         s)\\<^esup>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma app_tl_empty_hd[rule_format]: \"tl (l @ [a]) = [] \\<longrightarrow> hd (l @ [a]) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (l @ [a]) = [] \\<longrightarrow> hd (l @ [a]) = a", "by (induction l) auto"], ["", "lemma tl_hd_empty[rule_format]: \"tl (l @ [a]) = [] \\<longrightarrow> l = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (l @ [a]) = [] \\<longrightarrow> l = []", "by (induction l) auto"], ["", "lemma tl_hd_not_empty[rule_format]: \"tl (l @ [a]) \\<noteq> [] \\<longrightarrow> l \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (l @ [a]) \\<noteq> [] \\<longrightarrow> l \\<noteq> []", "by (induction l) auto"], ["", "lemma app_tl_empty_length[rule_format]: \"tl (map f [0..<length l] @ [a]) = []  \n                                        \\<Longrightarrow> l = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (map f [0..<length l] @ [a]) = [] \\<Longrightarrow> l = []", "by (drule tl_hd_empty, simp)"], ["", "lemma not_empty_hd_fst[rule_format]: \"l \\<noteq> [] \\<longrightarrow> hd(l @ [a]) = l ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<longrightarrow> hd (l @ [a]) = l ! 0", "by (induction l) auto"], ["", "lemma app_tl_hd_list[rule_format]: \"tl (map f [0..<length l] @ [a]) \\<noteq> []  \n                             \\<Longrightarrow> hd(map f [0..<length l] @ [a]) = (map f [0..<length l]) ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (map f [0..<length l] @ [a]) \\<noteq> [] \\<Longrightarrow>\n    hd (map f [0..<length l] @ [a]) = map f [0..<length l] ! 0", "by (drule tl_hd_not_empty, erule not_empty_hd_fst)"], ["", "lemma tl_app_in[rule_format]: \"l \\<noteq> [] \\<longrightarrow>\n   map f [0..<(length l - (Suc 0:: nat))] @ [f(length l - (Suc 0 :: nat))] = map f [0..<length l]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<longrightarrow>\n    map f [0..<length l - Suc 0] @ [f (length l - Suc 0)] =\n    map f [0..<length l]", "by (induction l) auto"], ["", "lemma map_fst[rule_format]: \"n > 0 \\<longrightarrow> map f [0..<n] = f 0 # (map f [1..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<longrightarrow> map f [0..<n] = f 0 # map f [1..<n]", "by (induction n) auto"], ["", "lemma step_lem[rule_format]:  \"l \\<noteq> [] \\<Longrightarrow>\n       tl (map (\\<lambda> i. f((x1 # a # l) ! i)((a # l) ! i)) [0..<length l]) =\n       map (\\<lambda>i. f((a # l) ! i)(l ! i)) [0..<length l - (1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    tl (map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i))\n         [0..<length l]) =\n    map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - 1]", "proof (simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    tl (map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i))\n         [0..<length l]) =\n    map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - Suc 0]", "assume l: \"l \\<noteq> []\""], ["proof (state)\nthis:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    tl (map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i))\n         [0..<length l]) =\n    map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - Suc 0]", "have a: \"map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n                 (f(x1)(a) # (map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<(length l - 1)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n    f x1 a # map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - 1]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n    f x1 a # map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - 1]", "have b : \"map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n                     f ((x1 # a # l) ! 0) ((a # l) ! 0) # \n                     (map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [1..<length l])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n    f ((x1 # a # l) ! 0) ((a # l) ! 0) #\n    map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [1..<length l]", "by (rule map_fst, simp, rule l)"], ["proof (state)\nthis:\n  map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n  f ((x1 # a # l) ! 0) ((a # l) ! 0) #\n  map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [1..<length l]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n    f x1 a # map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - 1]", "have c: \"map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [Suc (0)..<length l] =\n                map (\\<lambda>i. f ((x1 # a # l) ! Suc i) ((a # l) ! Suc i)) [(0)..<(length l - 1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i))\n     [Suc 0..<length l] =\n    map (\\<lambda>i. f ((x1 # a # l) ! Suc i) ((a # l) ! Suc i))\n     [0..<length l - 1]", "by (subgoal_tac \"[Suc (0)..<length l] = map Suc [0..<(length l - 1)]\", \n             simp, simp add: map_Suc_upt l)"], ["proof (state)\nthis:\n  map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [Suc 0..<length l] =\n  map (\\<lambda>i. f ((x1 # a # l) ! Suc i) ((a # l) ! Suc i))\n   [0..<length l - 1]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n    f x1 a # map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - 1]", "thus \"map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n             f x1 a # map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - (1)]\""], ["proof (prove)\nusing this:\n  map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [Suc 0..<length l] =\n  map (\\<lambda>i. f ((x1 # a # l) ! Suc i) ((a # l) ! Suc i))\n   [0..<length l - 1]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n    f x1 a # map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - 1]", "by (simp add: b c)"], ["proof (state)\nthis:\n  map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n  f x1 a # map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - 1]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n  f x1 a # map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - 1]\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    tl (map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i))\n         [0..<length l]) =\n    map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - Suc 0]", "thus \"l \\<noteq> [] \\<Longrightarrow>\n    tl (map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l]) =\n    map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - Suc (0)]\""], ["proof (prove)\nusing this:\n  map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l] =\n  f x1 a # map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - 1]\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    tl (map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i))\n         [0..<length l]) =\n    map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - Suc 0]", "by (subst a, simp)"], ["proof (state)\nthis:\n  l \\<noteq> [] \\<Longrightarrow>\n  tl (map (\\<lambda>i. f ((x1 # a # l) ! i) ((a # l) ! i)) [0..<length l]) =\n  map (\\<lambda>i. f ((a # l) ! i) (l ! i)) [0..<length l - Suc 0]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_lem2a[rule_format]: \"0 < length list \\<Longrightarrow> map (\\<lambda>i. \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>)\n        [0..<length list] @\n       [\\<N>\\<^bsub>((x1 # a # list) ! length list, (a # list) ! length list)\\<^esub>] =\n       aa # listb \\<longrightarrow> \\<N>\\<^bsub>((x1, a))\\<^esub> = aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length list \\<Longrightarrow>\n    map (\\<lambda>i.\n            \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>)\n     [0..<length list] @\n    [\\<N>\\<^bsub>((x1 # a # list) ! length list,\n                  (a # list) ! length list)\\<^esub>] =\n    aa # listb \\<longrightarrow>\n    \\<N>\\<^bsub>(x1, a)\\<^esub> = aa", "by (subst map_fst, assumption, simp)"], ["", "lemma step_lem2b[rule_format]: \"0 = length list \\<Longrightarrow> map (\\<lambda>i. \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>)\n        [0..<length list] @\n       [\\<N>\\<^bsub>((x1 # a # list) ! length list, (a # list) ! length list)\\<^esub>] =\n       aa # listb \\<longrightarrow> \\<N>\\<^bsub>((x1, a))\\<^esub> = aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = length list \\<Longrightarrow>\n    map (\\<lambda>i.\n            \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>)\n     [0..<length list] @\n    [\\<N>\\<^bsub>((x1 # a # list) ! length list,\n                  (a # list) ! length list)\\<^esub>] =\n    aa # listb \\<longrightarrow>\n    \\<N>\\<^bsub>(x1, a)\\<^esub> = aa", "by simp"], ["", "lemma step_lem2: \"map (\\<lambda>i. \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>)\n        [0..<length list] @\n       [\\<N>\\<^bsub>((x1 # a # list) ! length list, (a # list) ! length list)\\<^esub>] =\n       aa # listb \\<Longrightarrow> \\<N>\\<^bsub>((x1, a))\\<^esub> = aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>)\n     [0..<length list] @\n    [\\<N>\\<^bsub>((x1 # a # list) ! length list,\n                  (a # list) ! length list)\\<^esub>] =\n    aa # listb \\<Longrightarrow>\n    \\<N>\\<^bsub>(x1, a)\\<^esub> = aa", "proof (case_tac \"length list\", rule step_lem2b, erule sym, assumption)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>map (\\<lambda>i.\n                        \\<N>\\<^bsub>((x1 # a # list) ! i,\n                                     (a # list) ! i)\\<^esub>)\n                 [0..<length list] @\n                [\\<N>\\<^bsub>((x1 # a # list) ! length list,\n                              (a # list) ! length list)\\<^esub>] =\n                aa # listb;\n        length list = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<N>\\<^bsub>(x1, a)\\<^esub> = aa", "show \"\\<And>nat.\n       map (\\<lambda>i. \\<N>\\<^bsub>((x1 # a # list) ! i, (a # list) ! i)\\<^esub>) [0..<length list] @\n       [\\<N>\\<^bsub>((x1 # a # list) ! length list, (a # list) ! length list)\\<^esub>] =\n       aa # listb \\<Longrightarrow>\n       length list = Suc nat \\<Longrightarrow> \\<N>\\<^bsub>(x1, a)\\<^esub> = aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>map (\\<lambda>i.\n                        \\<N>\\<^bsub>((x1 # a # list) ! i,\n                                     (a # list) ! i)\\<^esub>)\n                 [0..<length list] @\n                [\\<N>\\<^bsub>((x1 # a # list) ! length list,\n                              (a # list) ! length list)\\<^esub>] =\n                aa # listb;\n        length list = Suc nat\\<rbrakk>\n       \\<Longrightarrow> \\<N>\\<^bsub>(x1, a)\\<^esub> = aa", "by (rule_tac list = list in step_lem2a, simp)"], ["proof (state)\nthis:\n  \\<lbrakk>map (\\<lambda>i.\n                   \\<N>\\<^bsub>((x1 # a # list) ! i,\n                                (a # list) ! i)\\<^esub>)\n            [0..<length list] @\n           [\\<N>\\<^bsub>((x1 # a # list) ! length list,\n                         (a # list) ! length list)\\<^esub>] =\n           aa # listb;\n   length list = Suc ?nat\\<rbrakk>\n  \\<Longrightarrow> \\<N>\\<^bsub>(x1, a)\\<^esub> = aa\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_list_and[rule_format]: \"Sji \\<noteq> [] \\<longrightarrow> tl Sji \\<noteq> [] \\<longrightarrow>\n         (\\<forall> li.  Sji ! (0) = li \\<longrightarrow>\n        Sji! (length (Sji) - 1) = s \\<longrightarrow>\n       (\\<forall>i<length (Sji) - 1. \\<turnstile>\\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n       \\<turnstile> (map (\\<lambda>i. \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n          [0..<length (Sji) - Suc (0)] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sji \\<noteq> [] \\<longrightarrow>\n    tl Sji \\<noteq> [] \\<longrightarrow>\n    (\\<forall>li.\n        Sji ! 0 = li \\<longrightarrow>\n        Sji ! (length Sji - 1) = s \\<longrightarrow>\n        (\\<forall>i<length Sji - 1.\n            \\<turnstile>\\<N>\\<^bsub>(Sji ! i,\n                                     Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n                     [0..<\n                      length Sji -\n                      Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)", "proof (induction Sji)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    tl [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>li.\n        [] ! 0 = li \\<longrightarrow>\n        [] ! (length [] - 1) = s \\<longrightarrow>\n        (\\<forall>i<length [] - 1.\n            \\<turnstile>\\<N>\\<^bsub>([] ! i,\n                                     [] ! Suc i)\\<^esub>) \\<longrightarrow>\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>([] ! i, [] ! Suc i)\\<^esub>)\n                     [0..<\n                      length [] -\n                      Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)\n 2. \\<And>a Sji.\n       Sji \\<noteq> [] \\<longrightarrow>\n       tl Sji \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           Sji ! 0 = li \\<longrightarrow>\n           Sji ! (length Sji - 1) = s \\<longrightarrow>\n           (\\<forall>i<length Sji - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sji ! i,\n  Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n                        [0..<\n                         length Sji -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>) \\<Longrightarrow>\n       a # Sji \\<noteq> [] \\<longrightarrow>\n       tl (a # Sji) \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           (a # Sji) ! 0 = li \\<longrightarrow>\n           (a # Sji) ! (length (a # Sji) - 1) = s \\<longrightarrow>\n           (\\<forall>i<length (a # Sji) - 1.\n               \\<turnstile>\\<N>\\<^bsub>((a # Sji) ! i,\n  (a # Sji) ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>((a # Sji) ! i,\n      (a # Sji) ! Suc i)\\<^esub>)\n                        [0..<\n                         length (a # Sji) -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    tl [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>li.\n        [] ! 0 = li \\<longrightarrow>\n        [] ! (length [] - 1) = s \\<longrightarrow>\n        (\\<forall>i<length [] - 1.\n            \\<turnstile>\\<N>\\<^bsub>([] ! i,\n                                     [] ! Suc i)\\<^esub>) \\<longrightarrow>\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>([] ! i, [] ! Suc i)\\<^esub>)\n                     [0..<\n                      length [] -\n                      Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)\n 2. \\<And>a Sji.\n       Sji \\<noteq> [] \\<longrightarrow>\n       tl Sji \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           Sji ! 0 = li \\<longrightarrow>\n           Sji ! (length Sji - 1) = s \\<longrightarrow>\n           (\\<forall>i<length Sji - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sji ! i,\n  Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n                        [0..<\n                         length Sji -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>) \\<Longrightarrow>\n       a # Sji \\<noteq> [] \\<longrightarrow>\n       tl (a # Sji) \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           (a # Sji) ! 0 = li \\<longrightarrow>\n           (a # Sji) ! (length (a # Sji) - 1) = s \\<longrightarrow>\n           (\\<forall>i<length (a # Sji) - 1.\n               \\<turnstile>\\<N>\\<^bsub>((a # Sji) ! i,\n  (a # Sji) ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>((a # Sji) ! i,\n      (a # Sji) ! Suc i)\\<^esub>)\n                        [0..<\n                         length (a # Sji) -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<longrightarrow>\n    tl [] \\<noteq> [] \\<longrightarrow>\n    (\\<forall>li.\n        [] ! 0 = li \\<longrightarrow>\n        [] ! (length [] - 1) = s \\<longrightarrow>\n        (\\<forall>i<length [] - 1.\n            \\<turnstile>\\<N>\\<^bsub>([] ! i,\n                                     [] ! Suc i)\\<^esub>) \\<longrightarrow>\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>([] ! i, [] ! Suc i)\\<^esub>)\n                     [0..<\n                      length [] -\n                      Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)", "by simp"], ["proof (state)\nthis:\n  [] \\<noteq> [] \\<longrightarrow>\n  tl [] \\<noteq> [] \\<longrightarrow>\n  (\\<forall>li.\n      [] ! 0 = li \\<longrightarrow>\n      [] ! (length [] - 1) = s \\<longrightarrow>\n      (\\<forall>i<length [] - 1.\n          \\<turnstile>\\<N>\\<^bsub>([] ! i,\n                                   [] ! Suc i)\\<^esub>) \\<longrightarrow>\n      \\<turnstile>map (\\<lambda>i. \\<N>\\<^bsub>([] ! i, [] ! Suc i)\\<^esub>)\n                   [0..<\n                    length [] -\n                    Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)\n\ngoal (1 subgoal):\n 1. \\<And>a Sji.\n       Sji \\<noteq> [] \\<longrightarrow>\n       tl Sji \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           Sji ! 0 = li \\<longrightarrow>\n           Sji ! (length Sji - 1) = s \\<longrightarrow>\n           (\\<forall>i<length Sji - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sji ! i,\n  Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n                        [0..<\n                         length Sji -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>) \\<Longrightarrow>\n       a # Sji \\<noteq> [] \\<longrightarrow>\n       tl (a # Sji) \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           (a # Sji) ! 0 = li \\<longrightarrow>\n           (a # Sji) ! (length (a # Sji) - 1) = s \\<longrightarrow>\n           (\\<forall>i<length (a # Sji) - 1.\n               \\<turnstile>\\<N>\\<^bsub>((a # Sji) ! i,\n  (a # Sji) ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>((a # Sji) ! i,\n      (a # Sji) ! Suc i)\\<^esub>)\n                        [0..<\n                         length (a # Sji) -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Sji.\n       Sji \\<noteq> [] \\<longrightarrow>\n       tl Sji \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           Sji ! 0 = li \\<longrightarrow>\n           Sji ! (length Sji - 1) = s \\<longrightarrow>\n           (\\<forall>i<length Sji - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sji ! i,\n  Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n                        [0..<\n                         length Sji -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>) \\<Longrightarrow>\n       a # Sji \\<noteq> [] \\<longrightarrow>\n       tl (a # Sji) \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           (a # Sji) ! 0 = li \\<longrightarrow>\n           (a # Sji) ! (length (a # Sji) - 1) = s \\<longrightarrow>\n           (\\<forall>i<length (a # Sji) - 1.\n               \\<turnstile>\\<N>\\<^bsub>((a # Sji) ! i,\n  (a # Sji) ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>((a # Sji) ! i,\n      (a # Sji) ! Suc i)\\<^esub>)\n                        [0..<\n                         length (a # Sji) -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>)", "case (Cons a Sji)"], ["proof (state)\nthis:\n  Sji \\<noteq> [] \\<longrightarrow>\n  tl Sji \\<noteq> [] \\<longrightarrow>\n  (\\<forall>li.\n      Sji ! 0 = li \\<longrightarrow>\n      Sji ! (length Sji - 1) = s \\<longrightarrow>\n      (\\<forall>i<length Sji - 1.\n          \\<turnstile>\\<N>\\<^bsub>(Sji ! i,\n                                   Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n      \\<turnstile>map (\\<lambda>i.\n                          \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n                   [0..<\n                    length Sji -\n                    Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)\n\ngoal (1 subgoal):\n 1. \\<And>a Sji.\n       Sji \\<noteq> [] \\<longrightarrow>\n       tl Sji \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           Sji ! 0 = li \\<longrightarrow>\n           Sji ! (length Sji - 1) = s \\<longrightarrow>\n           (\\<forall>i<length Sji - 1.\n               \\<turnstile>\\<N>\\<^bsub>(Sji ! i,\n  Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n                        [0..<\n                         length Sji -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>) \\<Longrightarrow>\n       a # Sji \\<noteq> [] \\<longrightarrow>\n       tl (a # Sji) \\<noteq> [] \\<longrightarrow>\n       (\\<forall>li.\n           (a # Sji) ! 0 = li \\<longrightarrow>\n           (a # Sji) ! (length (a # Sji) - 1) = s \\<longrightarrow>\n           (\\<forall>i<length (a # Sji) - 1.\n               \\<turnstile>\\<N>\\<^bsub>((a # Sji) ! i,\n  (a # Sji) ! Suc i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>((a # Sji) ! i,\n      (a # Sji) ! Suc i)\\<^esub>)\n                        [0..<\n                         length (a # Sji) -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li,\n                        s)\\<^esup>)", "then"], ["proof (chain)\npicking this:\n  Sji \\<noteq> [] \\<longrightarrow>\n  tl Sji \\<noteq> [] \\<longrightarrow>\n  (\\<forall>li.\n      Sji ! 0 = li \\<longrightarrow>\n      Sji ! (length Sji - 1) = s \\<longrightarrow>\n      (\\<forall>i<length Sji - 1.\n          \\<turnstile>\\<N>\\<^bsub>(Sji ! i,\n                                   Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n      \\<turnstile>map (\\<lambda>i.\n                          \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n                   [0..<\n                    length Sji -\n                    Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)", "show ?case"], ["proof (prove)\nusing this:\n  Sji \\<noteq> [] \\<longrightarrow>\n  tl Sji \\<noteq> [] \\<longrightarrow>\n  (\\<forall>li.\n      Sji ! 0 = li \\<longrightarrow>\n      Sji ! (length Sji - 1) = s \\<longrightarrow>\n      (\\<forall>i<length Sji - 1.\n          \\<turnstile>\\<N>\\<^bsub>(Sji ! i,\n                                   Sji ! Suc i)\\<^esub>) \\<longrightarrow>\n      \\<turnstile>map (\\<lambda>i.\n                          \\<N>\\<^bsub>(Sji ! i, Sji ! Suc i)\\<^esub>)\n                   [0..<\n                    length Sji -\n                    Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)\n\ngoal (1 subgoal):\n 1. a # Sji \\<noteq> [] \\<longrightarrow>\n    tl (a # Sji) \\<noteq> [] \\<longrightarrow>\n    (\\<forall>li.\n        (a # Sji) ! 0 = li \\<longrightarrow>\n        (a # Sji) ! (length (a # Sji) - 1) = s \\<longrightarrow>\n        (\\<forall>i<length (a # Sji) - 1.\n            \\<turnstile>\\<N>\\<^bsub>((a # Sji) ! i,\n                                     (a # Sji) !\n                                     Suc i)\\<^esub>) \\<longrightarrow>\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((a # Sji) ! i,\n   (a # Sji) ! Suc i)\\<^esub>)\n                     [0..<\n                      length (a # Sji) -\n                      Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)", "apply (subst att_and, case_tac Sji, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n                list ! (length list - Suc 0) = s \\<longrightarrow>\n                (\\<forall>i<length list.\n                    \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n       list ! i)\\<^esub>) \\<longrightarrow>\n                \\<turnstile>map (\\<lambda>i.\n                                    \\<N>\\<^bsub>((aa # list) ! i,\n           list ! i)\\<^esub>)\n                             [0..<\n                              length\n                               list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                             s)\\<^esup>;\n        Sji = aa # list\\<rbrakk>\n       \\<Longrightarrow> (aa # list) ! length list = s \\<longrightarrow>\n                         (\\<forall>i<Suc (length list).\n                             \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                (aa # list) ! i)\\<^esub>) \\<longrightarrow>\n                         (case map (\\<lambda>i.\n \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n                                [0..<length list] @\n                               [\\<N>\\<^bsub>((a # aa # list) ! length list,\n       s)\\<^esub>] of\n                          [] \\<Rightarrow> fst (a, s) \\<subseteq> snd (a, s)\n                          | [aa] \\<Rightarrow>\n                              \\<turnstile>aa \\<and> attack aa = (a, s)\n                          | aa # ab # list \\<Rightarrow>\n                              \\<turnstile>aa \\<and>\n                              fst (attack aa) = fst (a, s) \\<and>\n                              \\<turnstile>ab #\n    list \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack aa), snd (a, s))\\<^esup>)", "apply (rule impI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n                list ! (length list - Suc 0) = s \\<longrightarrow>\n                (\\<forall>i<length list.\n                    \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n       list ! i)\\<^esub>) \\<longrightarrow>\n                \\<turnstile>map (\\<lambda>i.\n                                    \\<N>\\<^bsub>((aa # list) ! i,\n           list ! i)\\<^esub>)\n                             [0..<\n                              length\n                               list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                             s)\\<^esup>;\n        Sji = aa # list; (aa # list) ! length list = s;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> case map (\\<lambda>i.\n\\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n                               [0..<length list] @\n                              [\\<N>\\<^bsub>((a # aa # list) ! length list,\n      s)\\<^esub>] of\n                         [] \\<Rightarrow> fst (a, s) \\<subseteq> snd (a, s)\n                         | [aa] \\<Rightarrow>\n                             \\<turnstile>aa \\<and> attack aa = (a, s)\n                         | aa # ab # list \\<Rightarrow>\n                             \\<turnstile>aa \\<and>\n                             fst (attack aa) = fst (a, s) \\<and>\n                             \\<turnstile>ab #\n   list \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack aa), snd (a, s))\\<^esup>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n                list ! (length list - Suc 0) = s \\<longrightarrow>\n                (\\<forall>i<length list.\n                    \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n       list ! i)\\<^esub>) \\<longrightarrow>\n                \\<turnstile>map (\\<lambda>i.\n                                    \\<N>\\<^bsub>((aa # list) ! i,\n           list ! i)\\<^esub>)\n                             [0..<\n                              length\n                               list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                             s)\\<^esup>;\n        Sji = aa # list; (aa # list) ! length list = s;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> case map (\\<lambda>i.\n\\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n                               [0..<length list] @\n                              [\\<N>\\<^bsub>((a # aa # list) ! length list,\n      s)\\<^esub>] of\n                         [] \\<Rightarrow> fst (a, s) \\<subseteq> snd (a, s)\n                         | [aa] \\<Rightarrow>\n                             \\<turnstile>aa \\<and> attack aa = (a, s)\n                         | aa # ab # list \\<Rightarrow>\n                             \\<turnstile>aa \\<and>\n                             fst (attack aa) = fst (a, s) \\<and>\n                             \\<turnstile>ab #\n   list \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack aa), snd (a, s))\\<^esup>", "fix aa list"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n                list ! (length list - Suc 0) = s \\<longrightarrow>\n                (\\<forall>i<length list.\n                    \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n       list ! i)\\<^esub>) \\<longrightarrow>\n                \\<turnstile>map (\\<lambda>i.\n                                    \\<N>\\<^bsub>((aa # list) ! i,\n           list ! i)\\<^esub>)\n                             [0..<\n                              length\n                               list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                             s)\\<^esup>;\n        Sji = aa # list; (aa # list) ! length list = s;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> case map (\\<lambda>i.\n\\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n                               [0..<length list] @\n                              [\\<N>\\<^bsub>((a # aa # list) ! length list,\n      s)\\<^esub>] of\n                         [] \\<Rightarrow> fst (a, s) \\<subseteq> snd (a, s)\n                         | [aa] \\<Rightarrow>\n                             \\<turnstile>aa \\<and> attack aa = (a, s)\n                         | aa # ab # list \\<Rightarrow>\n                             \\<turnstile>aa \\<and>\n                             fst (attack aa) = fst (a, s) \\<and>\n                             \\<turnstile>ab #\n   list \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack aa), snd (a, s))\\<^esup>", "show \"list \\<noteq> [] \\<longrightarrow>\n       list ! (length list - Suc 0) = s \\<longrightarrow>\n       (\\<forall>i<length list. \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>) \\<longrightarrow>\n       \\<turnstile>(map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>) [0..<length list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa, s)\\<^esup>) \\<Longrightarrow>\n       Sji = aa # list \\<Longrightarrow>\n       (aa # list) ! length list = s \\<Longrightarrow>\n       \\<forall>i<Suc (length list). \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub> \\<Longrightarrow>\n       case map (\\<lambda>i. \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>) [0..<length list] @\n            [\\<N>\\<^bsub>((a # aa # list) ! length list, s)\\<^esub>] of\n       [] \\<Rightarrow> fst (a, s) \\<subseteq> snd (a, s) | [aa] \\<Rightarrow> \\<turnstile>aa \\<and> attack aa = (a, s)\n       | aa # ab # list \\<Rightarrow>\n           \\<turnstile>aa \\<and> fst (attack aa) = fst (a, s) \\<and> \\<turnstile>(ab # list \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack aa), snd (a, s))\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n             list ! (length list - Suc 0) = s \\<longrightarrow>\n             (\\<forall>i<length list.\n                 \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n    list ! i)\\<^esub>) \\<longrightarrow>\n             \\<turnstile>map (\\<lambda>i.\n                                 \\<N>\\<^bsub>((aa # list) ! i,\n        list ! i)\\<^esub>)\n                          [0..<\n                           length\n                            list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                          s)\\<^esup>;\n     Sji = aa # list; (aa # list) ! length list = s;\n     \\<forall>i<Suc (length list).\n        \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                 (aa # list) ! i)\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> case map (\\<lambda>i.\n                                   \\<N>\\<^bsub>((a # aa # list) ! i,\n          (aa # list) ! i)\\<^esub>)\n                            [0..<length list] @\n                           [\\<N>\\<^bsub>((a # aa # list) ! length list,\n   s)\\<^esub>] of\n                      [] \\<Rightarrow> fst (a, s) \\<subseteq> snd (a, s)\n                      | [aa] \\<Rightarrow>\n                          \\<turnstile>aa \\<and> attack aa = (a, s)\n                      | aa # ab # list \\<Rightarrow>\n                          \\<turnstile>aa \\<and>\n                          fst (attack aa) = fst (a, s) \\<and>\n                          \\<turnstile>ab #\nlist \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack aa), snd (a, s))\\<^esup>", "proof (case_tac \"map (\\<lambda>i. \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>) [0..<length list] @\n            [\\<N>\\<^bsub>((a # aa # list) ! length list, s)\\<^esub>]\", simp, clarify, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ab lista.\n       \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n                (\\<forall>i<length list.\n                    \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n       list ! i)\\<^esub>) \\<longrightarrow>\n                \\<turnstile>map (\\<lambda>i.\n                                    \\<N>\\<^bsub>((aa # list) ! i,\n           list ! i)\\<^esub>)\n                             [0..<\n                              length\n                               list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                             list ! (length list - Suc 0))\\<^esup>;\n        Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # lista;\n        s = (aa # list) ! length list\\<rbrakk>\n       \\<Longrightarrow> case lista of\n                         [] \\<Rightarrow>\n                           \\<turnstile>ab \\<and>\n                           attack ab = (a, (aa # list) ! length list)\n                         | aba # lista \\<Rightarrow>\n                             \\<turnstile>ab \\<and>\n                             fst (attack ab) = a \\<and>\n                             \\<turnstile>aba #\n   lista \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack ab),\n (aa # list) ! length list)\\<^esup>", "fix ab lista"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ab lista.\n       \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n                (\\<forall>i<length list.\n                    \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n       list ! i)\\<^esub>) \\<longrightarrow>\n                \\<turnstile>map (\\<lambda>i.\n                                    \\<N>\\<^bsub>((aa # list) ! i,\n           list ! i)\\<^esub>)\n                             [0..<\n                              length\n                               list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                             list ! (length list - Suc 0))\\<^esup>;\n        Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # lista;\n        s = (aa # list) ! length list\\<rbrakk>\n       \\<Longrightarrow> case lista of\n                         [] \\<Rightarrow>\n                           \\<turnstile>ab \\<and>\n                           attack ab = (a, (aa # list) ! length list)\n                         | aba # lista \\<Rightarrow>\n                             \\<turnstile>ab \\<and>\n                             fst (attack ab) = a \\<and>\n                             \\<turnstile>aba #\n   lista \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack ab),\n (aa # list) ! length list)\\<^esup>", "have *: \"tl (map (\\<lambda>i. \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>) [0..<length list])\n                    =  (map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, (list) ! i)\\<^esub>) [0..<(length list - 1)])\"\n        if \"list \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list]) =\n    map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n     [0..<length list - 1]", "apply (subgoal_tac \"tl (map (\\<lambda>i. \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>) [0..<length list])\n                    =  (map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, (list) ! i)\\<^esub>) [0..<(length list - 1)])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. tl (map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list]) =\n    map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n     [0..<length list - 1] \\<Longrightarrow>\n    tl (map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list]) =\n    map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n     [0..<length list - 1]\n 2. tl (map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list]) =\n    map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n     [0..<length list - 1]", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list]) =\n    map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n     [0..<length list - 1]", "apply (subst step_lem [OF that])"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n     [0..<length list - 1] =\n    map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n     [0..<length list - 1]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list \\<noteq> [] \\<Longrightarrow>\n  tl (map (\\<lambda>i.\n              \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n       [0..<length list]) =\n  map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n   [0..<length list - 1]\n\ngoal (1 subgoal):\n 1. \\<And>ab lista.\n       \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n                (\\<forall>i<length list.\n                    \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n       list ! i)\\<^esub>) \\<longrightarrow>\n                \\<turnstile>map (\\<lambda>i.\n                                    \\<N>\\<^bsub>((aa # list) ! i,\n           list ! i)\\<^esub>)\n                             [0..<\n                              length\n                               list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                             list ! (length list - Suc 0))\\<^esup>;\n        Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # lista;\n        s = (aa # list) ! length list\\<rbrakk>\n       \\<Longrightarrow> case lista of\n                         [] \\<Rightarrow>\n                           \\<turnstile>ab \\<and>\n                           attack ab = (a, (aa # list) ! length list)\n                         | aba # lista \\<Rightarrow>\n                             \\<turnstile>ab \\<and>\n                             fst (attack ab) = a \\<and>\n                             \\<turnstile>aba #\n   lista \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack ab),\n (aa # list) ! length list)\\<^esup>", "show \"list \\<noteq> [] \\<longrightarrow>\n       (\\<forall>i<length list. \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>) \\<longrightarrow>\n       \\<turnstile>(map (\\<lambda>i. \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n          [0..<length list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa, list ! (length list - Suc 0))\\<^esup>) \\<Longrightarrow>\n       Sji = aa # list \\<Longrightarrow>\n       \\<forall>i<Suc (length list). \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub> \\<Longrightarrow>\n       map (\\<lambda>i. \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>) [0..<length list] @\n       [\\<N>\\<^bsub>((a # aa # list) ! length list, (aa # list) ! length list)\\<^esub>] =\n       ab # lista \\<Longrightarrow>\n       s = (aa # list) ! length list \\<Longrightarrow>\n       case lista of [] \\<Rightarrow> \\<turnstile>ab \\<and> attack ab = (a, (aa # list) ! length list)\n       | aba # lista \\<Rightarrow>\n           \\<turnstile>ab \\<and> fst (attack ab) = a \\<and> \\<turnstile>(aba # lista \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack ab), (aa # list) ! length list)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n             (\\<forall>i<length list.\n                 \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n    list ! i)\\<^esub>) \\<longrightarrow>\n             \\<turnstile>map (\\<lambda>i.\n                                 \\<N>\\<^bsub>((aa # list) ! i,\n        list ! i)\\<^esub>)\n                          [0..<\n                           length\n                            list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                          list ! (length list - Suc 0))\\<^esup>;\n     Sji = aa # list;\n     \\<forall>i<Suc (length list).\n        \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                 (aa # list) ! i)\\<^esub>;\n     map (\\<lambda>i.\n             \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n      [0..<length list] @\n     [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                   (aa # list) ! length list)\\<^esub>] =\n     ab # lista;\n     s = (aa # list) ! length list\\<rbrakk>\n    \\<Longrightarrow> case lista of\n                      [] \\<Rightarrow>\n                        \\<turnstile>ab \\<and>\n                        attack ab = (a, (aa # list) ! length list)\n                      | aba # lista \\<Rightarrow>\n                          \\<turnstile>ab \\<and>\n                          fst (attack ab) = a \\<and>\n                          \\<turnstile>aba #\nlista \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd (attack ab),\n                                    (aa # list) ! length list)\\<^esup>", "apply (auto simp: split: list.split)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>ab\n 2. \\<And>x21 x22 x.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22; x \\<in> fst (attack ab)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a\n 3. \\<And>x21 x22 x.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fst (attack ab)\n 4. \\<And>x21 x22.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>x21 #\n                                     x22 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                                  (attack ab),\n                                 (aa # list) ! length list)\\<^esup>", "apply (metis (no_types, lifting) app_tl_hd_list length_greater_0_conv list.sel(1) list.sel(3) list.simps(3) list.simps(8) list.size(3) map_fst nth_Cons_0 self_append_conv2 upt_0 zero_less_Suc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22 x.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22; x \\<in> fst (attack ab)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> a\n 2. \\<And>x21 x22 x.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fst (attack ab)\n 3. \\<And>x21 x22.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>x21 #\n                                     x22 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                                  (attack ab),\n                                 (aa # list) ! length list)\\<^esup>", "apply (metis (no_types, lifting) app_tl_hd_list attack.simps(1) fst_conv length_greater_0_conv list.sel(1) list.sel(3) list.simps(3) list.simps(8) list.size(3) map_fst nth_Cons_0 self_append_conv2 upt_0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fst (attack ab)\n 2. \\<And>x21 x22.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>x21 #\n                                     x22 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                                  (attack ab),\n                                 (aa # list) ! length list)\\<^esup>", "apply (metis (mono_tags, lifting) app_tl_hd_list attack.simps(1) fst_conv length_greater_0_conv list.sel(1) list.sel(3) list.simps(3) list.simps(8) list.size(3) map_fst nth_Cons_0 self_append_conv2 upt_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>Sji = aa # list;\n        \\<forall>i<Suc (length list).\n           \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                                    (aa # list) ! i)\\<^esub>;\n        map (\\<lambda>i.\n                \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n         [0..<length list] @\n        [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                      (aa # list) ! length list)\\<^esub>] =\n        ab # x21 # x22;\n        s = (aa # list) ! length list;\n        \\<turnstile>map (\\<lambda>i.\n                            \\<N>\\<^bsub>((aa # list) ! i, list ! i)\\<^esub>)\n                     [0..<\n                      length\n                       list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                     list ! (length list - Suc 0))\\<^esup>;\n        lista = x21 # x22\\<rbrakk>\n       \\<Longrightarrow> \\<turnstile>x21 #\n                                     x22 \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                                  (attack ab),\n                                 (aa # list) ! length list)\\<^esup>", "by (smt * One_nat_def app_tl_hd_list attack.simps(1) length_greater_0_conv list.sel(1) list.sel(3) list.simps(3) list.simps(8) list.size(3) map_fst nth_Cons_0 nth_Cons_pos self_append_conv2 snd_conv tl_app_in tl_append2 upt_0)"], ["proof (state)\nthis:\n  \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n           (\\<forall>i<length list.\n               \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n  list ! i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>((aa # list) ! i,\n      list ! i)\\<^esub>)\n                        [0..<\n                         length\n                          list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                        list ! (length list - Suc 0))\\<^esup>;\n   Sji = aa # list;\n   \\<forall>i<Suc (length list).\n      \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                               (aa # list) ! i)\\<^esub>;\n   map (\\<lambda>i.\n           \\<N>\\<^bsub>((a # aa # list) ! i, (aa # list) ! i)\\<^esub>)\n    [0..<length list] @\n   [\\<N>\\<^bsub>((a # aa # list) ! length list,\n                 (aa # list) ! length list)\\<^esub>] =\n   ab # lista;\n   s = (aa # list) ! length list\\<rbrakk>\n  \\<Longrightarrow> case lista of\n                    [] \\<Rightarrow>\n                      \\<turnstile>ab \\<and>\n                      attack ab = (a, (aa # list) ! length list)\n                    | aba # lista \\<Rightarrow>\n                        \\<turnstile>ab \\<and>\n                        fst (attack ab) = a \\<and>\n                        \\<turnstile>aba #\n                                    lista \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                                   (attack ab),\n                                  (aa # list) ! length list)\\<^esup>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>list \\<noteq> [] \\<longrightarrow>\n           list ! (length list - Suc 0) = s \\<longrightarrow>\n           (\\<forall>i<length list.\n               \\<turnstile>\\<N>\\<^bsub>((aa # list) ! i,\n  list ! i)\\<^esub>) \\<longrightarrow>\n           \\<turnstile>map (\\<lambda>i.\n                               \\<N>\\<^bsub>((aa # list) ! i,\n      list ! i)\\<^esub>)\n                        [0..<\n                         length\n                          list] \\<oplus>\\<^sub>\\<and>\\<^bsup>(aa,\n                        s)\\<^esup>;\n   Sji = aa # list; (aa # list) ! length list = s;\n   \\<forall>i<Suc (length list).\n      \\<turnstile>\\<N>\\<^bsub>((a # aa # list) ! i,\n                               (aa # list) ! i)\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> case map (\\<lambda>i.\n                                 \\<N>\\<^bsub>((a # aa # list) ! i,\n        (aa # list) ! i)\\<^esub>)\n                          [0..<length list] @\n                         [\\<N>\\<^bsub>((a # aa # list) ! length list,\n s)\\<^esub>] of\n                    [] \\<Rightarrow> fst (a, s) \\<subseteq> snd (a, s)\n                    | [aa] \\<Rightarrow>\n                        \\<turnstile>aa \\<and> attack aa = (a, s)\n                    | aa # ab # list \\<Rightarrow>\n                        \\<turnstile>aa \\<and>\n                        fst (attack aa) = fst (a, s) \\<and>\n                        \\<turnstile>ab #\n                                    list \\<oplus>\\<^sub>\\<and>\\<^bsup>(snd\n                                  (attack aa),\n                                 snd (a, s))\\<^esup>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # Sji \\<noteq> [] \\<longrightarrow>\n  tl (a # Sji) \\<noteq> [] \\<longrightarrow>\n  (\\<forall>li.\n      (a # Sji) ! 0 = li \\<longrightarrow>\n      (a # Sji) ! (length (a # Sji) - 1) = s \\<longrightarrow>\n      (\\<forall>i<length (a # Sji) - 1.\n          \\<turnstile>\\<N>\\<^bsub>((a # Sji) ! i,\n                                   (a # Sji) !\n                                   Suc i)\\<^esub>) \\<longrightarrow>\n      \\<turnstile>map (\\<lambda>i.\n                          \\<N>\\<^bsub>((a # Sji) ! i,\n (a # Sji) ! Suc i)\\<^esub>)\n                   [0..<\n                    length (a # Sji) -\n                    Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>(li, s)\\<^esup>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Compl_step4: \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow> \\<not> I \\<subseteq> s \\<Longrightarrow>\n(\\<exists> lI. set lI = {x. x \\<in> I \\<and> x \\<notin> s} \\<and> (\\<exists> Sj :: ((('s :: state) set)list) list. \n               length Sj = length lI \\<and> nodup_all lI \\<and>\n            (\\<forall> j < length Sj. (((Sj ! j)  \\<noteq> []) \\<and> (tl (Sj ! j) \\<noteq> []) \\<and>\n                 ((Sj ! j) ! 0, (Sj ! j) ! (length (Sj ! j) - 1)) = ({lI ! j},s) \\<and>\n                 (\\<forall> i < (length (Sj ! j) - 1).  \\<turnstile> \\<N>\\<^bsub>((Sj ! j) ! i, (Sj ! j) ! (i+1) )\\<^esub>\n                         )))))\n \\<Longrightarrow>  \\<exists> (A :: ('s :: state) attree).  \\<turnstile> A \\<and> attack A = (I,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I; \\<not> I \\<subseteq> s;\n     \\<exists>lI.\n        set lI = {x \\<in> I. x \\<notin> s} \\<and>\n        (\\<exists>Sj.\n            length Sj = length lI \\<and>\n            nodup_all lI \\<and>\n            (\\<forall>j<length Sj.\n                Sj ! j \\<noteq> [] \\<and>\n                tl (Sj ! j) \\<noteq> [] \\<and>\n                (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n                ({lI ! j}, s) \\<and>\n                (\\<forall>i<length (Sj ! j) - 1.\n                    \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n       Sj ! j ! (i + 1))\\<^esub>)))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "proof (erule exE, erule conjE, erule exE, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lI Sj.\n       \\<lbrakk>I \\<noteq> {}; finite I; \\<not> I \\<subseteq> s;\n        set lI = {x \\<in> I. x \\<notin> s}; length Sj = length lI;\n        nodup_all lI \\<and>\n        (\\<forall>j<length Sj.\n            Sj ! j \\<noteq> [] \\<and>\n            tl (Sj ! j) \\<noteq> [] \\<and>\n            (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n            ({lI ! j}, s) \\<and>\n            (\\<forall>i<length (Sj ! j) - 1.\n                \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n   Sj ! j ! (i + 1))\\<^esub>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "fix lI Sj"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>lI Sj.\n       \\<lbrakk>I \\<noteq> {}; finite I; \\<not> I \\<subseteq> s;\n        set lI = {x \\<in> I. x \\<notin> s}; length Sj = length lI;\n        nodup_all lI \\<and>\n        (\\<forall>j<length Sj.\n            Sj ! j \\<noteq> [] \\<and>\n            tl (Sj ! j) \\<noteq> [] \\<and>\n            (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n            ({lI ! j}, s) \\<and>\n            (\\<forall>i<length (Sj ! j) - 1.\n                \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n   Sj ! j ! (i + 1))\\<^esub>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "assume  a: \"I \\<noteq> {}\" and b: \"finite I\" and c: \"\\<not> I \\<subseteq> s\"\n    and d: \"set lI = {x::'s \\<in> I. x \\<notin> s}\" and e: \"length Sj = length lI\"\n    and f: \"nodup_all lI \\<and> \n              (\\<forall>j<length Sj. Sj ! j \\<noteq> [] \\<and>\n                             tl (Sj ! j) \\<noteq> [] \\<and>\n           (Sj ! j ! (0), Sj ! j ! (length (Sj ! j) - (1))) = ({lI ! j}, s) \\<and>\n           (\\<forall>i<length (Sj ! j) - (1). \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! (i + (1)))\\<^esub>))\""], ["proof (state)\nthis:\n  I \\<noteq> {}\n  finite I\n  \\<not> I \\<subseteq> s\n  set lI = {x \\<in> I. x \\<notin> s}\n  length Sj = length lI\n  nodup_all lI \\<and>\n  (\\<forall>j<length Sj.\n      Sj ! j \\<noteq> [] \\<and>\n      tl (Sj ! j) \\<noteq> [] \\<and>\n      (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) = ({lI ! j}, s) \\<and>\n      (\\<forall>i<length (Sj ! j) - 1.\n          \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! (i + 1))\\<^esub>))\n\ngoal (1 subgoal):\n 1. \\<And>lI Sj.\n       \\<lbrakk>I \\<noteq> {}; finite I; \\<not> I \\<subseteq> s;\n        set lI = {x \\<in> I. x \\<notin> s}; length Sj = length lI;\n        nodup_all lI \\<and>\n        (\\<forall>j<length Sj.\n            Sj ! j \\<noteq> [] \\<and>\n            tl (Sj ! j) \\<noteq> [] \\<and>\n            (Sj ! j ! 0, Sj ! j ! (length (Sj ! j) - 1)) =\n            ({lI ! j}, s) \\<and>\n            (\\<forall>i<length (Sj ! j) - 1.\n                \\<turnstile>\\<N>\\<^bsub>(Sj ! j ! i,\n   Sj ! j ! (i + 1))\\<^esub>))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "show    \"\\<exists>A::'s attree. \\<turnstile>A \\<and> attack A = (I, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "apply (rule_tac x = \n        \"[([] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x. x \\<in> I \\<and> x \\<in> s}, s)\\<^esup>),\n    ([[ \\<N>\\<^bsub>((Sj ! j) ! i, (Sj ! j) ! (i + (1)))\\<^esub>. \n      i \\<leftarrow> [0..<(length (Sj ! j)-(1))]] \\<oplus>\\<^sub>\\<and>\\<^bsup>(({lI ! j},s))\\<^esup>. j \\<leftarrow> [0..<(length Sj)]]\n     \\<oplus>\\<^sub>\\<or>\\<^bsup>({x. x \\<in> I \\<and> x \\<notin> s},s)\\<^esup>)] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n           s)\\<^esup>,\n                 map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! (i + 1))\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                      s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup> \\<and>\n    attack\n     ([[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s}, s)\\<^esup>,\n       map (\\<lambda>j.\n               map (\\<lambda>i.\n                       \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! (i + 1))\\<^esub>)\n                [0..<\n                 length (Sj ! j) -\n                 1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>)\n        [0..<\n         length\n          Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<notin> s},\n     s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>) =\n    (I, s)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<turnstile>[[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n           s)\\<^esup>,\n                 map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! (i + 1))\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                      s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>\n 2. attack\n     ([[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s}, s)\\<^esup>,\n       map (\\<lambda>j.\n               map (\\<lambda>i.\n                       \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! (i + 1))\\<^esub>)\n                [0..<\n                 length (Sj ! j) -\n                 1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>)\n        [0..<\n         length\n          Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<notin> s},\n     s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>) =\n    (I, s)", "show  \"\\<turnstile>([[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x::'s \\<in> I. x \\<in> s}, s)\\<^esup>,\n       map (\\<lambda>j.\n               ((map (\\<lambda>i. \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! (i + (1)))\\<^esub>)\n                [0..<length (Sj ! j) - (1)]) \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>))\n       [0..<length Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x::'s \\<in> I. x \\<notin> s}, s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>[[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n           s)\\<^esup>,\n                 map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! (i + 1))\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                      s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<turnstile>[[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n           s)\\<^esup>,\n                 map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! (i + 1))\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                      s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>", "have g: \"I - {x::'s \\<in> I. x \\<in> s} = {x::'s \\<in> I. x \\<notin> s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s}", "by blast"], ["proof (state)\nthis:\n  I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s}\n\ngoal (1 subgoal):\n 1. \\<turnstile>[[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n           s)\\<^esup>,\n                 map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! (i + 1))\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                      s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>", "thus \"\\<turnstile>([[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x::'s \\<in> I. x \\<in> s}, s)\\<^esup>,\n       (map (\\<lambda>j.\n               ((map (\\<lambda>i. \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! (i + (1)))\\<^esub>)\n                [0..<length (Sj ! j) - (1)]) \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>))\n       [0..<length Sj]) \\<oplus>\\<^sub>\\<or>\\<^bsup>({x::'s \\<in> I. x \\<notin> s}, s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>)\""], ["proof (prove)\nusing this:\n  I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s}\n\ngoal (1 subgoal):\n 1. \\<turnstile>[[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n           s)\\<^esup>,\n                 map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! (i + 1))\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                      s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>", "apply (subst att_or, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n    \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n          s)\\<^esup> \\<and>\n    \\<turnstile>[map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! Suc i)\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                          s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                   x \\<notin> s},\n                  s)\\<^esup>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n    \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n          s)\\<^esup>\n 2. I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n    \\<turnstile>[map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! Suc i)\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                          s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                   x \\<notin> s},\n                  s)\\<^esup>", "show \"I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow> \\<turnstile>([] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s}, s)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n    \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n          s)\\<^esup>", "by (metis (no_types, lifting) CollectD att_or_empty_back subsetI)"], ["proof (state)\nthis:\n  I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n  \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n        s)\\<^esup>\n\ngoal (1 subgoal):\n 1. I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n    \\<turnstile>[map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! Suc i)\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                          s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                   x \\<notin> s},\n                  s)\\<^esup>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n    \\<turnstile>[map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! Suc i)\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                          s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                   x \\<notin> s},\n                  s)\\<^esup>", "show \"I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n    \\<turnstile>([map (\\<lambda>j. ((map (\\<lambda>i. \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>) [0..<length (Sj ! j) - Suc 0]) \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>))\n        [0..<length Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<notin> s}, s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<notin> s}, s)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n    \\<turnstile>[map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! Suc i)\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                          s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                   x \\<notin> s},\n                  s)\\<^esup>", "text \\<open>Use lemma @{text \\<open>list_or_upt\\<close>} to distribute attack validity  over list lI\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n    \\<turnstile>[map (\\<lambda>j.\n                         map (\\<lambda>i.\n                                 \\<N>\\<^bsub>(Sj ! j ! i,\n        Sj ! j ! Suc i)\\<^esub>)\n                          [0..<\n                           length (Sj ! j) -\n                           Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                          s)\\<^esup>)\n                  [0..<\n                   length\n                    Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                x \\<notin> s},\n               s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                   x \\<notin> s},\n                  s)\\<^esup>", "proof (erule ssubst, subst att_or, simp, rule subst, rule d, rule_tac lI = lI in list_or_upt)"], ["proof (state)\ngoal (4 subgoals):\n 1. lI \\<noteq> []\n 2. length\n     (map (\\<lambda>j.\n              map (\\<lambda>i.\n                      \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n               [0..<\n                length (Sj ! j) -\n                Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>)\n       [0..<length Sj]) =\n    length lI\n 3. nodup_all lI\n 4. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>j.\n                           map (\\<lambda>i.\n                                   \\<N>\\<^bsub>(Sj ! j ! i,\n          Sj ! j ! Suc i)\\<^esub>)\n                            [0..<\n                             length (Sj ! j) -\n                             Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                            s)\\<^esup>)\n                    [0..<length Sj] !\n                   i \\<and>\n       attack\n        (map (\\<lambda>j.\n                 map (\\<lambda>i.\n                         \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n                  [0..<\n                   length (Sj ! j) -\n                   Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                  s)\\<^esup>)\n          [0..<length Sj] !\n         i) =\n       ({lI ! i}, s)", "show \"lI \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lI \\<noteq> []", "using c d"], ["proof (prove)\nusing this:\n  \\<not> I \\<subseteq> s\n  set lI = {x \\<in> I. x \\<notin> s}\n\ngoal (1 subgoal):\n 1. lI \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  lI \\<noteq> []\n\ngoal (3 subgoals):\n 1. length\n     (map (\\<lambda>j.\n              map (\\<lambda>i.\n                      \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n               [0..<\n                length (Sj ! j) -\n                Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>)\n       [0..<length Sj]) =\n    length lI\n 2. nodup_all lI\n 3. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>j.\n                           map (\\<lambda>i.\n                                   \\<N>\\<^bsub>(Sj ! j ! i,\n          Sj ! j ! Suc i)\\<^esub>)\n                            [0..<\n                             length (Sj ! j) -\n                             Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                            s)\\<^esup>)\n                    [0..<length Sj] !\n                   i \\<and>\n       attack\n        (map (\\<lambda>j.\n                 map (\\<lambda>i.\n                         \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n                  [0..<\n                   length (Sj ! j) -\n                   Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                  s)\\<^esup>)\n          [0..<length Sj] !\n         i) =\n       ({lI ! i}, s)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. length\n     (map (\\<lambda>j.\n              map (\\<lambda>i.\n                      \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n               [0..<\n                length (Sj ! j) -\n                Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>)\n       [0..<length Sj]) =\n    length lI\n 2. nodup_all lI\n 3. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>j.\n                           map (\\<lambda>i.\n                                   \\<N>\\<^bsub>(Sj ! j ! i,\n          Sj ! j ! Suc i)\\<^esub>)\n                            [0..<\n                             length (Sj ! j) -\n                             Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                            s)\\<^esup>)\n                    [0..<length Sj] !\n                   i \\<and>\n       attack\n        (map (\\<lambda>j.\n                 map (\\<lambda>i.\n                         \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n                  [0..<\n                   length (Sj ! j) -\n                   Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                  s)\\<^esup>)\n          [0..<length Sj] !\n         i) =\n       ({lI ! i}, s)", "show \"\\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>(map (\\<lambda>j.\n                 ((map (\\<lambda>i. \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n                  [0..<length (Sj ! j) - Suc (0)]) \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>))\n          [0..<length Sj] !\n         i) \\<and>\n       (attack\n        (map (\\<lambda>j.\n                 ((map (\\<lambda>i. \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n                  [0..<length (Sj ! j) - Suc (0)]) \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>))\n          [0..<length Sj] !\n         i) =\n       ({lI ! i}, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>j.\n                           map (\\<lambda>i.\n                                   \\<N>\\<^bsub>(Sj ! j ! i,\n          Sj ! j ! Suc i)\\<^esub>)\n                            [0..<\n                             length (Sj ! j) -\n                             Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                            s)\\<^esup>)\n                    [0..<length Sj] !\n                   i \\<and>\n       attack\n        (map (\\<lambda>j.\n                 map (\\<lambda>i.\n                         \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n                  [0..<\n                   length (Sj ! j) -\n                   Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                  s)\\<^esup>)\n          [0..<length Sj] !\n         i) =\n       ({lI ! i}, s)", "proof (simp add: a b c d e f)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>ia.\n                           \\<N>\\<^bsub>(Sj ! i ! ia,\n  Sj ! i ! Suc ia)\\<^esub>)\n                    [0..<\n                     length (Sj ! i) -\n                     Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i},\n                    s)\\<^esup>", "show \"\\<And>i.\n                i < length lI \\<Longrightarrow>\n                \\<turnstile>(map (\\<lambda>ia. \\<N>\\<^bsub>(Sj ! i ! ia, Sj ! i ! Suc ia)\\<^esub>)\n                [0..<length (Sj ! i) - Suc (0)] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i}, s)\\<^esup>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>ia.\n                           \\<N>\\<^bsub>(Sj ! i ! ia,\n  Sj ! i ! Suc ia)\\<^esub>)\n                    [0..<\n                     length (Sj ! i) -\n                     Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i},\n                    s)\\<^esup>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>ia.\n                           \\<N>\\<^bsub>(Sj ! i ! ia,\n  Sj ! i ! Suc ia)\\<^esub>)\n                    [0..<\n                     length (Sj ! i) -\n                     Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i},\n                    s)\\<^esup>", "fix i :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>ia.\n                           \\<N>\\<^bsub>(Sj ! i ! ia,\n  Sj ! i ! Suc ia)\\<^esub>)\n                    [0..<\n                     length (Sj ! i) -\n                     Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i},\n                    s)\\<^esup>", "assume a1: \"i < length lI\""], ["proof (state)\nthis:\n  i < length lI\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>ia.\n                           \\<N>\\<^bsub>(Sj ! i ! ia,\n  Sj ! i ! Suc ia)\\<^esub>)\n                    [0..<\n                     length (Sj ! i) -\n                     Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i},\n                    s)\\<^esup>", "have \"\\<forall>n. \\<turnstile>map (\\<lambda>na. \\<N>\\<^bsub>(Sj ! n ! na, Sj ! n ! Suc na)\\<^esub>) [0..< length (Sj ! n) - 1] \\<oplus>\\<^sub>\\<and>\\<^bsup>(Sj ! n ! 0, Sj ! n ! (length (Sj ! n) - 1))\\<^esup> \\<or> \\<not> n < length Sj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<turnstile>map (\\<lambda>na.\n                           \\<N>\\<^bsub>(Sj ! n ! na,\n  Sj ! n ! Suc na)\\<^esub>)\n                    [0..<\n                     length (Sj ! n) -\n                     1] \\<oplus>\\<^sub>\\<and>\\<^bsup>(Sj ! n ! 0,\n                Sj ! n ! (length (Sj ! n) - 1))\\<^esup> \\<or>\n       \\<not> n < length Sj", "by (metis (no_types) One_nat_def add.right_neutral add_Suc_right base_list_and f)"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<turnstile>map (\\<lambda>na.\n                         \\<N>\\<^bsub>(Sj ! n ! na, Sj ! n ! Suc na)\\<^esub>)\n                  [0..<\n                   length (Sj ! n) -\n                   1] \\<oplus>\\<^sub>\\<and>\\<^bsup>(Sj ! n ! 0,\n              Sj ! n ! (length (Sj ! n) - 1))\\<^esup> \\<or>\n     \\<not> n < length Sj\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length lI \\<Longrightarrow>\n       \\<turnstile>map (\\<lambda>ia.\n                           \\<N>\\<^bsub>(Sj ! i ! ia,\n  Sj ! i ! Suc ia)\\<^esub>)\n                    [0..<\n                     length (Sj ! i) -\n                     Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i},\n                    s)\\<^esup>", "then"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     \\<turnstile>map (\\<lambda>na.\n                         \\<N>\\<^bsub>(Sj ! n ! na, Sj ! n ! Suc na)\\<^esub>)\n                  [0..<\n                   length (Sj ! n) -\n                   1] \\<oplus>\\<^sub>\\<and>\\<^bsup>(Sj ! n ! 0,\n              Sj ! n ! (length (Sj ! n) - 1))\\<^esup> \\<or>\n     \\<not> n < length Sj", "show \"\\<turnstile>map (\\<lambda>n. \\<N>\\<^bsub>(Sj ! i ! n, Sj ! i ! Suc n)\\<^esub>) [0..< length (Sj ! i) - Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i}, s)\\<^esup>\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     \\<turnstile>map (\\<lambda>na.\n                         \\<N>\\<^bsub>(Sj ! n ! na, Sj ! n ! Suc na)\\<^esub>)\n                  [0..<\n                   length (Sj ! n) -\n                   1] \\<oplus>\\<^sub>\\<and>\\<^bsup>(Sj ! n ! 0,\n              Sj ! n ! (length (Sj ! n) - 1))\\<^esup> \\<or>\n     \\<not> n < length Sj\n\ngoal (1 subgoal):\n 1. \\<turnstile>map (\\<lambda>n.\n                        \\<N>\\<^bsub>(Sj ! i ! n, Sj ! i ! Suc n)\\<^esub>)\n                 [0..<\n                  length (Sj ! i) -\n                  Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i}, s)\\<^esup>", "using a1"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     \\<turnstile>map (\\<lambda>na.\n                         \\<N>\\<^bsub>(Sj ! n ! na, Sj ! n ! Suc na)\\<^esub>)\n                  [0..<\n                   length (Sj ! n) -\n                   1] \\<oplus>\\<^sub>\\<and>\\<^bsup>(Sj ! n ! 0,\n              Sj ! n ! (length (Sj ! n) - 1))\\<^esup> \\<or>\n     \\<not> n < length Sj\n  i < length lI\n\ngoal (1 subgoal):\n 1. \\<turnstile>map (\\<lambda>n.\n                        \\<N>\\<^bsub>(Sj ! i ! n, Sj ! i ! Suc n)\\<^esub>)\n                 [0..<\n                  length (Sj ! i) -\n                  Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i}, s)\\<^esup>", "by (metis (no_types) One_nat_def e f)"], ["proof (state)\nthis:\n  \\<turnstile>map (\\<lambda>n.\n                      \\<N>\\<^bsub>(Sj ! i ! n, Sj ! i ! Suc n)\\<^esub>)\n               [0..<\n                length (Sj ! i) -\n                Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! i}, s)\\<^esup>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length lI \\<Longrightarrow>\n  \\<turnstile>map (\\<lambda>ia.\n                      \\<N>\\<^bsub>(Sj ! ?i ! ia, Sj ! ?i ! Suc ia)\\<^esub>)\n               [0..<\n                length (Sj ! ?i) -\n                Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! ?i}, s)\\<^esup>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length lI \\<Longrightarrow>\n  \\<turnstile>map (\\<lambda>j.\n                      map (\\<lambda>i.\n                              \\<N>\\<^bsub>(Sj ! j ! i,\n     Sj ! j ! Suc i)\\<^esub>)\n                       [0..<\n                        length (Sj ! j) -\n                        Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                       s)\\<^esup>)\n               [0..<length Sj] !\n              ?i \\<and>\n  attack\n   (map (\\<lambda>j.\n            map (\\<lambda>i.\n                    \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n             [0..<\n              length (Sj ! j) -\n              Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>)\n     [0..<length Sj] !\n    ?i) =\n  ({lI ! ?i}, s)\n\ngoal (2 subgoals):\n 1. length\n     (map (\\<lambda>j.\n              map (\\<lambda>i.\n                      \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! Suc i)\\<^esub>)\n               [0..<\n                length (Sj ! j) -\n                Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>)\n       [0..<length Sj]) =\n    length lI\n 2. nodup_all lI", "qed (auto simp add: e f)"], ["proof (state)\nthis:\n  I - {x \\<in> I. x \\<in> s} = {x \\<in> I. x \\<notin> s} \\<Longrightarrow>\n  \\<turnstile>[map (\\<lambda>j.\n                       map (\\<lambda>i.\n                               \\<N>\\<^bsub>(Sj ! j ! i,\n      Sj ! j ! Suc i)\\<^esub>)\n                        [0..<\n                         length (Sj ! j) -\n                         Suc 0] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                        s)\\<^esup>)\n                [0..<\n                 length\n                  Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n              x \\<notin> s},\n             s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n                 x \\<notin> s},\n                s)\\<^esup>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile>[[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n         s)\\<^esup>,\n               map (\\<lambda>j.\n                       map (\\<lambda>i.\n                               \\<N>\\<^bsub>(Sj ! j ! i,\n      Sj ! j ! (i + 1))\\<^esub>)\n                        [0..<\n                         length (Sj ! j) -\n                         1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                    s)\\<^esup>)\n                [0..<\n                 length\n                  Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n              x \\<notin> s},\n             s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<turnstile>[[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s},\n         s)\\<^esup>,\n               map (\\<lambda>j.\n                       map (\\<lambda>i.\n                               \\<N>\\<^bsub>(Sj ! j ! i,\n      Sj ! j ! (i + 1))\\<^esub>)\n                        [0..<\n                         length (Sj ! j) -\n                         1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j},\n                    s)\\<^esup>)\n                [0..<\n                 length\n                  Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I.\n              x \\<notin> s},\n             s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>\n\ngoal (1 subgoal):\n 1. attack\n     ([[] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<in> s}, s)\\<^esup>,\n       map (\\<lambda>j.\n               map (\\<lambda>i.\n                       \\<N>\\<^bsub>(Sj ! j ! i, Sj ! j ! (i + 1))\\<^esub>)\n                [0..<\n                 length (Sj ! j) -\n                 1] \\<oplus>\\<^sub>\\<and>\\<^bsup>({lI ! j}, s)\\<^esup>)\n        [0..<\n         length\n          Sj] \\<oplus>\\<^sub>\\<or>\\<^bsup>({x \\<in> I. x \\<notin> s},\n     s)\\<^esup>] \\<oplus>\\<^sub>\\<or>\\<^bsup>(I, s)\\<^esup>) =\n    (I, s)", "qed auto"], ["proof (state)\nthis:\n  \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Main Theorem Completeness\\<close>"], ["", "theorem Completeness: \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow> \nKripke {s :: ('s :: state). \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} (I :: ('s :: state)set)  \\<turnstile> EF s \n\\<Longrightarrow> \\<exists> (A :: ('s :: state) attree). \\<turnstile> A \\<and> attack A = (I,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n      I \\<turnstile> EF s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "proof (case_tac \"I \\<subseteq> s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n      I \\<turnstile> EF s;\n     I \\<subseteq> s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)\n 2. \\<lbrakk>I \\<noteq> {}; finite I;\n     Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n      I \\<turnstile> EF s;\n     \\<not> I \\<subseteq> s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "show \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow>\n    Kripke {s::'s. \\<exists>i::'s\\<in>I. i \\<rightarrow>\\<^sub>i* s} I \\<turnstile> EF s \\<Longrightarrow> I \\<subseteq> s \\<Longrightarrow> \\<exists>A::'s attree. \\<turnstile>A \\<and> attack A = (I, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n      I \\<turnstile> EF s;\n     I \\<subseteq> s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "using att_or_empty_back attack.simps(3)"], ["proof (prove)\nusing this:\n  ?s' \\<subseteq> ?s'' \\<Longrightarrow>\n  \\<turnstile>[] \\<oplus>\\<^sub>\\<or>\\<^bsup>(?s', ?s'')\\<^esup>\n  attack (?as \\<oplus>\\<^sub>\\<or>\\<^bsup>?s\\<^esup>) = ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n      I \\<turnstile> EF s;\n     I \\<subseteq> s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>I \\<noteq> {}; finite I;\n   Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n    I \\<turnstile> EF s;\n   I \\<subseteq> s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n      I \\<turnstile> EF s;\n     \\<not> I \\<subseteq> s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n      I \\<turnstile> EF s;\n     \\<not> I \\<subseteq> s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "show \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow>\n    Kripke {s::'s. \\<exists>i::'s\\<in>I. i \\<rightarrow>\\<^sub>i* s} I \\<turnstile> EF s \\<Longrightarrow> \\<not> I \\<subseteq> s \n   \\<Longrightarrow> \\<exists>A::'s attree. \\<turnstile>A \\<and> attack A = (I, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n      I \\<turnstile> EF s;\n     \\<not> I \\<subseteq> s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)", "by (iprover intro: Compl_step1 Compl_step2 Compl_step3 Compl_step4 elim: )"], ["proof (state)\nthis:\n  \\<lbrakk>I \\<noteq> {}; finite I;\n   Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n    I \\<turnstile> EF s;\n   \\<not> I \\<subseteq> s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (I, s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Contrapositions of Correctness and Completeness\\<close>"], ["", "lemma contrapos_compl: \n  \"I \\<noteq> {} \\<Longrightarrow> finite I \\<Longrightarrow> \n  (\\<not> (\\<exists> (A :: ('s :: state) attree). \\<turnstile> A \\<and> attack A = (I, - s))) \\<Longrightarrow>\n\\<not> (Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s} I \\<turnstile> EF (- s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     \\<nexists>A. \\<turnstile>A \\<and> attack A = (I, - s)\\<rbrakk>\n    \\<Longrightarrow> \\<not> Kripke\n                              {s. \\<exists>i\\<in>I.\n                                     i \\<rightarrow>\\<^sub>i* s}\n                              I \\<turnstile> EF (- s)", "using Completeness"], ["proof (prove)\nusing this:\n  \\<lbrakk>?I \\<noteq> {}; finite ?I;\n   Kripke {s. \\<exists>i\\<in>?I. i \\<rightarrow>\\<^sub>i* s}\n    ?I \\<turnstile> EF ?s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>A. \\<turnstile>A \\<and> attack A = (?I, ?s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I \\<noteq> {}; finite I;\n     \\<nexists>A. \\<turnstile>A \\<and> attack A = (I, - s)\\<rbrakk>\n    \\<Longrightarrow> \\<not> Kripke\n                              {s. \\<exists>i\\<in>I.\n                                     i \\<rightarrow>\\<^sub>i* s}\n                              I \\<turnstile> EF (- s)", "by auto"], ["", "lemma contrapos_corr:   \n\"(\\<not>(Kripke {s :: ('s :: state). \\<exists> i \\<in> I. (i \\<rightarrow>\\<^sub>i* s)} I  \\<turnstile> EF s))\n\\<Longrightarrow> attack A = (I,s) \n\\<Longrightarrow> \\<not> (\\<turnstile> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n                     I \\<turnstile> EF s;\n     attack A = (I, s)\\<rbrakk>\n    \\<Longrightarrow> \\<not> \\<turnstile>A", "using AT_EF"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<turnstile>?A; attack ?A = (?I, ?s)\\<rbrakk>\n  \\<Longrightarrow> Kripke\n                     {s. \\<exists>i\\<in>?I. i \\<rightarrow>\\<^sub>i* s}\n                     ?I \\<turnstile> EF ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> Kripke {s. \\<exists>i\\<in>I. i \\<rightarrow>\\<^sub>i* s}\n                     I \\<turnstile> EF s;\n     attack A = (I, s)\\<rbrakk>\n    \\<Longrightarrow> \\<not> \\<turnstile>A", "by blast"], ["", "end"]]}