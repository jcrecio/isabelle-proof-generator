{"file_name": "/home/qj213/afp-2021-10-22/thys/FLP/Execution.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FLP", "problem_names": ["lemma FirstOccurrenceExists:\nassumes\n  \"enabled (last exec) msg\"\n  \"\\<exists>p. isReceiverOf p msg\"\nshows\n  \"\\<exists> n . firstOccurrence msg n\"", "lemma ReachableInExecution:\nassumes\n  \"i < length exec\"\n  \"j \\<le> i\"\nshows\n  \"reachable (execConf j) (execConf i)\"", "lemma LastPoint:\nfixes\n  msg::\"('p, 'v) message\"\nassumes\n  \"enabled (last exec) msg\"\nobtains n where\n  \"n < length exec\"\n  \"enabled (execConf n) msg\"\n  \"\\<forall> n' \\<ge> n .\n    n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n')\"\n  \"\\<forall> n0 . \n      n0 < length exec \n    \\<and> enabled (execConf n0) msg \n    \\<and> (\\<forall> n' \\<ge> n0 .\n        n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n'))\n    \\<longrightarrow> n0 \\<ge> n\"", "lemma ExistImpliesMinEnabled:\nfixes \n  msg :: \"('p, 'v) message\" and\n  p :: 'p\nassumes \n  \"isReceiverOf p msg\" \n  \"enabled (last exec) msg\"\nshows\n  \"\\<exists> msg' . minimalEnabled msg'\"", "lemma StaysEnabledStep:\nassumes\n  En: \"enabled cfg msg\" and\n  Cfg: \"cfg = exec ! n\" and\n  N: \"n < length exec\" \nshows\n  \"enabled (exec ! (n + 1)) msg \n  \\<or> n = (length exec - 1) \n  \\<or> msg = trace ! n\"", "lemma StaysEnabledHelp:\nassumes\n  \"enabled cfg msg\" and\n  \"cfg = exec ! n\" and\n  \"n < length exec\"    \nshows \n  \"\\<forall> i . i \\<ge> n \\<and> i < (length exec - 1) \\<and> enabled (exec ! i) msg \n  \\<longrightarrow> msg = (trace ! i) \\<or> (enabled (exec ! (i+1)) msg)\"", "lemma StaysEnabled:\nassumes En: \"enabled cfg msg\" and\n  \"cfg = exec ! n\" and\n  \"n < length exec\"   \nshows \"enabled (last exec) msg \\<or> (\\<exists> i . i \\<ge> n \\<and> i < (length exec - 1) \n  \\<and> msg = trace ! i )\"", "lemma (in asynchronousSystem) expandExecutionStep:\nfixes \n  cfg :: \"('p, 'v, 's ) configuration\"\nassumes\n  CfgIsReachable: \"(last exec') \\<turnstile> msg \\<mapsto> cMsg\" and\n  ExecIsExecution: \"execution trans sends start exec' trace'\" \nshows\n  \"\\<exists> exec'' trace''. (execution trans sends start exec'' trace'') \n  \\<and> (prefixList exec' exec'') \n  \\<and> (prefixList trace' trace'') \n  \\<and> (last exec'') = cMsg \n  \\<and> (last trace'' = msg)\"", "lemma (in asynchronousSystem) expandExecutionReachable:\nfixes \n  cfg :: \"('p, 'v, 's ) configuration\" and\n  cfgLast :: \"('p, 'v, 's ) configuration\"\nassumes\n  CfgIsReachable: \"reachable (cfgLast) cfg\" and\n  ExecIsExecution: \"execution trans sends start exec trace\"  and\n  ExecLast: \"cfgLast = last exec\" \nshows\n  \"\\<exists> exec' trace'. (execution trans sends start exec' trace') \n  \\<and> ((prefixList exec exec' \n    \\<and> prefixList trace trace') \n    \\<or> (exec = exec' \\<and> trace = trace')) \n  \\<and> (last exec') = cfg\"", "lemma (in asynchronousSystem) expandExecution:\nfixes \n  cfg :: \"('p, 'v, 's ) configuration\" and\n  cfgLast :: \"('p, 'v, 's ) configuration\"\nassumes\n  CfgIsReachable: \"stepReachable (last exec) msg cfg\" and\n  ExecIsExecution: \"execution trans sends start exec trace\"\nshows\n  \"\\<exists> exec' trace'. (execution trans sends start exec' trace') \n  \\<and> (prefixList exec exec') \n  \\<and> (prefixList trace trace') \\<and> (last exec') = cfg \n  \\<and> (msg \\<in> set (drop (length trace) trace'))\""], "translations": [["", "lemma FirstOccurrenceExists:\nassumes\n  \"enabled (last exec) msg\"\n  \"\\<exists>p. isReceiverOf p msg\"\nshows\n  \"\\<exists> n . firstOccurrence msg n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "have \"length exec - 1 < length exec \n    \\<and> (\\<forall> n' \\<ge> (length exec - 1) . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length exec - 1 < length exec \\<and>\n    (\\<forall>n'\\<ge>length exec - 1.\n        n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)", "using length"], ["proof (prove)\nusing this:\n  length exec - 1 = length trace\n\ngoal (1 subgoal):\n 1. length exec - 1 < length exec \\<and>\n    (\\<forall>n'\\<ge>length exec - 1.\n        n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)", "by (metis diff_diff_cancel leD notEmpty zero_less_diff \n      zero_less_one)"], ["proof (state)\nthis:\n  length exec - 1 < length exec \\<and>\n  (\\<forall>n'\\<ge>length exec - 1.\n      n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "hence NNotInTrace: \"\\<exists> n < length exec . \n    (\\<forall> n'\\<ge>n . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg)\""], ["proof (prove)\nusing this:\n  length exec - 1 < length exec \\<and>\n  (\\<forall>n'\\<ge>length exec - 1.\n      n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n\ngoal (1 subgoal):\n 1. \\<exists>n<length exec.\n       \\<forall>n'\\<ge>n.\n          n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg", "by blast"], ["proof (state)\nthis:\n  \\<exists>n<length exec.\n     \\<forall>n'\\<ge>n.\n        n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "hence \"\\<exists> n0 < length exec . \n    (\\<forall> n'\\<ge>n0 . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg) \\<and>\n    ((n0 = 0) \n      \\<or> \\<not> (\\<forall> n' \\<ge> (n0 - 1) . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg))\""], ["proof (prove)\nusing this:\n  \\<exists>n<length exec.\n     \\<forall>n'\\<ge>n.\n        n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n\ngoal (1 subgoal):\n 1. \\<exists>n0<length exec.\n       (\\<forall>n'\\<ge>n0.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       (n0 = 0 \\<or>\n        \\<not> (\\<forall>n'\\<ge>n0 - 1.\n                   n' < length trace \\<longrightarrow>\n                   execMsg n' \\<noteq> msg))", "using MinPredicate2[of \"\\<lambda>x.(x < length exec \n      \\<and> (\\<forall>n'\\<ge>x.(n'<length trace \\<longrightarrow> trace ! n' \\<noteq> msg)))\"]"], ["proof (prove)\nusing this:\n  \\<exists>n<length exec.\n     \\<forall>n'\\<ge>n.\n        n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  \\<exists>n<length exec.\n     \\<forall>n'\\<ge>n.\n        n' < length trace \\<longrightarrow>\n        execMsg n' \\<noteq> msg \\<Longrightarrow>\n  \\<exists>n0.\n     (n0 < length exec \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          execMsg n' \\<noteq> msg)) \\<and>\n     (n0 = 0 \\<or>\n      \\<not> (n0 - 1 < length exec \\<and>\n              (\\<forall>n'\\<ge>n0 - 1.\n                  n' < length trace \\<longrightarrow>\n                  execMsg n' \\<noteq> msg)))\n\ngoal (1 subgoal):\n 1. \\<exists>n0<length exec.\n       (\\<forall>n'\\<ge>n0.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       (n0 = 0 \\<or>\n        \\<not> (\\<forall>n'\\<ge>n0 - 1.\n                   n' < length trace \\<longrightarrow>\n                   execMsg n' \\<noteq> msg))", "by auto"], ["proof (state)\nthis:\n  \\<exists>n0<length exec.\n     (\\<forall>n'\\<ge>n0.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     (n0 = 0 \\<or>\n      \\<not> (\\<forall>n'\\<ge>n0 - 1.\n                 n' < length trace \\<longrightarrow>\n                 execMsg n' \\<noteq> msg))\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "hence \"\\<exists> n0. n0 < length exec \n    \\<and> (\\<forall> n'\\<ge>n0 . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg) \n    \\<and> ((n0 = 0) \n      \\<or> \\<not> (\\<forall> n' \\<ge> (n0 - 1) . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg))\""], ["proof (prove)\nusing this:\n  \\<exists>n0<length exec.\n     (\\<forall>n'\\<ge>n0.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     (n0 = 0 \\<or>\n      \\<not> (\\<forall>n'\\<ge>n0 - 1.\n                 n' < length trace \\<longrightarrow>\n                 execMsg n' \\<noteq> msg))\n\ngoal (1 subgoal):\n 1. \\<exists>n0<length exec.\n       (\\<forall>n'\\<ge>n0.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       (n0 = 0 \\<or>\n        \\<not> (\\<forall>n'\\<ge>n0 - 1.\n                   n' < length trace \\<longrightarrow>\n                   execMsg n' \\<noteq> msg))", "by simp"], ["proof (state)\nthis:\n  \\<exists>n0<length exec.\n     (\\<forall>n'\\<ge>n0.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     (n0 = 0 \\<or>\n      \\<not> (\\<forall>n'\\<ge>n0 - 1.\n                 n' < length trace \\<longrightarrow>\n                 execMsg n' \\<noteq> msg))\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "from this"], ["proof (chain)\npicking this:\n  \\<exists>n0<length exec.\n     (\\<forall>n'\\<ge>n0.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     (n0 = 0 \\<or>\n      \\<not> (\\<forall>n'\\<ge>n0 - 1.\n                 n' < length trace \\<longrightarrow>\n                 execMsg n' \\<noteq> msg))", "obtain n0 where N0a: \"n0 < length exec \n    \\<and> (\\<forall> n'\\<ge>n0 . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg) \n    \\<and> ((n0 = 0) \n      \\<or> \\<not> (\\<forall> n' \\<ge> (n0 - 1) . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg))\""], ["proof (prove)\nusing this:\n  \\<exists>n0<length exec.\n     (\\<forall>n'\\<ge>n0.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     (n0 = 0 \\<or>\n      \\<not> (\\<forall>n'\\<ge>n0 - 1.\n                 n' < length trace \\<longrightarrow>\n                 execMsg n' \\<noteq> msg))\n\ngoal (1 subgoal):\n 1. (\\<And>n0.\n        n0 < length exec \\<and>\n        (\\<forall>n'\\<ge>n0.\n            n' < length trace \\<longrightarrow>\n            execMsg n' \\<noteq> msg) \\<and>\n        (n0 = 0 \\<or>\n         \\<not> (\\<forall>n'\\<ge>n0 - 1.\n                    n' < length trace \\<longrightarrow>\n                    execMsg n' \\<noteq> msg)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  n0 < length exec \\<and>\n  (\\<forall>n'\\<ge>n0.\n      n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n  (n0 = 0 \\<or>\n   \\<not> (\\<forall>n'\\<ge>n0 - 1.\n              n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg))\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "hence N0: \"n0 < length exec\" \n    \"(\\<forall> n'\\<ge>n0 . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg)\"\n    \"((n0 = 0) \n      \\<or> \\<not> (\\<forall> n' \\<ge> (n0 - 1) . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg))\""], ["proof (prove)\nusing this:\n  n0 < length exec \\<and>\n  (\\<forall>n'\\<ge>n0.\n      n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n  (n0 = 0 \\<or>\n   \\<not> (\\<forall>n'\\<ge>n0 - 1.\n              n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg))\n\ngoal (1 subgoal):\n 1. n0 < length exec &&&\n    \\<forall>n'\\<ge>n0.\n       n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg &&&\n    n0 = 0 \\<or>\n    \\<not> (\\<forall>n'\\<ge>n0 - 1.\n               n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)", "using N0a"], ["proof (prove)\nusing this:\n  n0 < length exec \\<and>\n  (\\<forall>n'\\<ge>n0.\n      n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n  (n0 = 0 \\<or>\n   \\<not> (\\<forall>n'\\<ge>n0 - 1.\n              n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg))\n  n0 < length exec \\<and>\n  (\\<forall>n'\\<ge>n0.\n      n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n  (n0 = 0 \\<or>\n   \\<not> (\\<forall>n'\\<ge>n0 - 1.\n              n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg))\n\ngoal (1 subgoal):\n 1. n0 < length exec &&&\n    \\<forall>n'\\<ge>n0.\n       n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg &&&\n    n0 = 0 \\<or>\n    \\<not> (\\<forall>n'\\<ge>n0 - 1.\n               n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)", "by auto"], ["proof (state)\nthis:\n  n0 < length exec\n  \\<forall>n'\\<ge>n0.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  n0 = 0 \\<or>\n  \\<not> (\\<forall>n'\\<ge>n0 - 1.\n             n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "have N0': \"n0 = 0 \\<or> trace ! (n0 - 1) = msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n0 = 0 \\<or> execMsg (n0 - 1) = msg", "proof(cases \"n0 = 0\", auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < n0 \\<Longrightarrow> execMsg (n0 - Suc 0) = msg", "assume N0NotZero: \"n0 > 0\""], ["proof (state)\nthis:\n  0 < n0\n\ngoal (1 subgoal):\n 1. 0 < n0 \\<Longrightarrow> execMsg (n0 - Suc 0) = msg", "hence \"\\<not> (\\<forall> n' \\<ge> (n0 - 1) . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg)\""], ["proof (prove)\nusing this:\n  0 < n0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n'\\<ge>n0 - 1.\n               n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)", "using N0(3)"], ["proof (prove)\nusing this:\n  0 < n0\n  n0 = 0 \\<or>\n  \\<not> (\\<forall>n'\\<ge>n0 - 1.\n             n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n'\\<ge>n0 - 1.\n               n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<forall>n'\\<ge>n0 - 1.\n             n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n\ngoal (1 subgoal):\n 1. 0 < n0 \\<Longrightarrow> execMsg (n0 - Suc 0) = msg", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<forall>n'\\<ge>n0 - 1.\n             n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n\ngoal (1 subgoal):\n 1. 0 < n0 \\<Longrightarrow> execMsg (n0 - Suc 0) = msg", "have \"n0 - 1 < length trace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n0 - 1 < length trace", "using N0(1) length N0NotZero"], ["proof (prove)\nusing this:\n  n0 < length exec\n  length exec - 1 = length trace\n  0 < n0\n\ngoal (1 subgoal):\n 1. n0 - 1 < length trace", "by (metis calculation le_less_trans)"], ["proof (state)\nthis:\n  n0 - 1 < length trace\n\ngoal (1 subgoal):\n 1. 0 < n0 \\<Longrightarrow> execMsg (n0 - Suc 0) = msg", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>n'\\<ge>n0 - 1.\n             n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n  n0 - 1 < length trace", "show \"execMsg (n0 - Suc 0) = msg\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>n'\\<ge>n0 - 1.\n             n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n  n0 - 1 < length trace\n\ngoal (1 subgoal):\n 1. execMsg (n0 - Suc 0) = msg", "using N0(2)"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>n'\\<ge>n0 - 1.\n             n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n  n0 - 1 < length trace\n  \\<forall>n'\\<ge>n0.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n\ngoal (1 subgoal):\n 1. execMsg (n0 - Suc 0) = msg", "by (metis One_nat_def Suc_diff_Suc diff_Suc_eq_diff_pred \n         diff_diff_cancel diff_is_0_eq leI nat_le_linear)"], ["proof (state)\nthis:\n  execMsg (n0 - Suc 0) = msg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n0 = 0 \\<or> execMsg (n0 - 1) = msg\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "have \"\\<exists> n1 < length exec . \n    (\\<forall> n'\\<ge>n1 . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg) \n    \\<and> enabled (exec ! n1) msg \n    \\<and> (n1 = 0 \\<or> \\<not> enabled (exec ! (n1 - 1)) msg \\<or> trace ! (n1 - 1) = msg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "proof(cases \"enabled (exec ! n0) msg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)\n 2. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "assume \"enabled (execConf n0) msg\""], ["proof (state)\nthis:\n  enabled (execConf n0) msg\n\ngoal (2 subgoals):\n 1. enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)\n 2. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "hence \"n0 < length exec\" \n      \"(\\<forall> n'\\<ge>n0 . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg)\" \n      \"enabled (exec ! n0) msg \\<and>\n      (n0 = 0 \\<or> \\<not> enabled (exec ! (n0 - 1)) msg \\<or> trace ! (n0 - 1) = msg)\""], ["proof (prove)\nusing this:\n  enabled (execConf n0) msg\n\ngoal (1 subgoal):\n 1. n0 < length exec &&&\n    \\<forall>n'\\<ge>n0.\n       n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg &&&\n    enabled (execConf n0) msg \\<and>\n    (n0 = 0 \\<or>\n     \\<not> enabled (execConf (n0 - 1)) msg \\<or> execMsg (n0 - 1) = msg)", "using N0 N0'"], ["proof (prove)\nusing this:\n  enabled (execConf n0) msg\n  n0 < length exec\n  \\<forall>n'\\<ge>n0.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  n0 = 0 \\<or>\n  \\<not> (\\<forall>n'\\<ge>n0 - 1.\n             n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg)\n  n0 = 0 \\<or> execMsg (n0 - 1) = msg\n\ngoal (1 subgoal):\n 1. n0 < length exec &&&\n    \\<forall>n'\\<ge>n0.\n       n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg &&&\n    enabled (execConf n0) msg \\<and>\n    (n0 = 0 \\<or>\n     \\<not> enabled (execConf (n0 - 1)) msg \\<or> execMsg (n0 - 1) = msg)", "by auto"], ["proof (state)\nthis:\n  n0 < length exec\n  \\<forall>n'\\<ge>n0.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  enabled (execConf n0) msg \\<and>\n  (n0 = 0 \\<or>\n   \\<not> enabled (execConf (n0 - 1)) msg \\<or> execMsg (n0 - 1) = msg)\n\ngoal (2 subgoals):\n 1. enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)\n 2. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "thus \"\\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1. n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \n       \\<and> enabled (execConf n1) msg \n       \\<and> (n1 = 0 \\<or> \\<not> enabled (execConf (n1 - 1)) msg \n         \\<or> execMsg (n1 - 1) = msg)\""], ["proof (prove)\nusing this:\n  n0 < length exec\n  \\<forall>n'\\<ge>n0.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  enabled (execConf n0) msg \\<and>\n  (n0 = 0 \\<or>\n   \\<not> enabled (execConf (n0 - 1)) msg \\<or> execMsg (n0 - 1) = msg)\n\ngoal (1 subgoal):\n 1. \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "by metis"], ["proof (state)\nthis:\n  \\<exists>n1<length exec.\n     (\\<forall>n'\\<ge>n1.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     enabled (execConf n1) msg \\<and>\n     (n1 = 0 \\<or>\n      \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "assume NotEnabled: \"\\<not> enabled (execConf n0) msg\""], ["proof (state)\nthis:\n  \\<not> enabled (execConf n0) msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "have \"last exec = exec ! (length exec - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last exec = execConf (length exec - 1)", "using last_conv_nth notEmpty"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> last ?xs = ?xs ! (length ?xs - 1)\n  1 \\<le> length exec\n\ngoal (1 subgoal):\n 1. last exec = execConf (length exec - 1)", "by (metis NNotInTrace length_0_conv less_nat_zero_code)"], ["proof (state)\nthis:\n  last exec = execConf (length exec - 1)\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "hence EnabledInLast: \"enabled (exec ! (length exec - 1)) msg\""], ["proof (prove)\nusing this:\n  last exec = execConf (length exec - 1)\n\ngoal (1 subgoal):\n 1. enabled (execConf (length exec - 1)) msg", "using assms(1)"], ["proof (prove)\nusing this:\n  last exec = execConf (length exec - 1)\n  enabled (last exec) msg\n\ngoal (1 subgoal):\n 1. enabled (execConf (length exec - 1)) msg", "by simp"], ["proof (state)\nthis:\n  enabled (execConf (length exec - 1)) msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "hence \"n0 \\<noteq> length exec - 1\""], ["proof (prove)\nusing this:\n  enabled (execConf (length exec - 1)) msg\n\ngoal (1 subgoal):\n 1. n0 \\<noteq> length exec - 1", "using NotEnabled"], ["proof (prove)\nusing this:\n  enabled (execConf (length exec - 1)) msg\n  \\<not> enabled (execConf n0) msg\n\ngoal (1 subgoal):\n 1. n0 \\<noteq> length exec - 1", "by auto"], ["proof (state)\nthis:\n  n0 \\<noteq> length exec - 1\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "hence N0Small: \"n0 < length exec - 1\""], ["proof (prove)\nusing this:\n  n0 \\<noteq> length exec - 1\n\ngoal (1 subgoal):\n 1. n0 < length exec - 1", "using N0(1)"], ["proof (prove)\nusing this:\n  n0 \\<noteq> length exec - 1\n  n0 < length exec\n\ngoal (1 subgoal):\n 1. n0 < length exec - 1", "by simp"], ["proof (state)\nthis:\n  n0 < length exec - 1\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "hence \"\\<exists> k < length exec - 1 - n0  . \\<not> enabled (execConf (n0 + k)) msg \n      \\<and> enabled (execConf (n0 + k + 1)) msg\""], ["proof (prove)\nusing this:\n  n0 < length exec - 1\n\ngoal (1 subgoal):\n 1. \\<exists>k<length exec - 1 - n0.\n       \\<not> enabled (execConf (n0 + k)) msg \\<and>\n       enabled (execConf (n0 + k + 1)) msg", "using NatPredicateTippingPoint[of \"length exec - 1 - n0\" \n        \"\\<lambda>x.\\<not>(enabled (exec ! (n0 + x)) msg)\"]\n        assms(1) NotEnabled EnabledInLast"], ["proof (prove)\nusing this:\n  n0 < length exec - 1\n  \\<lbrakk>n0 \\<in># (-) (length exec - 1);\n   \\<not> enabled (execConf (n0 + 0)) msg;\n   \\<not> \\<not> enabled (execConf (n0 + (length exec - 1 - n0)))\n                  msg\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n<length exec - 1 - n0.\n                       \\<not> enabled (execConf (n0 + n)) msg \\<and>\n                       \\<not> \\<not> enabled (execConf (n0 + Suc n)) msg\n  enabled (last exec) msg\n  \\<not> enabled (execConf n0) msg\n  enabled (execConf (length exec - 1)) msg\n\ngoal (1 subgoal):\n 1. \\<exists>k<length exec - 1 - n0.\n       \\<not> enabled (execConf (n0 + k)) msg \\<and>\n       enabled (execConf (n0 + k + 1)) msg", "by simp"], ["proof (state)\nthis:\n  \\<exists>k<length exec - 1 - n0.\n     \\<not> enabled (execConf (n0 + k)) msg \\<and>\n     enabled (execConf (n0 + k + 1)) msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k<length exec - 1 - n0.\n     \\<not> enabled (execConf (n0 + k)) msg \\<and>\n     enabled (execConf (n0 + k + 1)) msg", "obtain k where K: \" k < length exec - 1 - n0\" \n      \"\\<not> enabled (execConf (n0 + k)) msg\" \n      \"enabled (execConf (n0 + k + 1)) msg\""], ["proof (prove)\nusing this:\n  \\<exists>k<length exec - 1 - n0.\n     \\<not> enabled (execConf (n0 + k)) msg \\<and>\n     enabled (execConf (n0 + k + 1)) msg\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < length exec - 1 - n0;\n         \\<not> enabled (execConf (n0 + k)) msg;\n         enabled (execConf (n0 + k + 1)) msg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k < length exec - 1 - n0\n  \\<not> enabled (execConf (n0 + k)) msg\n  enabled (execConf (n0 + k + 1)) msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "define n1 where \"n1 = k + n0 + 1\""], ["proof (state)\nthis:\n  n1 = k + n0 + 1\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "hence N1: \"n1 \\<ge> n0\" \"\\<not> enabled (execConf (n1 - 1)) msg\" \n      \"enabled (execConf n1) msg\" \"n1 < length exec\""], ["proof (prove)\nusing this:\n  n1 = k + n0 + 1\n\ngoal (1 subgoal):\n 1. (n0 \\<le> n1 &&& \\<not> enabled (execConf (n1 - 1)) msg) &&&\n    enabled (execConf n1) msg &&& n1 < length exec", "unfolding n1_def"], ["proof (prove)\nusing this:\n  k + n0 + 1 = k + n0 + 1\n\ngoal (1 subgoal):\n 1. (n0 \\<le> k + n0 + 1 &&&\n     \\<not> enabled (execConf (k + n0 + 1 - 1)) msg) &&&\n    enabled (execConf (k + n0 + 1)) msg &&& k + n0 + 1 < length exec", "using K"], ["proof (prove)\nusing this:\n  k + n0 + 1 = k + n0 + 1\n  k < length exec - 1 - n0\n  \\<not> enabled (execConf (n0 + k)) msg\n  enabled (execConf (n0 + k + 1)) msg\n\ngoal (1 subgoal):\n 1. (n0 \\<le> k + n0 + 1 &&&\n     \\<not> enabled (execConf (k + n0 + 1 - 1)) msg) &&&\n    enabled (execConf (k + n0 + 1)) msg &&& k + n0 + 1 < length exec", "by (auto simp add: add.commute)"], ["proof (state)\nthis:\n  n0 \\<le> n1\n  \\<not> enabled (execConf (n1 - 1)) msg\n  enabled (execConf n1) msg\n  n1 < length exec\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "have \"\\<forall>n'\\<ge>n1. n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n1.\n       n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg", "using N1(1) N0(2)"], ["proof (prove)\nusing this:\n  n0 \\<le> n1\n  \\<forall>n'\\<ge>n0.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n1.\n       n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg", "by (metis order_trans)"], ["proof (state)\nthis:\n  \\<forall>n'\\<ge>n1.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf n0) msg \\<Longrightarrow>\n    \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "thus \"\\<exists>n1<length exec.\n        (\\<forall>n'\\<ge>n1. n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \n        \\<and> enabled (execConf n1) msg \n        \\<and> (n1 = 0 \\<or> \\<not> enabled (execConf (n1 - 1)) msg \n          \\<or> execMsg (n1 - 1) = msg)\""], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>n1.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n\ngoal (1 subgoal):\n 1. \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "using N1"], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>n1.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  n0 \\<le> n1\n  \\<not> enabled (execConf (n1 - 1)) msg\n  enabled (execConf n1) msg\n  n1 < length exec\n\ngoal (1 subgoal):\n 1. \\<exists>n1<length exec.\n       (\\<forall>n'\\<ge>n1.\n           n' < length trace \\<longrightarrow>\n           execMsg n' \\<noteq> msg) \\<and>\n       enabled (execConf n1) msg \\<and>\n       (n1 = 0 \\<or>\n        \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n1<length exec.\n     (\\<forall>n'\\<ge>n1.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     enabled (execConf n1) msg \\<and>\n     (n1 = 0 \\<or>\n      \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n1<length exec.\n     (\\<forall>n'\\<ge>n1.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     enabled (execConf n1) msg \\<and>\n     (n1 = 0 \\<or>\n      \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "then"], ["proof (chain)\npicking this:\n  \\<exists>n1<length exec.\n     (\\<forall>n'\\<ge>n1.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     enabled (execConf n1) msg \\<and>\n     (n1 = 0 \\<or>\n      \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)", "obtain n1 where N1: \"n1 < length exec\" \n    \"\\<forall> n'\\<ge>n1 . n' < length trace \\<longrightarrow> trace ! n' \\<noteq> msg\"\n    \"enabled (exec ! n1) msg\"\n    \"n1 = 0 \\<or> \\<not> enabled (exec ! (n1 - 1)) msg \\<or> trace ! (n1 - 1) = msg\""], ["proof (prove)\nusing this:\n  \\<exists>n1<length exec.\n     (\\<forall>n'\\<ge>n1.\n         n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg) \\<and>\n     enabled (execConf n1) msg \\<and>\n     (n1 = 0 \\<or>\n      \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg)\n\ngoal (1 subgoal):\n 1. (\\<And>n1.\n        \\<lbrakk>n1 < length exec;\n         \\<forall>n'\\<ge>n1.\n            n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg;\n         enabled (execConf n1) msg;\n         n1 = 0 \\<or>\n         \\<not> enabled (execConf (n1 - 1)) msg \\<or>\n         execMsg (n1 - 1) = msg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  n1 < length exec\n  \\<forall>n'\\<ge>n1.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  enabled (execConf n1) msg\n  n1 = 0 \\<or>\n  \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "hence \"firstOccurrence msg n1\""], ["proof (prove)\nusing this:\n  n1 < length exec\n  \\<forall>n'\\<ge>n1.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  enabled (execConf n1) msg\n  n1 = 0 \\<or>\n  \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg\n\ngoal (1 subgoal):\n 1. firstOccurrence msg n1", "using assms"], ["proof (prove)\nusing this:\n  n1 < length exec\n  \\<forall>n'\\<ge>n1.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  enabled (execConf n1) msg\n  n1 = 0 \\<or>\n  \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg\n  enabled (last exec) msg\n  \\<exists>p. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. firstOccurrence msg n1", "unfolding firstOccurrence_def"], ["proof (prove)\nusing this:\n  n1 < length exec\n  \\<forall>n'\\<ge>n1.\n     n' < length trace \\<longrightarrow> execMsg n' \\<noteq> msg\n  enabled (execConf n1) msg\n  n1 = 0 \\<or>\n  \\<not> enabled (execConf (n1 - 1)) msg \\<or> execMsg (n1 - 1) = msg\n  enabled (last exec) msg\n  \\<exists>p. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg) \\<and>\n    enabled (last exec) msg \\<and>\n    n1 < length exec \\<and>\n    enabled (execConf n1) msg \\<and>\n    (\\<forall>n'\\<ge>n1.\n        n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n') \\<and>\n    (n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (execConf (n1 - 1)) msg \\<or> msg = execMsg (n1 - 1))", "by auto"], ["proof (state)\nthis:\n  firstOccurrence msg n1\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "thus \"\\<exists>n. firstOccurrence msg n\""], ["proof (prove)\nusing this:\n  firstOccurrence msg n1\n\ngoal (1 subgoal):\n 1. \\<exists>n. firstOccurrence msg n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. firstOccurrence msg n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ReachableInExecution:\nassumes\n  \"i < length exec\"\n  \"j \\<le> i\"\nshows\n  \"reachable (execConf j) (execConf i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (execConf j) (execConf i)", "using assms"], ["proof (prove)\nusing this:\n  i < length exec\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. reachable (execConf j) (execConf i)", "proof(induct i, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>exec \\<noteq> []; j = 0; i < length exec\\<rbrakk>\n    \\<Longrightarrow> reachable (execConf 0) (execConf 0)\n 2. \\<And>ia.\n       \\<lbrakk>j \\<le> ia \\<Longrightarrow>\n                reachable (execConf j) (execConf ia);\n        Suc ia < length exec; j \\<le> Suc ia; i < length exec;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> reachable (execConf j) (execConf (Suc ia))", "show \"reachable (execConf 0) (execConf 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (execConf 0) (execConf 0)", "using reachable.simps"], ["proof (prove)\nusing this:\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. reachable (execConf 0) (execConf 0)", "by blast"], ["proof (state)\nthis:\n  reachable (execConf 0) (execConf 0)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>j \\<le> ia \\<Longrightarrow>\n                reachable (execConf j) (execConf ia);\n        Suc ia < length exec; j \\<le> Suc ia; i < length exec;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> reachable (execConf j) (execConf (Suc ia))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>j \\<le> ia \\<Longrightarrow>\n                reachable (execConf j) (execConf ia);\n        Suc ia < length exec; j \\<le> Suc ia; i < length exec;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> reachable (execConf j) (execConf (Suc ia))", "fix ia"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>j \\<le> ia \\<Longrightarrow>\n                reachable (execConf j) (execConf ia);\n        Suc ia < length exec; j \\<le> Suc ia; i < length exec;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> reachable (execConf j) (execConf (Suc ia))", "assume \n    IH: \"(j \\<le> ia \\<Longrightarrow> reachable (execConf j) (execConf ia))\" \n    \"Suc ia < length exec\" \n    \"j \\<le> Suc ia\"  \n    \"i < length exec\" \n    \"j \\<le> i\""], ["proof (state)\nthis:\n  j \\<le> ia \\<Longrightarrow> reachable (execConf j) (execConf ia)\n  Suc ia < length exec\n  j \\<le> Suc ia\n  i < length exec\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       \\<lbrakk>j \\<le> ia \\<Longrightarrow>\n                reachable (execConf j) (execConf ia);\n        Suc ia < length exec; j \\<le> Suc ia; i < length exec;\n        j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> reachable (execConf j) (execConf (Suc ia))", "show \"reachable (execConf j) (execConf (Suc ia))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (execConf j) (execConf (Suc ia))", "proof(cases \"j = Suc ia\", auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. j = Suc ia \\<Longrightarrow>\n    reachable (execConf (Suc ia)) (execConf (Suc ia))\n 2. j \\<noteq> Suc ia \\<Longrightarrow>\n    reachable (execConf j) (execConf (Suc ia))", "show \"reachable (execConf (Suc ia)) (execConf (Suc ia))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (execConf (Suc ia)) (execConf (Suc ia))", "using reachable.simps"], ["proof (prove)\nusing this:\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. reachable (execConf (Suc ia)) (execConf (Suc ia))", "by metis"], ["proof (state)\nthis:\n  reachable (execConf (Suc ia)) (execConf (Suc ia))\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc ia \\<Longrightarrow>\n    reachable (execConf j) (execConf (Suc ia))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> Suc ia \\<Longrightarrow>\n    reachable (execConf j) (execConf (Suc ia))", "assume \"j \\<noteq> Suc ia\""], ["proof (state)\nthis:\n  j \\<noteq> Suc ia\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc ia \\<Longrightarrow>\n    reachable (execConf j) (execConf (Suc ia))", "hence \"j \\<le> ia\""], ["proof (prove)\nusing this:\n  j \\<noteq> Suc ia\n\ngoal (1 subgoal):\n 1. j \\<le> ia", "using IH(3)"], ["proof (prove)\nusing this:\n  j \\<noteq> Suc ia\n  j \\<le> Suc ia\n\ngoal (1 subgoal):\n 1. j \\<le> ia", "by simp"], ["proof (state)\nthis:\n  j \\<le> ia\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc ia \\<Longrightarrow>\n    reachable (execConf j) (execConf (Suc ia))", "hence \"reachable (execConf j) (execConf ia)\""], ["proof (prove)\nusing this:\n  j \\<le> ia\n\ngoal (1 subgoal):\n 1. reachable (execConf j) (execConf ia)", "using IH(1)"], ["proof (prove)\nusing this:\n  j \\<le> ia\n  j \\<le> ia \\<Longrightarrow> reachable (execConf j) (execConf ia)\n\ngoal (1 subgoal):\n 1. reachable (execConf j) (execConf ia)", "by simp"], ["proof (state)\nthis:\n  reachable (execConf j) (execConf ia)\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc ia \\<Longrightarrow>\n    reachable (execConf j) (execConf (Suc ia))", "moreover"], ["proof (state)\nthis:\n  reachable (execConf j) (execConf ia)\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc ia \\<Longrightarrow>\n    reachable (execConf j) (execConf (Suc ia))", "have \"reachable (execConf ia) (execConf (Suc ia))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (execConf ia) (execConf (Suc ia))", "using reachable.simps"], ["proof (prove)\nusing this:\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. reachable (execConf ia) (execConf (Suc ia))", "by (metis IH(2) Suc_eq_plus1 less_diff_conv local.step)"], ["proof (state)\nthis:\n  reachable (execConf ia) (execConf (Suc ia))\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc ia \\<Longrightarrow>\n    reachable (execConf j) (execConf (Suc ia))", "ultimately"], ["proof (chain)\npicking this:\n  reachable (execConf j) (execConf ia)\n  reachable (execConf ia) (execConf (Suc ia))", "show \"reachable (execConf j) (execConf (Suc ia))\""], ["proof (prove)\nusing this:\n  reachable (execConf j) (execConf ia)\n  reachable (execConf ia) (execConf (Suc ia))\n\ngoal (1 subgoal):\n 1. reachable (execConf j) (execConf (Suc ia))", "using ReachableTrans"], ["proof (prove)\nusing this:\n  reachable (execConf j) (execConf ia)\n  reachable (execConf ia) (execConf (Suc ia))\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n\ngoal (1 subgoal):\n 1. reachable (execConf j) (execConf (Suc ia))", "by blast"], ["proof (state)\nthis:\n  reachable (execConf j) (execConf (Suc ia))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable (execConf j) (execConf (Suc ia))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma LastPoint:\nfixes\n  msg::\"('p, 'v) message\"\nassumes\n  \"enabled (last exec) msg\"\nobtains n where\n  \"n < length exec\"\n  \"enabled (execConf n) msg\"\n  \"\\<forall> n' \\<ge> n .\n    n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n')\"\n  \"\\<forall> n0 . \n      n0 < length exec \n    \\<and> enabled (execConf n0) msg \n    \\<and> (\\<forall> n' \\<ge> n0 .\n        n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n'))\n    \\<longrightarrow> n0 \\<ge> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>n < length exec; enabled (execConf n) msg;\n         \\<forall>n'\\<ge>n.\n            n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n';\n         \\<forall>n0.\n            n0 < length exec \\<and>\n            enabled (execConf n0) msg \\<and>\n            (\\<forall>n'\\<ge>n0.\n                n' < length trace \\<longrightarrow>\n                msg \\<noteq> execMsg n') \\<longrightarrow>\n            n \\<le> n0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases ?thesis, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>n < length exec; enabled (execConf n) msg;\n                 \\<forall>n'\\<ge>n.\n                    n' < length trace \\<longrightarrow>\n                    msg \\<noteq> execMsg n';\n                 \\<forall>n0.\n                    n0 < length exec \\<and>\n                    enabled (execConf n0) msg \\<and>\n                    (\\<forall>n'\\<ge>n0.\n                        n' < length trace \\<longrightarrow>\n                        msg \\<noteq> execMsg n') \\<longrightarrow>\n                    n \\<le> n0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  \\<not> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>n < length exec; enabled (execConf n) msg;\n                 \\<forall>n'\\<ge>n.\n                    n' < length trace \\<longrightarrow>\n                    msg \\<noteq> execMsg n';\n                 \\<forall>n0.\n                    n0 < length exec \\<and>\n                    enabled (execConf n0) msg \\<and>\n                    (\\<forall>n'\\<ge>n0.\n                        n' < length trace \\<longrightarrow>\n                        msg \\<noteq> execMsg n') \\<longrightarrow>\n                    n \\<le> n0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "define len where \"len = length exec - 1\""], ["proof (state)\nthis:\n  len = length exec - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>n < length exec; enabled (execConf n) msg;\n                 \\<forall>n'\\<ge>n.\n                    n' < length trace \\<longrightarrow>\n                    msg \\<noteq> execMsg n';\n                 \\<forall>n0.\n                    n0 < length exec \\<and>\n                    enabled (execConf n0) msg \\<and>\n                    (\\<forall>n'\\<ge>n0.\n                        n' < length trace \\<longrightarrow>\n                        msg \\<noteq> execMsg n') \\<longrightarrow>\n                    n \\<le> n0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have\n    \"len < length exec\"\n    \"enabled (execConf len) msg\" \n    \"\\<forall> n' \\<ge> len . n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len < length exec &&&\n    enabled (execConf len) msg &&&\n    \\<forall>n'\\<ge>len.\n       n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n'", "using assms notEmpty length"], ["proof (prove)\nusing this:\n  enabled (last exec) msg\n  1 \\<le> length exec\n  length exec - 1 = length trace\n\ngoal (1 subgoal):\n 1. len < length exec &&&\n    enabled (execConf len) msg &&&\n    \\<forall>n'\\<ge>len.\n       n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n'", "unfolding len_def"], ["proof (prove)\nusing this:\n  enabled (last exec) msg\n  1 \\<le> length exec\n  length exec - 1 = length trace\n\ngoal (1 subgoal):\n 1. length exec - 1 < length exec &&&\n    enabled (execConf (length exec - 1)) msg &&&\n    \\<forall>n'\\<ge>length exec - 1.\n       n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n'", "by (auto, metis One_nat_def last_conv_nth list.size(3) not_one_le_zero)"], ["proof (state)\nthis:\n  len < length exec\n  enabled (execConf len) msg\n  \\<forall>n'\\<ge>len.\n     n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>n < length exec; enabled (execConf n) msg;\n                 \\<forall>n'\\<ge>n.\n                    n' < length trace \\<longrightarrow>\n                    msg \\<noteq> execMsg n';\n                 \\<forall>n0.\n                    n0 < length exec \\<and>\n                    enabled (execConf n0) msg \\<and>\n                    (\\<forall>n'\\<ge>n0.\n                        n' < length trace \\<longrightarrow>\n                        msg \\<noteq> execMsg n') \\<longrightarrow>\n                    n \\<le> n0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<exists> n . n < length exec \\<and> enabled (execConf n) msg \n    \\<and> (\\<forall> n' \\<ge> n . n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n'))\""], ["proof (prove)\nusing this:\n  len < length exec\n  enabled (execConf len) msg\n  \\<forall>n'\\<ge>len.\n     n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n'\n\ngoal (1 subgoal):\n 1. \\<exists>n<length exec.\n       enabled (execConf n) msg \\<and>\n       (\\<forall>n'\\<ge>n.\n           n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n')", "by blast"], ["proof (state)\nthis:\n  \\<exists>n<length exec.\n     enabled (execConf n) msg \\<and>\n     (\\<forall>n'\\<ge>n.\n         n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n.\n                \\<lbrakk>n < length exec; enabled (execConf n) msg;\n                 \\<forall>n'\\<ge>n.\n                    n' < length trace \\<longrightarrow>\n                    msg \\<noteq> execMsg n';\n                 \\<forall>n0.\n                    n0 < length exec \\<and>\n                    enabled (execConf n0) msg \\<and>\n                    (\\<forall>n'\\<ge>n0.\n                        n' < length trace \\<longrightarrow>\n                        msg \\<noteq> execMsg n') \\<longrightarrow>\n                    n \\<le> n0\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "from MinPredicate[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>n0.\n     (n0 < length exec \\<and>\n      enabled (execConf n0) msg \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          msg \\<noteq> execMsg n')) \\<and>\n     (\\<forall>n'.\n         n' < length exec \\<and>\n         enabled (execConf n') msg \\<and>\n         (\\<forall>n'a\\<ge>n'.\n             n'a < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n'a) \\<longrightarrow>\n         n0 \\<le> n')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>n0.\n     (n0 < length exec \\<and>\n      enabled (execConf n0) msg \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          msg \\<noteq> execMsg n')) \\<and>\n     (\\<forall>n'.\n         n' < length exec \\<and>\n         enabled (execConf n') msg \\<and>\n         (\\<forall>n'a\\<ge>n'.\n             n'a < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n'a) \\<longrightarrow>\n         n0 \\<le> n')\n\ngoal (1 subgoal):\n 1. thesis", "using that False"], ["proof (prove)\nusing this:\n  \\<exists>n0.\n     (n0 < length exec \\<and>\n      enabled (execConf n0) msg \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          msg \\<noteq> execMsg n')) \\<and>\n     (\\<forall>n'.\n         n' < length exec \\<and>\n         enabled (execConf n') msg \\<and>\n         (\\<forall>n'a\\<ge>n'.\n             n'a < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n'a) \\<longrightarrow>\n         n0 \\<le> n')\n  \\<lbrakk>?n < length exec; enabled (execConf ?n) msg;\n   \\<forall>n'\\<ge>?n.\n      n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n';\n   \\<forall>n0.\n      n0 < length exec \\<and>\n      enabled (execConf n0) msg \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          msg \\<noteq> execMsg n') \\<longrightarrow>\n      ?n \\<le> n0\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<not> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ExistImpliesMinEnabled:\nfixes \n  msg :: \"('p, 'v) message\" and\n  p :: 'p\nassumes \n  \"isReceiverOf p msg\" \n  \"enabled (last exec) msg\"\nshows\n  \"\\<exists> msg' . minimalEnabled msg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "have MsgHasMinTime:\"\\<forall> msg . (enabled (last exec) msg \n    \\<and> (\\<exists> p . isReceiverOf p msg))\n    \\<longrightarrow> (\\<exists> n .  n < length exec \\<and> enabled (execConf n) msg \n        \\<and> (\\<forall> n' \\<ge> n . n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n'))\n        \\<and> (\\<forall> n0 .  n0 < length exec \\<and> enabled (execConf n0) msg \n        \\<and> (\\<forall> n' \\<ge> n0 . n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n')) \n        \\<longrightarrow> n0 \\<ge> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>msg.\n       enabled (last exec) msg \\<and>\n       (\\<exists>p. isReceiverOf p msg) \\<longrightarrow>\n       (\\<exists>n<length exec.\n           enabled (execConf n) msg \\<and>\n           (\\<forall>n'\\<ge>n.\n               n' < length trace \\<longrightarrow>\n               msg \\<noteq> execMsg n') \\<and>\n           (\\<forall>n0.\n               n0 < length exec \\<and>\n               enabled (execConf n0) msg \\<and>\n               (\\<forall>n'\\<ge>n0.\n                   n' < length trace \\<longrightarrow>\n                   msg \\<noteq> execMsg n') \\<longrightarrow>\n               n \\<le> n0))", "by (clarify, rule LastPoint, auto)"], ["proof (state)\nthis:\n  \\<forall>msg.\n     enabled (last exec) msg \\<and>\n     (\\<exists>p. isReceiverOf p msg) \\<longrightarrow>\n     (\\<exists>n<length exec.\n         enabled (execConf n) msg \\<and>\n         (\\<forall>n'\\<ge>n.\n             n' < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n') \\<and>\n         (\\<forall>n0.\n             n0 < length exec \\<and>\n             enabled (execConf n0) msg \\<and>\n             (\\<forall>n'\\<ge>n0.\n                 n' < length trace \\<longrightarrow>\n                 msg \\<noteq> execMsg n') \\<longrightarrow>\n             n \\<le> n0))\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "let ?enabledTimes = \"{n::nat . \\<exists> msg . (enabled (last exec) msg \n    \\<and> (\\<exists> p . isReceiverOf p msg))\n    \\<and>  n < length exec \\<and> (enabled (execConf n) msg \n    \\<and> (\\<forall> n' \\<ge> n . n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n')))}\""], ["proof (state)\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "have NotEmpty:\"?enabledTimes \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. \\<exists>msg.\n           (enabled (last exec) msg \\<and>\n            (\\<exists>p. isReceiverOf p msg)) \\<and>\n           n < length exec \\<and>\n           enabled (execConf n) msg \\<and>\n           (\\<forall>n'\\<ge>n.\n               n' < length trace \\<longrightarrow>\n               msg \\<noteq> execMsg n')} \\<noteq>\n    {}", "using assms MsgHasMinTime"], ["proof (prove)\nusing this:\n  isReceiverOf p msg\n  enabled (last exec) msg\n  \\<forall>msg.\n     enabled (last exec) msg \\<and>\n     (\\<exists>p. isReceiverOf p msg) \\<longrightarrow>\n     (\\<exists>n<length exec.\n         enabled (execConf n) msg \\<and>\n         (\\<forall>n'\\<ge>n.\n             n' < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n') \\<and>\n         (\\<forall>n0.\n             n0 < length exec \\<and>\n             enabled (execConf n0) msg \\<and>\n             (\\<forall>n'\\<ge>n0.\n                 n' < length trace \\<longrightarrow>\n                 msg \\<noteq> execMsg n') \\<longrightarrow>\n             n \\<le> n0))\n\ngoal (1 subgoal):\n 1. {n. \\<exists>msg.\n           (enabled (last exec) msg \\<and>\n            (\\<exists>p. isReceiverOf p msg)) \\<and>\n           n < length exec \\<and>\n           enabled (execConf n) msg \\<and>\n           (\\<forall>n'\\<ge>n.\n               n' < length trace \\<longrightarrow>\n               msg \\<noteq> execMsg n')} \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  {n. \\<exists>msg.\n         (enabled (last exec) msg \\<and>\n          (\\<exists>p. isReceiverOf p msg)) \\<and>\n         n < length exec \\<and>\n         enabled (execConf n) msg \\<and>\n         (\\<forall>n'\\<ge>n.\n             n' < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n')} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "hence \"\\<exists> n0 . n0 \\<in> ?enabledTimes\""], ["proof (prove)\nusing this:\n  {n. \\<exists>msg.\n         (enabled (last exec) msg \\<and>\n          (\\<exists>p. isReceiverOf p msg)) \\<and>\n         n < length exec \\<and>\n         enabled (execConf n) msg \\<and>\n         (\\<forall>n'\\<ge>n.\n             n' < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n')} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>n0.\n       n0 \\<in> {n. \\<exists>msg.\n                       (enabled (last exec) msg \\<and>\n                        (\\<exists>p. isReceiverOf p msg)) \\<and>\n                       n < length exec \\<and>\n                       enabled (execConf n) msg \\<and>\n                       (\\<forall>n'\\<ge>n.\n                           n' < length trace \\<longrightarrow>\n                           msg \\<noteq> execMsg n')}", "by blast"], ["proof (state)\nthis:\n  \\<exists>n0.\n     n0 \\<in> {n. \\<exists>msg.\n                     (enabled (last exec) msg \\<and>\n                      (\\<exists>p. isReceiverOf p msg)) \\<and>\n                     n < length exec \\<and>\n                     enabled (execConf n) msg \\<and>\n                     (\\<forall>n'\\<ge>n.\n                         n' < length trace \\<longrightarrow>\n                         msg \\<noteq> execMsg n')}\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "hence \"\\<exists> nMin \\<in> ?enabledTimes . \\<forall> x \\<in> ?enabledTimes . x \\<ge> nMin\""], ["proof (prove)\nusing this:\n  \\<exists>n0.\n     n0 \\<in> {n. \\<exists>msg.\n                     (enabled (last exec) msg \\<and>\n                      (\\<exists>p. isReceiverOf p msg)) \\<and>\n                     n < length exec \\<and>\n                     enabled (execConf n) msg \\<and>\n                     (\\<forall>n'\\<ge>n.\n                         n' < length trace \\<longrightarrow>\n                         msg \\<noteq> execMsg n')}\n\ngoal (1 subgoal):\n 1. \\<exists>nMin\n             \\<in>{n. \\<exists>msg.\n                         (enabled (last exec) msg \\<and>\n                          (\\<exists>p. isReceiverOf p msg)) \\<and>\n                         n < length exec \\<and>\n                         enabled (execConf n) msg \\<and>\n                         (\\<forall>n'\\<ge>n.\n                             n' < length trace \\<longrightarrow>\n                             msg \\<noteq> execMsg n')}.\n       \\<forall>x\\<in>{n. \\<exists>msg.\n                             (enabled (last exec) msg \\<and>\n                              (\\<exists>p. isReceiverOf p msg)) \\<and>\n                             n < length exec \\<and>\n                             enabled (execConf n) msg \\<and>\n                             (\\<forall>n'\\<ge>n.\n                                 n' < length trace \\<longrightarrow>\n                                 msg \\<noteq> execMsg n')}.\n          nMin \\<le> x", "using MinPredicate[of \"\\<lambda>n.(n \\<in> ?enabledTimes)\"]"], ["proof (prove)\nusing this:\n  \\<exists>n0.\n     n0 \\<in> {n. \\<exists>msg.\n                     (enabled (last exec) msg \\<and>\n                      (\\<exists>p. isReceiverOf p msg)) \\<and>\n                     n < length exec \\<and>\n                     enabled (execConf n) msg \\<and>\n                     (\\<forall>n'\\<ge>n.\n                         n' < length trace \\<longrightarrow>\n                         msg \\<noteq> execMsg n')}\n  \\<exists>n.\n     n \\<in> {n. \\<exists>msg.\n                    (enabled (last exec) msg \\<and>\n                     (\\<exists>p. isReceiverOf p msg)) \\<and>\n                    n < length exec \\<and>\n                    enabled (execConf n) msg \\<and>\n                    (\\<forall>n'\\<ge>n.\n                        n' < length trace \\<longrightarrow>\n                        msg \\<noteq> execMsg n')} \\<Longrightarrow>\n  \\<exists>n0.\n     n0 \\<in> {n. \\<exists>msg.\n                     (enabled (last exec) msg \\<and>\n                      (\\<exists>p. isReceiverOf p msg)) \\<and>\n                     n < length exec \\<and>\n                     enabled (execConf n) msg \\<and>\n                     (\\<forall>n'\\<ge>n.\n                         n' < length trace \\<longrightarrow>\n                         msg \\<noteq> execMsg n')} \\<and>\n     (\\<forall>n'.\n         n' \\<in> {n. \\<exists>msg.\n                         (enabled (last exec) msg \\<and>\n                          (\\<exists>p. isReceiverOf p msg)) \\<and>\n                         n < length exec \\<and>\n                         enabled (execConf n) msg \\<and>\n                         (\\<forall>n'\\<ge>n.\n                             n' < length trace \\<longrightarrow>\n                             msg \\<noteq> execMsg n')} \\<longrightarrow>\n         n0 \\<le> n')\n\ngoal (1 subgoal):\n 1. \\<exists>nMin\n             \\<in>{n. \\<exists>msg.\n                         (enabled (last exec) msg \\<and>\n                          (\\<exists>p. isReceiverOf p msg)) \\<and>\n                         n < length exec \\<and>\n                         enabled (execConf n) msg \\<and>\n                         (\\<forall>n'\\<ge>n.\n                             n' < length trace \\<longrightarrow>\n                             msg \\<noteq> execMsg n')}.\n       \\<forall>x\\<in>{n. \\<exists>msg.\n                             (enabled (last exec) msg \\<and>\n                              (\\<exists>p. isReceiverOf p msg)) \\<and>\n                             n < length exec \\<and>\n                             enabled (execConf n) msg \\<and>\n                             (\\<forall>n'\\<ge>n.\n                                 n' < length trace \\<longrightarrow>\n                                 msg \\<noteq> execMsg n')}.\n          nMin \\<le> x", "by simp"], ["proof (state)\nthis:\n  \\<exists>nMin\n           \\<in>{n. \\<exists>msg.\n                       (enabled (last exec) msg \\<and>\n                        (\\<exists>p. isReceiverOf p msg)) \\<and>\n                       n < length exec \\<and>\n                       enabled (execConf n) msg \\<and>\n                       (\\<forall>n'\\<ge>n.\n                           n' < length trace \\<longrightarrow>\n                           msg \\<noteq> execMsg n')}.\n     \\<forall>x\\<in>{n. \\<exists>msg.\n                           (enabled (last exec) msg \\<and>\n                            (\\<exists>p. isReceiverOf p msg)) \\<and>\n                           n < length exec \\<and>\n                           enabled (execConf n) msg \\<and>\n                           (\\<forall>n'\\<ge>n.\n                               n' < length trace \\<longrightarrow>\n                               msg \\<noteq> execMsg n')}.\n        nMin \\<le> x\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "then"], ["proof (chain)\npicking this:\n  \\<exists>nMin\n           \\<in>{n. \\<exists>msg.\n                       (enabled (last exec) msg \\<and>\n                        (\\<exists>p. isReceiverOf p msg)) \\<and>\n                       n < length exec \\<and>\n                       enabled (execConf n) msg \\<and>\n                       (\\<forall>n'\\<ge>n.\n                           n' < length trace \\<longrightarrow>\n                           msg \\<noteq> execMsg n')}.\n     \\<forall>x\\<in>{n. \\<exists>msg.\n                           (enabled (last exec) msg \\<and>\n                            (\\<exists>p. isReceiverOf p msg)) \\<and>\n                           n < length exec \\<and>\n                           enabled (execConf n) msg \\<and>\n                           (\\<forall>n'\\<ge>n.\n                               n' < length trace \\<longrightarrow>\n                               msg \\<noteq> execMsg n')}.\n        nMin \\<le> x", "obtain nMin where NMin: \"nMin \\<in> ?enabledTimes\" \n    \"\\<forall> x \\<in> ?enabledTimes . x \\<ge> nMin\""], ["proof (prove)\nusing this:\n  \\<exists>nMin\n           \\<in>{n. \\<exists>msg.\n                       (enabled (last exec) msg \\<and>\n                        (\\<exists>p. isReceiverOf p msg)) \\<and>\n                       n < length exec \\<and>\n                       enabled (execConf n) msg \\<and>\n                       (\\<forall>n'\\<ge>n.\n                           n' < length trace \\<longrightarrow>\n                           msg \\<noteq> execMsg n')}.\n     \\<forall>x\\<in>{n. \\<exists>msg.\n                           (enabled (last exec) msg \\<and>\n                            (\\<exists>p. isReceiverOf p msg)) \\<and>\n                           n < length exec \\<and>\n                           enabled (execConf n) msg \\<and>\n                           (\\<forall>n'\\<ge>n.\n                               n' < length trace \\<longrightarrow>\n                               msg \\<noteq> execMsg n')}.\n        nMin \\<le> x\n\ngoal (1 subgoal):\n 1. (\\<And>nMin.\n        \\<lbrakk>nMin\n                 \\<in> {n. \\<exists>msg.\n                              (enabled (last exec) msg \\<and>\n                               (\\<exists>p. isReceiverOf p msg)) \\<and>\n                              n < length exec \\<and>\n                              enabled (execConf n) msg \\<and>\n                              (\\<forall>n'\\<ge>n.\n                                  n' < length trace \\<longrightarrow>\n                                  msg \\<noteq> execMsg n')};\n         \\<forall>x\\<in>{n. \\<exists>msg.\n                               (enabled (last exec) msg \\<and>\n                                (\\<exists>p. isReceiverOf p msg)) \\<and>\n                               n < length exec \\<and>\n                               enabled (execConf n) msg \\<and>\n                               (\\<forall>n'\\<ge>n.\n                                   n' < length trace \\<longrightarrow>\n                                   msg \\<noteq> execMsg n')}.\n            nMin \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nMin\n  \\<in> {n. \\<exists>msg.\n               (enabled (last exec) msg \\<and>\n                (\\<exists>p. isReceiverOf p msg)) \\<and>\n               n < length exec \\<and>\n               enabled (execConf n) msg \\<and>\n               (\\<forall>n'\\<ge>n.\n                   n' < length trace \\<longrightarrow>\n                   msg \\<noteq> execMsg n')}\n  \\<forall>x\\<in>{n. \\<exists>msg.\n                        (enabled (last exec) msg \\<and>\n                         (\\<exists>p. isReceiverOf p msg)) \\<and>\n                        n < length exec \\<and>\n                        enabled (execConf n) msg \\<and>\n                        (\\<forall>n'\\<ge>n.\n                            n' < length trace \\<longrightarrow>\n                            msg \\<noteq> execMsg n')}.\n     nMin \\<le> x\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "hence \"\\<exists> msg . (enabled (last exec) msg \\<and> (\\<exists> p . isReceiverOf p msg))\n    \\<and>  nMin < length exec \\<and> (enabled (execConf nMin) msg \n    \\<and> (\\<forall> n' \\<ge> nMin . n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n'))\n    \\<and> (\\<forall> n0 .  n0 < length exec \\<and> enabled (execConf n0) msg \n      \\<and> (\\<forall> n' \\<ge> n0 . n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n')) \n      \\<longrightarrow> n0 \\<ge> nMin))\""], ["proof (prove)\nusing this:\n  nMin\n  \\<in> {n. \\<exists>msg.\n               (enabled (last exec) msg \\<and>\n                (\\<exists>p. isReceiverOf p msg)) \\<and>\n               n < length exec \\<and>\n               enabled (execConf n) msg \\<and>\n               (\\<forall>n'\\<ge>n.\n                   n' < length trace \\<longrightarrow>\n                   msg \\<noteq> execMsg n')}\n  \\<forall>x\\<in>{n. \\<exists>msg.\n                        (enabled (last exec) msg \\<and>\n                         (\\<exists>p. isReceiverOf p msg)) \\<and>\n                        n < length exec \\<and>\n                        enabled (execConf n) msg \\<and>\n                        (\\<forall>n'\\<ge>n.\n                            n' < length trace \\<longrightarrow>\n                            msg \\<noteq> execMsg n')}.\n     nMin \\<le> x\n\ngoal (1 subgoal):\n 1. \\<exists>msg.\n       (enabled (last exec) msg \\<and>\n        (\\<exists>p. isReceiverOf p msg)) \\<and>\n       nMin < length exec \\<and>\n       enabled (execConf nMin) msg \\<and>\n       (\\<forall>n'\\<ge>nMin.\n           n' < length trace \\<longrightarrow>\n           msg \\<noteq> execMsg n') \\<and>\n       (\\<forall>n0.\n           n0 < length exec \\<and>\n           enabled (execConf n0) msg \\<and>\n           (\\<forall>n'\\<ge>n0.\n               n' < length trace \\<longrightarrow>\n               msg \\<noteq> execMsg n') \\<longrightarrow>\n           nMin \\<le> n0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>msg.\n     (enabled (last exec) msg \\<and>\n      (\\<exists>p. isReceiverOf p msg)) \\<and>\n     nMin < length exec \\<and>\n     enabled (execConf nMin) msg \\<and>\n     (\\<forall>n'\\<ge>nMin.\n         n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n') \\<and>\n     (\\<forall>n0.\n         n0 < length exec \\<and>\n         enabled (execConf n0) msg \\<and>\n         (\\<forall>n'\\<ge>n0.\n             n' < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n') \\<longrightarrow>\n         nMin \\<le> n0)\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "then"], ["proof (chain)\npicking this:\n  \\<exists>msg.\n     (enabled (last exec) msg \\<and>\n      (\\<exists>p. isReceiverOf p msg)) \\<and>\n     nMin < length exec \\<and>\n     enabled (execConf nMin) msg \\<and>\n     (\\<forall>n'\\<ge>nMin.\n         n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n') \\<and>\n     (\\<forall>n0.\n         n0 < length exec \\<and>\n         enabled (execConf n0) msg \\<and>\n         (\\<forall>n'\\<ge>n0.\n             n' < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n') \\<longrightarrow>\n         nMin \\<le> n0)", "obtain msg where \"(enabled (last exec) msg \n    \\<and> (\\<exists> p . isReceiverOf p msg))\n    \\<and> nMin < length exec \\<and>(enabled (execConf nMin) msg \n    \\<and> (\\<forall> n' \\<ge> nMin . n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n'))\n    \\<and> (\\<forall> n0 .  n0 < length exec \\<and> enabled (execConf n0) msg \n      \\<and> (\\<forall> n' \\<ge> n0 . n' < length trace \\<longrightarrow> msg \\<noteq> (execMsg n')) \n      \\<longrightarrow> n0 \\<ge> nMin))\""], ["proof (prove)\nusing this:\n  \\<exists>msg.\n     (enabled (last exec) msg \\<and>\n      (\\<exists>p. isReceiverOf p msg)) \\<and>\n     nMin < length exec \\<and>\n     enabled (execConf nMin) msg \\<and>\n     (\\<forall>n'\\<ge>nMin.\n         n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n') \\<and>\n     (\\<forall>n0.\n         n0 < length exec \\<and>\n         enabled (execConf n0) msg \\<and>\n         (\\<forall>n'\\<ge>n0.\n             n' < length trace \\<longrightarrow>\n             msg \\<noteq> execMsg n') \\<longrightarrow>\n         nMin \\<le> n0)\n\ngoal (1 subgoal):\n 1. (\\<And>msg.\n        (enabled (last exec) msg \\<and>\n         (\\<exists>p. isReceiverOf p msg)) \\<and>\n        nMin < length exec \\<and>\n        enabled (execConf nMin) msg \\<and>\n        (\\<forall>n'\\<ge>nMin.\n            n' < length trace \\<longrightarrow>\n            msg \\<noteq> execMsg n') \\<and>\n        (\\<forall>n0.\n            n0 < length exec \\<and>\n            enabled (execConf n0) msg \\<and>\n            (\\<forall>n'\\<ge>n0.\n                n' < length trace \\<longrightarrow>\n                msg \\<noteq> execMsg n') \\<longrightarrow>\n            nMin \\<le> n0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (enabled (last exec) msg \\<and> (\\<exists>p. isReceiverOf p msg)) \\<and>\n  nMin < length exec \\<and>\n  enabled (execConf nMin) msg \\<and>\n  (\\<forall>n'\\<ge>nMin.\n      n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n') \\<and>\n  (\\<forall>n0.\n      n0 < length exec \\<and>\n      enabled (execConf n0) msg \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          msg \\<noteq> execMsg n') \\<longrightarrow>\n      nMin \\<le> n0)\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "moreover"], ["proof (state)\nthis:\n  (enabled (last exec) msg \\<and> (\\<exists>p. isReceiverOf p msg)) \\<and>\n  nMin < length exec \\<and>\n  enabled (execConf nMin) msg \\<and>\n  (\\<forall>n'\\<ge>nMin.\n      n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n') \\<and>\n  (\\<forall>n0.\n      n0 < length exec \\<and>\n      enabled (execConf n0) msg \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          msg \\<noteq> execMsg n') \\<longrightarrow>\n      nMin \\<le> n0)\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "have \"(\\<forall> n' msg' . ((\\<exists> p . isReceiverOf p msg') \n    \\<and> (enabled (last exec) msg') \n    \\<and> n' < length trace \\<and> enabled (execConf n') msg' \n    \\<and> (\\<forall> n'' \\<ge> n' . n'' < length trace \\<longrightarrow> msg' \\<noteq> (execMsg n''))) \n      \\<longrightarrow> n' \\<ge> nMin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n' msg'.\n       (\\<exists>p. isReceiverOf p msg') \\<and>\n       enabled (last exec) msg' \\<and>\n       n' < length trace \\<and>\n       enabled (execConf n') msg' \\<and>\n       (\\<forall>n''\\<ge>n'.\n           n'' < length trace \\<longrightarrow>\n           msg' \\<noteq> execMsg n'') \\<longrightarrow>\n       nMin \\<le> n'", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' msg' p.\n       \\<lbrakk>isReceiverOf p msg'; enabled (last exec) msg';\n        n' < length trace; enabled (execConf n') msg';\n        \\<forall>n''\\<ge>n'.\n           n'' < length trace \\<longrightarrow>\n           msg' \\<noteq> execMsg n''\\<rbrakk>\n       \\<Longrightarrow> nMin \\<le> n'", "fix n' msg' p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' msg' p.\n       \\<lbrakk>isReceiverOf p msg'; enabled (last exec) msg';\n        n' < length trace; enabled (execConf n') msg';\n        \\<forall>n''\\<ge>n'.\n           n'' < length trace \\<longrightarrow>\n           msg' \\<noteq> execMsg n''\\<rbrakk>\n       \\<Longrightarrow> nMin \\<le> n'", "assume Assms:\n      \"isReceiverOf p msg'\" \n      \"enabled (last exec) msg'\" \n      \"n' < length trace\" \n      \"enabled (execConf n') msg'\" \n      \"\\<forall>n'' \\<ge> n'. (n'' < length trace) \\<longrightarrow> (msg' \\<noteq> execMsg n'')\""], ["proof (state)\nthis:\n  isReceiverOf p msg'\n  enabled (last exec) msg'\n  n' < length trace\n  enabled (execConf n') msg'\n  \\<forall>n''\\<ge>n'.\n     n'' < length trace \\<longrightarrow> msg' \\<noteq> execMsg n''\n\ngoal (1 subgoal):\n 1. \\<And>n' msg' p.\n       \\<lbrakk>isReceiverOf p msg'; enabled (last exec) msg';\n        n' < length trace; enabled (execConf n') msg';\n        \\<forall>n''\\<ge>n'.\n           n'' < length trace \\<longrightarrow>\n           msg' \\<noteq> execMsg n''\\<rbrakk>\n       \\<Longrightarrow> nMin \\<le> n'", "from Assms(3)"], ["proof (chain)\npicking this:\n  n' < length trace", "have \"n' < length exec\""], ["proof (prove)\nusing this:\n  n' < length trace\n\ngoal (1 subgoal):\n 1. n' < length exec", "using length"], ["proof (prove)\nusing this:\n  n' < length trace\n  length exec - 1 = length trace\n\ngoal (1 subgoal):\n 1. n' < length exec", "by simp"], ["proof (state)\nthis:\n  n' < length exec\n\ngoal (1 subgoal):\n 1. \\<And>n' msg' p.\n       \\<lbrakk>isReceiverOf p msg'; enabled (last exec) msg';\n        n' < length trace; enabled (execConf n') msg';\n        \\<forall>n''\\<ge>n'.\n           n'' < length trace \\<longrightarrow>\n           msg' \\<noteq> execMsg n''\\<rbrakk>\n       \\<Longrightarrow> nMin \\<le> n'", "with Assms"], ["proof (chain)\npicking this:\n  isReceiverOf p msg'\n  enabled (last exec) msg'\n  n' < length trace\n  enabled (execConf n') msg'\n  \\<forall>n''\\<ge>n'.\n     n'' < length trace \\<longrightarrow> msg' \\<noteq> execMsg n''\n  n' < length exec", "have \"n' \\<in> ?enabledTimes\""], ["proof (prove)\nusing this:\n  isReceiverOf p msg'\n  enabled (last exec) msg'\n  n' < length trace\n  enabled (execConf n') msg'\n  \\<forall>n''\\<ge>n'.\n     n'' < length trace \\<longrightarrow> msg' \\<noteq> execMsg n''\n  n' < length exec\n\ngoal (1 subgoal):\n 1. n' \\<in> {n. \\<exists>msg.\n                    (enabled (last exec) msg \\<and>\n                     (\\<exists>p. isReceiverOf p msg)) \\<and>\n                    n < length exec \\<and>\n                    enabled (execConf n) msg \\<and>\n                    (\\<forall>n'\\<ge>n.\n                        n' < length trace \\<longrightarrow>\n                        msg \\<noteq> execMsg n')}", "by auto"], ["proof (state)\nthis:\n  n' \\<in> {n. \\<exists>msg.\n                  (enabled (last exec) msg \\<and>\n                   (\\<exists>p. isReceiverOf p msg)) \\<and>\n                  n < length exec \\<and>\n                  enabled (execConf n) msg \\<and>\n                  (\\<forall>n'\\<ge>n.\n                      n' < length trace \\<longrightarrow>\n                      msg \\<noteq> execMsg n')}\n\ngoal (1 subgoal):\n 1. \\<And>n' msg' p.\n       \\<lbrakk>isReceiverOf p msg'; enabled (last exec) msg';\n        n' < length trace; enabled (execConf n') msg';\n        \\<forall>n''\\<ge>n'.\n           n'' < length trace \\<longrightarrow>\n           msg' \\<noteq> execMsg n''\\<rbrakk>\n       \\<Longrightarrow> nMin \\<le> n'", "thus \"nMin \\<le> n'\""], ["proof (prove)\nusing this:\n  n' \\<in> {n. \\<exists>msg.\n                  (enabled (last exec) msg \\<and>\n                   (\\<exists>p. isReceiverOf p msg)) \\<and>\n                  n < length exec \\<and>\n                  enabled (execConf n) msg \\<and>\n                  (\\<forall>n'\\<ge>n.\n                      n' < length trace \\<longrightarrow>\n                      msg \\<noteq> execMsg n')}\n\ngoal (1 subgoal):\n 1. nMin \\<le> n'", "using NMin(2)"], ["proof (prove)\nusing this:\n  n' \\<in> {n. \\<exists>msg.\n                  (enabled (last exec) msg \\<and>\n                   (\\<exists>p. isReceiverOf p msg)) \\<and>\n                  n < length exec \\<and>\n                  enabled (execConf n) msg \\<and>\n                  (\\<forall>n'\\<ge>n.\n                      n' < length trace \\<longrightarrow>\n                      msg \\<noteq> execMsg n')}\n  \\<forall>x\\<in>{n. \\<exists>msg.\n                        (enabled (last exec) msg \\<and>\n                         (\\<exists>p. isReceiverOf p msg)) \\<and>\n                        n < length exec \\<and>\n                        enabled (execConf n) msg \\<and>\n                        (\\<forall>n'\\<ge>n.\n                            n' < length trace \\<longrightarrow>\n                            msg \\<noteq> execMsg n')}.\n     nMin \\<le> x\n\ngoal (1 subgoal):\n 1. nMin \\<le> n'", "by simp"], ["proof (state)\nthis:\n  nMin \\<le> n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n' msg'.\n     (\\<exists>p. isReceiverOf p msg') \\<and>\n     enabled (last exec) msg' \\<and>\n     n' < length trace \\<and>\n     enabled (execConf n') msg' \\<and>\n     (\\<forall>n''\\<ge>n'.\n         n'' < length trace \\<longrightarrow>\n         msg' \\<noteq> execMsg n'') \\<longrightarrow>\n     nMin \\<le> n'\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "ultimately"], ["proof (chain)\npicking this:\n  (enabled (last exec) msg \\<and> (\\<exists>p. isReceiverOf p msg)) \\<and>\n  nMin < length exec \\<and>\n  enabled (execConf nMin) msg \\<and>\n  (\\<forall>n'\\<ge>nMin.\n      n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n') \\<and>\n  (\\<forall>n0.\n      n0 < length exec \\<and>\n      enabled (execConf n0) msg \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          msg \\<noteq> execMsg n') \\<longrightarrow>\n      nMin \\<le> n0)\n  \\<forall>n' msg'.\n     (\\<exists>p. isReceiverOf p msg') \\<and>\n     enabled (last exec) msg' \\<and>\n     n' < length trace \\<and>\n     enabled (execConf n') msg' \\<and>\n     (\\<forall>n''\\<ge>n'.\n         n'' < length trace \\<longrightarrow>\n         msg' \\<noteq> execMsg n'') \\<longrightarrow>\n     nMin \\<le> n'", "have \"minimalEnabled msg\""], ["proof (prove)\nusing this:\n  (enabled (last exec) msg \\<and> (\\<exists>p. isReceiverOf p msg)) \\<and>\n  nMin < length exec \\<and>\n  enabled (execConf nMin) msg \\<and>\n  (\\<forall>n'\\<ge>nMin.\n      n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n') \\<and>\n  (\\<forall>n0.\n      n0 < length exec \\<and>\n      enabled (execConf n0) msg \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          msg \\<noteq> execMsg n') \\<longrightarrow>\n      nMin \\<le> n0)\n  \\<forall>n' msg'.\n     (\\<exists>p. isReceiverOf p msg') \\<and>\n     enabled (last exec) msg' \\<and>\n     n' < length trace \\<and>\n     enabled (execConf n') msg' \\<and>\n     (\\<forall>n''\\<ge>n'.\n         n'' < length trace \\<longrightarrow>\n         msg' \\<noteq> execMsg n'') \\<longrightarrow>\n     nMin \\<le> n'\n\ngoal (1 subgoal):\n 1. minimalEnabled msg", "using minimalEnabled_def"], ["proof (prove)\nusing this:\n  (enabled (last exec) msg \\<and> (\\<exists>p. isReceiverOf p msg)) \\<and>\n  nMin < length exec \\<and>\n  enabled (execConf nMin) msg \\<and>\n  (\\<forall>n'\\<ge>nMin.\n      n' < length trace \\<longrightarrow> msg \\<noteq> execMsg n') \\<and>\n  (\\<forall>n0.\n      n0 < length exec \\<and>\n      enabled (execConf n0) msg \\<and>\n      (\\<forall>n'\\<ge>n0.\n          n' < length trace \\<longrightarrow>\n          msg \\<noteq> execMsg n') \\<longrightarrow>\n      nMin \\<le> n0)\n  \\<forall>n' msg'.\n     (\\<exists>p. isReceiverOf p msg') \\<and>\n     enabled (last exec) msg' \\<and>\n     n' < length trace \\<and>\n     enabled (execConf n') msg' \\<and>\n     (\\<forall>n''\\<ge>n'.\n         n'' < length trace \\<longrightarrow>\n         msg' \\<noteq> execMsg n'') \\<longrightarrow>\n     nMin \\<le> n'\n  minimalEnabled ?msg \\<equiv>\n  (\\<exists>p. isReceiverOf p ?msg) \\<and>\n  enabled (last exec) ?msg \\<and>\n  (\\<exists>n<length exec.\n      enabled (execConf n) ?msg \\<and>\n      (\\<forall>n'\\<ge>n.\n          n' < length trace \\<longrightarrow>\n          ?msg \\<noteq> execMsg n') \\<and>\n      (\\<forall>n' msg'.\n          (\\<exists>p. isReceiverOf p msg') \\<and>\n          enabled (last exec) msg' \\<and>\n          n' < length trace \\<and>\n          enabled (execConf n') msg' \\<and>\n          (\\<forall>n''\\<ge>n'.\n              n'' < length trace \\<longrightarrow>\n              msg' \\<noteq> execMsg n'') \\<longrightarrow>\n          n \\<le> n'))\n\ngoal (1 subgoal):\n 1. minimalEnabled msg", "by blast"], ["proof (state)\nthis:\n  minimalEnabled msg\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "thus ?thesis"], ["proof (prove)\nusing this:\n  minimalEnabled msg\n\ngoal (1 subgoal):\n 1. Ex minimalEnabled", "by blast"], ["proof (state)\nthis:\n  Ex minimalEnabled\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma StaysEnabledStep:\nassumes\n  En: \"enabled cfg msg\" and\n  Cfg: \"cfg = exec ! n\" and\n  N: \"n < length exec\" \nshows\n  \"enabled (exec ! (n + 1)) msg \n  \\<or> n = (length exec - 1) \n  \\<or> msg = trace ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "proof(cases \"n = length exec - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = length exec - 1 \\<Longrightarrow>\n    enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n\n 2. n \\<noteq> length exec - 1 \\<Longrightarrow>\n    enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "case True"], ["proof (state)\nthis:\n  n = length exec - 1\n\ngoal (2 subgoals):\n 1. n = length exec - 1 \\<Longrightarrow>\n    enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n\n 2. n \\<noteq> length exec - 1 \\<Longrightarrow>\n    enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = length exec - 1\n\ngoal (1 subgoal):\n 1. enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "by simp"], ["proof (state)\nthis:\n  enabled (execConf (n + 1)) msg \\<or>\n  n = length exec - 1 \\<or> msg = execMsg n\n\ngoal (1 subgoal):\n 1. n \\<noteq> length exec - 1 \\<Longrightarrow>\n    enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> length exec - 1 \\<Longrightarrow>\n    enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "case False"], ["proof (state)\nthis:\n  n \\<noteq> length exec - 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> length exec - 1 \\<Longrightarrow>\n    enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "with N"], ["proof (chain)\npicking this:\n  n < length exec\n  n \\<noteq> length exec - 1", "have N: \"n < length exec - 1\""], ["proof (prove)\nusing this:\n  n < length exec\n  n \\<noteq> length exec - 1\n\ngoal (1 subgoal):\n 1. n < length exec - 1", "by simp"], ["proof (state)\nthis:\n  n < length exec - 1\n\ngoal (1 subgoal):\n 1. n \\<noteq> length exec - 1 \\<Longrightarrow>\n    enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "with Cfg"], ["proof (chain)\npicking this:\n  cfg = execConf n\n  n < length exec - 1", "have Step:  \"cfg \\<turnstile> trace ! n \\<mapsto> (exec ! (n + 1))\""], ["proof (prove)\nusing this:\n  cfg = execConf n\n  n < length exec - 1\n\ngoal (1 subgoal):\n 1. cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1)", "using step"], ["proof (prove)\nusing this:\n  cfg = execConf n\n  n < length exec - 1\n  \\<lbrakk>?i < length exec - 1; ?cfg1.0 = execConf ?i;\n   ?cfg2.0 = execConf (?i + 1)\\<rbrakk>\n  \\<Longrightarrow> ?cfg1.0 \\<turnstile> execMsg ?i \\<mapsto> ?cfg2.0\n\ngoal (1 subgoal):\n 1. cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1)", "by simp"], ["proof (state)\nthis:\n  cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1)\n\ngoal (1 subgoal):\n 1. n \\<noteq> length exec - 1 \\<Longrightarrow>\n    enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "thus ?thesis"], ["proof (prove)\nusing this:\n  cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1)\n\ngoal (1 subgoal):\n 1. enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "proof(cases \"enabled (exec ! (n + 1)) msg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1);\n     enabled (execConf (n + 1)) msg\\<rbrakk>\n    \\<Longrightarrow> enabled (execConf (n + 1)) msg \\<or>\n                      n = length exec - 1 \\<or> msg = execMsg n\n 2. \\<lbrakk>cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1);\n     \\<not> enabled (execConf (n + 1)) msg\\<rbrakk>\n    \\<Longrightarrow> enabled (execConf (n + 1)) msg \\<or>\n                      n = length exec - 1 \\<or> msg = execMsg n", "case True"], ["proof (state)\nthis:\n  enabled (execConf (n + 1)) msg\n\ngoal (2 subgoals):\n 1. \\<lbrakk>cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1);\n     enabled (execConf (n + 1)) msg\\<rbrakk>\n    \\<Longrightarrow> enabled (execConf (n + 1)) msg \\<or>\n                      n = length exec - 1 \\<or> msg = execMsg n\n 2. \\<lbrakk>cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1);\n     \\<not> enabled (execConf (n + 1)) msg\\<rbrakk>\n    \\<Longrightarrow> enabled (execConf (n + 1)) msg \\<or>\n                      n = length exec - 1 \\<or> msg = execMsg n", "thus ?thesis"], ["proof (prove)\nusing this:\n  enabled (execConf (n + 1)) msg\n\ngoal (1 subgoal):\n 1. enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "by simp"], ["proof (state)\nthis:\n  enabled (execConf (n + 1)) msg \\<or>\n  n = length exec - 1 \\<or> msg = execMsg n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1);\n     \\<not> enabled (execConf (n + 1)) msg\\<rbrakk>\n    \\<Longrightarrow> enabled (execConf (n + 1)) msg \\<or>\n                      n = length exec - 1 \\<or> msg = execMsg n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1);\n     \\<not> enabled (execConf (n + 1)) msg\\<rbrakk>\n    \\<Longrightarrow> enabled (execConf (n + 1)) msg \\<or>\n                      n = length exec - 1 \\<or> msg = execMsg n", "case False"], ["proof (state)\nthis:\n  \\<not> enabled (execConf (n + 1)) msg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1);\n     \\<not> enabled (execConf (n + 1)) msg\\<rbrakk>\n    \\<Longrightarrow> enabled (execConf (n + 1)) msg \\<or>\n                      n = length exec - 1 \\<or> msg = execMsg n", "hence \"\\<not> enabled (exec ! (n + 1)) msg\""], ["proof (prove)\nusing this:\n  \\<not> enabled (execConf (n + 1)) msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (execConf (n + 1)) msg", "by simp"], ["proof (state)\nthis:\n  \\<not> enabled (execConf (n + 1)) msg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1);\n     \\<not> enabled (execConf (n + 1)) msg\\<rbrakk>\n    \\<Longrightarrow> enabled (execConf (n + 1)) msg \\<or>\n                      n = length exec - 1 \\<or> msg = execMsg n", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> enabled (execConf (n + 1)) msg\n\ngoal (1 subgoal):\n 1. enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "using En enabled_def Step N OnlyOccurenceDisables"], ["proof (prove)\nusing this:\n  \\<not> enabled (execConf (n + 1)) msg\n  enabled cfg msg\n  enabled ?cfg ?msg \\<equiv> ?msg \\<in># msgs ?cfg\n  cfg \\<turnstile> execMsg n \\<mapsto> execConf (n + 1)\n  n < length exec - 1\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0; enabled ?cfg1.0 ?m';\n   \\<not> enabled ?cfg2.0 ?m'\\<rbrakk>\n  \\<Longrightarrow> ?m = ?m'\n\ngoal (1 subgoal):\n 1. enabled (execConf (n + 1)) msg \\<or>\n    n = length exec - 1 \\<or> msg = execMsg n", "by blast"], ["proof (state)\nthis:\n  enabled (execConf (n + 1)) msg \\<or>\n  n = length exec - 1 \\<or> msg = execMsg n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enabled (execConf (n + 1)) msg \\<or>\n  n = length exec - 1 \\<or> msg = execMsg n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma StaysEnabledHelp:\nassumes\n  \"enabled cfg msg\" and\n  \"cfg = exec ! n\" and\n  \"n < length exec\"    \nshows \n  \"\\<forall> i . i \\<ge> n \\<and> i < (length exec - 1) \\<and> enabled (exec ! i) msg \n  \\<longrightarrow> msg = (trace ! i) \\<or> (enabled (exec ! (i+1)) msg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       n \\<le> i \\<and>\n       i < length exec - 1 \\<and> enabled (execConf i) msg \\<longrightarrow>\n       msg = execMsg i \\<or> enabled (execConf (i + 1)) msg", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n \\<le> i; i < length exec - 1; enabled (execConf i) msg;\n        \\<not> enabled (execConf (i + 1)) msg\\<rbrakk>\n       \\<Longrightarrow> msg = execMsg i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n \\<le> i; i < length exec - 1; enabled (execConf i) msg;\n        \\<not> enabled (execConf (i + 1)) msg\\<rbrakk>\n       \\<Longrightarrow> msg = execMsg i", "assume \"n \\<le> i\" \"i < length exec - 1\"\n    \"enabled (execConf i) msg\" \"\\<not> enabled (execConf (i + 1)) msg\""], ["proof (state)\nthis:\n  n \\<le> i\n  i < length exec - 1\n  enabled (execConf i) msg\n  \\<not> enabled (execConf (i + 1)) msg\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n \\<le> i; i < length exec - 1; enabled (execConf i) msg;\n        \\<not> enabled (execConf (i + 1)) msg\\<rbrakk>\n       \\<Longrightarrow> msg = execMsg i", "thus \"msg = (trace ! i)\""], ["proof (prove)\nusing this:\n  n \\<le> i\n  i < length exec - 1\n  enabled (execConf i) msg\n  \\<not> enabled (execConf (i + 1)) msg\n\ngoal (1 subgoal):\n 1. msg = execMsg i", "using assms StaysEnabledStep"], ["proof (prove)\nusing this:\n  n \\<le> i\n  i < length exec - 1\n  enabled (execConf i) msg\n  \\<not> enabled (execConf (i + 1)) msg\n  enabled cfg msg\n  cfg = execConf n\n  n < length exec\n  \\<lbrakk>enabled ?cfg ?msg; ?cfg = execConf ?n; ?n < length exec\\<rbrakk>\n  \\<Longrightarrow> enabled (execConf (?n + 1)) ?msg \\<or>\n                    ?n = length exec - 1 \\<or> ?msg = execMsg ?n\n\ngoal (1 subgoal):\n 1. msg = execMsg i", "by (metis add.right_neutral add_strict_mono le_add_diff_inverse2\n        nat_neq_iff notEmpty  zero_less_one)"], ["proof (state)\nthis:\n  msg = execMsg i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma StaysEnabled:\nassumes En: \"enabled cfg msg\" and\n  \"cfg = exec ! n\" and\n  \"n < length exec\"   \nshows \"enabled (last exec) msg \\<or> (\\<exists> i . i \\<ge> n \\<and> i < (length exec - 1) \n  \\<and> msg = trace ! i )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "proof(cases \"enabled (last exec) msg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)\n 2. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "case True"], ["proof (state)\nthis:\n  enabled (last exec) msg\n\ngoal (2 subgoals):\n 1. enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)\n 2. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  enabled (last exec) msg\n\ngoal (1 subgoal):\n 1. enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "by simp"], ["proof (state)\nthis:\n  enabled (last exec) msg \\<or>\n  (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "case False"], ["proof (state)\nthis:\n  \\<not> enabled (last exec) msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "hence NotEnabled: \"\\<not> enabled (last exec) msg\""], ["proof (prove)\nusing this:\n  \\<not> enabled (last exec) msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec) msg", "by simp"], ["proof (state)\nthis:\n  \\<not> enabled (last exec) msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "have \"last exec = exec ! (length exec - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last exec = execConf (length exec - 1)", "by (metis last_conv_nth list.size(3) notEmpty not_one_le_zero)"], ["proof (state)\nthis:\n  last exec = execConf (length exec - 1)\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "hence \"\\<exists> l . l \\<ge> n \\<and> last exec = exec ! l \\<and> l = length exec - 1\""], ["proof (prove)\nusing this:\n  last exec = execConf (length exec - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>n. last exec = execConf l \\<and> l = length exec - 1", "using assms(3)"], ["proof (prove)\nusing this:\n  last exec = execConf (length exec - 1)\n  n < length exec\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<ge>n. last exec = execConf l \\<and> l = length exec - 1", "by auto"], ["proof (state)\nthis:\n  \\<exists>l\\<ge>n. last exec = execConf l \\<and> l = length exec - 1\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>l\\<ge>n. last exec = execConf l \\<and> l = length exec - 1", "obtain l where L: \"l \\<ge> n\" \"last exec = exec ! l\" \n    \"l = length exec - 1\""], ["proof (prove)\nusing this:\n  \\<exists>l\\<ge>n. last exec = execConf l \\<and> l = length exec - 1\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>n \\<le> l; last exec = execConf l;\n         l = length exec - 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n \\<le> l\n  last exec = execConf l\n  l = length exec - 1\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "have \"(\\<exists> i . i \\<ge> n \\<and> i < (length exec - 1) \\<and> msg = trace ! i )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<ge>n.\n               i < length exec - 1 \\<and> msg = execMsg i) \\<Longrightarrow>\n    False", "assume Ass: \" \\<not> (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<ge>n.\n               i < length exec - 1 \\<and> msg = execMsg i) \\<Longrightarrow>\n    False", "hence Not: \"\\<forall> i. i < n \\<or> i \\<ge> length exec - 1 \\<or> msg \\<noteq> execMsg i\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       i < n \\<or> length exec - 1 \\<le> i \\<or> msg \\<noteq> execMsg i", "by (metis leI)"], ["proof (state)\nthis:\n  \\<forall>i.\n     i < n \\<or> length exec - 1 \\<le> i \\<or> msg \\<noteq> execMsg i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<ge>n.\n               i < length exec - 1 \\<and> msg = execMsg i) \\<Longrightarrow>\n    False", "have \"\\<forall> i. i \\<ge> n \\<and> i \\<le> length exec - 1 \\<longrightarrow> enabled (exec ! i) msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       n \\<le> i \\<and> i \\<le> length exec - 1 \\<longrightarrow>\n       enabled (execConf i) msg", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n \\<le> i; i \\<le> length exec - 1\\<rbrakk>\n       \\<Longrightarrow> enabled (execConf i) msg", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n \\<le> i; i \\<le> length exec - 1\\<rbrakk>\n       \\<Longrightarrow> enabled (execConf i) msg", "assume I: \"n \\<le> i\" \"i \\<le> length exec - 1\""], ["proof (state)\nthis:\n  n \\<le> i\n  i \\<le> length exec - 1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>n \\<le> i; i \\<le> length exec - 1\\<rbrakk>\n       \\<Longrightarrow> enabled (execConf i) msg", "thus \"enabled (execConf i) msg\""], ["proof (prove)\nusing this:\n  n \\<le> i\n  i \\<le> length exec - 1\n\ngoal (1 subgoal):\n 1. enabled (execConf i) msg", "using StaysEnabledHelp[OF assms] assms(1,2) Ass"], ["proof (prove)\nusing this:\n  n \\<le> i\n  i \\<le> length exec - 1\n  \\<forall>i.\n     n \\<le> i \\<and>\n     i < length exec - 1 \\<and> enabled (execConf i) msg \\<longrightarrow>\n     msg = execMsg i \\<or> enabled (execConf (i + 1)) msg\n  enabled cfg msg\n  cfg = execConf n\n  \\<not> (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)\n\ngoal (1 subgoal):\n 1. enabled (execConf i) msg", "by (induct i, auto, metis Suc_le_lessD le_Suc_eq)"], ["proof (state)\nthis:\n  enabled (execConf i) msg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i.\n     n \\<le> i \\<and> i \\<le> length exec - 1 \\<longrightarrow>\n     enabled (execConf i) msg\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<ge>n.\n               i < length exec - 1 \\<and> msg = execMsg i) \\<Longrightarrow>\n    False", "with NotEnabled L"], ["proof (chain)\npicking this:\n  \\<not> enabled (last exec) msg\n  n \\<le> l\n  last exec = execConf l\n  l = length exec - 1\n  \\<forall>i.\n     n \\<le> i \\<and> i \\<le> length exec - 1 \\<longrightarrow>\n     enabled (execConf i) msg", "show False"], ["proof (prove)\nusing this:\n  \\<not> enabled (last exec) msg\n  n \\<le> l\n  last exec = execConf l\n  l = length exec - 1\n  \\<forall>i.\n     n \\<le> i \\<and> i \\<le> length exec - 1 \\<longrightarrow>\n     enabled (execConf i) msg\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec) msg \\<Longrightarrow>\n    enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i\n\ngoal (1 subgoal):\n 1. enabled (last exec) msg \\<or>\n    (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)", "by simp"], ["proof (state)\nthis:\n  enabled (last exec) msg \\<or>\n  (\\<exists>i\\<ge>n. i < length exec - 1 \\<and> msg = execMsg i)\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>end of locale Execution\\<close>"], ["", "subsection \\<open>Expanding executions to longer executions\\<close>"], ["", "lemma (in asynchronousSystem) expandExecutionStep:\nfixes \n  cfg :: \"('p, 'v, 's ) configuration\"\nassumes\n  CfgIsReachable: \"(last exec') \\<turnstile> msg \\<mapsto> cMsg\" and\n  ExecIsExecution: \"execution trans sends start exec' trace'\" \nshows\n  \"\\<exists> exec'' trace''. (execution trans sends start exec'' trace'') \n  \\<and> (prefixList exec' exec'') \n  \\<and> (prefixList trace' trace'') \n  \\<and> (last exec'') = cMsg \n  \\<and> (last trace'' = msg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "define execMsg where \"execMsg = exec' @ [cMsg]\""], ["proof (state)\nthis:\n  execMsg = exec' @ [cMsg]\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "define traceMsg where \"traceMsg = trace' @ [msg]\""], ["proof (state)\nthis:\n  traceMsg = trace' @ [msg]\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have ExecMsgEq: \"\\<forall> i < ((length execMsg) - 1) . execMsg ! i = exec'!i \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length execMsg - 1. execMsg ! i = exec' ! i", "using execMsg_def"], ["proof (prove)\nusing this:\n  execMsg = exec' @ [cMsg]\n\ngoal (1 subgoal):\n 1. \\<forall>i<length execMsg - 1. execMsg ! i = exec' ! i", "by (auto simp add: nth_append)"], ["proof (state)\nthis:\n  \\<forall>i<length execMsg - 1. execMsg ! i = exec' ! i\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have TraceMsgEq: \"\\<forall> i < ((length traceMsg) - 1) . traceMsg!i = trace'!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length traceMsg - 1. traceMsg ! i = trace' ! i", "using traceMsg_def"], ["proof (prove)\nusing this:\n  traceMsg = trace' @ [msg]\n\ngoal (1 subgoal):\n 1. \\<forall>i<length traceMsg - 1. traceMsg ! i = trace' ! i", "by (auto simp add: nth_append)"], ["proof (state)\nthis:\n  \\<forall>i<length traceMsg - 1. traceMsg ! i = trace' ! i\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have ExecLen: \"(length execMsg) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> length execMsg", "using execMsg_def"], ["proof (prove)\nusing this:\n  execMsg = exec' @ [cMsg]\n\ngoal (1 subgoal):\n 1. 1 \\<le> length execMsg", "by auto"], ["proof (state)\nthis:\n  1 \\<le> length execMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have lessLessExec: \"\\<forall> i . i < (length exec') \\<longrightarrow> i < (length execMsg )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length exec'. i < length execMsg", "unfolding execMsg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length exec'. i < length (exec' @ [cMsg])", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length exec'. i < length execMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have ExecLenTraceLen: \"length exec'- 1 = length trace'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length exec' - 1 = length trace'", "using ExecIsExecution execution.length"], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  execution ?trans ?sends ?start ?exec ?trace \\<Longrightarrow>\n  length ?exec - 1 = length ?trace\n\ngoal (1 subgoal):\n 1. length exec' - 1 = length trace'", "by auto"], ["proof (state)\nthis:\n  length exec' - 1 = length trace'\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have lessLessTrace: \"\\<forall> i . i < (length exec' - 1) \\<longrightarrow> i < (length trace')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length exec' - 1. i < length trace'", "using ExecLenTraceLen"], ["proof (prove)\nusing this:\n  length exec' - 1 = length trace'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length exec' - 1. i < length trace'", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length exec' - 1. i < length trace'\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have Exec'Len: \"length exec' \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> length exec'", "using ExecIsExecution execution.notEmpty"], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  execution ?trans ?sends ?start ?exec ?trace \\<Longrightarrow>\n  1 \\<le> length ?exec\n\ngoal (1 subgoal):\n 1. 1 \\<le> length exec'", "by blast"], ["proof (state)\nthis:\n  1 \\<le> length exec'\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "hence \"hd exec' = hd execMsg \""], ["proof (prove)\nusing this:\n  1 \\<le> length exec'\n\ngoal (1 subgoal):\n 1. hd exec' = hd execMsg", "using execMsg_def"], ["proof (prove)\nusing this:\n  1 \\<le> length exec'\n  execMsg = exec' @ [cMsg]\n\ngoal (1 subgoal):\n 1. hd exec' = hd execMsg", "by (metis One_nat_def hd_append2 length_0_conv not_one_le_zero)"], ["proof (state)\nthis:\n  hd exec' = hd execMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "moreover"], ["proof (state)\nthis:\n  hd exec' = hd execMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have \"initial (hd exec')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial (hd exec')", "using ExecIsExecution execution.base"], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  execution ?trans ?sends ?start ?exec ?trace \\<Longrightarrow>\n  asynchronousSystem.initial ?start (hd ?exec)\n\ngoal (1 subgoal):\n 1. initial (hd exec')", "by blast"], ["proof (state)\nthis:\n  initial (hd exec')\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "ultimately"], ["proof (chain)\npicking this:\n  hd exec' = hd execMsg\n  initial (hd exec')", "have ExecInit: \"initial (hd execMsg)\""], ["proof (prove)\nusing this:\n  hd exec' = hd execMsg\n  initial (hd exec')\n\ngoal (1 subgoal):\n 1. initial (hd execMsg)", "using execMsg_def"], ["proof (prove)\nusing this:\n  hd exec' = hd execMsg\n  initial (hd exec')\n  execMsg = exec' @ [cMsg]\n\ngoal (1 subgoal):\n 1. initial (hd execMsg)", "by auto"], ["proof (state)\nthis:\n  initial (hd execMsg)\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have ExecMsgLen: \"length execMsg - 1 = length traceMsg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length execMsg - 1 = length traceMsg", "using ExecLenTraceLen"], ["proof (prove)\nusing this:\n  length exec' - 1 = length trace'\n\ngoal (1 subgoal):\n 1. length execMsg - 1 = length traceMsg", "unfolding execMsg_def traceMsg_def"], ["proof (prove)\nusing this:\n  length exec' - 1 = length trace'\n\ngoal (1 subgoal):\n 1. length (exec' @ [cMsg]) - 1 = length (trace' @ [msg])", "by (auto,metis Exec'Len Suc_pred length_greater_0_conv list.size(3) \n       not_one_le_zero)"], ["proof (state)\nthis:\n  length execMsg - 1 = length traceMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have ExecSteps:\"\\<forall> i < length exec' - 1 .\n    ((exec' ! i)  \\<turnstile> trace' ! i \\<mapsto> (exec' ! (i + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length exec' - 1.\n       exec' ! i \\<turnstile> trace' ! i \\<mapsto> exec' ! (i + 1)", "using ExecIsExecution execution.step"], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  \\<lbrakk>execution ?trans ?sends ?start ?exec ?trace;\n   ?i < length ?exec - 1; ?cfg1.0 = ?exec ! ?i;\n   ?cfg2.0 = ?exec ! (?i + 1)\\<rbrakk>\n  \\<Longrightarrow> asynchronousSystem.steps ?trans ?sends ?cfg1.0\n                     (?trace ! ?i) ?cfg2.0\n\ngoal (1 subgoal):\n 1. \\<forall>i<length exec' - 1.\n       exec' ! i \\<turnstile> trace' ! i \\<mapsto> exec' ! (i + 1)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<length exec' - 1.\n     exec' ! i \\<turnstile> trace' ! i \\<mapsto> exec' ! (i + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have \"\\<forall> i < length execMsg - 1. \n    ((execMsg ! i) \\<turnstile> traceMsg ! i \\<mapsto> (execMsg ! (i + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length execMsg - 1.\n       execMsg ! i \\<turnstile> traceMsg ! i \\<mapsto> execMsg ! (i + 1)", "unfolding execMsg_def traceMsg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (exec' @ [cMsg]) - 1.\n       (exec' @ [cMsg]) !\n       i \\<turnstile> (trace' @ [msg]) !\n                      i \\<mapsto> (exec' @ [cMsg]) ! (i + 1)", "proof auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length exec' \\<Longrightarrow>\n       (exec' @ [cMsg]) !\n       i \\<turnstile> (trace' @ [msg]) !\n                      i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length exec' \\<Longrightarrow>\n       (exec' @ [cMsg]) !\n       i \\<turnstile> (trace' @ [msg]) !\n                      i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "assume IlessLen:\"i < (length exec')\""], ["proof (state)\nthis:\n  i < length exec'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length exec' \\<Longrightarrow>\n       (exec' @ [cMsg]) !\n       i \\<turnstile> (trace' @ [msg]) !\n                      i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "show \"((exec' @ [cMsg]) ! i) \\<turnstile> ((trace' @ [msg]) ! i) \n      \\<mapsto> ((exec' @ [cMsg]) ! (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "proof (cases \"(i < (length exec') - 1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n 2. \\<not> i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "case True"], ["proof (state)\nthis:\n  i < length exec' - 1\n\ngoal (2 subgoals):\n 1. i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n 2. \\<not> i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "hence IlessLen1: \"(i < (length exec') - 1)\""], ["proof (prove)\nusing this:\n  i < length exec' - 1\n\ngoal (1 subgoal):\n 1. i < length exec' - 1", "by auto"], ["proof (state)\nthis:\n  i < length exec' - 1\n\ngoal (2 subgoals):\n 1. i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n 2. \\<not> i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "hence \"((exec' ! i)  \\<turnstile> trace' ! i \\<mapsto> (exec' ! (i + 1)))\""], ["proof (prove)\nusing this:\n  i < length exec' - 1\n\ngoal (1 subgoal):\n 1. exec' ! i \\<turnstile> trace' ! i \\<mapsto> exec' ! (i + 1)", "using ExecSteps"], ["proof (prove)\nusing this:\n  i < length exec' - 1\n  \\<forall>i<length exec' - 1.\n     exec' ! i \\<turnstile> trace' ! i \\<mapsto> exec' ! (i + 1)\n\ngoal (1 subgoal):\n 1. exec' ! i \\<turnstile> trace' ! i \\<mapsto> exec' ! (i + 1)", "by auto"], ["proof (state)\nthis:\n  exec' ! i \\<turnstile> trace' ! i \\<mapsto> exec' ! (i + 1)\n\ngoal (2 subgoals):\n 1. i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n 2. \\<not> i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "with IlessLen1 ExecMsgEq lessLessExec execMsg_def"], ["proof (chain)\npicking this:\n  i < length exec' - 1\n  \\<forall>i<length execMsg - 1. execMsg ! i = exec' ! i\n  \\<forall>i<length exec'. i < length execMsg\n  execMsg = exec' @ [cMsg]\n  exec' ! i \\<turnstile> trace' ! i \\<mapsto> exec' ! (i + 1)", "have \"((exec' @ [cMsg]) ! i) \\<turnstile> ((trace') ! i) \n        \\<mapsto> ((exec' @ [cMsg]) ! (Suc i))\""], ["proof (prove)\nusing this:\n  i < length exec' - 1\n  \\<forall>i<length execMsg - 1. execMsg ! i = exec' ! i\n  \\<forall>i<length exec'. i < length execMsg\n  execMsg = exec' @ [cMsg]\n  exec' ! i \\<turnstile> trace' ! i \\<mapsto> exec' ! (i + 1)\n\ngoal (1 subgoal):\n 1. (exec' @ [cMsg]) !\n    i \\<turnstile> trace' ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "by auto"], ["proof (state)\nthis:\n  (exec' @ [cMsg]) !\n  i \\<turnstile> trace' ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n\ngoal (2 subgoals):\n 1. i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n 2. \\<not> i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "thus \"((exec' @ [cMsg]) ! i) \\<turnstile> ((trace' @ [msg]) ! i) \n        \\<mapsto> ((exec' @ [cMsg]) ! (Suc i))\""], ["proof (prove)\nusing this:\n  (exec' @ [cMsg]) !\n  i \\<turnstile> trace' ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n\ngoal (1 subgoal):\n 1. (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "using IlessLen1 TraceMsgEq lessLessTrace traceMsg_def"], ["proof (prove)\nusing this:\n  (exec' @ [cMsg]) !\n  i \\<turnstile> trace' ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n  i < length exec' - 1\n  \\<forall>i<length traceMsg - 1. traceMsg ! i = trace' ! i\n  \\<forall>i<length exec' - 1. i < length trace'\n  traceMsg = trace' @ [msg]\n\ngoal (1 subgoal):\n 1. (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "by auto"], ["proof (state)\nthis:\n  (exec' @ [cMsg]) !\n  i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n\ngoal (1 subgoal):\n 1. \\<not> i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "case False"], ["proof (state)\nthis:\n  \\<not> i < length exec' - 1\n\ngoal (1 subgoal):\n 1. \\<not> i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "with IlessLen"], ["proof (chain)\npicking this:\n  i < length exec'\n  \\<not> i < length exec' - 1", "have IEqLen1: \"(i = (length exec') - 1)\""], ["proof (prove)\nusing this:\n  i < length exec'\n  \\<not> i < length exec' - 1\n\ngoal (1 subgoal):\n 1. i = length exec' - 1", "by auto"], ["proof (state)\nthis:\n  i = length exec' - 1\n\ngoal (1 subgoal):\n 1. \\<not> i < length exec' - 1 \\<Longrightarrow>\n    (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "thus \"((exec' @ [cMsg]) ! i) \\<turnstile> ((trace' @ [msg]) ! i) \n        \\<mapsto> ((exec' @ [cMsg]) ! (Suc i))\""], ["proof (prove)\nusing this:\n  i = length exec' - 1\n\ngoal (1 subgoal):\n 1. (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "using  execMsg_def traceMsg_def  CfgIsReachable Exec'Len \n               ExecLenTraceLen ExecMsgEq ExecMsgLen IlessLen"], ["proof (prove)\nusing this:\n  i = length exec' - 1\n  execMsg = exec' @ [cMsg]\n  traceMsg = trace' @ [msg]\n  last exec' \\<turnstile> msg \\<mapsto> cMsg\n  1 \\<le> length exec'\n  length exec' - 1 = length trace'\n  \\<forall>i<length execMsg - 1. execMsg ! i = exec' ! i\n  length execMsg - 1 = length traceMsg\n  i < length exec'\n\ngoal (1 subgoal):\n 1. (exec' @ [cMsg]) !\n    i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i", "by (metis One_nat_def Suc_eq_plus1 Suc_eq_plus1_left last_conv_nth \n           le_add_diff_inverse length_append less_nat_zero_code list.size(3) \n           list.size(4) nth_append_length)"], ["proof (state)\nthis:\n  (exec' @ [cMsg]) !\n  i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (exec' @ [cMsg]) !\n  i \\<turnstile> (trace' @ [msg]) ! i \\<mapsto> (exec' @ [cMsg]) ! Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length execMsg - 1.\n     execMsg ! i \\<turnstile> traceMsg ! i \\<mapsto> execMsg ! (i + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "hence isExecution: \"execution trans sends start execMsg traceMsg\""], ["proof (prove)\nusing this:\n  \\<forall>i<length execMsg - 1.\n     execMsg ! i \\<turnstile> traceMsg ! i \\<mapsto> execMsg ! (i + 1)\n\ngoal (1 subgoal):\n 1. execution trans sends start execMsg traceMsg", "using ExecLen ExecMsgLen ExecInit"], ["proof (prove)\nusing this:\n  \\<forall>i<length execMsg - 1.\n     execMsg ! i \\<turnstile> traceMsg ! i \\<mapsto> execMsg ! (i + 1)\n  1 \\<le> length execMsg\n  length execMsg - 1 = length traceMsg\n  initial (hd execMsg)\n\ngoal (1 subgoal):\n 1. execution trans sends start execMsg traceMsg", "by (unfold_locales ,auto)"], ["proof (state)\nthis:\n  execution trans sends start execMsg traceMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "moreover"], ["proof (state)\nthis:\n  execution trans sends start execMsg traceMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have \"prefixList exec' execMsg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList exec' execMsg", "unfolding execMsg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList exec' (exec' @ [cMsg])", "by (metis TailIsPrefixList not_Cons_self2)"], ["proof (state)\nthis:\n  prefixList exec' execMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "moreover"], ["proof (state)\nthis:\n  prefixList exec' execMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "have \"prefixList trace' traceMsg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList trace' traceMsg", "unfolding traceMsg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList trace' (trace' @ [msg])", "by (metis TailIsPrefixList not_Cons_self2)"], ["proof (state)\nthis:\n  prefixList trace' traceMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "ultimately"], ["proof (chain)\npicking this:\n  execution trans sends start execMsg traceMsg\n  prefixList exec' execMsg\n  prefixList trace' traceMsg", "show ?thesis"], ["proof (prove)\nusing this:\n  execution trans sends start execMsg traceMsg\n  prefixList exec' execMsg\n  prefixList trace' traceMsg\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "using execMsg_def traceMsg_def"], ["proof (prove)\nusing this:\n  execution trans sends start execMsg traceMsg\n  prefixList exec' execMsg\n  prefixList trace' traceMsg\n  execMsg = exec' @ [cMsg]\n  traceMsg = trace' @ [msg]\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cMsg \\<and> last trace'' = msg", "by (metis last_snoc)"], ["proof (state)\nthis:\n  \\<exists>exec'' trace''.\n     execution trans sends start exec'' trace'' \\<and>\n     prefixList exec' exec'' \\<and>\n     prefixList trace' trace'' \\<and>\n     last exec'' = cMsg \\<and> last trace'' = msg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in asynchronousSystem) expandExecutionReachable:\nfixes \n  cfg :: \"('p, 'v, 's ) configuration\" and\n  cfgLast :: \"('p, 'v, 's ) configuration\"\nassumes\n  CfgIsReachable: \"reachable (cfgLast) cfg\" and\n  ExecIsExecution: \"execution trans sends start exec trace\"  and\n  ExecLast: \"cfgLast = last exec\" \nshows\n  \"\\<exists> exec' trace'. (execution trans sends start exec' trace') \n  \\<and> ((prefixList exec exec' \n    \\<and> prefixList trace trace') \n    \\<or> (exec = exec' \\<and> trace = trace')) \n  \\<and> (last exec') = cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       (prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n        exec = exec' \\<and> trace = trace') \\<and>\n       last exec' = cfg", "using CfgIsReachable  ExecIsExecution ExecLast"], ["proof (prove)\nusing this:\n  reachable cfgLast cfg\n  execution trans sends start exec trace\n  cfgLast = last exec\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       (prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n        exec = exec' \\<and> trace = trace') \\<and>\n       last exec' = cfg", "proof (induct cfgLast cfg rule: reachable.induct, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>msg cfg3 exec' trace'.\n       \\<lbrakk>reachable (last exec) (last exec');\n        last exec' \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; execution trans sends start exec trace;\n        cfgLast = last exec; execution trans sends start exec' trace';\n        prefixList exec exec'; prefixList trace trace'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3\n 2. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "fix msg cfg3 exec' trace'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>msg cfg3 exec' trace'.\n       \\<lbrakk>reachable (last exec) (last exec');\n        last exec' \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; execution trans sends start exec trace;\n        cfgLast = last exec; execution trans sends start exec' trace';\n        prefixList exec exec'; prefixList trace trace'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3\n 2. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "assume \"(last exec') \\<turnstile> msg \\<mapsto> cfg3\"\n         \"execution trans sends start exec' trace'\""], ["proof (state)\nthis:\n  last exec' \\<turnstile> msg \\<mapsto> cfg3\n  execution trans sends start exec' trace'\n\ngoal (2 subgoals):\n 1. \\<And>msg cfg3 exec' trace'.\n       \\<lbrakk>reachable (last exec) (last exec');\n        last exec' \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; execution trans sends start exec trace;\n        cfgLast = last exec; execution trans sends start exec' trace';\n        prefixList exec exec'; prefixList trace trace'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3\n 2. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "hence \"\\<exists> exec'' trace''. (execution trans sends start exec'' trace'') \n    \\<and> (prefixList exec' exec'') \n    \\<and> (prefixList trace' trace'') \\<and> (last exec'') = cfg3 \n    \\<and> (last trace'') = msg\""], ["proof (prove)\nusing this:\n  last exec' \\<turnstile> msg \\<mapsto> cfg3\n  execution trans sends start exec' trace'\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = cfg3 \\<and> last trace'' = msg", "by (simp add: expandExecutionStep)"], ["proof (state)\nthis:\n  \\<exists>exec'' trace''.\n     execution trans sends start exec'' trace'' \\<and>\n     prefixList exec' exec'' \\<and>\n     prefixList trace' trace'' \\<and>\n     last exec'' = cfg3 \\<and> last trace'' = msg\n\ngoal (2 subgoals):\n 1. \\<And>msg cfg3 exec' trace'.\n       \\<lbrakk>reachable (last exec) (last exec');\n        last exec' \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; execution trans sends start exec trace;\n        cfgLast = last exec; execution trans sends start exec' trace';\n        prefixList exec exec'; prefixList trace trace'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3\n 2. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "then"], ["proof (chain)\npicking this:\n  \\<exists>exec'' trace''.\n     execution trans sends start exec'' trace'' \\<and>\n     prefixList exec' exec'' \\<and>\n     prefixList trace' trace'' \\<and>\n     last exec'' = cfg3 \\<and> last trace'' = msg", "obtain  exec'' trace'' where \n    NewExec: \"execution trans sends start exec'' trace''\" \n             \"prefixList exec' exec''\" \"prefixList trace' trace''\" \n             \"last exec'' = cfg3\""], ["proof (prove)\nusing this:\n  \\<exists>exec'' trace''.\n     execution trans sends start exec'' trace'' \\<and>\n     prefixList exec' exec'' \\<and>\n     prefixList trace' trace'' \\<and>\n     last exec'' = cfg3 \\<and> last trace'' = msg\n\ngoal (1 subgoal):\n 1. (\\<And>exec'' trace''.\n        \\<lbrakk>execution trans sends start exec'' trace'';\n         prefixList exec' exec''; prefixList trace' trace'';\n         last exec'' = cfg3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution trans sends start exec'' trace''\n  prefixList exec' exec''\n  prefixList trace' trace''\n  last exec'' = cfg3\n\ngoal (2 subgoals):\n 1. \\<And>msg cfg3 exec' trace'.\n       \\<lbrakk>reachable (last exec) (last exec');\n        last exec' \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; execution trans sends start exec trace;\n        cfgLast = last exec; execution trans sends start exec' trace';\n        prefixList exec exec'; prefixList trace trace'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3\n 2. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "assume prefixLists: \"prefixList exec exec'\" \n                      \"prefixList trace trace'\""], ["proof (state)\nthis:\n  prefixList exec exec'\n  prefixList trace trace'\n\ngoal (2 subgoals):\n 1. \\<And>msg cfg3 exec' trace'.\n       \\<lbrakk>reachable (last exec) (last exec');\n        last exec' \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; execution trans sends start exec trace;\n        cfgLast = last exec; execution trans sends start exec' trace';\n        prefixList exec exec'; prefixList trace trace'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3\n 2. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "from prefixLists(1) NewExec(2)"], ["proof (chain)\npicking this:\n  prefixList exec exec'\n  prefixList exec' exec''", "have \"prefixList exec exec''\""], ["proof (prove)\nusing this:\n  prefixList exec exec'\n  prefixList exec' exec''\n\ngoal (1 subgoal):\n 1. prefixList exec exec''", "using PrefixListTransitive"], ["proof (prove)\nusing this:\n  prefixList exec exec'\n  prefixList exec' exec''\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n\ngoal (1 subgoal):\n 1. prefixList exec exec''", "by auto"], ["proof (state)\nthis:\n  prefixList exec exec''\n\ngoal (2 subgoals):\n 1. \\<And>msg cfg3 exec' trace'.\n       \\<lbrakk>reachable (last exec) (last exec');\n        last exec' \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; execution trans sends start exec trace;\n        cfgLast = last exec; execution trans sends start exec' trace';\n        prefixList exec exec'; prefixList trace trace'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3\n 2. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "moreover"], ["proof (state)\nthis:\n  prefixList exec exec''\n\ngoal (2 subgoals):\n 1. \\<And>msg cfg3 exec' trace'.\n       \\<lbrakk>reachable (last exec) (last exec');\n        last exec' \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; execution trans sends start exec trace;\n        cfgLast = last exec; execution trans sends start exec' trace';\n        prefixList exec exec'; prefixList trace trace'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3\n 2. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "from prefixLists(2) NewExec(3)"], ["proof (chain)\npicking this:\n  prefixList trace trace'\n  prefixList trace' trace''", "have \n    \"prefixList trace trace''\""], ["proof (prove)\nusing this:\n  prefixList trace trace'\n  prefixList trace' trace''\n\ngoal (1 subgoal):\n 1. prefixList trace trace''", "using PrefixListTransitive"], ["proof (prove)\nusing this:\n  prefixList trace trace'\n  prefixList trace' trace''\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n\ngoal (1 subgoal):\n 1. prefixList trace trace''", "by auto"], ["proof (state)\nthis:\n  prefixList trace trace''\n\ngoal (2 subgoals):\n 1. \\<And>msg cfg3 exec' trace'.\n       \\<lbrakk>reachable (last exec) (last exec');\n        last exec' \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; execution trans sends start exec trace;\n        cfgLast = last exec; execution trans sends start exec' trace';\n        prefixList exec exec'; prefixList trace trace'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3\n 2. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "ultimately"], ["proof (chain)\npicking this:\n  prefixList exec exec''\n  prefixList trace trace''", "show \"\\<exists> exec'' trace'' .\n          execution trans sends start exec'' trace'' \\<and>\n          ((prefixList exec exec'' \\<and> prefixList trace trace'') \n          \\<or> (exec = exec'' \\<and> trace = trace'')) \\<and>\n          last exec'' = cfg3\""], ["proof (prove)\nusing this:\n  prefixList exec exec''\n  prefixList trace trace''\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       (prefixList exec exec'' \\<and> prefixList trace trace'' \\<or>\n        exec = exec'' \\<and> trace = trace'') \\<and>\n       last exec'' = cfg3", "using NewExec(1) NewExec(4)"], ["proof (prove)\nusing this:\n  prefixList exec exec''\n  prefixList trace trace''\n  execution trans sends start exec'' trace''\n  last exec'' = cfg3\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       (prefixList exec exec'' \\<and> prefixList trace trace'' \\<or>\n        exec = exec'' \\<and> trace = trace'') \\<and>\n       last exec'' = cfg3", "by blast"], ["proof (state)\nthis:\n  \\<exists>exec'' trace''.\n     execution trans sends start exec'' trace'' \\<and>\n     (prefixList exec exec'' \\<and> prefixList trace trace'' \\<or>\n      exec = exec'' \\<and> trace = trace'') \\<and>\n     last exec'' = cfg3\n\ngoal (1 subgoal):\n 1. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "fix msg cfg3"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "assume \"(last exec) \\<turnstile> msg \\<mapsto> cfg3\" \"execution trans sends start exec trace\""], ["proof (state)\nthis:\n  last exec \\<turnstile> msg \\<mapsto> cfg3\n  execution trans sends start exec trace\n\ngoal (1 subgoal):\n 1. \\<And>msg cfg3.\n       \\<lbrakk>reachable (last exec) (last exec);\n        last exec \\<turnstile> msg \\<mapsto> cfg3;\n        reachable (last exec) cfg; cfgLast = last exec;\n        execution trans sends start exec trace\\<rbrakk>\n       \\<Longrightarrow> \\<exists>exec' trace'.\n                            execution trans sends start exec' trace' \\<and>\n                            (prefixList exec exec' \\<and>\n                             prefixList trace trace' \\<or>\n                             exec = exec' \\<and> trace = trace') \\<and>\n                            last exec' = cfg3", "then"], ["proof (chain)\npicking this:\n  last exec \\<turnstile> msg \\<mapsto> cfg3\n  execution trans sends start exec trace", "show\n    \"\\<exists>exec' trace'. execution trans sends start exec' trace' \\<and>\n       (prefixList exec exec' \\<and> prefixList trace trace' \n        \\<or> exec = exec' \\<and> trace = trace') \\<and> last exec' = cfg3\""], ["proof (prove)\nusing this:\n  last exec \\<turnstile> msg \\<mapsto> cfg3\n  execution trans sends start exec trace\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       (prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n        exec = exec' \\<and> trace = trace') \\<and>\n       last exec' = cfg3", "using expandExecutionStep"], ["proof (prove)\nusing this:\n  last exec \\<turnstile> msg \\<mapsto> cfg3\n  execution trans sends start exec trace\n  \\<lbrakk>last ?exec' \\<turnstile> ?msg \\<mapsto> ?cMsg;\n   execution trans sends start ?exec' ?trace'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>exec'' trace''.\n                       execution trans sends start exec'' trace'' \\<and>\n                       prefixList ?exec' exec'' \\<and>\n                       prefixList ?trace' trace'' \\<and>\n                       last exec'' = ?cMsg \\<and> last trace'' = ?msg\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       (prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n        exec = exec' \\<and> trace = trace') \\<and>\n       last exec' = cfg3", "by blast"], ["proof (state)\nthis:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     (prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n      exec = exec' \\<and> trace = trace') \\<and>\n     last exec' = cfg3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in asynchronousSystem) expandExecution:\nfixes \n  cfg :: \"('p, 'v, 's ) configuration\" and\n  cfgLast :: \"('p, 'v, 's ) configuration\"\nassumes\n  CfgIsReachable: \"stepReachable (last exec) msg cfg\" and\n  ExecIsExecution: \"execution trans sends start exec trace\"\nshows\n  \"\\<exists> exec' trace'. (execution trans sends start exec' trace') \n  \\<and> (prefixList exec exec') \n  \\<and> (prefixList trace trace') \\<and> (last exec') = cfg \n  \\<and> (msg \\<in> set (drop (length trace) trace'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "from CfgIsReachable"], ["proof (chain)\npicking this:\n  stepReachable (last exec) msg cfg", "obtain c' c'' where \n    Step: \"reachable (last exec) c'\" \"c' \\<turnstile> msg \\<mapsto> c''\" \"reachable c'' cfg\""], ["proof (prove)\nusing this:\n  stepReachable (last exec) msg cfg\n\ngoal (1 subgoal):\n 1. (\\<And>c' c''.\n        \\<lbrakk>reachable (last exec) c';\n         c' \\<turnstile> msg \\<mapsto> c''; reachable c'' cfg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: stepReachable_def)"], ["proof (state)\nthis:\n  reachable (last exec) c'\n  c' \\<turnstile> msg \\<mapsto> c''\n  reachable c'' cfg\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "from Step(1) ExecIsExecution"], ["proof (chain)\npicking this:\n  reachable (last exec) c'\n  execution trans sends start exec trace", "have \"\\<exists> exec' trace' .\n    execution trans sends start exec' trace' \\<and>\n    ((prefixList exec exec' \\<and> prefixList trace trace') \n    \\<or> (exec = exec' \\<and> trace = trace')) \\<and>\n    last exec' = c'\""], ["proof (prove)\nusing this:\n  reachable (last exec) c'\n  execution trans sends start exec trace\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       (prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n        exec = exec' \\<and> trace = trace') \\<and>\n       last exec' = c'", "by (auto simp add: expandExecutionReachable)"], ["proof (state)\nthis:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     (prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n      exec = exec' \\<and> trace = trace') \\<and>\n     last exec' = c'\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "then"], ["proof (chain)\npicking this:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     (prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n      exec = exec' \\<and> trace = trace') \\<and>\n     last exec' = c'", "obtain  exec' trace' where Exec': \n    \"execution trans sends start exec' trace'\"\n    \"(prefixList exec exec' \\<and> prefixList trace trace') \n      \\<or> (exec = exec' \\<and> trace = trace')\"\n    \"last exec' = c'\""], ["proof (prove)\nusing this:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     (prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n      exec = exec' \\<and> trace = trace') \\<and>\n     last exec' = c'\n\ngoal (1 subgoal):\n 1. (\\<And>exec' trace'.\n        \\<lbrakk>execution trans sends start exec' trace';\n         prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n         exec = exec' \\<and> trace = trace';\n         last exec' = c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution trans sends start exec' trace'\n  prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n  exec = exec' \\<and> trace = trace'\n  last exec' = c'\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "from Exec'(1) Exec'(3) Step(2)"], ["proof (chain)\npicking this:\n  execution trans sends start exec' trace'\n  last exec' = c'\n  c' \\<turnstile> msg \\<mapsto> c''", "have \"\\<exists> exec'' trace'' . \n    execution trans sends start exec'' trace'' \\<and>\n    prefixList exec' exec'' \\<and> prefixList trace' trace'' \n    \\<and> last exec'' = c'' \\<and> last trace'' = msg\""], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  last exec' = c'\n  c' \\<turnstile> msg \\<mapsto> c''\n\ngoal (1 subgoal):\n 1. \\<exists>exec'' trace''.\n       execution trans sends start exec'' trace'' \\<and>\n       prefixList exec' exec'' \\<and>\n       prefixList trace' trace'' \\<and>\n       last exec'' = c'' \\<and> last trace'' = msg", "by (auto simp add: expandExecutionStep)"], ["proof (state)\nthis:\n  \\<exists>exec'' trace''.\n     execution trans sends start exec'' trace'' \\<and>\n     prefixList exec' exec'' \\<and>\n     prefixList trace' trace'' \\<and>\n     last exec'' = c'' \\<and> last trace'' = msg\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "then"], ["proof (chain)\npicking this:\n  \\<exists>exec'' trace''.\n     execution trans sends start exec'' trace'' \\<and>\n     prefixList exec' exec'' \\<and>\n     prefixList trace' trace'' \\<and>\n     last exec'' = c'' \\<and> last trace'' = msg", "obtain exec'' trace'' where Exec'': \n    \"execution trans sends start exec'' trace''\"\n    \"prefixList exec' exec''\" \"prefixList trace' trace''\" \n    \"last exec'' = c''\" \"last trace'' = msg\""], ["proof (prove)\nusing this:\n  \\<exists>exec'' trace''.\n     execution trans sends start exec'' trace'' \\<and>\n     prefixList exec' exec'' \\<and>\n     prefixList trace' trace'' \\<and>\n     last exec'' = c'' \\<and> last trace'' = msg\n\ngoal (1 subgoal):\n 1. (\\<And>exec'' trace''.\n        \\<lbrakk>execution trans sends start exec'' trace'';\n         prefixList exec' exec''; prefixList trace' trace'';\n         last exec'' = c''; last trace'' = msg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution trans sends start exec'' trace''\n  prefixList exec' exec''\n  prefixList trace' trace''\n  last exec'' = c''\n  last trace'' = msg\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "have PrefixLists: \"prefixList exec exec'' \\<and> prefixList trace trace''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList exec exec'' \\<and> prefixList trace trace''", "proof(cases \"exec = exec' \\<and> trace = trace'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. exec = exec' \\<and> trace = trace' \\<Longrightarrow>\n    prefixList exec exec'' \\<and> prefixList trace trace''\n 2. \\<not> (exec = exec' \\<and> trace = trace') \\<Longrightarrow>\n    prefixList exec exec'' \\<and> prefixList trace trace''", "case True"], ["proof (state)\nthis:\n  exec = exec' \\<and> trace = trace'\n\ngoal (2 subgoals):\n 1. exec = exec' \\<and> trace = trace' \\<Longrightarrow>\n    prefixList exec exec'' \\<and> prefixList trace trace''\n 2. \\<not> (exec = exec' \\<and> trace = trace') \\<Longrightarrow>\n    prefixList exec exec'' \\<and> prefixList trace trace''", "with Exec''"], ["proof (chain)\npicking this:\n  execution trans sends start exec'' trace''\n  prefixList exec' exec''\n  prefixList trace' trace''\n  last exec'' = c''\n  last trace'' = msg\n  exec = exec' \\<and> trace = trace'", "show \"prefixList exec exec'' \\<and> prefixList trace trace''\""], ["proof (prove)\nusing this:\n  execution trans sends start exec'' trace''\n  prefixList exec' exec''\n  prefixList trace' trace''\n  last exec'' = c''\n  last trace'' = msg\n  exec = exec' \\<and> trace = trace'\n\ngoal (1 subgoal):\n 1. prefixList exec exec'' \\<and> prefixList trace trace''", "by auto"], ["proof (state)\nthis:\n  prefixList exec exec'' \\<and> prefixList trace trace''\n\ngoal (1 subgoal):\n 1. \\<not> (exec = exec' \\<and> trace = trace') \\<Longrightarrow>\n    prefixList exec exec'' \\<and> prefixList trace trace''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (exec = exec' \\<and> trace = trace') \\<Longrightarrow>\n    prefixList exec exec'' \\<and> prefixList trace trace''", "case False"], ["proof (state)\nthis:\n  \\<not> (exec = exec' \\<and> trace = trace')\n\ngoal (1 subgoal):\n 1. \\<not> (exec = exec' \\<and> trace = trace') \\<Longrightarrow>\n    prefixList exec exec'' \\<and> prefixList trace trace''", "with Exec'(2)"], ["proof (chain)\npicking this:\n  prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n  exec = exec' \\<and> trace = trace'\n  \\<not> (exec = exec' \\<and> trace = trace')", "have Prefix: \"prefixList exec exec'\" \n      \"prefixList trace trace'\""], ["proof (prove)\nusing this:\n  prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n  exec = exec' \\<and> trace = trace'\n  \\<not> (exec = exec' \\<and> trace = trace')\n\ngoal (1 subgoal):\n 1. prefixList exec exec' &&& prefixList trace trace'", "by auto"], ["proof (state)\nthis:\n  prefixList exec exec'\n  prefixList trace trace'\n\ngoal (1 subgoal):\n 1. \\<not> (exec = exec' \\<and> trace = trace') \\<Longrightarrow>\n    prefixList exec exec'' \\<and> prefixList trace trace''", "from Prefix(1) Exec''(2)"], ["proof (chain)\npicking this:\n  prefixList exec exec'\n  prefixList exec' exec''", "have \"prefixList exec exec''\""], ["proof (prove)\nusing this:\n  prefixList exec exec'\n  prefixList exec' exec''\n\ngoal (1 subgoal):\n 1. prefixList exec exec''", "using PrefixListTransitive"], ["proof (prove)\nusing this:\n  prefixList exec exec'\n  prefixList exec' exec''\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n\ngoal (1 subgoal):\n 1. prefixList exec exec''", "by auto"], ["proof (state)\nthis:\n  prefixList exec exec''\n\ngoal (1 subgoal):\n 1. \\<not> (exec = exec' \\<and> trace = trace') \\<Longrightarrow>\n    prefixList exec exec'' \\<and> prefixList trace trace''", "with Prefix(2) Exec''(3)"], ["proof (chain)\npicking this:\n  prefixList trace trace'\n  prefixList trace' trace''\n  prefixList exec exec''", "show  \"prefixList exec exec'' \n      \\<and> prefixList trace trace''\""], ["proof (prove)\nusing this:\n  prefixList trace trace'\n  prefixList trace' trace''\n  prefixList exec exec''\n\ngoal (1 subgoal):\n 1. prefixList exec exec'' \\<and> prefixList trace trace''", "using PrefixListTransitive"], ["proof (prove)\nusing this:\n  prefixList trace trace'\n  prefixList trace' trace''\n  prefixList exec exec''\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n\ngoal (1 subgoal):\n 1. prefixList exec exec'' \\<and> prefixList trace trace''", "by auto"], ["proof (state)\nthis:\n  prefixList exec exec'' \\<and> prefixList trace trace''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixList exec exec'' \\<and> prefixList trace trace''\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "with Exec''(5)"], ["proof (chain)\npicking this:\n  last trace'' = msg\n  prefixList exec exec'' \\<and> prefixList trace trace''", "have MsgInTrace'': \"msg \\<in> set (drop (length trace) trace'')\""], ["proof (prove)\nusing this:\n  last trace'' = msg\n  prefixList exec exec'' \\<and> prefixList trace trace''\n\ngoal (1 subgoal):\n 1. msg \\<in> set (drop (length trace) trace'')", "by (metis PrefixListMonotonicity drop_eq_Nil last_drop \n      last_in_set not_le)"], ["proof (state)\nthis:\n  msg \\<in> set (drop (length trace) trace'')\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "from Step(3) Exec''(1) Exec''(4)"], ["proof (chain)\npicking this:\n  reachable c'' cfg\n  execution trans sends start exec'' trace''\n  last exec'' = c''", "have \"\\<exists> exec''' trace''' .\n    execution trans sends start exec''' trace''' \\<and>\n    ((prefixList exec'' exec''' \\<and> prefixList trace'' trace''') \n    \\<or> (exec'' = exec''' \\<and> trace'' = trace''')) \\<and>\n    last exec''' = cfg\""], ["proof (prove)\nusing this:\n  reachable c'' cfg\n  execution trans sends start exec'' trace''\n  last exec'' = c''\n\ngoal (1 subgoal):\n 1. \\<exists>exec''' trace'''.\n       execution trans sends start exec''' trace''' \\<and>\n       (prefixList exec'' exec''' \\<and> prefixList trace'' trace''' \\<or>\n        exec'' = exec''' \\<and> trace'' = trace''') \\<and>\n       last exec''' = cfg", "by (auto simp add: expandExecutionReachable)"], ["proof (state)\nthis:\n  \\<exists>exec''' trace'''.\n     execution trans sends start exec''' trace''' \\<and>\n     (prefixList exec'' exec''' \\<and> prefixList trace'' trace''' \\<or>\n      exec'' = exec''' \\<and> trace'' = trace''') \\<and>\n     last exec''' = cfg\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "then"], ["proof (chain)\npicking this:\n  \\<exists>exec''' trace'''.\n     execution trans sends start exec''' trace''' \\<and>\n     (prefixList exec'' exec''' \\<and> prefixList trace'' trace''' \\<or>\n      exec'' = exec''' \\<and> trace'' = trace''') \\<and>\n     last exec''' = cfg", "obtain exec''' trace''' where Exec''': \n    \"execution trans sends start exec''' trace'''\"\n    \"(prefixList exec'' exec''' \\<and> prefixList trace'' trace''') \n    \\<or> (exec'' = exec''' \\<and> trace'' = trace''')\"\n    \"last exec''' = cfg\""], ["proof (prove)\nusing this:\n  \\<exists>exec''' trace'''.\n     execution trans sends start exec''' trace''' \\<and>\n     (prefixList exec'' exec''' \\<and> prefixList trace'' trace''' \\<or>\n      exec'' = exec''' \\<and> trace'' = trace''') \\<and>\n     last exec''' = cfg\n\ngoal (1 subgoal):\n 1. (\\<And>exec''' trace'''.\n        \\<lbrakk>execution trans sends start exec''' trace''';\n         prefixList exec'' exec''' \\<and> prefixList trace'' trace''' \\<or>\n         exec'' = exec''' \\<and> trace'' = trace''';\n         last exec''' = cfg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution trans sends start exec''' trace'''\n  prefixList exec'' exec''' \\<and> prefixList trace'' trace''' \\<or>\n  exec'' = exec''' \\<and> trace'' = trace'''\n  last exec''' = cfg\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "have \"prefixList exec exec''' \\<and> prefixList trace trace''' \n    \\<and> msg \\<in> set (drop (length trace) trace''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "proof(cases \"exec'' = exec''' \\<and> trace'' = trace'''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. exec'' = exec''' \\<and> trace'' = trace''' \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')\n 2. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "case True"], ["proof (state)\nthis:\n  exec'' = exec''' \\<and> trace'' = trace'''\n\ngoal (2 subgoals):\n 1. exec'' = exec''' \\<and> trace'' = trace''' \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')\n 2. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "with PrefixLists MsgInTrace''"], ["proof (chain)\npicking this:\n  prefixList exec exec'' \\<and> prefixList trace trace''\n  msg \\<in> set (drop (length trace) trace'')\n  exec'' = exec''' \\<and> trace'' = trace'''", "show \"prefixList exec exec''' \\<and> prefixList trace trace''' \n    \\<and> msg \\<in> set (drop (length trace) trace''')\""], ["proof (prove)\nusing this:\n  prefixList exec exec'' \\<and> prefixList trace trace''\n  msg \\<in> set (drop (length trace) trace'')\n  exec'' = exec''' \\<and> trace'' = trace'''\n\ngoal (1 subgoal):\n 1. prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "by auto"], ["proof (state)\nthis:\n  prefixList exec exec''' \\<and>\n  prefixList trace trace''' \\<and>\n  msg \\<in> set (drop (length trace) trace''')\n\ngoal (1 subgoal):\n 1. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "case False"], ["proof (state)\nthis:\n  \\<not> (exec'' = exec''' \\<and> trace'' = trace''')\n\ngoal (1 subgoal):\n 1. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "with Exec'''(2)"], ["proof (chain)\npicking this:\n  prefixList exec'' exec''' \\<and> prefixList trace'' trace''' \\<or>\n  exec'' = exec''' \\<and> trace'' = trace'''\n  \\<not> (exec'' = exec''' \\<and> trace'' = trace''')", "have Prefix: \"prefixList exec'' exec'''\" \n      \"prefixList trace'' trace'''\""], ["proof (prove)\nusing this:\n  prefixList exec'' exec''' \\<and> prefixList trace'' trace''' \\<or>\n  exec'' = exec''' \\<and> trace'' = trace'''\n  \\<not> (exec'' = exec''' \\<and> trace'' = trace''')\n\ngoal (1 subgoal):\n 1. prefixList exec'' exec''' &&& prefixList trace'' trace'''", "by auto"], ["proof (state)\nthis:\n  prefixList exec'' exec'''\n  prefixList trace'' trace'''\n\ngoal (1 subgoal):\n 1. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "from Prefix(1) PrefixLists"], ["proof (chain)\npicking this:\n  prefixList exec'' exec'''\n  prefixList exec exec'' \\<and> prefixList trace trace''", "have \"prefixList exec exec'''\""], ["proof (prove)\nusing this:\n  prefixList exec'' exec'''\n  prefixList exec exec'' \\<and> prefixList trace trace''\n\ngoal (1 subgoal):\n 1. prefixList exec exec'''", "using PrefixListTransitive"], ["proof (prove)\nusing this:\n  prefixList exec'' exec'''\n  prefixList exec exec'' \\<and> prefixList trace trace''\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n\ngoal (1 subgoal):\n 1. prefixList exec exec'''", "by auto"], ["proof (state)\nthis:\n  prefixList exec exec'''\n\ngoal (1 subgoal):\n 1. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "with Prefix(2) PrefixLists"], ["proof (chain)\npicking this:\n  prefixList trace'' trace'''\n  prefixList exec exec'' \\<and> prefixList trace trace''\n  prefixList exec exec'''", "have \"prefixList exec exec''' \n      \\<and> prefixList trace trace'''\""], ["proof (prove)\nusing this:\n  prefixList trace'' trace'''\n  prefixList exec exec'' \\<and> prefixList trace trace''\n  prefixList exec exec'''\n\ngoal (1 subgoal):\n 1. prefixList exec exec''' \\<and> prefixList trace trace'''", "using PrefixListTransitive"], ["proof (prove)\nusing this:\n  prefixList trace'' trace'''\n  prefixList exec exec'' \\<and> prefixList trace trace''\n  prefixList exec exec'''\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n\ngoal (1 subgoal):\n 1. prefixList exec exec''' \\<and> prefixList trace trace'''", "by auto"], ["proof (state)\nthis:\n  prefixList exec exec''' \\<and> prefixList trace trace'''\n\ngoal (1 subgoal):\n 1. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "moreover"], ["proof (state)\nthis:\n  prefixList exec exec''' \\<and> prefixList trace trace'''\n\ngoal (1 subgoal):\n 1. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "have \"msg \\<in> set (drop (length trace) trace''')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg \\<in> set (drop (length trace) trace''')", "using Prefix(2) PrefixLists MsgInTrace''"], ["proof (prove)\nusing this:\n  prefixList trace'' trace'''\n  prefixList exec exec'' \\<and> prefixList trace trace''\n  msg \\<in> set (drop (length trace) trace'')\n\ngoal (1 subgoal):\n 1. msg \\<in> set (drop (length trace) trace''')", "by (metis (hide_lams, no_types) PrefixListHasTail append_eq_conv_conj \n         drop_take rev_subsetD set_take_subset)"], ["proof (state)\nthis:\n  msg \\<in> set (drop (length trace) trace''')\n\ngoal (1 subgoal):\n 1. \\<not> (exec'' = exec''' \\<and> trace'' = trace''') \\<Longrightarrow>\n    prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "ultimately"], ["proof (chain)\npicking this:\n  prefixList exec exec''' \\<and> prefixList trace trace'''\n  msg \\<in> set (drop (length trace) trace''')", "show ?thesis"], ["proof (prove)\nusing this:\n  prefixList exec exec''' \\<and> prefixList trace trace'''\n  msg \\<in> set (drop (length trace) trace''')\n\ngoal (1 subgoal):\n 1. prefixList exec exec''' \\<and>\n    prefixList trace trace''' \\<and>\n    msg \\<in> set (drop (length trace) trace''')", "by auto"], ["proof (state)\nthis:\n  prefixList exec exec''' \\<and>\n  prefixList trace trace''' \\<and>\n  msg \\<in> set (drop (length trace) trace''')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixList exec exec''' \\<and>\n  prefixList trace trace''' \\<and>\n  msg \\<in> set (drop (length trace) trace''')\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "with Exec'''(1) Exec'''(3)"], ["proof (chain)\npicking this:\n  execution trans sends start exec''' trace'''\n  last exec''' = cfg\n  prefixList exec exec''' \\<and>\n  prefixList trace trace''' \\<and>\n  msg \\<in> set (drop (length trace) trace''')", "show ?thesis"], ["proof (prove)\nusing this:\n  execution trans sends start exec''' trace'''\n  last exec''' = cfg\n  prefixList exec exec''' \\<and>\n  prefixList trace trace''' \\<and>\n  msg \\<in> set (drop (length trace) trace''')\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')", "by blast"], ["proof (state)\nthis:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     prefixList exec exec' \\<and>\n     prefixList trace trace' \\<and>\n     last exec' = cfg \\<and> msg \\<in> set (drop (length trace) trace')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Infinite and fair executions\\<close>"], ["", "text \\<open>\n  V?lzer does not give much attention to the definition of the\n  infinite executions. We derive them from finite executions by considering\n  infinite executions to be infinite sequence of finite executions increasing\n  monotonically w.r.t. the list prefix relation.\n\\<close>"], ["", "definition (in asynchronousSystem) infiniteExecution ::\n  \"(nat \\<Rightarrow> (('p, 'v, 's) configuration list)) \n  \\<Rightarrow> (nat \\<Rightarrow> (('p, 'v) message list)) \\<Rightarrow> bool\"\nwhere\n  \"infiniteExecution fe ft \\<equiv>\n    \\<forall> n . execution trans sends start (fe n) (ft n) \\<and> \n      prefixList (fe n) (fe (n+1)) \\<and>\n      prefixList (ft n) (ft (n+1))\""], ["", "definition (in asynchronousSystem) correctInfinite ::\n  \"(nat \\<Rightarrow> (('p, 'v, 's) configuration list)) \n  \\<Rightarrow> (nat \\<Rightarrow> (('p, 'v) message list)) \\<Rightarrow> 'p \\<Rightarrow> bool\"\nwhere \n  \"correctInfinite fe ft p \\<equiv> \n    infiniteExecution fe ft\n    \\<and> (\\<forall> n . \\<forall> n0 < length (fe n). \\<forall> msg .(enabled ((fe n) ! n0) msg) \n    \\<and> isReceiverOf p msg \n    \\<longrightarrow> (\\<exists> msg' . \\<exists> n' \\<ge> n . \\<exists> n0' \\<ge> n0 .isReceiverOf p msg' \n    \\<and> n0' < length (fe n') \\<and> (msg' = ((ft n') ! n0'))))\""], ["", "definition (in asynchronousSystem) fairInfiniteExecution ::\n  \"(nat \\<Rightarrow> (('p, 'v, 's) configuration list)) \n  \\<Rightarrow> (nat \\<Rightarrow> (('p, 'v) message list)) \\<Rightarrow> bool\"\nwhere\n  \"fairInfiniteExecution fe ft \\<equiv>\n    infiniteExecution fe ft\n    \\<and> (\\<forall> n . \\<forall> n0 < length (fe n). \\<forall> p . \\<forall> msg . \n      ((enabled ((fe n) ! n0) msg) \n        \\<and> isReceiverOf p msg \\<and> correctInfinite fe ft p ) \n      \\<longrightarrow> (\\<exists> n' \\<ge> n . \\<exists> n0' \\<ge> n0 . n0' < length (ft n') \n        \\<and> (msg = ((ft n') ! n0'))))\""], ["", "end"]]}