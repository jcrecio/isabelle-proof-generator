{"file_name": "/home/qj213/afp-2021-10-22/thys/FLP/FLPTheorem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FLP", "problem_names": ["lemma NonUniformExecutionsConstructable:\nfixes\n  exec :: \"('p, 'v, 's ) configuration list \" and\n  trace :: \"('p, 'v) message list\" and \n  msg :: \"('p, 'v) message\" and\n  p :: 'p  \nassumes\n  MsgEnabled: \"enabled (last exec) msg\" and\n  PisReceiverOf: \"isReceiverOf p msg\" and\n  ExecIsExecution: \"execution trans sends start exec trace\" and\n  NonUniformLexec: \"nonUniform (last exec)\" and\n  Agree: \"\\<And> cfg . reachable (last exec) cfg \\<longrightarrow> agreement cfg\"\nshows\n  \"\\<exists> exec' trace' . (execution trans sends start exec' trace') \n    \\<and> nonUniform (last exec')\n    \\<and> prefixList exec exec' \\<and> prefixList trace trace' \n    \\<and> (\\<forall> cfg . reachable (last exec') cfg \\<longrightarrow> agreement cfg)\n    \\<and> stepReachable (last exec) msg (last exec') \n    \\<and> (msg \\<in> set (drop (length trace) trace'))\"", "lemma NonUniformExecutionBase:\nfixes\n  cfg\nassumes\n  Cfg: \"initial cfg\" \"nonUniform cfg\"\nshows \n  \"execution trans sends start [cfg] [] \n  \\<and> nonUniform (last [cfg]) \n  \\<and> (\\<exists> cfgList' msgList'.  nonUniform (last cfgList') \n    \\<and> prefixList [cfg] cfgList' \n    \\<and> prefixList [] msgList'\n    \\<and> (execution trans sends start cfgList' msgList')\n     \\<and> (\\<exists> msg'. execution.minimalEnabled [cfg] [] msg' \n         \\<and> msg' \\<in> set msgList'))\"", "lemma NonUniformExecutionStep:\nfixes\n cfgList msgList\nassumes\n  Init: \"initial (hd cfgList)\" and\n  NonUni: \"nonUniform (last cfgList)\" and\n  Execution: \"execution trans sends start cfgList msgList\"\nshows\n  \"(\\<exists> cfgList' msgList' .\n      nonUniform (last cfgList') \n      \\<and> prefixList cfgList cfgList' \n      \\<and> prefixList msgList msgList'\n      \\<and> (execution trans sends start cfgList' msgList') \n      \\<and> (initial (hd cfgList'))\n      \\<and> (\\<exists> msg'. execution.minimalEnabled cfgList msgList msg' \n        \\<and> msg' \\<in> (set (drop (length msgList ) msgList')) ))\"", "lemma FairNonUniformExecution:\nfixes\n  cfg\nassumes\n  Cfg: \"initial cfg\" \"nonUniform cfg\"\nshows \"\\<exists> fe ft.\n  (fe 0) = [cfg]\n  \\<and> fairInfiniteExecution fe ft\n  \\<and> (\\<forall> n . nonUniform (last (fe n))\n       \\<and> prefixList (fe n) (fe (n+1)) \n       \\<and> prefixList (ft n) (ft (n+1))\n       \\<and> (execution trans sends start (fe n) (ft n)))\"", "theorem ConsensusFails:\nassumes \n  Termination:\n    \"\\<And> fe ft . (fairInfiniteExecution fe ft \\<Longrightarrow> terminationFLP fe ft)\" and\n  Validity: \"\\<forall> i c . validity i c\" and\n  Agreement: \"\\<forall> i c . agreementInit i c\"\nshows\n  \"False\""], "translations": [["", "lemma NonUniformExecutionsConstructable:\nfixes\n  exec :: \"('p, 'v, 's ) configuration list \" and\n  trace :: \"('p, 'v) message list\" and \n  msg :: \"('p, 'v) message\" and\n  p :: 'p  \nassumes\n  MsgEnabled: \"enabled (last exec) msg\" and\n  PisReceiverOf: \"isReceiverOf p msg\" and\n  ExecIsExecution: \"execution trans sends start exec trace\" and\n  NonUniformLexec: \"nonUniform (last exec)\" and\n  Agree: \"\\<And> cfg . reachable (last exec) cfg \\<longrightarrow> agreement cfg\"\nshows\n  \"\\<exists> exec' trace' . (execution trans sends start exec' trace') \n    \\<and> nonUniform (last exec')\n    \\<and> prefixList exec exec' \\<and> prefixList trace trace' \n    \\<and> (\\<forall> cfg . reachable (last exec') cfg \\<longrightarrow> agreement cfg)\n    \\<and> stepReachable (last exec) msg (last exec') \n    \\<and> (msg \\<in> set (drop (length trace) trace'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "from NonUniformCanReachSilentBivalence[OF NonUniformLexec PseudoTermination Agree]"], ["proof (chain)\npicking this:\n  \\<exists>c'. reachable (last exec) c' \\<and> val[?p,c'] = {True, False}", "obtain c' where C':\n      \"reachable (last exec) c'\" \n      \"val[p,c'] = {True, False}\""], ["proof (prove)\nusing this:\n  \\<exists>c'. reachable (last exec) c' \\<and> val[?p,c'] = {True, False}\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        \\<lbrakk>reachable (last exec) c';\n         val[p,c'] = {True, False}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  reachable (last exec) c'\n  val[p,c'] = {True, False}\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "proof (cases \"stepReachable (last exec) msg c'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')\n 2. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "case True"], ["proof (state)\nthis:\n  stepReachable (last exec) msg c'\n\ngoal (2 subgoals):\n 1. stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')\n 2. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "hence IsStepReachable: \"stepReachable (last exec) msg c'\""], ["proof (prove)\nusing this:\n  stepReachable (last exec) msg c'\n\ngoal (1 subgoal):\n 1. stepReachable (last exec) msg c'", "by simp"], ["proof (state)\nthis:\n  stepReachable (last exec) msg c'\n\ngoal (2 subgoals):\n 1. stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')\n 2. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "hence \"\\<exists> exec' trace'. (execution trans sends start exec' trace') \n      \\<and> prefixList exec exec' \n      \\<and> prefixList trace trace' \\<and> (last exec') = c' \n      \\<and> msg \\<in> set (drop (length trace) trace')\""], ["proof (prove)\nusing this:\n  stepReachable (last exec) msg c'\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = c' \\<and> msg \\<in> set (drop (length trace) trace')", "using ExecIsExecution expandExecution"], ["proof (prove)\nusing this:\n  stepReachable (last exec) msg c'\n  execution trans sends start exec trace\n  \\<lbrakk>stepReachable (last ?exec) ?msg ?cfg;\n   execution trans sends start ?exec ?trace\\<rbrakk>\n  \\<Longrightarrow> \\<exists>exec' trace'.\n                       execution trans sends start exec' trace' \\<and>\n                       prefixList ?exec exec' \\<and>\n                       prefixList ?trace trace' \\<and>\n                       last exec' = ?cfg \\<and>\n                       ?msg \\<in> set (drop (length ?trace) trace')\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       last exec' = c' \\<and> msg \\<in> set (drop (length trace) trace')", "by auto"], ["proof (state)\nthis:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     prefixList exec exec' \\<and>\n     prefixList trace trace' \\<and>\n     last exec' = c' \\<and> msg \\<in> set (drop (length trace) trace')\n\ngoal (2 subgoals):\n 1. stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')\n 2. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "then"], ["proof (chain)\npicking this:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     prefixList exec exec' \\<and>\n     prefixList trace trace' \\<and>\n     last exec' = c' \\<and> msg \\<in> set (drop (length trace) trace')", "obtain exec' trace' where NewExec: \n      \"(execution trans sends start exec' trace')\" \n      \"prefixList exec exec'\" \"(last exec') = c'\" \"prefixList trace trace'\" \n      \"msg \\<in> set (drop (length trace) trace')\""], ["proof (prove)\nusing this:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     prefixList exec exec' \\<and>\n     prefixList trace trace' \\<and>\n     last exec' = c' \\<and> msg \\<in> set (drop (length trace) trace')\n\ngoal (1 subgoal):\n 1. (\\<And>exec' trace'.\n        \\<lbrakk>execution trans sends start exec' trace';\n         prefixList exec exec'; last exec' = c'; prefixList trace trace';\n         msg \\<in> set (drop (length trace) trace')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution trans sends start exec' trace'\n  prefixList exec exec'\n  last exec' = c'\n  prefixList trace trace'\n  msg \\<in> set (drop (length trace) trace')\n\ngoal (2 subgoals):\n 1. stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')\n 2. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "hence lastExecExec'Reachable: \"reachable (last exec) (last exec')\""], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  prefixList exec exec'\n  last exec' = c'\n  prefixList trace trace'\n  msg \\<in> set (drop (length trace) trace')\n\ngoal (1 subgoal):\n 1. reachable (last exec) (last exec')", "using C'(1)"], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  prefixList exec exec'\n  last exec' = c'\n  prefixList trace trace'\n  msg \\<in> set (drop (length trace) trace')\n  reachable (last exec) c'\n\ngoal (1 subgoal):\n 1. reachable (last exec) (last exec')", "by simp"], ["proof (state)\nthis:\n  reachable (last exec) (last exec')\n\ngoal (2 subgoals):\n 1. stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')\n 2. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "hence InitReachLastExec':  \"initReachable (last exec')\""], ["proof (prove)\nusing this:\n  reachable (last exec) (last exec')\n\ngoal (1 subgoal):\n 1. initReachable (last exec')", "using NonUniformLexec"], ["proof (prove)\nusing this:\n  reachable (last exec) (last exec')\n  nonUniform (last exec)\n\ngoal (1 subgoal):\n 1. initReachable (last exec')", "by (metis ReachableTrans initReachable_def)"], ["proof (state)\nthis:\n  initReachable (last exec')\n\ngoal (2 subgoals):\n 1. stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')\n 2. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "hence nonUniformC': \"nonUniform (last exec')\""], ["proof (prove)\nusing this:\n  initReachable (last exec')\n\ngoal (1 subgoal):\n 1. nonUniform (last exec')", "using C'(2) NewExec(3)"], ["proof (prove)\nusing this:\n  initReachable (last exec')\n  val[p,c'] = {True, False}\n  last exec' = c'\n\ngoal (1 subgoal):\n 1. nonUniform (last exec')", "by (auto simp add: vUniform_def)"], ["proof (state)\nthis:\n  nonUniform (last exec')\n\ngoal (2 subgoals):\n 1. stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')\n 2. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "hence isAgreementPreventing: \n      \"(\\<forall> cfg . reachable (last exec') cfg \\<longrightarrow> agreement cfg)\""], ["proof (prove)\nusing this:\n  nonUniform (last exec')\n\ngoal (1 subgoal):\n 1. \\<forall>cfg. reachable (last exec') cfg \\<longrightarrow> agreement cfg", "using lastExecExec'Reachable Agree"], ["proof (prove)\nusing this:\n  nonUniform (last exec')\n  reachable (last exec) (last exec')\n  reachable (last exec) ?cfg \\<longrightarrow> agreement ?cfg\n\ngoal (1 subgoal):\n 1. \\<forall>cfg. reachable (last exec') cfg \\<longrightarrow> agreement cfg", "by (metis ReachableTrans)"], ["proof (state)\nthis:\n  \\<forall>cfg. reachable (last exec') cfg \\<longrightarrow> agreement cfg\n\ngoal (2 subgoals):\n 1. stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')\n 2. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "with NewExec nonUniformC' IsStepReachable"], ["proof (chain)\npicking this:\n  execution trans sends start exec' trace'\n  prefixList exec exec'\n  last exec' = c'\n  prefixList trace trace'\n  msg \\<in> set (drop (length trace) trace')\n  nonUniform (last exec')\n  stepReachable (last exec) msg c'\n  \\<forall>cfg. reachable (last exec') cfg \\<longrightarrow> agreement cfg", "show ?thesis"], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  prefixList exec exec'\n  last exec' = c'\n  prefixList trace trace'\n  msg \\<in> set (drop (length trace) trace')\n  nonUniform (last exec')\n  stepReachable (last exec) msg c'\n  \\<forall>cfg. reachable (last exec') cfg \\<longrightarrow> agreement cfg\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "by auto"], ["proof (state)\nthis:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     nonUniform (last exec') \\<and>\n     prefixList exec exec' \\<and>\n     prefixList trace trace' \\<and>\n     (\\<forall>cfg.\n         reachable (last exec') cfg \\<longrightarrow> agreement cfg) \\<and>\n     stepReachable (last exec) msg (last exec') \\<and>\n     msg \\<in> set (drop (length trace) trace')\n\ngoal (1 subgoal):\n 1. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "case False"], ["proof (state)\nthis:\n  \\<not> stepReachable (last exec) msg c'\n\ngoal (1 subgoal):\n 1. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "hence NotStepReachable: \"\\<not> (stepReachable (last exec) msg c')\""], ["proof (prove)\nusing this:\n  \\<not> stepReachable (last exec) msg c'\n\ngoal (1 subgoal):\n 1. \\<not> stepReachable (last exec) msg c'", "by simp"], ["proof (state)\nthis:\n  \\<not> stepReachable (last exec) msg c'\n\ngoal (1 subgoal):\n 1. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "from C'(1)"], ["proof (chain)\npicking this:\n  reachable (last exec) c'", "obtain exec' trace' where NewExec: \n      \"execution trans sends start exec' trace'\"\n      \"(prefixList exec exec' \\<and> prefixList trace trace') \n      \\<or> (exec = exec' \\<and> trace = trace')\"\n      \"last exec' = c'\""], ["proof (prove)\nusing this:\n  reachable (last exec) c'\n\ngoal (1 subgoal):\n 1. (\\<And>exec' trace'.\n        \\<lbrakk>execution trans sends start exec' trace';\n         prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n         exec = exec' \\<and> trace = trace';\n         last exec' = c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ExecIsExecution expandExecutionReachable"], ["proof (prove)\nusing this:\n  reachable (last exec) c'\n  execution trans sends start exec trace\n  \\<lbrakk>reachable ?cfgLast ?cfg;\n   execution trans sends start ?exec ?trace; ?cfgLast = last ?exec\\<rbrakk>\n  \\<Longrightarrow> \\<exists>exec' trace'.\n                       execution trans sends start exec' trace' \\<and>\n                       (prefixList ?exec exec' \\<and>\n                        prefixList ?trace trace' \\<or>\n                        ?exec = exec' \\<and> ?trace = trace') \\<and>\n                       last exec' = ?cfg\n\ngoal (1 subgoal):\n 1. (\\<And>exec' trace'.\n        \\<lbrakk>execution trans sends start exec' trace';\n         prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n         exec = exec' \\<and> trace = trace';\n         last exec' = c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution trans sends start exec' trace'\n  prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n  exec = exec' \\<and> trace = trace'\n  last exec' = c'\n\ngoal (1 subgoal):\n 1. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "have lastExecExec'Reachable: \"reachable (last exec) (last exec')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (last exec) (last exec')", "using C'(1) NewExec(3)"], ["proof (prove)\nusing this:\n  reachable (last exec) c'\n  last exec' = c'\n\ngoal (1 subgoal):\n 1. reachable (last exec) (last exec')", "by simp"], ["proof (state)\nthis:\n  reachable (last exec) (last exec')\n\ngoal (1 subgoal):\n 1. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "with NonUniformLexec"], ["proof (chain)\npicking this:\n  nonUniform (last exec)\n  reachable (last exec) (last exec')", "have InitReachLastExec': \n      \"initReachable (last exec')\""], ["proof (prove)\nusing this:\n  nonUniform (last exec)\n  reachable (last exec) (last exec')\n\ngoal (1 subgoal):\n 1. initReachable (last exec')", "by (metis ReachableTrans initReachable_def)"], ["proof (state)\nthis:\n  initReachable (last exec')\n\ngoal (1 subgoal):\n 1. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "with C'(2) NewExec(3)"], ["proof (chain)\npicking this:\n  val[p,c'] = {True, False}\n  last exec' = c'\n  initReachable (last exec')", "have nonUniformC': \"nonUniform (last exec')\""], ["proof (prove)\nusing this:\n  val[p,c'] = {True, False}\n  last exec' = c'\n  initReachable (last exec')\n\ngoal (1 subgoal):\n 1. nonUniform (last exec')", "by (auto simp add: vUniform_def)"], ["proof (state)\nthis:\n  nonUniform (last exec')\n\ngoal (1 subgoal):\n 1. \\<not> stepReachable (last exec) msg c' \\<Longrightarrow>\n    \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList exec exec' \\<and>\n       prefixList trace trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec') \\<and>\n       msg \\<in> set (drop (length trace) trace')", "show \"\\<exists> exec1 trace1 . (execution trans sends start exec1 trace1) \n      \\<and> nonUniform (last exec1)\n      \\<and> prefixList exec exec1 \\<and> prefixList trace trace1 \n      \\<and> (\\<forall> cfg . reachable (last exec1) cfg \\<longrightarrow> agreement cfg)\n      \\<and> stepReachable (last exec) msg (last exec1) \n      \\<and> (msg \\<in> set (drop (length trace) trace1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "proof (cases \"enabled (last exec') msg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "case True"], ["proof (state)\nthis:\n  enabled (last exec') msg\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "hence EnabledMsg: \"enabled (last exec') msg\""], ["proof (prove)\nusing this:\n  enabled (last exec') msg\n\ngoal (1 subgoal):\n 1. enabled (last exec') msg", "by auto"], ["proof (state)\nthis:\n  enabled (last exec') msg\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "hence \"\\<exists> cMsg . ((last exec') \\<turnstile> msg \\<mapsto> cMsg )\""], ["proof (prove)\nusing this:\n  enabled (last exec') msg\n\ngoal (1 subgoal):\n 1. \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg", "proof (cases msg)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>enabled (last exec') msg; msg = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 2. \\<And>x2.\n       \\<lbrakk>enabled (last exec') msg;\n        msg = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 3. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "case (InMsg p' b)"], ["proof (state)\nthis:\n  msg = <p', inM b>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>enabled (last exec') msg; msg = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 2. \\<And>x2.\n       \\<lbrakk>enabled (last exec') msg;\n        msg = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 3. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "with PisReceiverOf"], ["proof (chain)\npicking this:\n  isReceiverOf p msg\n  msg = <p', inM b>", "have MsgIsInMsg: \"(msg = <p, inM b>)\""], ["proof (prove)\nusing this:\n  isReceiverOf p msg\n  msg = <p', inM b>\n\ngoal (1 subgoal):\n 1. msg = <p, inM b>", "by auto"], ["proof (state)\nthis:\n  msg = <p, inM b>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>enabled (last exec') msg; msg = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 2. \\<And>x2.\n       \\<lbrakk>enabled (last exec') msg;\n        msg = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 3. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "define cfgInM where \"cfgInM = \\<lparr>states = \\<lambda>proc. (\n        if proc = p then\n          trans p (states (last exec') p) (Bool b)\n        else states (last exec') proc),\n        msgs = (((sends p (states (last exec') p) (Bool b))\n              \\<union># (msgs (last exec')-# msg)))\\<rparr> \""], ["proof (state)\nthis:\n  cfgInM =\n  \\<lparr>states =\n            \\<lambda>proc.\n               if proc = p then trans p (states (last exec') p) (Bool b)\n               else states (last exec') proc,\n     msgs =\n       sends p (states (last exec') p)\n        (Bool b) \\<union># msgs (last exec') -# msg\\<rparr>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>enabled (last exec') msg; msg = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 2. \\<And>x2.\n       \\<lbrakk>enabled (last exec') msg;\n        msg = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 3. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "with UniqueReceiverOf MsgIsInMsg EnabledMsg"], ["proof (chain)\npicking this:\n  \\<lbrakk>isReceiverOf ?q ?msg; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> \\<not> isReceiverOf ?p ?msg\n  msg = <p, inM b>\n  enabled (last exec') msg\n  cfgInM =\n  \\<lparr>states =\n            \\<lambda>proc.\n               if proc = p then trans p (states (last exec') p) (Bool b)\n               else states (last exec') proc,\n     msgs =\n       sends p (states (last exec') p)\n        (Bool b) \\<union># msgs (last exec') -# msg\\<rparr>", "have \n          \"((last exec') \\<turnstile> msg \\<mapsto> cfgInM)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>isReceiverOf ?q ?msg; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> \\<not> isReceiverOf ?p ?msg\n  msg = <p, inM b>\n  enabled (last exec') msg\n  cfgInM =\n  \\<lparr>states =\n            \\<lambda>proc.\n               if proc = p then trans p (states (last exec') p) (Bool b)\n               else states (last exec') proc,\n     msgs =\n       sends p (states (last exec') p)\n        (Bool b) \\<union># msgs (last exec') -# msg\\<rparr>\n\ngoal (1 subgoal):\n 1. last exec' \\<turnstile> msg \\<mapsto> cfgInM", "by auto"], ["proof (state)\nthis:\n  last exec' \\<turnstile> msg \\<mapsto> cfgInM\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>enabled (last exec') msg; msg = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 2. \\<And>x2.\n       \\<lbrakk>enabled (last exec') msg;\n        msg = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 3. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "thus \"\\<exists> cMsg . ((last exec') \\<turnstile> msg \\<mapsto> cMsg )\""], ["proof (prove)\nusing this:\n  last exec' \\<turnstile> msg \\<mapsto> cfgInM\n\ngoal (1 subgoal):\n 1. \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg", "by blast"], ["proof (state)\nthis:\n  \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>enabled (last exec') msg;\n        msg = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 2. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>enabled (last exec') msg;\n        msg = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 2. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "case (OutMsg b)"], ["proof (state)\nthis:\n  msg = <\\<bottom>, outM b>\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>enabled (last exec') msg;\n        msg = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg\n 2. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "thus \"\\<exists> cMsg . ((last exec') \\<turnstile> msg \\<mapsto> cMsg )\""], ["proof (prove)\nusing this:\n  msg = <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg", "using PisReceiverOf"], ["proof (prove)\nusing this:\n  msg = <\\<bottom>, outM b>\n  isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg", "by auto"], ["proof (state)\nthis:\n  \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "case (Msg p' v')"], ["proof (state)\nthis:\n  msg = <p', v'>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "with PisReceiverOf"], ["proof (chain)\npicking this:\n  isReceiverOf p msg\n  msg = <p', v'>", "have MsgIsVMsg: \"(msg = <p, v'>)\""], ["proof (prove)\nusing this:\n  isReceiverOf p msg\n  msg = <p', v'>\n\ngoal (1 subgoal):\n 1. msg = <p, v'>", "by auto"], ["proof (state)\nthis:\n  msg = <p, v'>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "define cfgVMsg where \"cfgVMsg =\n          \\<lparr>states = \\<lambda>proc. (\n              if proc = p then\n               trans p (states (last exec') p) (Value v')\n               else states (last exec') proc),\n            msgs = (((sends p (states (last exec') p) (Value v'))\n                \\<union># (msgs (last exec') -# msg )))\\<rparr> \""], ["proof (state)\nthis:\n  cfgVMsg =\n  \\<lparr>states =\n            \\<lambda>proc.\n               if proc = p then trans p (states (last exec') p) (Value v')\n               else states (last exec') proc,\n     msgs =\n       sends p (states (last exec') p)\n        (Value v') \\<union># msgs (last exec') -# msg\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "with UniqueReceiverOf MsgIsVMsg EnabledMsg noInSends"], ["proof (chain)\npicking this:\n  \\<lbrakk>isReceiverOf ?q ?msg; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> \\<not> isReceiverOf ?p ?msg\n  msg = <p, v'>\n  enabled (last exec') msg\n  sends ?p ?s ?m <?p2.0, inM ?v> = 0\n  cfgVMsg =\n  \\<lparr>states =\n            \\<lambda>proc.\n               if proc = p then trans p (states (last exec') p) (Value v')\n               else states (last exec') proc,\n     msgs =\n       sends p (states (last exec') p)\n        (Value v') \\<union># msgs (last exec') -# msg\\<rparr>", "have \n          \"((last exec') \\<turnstile> msg \\<mapsto> cfgVMsg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>isReceiverOf ?q ?msg; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> \\<not> isReceiverOf ?p ?msg\n  msg = <p, v'>\n  enabled (last exec') msg\n  sends ?p ?s ?m <?p2.0, inM ?v> = 0\n  cfgVMsg =\n  \\<lparr>states =\n            \\<lambda>proc.\n               if proc = p then trans p (states (last exec') p) (Value v')\n               else states (last exec') proc,\n     msgs =\n       sends p (states (last exec') p)\n        (Value v') \\<union># msgs (last exec') -# msg\\<rparr>\n\ngoal (1 subgoal):\n 1. last exec' \\<turnstile> msg \\<mapsto> cfgVMsg", "by auto"], ["proof (state)\nthis:\n  last exec' \\<turnstile> msg \\<mapsto> cfgVMsg\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>enabled (last exec') msg; msg = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cMsg.\n                            last exec' \\<turnstile> msg \\<mapsto> cMsg", "thus \"\\<exists> cMsg . ((last exec') \\<turnstile> msg \\<mapsto> cMsg )\""], ["proof (prove)\nusing this:\n  last exec' \\<turnstile> msg \\<mapsto> cfgVMsg\n\ngoal (1 subgoal):\n 1. \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg", "by blast"], ["proof (state)\nthis:\n  \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "then"], ["proof (chain)\npicking this:\n  \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg", "obtain cMsg where  CMsg:\"((last exec') \\<turnstile> msg \\<mapsto> cMsg )\""], ["proof (prove)\nusing this:\n  \\<exists>cMsg. last exec' \\<turnstile> msg \\<mapsto> cMsg\n\ngoal (1 subgoal):\n 1. (\\<And>cMsg.\n        last exec' \\<turnstile> msg \\<mapsto> cMsg \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  last exec' \\<turnstile> msg \\<mapsto> cMsg\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "define execMsg where \"execMsg = exec' @ [cMsg]\""], ["proof (state)\nthis:\n  execMsg = exec' @ [cMsg]\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "define traceMsg where \"traceMsg = trace' @ [msg]\""], ["proof (state)\nthis:\n  traceMsg = trace' @ [msg]\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "from NewExec(1) CMsg"], ["proof (chain)\npicking this:\n  execution trans sends start exec' trace'\n  last exec' \\<turnstile> msg \\<mapsto> cMsg", "obtain execMsg traceMsg where isExecution: \n        \"execution trans sends start execMsg traceMsg\"\n        and ExecMsg: \"prefixList exec' execMsg\" \"prefixList trace' traceMsg\"\n        \"last execMsg = cMsg\" \"last traceMsg = msg\""], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  last exec' \\<turnstile> msg \\<mapsto> cMsg\n\ngoal (1 subgoal):\n 1. (\\<And>execMsg traceMsg.\n        \\<lbrakk>execution trans sends start execMsg traceMsg;\n         prefixList exec' execMsg; prefixList trace' traceMsg;\n         last execMsg = cMsg; last traceMsg = msg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using expandExecutionStep"], ["proof (prove)\nusing this:\n  execution trans sends start exec' trace'\n  last exec' \\<turnstile> msg \\<mapsto> cMsg\n  \\<lbrakk>last ?exec' \\<turnstile> ?msg \\<mapsto> ?cMsg;\n   execution trans sends start ?exec' ?trace'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>exec'' trace''.\n                       execution trans sends start exec'' trace'' \\<and>\n                       prefixList ?exec' exec'' \\<and>\n                       prefixList ?trace' trace'' \\<and>\n                       last exec'' = ?cMsg \\<and> last trace'' = ?msg\n\ngoal (1 subgoal):\n 1. (\\<And>execMsg traceMsg.\n        \\<lbrakk>execution trans sends start execMsg traceMsg;\n         prefixList exec' execMsg; prefixList trace' traceMsg;\n         last execMsg = cMsg; last traceMsg = msg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution trans sends start execMsg traceMsg\n  prefixList exec' execMsg\n  prefixList trace' traceMsg\n  last execMsg = cMsg\n  last traceMsg = msg\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "have isPrefixListExec: \"prefixList exec execMsg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList exec execMsg", "using PrefixListTransitive NewExec(2) ExecMsg(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n  prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n  exec = exec' \\<and> trace = trace'\n  prefixList exec' execMsg\n\ngoal (1 subgoal):\n 1. prefixList exec execMsg", "by auto"], ["proof (state)\nthis:\n  prefixList exec execMsg\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "have isPrefixListTrace: \"prefixList trace traceMsg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList trace traceMsg", "using PrefixListTransitive NewExec(2) ExecMsg(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n  prefixList exec exec' \\<and> prefixList trace trace' \\<or>\n  exec = exec' \\<and> trace = trace'\n  prefixList trace' traceMsg\n\ngoal (1 subgoal):\n 1. prefixList trace traceMsg", "by auto"], ["proof (state)\nthis:\n  prefixList trace traceMsg\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "have cMsgLastReachable: \"reachable cMsg (last execMsg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable cMsg (last execMsg)", "by (auto simp add: ExecMsg reachable.init)"], ["proof (state)\nthis:\n  reachable cMsg (last execMsg)\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "hence isStepReachable: \"stepReachable (last exec) msg (last execMsg)\""], ["proof (prove)\nusing this:\n  reachable cMsg (last execMsg)\n\ngoal (1 subgoal):\n 1. stepReachable (last exec) msg (last execMsg)", "using CMsg lastExecExec'Reachable"], ["proof (prove)\nusing this:\n  reachable cMsg (last execMsg)\n  last exec' \\<turnstile> msg \\<mapsto> cMsg\n  reachable (last exec) (last exec')\n\ngoal (1 subgoal):\n 1. stepReachable (last exec) msg (last execMsg)", "by (auto simp add: stepReachable_def)"], ["proof (state)\nthis:\n  stepReachable (last exec) msg (last execMsg)\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "have InitReachLastExecMsg: \"initReachable (last execMsg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initReachable (last execMsg)", "using CMsg InitReachLastExec' cMsgLastReachable"], ["proof (prove)\nusing this:\n  last exec' \\<turnstile> msg \\<mapsto> cMsg\n  initReachable (last exec')\n  reachable cMsg (last execMsg)\n\ngoal (1 subgoal):\n 1. initReachable (last execMsg)", "by (metis ReachableTrans initReachable_def step)"], ["proof (state)\nthis:\n  initReachable (last execMsg)\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "have \"val[p, (last exec')] \\<subseteq> val[p, cMsg]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val[p,last exec'] \\<subseteq> val[p,cMsg]", "using CMsg PisReceiverOf InitReachLastExec'\n          ActiveProcessSilentDecisionValuesIncrease[of p p \"last exec'\" msg cMsg]"], ["proof (prove)\nusing this:\n  last exec' \\<turnstile> msg \\<mapsto> cMsg\n  isReceiverOf p msg\n  initReachable (last exec')\n  \\<lbrakk>p = p; last exec' \\<turnstile> msg \\<mapsto> cMsg;\n   isReceiverOf p msg; initReachable (last exec')\\<rbrakk>\n  \\<Longrightarrow> val[p,last exec'] \\<subseteq> val[p,cMsg]\n\ngoal (1 subgoal):\n 1. val[p,last exec'] \\<subseteq> val[p,cMsg]", "by auto"], ["proof (state)\nthis:\n  val[p,last exec'] \\<subseteq> val[p,cMsg]\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "with ExecMsg C'(2) NewExec(3)"], ["proof (chain)\npicking this:\n  prefixList exec' execMsg\n  prefixList trace' traceMsg\n  last execMsg = cMsg\n  last traceMsg = msg\n  val[p,c'] = {True, False}\n  last exec' = c'\n  val[p,last exec'] \\<subseteq> val[p,cMsg]", "have \n        \"val[p, (last execMsg)] = {True, False}\""], ["proof (prove)\nusing this:\n  prefixList exec' execMsg\n  prefixList trace' traceMsg\n  last execMsg = cMsg\n  last traceMsg = msg\n  val[p,c'] = {True, False}\n  last exec' = c'\n  val[p,last exec'] \\<subseteq> val[p,cMsg]\n\ngoal (1 subgoal):\n 1. val[p,last execMsg] = {True, False}", "by auto"], ["proof (state)\nthis:\n  val[p,last execMsg] = {True, False}\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "with InitReachLastExecMsg"], ["proof (chain)\npicking this:\n  initReachable (last execMsg)\n  val[p,last execMsg] = {True, False}", "have isNonUniform: \n        \"nonUniform (last execMsg)\""], ["proof (prove)\nusing this:\n  initReachable (last execMsg)\n  val[p,last execMsg] = {True, False}\n\ngoal (1 subgoal):\n 1. nonUniform (last execMsg)", "by (auto simp add: vUniform_def)"], ["proof (state)\nthis:\n  nonUniform (last execMsg)\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "have \"reachable (last exec) (last execMsg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (last exec) (last execMsg)", "using lastExecExec'Reachable cMsgLastReachable CMsg"], ["proof (prove)\nusing this:\n  reachable (last exec) (last exec')\n  reachable cMsg (last execMsg)\n  last exec' \\<turnstile> msg \\<mapsto> cMsg\n\ngoal (1 subgoal):\n 1. reachable (last exec) (last execMsg)", "by (metis ReachableTrans step)"], ["proof (state)\nthis:\n  reachable (last exec) (last execMsg)\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "hence isAgreementPreventing: \n        \"(\\<forall> cfg . reachable (last execMsg) cfg \\<longrightarrow> agreement cfg)\""], ["proof (prove)\nusing this:\n  reachable (last exec) (last execMsg)\n\ngoal (1 subgoal):\n 1. \\<forall>cfg.\n       reachable (last execMsg) cfg \\<longrightarrow> agreement cfg", "using Agree"], ["proof (prove)\nusing this:\n  reachable (last exec) (last execMsg)\n  reachable (last exec) ?cfg \\<longrightarrow> agreement ?cfg\n\ngoal (1 subgoal):\n 1. \\<forall>cfg.\n       reachable (last execMsg) cfg \\<longrightarrow> agreement cfg", "by (metis ReachableTrans)"], ["proof (state)\nthis:\n  \\<forall>cfg. reachable (last execMsg) cfg \\<longrightarrow> agreement cfg\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "have \"msg \\<in> set (drop (length trace) traceMsg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg \\<in> set (drop (length trace) traceMsg)", "using ExecMsg(4) \n        isPrefixListTrace"], ["proof (prove)\nusing this:\n  last traceMsg = msg\n  prefixList trace traceMsg\n\ngoal (1 subgoal):\n 1. msg \\<in> set (drop (length trace) traceMsg)", "by (metis (full_types) PrefixListMonotonicity last_drop last_in_set\n          length_0_conv length_drop less_zeroE zero_less_diff)"], ["proof (state)\nthis:\n  msg \\<in> set (drop (length trace) traceMsg)\n\ngoal (2 subgoals):\n 1. enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)\n 2. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  msg \\<in> set (drop (length trace) traceMsg)\n\ngoal (1 subgoal):\n 1. \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "using isExecution isNonUniform isPrefixListExec \n        isPrefixListTrace isAgreementPreventing isStepReachable"], ["proof (prove)\nusing this:\n  msg \\<in> set (drop (length trace) traceMsg)\n  execution trans sends start execMsg traceMsg\n  nonUniform (last execMsg)\n  prefixList exec execMsg\n  prefixList trace traceMsg\n  \\<forall>cfg. reachable (last execMsg) cfg \\<longrightarrow> agreement cfg\n  stepReachable (last exec) msg (last execMsg)\n\ngoal (1 subgoal):\n 1. \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "by blast"], ["proof (state)\nthis:\n  \\<exists>exec1 trace1.\n     execution trans sends start exec1 trace1 \\<and>\n     nonUniform (last exec1) \\<and>\n     prefixList exec exec1 \\<and>\n     prefixList trace trace1 \\<and>\n     (\\<forall>cfg.\n         reachable (last exec1) cfg \\<longrightarrow> agreement cfg) \\<and>\n     stepReachable (last exec) msg (last exec1) \\<and>\n     msg \\<in> set (drop (length trace) trace1)\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "case False"], ["proof (state)\nthis:\n  \\<not> enabled (last exec') msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "hence notEnabled: \"\\<not> (enabled (last exec') msg)\""], ["proof (prove)\nusing this:\n  \\<not> enabled (last exec') msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec') msg", "by auto"], ["proof (state)\nthis:\n  \\<not> enabled (last exec') msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "have isStepReachable: \"stepReachable (last exec) msg (last exec')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stepReachable (last exec) msg (last exec')", "using MsgEnabled notEnabled lastExecExec'Reachable StepReachable"], ["proof (prove)\nusing this:\n  enabled (last exec) msg\n  \\<not> enabled (last exec') msg\n  reachable (last exec) (last exec')\n  \\<lbrakk>reachable ?cfg ?cfg'; enabled ?cfg ?msg;\n   \\<not> enabled ?cfg' ?msg\\<rbrakk>\n  \\<Longrightarrow> stepReachable ?cfg ?msg ?cfg'\n\ngoal (1 subgoal):\n 1. stepReachable (last exec) msg (last exec')", "by auto"], ["proof (state)\nthis:\n  stepReachable (last exec) msg (last exec')\n\ngoal (1 subgoal):\n 1. \\<not> enabled (last exec') msg \\<Longrightarrow>\n    \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "with NotStepReachable NewExec(3)"], ["proof (chain)\npicking this:\n  \\<not> stepReachable (last exec) msg c'\n  last exec' = c'\n  stepReachable (last exec) msg (last exec')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> stepReachable (last exec) msg c'\n  last exec' = c'\n  stepReachable (last exec) msg (last exec')\n\ngoal (1 subgoal):\n 1. \\<exists>exec1 trace1.\n       execution trans sends start exec1 trace1 \\<and>\n       nonUniform (last exec1) \\<and>\n       prefixList exec exec1 \\<and>\n       prefixList trace trace1 \\<and>\n       (\\<forall>cfg.\n           reachable (last exec1) cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last exec) msg (last exec1) \\<and>\n       msg \\<in> set (drop (length trace) trace1)", "by simp"], ["proof (state)\nthis:\n  \\<exists>exec1 trace1.\n     execution trans sends start exec1 trace1 \\<and>\n     nonUniform (last exec1) \\<and>\n     prefixList exec exec1 \\<and>\n     prefixList trace trace1 \\<and>\n     (\\<forall>cfg.\n         reachable (last exec1) cfg \\<longrightarrow> agreement cfg) \\<and>\n     stepReachable (last exec) msg (last exec1) \\<and>\n     msg \\<in> set (drop (length trace) trace1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>exec1 trace1.\n     execution trans sends start exec1 trace1 \\<and>\n     nonUniform (last exec1) \\<and>\n     prefixList exec exec1 \\<and>\n     prefixList trace trace1 \\<and>\n     (\\<forall>cfg.\n         reachable (last exec1) cfg \\<longrightarrow> agreement cfg) \\<and>\n     stepReachable (last exec) msg (last exec1) \\<and>\n     msg \\<in> set (drop (length trace) trace1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     nonUniform (last exec') \\<and>\n     prefixList exec exec' \\<and>\n     prefixList trace trace' \\<and>\n     (\\<forall>cfg.\n         reachable (last exec') cfg \\<longrightarrow> agreement cfg) \\<and>\n     stepReachable (last exec) msg (last exec') \\<and>\n     msg \\<in> set (drop (length trace) trace')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NonUniformExecutionBase:\nfixes\n  cfg\nassumes\n  Cfg: \"initial cfg\" \"nonUniform cfg\"\nshows \n  \"execution trans sends start [cfg] [] \n  \\<and> nonUniform (last [cfg]) \n  \\<and> (\\<exists> cfgList' msgList'.  nonUniform (last cfgList') \n    \\<and> prefixList [cfg] cfgList' \n    \\<and> prefixList [] msgList'\n    \\<and> (execution trans sends start cfgList' msgList')\n     \\<and> (\\<exists> msg'. execution.minimalEnabled [cfg] [] msg' \n         \\<and> msg' \\<in> set msgList'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "have NonUniListCfg: \"nonUniform (last [cfg])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonUniform (last [cfg])", "using Cfg(2)"], ["proof (prove)\nusing this:\n  nonUniform cfg\n\ngoal (1 subgoal):\n 1. nonUniform (last [cfg])", "by auto"], ["proof (state)\nthis:\n  nonUniform (last [cfg])\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "have AgreeCfg': \"\\<forall> cfg' . \n    reachable (last [cfg]) cfg' \\<longrightarrow> agreement cfg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cfg'.\n       reachable (last [cfg]) cfg' \\<longrightarrow> agreement cfg'", "using Agreement Cfg(1)"], ["proof (prove)\nusing this:\n  agreementInit ?i ?c\n  initial cfg\n\ngoal (1 subgoal):\n 1. \\<forall>cfg'.\n       reachable (last [cfg]) cfg' \\<longrightarrow> agreement cfg'", "by (auto simp add: agreementInit_def reachable.init agreement_def)"], ["proof (state)\nthis:\n  \\<forall>cfg'.\n     reachable (last [cfg]) cfg' \\<longrightarrow> agreement cfg'\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "have StartExec: \"execution trans sends start [cfg] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] []", "using Cfg(1)"], ["proof (prove)\nusing this:\n  initial cfg\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] []", "by (unfold_locales, auto)"], ["proof (state)\nthis:\n  execution trans sends start [cfg] []\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "hence \"\\<exists> msg . execution.minimalEnabled [cfg] [] msg\""], ["proof (prove)\nusing this:\n  execution trans sends start [cfg] []\n\ngoal (1 subgoal):\n 1. \\<exists>msg. execution.minimalEnabled [cfg] [] msg", "using Cfg execution.ExistImpliesMinEnabled"], ["proof (prove)\nusing this:\n  execution trans sends start [cfg] []\n  initial cfg\n  nonUniform cfg\n  \\<lbrakk>execution ?trans ?sends ?start ?exec ?trace;\n   isReceiverOf ?p ?msg; enabled (last ?exec) ?msg\\<rbrakk>\n  \\<Longrightarrow> \\<exists>msg'.\n                       execution.minimalEnabled ?exec ?trace msg'\n\ngoal (1 subgoal):\n 1. \\<exists>msg. execution.minimalEnabled [cfg] [] msg", "by (metis enabled_def initial_def isReceiverOf.simps(1) \n       last.simps zero_less_one)"], ["proof (state)\nthis:\n  \\<exists>msg. execution.minimalEnabled [cfg] [] msg\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "then"], ["proof (chain)\npicking this:\n  \\<exists>msg. execution.minimalEnabled [cfg] [] msg", "obtain msg where MinEnabledMsg: \n    \"execution.minimalEnabled [cfg] [] msg\""], ["proof (prove)\nusing this:\n  \\<exists>msg. execution.minimalEnabled [cfg] [] msg\n\ngoal (1 subgoal):\n 1. (\\<And>msg.\n        execution.minimalEnabled [cfg] [] msg \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution.minimalEnabled [cfg] [] msg\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "hence \"\\<exists> pMin . isReceiverOf pMin msg\""], ["proof (prove)\nusing this:\n  execution.minimalEnabled [cfg] [] msg\n\ngoal (1 subgoal):\n 1. \\<exists>pMin. isReceiverOf pMin msg", "using StartExec"], ["proof (prove)\nusing this:\n  execution.minimalEnabled [cfg] [] msg\n  execution trans sends start [cfg] []\n\ngoal (1 subgoal):\n 1. \\<exists>pMin. isReceiverOf pMin msg", "by (auto simp add: execution.minimalEnabled_def)"], ["proof (state)\nthis:\n  \\<exists>pMin. isReceiverOf pMin msg\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "then"], ["proof (chain)\npicking this:\n  \\<exists>pMin. isReceiverOf pMin msg", "obtain pMin where PMin: \"isReceiverOf pMin msg\""], ["proof (prove)\nusing this:\n  \\<exists>pMin. isReceiverOf pMin msg\n\ngoal (1 subgoal):\n 1. (\\<And>pMin.\n        isReceiverOf pMin msg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  isReceiverOf pMin msg\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "hence \"enabled (last [cfg]) msg \\<and> isReceiverOf pMin msg\""], ["proof (prove)\nusing this:\n  isReceiverOf pMin msg\n\ngoal (1 subgoal):\n 1. enabled (last [cfg]) msg \\<and> isReceiverOf pMin msg", "using MinEnabledMsg StartExec"], ["proof (prove)\nusing this:\n  isReceiverOf pMin msg\n  execution.minimalEnabled [cfg] [] msg\n  execution trans sends start [cfg] []\n\ngoal (1 subgoal):\n 1. enabled (last [cfg]) msg \\<and> isReceiverOf pMin msg", "by (auto simp add: execution.minimalEnabled_def)"], ["proof (state)\nthis:\n  enabled (last [cfg]) msg \\<and> isReceiverOf pMin msg\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "hence Enabled: \"enabled (last [cfg]) msg\" \"isReceiverOf pMin msg\""], ["proof (prove)\nusing this:\n  enabled (last [cfg]) msg \\<and> isReceiverOf pMin msg\n\ngoal (1 subgoal):\n 1. enabled (last [cfg]) msg &&& isReceiverOf pMin msg", "by auto"], ["proof (state)\nthis:\n  enabled (last [cfg]) msg\n  isReceiverOf pMin msg\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "from Enabled StartExec NonUniListCfg PseudoTermination AgreeCfg'"], ["proof (chain)\npicking this:\n  enabled (last [cfg]) msg\n  isReceiverOf pMin msg\n  execution trans sends start [cfg] []\n  nonUniform (last [cfg])\n  terminationPseudo 1 ?cc ?Q\n  \\<forall>cfg'.\n     reachable (last [cfg]) cfg' \\<longrightarrow> agreement cfg'", "have \"\\<exists> exec' trace' . (execution trans sends start exec' trace') \n    \\<and> nonUniform (last exec')\n    \\<and> prefixList [cfg] exec' \\<and> prefixList [] trace' \n    \\<and> (\\<forall> cfg' . reachable (last exec') cfg' \\<longrightarrow> agreement cfg')\n    \\<and> stepReachable (last [cfg]) msg (last exec') \n    \\<and> (msg \\<in> set (drop (length []) trace'))\""], ["proof (prove)\nusing this:\n  enabled (last [cfg]) msg\n  isReceiverOf pMin msg\n  execution trans sends start [cfg] []\n  nonUniform (last [cfg])\n  terminationPseudo 1 ?cc ?Q\n  \\<forall>cfg'.\n     reachable (last [cfg]) cfg' \\<longrightarrow> agreement cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList [cfg] exec' \\<and>\n       prefixList [] trace' \\<and>\n       (\\<forall>cfg'.\n           reachable (last exec') cfg' \\<longrightarrow>\n           agreement cfg') \\<and>\n       stepReachable (last [cfg]) msg (last exec') \\<and>\n       msg \\<in> set (drop (length []) trace')", "using NonUniformExecutionsConstructable[of \"[cfg]\" \"msg\" \"pMin\"\n          \"[]::('p,'v) message list\"]"], ["proof (prove)\nusing this:\n  enabled (last [cfg]) msg\n  isReceiverOf pMin msg\n  execution trans sends start [cfg] []\n  nonUniform (last [cfg])\n  terminationPseudo 1 ?cc ?Q\n  \\<forall>cfg'.\n     reachable (last [cfg]) cfg' \\<longrightarrow> agreement cfg'\n  \\<lbrakk>enabled (last [cfg]) msg; isReceiverOf pMin msg;\n   execution trans sends start [cfg] []; nonUniform (last [cfg]);\n   \\<And>cfga.\n      reachable (last [cfg]) cfga \\<longrightarrow> agreement cfga\\<rbrakk>\n  \\<Longrightarrow> \\<exists>exec' trace'.\n                       execution trans sends start exec' trace' \\<and>\n                       nonUniform (last exec') \\<and>\n                       prefixList [cfg] exec' \\<and>\n                       prefixList [] trace' \\<and>\n                       (\\<forall>cfg.\n                           reachable (last exec') cfg \\<longrightarrow>\n                           agreement cfg) \\<and>\n                       stepReachable (last [cfg]) msg (last exec') \\<and>\n                       msg \\<in> set (drop (length []) trace')\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList [cfg] exec' \\<and>\n       prefixList [] trace' \\<and>\n       (\\<forall>cfg'.\n           reachable (last exec') cfg' \\<longrightarrow>\n           agreement cfg') \\<and>\n       stepReachable (last [cfg]) msg (last exec') \\<and>\n       msg \\<in> set (drop (length []) trace')", "by simp"], ["proof (state)\nthis:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     nonUniform (last exec') \\<and>\n     prefixList [cfg] exec' \\<and>\n     prefixList [] trace' \\<and>\n     (\\<forall>cfg'.\n         reachable (last exec') cfg' \\<longrightarrow>\n         agreement cfg') \\<and>\n     stepReachable (last [cfg]) msg (last exec') \\<and>\n     msg \\<in> set (drop (length []) trace')\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "with StartExec NonUniListCfg MinEnabledMsg"], ["proof (chain)\npicking this:\n  execution trans sends start [cfg] []\n  nonUniform (last [cfg])\n  execution.minimalEnabled [cfg] [] msg\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     nonUniform (last exec') \\<and>\n     prefixList [cfg] exec' \\<and>\n     prefixList [] trace' \\<and>\n     (\\<forall>cfg'.\n         reachable (last exec') cfg' \\<longrightarrow>\n         agreement cfg') \\<and>\n     stepReachable (last [cfg]) msg (last exec') \\<and>\n     msg \\<in> set (drop (length []) trace')", "show ?thesis"], ["proof (prove)\nusing this:\n  execution trans sends start [cfg] []\n  nonUniform (last [cfg])\n  execution.minimalEnabled [cfg] [] msg\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     nonUniform (last exec') \\<and>\n     prefixList [cfg] exec' \\<and>\n     prefixList [] trace' \\<and>\n     (\\<forall>cfg'.\n         reachable (last exec') cfg' \\<longrightarrow>\n         agreement cfg') \\<and>\n     stepReachable (last [cfg]) msg (last exec') \\<and>\n     msg \\<in> set (drop (length []) trace')\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "by auto"], ["proof (state)\nthis:\n  execution trans sends start [cfg] [] \\<and>\n  nonUniform (last [cfg]) \\<and>\n  (\\<exists>cfgList' msgList'.\n      nonUniform (last cfgList') \\<and>\n      prefixList [cfg] cfgList' \\<and>\n      prefixList [] msgList' \\<and>\n      execution trans sends start cfgList' msgList' \\<and>\n      (\\<exists>msg'.\n          execution.minimalEnabled [cfg] [] msg' \\<and>\n          msg' \\<in> set msgList'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NonUniformExecutionStep:\nfixes\n cfgList msgList\nassumes\n  Init: \"initial (hd cfgList)\" and\n  NonUni: \"nonUniform (last cfgList)\" and\n  Execution: \"execution trans sends start cfgList msgList\"\nshows\n  \"(\\<exists> cfgList' msgList' .\n      nonUniform (last cfgList') \n      \\<and> prefixList cfgList cfgList' \n      \\<and> prefixList msgList msgList'\n      \\<and> (execution trans sends start cfgList' msgList') \n      \\<and> (initial (hd cfgList'))\n      \\<and> (\\<exists> msg'. execution.minimalEnabled cfgList msgList msg' \n        \\<and> msg' \\<in> (set (drop (length msgList ) msgList')) ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "have ReachImplAgree: \"\\<forall> cfg . reachable (last cfgList) cfg \n    \\<longrightarrow> agreement cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cfg.\n       reachable (last cfgList) cfg \\<longrightarrow> agreement cfg", "using Agreement Init NonUni ReachableTrans"], ["proof (prove)\nusing this:\n  agreementInit ?i ?c\n  initial (hd cfgList)\n  nonUniform (last cfgList)\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n\ngoal (1 subgoal):\n 1. \\<forall>cfg.\n       reachable (last cfgList) cfg \\<longrightarrow> agreement cfg", "unfolding agreementInit_def agreement_def initReachable_def"], ["proof (prove)\nusing this:\n  initial ?i \\<and> reachable ?i ?c \\<longrightarrow>\n  (\\<forall>v1.\n      <\\<bottom>, outM v1> \\<in># msgs ?c \\<longrightarrow>\n      (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs ?c = (v2 = v1)))\n  initial (hd cfgList)\n  (\\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 (last cfgList)) \\<and>\n  \\<not> vUniform False (last cfgList) \\<and>\n  \\<not> vUniform True (last cfgList)\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n\ngoal (1 subgoal):\n 1. \\<forall>cfg.\n       reachable (last cfgList) cfg \\<longrightarrow>\n       (\\<forall>v1.\n           <\\<bottom>, outM v1> \\<in># msgs cfg \\<longrightarrow>\n           (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs cfg = (v2 = v1)))", "by (metis (full_types))"], ["proof (state)\nthis:\n  \\<forall>cfg. reachable (last cfgList) cfg \\<longrightarrow> agreement cfg\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "have \"\\<exists> msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg", "from PseudoTermination NonUni"], ["proof (chain)\npicking this:\n  terminationPseudo 1 ?cc ?Q\n  nonUniform (last cfgList)", "have \n      \"\\<exists>c'. qReachable (last cfgList) Proc c' \\<and> decided c'\""], ["proof (prove)\nusing this:\n  terminationPseudo 1 ?cc ?Q\n  nonUniform (last cfgList)\n\ngoal (1 subgoal):\n 1. \\<exists>c'.\n       qReachable (last cfgList) Proc c' \\<and>\n       (\\<exists>v.\n           initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c')", "using terminationPseudo_def"], ["proof (prove)\nusing this:\n  terminationPseudo 1 ?cc ?Q\n  nonUniform (last cfgList)\n  terminationPseudo ?t ?c ?Q \\<equiv>\n  initReachable ?c \\<and> card Proc \\<le> card ?Q + ?t \\<longrightarrow>\n  (\\<exists>c'.\n      qReachable ?c ?Q c' \\<and>\n      (\\<exists>v.\n          initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'))\n\ngoal (1 subgoal):\n 1. \\<exists>c'.\n       qReachable (last cfgList) Proc c' \\<and>\n       (\\<exists>v.\n           initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c')", "by auto"], ["proof (state)\nthis:\n  \\<exists>c'.\n     qReachable (last cfgList) Proc c' \\<and>\n     (\\<exists>v.\n         initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c')\n\ngoal (1 subgoal):\n 1. \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg", "then"], ["proof (chain)\npicking this:\n  \\<exists>c'.\n     qReachable (last cfgList) Proc c' \\<and>\n     (\\<exists>v.\n         initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c')", "obtain c' where C': \"reachable (last cfgList) c'\" \n        \"decided c'\""], ["proof (prove)\nusing this:\n  \\<exists>c'.\n     qReachable (last cfgList) Proc c' \\<and>\n     (\\<exists>v.\n         initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c')\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        \\<lbrakk>reachable (last cfgList) c';\n         \\<exists>v.\n            initReachable c' \\<and>\n            <\\<bottom>, outM v> \\<in># msgs c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using QReachImplReach"], ["proof (prove)\nusing this:\n  \\<exists>c'.\n     qReachable (last cfgList) Proc c' \\<and>\n     (\\<exists>v.\n         initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c')\n  qReachable ?cfg1.0 ?Q ?cfg2.0 \\<Longrightarrow> reachable ?cfg1.0 ?cfg2.0\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        \\<lbrakk>reachable (last cfgList) c';\n         \\<exists>v.\n            initReachable c' \\<and>\n            <\\<bottom>, outM v> \\<in># msgs c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  reachable (last cfgList) c'\n  \\<exists>v. initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'\n\ngoal (1 subgoal):\n 1. \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg", "have NoOut: \n      \"0 = msgs (last cfgList) <\\<bottom>, outM False>\"  \n      \"0 = msgs (last cfgList) <\\<bottom>, outM True>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = msgs (last cfgList) <\\<bottom>, outM False> &&&\n    0 = msgs (last cfgList) <\\<bottom>, outM True>", "using NonUni ReachImplAgree PseudoTermination"], ["proof (prove)\nusing this:\n  nonUniform (last cfgList)\n  \\<forall>cfg. reachable (last cfgList) cfg \\<longrightarrow> agreement cfg\n  terminationPseudo 1 ?cc ?Q\n\ngoal (1 subgoal):\n 1. 0 = msgs (last cfgList) <\\<bottom>, outM False> &&&\n    0 = msgs (last cfgList) <\\<bottom>, outM True>", "by (metis NonUniformImpliesNotDecided neq0_conv)+"], ["proof (state)\nthis:\n  0 = msgs (last cfgList) <\\<bottom>, outM False>\n  0 = msgs (last cfgList) <\\<bottom>, outM True>\n\ngoal (1 subgoal):\n 1. \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg", "with C'(2)"], ["proof (chain)\npicking this:\n  \\<exists>v. initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'\n  0 = msgs (last cfgList) <\\<bottom>, outM False>\n  0 = msgs (last cfgList) <\\<bottom>, outM True>", "have \"(last cfgList) \\<noteq> c'\""], ["proof (prove)\nusing this:\n  \\<exists>v. initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'\n  0 = msgs (last cfgList) <\\<bottom>, outM False>\n  0 = msgs (last cfgList) <\\<bottom>, outM True>\n\ngoal (1 subgoal):\n 1. last cfgList \\<noteq> c'", "by (metis (full_types) less_zeroE)"], ["proof (state)\nthis:\n  last cfgList \\<noteq> c'\n\ngoal (1 subgoal):\n 1. \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg", "thus ?thesis"], ["proof (prove)\nusing this:\n  last cfgList \\<noteq> c'\n\ngoal (1 subgoal):\n 1. \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg", "using C'(1) ReachableStepFirst"], ["proof (prove)\nusing this:\n  last cfgList \\<noteq> c'\n  reachable (last cfgList) c'\n  reachable ?cfg ?cfg' \\<Longrightarrow>\n  ?cfg = ?cfg' \\<or>\n  (\\<exists>cfg1 msg p.\n      ?cfg \\<turnstile> msg \\<mapsto> cfg1 \\<and>\n      enabled ?cfg msg \\<and>\n      isReceiverOf p msg \\<and> reachable cfg1 ?cfg')\n\ngoal (1 subgoal):\n 1. \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg", "by blast"], ["proof (state)\nthis:\n  \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "then"], ["proof (chain)\npicking this:\n  \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg", "obtain msg p where Enabled: \n    \"enabled (last cfgList) msg\" \"isReceiverOf p msg\""], ["proof (prove)\nusing this:\n  \\<exists>msg p. enabled (last cfgList) msg \\<and> isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. (\\<And>msg p.\n        \\<lbrakk>enabled (last cfgList) msg; isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  enabled (last cfgList) msg\n  isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "hence \"\\<exists> msg . execution.minimalEnabled cfgList msgList msg\""], ["proof (prove)\nusing this:\n  enabled (last cfgList) msg\n  isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<exists>msg. execution.minimalEnabled cfgList msgList msg", "using Init execution.ExistImpliesMinEnabled[OF Execution]"], ["proof (prove)\nusing this:\n  enabled (last cfgList) msg\n  isReceiverOf p msg\n  initial (hd cfgList)\n  \\<lbrakk>isReceiverOf ?p ?msg; enabled (last cfgList) ?msg\\<rbrakk>\n  \\<Longrightarrow> \\<exists>msg'.\n                       execution.minimalEnabled cfgList msgList msg'\n\ngoal (1 subgoal):\n 1. \\<exists>msg. execution.minimalEnabled cfgList msgList msg", "by auto"], ["proof (state)\nthis:\n  \\<exists>msg. execution.minimalEnabled cfgList msgList msg\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "then"], ["proof (chain)\npicking this:\n  \\<exists>msg. execution.minimalEnabled cfgList msgList msg", "obtain msg' where MinEnabledMsg: \n    \"execution.minimalEnabled cfgList msgList msg'\""], ["proof (prove)\nusing this:\n  \\<exists>msg. execution.minimalEnabled cfgList msgList msg\n\ngoal (1 subgoal):\n 1. (\\<And>msg'.\n        execution.minimalEnabled cfgList msgList msg' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution.minimalEnabled cfgList msgList msg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "hence \"\\<exists> p' . isReceiverOf p' msg'\""], ["proof (prove)\nusing this:\n  execution.minimalEnabled cfgList msgList msg'\n\ngoal (1 subgoal):\n 1. \\<exists>p'. isReceiverOf p' msg'", "using Execution"], ["proof (prove)\nusing this:\n  execution.minimalEnabled cfgList msgList msg'\n  execution trans sends start cfgList msgList\n\ngoal (1 subgoal):\n 1. \\<exists>p'. isReceiverOf p' msg'", "by (auto simp add: execution.minimalEnabled_def)"], ["proof (state)\nthis:\n  \\<exists>p'. isReceiverOf p' msg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "then"], ["proof (chain)\npicking this:\n  \\<exists>p'. isReceiverOf p' msg'", "obtain p' where\n    P': \"isReceiverOf p' msg'\""], ["proof (prove)\nusing this:\n  \\<exists>p'. isReceiverOf p' msg'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        isReceiverOf p' msg' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  isReceiverOf p' msg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "hence Enabled':\n    \"enabled (last cfgList) msg'\" \"isReceiverOf p' msg'\""], ["proof (prove)\nusing this:\n  isReceiverOf p' msg'\n\ngoal (1 subgoal):\n 1. enabled (last cfgList) msg' &&& isReceiverOf p' msg'", "using MinEnabledMsg Execution"], ["proof (prove)\nusing this:\n  isReceiverOf p' msg'\n  execution.minimalEnabled cfgList msgList msg'\n  execution trans sends start cfgList msgList\n\ngoal (1 subgoal):\n 1. enabled (last cfgList) msg' &&& isReceiverOf p' msg'", "by (auto simp add: execution.minimalEnabled_def)"], ["proof (state)\nthis:\n  enabled (last cfgList) msg'\n  isReceiverOf p' msg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "have \"\\<exists> exec' trace' . (execution trans sends start exec' trace') \n    \\<and> nonUniform (last exec')\n    \\<and> prefixList cfgList exec' \\<and> prefixList msgList trace' \n    \\<and> (\\<forall> cfg . reachable (last exec') cfg \\<longrightarrow> agreement cfg)\n    \\<and> stepReachable (last cfgList) msg' (last exec') \n    \\<and> (msg' \\<in> set (drop (length msgList) trace')) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList cfgList exec' \\<and>\n       prefixList msgList trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last cfgList) msg' (last exec') \\<and>\n       msg' \\<in> set (drop (length msgList) trace')", "using NonUniformExecutionsConstructable[OF Enabled' Execution\n          NonUni] ReachImplAgree"], ["proof (prove)\nusing this:\n  (\\<And>cfg.\n      reachable (last cfgList) cfg \\<longrightarrow>\n      agreement cfg) \\<Longrightarrow>\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     nonUniform (last exec') \\<and>\n     prefixList cfgList exec' \\<and>\n     prefixList msgList trace' \\<and>\n     (\\<forall>cfg.\n         reachable (last exec') cfg \\<longrightarrow> agreement cfg) \\<and>\n     stepReachable (last cfgList) msg' (last exec') \\<and>\n     msg' \\<in> set (drop (length msgList) trace')\n  \\<forall>cfg. reachable (last cfgList) cfg \\<longrightarrow> agreement cfg\n\ngoal (1 subgoal):\n 1. \\<exists>exec' trace'.\n       execution trans sends start exec' trace' \\<and>\n       nonUniform (last exec') \\<and>\n       prefixList cfgList exec' \\<and>\n       prefixList msgList trace' \\<and>\n       (\\<forall>cfg.\n           reachable (last exec') cfg \\<longrightarrow>\n           agreement cfg) \\<and>\n       stepReachable (last cfgList) msg' (last exec') \\<and>\n       msg' \\<in> set (drop (length msgList) trace')", "by auto"], ["proof (state)\nthis:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     nonUniform (last exec') \\<and>\n     prefixList cfgList exec' \\<and>\n     prefixList msgList trace' \\<and>\n     (\\<forall>cfg.\n         reachable (last exec') cfg \\<longrightarrow> agreement cfg) \\<and>\n     stepReachable (last cfgList) msg' (last exec') \\<and>\n     msg' \\<in> set (drop (length msgList) trace')\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     nonUniform (last exec') \\<and>\n     prefixList cfgList exec' \\<and>\n     prefixList msgList trace' \\<and>\n     (\\<forall>cfg.\n         reachable (last exec') cfg \\<longrightarrow> agreement cfg) \\<and>\n     stepReachable (last cfgList) msg' (last exec') \\<and>\n     msg' \\<in> set (drop (length msgList) trace')\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "using MinEnabledMsg"], ["proof (prove)\nusing this:\n  \\<exists>exec' trace'.\n     execution trans sends start exec' trace' \\<and>\n     nonUniform (last exec') \\<and>\n     prefixList cfgList exec' \\<and>\n     prefixList msgList trace' \\<and>\n     (\\<forall>cfg.\n         reachable (last exec') cfg \\<longrightarrow> agreement cfg) \\<and>\n     stepReachable (last cfgList) msg' (last exec') \\<and>\n     msg' \\<in> set (drop (length msgList) trace')\n  execution.minimalEnabled cfgList msgList msg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfgList' msgList'.\n       nonUniform (last cfgList') \\<and>\n       prefixList cfgList cfgList' \\<and>\n       prefixList msgList msgList' \\<and>\n       execution trans sends start cfgList' msgList' \\<and>\n       initial (hd cfgList') \\<and>\n       (\\<exists>msg'.\n           execution.minimalEnabled cfgList msgList msg' \\<and>\n           msg' \\<in> set (drop (length msgList) msgList'))", "by (metis execution.base)"], ["proof (state)\nthis:\n  \\<exists>cfgList' msgList'.\n     nonUniform (last cfgList') \\<and>\n     prefixList cfgList cfgList' \\<and>\n     prefixList msgList msgList' \\<and>\n     execution trans sends start cfgList' msgList' \\<and>\n     initial (hd cfgList') \\<and>\n     (\\<exists>msg'.\n         execution.minimalEnabled cfgList msgList msg' \\<and>\n         msg' \\<in> set (drop (length msgList) msgList'))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Non-uniformity even when demanding fairness\\<close>"], ["", "text \\<open>\n  Using \\isb{NonUniformExecutionBase} and \\isb{NonUniformExecutionStep} one can obtain\n  non-uniform executions which are fair.\n\n  Proving the fairness turned out quite cumbersome.\n\\<close>"], ["", "text \\<open>\n  These two functions construct infinite series of configurations lists\n  and message lists from two extension functions. \n\\<close>"], ["", "fun infiniteExecutionCfg ::\n  \"('p, 'v, 's) configuration \\<Rightarrow>\n   (('p, 'v, 's) configuration list \\<Rightarrow> ('p, 'v) message list \n    \\<Rightarrow> ('p, 'v, 's) configuration list) \\<Rightarrow>\n   (('p, 'v, 's) configuration list \\<Rightarrow> ('p, 'v) message list \n    \\<Rightarrow>('p, 'v) message list) \n  \\<Rightarrow> nat\n  \\<Rightarrow> (('p, 'v, 's) configuration list)\"\nand  infiniteExecutionMsg ::\n  \"('p, 'v, 's) configuration \\<Rightarrow>\n   (('p, 'v, 's) configuration list \\<Rightarrow> ('p, 'v) message list \n    \\<Rightarrow> ('p, 'v, 's) configuration list) \\<Rightarrow>\n   (('p, 'v, 's) configuration list \\<Rightarrow> ('p, 'v) message list \n    \\<Rightarrow>('p, 'v) message list) \n  \\<Rightarrow> nat\n  \\<Rightarrow> ('p, 'v) message list\"\nwhere\n  \"infiniteExecutionCfg cfg fStepCfg fStepMsg 0 = [cfg]\"\n| \"infiniteExecutionCfg cfg fStepCfg fStepMsg (Suc n) =\n    fStepCfg (infiniteExecutionCfg cfg fStepCfg fStepMsg n) \n             (infiniteExecutionMsg cfg fStepCfg fStepMsg n)\"\n| \"infiniteExecutionMsg cfg fStepCfg fStepMsg 0 = []\"\n| \"infiniteExecutionMsg cfg fStepCfg fStepMsg (Suc n) =\n    fStepMsg (infiniteExecutionCfg cfg fStepCfg fStepMsg n) \n             (infiniteExecutionMsg cfg fStepCfg fStepMsg n)\""], ["", "lemma FairNonUniformExecution:\nfixes\n  cfg\nassumes\n  Cfg: \"initial cfg\" \"nonUniform cfg\"\nshows \"\\<exists> fe ft.\n  (fe 0) = [cfg]\n  \\<and> fairInfiniteExecution fe ft\n  \\<and> (\\<forall> n . nonUniform (last (fe n))\n       \\<and> prefixList (fe n) (fe (n+1)) \n       \\<and> prefixList (ft n) (ft (n+1))\n       \\<and> (execution trans sends start (fe n) (ft n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fe ft.\n       fe 0 = [cfg] \\<and>\n       fairInfiniteExecution fe ft \\<and>\n       (\\<forall>n.\n           nonUniform (last (fe n)) \\<and>\n           prefixList (fe n) (fe (n + 1)) \\<and>\n           prefixList (ft n) (ft (n + 1)) \\<and>\n           execution trans sends start (fe n) (ft n))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>fe ft.\n       fe 0 = [cfg] \\<and>\n       fairInfiniteExecution fe ft \\<and>\n       (\\<forall>n.\n           nonUniform (last (fe n)) \\<and>\n           prefixList (fe n) (fe (n + 1)) \\<and>\n           prefixList (ft n) (ft (n + 1)) \\<and>\n           execution trans sends start (fe n) (ft n))", "have BC: \n    \"execution trans sends start [cfg] [] \n    \\<and> nonUniform (last [cfg]) \n    \\<and> (\\<exists> cfgList' msgList'.  nonUniform (last cfgList') \n    \\<and> prefixList [cfg] cfgList' \n    \\<and> prefixList [] msgList'\n    \\<and> (execution trans sends start cfgList' msgList')\n    \\<and> (\\<exists> msg'. execution.minimalEnabled [cfg] [] msg' \n       \\<and> msg' \\<in> set msgList'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", "using NonUniformExecutionBase[OF assms]"], ["proof (prove)\nusing this:\n  execution trans sends start [cfg] [] \\<and>\n  nonUniform (last [cfg]) \\<and>\n  (\\<exists>cfgList' msgList'.\n      nonUniform (last cfgList') \\<and>\n      prefixList [cfg] cfgList' \\<and>\n      prefixList [] msgList' \\<and>\n      execution trans sends start cfgList' msgList' \\<and>\n      (\\<exists>msg'.\n          execution.minimalEnabled [cfg] [] msg' \\<and>\n          msg' \\<in> set msgList'))\n\ngoal (1 subgoal):\n 1. execution trans sends start [cfg] [] \\<and>\n    nonUniform (last [cfg]) \\<and>\n    (\\<exists>cfgList' msgList'.\n        nonUniform (last cfgList') \\<and>\n        prefixList [cfg] cfgList' \\<and>\n        prefixList [] msgList' \\<and>\n        execution trans sends start cfgList' msgList' \\<and>\n        (\\<exists>msg'.\n            execution.minimalEnabled [cfg] [] msg' \\<and>\n            msg' \\<in> set msgList'))", ".\n  \\<comment> \\<open>fStep ... a step leading to a fair execution.\\<close>"], ["proof (state)\nthis:\n  execution trans sends start [cfg] [] \\<and>\n  nonUniform (last [cfg]) \\<and>\n  (\\<exists>cfgList' msgList'.\n      nonUniform (last cfgList') \\<and>\n      prefixList [cfg] cfgList' \\<and>\n      prefixList [] msgList' \\<and>\n      execution trans sends start cfgList' msgList' \\<and>\n      (\\<exists>msg'.\n          execution.minimalEnabled [cfg] [] msg' \\<and>\n          msg' \\<in> set msgList'))\n\ngoal (1 subgoal):\n 1. \\<exists>fe ft.\n       fe 0 = [cfg] \\<and>\n       fairInfiniteExecution fe ft \\<and>\n       (\\<forall>n.\n           nonUniform (last (fe n)) \\<and>\n           prefixList (fe n) (fe (n + 1)) \\<and>\n           prefixList (ft n) (ft (n + 1)) \\<and>\n           execution trans sends start (fe n) (ft n))", "obtain fStepCfg fStepMsg where FStep: \"\\<forall> cfgList msgList . \\<exists>cfgList' msgList' .\n          fStepCfg cfgList msgList = cfgList' \\<and>\n          fStepMsg cfgList msgList = msgList' \\<and>\n          (initial (hd cfgList) \\<and>\n          nonUniform (last cfgList) \\<and>\n          execution trans sends start cfgList msgList \\<longrightarrow> \n          (nonUniform (last (fStepCfg cfgList msgList)) \n          \\<and> prefixList cfgList (fStepCfg cfgList msgList) \n          \\<and> prefixList msgList (fStepMsg cfgList msgList) \n          \\<and> execution trans sends start (fStepCfg cfgList msgList) \n              (fStepMsg cfgList msgList) \n          \\<and> (initial (hd (fStepCfg cfgList msgList)))\n          \\<and> (\\<exists> msg'. execution.minimalEnabled cfgList msgList msg' \n            \\<and> msg' \\<in> (set (drop (length msgList) \n                                (fStepMsg cfgList msgList))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fStepCfg fStepMsg.\n        \\<forall>cfgList msgList.\n           \\<exists>cfgList' msgList'.\n              fStepCfg cfgList msgList = cfgList' \\<and>\n              fStepMsg cfgList msgList = msgList' \\<and>\n              (initial (hd cfgList) \\<and>\n               nonUniform (last cfgList) \\<and>\n               execution trans sends start cfgList msgList \\<longrightarrow>\n               nonUniform (last (fStepCfg cfgList msgList)) \\<and>\n               prefixList cfgList (fStepCfg cfgList msgList) \\<and>\n               prefixList msgList (fStepMsg cfgList msgList) \\<and>\n               execution trans sends start (fStepCfg cfgList msgList)\n                (fStepMsg cfgList msgList) \\<and>\n               initial (hd (fStepCfg cfgList msgList)) \\<and>\n               (\\<exists>msg'.\n                   execution.minimalEnabled cfgList msgList msg' \\<and>\n                   msg'\n                   \\<in> set (drop (length msgList)\n                               (fStepMsg cfgList\n                                 msgList)))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using NonUniformExecutionStep\n      PredicatePairFunctions2[of \n        \"\\<lambda> cfgList msgList cfgList' msgList'. \n          (initial (hd cfgList) \n          \\<and> nonUniform (last cfgList) \n          \\<and> execution trans sends start cfgList msgList \n            \\<longrightarrow> (nonUniform (last cfgList') \n            \\<and> prefixList cfgList cfgList' \n            \\<and> prefixList msgList msgList' \n            \\<and> execution trans sends start cfgList' msgList'\n            \\<and> (initial (hd cfgList'))\n            \\<and> (\\<exists> msg'. execution.minimalEnabled cfgList msgList msg' \n              \\<and> msg' \\<in> (set (drop (length msgList ) msgList')))))\" \"False\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>initial (hd ?cfgList); nonUniform (last ?cfgList);\n   execution trans sends start ?cfgList ?msgList\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cfgList' msgList'.\n                       nonUniform (last cfgList') \\<and>\n                       prefixList ?cfgList cfgList' \\<and>\n                       prefixList ?msgList msgList' \\<and>\n                       execution trans sends start cfgList' msgList' \\<and>\n                       initial (hd cfgList') \\<and>\n                       (\\<exists>msg'.\n                           execution.minimalEnabled ?cfgList ?msgList\n                            msg' \\<and>\n                           msg' \\<in> set (drop (length ?msgList) msgList'))\n  \\<lbrakk>\\<forall>x1 x2.\n              \\<exists>y1 y2.\n                 initial (hd x1) \\<and>\n                 nonUniform (last x1) \\<and>\n                 execution trans sends start x1 x2 \\<longrightarrow>\n                 nonUniform (last y1) \\<and>\n                 prefixList x1 y1 \\<and>\n                 prefixList x2 y2 \\<and>\n                 execution trans sends start y1 y2 \\<and>\n                 initial (hd y1) \\<and>\n                 (\\<exists>msg'.\n                     execution.minimalEnabled x1 x2 msg' \\<and>\n                     msg' \\<in> set (drop (length x2) y2));\n   \\<And>f1 f2.\n      \\<forall>x1 x2.\n         \\<exists>y1 y2.\n            f1 x1 x2 = y1 \\<and>\n            f2 x1 x2 = y2 \\<and>\n            (initial (hd x1) \\<and>\n             nonUniform (last x1) \\<and>\n             execution trans sends start x1 x2 \\<longrightarrow>\n             nonUniform (last (f1 x1 x2)) \\<and>\n             prefixList x1 (f1 x1 x2) \\<and>\n             prefixList x2 (f2 x1 x2) \\<and>\n             execution trans sends start (f1 x1 x2) (f2 x1 x2) \\<and>\n             initial (hd (f1 x1 x2)) \\<and>\n             (\\<exists>msg'.\n                 execution.minimalEnabled x1 x2 msg' \\<and>\n                 msg'\n                 \\<in> set (drop (length x2) (f2 x1 x2)))) \\<Longrightarrow>\n      False\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>fStepCfg fStepMsg.\n        \\<forall>cfgList msgList.\n           \\<exists>cfgList' msgList'.\n              fStepCfg cfgList msgList = cfgList' \\<and>\n              fStepMsg cfgList msgList = msgList' \\<and>\n              (initial (hd cfgList) \\<and>\n               nonUniform (last cfgList) \\<and>\n               execution trans sends start cfgList msgList \\<longrightarrow>\n               nonUniform (last (fStepCfg cfgList msgList)) \\<and>\n               prefixList cfgList (fStepCfg cfgList msgList) \\<and>\n               prefixList msgList (fStepMsg cfgList msgList) \\<and>\n               execution trans sends start (fStepCfg cfgList msgList)\n                (fStepMsg cfgList msgList) \\<and>\n               initial (hd (fStepCfg cfgList msgList)) \\<and>\n               (\\<exists>msg'.\n                   execution.minimalEnabled cfgList msgList msg' \\<and>\n                   msg'\n                   \\<in> set (drop (length msgList)\n                               (fStepMsg cfgList\n                                 msgList)))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>cfgList msgList.\n     \\<exists>cfgList' msgList'.\n        fStepCfg cfgList msgList = cfgList' \\<and>\n        fStepMsg cfgList msgList = msgList' \\<and>\n        (initial (hd cfgList) \\<and>\n         nonUniform (last cfgList) \\<and>\n         execution trans sends start cfgList msgList \\<longrightarrow>\n         nonUniform (last (fStepCfg cfgList msgList)) \\<and>\n         prefixList cfgList (fStepCfg cfgList msgList) \\<and>\n         prefixList msgList (fStepMsg cfgList msgList) \\<and>\n         execution trans sends start (fStepCfg cfgList msgList)\n          (fStepMsg cfgList msgList) \\<and>\n         initial (hd (fStepCfg cfgList msgList)) \\<and>\n         (\\<exists>msg'.\n             execution.minimalEnabled cfgList msgList msg' \\<and>\n             msg'\n             \\<in> set (drop (length msgList) (fStepMsg cfgList msgList))))\n\ngoal (1 subgoal):\n 1. \\<exists>fe ft.\n       fe 0 = [cfg] \\<and>\n       fairInfiniteExecution fe ft \\<and>\n       (\\<forall>n.\n           nonUniform (last (fe n)) \\<and>\n           prefixList (fe n) (fe (n + 1)) \\<and>\n           prefixList (ft n) (ft (n + 1)) \\<and>\n           execution trans sends start (fe n) (ft n))", "define fe ft\n    where \"fe = infiniteExecutionCfg cfg fStepCfg fStepMsg\"\n      and \"ft = infiniteExecutionMsg cfg fStepCfg fStepMsg\""], ["proof (state)\nthis:\n  fe = infiniteExecutionCfg cfg fStepCfg fStepMsg\n  ft = infiniteExecutionMsg cfg fStepCfg fStepMsg\n\ngoal (1 subgoal):\n 1. \\<exists>fe ft.\n       fe 0 = [cfg] \\<and>\n       fairInfiniteExecution fe ft \\<and>\n       (\\<forall>n.\n           nonUniform (last (fe n)) \\<and>\n           prefixList (fe n) (fe (n + 1)) \\<and>\n           prefixList (ft n) (ft (n + 1)) \\<and>\n           execution trans sends start (fe n) (ft n))", "have BasicProperties: \"(\\<forall>n. nonUniform (last (fe n)) \n    \\<and> prefixList (fe n) (fe (n + 1)) \\<and> prefixList (ft n) (ft (n + 1)) \n    \\<and> execution trans sends start (fe n) (ft n) \n    \\<and> initial (hd (fe (n + 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       nonUniform (last (fe n)) \\<and>\n       prefixList (fe n) (fe (n + 1)) \\<and>\n       prefixList (ft n) (ft (n + 1)) \\<and>\n       execution trans sends start (fe n) (ft n) \\<and>\n       initial (hd (fe (n + 1)))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       nonUniform (last (fe n)) \\<and>\n       prefixList (fe n) (fe (n + 1)) \\<and>\n       prefixList (ft n) (ft (n + 1)) \\<and>\n       execution trans sends start (fe n) (ft n) \\<and>\n       initial (hd (fe (n + 1)))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       nonUniform (last (fe n)) \\<and>\n       prefixList (fe n) (fe (n + 1)) \\<and>\n       prefixList (ft n) (ft (n + 1)) \\<and>\n       execution trans sends start (fe n) (ft n) \\<and>\n       initial (hd (fe (n + 1)))", "show \"nonUniform (last (fe n)) \\<and>\n          prefixList (fe n) (fe (n + (1::nat))) \n          \\<and> prefixList (ft n) (ft (n + (1::nat))) \n          \\<and> execution trans sends start (fe n) (ft n) \n          \\<and> initial (hd (fe (n + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonUniform (last (fe n)) \\<and>\n    prefixList (fe n) (fe (n + 1)) \\<and>\n    prefixList (ft n) (ft (n + 1)) \\<and>\n    execution trans sends start (fe n) (ft n) \\<and>\n    initial (hd (fe (n + 1)))", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. nonUniform (last (fe 0)) \\<and>\n    prefixList (fe 0) (fe (0 + 1)) \\<and>\n    prefixList (ft 0) (ft (0 + 1)) \\<and>\n    execution trans sends start (fe 0) (ft 0) \\<and>\n    initial (hd (fe (0 + 1)))\n 2. \\<And>n.\n       nonUniform (last (fe n)) \\<and>\n       prefixList (fe n) (fe (n + 1)) \\<and>\n       prefixList (ft n) (ft (n + 1)) \\<and>\n       execution trans sends start (fe n) (ft n) \\<and>\n       initial (hd (fe (n + 1))) \\<Longrightarrow>\n       nonUniform (last (fe (Suc n))) \\<and>\n       prefixList (fe (Suc n)) (fe (Suc n + 1)) \\<and>\n       prefixList (ft (Suc n)) (ft (Suc n + 1)) \\<and>\n       execution trans sends start (fe (Suc n)) (ft (Suc n)) \\<and>\n       initial (hd (fe (Suc n + 1)))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. nonUniform (last (fe 0)) \\<and>\n    prefixList (fe 0) (fe (0 + 1)) \\<and>\n    prefixList (ft 0) (ft (0 + 1)) \\<and>\n    execution trans sends start (fe 0) (ft 0) \\<and>\n    initial (hd (fe (0 + 1)))\n 2. \\<And>n.\n       nonUniform (last (fe n)) \\<and>\n       prefixList (fe n) (fe (n + 1)) \\<and>\n       prefixList (ft n) (ft (n + 1)) \\<and>\n       execution trans sends start (fe n) (ft n) \\<and>\n       initial (hd (fe (n + 1))) \\<Longrightarrow>\n       nonUniform (last (fe (Suc n))) \\<and>\n       prefixList (fe (Suc n)) (fe (Suc n + 1)) \\<and>\n       prefixList (ft (Suc n)) (ft (Suc n + 1)) \\<and>\n       execution trans sends start (fe (Suc n)) (ft (Suc n)) \\<and>\n       initial (hd (fe (Suc n + 1)))", "hence \"fe 0 = [cfg]\" \"ft 0 = []\" \"fe 1 = fStepCfg (fe 0) (ft 0)\" \n        \"ft 1 = fStepMsg (fe 0) (ft 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fe 0 = [cfg] &&& ft 0 = []) &&&\n    fe 1 = fStepCfg (fe 0) (ft 0) &&& ft 1 = fStepMsg (fe 0) (ft 0)", "using fe_def ft_def"], ["proof (prove)\nusing this:\n  fe = infiniteExecutionCfg cfg fStepCfg fStepMsg\n  ft = infiniteExecutionMsg cfg fStepCfg fStepMsg\n\ngoal (1 subgoal):\n 1. (fe 0 = [cfg] &&& ft 0 = []) &&&\n    fe 1 = fStepCfg (fe 0) (ft 0) &&& ft 1 = fStepMsg (fe 0) (ft 0)", "by simp_all"], ["proof (state)\nthis:\n  fe 0 = [cfg]\n  ft 0 = []\n  fe 1 = fStepCfg (fe 0) (ft 0)\n  ft 1 = fStepMsg (fe 0) (ft 0)\n\ngoal (2 subgoals):\n 1. nonUniform (last (fe 0)) \\<and>\n    prefixList (fe 0) (fe (0 + 1)) \\<and>\n    prefixList (ft 0) (ft (0 + 1)) \\<and>\n    execution trans sends start (fe 0) (ft 0) \\<and>\n    initial (hd (fe (0 + 1)))\n 2. \\<And>n.\n       nonUniform (last (fe n)) \\<and>\n       prefixList (fe n) (fe (n + 1)) \\<and>\n       prefixList (ft n) (ft (n + 1)) \\<and>\n       execution trans sends start (fe n) (ft n) \\<and>\n       initial (hd (fe (n + 1))) \\<Longrightarrow>\n       nonUniform (last (fe (Suc n))) \\<and>\n       prefixList (fe (Suc n)) (fe (Suc n + 1)) \\<and>\n       prefixList (ft (Suc n)) (ft (Suc n + 1)) \\<and>\n       execution trans sends start (fe (Suc n)) (ft (Suc n)) \\<and>\n       initial (hd (fe (Suc n + 1)))", "thus ?case"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  ft 0 = []\n  fe 1 = fStepCfg (fe 0) (ft 0)\n  ft 1 = fStepMsg (fe 0) (ft 0)\n\ngoal (1 subgoal):\n 1. nonUniform (last (fe 0)) \\<and>\n    prefixList (fe 0) (fe (0 + 1)) \\<and>\n    prefixList (ft 0) (ft (0 + 1)) \\<and>\n    execution trans sends start (fe 0) (ft 0) \\<and>\n    initial (hd (fe (0 + 1)))", "using BC FStep"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  ft 0 = []\n  fe 1 = fStepCfg (fe 0) (ft 0)\n  ft 1 = fStepMsg (fe 0) (ft 0)\n  execution trans sends start [cfg] [] \\<and>\n  nonUniform (last [cfg]) \\<and>\n  (\\<exists>cfgList' msgList'.\n      nonUniform (last cfgList') \\<and>\n      prefixList [cfg] cfgList' \\<and>\n      prefixList [] msgList' \\<and>\n      execution trans sends start cfgList' msgList' \\<and>\n      (\\<exists>msg'.\n          execution.minimalEnabled [cfg] [] msg' \\<and>\n          msg' \\<in> set msgList'))\n  \\<forall>cfgList msgList.\n     \\<exists>cfgList' msgList'.\n        fStepCfg cfgList msgList = cfgList' \\<and>\n        fStepMsg cfgList msgList = msgList' \\<and>\n        (initial (hd cfgList) \\<and>\n         nonUniform (last cfgList) \\<and>\n         execution trans sends start cfgList msgList \\<longrightarrow>\n         nonUniform (last (fStepCfg cfgList msgList)) \\<and>\n         prefixList cfgList (fStepCfg cfgList msgList) \\<and>\n         prefixList msgList (fStepMsg cfgList msgList) \\<and>\n         execution trans sends start (fStepCfg cfgList msgList)\n          (fStepMsg cfgList msgList) \\<and>\n         initial (hd (fStepCfg cfgList msgList)) \\<and>\n         (\\<exists>msg'.\n             execution.minimalEnabled cfgList msgList msg' \\<and>\n             msg'\n             \\<in> set (drop (length msgList) (fStepMsg cfgList msgList))))\n\ngoal (1 subgoal):\n 1. nonUniform (last (fe 0)) \\<and>\n    prefixList (fe 0) (fe (0 + 1)) \\<and>\n    prefixList (ft 0) (ft (0 + 1)) \\<and>\n    execution trans sends start (fe 0) (ft 0) \\<and>\n    initial (hd (fe (0 + 1)))", "by (simp, metis execution.base)"], ["proof (state)\nthis:\n  nonUniform (last (fe 0)) \\<and>\n  prefixList (fe 0) (fe (0 + 1)) \\<and>\n  prefixList (ft 0) (ft (0 + 1)) \\<and>\n  execution trans sends start (fe 0) (ft 0) \\<and> initial (hd (fe (0 + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       nonUniform (last (fe n)) \\<and>\n       prefixList (fe n) (fe (n + 1)) \\<and>\n       prefixList (ft n) (ft (n + 1)) \\<and>\n       execution trans sends start (fe n) (ft n) \\<and>\n       initial (hd (fe (n + 1))) \\<Longrightarrow>\n       nonUniform (last (fe (Suc n))) \\<and>\n       prefixList (fe (Suc n)) (fe (Suc n + 1)) \\<and>\n       prefixList (ft (Suc n)) (ft (Suc n + 1)) \\<and>\n       execution trans sends start (fe (Suc n)) (ft (Suc n)) \\<and>\n       initial (hd (fe (Suc n + 1)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       nonUniform (last (fe n)) \\<and>\n       prefixList (fe n) (fe (n + 1)) \\<and>\n       prefixList (ft n) (ft (n + 1)) \\<and>\n       execution trans sends start (fe n) (ft n) \\<and>\n       initial (hd (fe (n + 1))) \\<Longrightarrow>\n       nonUniform (last (fe (Suc n))) \\<and>\n       prefixList (fe (Suc n)) (fe (Suc n + 1)) \\<and>\n       prefixList (ft (Suc n)) (ft (Suc n + 1)) \\<and>\n       execution trans sends start (fe (Suc n)) (ft (Suc n)) \\<and>\n       initial (hd (fe (Suc n + 1)))", "case (Suc n)"], ["proof (state)\nthis:\n  nonUniform (last (fe n)) \\<and>\n  prefixList (fe n) (fe (n + 1)) \\<and>\n  prefixList (ft n) (ft (n + 1)) \\<and>\n  execution trans sends start (fe n) (ft n) \\<and> initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       nonUniform (last (fe n)) \\<and>\n       prefixList (fe n) (fe (n + 1)) \\<and>\n       prefixList (ft n) (ft (n + 1)) \\<and>\n       execution trans sends start (fe n) (ft n) \\<and>\n       initial (hd (fe (n + 1))) \\<Longrightarrow>\n       nonUniform (last (fe (Suc n))) \\<and>\n       prefixList (fe (Suc n)) (fe (Suc n + 1)) \\<and>\n       prefixList (ft (Suc n)) (ft (Suc n + 1)) \\<and>\n       execution trans sends start (fe (Suc n)) (ft (Suc n)) \\<and>\n       initial (hd (fe (Suc n + 1)))", "thus ?case"], ["proof (prove)\nusing this:\n  nonUniform (last (fe n)) \\<and>\n  prefixList (fe n) (fe (n + 1)) \\<and>\n  prefixList (ft n) (ft (n + 1)) \\<and>\n  execution trans sends start (fe n) (ft n) \\<and> initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. nonUniform (last (fe (Suc n))) \\<and>\n    prefixList (fe (Suc n)) (fe (Suc n + 1)) \\<and>\n    prefixList (ft (Suc n)) (ft (Suc n + 1)) \\<and>\n    execution trans sends start (fe (Suc n)) (ft (Suc n)) \\<and>\n    initial (hd (fe (Suc n + 1)))", "using fe_def ft_def"], ["proof (prove)\nusing this:\n  nonUniform (last (fe n)) \\<and>\n  prefixList (fe n) (fe (n + 1)) \\<and>\n  prefixList (ft n) (ft (n + 1)) \\<and>\n  execution trans sends start (fe n) (ft n) \\<and> initial (hd (fe (n + 1)))\n  fe = infiniteExecutionCfg cfg fStepCfg fStepMsg\n  ft = infiniteExecutionMsg cfg fStepCfg fStepMsg\n\ngoal (1 subgoal):\n 1. nonUniform (last (fe (Suc n))) \\<and>\n    prefixList (fe (Suc n)) (fe (Suc n + 1)) \\<and>\n    prefixList (ft (Suc n)) (ft (Suc n + 1)) \\<and>\n    execution trans sends start (fe (Suc n)) (ft (Suc n)) \\<and>\n    initial (hd (fe (Suc n + 1)))", "by (auto, (metis FStep execution.base)+)"], ["proof (state)\nthis:\n  nonUniform (last (fe (Suc n))) \\<and>\n  prefixList (fe (Suc n)) (fe (Suc n + 1)) \\<and>\n  prefixList (ft (Suc n)) (ft (Suc n + 1)) \\<and>\n  execution trans sends start (fe (Suc n)) (ft (Suc n)) \\<and>\n  initial (hd (fe (Suc n + 1)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nonUniform (last (fe n)) \\<and>\n  prefixList (fe n) (fe (n + 1)) \\<and>\n  prefixList (ft n) (ft (n + 1)) \\<and>\n  execution trans sends start (fe n) (ft n) \\<and> initial (hd (fe (n + 1)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<exists>fe ft.\n       fe 0 = [cfg] \\<and>\n       fairInfiniteExecution fe ft \\<and>\n       (\\<forall>n.\n           nonUniform (last (fe n)) \\<and>\n           prefixList (fe n) (fe (n + 1)) \\<and>\n           prefixList (ft n) (ft (n + 1)) \\<and>\n           execution trans sends start (fe n) (ft n))", "have Fair: \"fairInfiniteExecution fe ft\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fairInfiniteExecution fe ft", "using BasicProperties"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. fairInfiniteExecution fe ft", "unfolding fairInfiniteExecution_def infiniteExecution_def \n      execution_def flpSystem_def"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     ((1 \\<le> length (fe n) \\<and>\n       length (fe n) - 1 = length (ft n)) \\<and>\n      initial (hd (fe n)) \\<and>\n      (\\<forall>i cfg1 cfg2.\n          i < length (fe n) - 1 \\<longrightarrow>\n          cfg1 = fe n ! i \\<longrightarrow>\n          cfg2 = fe n ! (i + 1) \\<longrightarrow>\n          cfg1 \\<turnstile> ft n ! i \\<mapsto> cfg2)) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. (\\<forall>n.\n        ((1 \\<le> length (fe n) \\<and>\n          length (fe n) - 1 = length (ft n)) \\<and>\n         initial (hd (fe n)) \\<and>\n         (\\<forall>i cfg1 cfg2.\n             i < length (fe n) - 1 \\<longrightarrow>\n             cfg1 = fe n ! i \\<longrightarrow>\n             cfg2 = fe n ! (i + 1) \\<longrightarrow>\n             cfg1 \\<turnstile> ft n ! i \\<mapsto> cfg2)) \\<and>\n        prefixList (fe n) (fe (n + 1)) \\<and>\n        prefixList (ft n) (ft (n + 1))) \\<and>\n    (\\<forall>n n0.\n        n0 < length (fe n) \\<longrightarrow>\n        (\\<forall>p msg.\n            enabled (fe n ! n0) msg \\<and>\n            isReceiverOf p msg \\<and>\n            correctInfinite fe ft p \\<longrightarrow>\n            (\\<exists>n'\\<ge>n.\n                \\<exists>n0'\\<ge>n0.\n                   n0' < length (ft n') \\<and> msg = ft n' ! n0')))", "proof(auto simp add: finiteProcs minimalProcs finiteSends noInSends)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n0 p msg.\n       \\<lbrakk>\\<forall>n.\n                   initReachable (last (fe n)) \\<and>\n                   \\<not> vUniform False (last (fe n)) \\<and>\n                   \\<not> vUniform True (last (fe n)) \\<and>\n                   prefixList (fe n) (fe (Suc n)) \\<and>\n                   prefixList (ft n) (ft (Suc n)) \\<and>\n                   Suc 0 \\<le> length (fe n) \\<and>\n                   length (fe n) - Suc 0 = length (ft n) \\<and>\n                   initial (hd (fe n)) \\<and>\n                   (\\<forall>i<length (fe n) - Suc 0.\n                       fe n !\n                       i \\<turnstile> ft n !\ni \\<mapsto> fe n ! Suc i) \\<and>\n                   initial (hd (fe (Suc n)));\n        n0 < length (fe n); enabled (fe n ! n0) msg; isReceiverOf p msg;\n        correctInfinite fe ft p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                            \\<exists>n0'\\<ge>n0.\n                               n0' < length (ft n') \\<and> msg = ft n' ! n0'", "fix n n0 p msg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n0 p msg.\n       \\<lbrakk>\\<forall>n.\n                   initReachable (last (fe n)) \\<and>\n                   \\<not> vUniform False (last (fe n)) \\<and>\n                   \\<not> vUniform True (last (fe n)) \\<and>\n                   prefixList (fe n) (fe (Suc n)) \\<and>\n                   prefixList (ft n) (ft (Suc n)) \\<and>\n                   Suc 0 \\<le> length (fe n) \\<and>\n                   length (fe n) - Suc 0 = length (ft n) \\<and>\n                   initial (hd (fe n)) \\<and>\n                   (\\<forall>i<length (fe n) - Suc 0.\n                       fe n !\n                       i \\<turnstile> ft n !\ni \\<mapsto> fe n ! Suc i) \\<and>\n                   initial (hd (fe (Suc n)));\n        n0 < length (fe n); enabled (fe n ! n0) msg; isReceiverOf p msg;\n        correctInfinite fe ft p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                            \\<exists>n0'\\<ge>n0.\n                               n0' < length (ft n') \\<and> msg = ft n' ! n0'", "assume AssumptionFair: \"\\<forall>n. initReachable (last (fe n)) \\<and>\n       \\<not> vUniform False (last (fe n)) \\<and>\n       \\<not> vUniform True (last (fe n)) \\<and>\n       prefixList (fe n) (fe (Suc n)) \\<and>\n       prefixList (ft n) (ft (Suc n)) \\<and>\n       Suc 0 \\<le> length (fe n) \\<and>\n       length (fe n) - Suc 0 = length (ft n) \\<and>\n       initial (hd (fe n)) \\<and> \n       (\\<forall>i<length (fe n) - Suc 0. ((fe n ! i) \\<turnstile> (ft n ! i) \n       \\<mapsto> (fe n ! Suc i))) \\<and> initial (hd (fe (Suc n)))\"\n      \"n0 < length (fe n)\"\n      \"enabled (fe n ! n0) msg\" \n      \"isReceiverOf p msg\" \n      \"correctInfinite fe ft p\""], ["proof (state)\nthis:\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n  n0 < length (fe n)\n  enabled (fe n ! n0) msg\n  isReceiverOf p msg\n  correctInfinite fe ft p\n\ngoal (1 subgoal):\n 1. \\<And>n n0 p msg.\n       \\<lbrakk>\\<forall>n.\n                   initReachable (last (fe n)) \\<and>\n                   \\<not> vUniform False (last (fe n)) \\<and>\n                   \\<not> vUniform True (last (fe n)) \\<and>\n                   prefixList (fe n) (fe (Suc n)) \\<and>\n                   prefixList (ft n) (ft (Suc n)) \\<and>\n                   Suc 0 \\<le> length (fe n) \\<and>\n                   length (fe n) - Suc 0 = length (ft n) \\<and>\n                   initial (hd (fe n)) \\<and>\n                   (\\<forall>i<length (fe n) - Suc 0.\n                       fe n !\n                       i \\<turnstile> ft n !\ni \\<mapsto> fe n ! Suc i) \\<and>\n                   initial (hd (fe (Suc n)));\n        n0 < length (fe n); enabled (fe n ! n0) msg; isReceiverOf p msg;\n        correctInfinite fe ft p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                            \\<exists>n0'\\<ge>n0.\n                               n0' < length (ft n') \\<and> msg = ft n' ! n0'", "have MessageStaysOrConsumed: \"\\<And> n n1 n2 msg. \n      (n1 \\<le> n2 \\<and> n2 < length (fe n) \\<and> (enabled (fe n ! n1) msg)) \n      \\<longrightarrow> (enabled (fe n ! n2) msg) \n          \\<or> (\\<exists> n0' \\<ge> n1. n0' < length (ft n) \\<and> ft n ! n0' = msg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n n1 n2 msg.\n       n1 \\<le> n2 \\<and>\n       n2 < length (fe n) \\<and> enabled (fe n ! n1) msg \\<longrightarrow>\n       enabled (fe n ! n2) msg \\<or>\n       (\\<exists>n0'\\<ge>n1. n0' < length (ft n) \\<and> ft n ! n0' = msg)", "proof(auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n1 n2 msg.\n       \\<lbrakk>n1 \\<le> n2; n2 < length (fe n); enabled (fe n ! n1) msg;\n        \\<forall>n0'<length (ft n).\n           n1 \\<le> n0' \\<longrightarrow> ft n ! n0' \\<noteq> msg\\<rbrakk>\n       \\<Longrightarrow> enabled (fe n ! n2) msg", "fix n n1 n2 msg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n1 n2 msg.\n       \\<lbrakk>n1 \\<le> n2; n2 < length (fe n); enabled (fe n ! n1) msg;\n        \\<forall>n0'<length (ft n).\n           n1 \\<le> n0' \\<longrightarrow> ft n ! n0' \\<noteq> msg\\<rbrakk>\n       \\<Longrightarrow> enabled (fe n ! n2) msg", "assume Ass: \"n1 \\<le> n2\" \"n2 < length (fe n)\" \"enabled (fe n ! n1) msg\"\n        \"\\<forall>index<length (ft n). n1 \\<le> index \\<longrightarrow> ft n ! index \\<noteq> msg\""], ["proof (state)\nthis:\n  n1 \\<le> n2\n  n2 < length (fe n)\n  enabled (fe n ! n1) msg\n  \\<forall>index<length (ft n).\n     n1 \\<le> index \\<longrightarrow> ft n ! index \\<noteq> msg\n\ngoal (1 subgoal):\n 1. \\<And>n n1 n2 msg.\n       \\<lbrakk>n1 \\<le> n2; n2 < length (fe n); enabled (fe n ! n1) msg;\n        \\<forall>n0'<length (ft n).\n           n1 \\<le> n0' \\<longrightarrow> ft n ! n0' \\<noteq> msg\\<rbrakk>\n       \\<Longrightarrow> enabled (fe n ! n2) msg", "have \"\\<forall> k \\<le> n2 - n1 . \n        msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<le>n2 - n1.\n       msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg", "proof(auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<le> n2 - n1 \\<Longrightarrow>\n       msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<le> n2 - n1 \\<Longrightarrow>\n       msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg", "show \"k \\<le> n2 - n1 \\<Longrightarrow> \n          msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n2 - n1 \\<Longrightarrow>\n    msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg", "proof(induct k, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg;\n        Suc k \\<le> n2 - n1\\<rbrakk>\n       \\<Longrightarrow> msgs (fe n ! n1) msg\n                         \\<le> msgs (fe n ! Suc (n1 + k)) msg", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg;\n        Suc k \\<le> n2 - n1\\<rbrakk>\n       \\<Longrightarrow> msgs (fe n ! n1) msg\n                         \\<le> msgs (fe n ! Suc (n1 + k)) msg", "assume IV: \"msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg\" \n            \"Suc k \\<le> n2 - n1\""], ["proof (state)\nthis:\n  msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg\n  Suc k \\<le> n2 - n1\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg;\n        Suc k \\<le> n2 - n1\\<rbrakk>\n       \\<Longrightarrow> msgs (fe n ! n1) msg\n                         \\<le> msgs (fe n ! Suc (n1 + k)) msg", "from BasicProperties"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))", "have Exec: \n            \"execution trans sends start (fe n) (ft n)\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. execution trans sends start (fe n) (ft n)", "by blast"], ["proof (state)\nthis:\n  execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg;\n        Suc k \\<le> n2 - n1\\<rbrakk>\n       \\<Longrightarrow> msgs (fe n ! n1) msg\n                         \\<le> msgs (fe n ! Suc (n1 + k)) msg", "have \"n2 \\<le> length (ft n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n2 \\<le> length (ft n)", "using Exec Ass(2)\n            execution.length[of trans sends start \"fe n\" \"ft n\"]"], ["proof (prove)\nusing this:\n  execution trans sends start (fe n) (ft n)\n  n2 < length (fe n)\n  execution trans sends start (fe n) (ft n) \\<Longrightarrow>\n  length (fe n) - 1 = length (ft n)\n\ngoal (1 subgoal):\n 1. n2 \\<le> length (ft n)", "by simp"], ["proof (state)\nthis:\n  n2 \\<le> length (ft n)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg;\n        Suc k \\<le> n2 - n1\\<rbrakk>\n       \\<Longrightarrow> msgs (fe n ! n1) msg\n                         \\<le> msgs (fe n ! Suc (n1 + k)) msg", "hence RightIndex: \"n1 + k \\<ge> n1 \\<and> n1 + k < length (ft n)\""], ["proof (prove)\nusing this:\n  n2 \\<le> length (ft n)\n\ngoal (1 subgoal):\n 1. n1 \\<le> n1 + k \\<and> n1 + k < length (ft n)", "using IV(2)"], ["proof (prove)\nusing this:\n  n2 \\<le> length (ft n)\n  Suc k \\<le> n2 - n1\n\ngoal (1 subgoal):\n 1. n1 \\<le> n1 + k \\<and> n1 + k < length (ft n)", "by simp"], ["proof (state)\nthis:\n  n1 \\<le> n1 + k \\<and> n1 + k < length (ft n)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg;\n        Suc k \\<le> n2 - n1\\<rbrakk>\n       \\<Longrightarrow> msgs (fe n ! n1) msg\n                         \\<le> msgs (fe n ! Suc (n1 + k)) msg", "have  Step: \"(fe n ! (n1 + k)) \\<turnstile> (ft n ! (n1 + k)) \n                      \\<mapsto> (fe n ! Suc (n1 + k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe n !\n    (n1 + k) \\<turnstile> ft n ! (n1 + k) \\<mapsto> fe n ! Suc (n1 + k)", "using Exec execution.step[of trans sends start \"fe n\" \"ft n\" \n              \"n1 + k\" \"fe n ! (n1 + k)\" \"fe n ! (n1 + k + 1)\"] IV(2) \n              Ass(2)"], ["proof (prove)\nusing this:\n  execution trans sends start (fe n) (ft n)\n  \\<lbrakk>execution trans sends start (fe n) (ft n);\n   n1 + k < length (fe n) - 1; fe n ! (n1 + k) = fe n ! (n1 + k);\n   fe n ! (n1 + k + 1) = fe n ! (n1 + k + 1)\\<rbrakk>\n  \\<Longrightarrow> fe n !\n                    (n1 +\n                     k) \\<turnstile> ft n !\n                                     (n1 + k) \\<mapsto> fe n ! (n1 + k + 1)\n  Suc k \\<le> n2 - n1\n  n2 < length (fe n)\n\ngoal (1 subgoal):\n 1. fe n !\n    (n1 + k) \\<turnstile> ft n ! (n1 + k) \\<mapsto> fe n ! Suc (n1 + k)", "by simp"], ["proof (state)\nthis:\n  fe n ! (n1 + k) \\<turnstile> ft n ! (n1 + k) \\<mapsto> fe n ! Suc (n1 + k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg;\n        Suc k \\<le> n2 - n1\\<rbrakk>\n       \\<Longrightarrow> msgs (fe n ! n1) msg\n                         \\<le> msgs (fe n ! Suc (n1 + k)) msg", "hence \"msg \\<noteq> (ft n ! (n1 + k))\""], ["proof (prove)\nusing this:\n  fe n ! (n1 + k) \\<turnstile> ft n ! (n1 + k) \\<mapsto> fe n ! Suc (n1 + k)\n\ngoal (1 subgoal):\n 1. msg \\<noteq> ft n ! (n1 + k)", "using Ass(4) Ass(2) IV(2) RightIndex Exec \n            execution.length[of trans sends start \"fe n\" \"ft n\"]"], ["proof (prove)\nusing this:\n  fe n ! (n1 + k) \\<turnstile> ft n ! (n1 + k) \\<mapsto> fe n ! Suc (n1 + k)\n  \\<forall>index<length (ft n).\n     n1 \\<le> index \\<longrightarrow> ft n ! index \\<noteq> msg\n  n2 < length (fe n)\n  Suc k \\<le> n2 - n1\n  n1 \\<le> n1 + k \\<and> n1 + k < length (ft n)\n  execution trans sends start (fe n) (ft n)\n  execution trans sends start (fe n) (ft n) \\<Longrightarrow>\n  length (fe n) - 1 = length (ft n)\n\ngoal (1 subgoal):\n 1. msg \\<noteq> ft n ! (n1 + k)", "by blast"], ["proof (state)\nthis:\n  msg \\<noteq> ft n ! (n1 + k)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg;\n        Suc k \\<le> n2 - n1\\<rbrakk>\n       \\<Longrightarrow> msgs (fe n ! n1) msg\n                         \\<le> msgs (fe n ! Suc (n1 + k)) msg", "thus \"msgs (fe n ! n1) msg \\<le> msgs (fe n ! Suc (n1 + k)) msg\""], ["proof (prove)\nusing this:\n  msg \\<noteq> ft n ! (n1 + k)\n\ngoal (1 subgoal):\n 1. msgs (fe n ! n1) msg \\<le> msgs (fe n ! Suc (n1 + k)) msg", "using Step OtherMessagesOnlyGrowing[of \"(fe n ! (n1 + k))\" \n              \"(ft n ! (n1 + k))\" \"(fe n ! Suc (n1 + k))\" \"msg\"] IV(1)"], ["proof (prove)\nusing this:\n  msg \\<noteq> ft n ! (n1 + k)\n  fe n ! (n1 + k) \\<turnstile> ft n ! (n1 + k) \\<mapsto> fe n ! Suc (n1 + k)\n  \\<lbrakk>fe n !\n           (n1 +\n            k) \\<turnstile> ft n ! (n1 + k) \\<mapsto> fe n ! Suc (n1 + k);\n   ft n ! (n1 + k) \\<noteq> msg\\<rbrakk>\n  \\<Longrightarrow> msgs (fe n ! (n1 + k)) msg\n                    \\<le> msgs (fe n ! Suc (n1 + k)) msg\n  msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg\n\ngoal (1 subgoal):\n 1. msgs (fe n ! n1) msg \\<le> msgs (fe n ! Suc (n1 + k)) msg", "by simp"], ["proof (state)\nthis:\n  msgs (fe n ! n1) msg \\<le> msgs (fe n ! Suc (n1 + k)) msg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<le> n2 - n1 \\<Longrightarrow>\n  msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k\\<le>n2 - n1.\n     msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg\n\ngoal (1 subgoal):\n 1. \\<And>n n1 n2 msg.\n       \\<lbrakk>n1 \\<le> n2; n2 < length (fe n); enabled (fe n ! n1) msg;\n        \\<forall>n0'<length (ft n).\n           n1 \\<le> n0' \\<longrightarrow> ft n ! n0' \\<noteq> msg\\<rbrakk>\n       \\<Longrightarrow> enabled (fe n ! n2) msg", "hence \"msgs (fe n ! n1) msg \\<le> msgs (fe n ! n2) msg\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>n2 - n1.\n     msgs (fe n ! n1) msg \\<le> msgs (fe n ! (n1 + k)) msg\n\ngoal (1 subgoal):\n 1. msgs (fe n ! n1) msg \\<le> msgs (fe n ! n2) msg", "by (metis Ass(1) le_add_diff_inverse order_refl)"], ["proof (state)\nthis:\n  msgs (fe n ! n1) msg \\<le> msgs (fe n ! n2) msg\n\ngoal (1 subgoal):\n 1. \\<And>n n1 n2 msg.\n       \\<lbrakk>n1 \\<le> n2; n2 < length (fe n); enabled (fe n ! n1) msg;\n        \\<forall>n0'<length (ft n).\n           n1 \\<le> n0' \\<longrightarrow> ft n ! n0' \\<noteq> msg\\<rbrakk>\n       \\<Longrightarrow> enabled (fe n ! n2) msg", "thus \"enabled (fe n ! n2) msg\""], ["proof (prove)\nusing this:\n  msgs (fe n ! n1) msg \\<le> msgs (fe n ! n2) msg\n\ngoal (1 subgoal):\n 1. enabled (fe n ! n2) msg", "using Ass(3) enabled_def"], ["proof (prove)\nusing this:\n  msgs (fe n ! n1) msg \\<le> msgs (fe n ! n2) msg\n  enabled (fe n ! n1) msg\n  enabled ?cfg ?msg \\<equiv> ?msg \\<in># msgs ?cfg\n\ngoal (1 subgoal):\n 1. enabled (fe n ! n2) msg", "by (metis gr0I leD)"], ["proof (state)\nthis:\n  enabled (fe n ! n2) msg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?n1.0 \\<le> ?n2.0 \\<and>\n  ?n2.0 < length (fe ?n) \\<and>\n  enabled (fe ?n ! ?n1.0) ?msg \\<longrightarrow>\n  enabled (fe ?n ! ?n2.0) ?msg \\<or>\n  (\\<exists>n0'\\<ge>?n1.0. n0' < length (ft ?n) \\<and> ft ?n ! n0' = ?msg)\n\ngoal (1 subgoal):\n 1. \\<And>n n0 p msg.\n       \\<lbrakk>\\<forall>n.\n                   initReachable (last (fe n)) \\<and>\n                   \\<not> vUniform False (last (fe n)) \\<and>\n                   \\<not> vUniform True (last (fe n)) \\<and>\n                   prefixList (fe n) (fe (Suc n)) \\<and>\n                   prefixList (ft n) (ft (Suc n)) \\<and>\n                   Suc 0 \\<le> length (fe n) \\<and>\n                   length (fe n) - Suc 0 = length (ft n) \\<and>\n                   initial (hd (fe n)) \\<and>\n                   (\\<forall>i<length (fe n) - Suc 0.\n                       fe n !\n                       i \\<turnstile> ft n !\ni \\<mapsto> fe n ! Suc i) \\<and>\n                   initial (hd (fe (Suc n)));\n        n0 < length (fe n); enabled (fe n ! n0) msg; isReceiverOf p msg;\n        correctInfinite fe ft p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                            \\<exists>n0'\\<ge>n0.\n                               n0' < length (ft n') \\<and> msg = ft n' ! n0'", "have EnabledOrConsumed: \"enabled (fe n ! (length (fe n) - 1)) msg \n      \\<or> (\\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (fe n ! (length (fe n) - 1)) msg \\<or>\n    (\\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg)", "using AssumptionFair(3) AssumptionFair(2) \n        MessageStaysOrConsumed[of \"n0\" \"length (fe n) - 1\" \"n\" \"msg\"]"], ["proof (prove)\nusing this:\n  enabled (fe n ! n0) msg\n  n0 < length (fe n)\n  n0 \\<le> length (fe n) - 1 \\<and>\n  length (fe n) - 1 < length (fe n) \\<and>\n  enabled (fe n ! n0) msg \\<longrightarrow>\n  enabled (fe n ! (length (fe n) - 1)) msg \\<or>\n  (\\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg)\n\ngoal (1 subgoal):\n 1. enabled (fe n ! (length (fe n) - 1)) msg \\<or>\n    (\\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg)", "by auto"], ["proof (state)\nthis:\n  enabled (fe n ! (length (fe n) - 1)) msg \\<or>\n  (\\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg)\n\ngoal (1 subgoal):\n 1. \\<And>n n0 p msg.\n       \\<lbrakk>\\<forall>n.\n                   initReachable (last (fe n)) \\<and>\n                   \\<not> vUniform False (last (fe n)) \\<and>\n                   \\<not> vUniform True (last (fe n)) \\<and>\n                   prefixList (fe n) (fe (Suc n)) \\<and>\n                   prefixList (ft n) (ft (Suc n)) \\<and>\n                   Suc 0 \\<le> length (fe n) \\<and>\n                   length (fe n) - Suc 0 = length (ft n) \\<and>\n                   initial (hd (fe n)) \\<and>\n                   (\\<forall>i<length (fe n) - Suc 0.\n                       fe n !\n                       i \\<turnstile> ft n !\ni \\<mapsto> fe n ! Suc i) \\<and>\n                   initial (hd (fe (Suc n)));\n        n0 < length (fe n); enabled (fe n ! n0) msg; isReceiverOf p msg;\n        correctInfinite fe ft p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                            \\<exists>n0'\\<ge>n0.\n                               n0' < length (ft n') \\<and> msg = ft n' ! n0'", "have EnabledOrConsumedAtLast: \"enabled (last (fe n)) msg \\<or> \n      (\\<exists> n0' . n0' \\<ge> n0 \\<and> n0' < length (ft n) \\<and> (ft n) ! n0' = msg )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (last (fe n)) msg \\<or>\n    (\\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg)", "using EnabledOrConsumed last_conv_nth AssumptionFair(2)"], ["proof (prove)\nusing this:\n  enabled (fe n ! (length (fe n) - 1)) msg \\<or>\n  (\\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg)\n  ?xs \\<noteq> [] \\<Longrightarrow> last ?xs = ?xs ! (length ?xs - 1)\n  n0 < length (fe n)\n\ngoal (1 subgoal):\n 1. enabled (last (fe n)) msg \\<or>\n    (\\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg)", "by (metis length_0_conv less_nat_zero_code)"], ["proof (state)\nthis:\n  enabled (last (fe n)) msg \\<or>\n  (\\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg)\n\ngoal (1 subgoal):\n 1. \\<And>n n0 p msg.\n       \\<lbrakk>\\<forall>n.\n                   initReachable (last (fe n)) \\<and>\n                   \\<not> vUniform False (last (fe n)) \\<and>\n                   \\<not> vUniform True (last (fe n)) \\<and>\n                   prefixList (fe n) (fe (Suc n)) \\<and>\n                   prefixList (ft n) (ft (Suc n)) \\<and>\n                   Suc 0 \\<le> length (fe n) \\<and>\n                   length (fe n) - Suc 0 = length (ft n) \\<and>\n                   initial (hd (fe n)) \\<and>\n                   (\\<forall>i<length (fe n) - Suc 0.\n                       fe n !\n                       i \\<turnstile> ft n !\ni \\<mapsto> fe n ! Suc i) \\<and>\n                   initial (hd (fe (Suc n)));\n        n0 < length (fe n); enabled (fe n ! n0) msg; isReceiverOf p msg;\n        correctInfinite fe ft p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                            \\<exists>n0'\\<ge>n0.\n                               n0' < length (ft n') \\<and> msg = ft n' ! n0'", "have Case2ImplThesis: \"(\\<exists> n0' . n0' \\<ge> n0 \\<and> n0' < length (ft n) \n      \\<and> ft n ! n0' = msg) \n      \\<Longrightarrow> (\\<exists>n'\\<ge>n. \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n0'\\<ge>n0.\n       n0' < length (ft n) \\<and> ft n ! n0' = msg \\<Longrightarrow>\n    \\<exists>n'\\<ge>n.\n       \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0'", "by auto"], ["proof (state)\nthis:\n  \\<exists>n0'\\<ge>n0.\n     n0' < length (ft n) \\<and> ft n ! n0' = msg \\<Longrightarrow>\n  \\<exists>n'\\<ge>n.\n     \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0'\n\ngoal (1 subgoal):\n 1. \\<And>n n0 p msg.\n       \\<lbrakk>\\<forall>n.\n                   initReachable (last (fe n)) \\<and>\n                   \\<not> vUniform False (last (fe n)) \\<and>\n                   \\<not> vUniform True (last (fe n)) \\<and>\n                   prefixList (fe n) (fe (Suc n)) \\<and>\n                   prefixList (ft n) (ft (Suc n)) \\<and>\n                   Suc 0 \\<le> length (fe n) \\<and>\n                   length (fe n) - Suc 0 = length (ft n) \\<and>\n                   initial (hd (fe n)) \\<and>\n                   (\\<forall>i<length (fe n) - Suc 0.\n                       fe n !\n                       i \\<turnstile> ft n !\ni \\<mapsto> fe n ! Suc i) \\<and>\n                   initial (hd (fe (Suc n)));\n        n0 < length (fe n); enabled (fe n ! n0) msg; isReceiverOf p msg;\n        correctInfinite fe ft p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                            \\<exists>n0'\\<ge>n0.\n                               n0' < length (ft n') \\<and> msg = ft n' ! n0'", "have Case1ImplThesis': \"enabled (last (fe n)) msg \n      \\<longrightarrow> (\\<exists>n'\\<ge>n. \\<exists>n0'\\<ge> (length (ft n)). n0' < length (ft n') \n          \\<and> msg = ft n' ! n0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (last (fe n)) msg \\<longrightarrow>\n    (\\<exists>n'\\<ge>n.\n        \\<exists>n0'\\<ge>length (ft n).\n           n0' < length (ft n') \\<and> msg = ft n' ! n0')", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. enabled (last (fe n)) msg \\<Longrightarrow>\n    \\<exists>n'\\<ge>n.\n       \\<exists>n0'\\<ge>length (ft n).\n          n0' < length (ft n') \\<and> msg = ft n' ! n0'", "assume AssumptionCase1ImplThesis': \"enabled (last (fe n)) msg\""], ["proof (state)\nthis:\n  enabled (last (fe n)) msg\n\ngoal (1 subgoal):\n 1. enabled (last (fe n)) msg \\<Longrightarrow>\n    \\<exists>n'\\<ge>n.\n       \\<exists>n0'\\<ge>length (ft n).\n          n0' < length (ft n') \\<and> msg = ft n' ! n0'", "show \"\\<exists>n'\\<ge>n. \\<exists>n0'\\<ge>length (ft n). n0' < length (ft n') \n        \\<and> msg = ft n' ! n0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'\\<ge>n.\n       \\<exists>n0'\\<ge>length (ft n).\n          n0' < length (ft n') \\<and> msg = ft n' ! n0'", "proof(rule ccontr,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "assume AssumptionFairContr: \"\\<forall>n'\\<ge>n. \\<forall>n0'<length (ft n'). \n          length (ft n) \\<le> n0' \\<longrightarrow> msg \\<noteq> ft n' ! n0'\""], ["proof (state)\nthis:\n  \\<forall>n'\\<ge>n.\n     \\<forall>n0'<length (ft n').\n        length (ft n) \\<le> n0' \\<longrightarrow> msg \\<noteq> ft n' ! n0'\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "define firstOccSet where \"firstOccSet n = { msg1 . \\<exists> nMsg . \n          \\<exists> n1 \\<le> nMsg . \n          execution.firstOccurrence (fe n) (ft n) msg1 n1 \n          \\<and> execution.firstOccurrence (fe n) (ft n) msg nMsg }\" for n"], ["proof (state)\nthis:\n  firstOccSet ?n =\n  {msg1.\n   \\<exists>nMsg n1.\n      n1 \\<le> nMsg \\<and>\n      execution.firstOccurrence (fe ?n) (ft ?n) msg1 n1 \\<and>\n      execution.firstOccurrence (fe ?n) (ft ?n) msg nMsg}\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "have NotEmpty: \"fe n \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe n \\<noteq> []", "using  AssumptionFair(2)"], ["proof (prove)\nusing this:\n  n0 < length (fe n)\n\ngoal (1 subgoal):\n 1. fe n \\<noteq> []", "by (metis less_nat_zero_code list.size(3))"], ["proof (state)\nthis:\n  fe n \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "have FirstToLast': \n          \"\\<forall> n . reachable ((fe n) ! 0) ((fe n) ! (length (fe n) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. reachable (fe n ! 0) (fe n ! (length (fe n) - 1))", "using execution.ReachableInExecution BasicProperties execution.notEmpty"], ["proof (prove)\nusing this:\n  \\<lbrakk>execution ?trans ?sends ?start ?exec ?trace; ?i < length ?exec;\n   ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> asynchronousSystem.reachable ?trans ?sends (?exec ! ?j)\n                     (?exec ! ?i)\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n  execution ?trans ?sends ?start ?exec ?trace \\<Longrightarrow>\n  1 \\<le> length ?exec\n\ngoal (1 subgoal):\n 1. \\<forall>n. reachable (fe n ! 0) (fe n ! (length (fe n) - 1))", "by (metis diff_less less_or_eq_imp_le not_gr0 not_one_le_zero)"], ["proof (state)\nthis:\n  \\<forall>n. reachable (fe n ! 0) (fe n ! (length (fe n) - 1))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence FirstToLast: \"\\<forall> n . reachable (hd (fe n)) (last (fe n))\""], ["proof (prove)\nusing this:\n  \\<forall>n. reachable (fe n ! 0) (fe n ! (length (fe n) - 1))\n\ngoal (1 subgoal):\n 1. \\<forall>n. reachable (hd (fe n)) (last (fe n))", "using NotEmpty hd_conv_nth last_conv_nth AssumptionFair(1)"], ["proof (prove)\nusing this:\n  \\<forall>n. reachable (fe n ! 0) (fe n ! (length (fe n) - 1))\n  fe n \\<noteq> []\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs = ?xs ! 0\n  ?xs \\<noteq> [] \\<Longrightarrow> last ?xs = ?xs ! (length ?xs - 1)\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<forall>n. reachable (hd (fe n)) (last (fe n))", "by (metis (full_types) One_nat_def length_0_conv \n            not_one_le_zero)"], ["proof (state)\nthis:\n  \\<forall>n. reachable (hd (fe n)) (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence InitToLast: \"\\<forall> n . initReachable (last (fe n))\""], ["proof (prove)\nusing this:\n  \\<forall>n. reachable (hd (fe n)) (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<forall>n. initReachable (last (fe n))", "using BasicProperties"], ["proof (prove)\nusing this:\n  \\<forall>n. reachable (hd (fe n)) (last (fe n))\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<forall>n. initReachable (last (fe n))", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. initReachable (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "have \"\\<And> msg n0 . \\<forall> n . \n          (execution.firstOccurrence (fe n) (ft n) msg n0) \n          \\<longrightarrow>  0 < msgs (last (fe n)) msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>msg n0.\n       \\<forall>n.\n          execution.firstOccurrence (fe n) (ft n) msg n0 \\<longrightarrow>\n          msg \\<in># msgs (last (fe n))", "using BasicProperties execution.firstOccurrence_def \n            enabled_def"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n  execution ?trans ?sends ?start ?exec ?trace \\<Longrightarrow>\n  execution.firstOccurrence ?exec ?trace ?msg ?n \\<equiv>\n  (\\<exists>p. isReceiverOf p ?msg) \\<and>\n  enabled (last ?exec) ?msg \\<and>\n  ?n < length ?exec \\<and>\n  enabled (?exec ! ?n) ?msg \\<and>\n  (\\<forall>n'\\<ge>?n.\n      n' < length ?trace \\<longrightarrow> ?msg \\<noteq> ?trace ! n') \\<and>\n  (?n \\<noteq> 0 \\<longrightarrow>\n   \\<not> enabled (?exec ! (?n - 1)) ?msg \\<or> ?msg = ?trace ! (?n - 1))\n  enabled ?cfg ?msg \\<equiv> ?msg \\<in># msgs ?cfg\n\ngoal (1 subgoal):\n 1. \\<And>msg n0.\n       \\<forall>n.\n          execution.firstOccurrence (fe n) (ft n) msg n0 \\<longrightarrow>\n          msg \\<in># msgs (last (fe n))", "by metis"], ["proof (state)\nthis:\n  \\<forall>n.\n     execution.firstOccurrence (fe n) (ft n) ?msg ?n0.0 \\<longrightarrow>\n     ?msg \\<in># msgs (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence \"\\<forall> n . \\<forall> msg' \\<in> (firstOccSet n) . \n          0 < msgs (last (fe n)) msg'\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     execution.firstOccurrence (fe n) (ft n) ?msg ?n0.0 \\<longrightarrow>\n     ?msg \\<in># msgs (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<forall>msg'\\<in>firstOccSet n. msg' \\<in># msgs (last (fe n))", "using firstOccSet_def"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     execution.firstOccurrence (fe n) (ft n) ?msg ?n0.0 \\<longrightarrow>\n     ?msg \\<in># msgs (last (fe n))\n  firstOccSet ?n =\n  {msg1.\n   \\<exists>nMsg n1.\n      n1 \\<le> nMsg \\<and>\n      execution.firstOccurrence (fe ?n) (ft ?n) msg1 n1 \\<and>\n      execution.firstOccurrence (fe ?n) (ft ?n) msg nMsg}\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<forall>msg'\\<in>firstOccSet n. msg' \\<in># msgs (last (fe n))", "by blast"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<forall>msg'\\<in>firstOccSet n. msg' \\<in># msgs (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence \"\\<forall> n . firstOccSet n \\<subseteq> {msg. 0 < msgs (last (fe n)) msg}\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     \\<forall>msg'\\<in>firstOccSet n. msg' \\<in># msgs (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       firstOccSet n \\<subseteq> {msg. msg \\<in># msgs (last (fe n))}", "by (metis (lifting, full_types) mem_Collect_eq subsetI)"], ["proof (state)\nthis:\n  \\<forall>n. firstOccSet n \\<subseteq> {msg. msg \\<in># msgs (last (fe n))}\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence FiniteMsgs: \"\\<forall> n . finite (firstOccSet n)\""], ["proof (prove)\nusing this:\n  \\<forall>n. firstOccSet n \\<subseteq> {msg. msg \\<in># msgs (last (fe n))}\n\ngoal (1 subgoal):\n 1. \\<forall>n. finite (firstOccSet n)", "using FiniteMessages[OF finiteProcs finiteSends] InitToLast"], ["proof (prove)\nusing this:\n  \\<forall>n. firstOccSet n \\<subseteq> {msg. msg \\<in># msgs (last (fe n))}\n  initReachable ?cfg \\<Longrightarrow> finite {msg. msg \\<in># msgs ?cfg}\n  \\<forall>n. initReachable (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<forall>n. finite (firstOccSet n)", "by (metis rev_finite_subset)"], ["proof (state)\nthis:\n  \\<forall>n. finite (firstOccSet n)\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "have FirstOccSetDecrOrConsumed: \"\\<forall> index . \n          (enabled (last (fe index)) msg) \n          \\<longrightarrow> (firstOccSet (Suc index) \\<subset> firstOccSet index \n          \\<and> (enabled (last (fe (Suc index))) msg)\n            \\<or> msg \\<in> (set (drop (length (ft index)) (ft (Suc index)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>index.\n       enabled (last (fe index)) msg \\<longrightarrow>\n       firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n       enabled (last (fe (Suc index))) msg \\<or>\n       msg \\<in> set (drop (length (ft index)) (ft (Suc index)))", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "fix index"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "assume AssumptionFirstOccSetDecrOrConsumed:\n            \"enabled (last (fe index)) msg\" \n            \"msg \\<notin> set (drop (length (ft index)) (ft (Suc index)))\""], ["proof (state)\nthis:\n  enabled (last (fe index)) msg\n  msg \\<notin> set (drop (length (ft index)) (ft (Suc index)))\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have NotEmpty: \"fe (Suc index) \\<noteq> []\" \"fe index \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe (Suc index) \\<noteq> [] &&& fe index \\<noteq> []", "using BasicProperties"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. fe (Suc index) \\<noteq> [] &&& fe index \\<noteq> []", "by (metis AssumptionFair(1) One_nat_def list.size(3) \n              not_one_le_zero)+"], ["proof (state)\nthis:\n  fe (Suc index) \\<noteq> []\n  fe index \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have LengthStep: \"length (ft (Suc index)) > length (ft index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ft index) < length (ft (Suc index))", "using AssumptionFair(1)"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n\ngoal (1 subgoal):\n 1. length (ft index) < length (ft (Suc index))", "by (metis PrefixListMonotonicity)"], ["proof (state)\nthis:\n  length (ft index) < length (ft (Suc index))\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have IPrefixList:\n            \"\\<forall> i::nat . prefixList (ft i) (ft (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. prefixList (ft i) (ft (Suc i))", "using AssumptionFair(1)"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<forall>i. prefixList (ft i) (ft (Suc i))", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. prefixList (ft i) (ft (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have IPrefixListEx:\n            \"\\<forall> i::nat . prefixList (fe i) (fe (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. prefixList (fe i) (fe (Suc i))", "using AssumptionFair(1)"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n\ngoal (1 subgoal):\n 1. \\<forall>i. prefixList (fe i) (fe (Suc i))", "by auto"], ["proof (state)\nthis:\n  \\<forall>i. prefixList (fe i) (fe (Suc i))\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have LastOfIndex:\n            \"(fe (Suc index) ! (length (fe index) - Suc 0)) \n            = (last (fe index))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe (Suc index) ! (length (fe index) - Suc 0) = last (fe index)", "using PrefixSameOnLow[of \"fe index\" \"fe (Suc index)\"]\n              IPrefixListEx[rule_format, of index]\n              NotEmpty LengthStep"], ["proof (prove)\nusing this:\n  prefixList (fe index) (fe (Suc index)) \\<Longrightarrow>\n  \\<forall>indexa<length (fe index).\n     fe index ! indexa = fe (Suc index) ! indexa\n  prefixList (fe index) (fe (Suc index))\n  fe (Suc index) \\<noteq> []\n  fe index \\<noteq> []\n  length (ft index) < length (ft (Suc index))\n\ngoal (1 subgoal):\n 1. fe (Suc index) ! (length (fe index) - Suc 0) = last (fe index)", "by (auto simp add: last_conv_nth)"], ["proof (state)\nthis:\n  fe (Suc index) ! (length (fe index) - Suc 0) = last (fe index)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have NotConsumedIntermediate: \n            \"\\<forall> i::nat < length (ft (Suc index)) . \n              (i \\<ge> length (ft index)\n              \\<longrightarrow> ft (Suc index) ! i \\<noteq> msg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (ft (Suc index)).\n       length (ft index) \\<le> i \\<longrightarrow>\n       ft (Suc index) ! i \\<noteq> msg", "using AssumptionFirstOccSetDecrOrConsumed(2) ListLenDrop"], ["proof (prove)\nusing this:\n  msg \\<notin> set (drop (length (ft index)) (ft (Suc index)))\n  \\<lbrakk>?i < length ?lb; ?la \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> ?lb ! ?i \\<in> set (drop ?la ?lb)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (ft (Suc index)).\n       length (ft index) \\<le> i \\<longrightarrow>\n       ft (Suc index) ! i \\<noteq> msg", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length (ft (Suc index)).\n     length (ft index) \\<le> i \\<longrightarrow>\n     ft (Suc index) ! i \\<noteq> msg\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "hence \n            \"\\<not>(\\<exists>i. i < length (ft (Suc index)) \\<and> i \\<ge> length (ft index)\n            \\<and> msg = (ft (Suc index)) ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (ft (Suc index)).\n     length (ft index) \\<le> i \\<longrightarrow>\n     ft (Suc index) ! i \\<noteq> msg\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (ft (Suc index)).\n               length (ft index) \\<le> i \\<and> msg = ft (Suc index) ! i)", "using execution.length BasicProperties"], ["proof (prove)\nusing this:\n  \\<forall>i<length (ft (Suc index)).\n     length (ft index) \\<le> i \\<longrightarrow>\n     ft (Suc index) ! i \\<noteq> msg\n  execution ?trans ?sends ?start ?exec ?trace \\<Longrightarrow>\n  length ?exec - 1 = length ?trace\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (ft (Suc index)).\n               length (ft index) \\<le> i \\<and> msg = ft (Suc index) ! i)", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i<length (ft (Suc index)).\n             length (ft index) \\<le> i \\<and> msg = ft (Suc index) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "hence \"\\<not>(\\<exists>i. i < length (fe (Suc index)) - 1 \n            \\<and> i \\<ge> length (fe index) - 1 \n            \\<and> msg = (ft (Suc index)) ! i)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i<length (ft (Suc index)).\n             length (ft index) \\<le> i \\<and> msg = ft (Suc index) ! i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (fe (Suc index)) - 1.\n               length (fe index) - 1 \\<le> i \\<and>\n               msg = ft (Suc index) ! i)", "using BasicProperties[rule_format, of \"Suc index\"]\n              BasicProperties[rule_format, of \"index\"]\n              execution.length[of trans sends start]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i<length (ft (Suc index)).\n             length (ft index) \\<le> i \\<and> msg = ft (Suc index) ! i)\n  nonUniform (last (fe (Suc index))) \\<and>\n  prefixList (fe (Suc index)) (fe (Suc index + 1)) \\<and>\n  prefixList (ft (Suc index)) (ft (Suc index + 1)) \\<and>\n  execution trans sends start (fe (Suc index)) (ft (Suc index)) \\<and>\n  initial (hd (fe (Suc index + 1)))\n  nonUniform (last (fe index)) \\<and>\n  prefixList (fe index) (fe (index + 1)) \\<and>\n  prefixList (ft index) (ft (index + 1)) \\<and>\n  execution trans sends start (fe index) (ft index) \\<and>\n  initial (hd (fe (index + 1)))\n  execution trans sends start ?exec ?trace \\<Longrightarrow>\n  length ?exec - 1 = length ?trace\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i<length (fe (Suc index)) - 1.\n               length (fe index) - 1 \\<le> i \\<and>\n               msg = ft (Suc index) ! i)", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i<length (fe (Suc index)) - 1.\n             length (fe index) - 1 \\<le> i \\<and> msg = ft (Suc index) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "hence EnabledIntermediate: \n            \"\\<forall> i < length (fe (Suc index)) . (i \\<ge> length (fe index) - 1\n              \\<longrightarrow> enabled (fe (Suc index) ! i) msg)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i<length (fe (Suc index)) - 1.\n             length (fe index) - 1 \\<le> i \\<and> msg = ft (Suc index) ! i)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fe (Suc index)).\n       length (fe index) - 1 \\<le> i \\<longrightarrow>\n       enabled (fe (Suc index) ! i) msg", "using BasicProperties[rule_format, of \"Suc index\"]\n              BasicProperties[rule_format, of \"index\"]\n              execution.StaysEnabled[of trans sends start\n              \"fe (Suc index)\" \"ft (Suc index)\" \"last (fe index)\" msg \n              \"length (fe index) - 1 \"]\n              AssumptionFirstOccSetDecrOrConsumed(1)"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i<length (fe (Suc index)) - 1.\n             length (fe index) - 1 \\<le> i \\<and> msg = ft (Suc index) ! i)\n  nonUniform (last (fe (Suc index))) \\<and>\n  prefixList (fe (Suc index)) (fe (Suc index + 1)) \\<and>\n  prefixList (ft (Suc index)) (ft (Suc index + 1)) \\<and>\n  execution trans sends start (fe (Suc index)) (ft (Suc index)) \\<and>\n  initial (hd (fe (Suc index + 1)))\n  nonUniform (last (fe index)) \\<and>\n  prefixList (fe index) (fe (index + 1)) \\<and>\n  prefixList (ft index) (ft (index + 1)) \\<and>\n  execution trans sends start (fe index) (ft index) \\<and>\n  initial (hd (fe (index + 1)))\n  \\<lbrakk>execution trans sends start (fe (Suc index)) (ft (Suc index));\n   enabled (last (fe index)) msg;\n   last (fe index) = fe (Suc index) ! (length (fe index) - 1);\n   length (fe index) - 1 < length (fe (Suc index))\\<rbrakk>\n  \\<Longrightarrow> enabled (last (fe (Suc index))) msg \\<or>\n                    (\\<exists>i\\<ge>length (fe index) - 1.\n                        i < length (fe (Suc index)) - 1 \\<and>\n                        msg = ft (Suc index) ! i)\n  enabled (last (fe index)) msg\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fe (Suc index)).\n       length (fe index) - 1 \\<le> i \\<longrightarrow>\n       enabled (fe (Suc index) ! i) msg", "by (auto, metis AssumptionFair(1) LastOfIndex \n              MessageStaysOrConsumed)"], ["proof (state)\nthis:\n  \\<forall>i<length (fe (Suc index)).\n     length (fe index) - 1 \\<le> i \\<longrightarrow>\n     enabled (fe (Suc index) ! i) msg\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have \"length (fe (Suc index)) - 1 \\<ge> length (fe index) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fe index) - 1 \\<le> length (fe (Suc index)) - 1", "using PrefixListMonotonicity NotEmpty BasicProperties"], ["proof (prove)\nusing this:\n  prefixList ?l1.0 ?l2.0 \\<Longrightarrow> length ?l1.0 < length ?l2.0\n  fe (Suc index) \\<noteq> []\n  fe index \\<noteq> []\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. length (fe index) - 1 \\<le> length (fe (Suc index)) - 1", "by (metis AssumptionFair(1) diff_le_mono less_imp_le)"], ["proof (state)\nthis:\n  length (fe index) - 1 \\<le> length (fe (Suc index)) - 1\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "hence \"enabled (fe (Suc index) \n            ! (length (fe (Suc index)) - 1)) msg\""], ["proof (prove)\nusing this:\n  length (fe index) - 1 \\<le> length (fe (Suc index)) - 1\n\ngoal (1 subgoal):\n 1. enabled (fe (Suc index) ! (length (fe (Suc index)) - 1)) msg", "using EnabledIntermediate NotEmpty(1)"], ["proof (prove)\nusing this:\n  length (fe index) - 1 \\<le> length (fe (Suc index)) - 1\n  \\<forall>i<length (fe (Suc index)).\n     length (fe index) - 1 \\<le> i \\<longrightarrow>\n     enabled (fe (Suc index) ! i) msg\n  fe (Suc index) \\<noteq> []\n\ngoal (1 subgoal):\n 1. enabled (fe (Suc index) ! (length (fe (Suc index)) - 1)) msg", "by (metis diff_less length_greater_0_conv zero_less_one)"], ["proof (state)\nthis:\n  enabled (fe (Suc index) ! (length (fe (Suc index)) - 1)) msg\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "hence EnabledInSuc: \"enabled (last (fe (Suc index))) msg\""], ["proof (prove)\nusing this:\n  enabled (fe (Suc index) ! (length (fe (Suc index)) - 1)) msg\n\ngoal (1 subgoal):\n 1. enabled (last (fe (Suc index))) msg", "using NotEmpty last_conv_nth[of \"fe (Suc index)\"]"], ["proof (prove)\nusing this:\n  enabled (fe (Suc index) ! (length (fe (Suc index)) - 1)) msg\n  fe (Suc index) \\<noteq> []\n  fe index \\<noteq> []\n  fe (Suc index) \\<noteq> [] \\<Longrightarrow>\n  last (fe (Suc index)) = fe (Suc index) ! (length (fe (Suc index)) - 1)\n\ngoal (1 subgoal):\n 1. enabled (last (fe (Suc index))) msg", "by simp"], ["proof (state)\nthis:\n  enabled (last (fe (Suc index))) msg\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have IndexIsExec: \n            \"execution trans sends start (fe index) (ft index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution trans sends start (fe index) (ft index)", "using BasicProperties"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. execution trans sends start (fe index) (ft index)", "by blast"], ["proof (state)\nthis:\n  execution trans sends start (fe index) (ft index)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have SucIndexIsExec: \n            \"execution trans sends start (fe (Suc index)) \n              (ft (Suc index))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution trans sends start (fe (Suc index)) (ft (Suc index))", "using BasicProperties"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. execution trans sends start (fe (Suc index)) (ft (Suc index))", "by blast"], ["proof (state)\nthis:\n  execution trans sends start (fe (Suc index)) (ft (Suc index))\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have SameCfgOnLow: \"\\<forall> i < length (fe index) . (fe index) ! i\n            = (fe (Suc index)) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (fe index). fe index ! i = fe (Suc index) ! i", "using BasicProperties PrefixSameOnLow"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n  prefixList ?l1.0 ?l2.0 \\<Longrightarrow>\n  \\<forall>index<length ?l1.0. ?l1.0 ! index = ?l2.0 ! index\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (fe index). fe index ! i = fe (Suc index) ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length (fe index). fe index ! i = fe (Suc index) ! i\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have SameMsgOnLow: \"\\<forall> i < length (ft index) . (ft index) ! i\n            = (ft (Suc index)) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (ft index). ft index ! i = ft (Suc index) ! i", "using BasicProperties PrefixSameOnLow"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n  prefixList ?l1.0 ?l2.0 \\<Longrightarrow>\n  \\<forall>index<length ?l1.0. ?l1.0 ! index = ?l2.0 ! index\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (ft index). ft index ! i = ft (Suc index) ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length (ft index). ft index ! i = ft (Suc index) ! i\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have SmallIndex: \"\\<And> nMsg . execution.firstOccurrence\n            (fe (Suc index)) (ft (Suc index)) msg nMsg \n            \\<Longrightarrow> nMsg < length (fe index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nMsg.\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n        nMsg \\<Longrightarrow>\n       nMsg < length (fe index)", "proof(-)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nMsg.\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n        nMsg \\<Longrightarrow>\n       nMsg < length (fe index)", "fix nMsg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nMsg.\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n        nMsg \\<Longrightarrow>\n       nMsg < length (fe index)", "assume \"execution.firstOccurrence (fe (Suc index)) \n              (ft (Suc index)) msg nMsg\""], ["proof (state)\nthis:\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n\ngoal (1 subgoal):\n 1. \\<And>nMsg.\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n        nMsg \\<Longrightarrow>\n       nMsg < length (fe index)", "hence AssumptionSubset3: \n              \"\\<exists>p. isReceiverOf p msg\"\n                \"enabled (last (fe (Suc index))) msg\"\n                \"nMsg < length (fe (Suc index))\"\n                \"enabled (fe (Suc index) ! nMsg) msg\"\n                \"\\<forall>n'\\<ge>nMsg. n' < length (ft (Suc index)) \n                \\<longrightarrow> msg \\<noteq> ft (Suc index) ! n'\"\n                \"nMsg \\<noteq> 0 \\<longrightarrow> \\<not> enabled (fe (Suc index) ! (nMsg - 1)) \n                msg \\<or> msg = ft (Suc index) ! (nMsg - 1)\""], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg &&&\n     enabled (last (fe (Suc index))) msg &&&\n     nMsg < length (fe (Suc index))) &&&\n    enabled (fe (Suc index) ! nMsg) msg &&&\n    \\<forall>n'\\<ge>nMsg.\n       n' < length (ft (Suc index)) \\<longrightarrow>\n       msg \\<noteq> ft (Suc index) ! n' &&&\n    nMsg \\<noteq> 0 \\<longrightarrow>\n    \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n    msg = ft (Suc index) ! (nMsg - 1)", "using execution.firstOccurrence_def[of \"trans\" \"sends\" \n                \"start\" \"fe (Suc index)\" \"ft (Suc index)\" \"msg\" \"nMsg\"]\n                SucIndexIsExec"], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n  execution trans sends start (fe (Suc index))\n   (ft (Suc index)) \\<Longrightarrow>\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   nMsg \\<equiv>\n  (\\<exists>p. isReceiverOf p msg) \\<and>\n  enabled (last (fe (Suc index))) msg \\<and>\n  nMsg < length (fe (Suc index)) \\<and>\n  enabled (fe (Suc index) ! nMsg) msg \\<and>\n  (\\<forall>n'\\<ge>nMsg.\n      n' < length (ft (Suc index)) \\<longrightarrow>\n      msg \\<noteq> ft (Suc index) ! n') \\<and>\n  (nMsg \\<noteq> 0 \\<longrightarrow>\n   \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n   msg = ft (Suc index) ! (nMsg - 1))\n  execution trans sends start (fe (Suc index)) (ft (Suc index))\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg &&&\n     enabled (last (fe (Suc index))) msg &&&\n     nMsg < length (fe (Suc index))) &&&\n    enabled (fe (Suc index) ! nMsg) msg &&&\n    \\<forall>n'\\<ge>nMsg.\n       n' < length (ft (Suc index)) \\<longrightarrow>\n       msg \\<noteq> ft (Suc index) ! n' &&&\n    nMsg \\<noteq> 0 \\<longrightarrow>\n    \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n    msg = ft (Suc index) ! (nMsg - 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. isReceiverOf p msg\n  enabled (last (fe (Suc index))) msg\n  nMsg < length (fe (Suc index))\n  enabled (fe (Suc index) ! nMsg) msg\n  \\<forall>n'\\<ge>nMsg.\n     n' < length (ft (Suc index)) \\<longrightarrow>\n     msg \\<noteq> ft (Suc index) ! n'\n  nMsg \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<And>nMsg.\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n        nMsg \\<Longrightarrow>\n       nMsg < length (fe index)", "show \"nMsg < length (fe index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nMsg < length (fe index)", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "assume AssumpSmallIndex: \"\\<not> nMsg < length (fe index)\""], ["proof (state)\nthis:\n  \\<not> nMsg < length (fe index)\n\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "have \"fe index \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe index \\<noteq> []", "using BasicProperties \n                AssumptionFair(1)"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n\ngoal (1 subgoal):\n 1. fe index \\<noteq> []", "by (metis One_nat_def list.size(3) not_one_le_zero)"], ["proof (state)\nthis:\n  fe index \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "hence \"length (fe index) > 0\""], ["proof (prove)\nusing this:\n  fe index \\<noteq> []\n\ngoal (1 subgoal):\n 1. fe index \\<in># length", "by (metis length_greater_0_conv)"], ["proof (state)\nthis:\n  fe index \\<in># length\n\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "hence nMsgNotZero: \"nMsg \\<noteq> 0\""], ["proof (prove)\nusing this:\n  fe index \\<in># length\n\ngoal (1 subgoal):\n 1. nMsg \\<noteq> 0", "using AssumpSmallIndex"], ["proof (prove)\nusing this:\n  fe index \\<in># length\n  \\<not> nMsg < length (fe index)\n\ngoal (1 subgoal):\n 1. nMsg \\<noteq> 0", "by metis"], ["proof (state)\nthis:\n  nMsg \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "hence SucCases: \"\\<not> enabled ((fe (Suc index)) ! (nMsg - 1))\n                msg \\<or> msg = (ft (Suc index)) ! (nMsg - 1)\""], ["proof (prove)\nusing this:\n  nMsg \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n    msg = ft (Suc index) ! (nMsg - 1)", "using AssumptionSubset3(6)"], ["proof (prove)\nusing this:\n  nMsg \\<noteq> 0\n  nMsg \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n    msg = ft (Suc index) ! (nMsg - 1)", "by blast"], ["proof (state)\nthis:\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "have Cond1: \"nMsg - 1 \\<ge> length (fe index) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fe index) - 1 \\<le> nMsg - 1", "using AssumpSmallIndex"], ["proof (prove)\nusing this:\n  \\<not> nMsg < length (fe index)\n\ngoal (1 subgoal):\n 1. length (fe index) - 1 \\<le> nMsg - 1", "by (metis diff_le_mono leI)"], ["proof (state)\nthis:\n  length (fe index) - 1 \\<le> nMsg - 1\n\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "hence Enabled: \"enabled (fe (Suc index) ! (nMsg - 1)) msg\""], ["proof (prove)\nusing this:\n  length (fe index) - 1 \\<le> nMsg - 1\n\ngoal (1 subgoal):\n 1. enabled (fe (Suc index) ! (nMsg - 1)) msg", "using EnabledIntermediate AssumptionSubset3(3)"], ["proof (prove)\nusing this:\n  length (fe index) - 1 \\<le> nMsg - 1\n  \\<forall>i<length (fe (Suc index)).\n     length (fe index) - 1 \\<le> i \\<longrightarrow>\n     enabled (fe (Suc index) ! i) msg\n  nMsg < length (fe (Suc index))\n\ngoal (1 subgoal):\n 1. enabled (fe (Suc index) ! (nMsg - 1)) msg", "by (metis less_imp_diff_less)"], ["proof (state)\nthis:\n  enabled (fe (Suc index) ! (nMsg - 1)) msg\n\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "have Cond2: \"nMsg - 1 \\<ge> length (ft index) \\<and> nMsg - 1\n                < length (ft (Suc index))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ft index) \\<le> nMsg - 1 \\<and>\n    nMsg - 1 < length (ft (Suc index))", "using Cond1 execution.length[of \"trans\" \"sends\" \"start\"\n                  \"fe index\" \"ft index\"]\n                  IndexIsExec AssumptionSubset3(3)"], ["proof (prove)\nusing this:\n  length (fe index) - 1 \\<le> nMsg - 1\n  execution trans sends start (fe index) (ft index) \\<Longrightarrow>\n  length (fe index) - 1 = length (ft index)\n  execution trans sends start (fe index) (ft index)\n  nMsg < length (fe (Suc index))\n\ngoal (1 subgoal):\n 1. length (ft index) \\<le> nMsg - 1 \\<and>\n    nMsg - 1 < length (ft (Suc index))", "by (simp, metis AssumptionFair(1) One_nat_def Suc_diff_1 \n                    Suc_eq_plus1 less_diff_conv nMsgNotZero neq0_conv)"], ["proof (state)\nthis:\n  length (ft index) \\<le> nMsg - 1 \\<and> nMsg - 1 < length (ft (Suc index))\n\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "hence NotConsumed: \"ft (Suc index) ! (nMsg - 1) \\<noteq> msg\""], ["proof (prove)\nusing this:\n  length (ft index) \\<le> nMsg - 1 \\<and> nMsg - 1 < length (ft (Suc index))\n\ngoal (1 subgoal):\n 1. ft (Suc index) ! (nMsg - 1) \\<noteq> msg", "using NotConsumedIntermediate"], ["proof (prove)\nusing this:\n  length (ft index) \\<le> nMsg - 1 \\<and> nMsg - 1 < length (ft (Suc index))\n  \\<forall>i<length (ft (Suc index)).\n     length (ft index) \\<le> i \\<longrightarrow>\n     ft (Suc index) ! i \\<noteq> msg\n\ngoal (1 subgoal):\n 1. ft (Suc index) ! (nMsg - 1) \\<noteq> msg", "by simp"], ["proof (state)\nthis:\n  ft (Suc index) ! (nMsg - 1) \\<noteq> msg\n\ngoal (1 subgoal):\n 1. \\<not> nMsg < length (fe index) \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using SucCases Enabled NotConsumed"], ["proof (prove)\nusing this:\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n  enabled (fe (Suc index) ! (nMsg - 1)) msg\n  ft (Suc index) ! (nMsg - 1) \\<noteq> msg\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nMsg < length (fe index)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   ?nMsg \\<Longrightarrow>\n  ?nMsg < length (fe index)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have Subset: \"\\<And> msgInSet . msgInSet \\<in> firstOccSet (Suc index)\n            \\<Longrightarrow> msgInSet \\<in> firstOccSet index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>msgInSet.\n       msgInSet \\<in> firstOccSet (Suc index) \\<Longrightarrow>\n       msgInSet \\<in> firstOccSet index", "unfolding firstOccSet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>msgInSet.\n       msgInSet\n       \\<in> {msg1.\n              \\<exists>nMsg n1.\n                 n1 \\<le> nMsg \\<and>\n                 execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n                  msg1 n1 \\<and>\n                 execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n                  msg nMsg} \\<Longrightarrow>\n       msgInSet\n       \\<in> {msg1.\n              \\<exists>nMsg n1.\n                 n1 \\<le> nMsg \\<and>\n                 execution.firstOccurrence (fe index) (ft index) msg1\n                  n1 \\<and>\n                 execution.firstOccurrence (fe index) (ft index) msg nMsg}", "proof(auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msgInSet nMsg n1.\n       \\<lbrakk>n1 \\<le> nMsg;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet\n         n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nMsg n1.\n                            n1 \\<le> nMsg \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msgInSet n1 \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msg nMsg", "fix msgInSet nMsg n1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msgInSet nMsg n1.\n       \\<lbrakk>n1 \\<le> nMsg;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet\n         n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nMsg n1.\n                            n1 \\<le> nMsg \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msgInSet n1 \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msg nMsg", "assume AssumptionSubset: \"n1 \\<le> nMsg\"\n              \"execution.firstOccurrence (fe (Suc index)) \n                (ft (Suc index)) msgInSet n1\"\n              \"execution.firstOccurrence (fe (Suc index)) \n                (ft (Suc index)) msg nMsg\""], ["proof (state)\nthis:\n  n1 \\<le> nMsg\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet n1\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n\ngoal (1 subgoal):\n 1. \\<And>msgInSet nMsg n1.\n       \\<lbrakk>n1 \\<le> nMsg;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet\n         n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nMsg n1.\n                            n1 \\<le> nMsg \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msgInSet n1 \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msg nMsg", "have AssumptionSubset2: \n              \"\\<exists>p. isReceiverOf p msgInSet\"\n                \"enabled (last (fe (Suc index))) msgInSet\"\n                \"n1 < length (fe (Suc index))\"\n                \"enabled (fe (Suc index) ! n1) msgInSet\"\n                \"\\<forall>n'\\<ge>n1. n' < length (ft (Suc index)) \n                  \\<longrightarrow> msgInSet \\<noteq> ft (Suc index) ! n'\"\n                \"n1 \\<noteq> 0 \\<longrightarrow> \\<not> enabled (fe (Suc index) ! (n1 - 1)) \n                  msgInSet \\<or> msgInSet = ft (Suc index) ! (n1 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msgInSet &&&\n     enabled (last (fe (Suc index))) msgInSet &&&\n     n1 < length (fe (Suc index))) &&&\n    enabled (fe (Suc index) ! n1) msgInSet &&&\n    \\<forall>n'\\<ge>n1.\n       n' < length (ft (Suc index)) \\<longrightarrow>\n       msgInSet \\<noteq> ft (Suc index) ! n' &&&\n    n1 \\<noteq> 0 \\<longrightarrow>\n    \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n    msgInSet = ft (Suc index) ! (n1 - 1)", "using execution.firstOccurrence_def[of \"trans\" \"sends\" \n                \"start\" \"fe (Suc index)\" \"ft (Suc index)\" \"msgInSet\" \n                \"n1\"] AssumptionSubset(2) SucIndexIsExec"], ["proof (prove)\nusing this:\n  execution trans sends start (fe (Suc index))\n   (ft (Suc index)) \\<Longrightarrow>\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet\n   n1 \\<equiv>\n  (\\<exists>p. isReceiverOf p msgInSet) \\<and>\n  enabled (last (fe (Suc index))) msgInSet \\<and>\n  n1 < length (fe (Suc index)) \\<and>\n  enabled (fe (Suc index) ! n1) msgInSet \\<and>\n  (\\<forall>n'\\<ge>n1.\n      n' < length (ft (Suc index)) \\<longrightarrow>\n      msgInSet \\<noteq> ft (Suc index) ! n') \\<and>\n  (n1 \\<noteq> 0 \\<longrightarrow>\n   \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n   msgInSet = ft (Suc index) ! (n1 - 1))\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet n1\n  execution trans sends start (fe (Suc index)) (ft (Suc index))\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msgInSet &&&\n     enabled (last (fe (Suc index))) msgInSet &&&\n     n1 < length (fe (Suc index))) &&&\n    enabled (fe (Suc index) ! n1) msgInSet &&&\n    \\<forall>n'\\<ge>n1.\n       n' < length (ft (Suc index)) \\<longrightarrow>\n       msgInSet \\<noteq> ft (Suc index) ! n' &&&\n    n1 \\<noteq> 0 \\<longrightarrow>\n    \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n    msgInSet = ft (Suc index) ! (n1 - 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. isReceiverOf p msgInSet\n  enabled (last (fe (Suc index))) msgInSet\n  n1 < length (fe (Suc index))\n  enabled (fe (Suc index) ! n1) msgInSet\n  \\<forall>n'\\<ge>n1.\n     n' < length (ft (Suc index)) \\<longrightarrow>\n     msgInSet \\<noteq> ft (Suc index) ! n'\n  n1 \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft (Suc index) ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. \\<And>msgInSet nMsg n1.\n       \\<lbrakk>n1 \\<le> nMsg;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet\n         n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nMsg n1.\n                            n1 \\<le> nMsg \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msgInSet n1 \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msg nMsg", "have AssumptionSubset3: \n              \"\\<exists>p. isReceiverOf p msg\"\n                \"enabled (last (fe (Suc index))) msg\"\n                \"nMsg < length (fe (Suc index))\"\n                \"enabled (fe (Suc index) ! nMsg) msg\"\n                \"\\<forall>n'\\<ge>nMsg. n' < length (ft (Suc index)) \n                  \\<longrightarrow> msg \\<noteq> ft (Suc index) ! n'\"\n                \"nMsg \\<noteq> 0 \\<longrightarrow> \\<not> enabled (fe (Suc index) ! (nMsg - 1)) \n                  msg \\<or> msg = ft (Suc index) ! (nMsg - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg &&&\n     enabled (last (fe (Suc index))) msg &&&\n     nMsg < length (fe (Suc index))) &&&\n    enabled (fe (Suc index) ! nMsg) msg &&&\n    \\<forall>n'\\<ge>nMsg.\n       n' < length (ft (Suc index)) \\<longrightarrow>\n       msg \\<noteq> ft (Suc index) ! n' &&&\n    nMsg \\<noteq> 0 \\<longrightarrow>\n    \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n    msg = ft (Suc index) ! (nMsg - 1)", "using execution.firstOccurrence_def[of \"trans\" \"sends\" \n                \"start\" \"fe (Suc index)\" \"ft (Suc index)\" \"msg\" \"nMsg\"]\n                AssumptionSubset(3) SucIndexIsExec"], ["proof (prove)\nusing this:\n  execution trans sends start (fe (Suc index))\n   (ft (Suc index)) \\<Longrightarrow>\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   nMsg \\<equiv>\n  (\\<exists>p. isReceiverOf p msg) \\<and>\n  enabled (last (fe (Suc index))) msg \\<and>\n  nMsg < length (fe (Suc index)) \\<and>\n  enabled (fe (Suc index) ! nMsg) msg \\<and>\n  (\\<forall>n'\\<ge>nMsg.\n      n' < length (ft (Suc index)) \\<longrightarrow>\n      msg \\<noteq> ft (Suc index) ! n') \\<and>\n  (nMsg \\<noteq> 0 \\<longrightarrow>\n   \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n   msg = ft (Suc index) ! (nMsg - 1))\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n  execution trans sends start (fe (Suc index)) (ft (Suc index))\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg &&&\n     enabled (last (fe (Suc index))) msg &&&\n     nMsg < length (fe (Suc index))) &&&\n    enabled (fe (Suc index) ! nMsg) msg &&&\n    \\<forall>n'\\<ge>nMsg.\n       n' < length (ft (Suc index)) \\<longrightarrow>\n       msg \\<noteq> ft (Suc index) ! n' &&&\n    nMsg \\<noteq> 0 \\<longrightarrow>\n    \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n    msg = ft (Suc index) ! (nMsg - 1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. isReceiverOf p msg\n  enabled (last (fe (Suc index))) msg\n  nMsg < length (fe (Suc index))\n  enabled (fe (Suc index) ! nMsg) msg\n  \\<forall>n'\\<ge>nMsg.\n     n' < length (ft (Suc index)) \\<longrightarrow>\n     msg \\<noteq> ft (Suc index) ! n'\n  nMsg \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<And>msgInSet nMsg n1.\n       \\<lbrakk>n1 \\<le> nMsg;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet\n         n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nMsg n1.\n                            n1 \\<le> nMsg \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msgInSet n1 \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msg nMsg", "have ShorterTrace: \"length (ft index) \n                                < length (ft (Suc index))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ft index) < length (ft (Suc index))", "using PrefixListMonotonicity BasicProperties"], ["proof (prove)\nusing this:\n  prefixList ?l1.0 ?l2.0 \\<Longrightarrow> length ?l1.0 < length ?l2.0\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. length (ft index) < length (ft (Suc index))", "by auto"], ["proof (state)\nthis:\n  length (ft index) < length (ft (Suc index))\n\ngoal (1 subgoal):\n 1. \\<And>msgInSet nMsg n1.\n       \\<lbrakk>n1 \\<le> nMsg;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet\n         n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nMsg n1.\n                            n1 \\<le> nMsg \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msgInSet n1 \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msg nMsg", "have FirstOccurrenceMsg: \"execution.firstOccurrence \n              (fe index) (ft index) msg nMsg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "have Occ1: \"\\<exists> p . isReceiverOf p msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. isReceiverOf p msg", "using AssumptionSubset3(1)"], ["proof (prove)\nusing this:\n  \\<exists>p. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<exists>p. isReceiverOf p msg", "by blast"], ["proof (state)\nthis:\n  \\<exists>p. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "have Occ2: \"enabled (last (fe index)) msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (last (fe index)) msg", "using AssumptionFirstOccSetDecrOrConsumed"], ["proof (prove)\nusing this:\n  enabled (last (fe index)) msg\n  msg \\<notin> set (drop (length (ft index)) (ft (Suc index)))\n\ngoal (1 subgoal):\n 1. enabled (last (fe index)) msg", "by blast"], ["proof (state)\nthis:\n  enabled (last (fe index)) msg\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "have \"(fe index) ! nMsg = (fe (Suc index)) ! nMsg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe index ! nMsg = fe (Suc index) ! nMsg", "using SmallIndex AssumptionSubset(3) \n                  PrefixSameOnLow[of \"fe index\" \"fe (Suc index)\"] \n                  BasicProperties"], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   ?nMsg \\<Longrightarrow>\n  ?nMsg < length (fe index)\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n  prefixList (fe index) (fe (Suc index)) \\<Longrightarrow>\n  \\<forall>indexa<length (fe index).\n     fe index ! indexa = fe (Suc index) ! indexa\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. fe index ! nMsg = fe (Suc index) ! nMsg", "by simp"], ["proof (state)\nthis:\n  fe index ! nMsg = fe (Suc index) ! nMsg\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "hence Occ4: \"enabled ((fe index) ! nMsg) msg\""], ["proof (prove)\nusing this:\n  fe index ! nMsg = fe (Suc index) ! nMsg\n\ngoal (1 subgoal):\n 1. enabled (fe index ! nMsg) msg", "using AssumptionSubset3(4)"], ["proof (prove)\nusing this:\n  fe index ! nMsg = fe (Suc index) ! nMsg\n  enabled (fe (Suc index) ! nMsg) msg\n\ngoal (1 subgoal):\n 1. enabled (fe index ! nMsg) msg", "by simp"], ["proof (state)\nthis:\n  enabled (fe index ! nMsg) msg\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "have OccSameMsg: \"\\<forall> n' \\<ge> nMsg . n' < length (ft index) \n                \\<longrightarrow> (ft index) ! n' = (ft (Suc index)) ! n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>nMsg.\n       n' < length (ft index) \\<longrightarrow>\n       ft index ! n' = ft (Suc index) ! n'", "using PrefixSameOnLow BasicProperties"], ["proof (prove)\nusing this:\n  prefixList ?l1.0 ?l2.0 \\<Longrightarrow>\n  \\<forall>index<length ?l1.0. ?l1.0 ! index = ?l2.0 ! index\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>nMsg.\n       n' < length (ft index) \\<longrightarrow>\n       ft index ! n' = ft (Suc index) ! n'", "by auto"], ["proof (state)\nthis:\n  \\<forall>n'\\<ge>nMsg.\n     n' < length (ft index) \\<longrightarrow>\n     ft index ! n' = ft (Suc index) ! n'\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "hence Occ5: \"\\<forall> n' \\<ge> nMsg . n' < length (ft index) \n                \\<longrightarrow> msg \\<noteq> ((ft index) ! n')\""], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>nMsg.\n     n' < length (ft index) \\<longrightarrow>\n     ft index ! n' = ft (Suc index) ! n'\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>nMsg.\n       n' < length (ft index) \\<longrightarrow> msg \\<noteq> ft index ! n'", "using AssumptionSubset3(5) ShorterTrace"], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>nMsg.\n     n' < length (ft index) \\<longrightarrow>\n     ft index ! n' = ft (Suc index) ! n'\n  \\<forall>n'\\<ge>nMsg.\n     n' < length (ft (Suc index)) \\<longrightarrow>\n     msg \\<noteq> ft (Suc index) ! n'\n  length (ft index) < length (ft (Suc index))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>nMsg.\n       n' < length (ft index) \\<longrightarrow> msg \\<noteq> ft index ! n'", "by simp"], ["proof (state)\nthis:\n  \\<forall>n'\\<ge>nMsg.\n     n' < length (ft index) \\<longrightarrow> msg \\<noteq> ft index ! n'\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "have Occ6: \"nMsg \\<noteq> 0 \\<longrightarrow> (\\<not> enabled ((fe index) ! \n                (nMsg - 1)) msg \\<or> msg = (ft index ) ! (nMsg - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nMsg \\<noteq> 0 \\<longrightarrow>\n    \\<not> enabled (fe index ! (nMsg - 1)) msg \\<or>\n    msg = ft index ! (nMsg - 1)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "assume AssumpOcc6: \"0 < nMsg\" \"msg \\<noteq> ft index ! \n                  (nMsg - 1)\" \"enabled (fe index ! (nMsg - 1)) msg\""], ["proof (state)\nthis:\n  0 < nMsg\n  msg \\<noteq> ft index ! (nMsg - 1)\n  enabled (fe index ! (nMsg - 1)) msg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "have \"nMsg - (Suc 0) < length (fe index) - (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nMsg - Suc 0 < length (fe index) - Suc 0", "using SmallIndex AssumptionSubset(3) AssumpOcc6(1)"], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   ?nMsg \\<Longrightarrow>\n  ?nMsg < length (fe index)\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n  0 < nMsg\n\ngoal (1 subgoal):\n 1. nMsg - Suc 0 < length (fe index) - Suc 0", "by (metis Suc_le_eq diff_less_mono)"], ["proof (state)\nthis:\n  nMsg - Suc 0 < length (fe index) - Suc 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "hence SmallIndexTrace: \"nMsg - 1 < length (ft index)\""], ["proof (prove)\nusing this:\n  nMsg - Suc 0 < length (fe index) - Suc 0\n\ngoal (1 subgoal):\n 1. nMsg - 1 < length (ft index)", "using IndexIsExec execution.length"], ["proof (prove)\nusing this:\n  nMsg - Suc 0 < length (fe index) - Suc 0\n  execution trans sends start (fe index) (ft index)\n  execution ?trans ?sends ?start ?exec ?trace \\<Longrightarrow>\n  length ?exec - 1 = length ?trace\n\ngoal (1 subgoal):\n 1. nMsg - 1 < length (ft index)", "by (metis One_nat_def)"], ["proof (state)\nthis:\n  nMsg - 1 < length (ft index)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \n                  \\<or> msg = ft (Suc index) ! (nMsg - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n    msg = ft (Suc index) ! (nMsg - 1)", "using AssumptionSubset3(6) AssumpOcc6(1)"], ["proof (prove)\nusing this:\n  nMsg \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n  0 < nMsg\n\ngoal (1 subgoal):\n 1. \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n    msg = ft (Suc index) ! (nMsg - 1)", "by blast"], ["proof (state)\nthis:\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "have \"fe (Suc index) ! (nMsg - 1) \n                  = fe index ! (nMsg - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe (Suc index) ! (nMsg - 1) = fe index ! (nMsg - 1)", "using SameCfgOnLow SmallIndex AssumptionSubset(3)"], ["proof (prove)\nusing this:\n  \\<forall>i<length (fe index). fe index ! i = fe (Suc index) ! i\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   ?nMsg \\<Longrightarrow>\n  ?nMsg < length (fe index)\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n\ngoal (1 subgoal):\n 1. fe (Suc index) ! (nMsg - 1) = fe index ! (nMsg - 1)", "by (metis less_imp_diff_less)"], ["proof (state)\nthis:\n  fe (Suc index) ! (nMsg - 1) = fe index ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fe (Suc index) ! (nMsg - 1) = fe index ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "have \"ft (Suc index) ! (nMsg - 1) \n                  = ft index ! (nMsg - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ft (Suc index) ! (nMsg - 1) = ft index ! (nMsg - 1)", "using SameMsgOnLow SmallIndexTrace"], ["proof (prove)\nusing this:\n  \\<forall>i<length (ft index). ft index ! i = ft (Suc index) ! i\n  nMsg - 1 < length (ft index)\n\ngoal (1 subgoal):\n 1. ft (Suc index) ! (nMsg - 1) = ft index ! (nMsg - 1)", "by metis"], ["proof (state)\nthis:\n  ft (Suc index) ! (nMsg - 1) = ft index ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n  fe (Suc index) ! (nMsg - 1) = fe index ! (nMsg - 1)\n  ft (Suc index) ! (nMsg - 1) = ft index ! (nMsg - 1)", "have \"\\<not> enabled (fe index ! (nMsg - 1)) msg \n                  \\<or> msg = ft index ! (nMsg - 1)\""], ["proof (prove)\nusing this:\n  \\<not> enabled (fe (Suc index) ! (nMsg - 1)) msg \\<or>\n  msg = ft (Suc index) ! (nMsg - 1)\n  fe (Suc index) ! (nMsg - 1) = fe index ! (nMsg - 1)\n  ft (Suc index) ! (nMsg - 1) = ft index ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<not> enabled (fe index ! (nMsg - 1)) msg \\<or>\n    msg = ft index ! (nMsg - 1)", "by simp"], ["proof (state)\nthis:\n  \\<not> enabled (fe index ! (nMsg - 1)) msg \\<or>\n  msg = ft index ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < nMsg; msg \\<noteq> ft index ! (nMsg - 1);\n     enabled (fe index ! (nMsg - 1)) msg\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> enabled (fe index ! (nMsg - 1)) msg \\<or>\n  msg = ft index ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. False", "using AssumpOcc6"], ["proof (prove)\nusing this:\n  \\<not> enabled (fe index ! (nMsg - 1)) msg \\<or>\n  msg = ft index ! (nMsg - 1)\n  0 < nMsg\n  msg \\<noteq> ft index ! (nMsg - 1)\n  enabled (fe index ! (nMsg - 1)) msg\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nMsg \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe index ! (nMsg - 1)) msg \\<or>\n  msg = ft index ! (nMsg - 1)\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "using IndexIsExec Occ1 Occ2 SmallIndex \n                AssumptionSubset(3) Occ4 Occ5 Occ6\n                execution.firstOccurrence_def[of \"trans\" \"sends\" \"start\"\n                  \"fe index\" \"ft index\"]"], ["proof (prove)\nusing this:\n  execution trans sends start (fe index) (ft index)\n  \\<exists>p. isReceiverOf p msg\n  enabled (last (fe index)) msg\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   ?nMsg \\<Longrightarrow>\n  ?nMsg < length (fe index)\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n  enabled (fe index ! nMsg) msg\n  \\<forall>n'\\<ge>nMsg.\n     n' < length (ft index) \\<longrightarrow> msg \\<noteq> ft index ! n'\n  nMsg \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe index ! (nMsg - 1)) msg \\<or>\n  msg = ft index ! (nMsg - 1)\n  execution trans sends start (fe index) (ft index) \\<Longrightarrow>\n  execution.firstOccurrence (fe index) (ft index) ?msg ?n \\<equiv>\n  (\\<exists>p. isReceiverOf p ?msg) \\<and>\n  enabled (last (fe index)) ?msg \\<and>\n  ?n < length (fe index) \\<and>\n  enabled (fe index ! ?n) ?msg \\<and>\n  (\\<forall>n'\\<ge>?n.\n      n' < length (ft index) \\<longrightarrow>\n      ?msg \\<noteq> ft index ! n') \\<and>\n  (?n \\<noteq> 0 \\<longrightarrow>\n   \\<not> enabled (fe index ! (?n - 1)) ?msg \\<or>\n   ?msg = ft index ! (?n - 1))\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg nMsg", "by simp"], ["proof (state)\nthis:\n  execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal (1 subgoal):\n 1. \\<And>msgInSet nMsg n1.\n       \\<lbrakk>n1 \\<le> nMsg;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet\n         n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nMsg n1.\n                            n1 \\<le> nMsg \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msgInSet n1 \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msg nMsg", "have \"execution.firstOccurrence (fe index) (ft index) \n              msgInSet n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msgInSet n1", "using AssumptionSubset2 AssumptionSubset(1)"], ["proof (prove)\nusing this:\n  \\<exists>p. isReceiverOf p msgInSet\n  enabled (last (fe (Suc index))) msgInSet\n  n1 < length (fe (Suc index))\n  enabled (fe (Suc index) ! n1) msgInSet\n  \\<forall>n'\\<ge>n1.\n     n' < length (ft (Suc index)) \\<longrightarrow>\n     msgInSet \\<noteq> ft (Suc index) ! n'\n  n1 \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft (Suc index) ! (n1 - 1)\n  n1 \\<le> nMsg\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msgInSet n1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "have Occ1': \"\\<exists>p. isReceiverOf p msgInSet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. isReceiverOf p msgInSet", "using AssumptionSubset2(1)"], ["proof (prove)\nusing this:\n  \\<exists>p. isReceiverOf p msgInSet\n\ngoal (1 subgoal):\n 1. \\<exists>p. isReceiverOf p msgInSet", "by blast"], ["proof (state)\nthis:\n  \\<exists>p. isReceiverOf p msgInSet\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "have Occ3': \"n1 < length (fe index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n1 < length (fe index)", "using SmallIndex AssumptionSubset(3) AssumptionSubset(1)"], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   ?nMsg \\<Longrightarrow>\n  ?nMsg < length (fe index)\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n  n1 \\<le> nMsg\n\ngoal (1 subgoal):\n 1. n1 < length (fe index)", "by (metis le_less_trans)"], ["proof (state)\nthis:\n  n1 < length (fe index)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "have \"(fe index) ! n1 = (fe (Suc index)) ! n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe index ! n1 = fe (Suc index) ! n1", "using Occ3' PrefixSameOnLow[of \"fe index\" \n                  \"fe (Suc index)\"] BasicProperties"], ["proof (prove)\nusing this:\n  n1 < length (fe index)\n  prefixList (fe index) (fe (Suc index)) \\<Longrightarrow>\n  \\<forall>indexa<length (fe index).\n     fe index ! indexa = fe (Suc index) ! indexa\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. fe index ! n1 = fe (Suc index) ! n1", "by simp"], ["proof (state)\nthis:\n  fe index ! n1 = fe (Suc index) ! n1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "hence Occ4': \"enabled (fe index ! n1) msgInSet\""], ["proof (prove)\nusing this:\n  fe index ! n1 = fe (Suc index) ! n1\n\ngoal (1 subgoal):\n 1. enabled (fe index ! n1) msgInSet", "using AssumptionSubset2(4)"], ["proof (prove)\nusing this:\n  fe index ! n1 = fe (Suc index) ! n1\n  enabled (fe (Suc index) ! n1) msgInSet\n\ngoal (1 subgoal):\n 1. enabled (fe index ! n1) msgInSet", "by simp"], ["proof (state)\nthis:\n  enabled (fe index ! n1) msgInSet\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "have OccSameMsg': \"\\<forall> n' \\<ge> n1 . n' < length (ft index) \n                \\<longrightarrow> (ft index) ! n' = (ft (Suc index)) ! n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n1.\n       n' < length (ft index) \\<longrightarrow>\n       ft index ! n' = ft (Suc index) ! n'", "using PrefixSameOnLow BasicProperties"], ["proof (prove)\nusing this:\n  prefixList ?l1.0 ?l2.0 \\<Longrightarrow>\n  \\<forall>index<length ?l1.0. ?l1.0 ! index = ?l2.0 ! index\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n1.\n       n' < length (ft index) \\<longrightarrow>\n       ft index ! n' = ft (Suc index) ! n'", "by auto"], ["proof (state)\nthis:\n  \\<forall>n'\\<ge>n1.\n     n' < length (ft index) \\<longrightarrow>\n     ft index ! n' = ft (Suc index) ! n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "hence Occ5': \"\\<forall>n' \\<ge> n1. n' < length (ft index) \n                \\<longrightarrow> msgInSet \\<noteq> ft index ! n'\""], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>n1.\n     n' < length (ft index) \\<longrightarrow>\n     ft index ! n' = ft (Suc index) ! n'\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n1.\n       n' < length (ft index) \\<longrightarrow>\n       msgInSet \\<noteq> ft index ! n'", "using AssumptionSubset2(5) ShorterTrace"], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>n1.\n     n' < length (ft index) \\<longrightarrow>\n     ft index ! n' = ft (Suc index) ! n'\n  \\<forall>n'\\<ge>n1.\n     n' < length (ft (Suc index)) \\<longrightarrow>\n     msgInSet \\<noteq> ft (Suc index) ! n'\n  length (ft index) < length (ft (Suc index))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n1.\n       n' < length (ft index) \\<longrightarrow>\n       msgInSet \\<noteq> ft index ! n'", "by simp"], ["proof (state)\nthis:\n  \\<forall>n'\\<ge>n1.\n     n' < length (ft index) \\<longrightarrow>\n     msgInSet \\<noteq> ft index ! n'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "have \"length (fe index) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe index \\<in># length", "using NotEmpty(2)"], ["proof (prove)\nusing this:\n  fe index \\<noteq> []\n\ngoal (1 subgoal):\n 1. fe index \\<in># length", "by (metis length_greater_0_conv)"], ["proof (state)\nthis:\n  fe index \\<in># length\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "hence \"length (fe index) - 1 < length (fe index)\""], ["proof (prove)\nusing this:\n  fe index \\<in># length\n\ngoal (1 subgoal):\n 1. length (fe index) - 1 < length (fe index)", "by (metis One_nat_def diff_Suc_less)"], ["proof (state)\nthis:\n  length (fe index) - 1 < length (fe index)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "hence \n                \"enabled (fe index ! (length (fe index) - 1)) msgInSet\n                \\<or> (\\<exists>n0'\\<ge>n1. n0' < length (ft index) \\<and> ft index ! n0'\n                  = msgInSet)\""], ["proof (prove)\nusing this:\n  length (fe index) - 1 < length (fe index)\n\ngoal (1 subgoal):\n 1. enabled (fe index ! (length (fe index) - 1)) msgInSet \\<or>\n    (\\<exists>n0'\\<ge>n1.\n        n0' < length (ft index) \\<and> ft index ! n0' = msgInSet)", "using Occ4' Occ3' MessageStaysOrConsumed[of \"n1\" \n                  \"length (fe index) - 1\" \"index\" \"msgInSet\"]"], ["proof (prove)\nusing this:\n  length (fe index) - 1 < length (fe index)\n  enabled (fe index ! n1) msgInSet\n  n1 < length (fe index)\n  n1 \\<le> length (fe index) - 1 \\<and>\n  length (fe index) - 1 < length (fe index) \\<and>\n  enabled (fe index ! n1) msgInSet \\<longrightarrow>\n  enabled (fe index ! (length (fe index) - 1)) msgInSet \\<or>\n  (\\<exists>n0'\\<ge>n1.\n      n0' < length (ft index) \\<and> ft index ! n0' = msgInSet)\n\ngoal (1 subgoal):\n 1. enabled (fe index ! (length (fe index) - 1)) msgInSet \\<or>\n    (\\<exists>n0'\\<ge>n1.\n        n0' < length (ft index) \\<and> ft index ! n0' = msgInSet)", "by (metis Suc_pred' \\<open>0 < length (fe index)\\<close> \n                  not_le not_less_eq_eq)"], ["proof (state)\nthis:\n  enabled (fe index ! (length (fe index) - 1)) msgInSet \\<or>\n  (\\<exists>n0'\\<ge>n1.\n      n0' < length (ft index) \\<and> ft index ! n0' = msgInSet)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "hence \"enabled ((fe index) ! (length (fe index) - 1)) \n                msgInSet\""], ["proof (prove)\nusing this:\n  enabled (fe index ! (length (fe index) - 1)) msgInSet \\<or>\n  (\\<exists>n0'\\<ge>n1.\n      n0' < length (ft index) \\<and> ft index ! n0' = msgInSet)\n\ngoal (1 subgoal):\n 1. enabled (fe index ! (length (fe index) - 1)) msgInSet", "using Occ5'"], ["proof (prove)\nusing this:\n  enabled (fe index ! (length (fe index) - 1)) msgInSet \\<or>\n  (\\<exists>n0'\\<ge>n1.\n      n0' < length (ft index) \\<and> ft index ! n0' = msgInSet)\n  \\<forall>n'\\<ge>n1.\n     n' < length (ft index) \\<longrightarrow>\n     msgInSet \\<noteq> ft index ! n'\n\ngoal (1 subgoal):\n 1. enabled (fe index ! (length (fe index) - 1)) msgInSet", "by auto"], ["proof (state)\nthis:\n  enabled (fe index ! (length (fe index) - 1)) msgInSet\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "hence Occ2': \"enabled (last (fe index)) msgInSet\""], ["proof (prove)\nusing this:\n  enabled (fe index ! (length (fe index) - 1)) msgInSet\n\ngoal (1 subgoal):\n 1. enabled (last (fe index)) msgInSet", "using last_conv_nth[of \"fe index\"] NotEmpty(2)"], ["proof (prove)\nusing this:\n  enabled (fe index ! (length (fe index) - 1)) msgInSet\n  fe index \\<noteq> [] \\<Longrightarrow>\n  last (fe index) = fe index ! (length (fe index) - 1)\n  fe index \\<noteq> []\n\ngoal (1 subgoal):\n 1. enabled (last (fe index)) msgInSet", "by simp"], ["proof (state)\nthis:\n  enabled (last (fe index)) msgInSet\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "have Occ6': \"n1 \\<noteq> 0 \\<longrightarrow> \\<not> enabled (fe index ! (n1 - 1)) \n                msgInSet \\<or> msgInSet = ft index ! (n1 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n1 \\<noteq> 0 \\<longrightarrow>\n    \\<not> enabled (fe index ! (n1 - 1)) msgInSet \\<or>\n    msgInSet = ft index ! (n1 - 1)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "assume AssumpOcc6': \"0 < n1\" \"msgInSet \\<noteq> ft index ! \n                  (n1 - 1)\" \"enabled (fe index ! (n1 - 1)) msgInSet\""], ["proof (state)\nthis:\n  0 < n1\n  msgInSet \\<noteq> ft index ! (n1 - 1)\n  enabled (fe index ! (n1 - 1)) msgInSet\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "have \"n1 - (Suc 0) < length (fe index) - (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n1 - Suc 0 < length (fe index) - Suc 0", "using Occ3' AssumpOcc6'(1)"], ["proof (prove)\nusing this:\n  n1 < length (fe index)\n  0 < n1\n\ngoal (1 subgoal):\n 1. n1 - Suc 0 < length (fe index) - Suc 0", "by (metis Suc_le_eq diff_less_mono)"], ["proof (state)\nthis:\n  n1 - Suc 0 < length (fe index) - Suc 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "hence SmallIndexTrace': \"n1 - 1 < length (ft index)\""], ["proof (prove)\nusing this:\n  n1 - Suc 0 < length (fe index) - Suc 0\n\ngoal (1 subgoal):\n 1. n1 - 1 < length (ft index)", "using IndexIsExec execution.length"], ["proof (prove)\nusing this:\n  n1 - Suc 0 < length (fe index) - Suc 0\n  execution trans sends start (fe index) (ft index)\n  execution ?trans ?sends ?start ?exec ?trace \\<Longrightarrow>\n  length ?exec - 1 = length ?trace\n\ngoal (1 subgoal):\n 1. n1 - 1 < length (ft index)", "by (metis One_nat_def)"], ["proof (state)\nthis:\n  n1 - 1 < length (ft index)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \n                  \\<or> msgInSet = ft (Suc index) ! (n1 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n    msgInSet = ft (Suc index) ! (n1 - 1)", "using AssumptionSubset2(6) AssumpOcc6'(1)"], ["proof (prove)\nusing this:\n  n1 \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft (Suc index) ! (n1 - 1)\n  0 < n1\n\ngoal (1 subgoal):\n 1. \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n    msgInSet = ft (Suc index) ! (n1 - 1)", "by blast"], ["proof (state)\nthis:\n  \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft (Suc index) ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft (Suc index) ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "have \"fe (Suc index) ! (n1 - 1) \n                  = fe index ! (n1 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe (Suc index) ! (n1 - 1) = fe index ! (n1 - 1)", "using SameCfgOnLow Occ3'"], ["proof (prove)\nusing this:\n  \\<forall>i<length (fe index). fe index ! i = fe (Suc index) ! i\n  n1 < length (fe index)\n\ngoal (1 subgoal):\n 1. fe (Suc index) ! (n1 - 1) = fe index ! (n1 - 1)", "by (metis less_imp_diff_less)"], ["proof (state)\nthis:\n  fe (Suc index) ! (n1 - 1) = fe index ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fe (Suc index) ! (n1 - 1) = fe index ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "have \"ft (Suc index) ! (n1 - 1) \n                  = ft index ! (n1 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ft (Suc index) ! (n1 - 1) = ft index ! (n1 - 1)", "using SameMsgOnLow SmallIndexTrace'"], ["proof (prove)\nusing this:\n  \\<forall>i<length (ft index). ft index ! i = ft (Suc index) ! i\n  n1 - 1 < length (ft index)\n\ngoal (1 subgoal):\n 1. ft (Suc index) ! (n1 - 1) = ft index ! (n1 - 1)", "by metis"], ["proof (state)\nthis:\n  ft (Suc index) ! (n1 - 1) = ft index ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft (Suc index) ! (n1 - 1)\n  fe (Suc index) ! (n1 - 1) = fe index ! (n1 - 1)\n  ft (Suc index) ! (n1 - 1) = ft index ! (n1 - 1)", "have \"\\<not> enabled (fe index ! \n                  (n1 - 1)) msgInSet \\<or> msgInSet = ft index ! (n1 - 1)\""], ["proof (prove)\nusing this:\n  \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft (Suc index) ! (n1 - 1)\n  fe (Suc index) ! (n1 - 1) = fe index ! (n1 - 1)\n  ft (Suc index) ! (n1 - 1) = ft index ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. \\<not> enabled (fe index ! (n1 - 1)) msgInSet \\<or>\n    msgInSet = ft index ! (n1 - 1)", "by simp"], ["proof (state)\nthis:\n  \\<not> enabled (fe index ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft index ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n1; msgInSet \\<noteq> ft index ! (n1 - 1);\n     enabled (fe index ! (n1 - 1)) msgInSet\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> enabled (fe index ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft index ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. False", "using AssumpOcc6'"], ["proof (prove)\nusing this:\n  \\<not> enabled (fe index ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft index ! (n1 - 1)\n  0 < n1\n  msgInSet \\<noteq> ft index ! (n1 - 1)\n  enabled (fe index ! (n1 - 1)) msgInSet\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n1 \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe index ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft index ! (n1 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isReceiverOf p msgInSet;\n     enabled (last (fe (Suc index))) msgInSet; n1 < length (fe (Suc index));\n     enabled (fe (Suc index) ! n1) msgInSet;\n     \\<forall>n'\\<ge>n1.\n        n' < length (ft (Suc index)) \\<longrightarrow>\n        msgInSet \\<noteq> ft (Suc index) ! n';\n     n1 \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe (Suc index) ! (n1 - 1)) msgInSet \\<or>\n     msgInSet = ft (Suc index) ! (n1 - 1);\n     n1 \\<le> nMsg\\<rbrakk>\n    \\<Longrightarrow> execution.firstOccurrence (fe index) (ft index)\n                       msgInSet n1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msgInSet n1", "using IndexIsExec Occ1' Occ2' Occ3' Occ4' \n                Occ5' Occ6'\n                execution.firstOccurrence_def[of \"trans\" \"sends\" \n                  \"start\" \"fe index\" \"ft index\"]"], ["proof (prove)\nusing this:\n  execution trans sends start (fe index) (ft index)\n  \\<exists>p. isReceiverOf p msgInSet\n  enabled (last (fe index)) msgInSet\n  n1 < length (fe index)\n  enabled (fe index ! n1) msgInSet\n  \\<forall>n'\\<ge>n1.\n     n' < length (ft index) \\<longrightarrow>\n     msgInSet \\<noteq> ft index ! n'\n  n1 \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe index ! (n1 - 1)) msgInSet \\<or>\n  msgInSet = ft index ! (n1 - 1)\n  execution trans sends start (fe index) (ft index) \\<Longrightarrow>\n  execution.firstOccurrence (fe index) (ft index) ?msg ?n \\<equiv>\n  (\\<exists>p. isReceiverOf p ?msg) \\<and>\n  enabled (last (fe index)) ?msg \\<and>\n  ?n < length (fe index) \\<and>\n  enabled (fe index ! ?n) ?msg \\<and>\n  (\\<forall>n'\\<ge>?n.\n      n' < length (ft index) \\<longrightarrow>\n      ?msg \\<noteq> ft index ! n') \\<and>\n  (?n \\<noteq> 0 \\<longrightarrow>\n   \\<not> enabled (fe index ! (?n - 1)) ?msg \\<or>\n   ?msg = ft index ! (?n - 1))\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msgInSet n1", "by simp"], ["proof (state)\nthis:\n  execution.firstOccurrence (fe index) (ft index) msgInSet n1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execution.firstOccurrence (fe index) (ft index) msgInSet n1\n\ngoal (1 subgoal):\n 1. \\<And>msgInSet nMsg n1.\n       \\<lbrakk>n1 \\<le> nMsg;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msgInSet\n         n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nMsg n1.\n                            n1 \\<le> nMsg \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msgInSet n1 \\<and>\n                            execution.firstOccurrence (fe index) (ft index)\n                             msg nMsg", "thus \"\\<exists>nMsg' n1'. n1' \\<le> nMsg' \n              \\<and> execution.firstOccurrence (fe index) (ft index) \n                msgInSet n1' \n              \\<and> execution.firstOccurrence (fe index) (ft index) \n                msg nMsg'\""], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe index) (ft index) msgInSet n1\n\ngoal (1 subgoal):\n 1. \\<exists>nMsg' n1'.\n       n1' \\<le> nMsg' \\<and>\n       execution.firstOccurrence (fe index) (ft index) msgInSet n1' \\<and>\n       execution.firstOccurrence (fe index) (ft index) msg nMsg'", "using FirstOccurrenceMsg AssumptionSubset(1)"], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe index) (ft index) msgInSet n1\n  execution.firstOccurrence (fe index) (ft index) msg nMsg\n  n1 \\<le> nMsg\n\ngoal (1 subgoal):\n 1. \\<exists>nMsg' n1'.\n       n1' \\<le> nMsg' \\<and>\n       execution.firstOccurrence (fe index) (ft index) msgInSet n1' \\<and>\n       execution.firstOccurrence (fe index) (ft index) msg nMsg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>nMsg' n1'.\n     n1' \\<le> nMsg' \\<and>\n     execution.firstOccurrence (fe index) (ft index) msgInSet n1' \\<and>\n     execution.firstOccurrence (fe index) (ft index) msg nMsg'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?msgInSet \\<in> firstOccSet (Suc index) \\<Longrightarrow>\n  ?msgInSet \\<in> firstOccSet index\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "have ProperSubset: \"\\<exists> msg' .msg' \\<in> firstOccSet index \n            \\<and> msg' \\<notin> firstOccSet (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "have \"initial (hd (fe index))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial (hd (fe index))", "using AssumptionFair(1)"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n\ngoal (1 subgoal):\n 1. initial (hd (fe index))", "by blast"], ["proof (state)\nthis:\n  initial (hd (fe index))\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "hence \"\\<exists>msg'. execution.minimalEnabled (fe index) (ft index)\n              msg' \\<and>  msg' \\<in> set (drop (length (ft index)) \n                (fStepMsg (fe index) (ft index)))\""], ["proof (prove)\nusing this:\n  initial (hd (fe index))\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<and>\n       msg'\n       \\<in> set (drop (length (ft index)) (fStepMsg (fe index) (ft index)))", "using FStep fe_def ft_def\n                BasicProperties"], ["proof (prove)\nusing this:\n  initial (hd (fe index))\n  \\<forall>cfgList msgList.\n     \\<exists>cfgList' msgList'.\n        fStepCfg cfgList msgList = cfgList' \\<and>\n        fStepMsg cfgList msgList = msgList' \\<and>\n        (initial (hd cfgList) \\<and>\n         nonUniform (last cfgList) \\<and>\n         execution trans sends start cfgList msgList \\<longrightarrow>\n         nonUniform (last (fStepCfg cfgList msgList)) \\<and>\n         prefixList cfgList (fStepCfg cfgList msgList) \\<and>\n         prefixList msgList (fStepMsg cfgList msgList) \\<and>\n         execution trans sends start (fStepCfg cfgList msgList)\n          (fStepMsg cfgList msgList) \\<and>\n         initial (hd (fStepCfg cfgList msgList)) \\<and>\n         (\\<exists>msg'.\n             execution.minimalEnabled cfgList msgList msg' \\<and>\n             msg'\n             \\<in> set (drop (length msgList) (fStepMsg cfgList msgList))))\n  fe = infiniteExecutionCfg cfg fStepCfg fStepMsg\n  ft = infiniteExecutionMsg cfg fStepCfg fStepMsg\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<and>\n       msg'\n       \\<in> set (drop (length (ft index)) (fStepMsg (fe index) (ft index)))", "by simp"], ["proof (state)\nthis:\n  \\<exists>msg'.\n     execution.minimalEnabled (fe index) (ft index) msg' \\<and>\n     msg'\n     \\<in> set (drop (length (ft index)) (fStepMsg (fe index) (ft index)))\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "then"], ["proof (chain)\npicking this:\n  \\<exists>msg'.\n     execution.minimalEnabled (fe index) (ft index) msg' \\<and>\n     msg'\n     \\<in> set (drop (length (ft index)) (fStepMsg (fe index) (ft index)))", "obtain consumedMsg where ConsumedMsg: \n              \"execution.minimalEnabled (fe index) (ft index) \n                consumedMsg\"\n              \"consumedMsg \\<in> set (drop (length (ft index)) \n                (fStepMsg (fe index) (ft index)))\""], ["proof (prove)\nusing this:\n  \\<exists>msg'.\n     execution.minimalEnabled (fe index) (ft index) msg' \\<and>\n     msg'\n     \\<in> set (drop (length (ft index)) (fStepMsg (fe index) (ft index)))\n\ngoal (1 subgoal):\n 1. (\\<And>consumedMsg.\n        \\<lbrakk>execution.minimalEnabled (fe index) (ft index) consumedMsg;\n         consumedMsg\n         \\<in> set (drop (length (ft index))\n                     (fStepMsg (fe index) (ft index)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution.minimalEnabled (fe index) (ft index) consumedMsg\n  consumedMsg\n  \\<in> set (drop (length (ft index)) (fStepMsg (fe index) (ft index)))\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "hence ConsumedIsInDrop:\n              \"consumedMsg \\<in> set (drop (length (ft index)) (ft (Suc index)))\""], ["proof (prove)\nusing this:\n  execution.minimalEnabled (fe index) (ft index) consumedMsg\n  consumedMsg\n  \\<in> set (drop (length (ft index)) (fStepMsg (fe index) (ft index)))\n\ngoal (1 subgoal):\n 1. consumedMsg \\<in> set (drop (length (ft index)) (ft (Suc index)))", "using fe_def ft_def FStep\n                BasicProperties[rule_format, of index]"], ["proof (prove)\nusing this:\n  execution.minimalEnabled (fe index) (ft index) consumedMsg\n  consumedMsg\n  \\<in> set (drop (length (ft index)) (fStepMsg (fe index) (ft index)))\n  fe = infiniteExecutionCfg cfg fStepCfg fStepMsg\n  ft = infiniteExecutionMsg cfg fStepCfg fStepMsg\n  \\<forall>cfgList msgList.\n     \\<exists>cfgList' msgList'.\n        fStepCfg cfgList msgList = cfgList' \\<and>\n        fStepMsg cfgList msgList = msgList' \\<and>\n        (initial (hd cfgList) \\<and>\n         nonUniform (last cfgList) \\<and>\n         execution trans sends start cfgList msgList \\<longrightarrow>\n         nonUniform (last (fStepCfg cfgList msgList)) \\<and>\n         prefixList cfgList (fStepCfg cfgList msgList) \\<and>\n         prefixList msgList (fStepMsg cfgList msgList) \\<and>\n         execution trans sends start (fStepCfg cfgList msgList)\n          (fStepMsg cfgList msgList) \\<and>\n         initial (hd (fStepCfg cfgList msgList)) \\<and>\n         (\\<exists>msg'.\n             execution.minimalEnabled cfgList msgList msg' \\<and>\n             msg'\n             \\<in> set (drop (length msgList) (fStepMsg cfgList msgList))))\n  nonUniform (last (fe index)) \\<and>\n  prefixList (fe index) (fe (index + 1)) \\<and>\n  prefixList (ft index) (ft (index + 1)) \\<and>\n  execution trans sends start (fe index) (ft index) \\<and>\n  initial (hd (fe (index + 1)))\n\ngoal (1 subgoal):\n 1. consumedMsg \\<in> set (drop (length (ft index)) (ft (Suc index)))", "by auto"], ["proof (state)\nthis:\n  consumedMsg \\<in> set (drop (length (ft index)) (ft (Suc index)))\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "have MinImplAllBigger: \"\\<And> msg' . execution.minimalEnabled\n            (fe index) (ft index) msg' \n             \\<longrightarrow> (\\<exists> OccM' . (execution.firstOccurrence (fe index) \n              (ft index) msg' OccM' )\n                \\<and> (\\<forall> msg . \\<forall> OccM . execution.firstOccurrence (fe index)\n                  (ft index) msg OccM \n                \\<longrightarrow> OccM' \\<le> OccM))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<longrightarrow>\n       (\\<exists>OccM'.\n           execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n           (\\<forall>msg OccM.\n               execution.firstOccurrence (fe index) (ft index) msg\n                OccM \\<longrightarrow>\n               OccM' \\<le> OccM))", "proof(auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       \\<exists>OccM'.\n          execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n          (\\<forall>msg OccM.\n              execution.firstOccurrence (fe index) (ft index) msg\n               OccM \\<longrightarrow>\n              OccM' \\<le> OccM)", "fix msg'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       \\<exists>OccM'.\n          execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n          (\\<forall>msg OccM.\n              execution.firstOccurrence (fe index) (ft index) msg\n               OccM \\<longrightarrow>\n              OccM' \\<le> OccM)", "assume AssumpMinImplAllBigger: \"execution.minimalEnabled \n                (fe index) (ft index) msg'\""], ["proof (state)\nthis:\n  execution.minimalEnabled (fe index) (ft index) msg'\n\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       \\<exists>OccM'.\n          execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n          (\\<forall>msg OccM.\n              execution.firstOccurrence (fe index) (ft index) msg\n               OccM \\<longrightarrow>\n              OccM' \\<le> OccM)", "have IsExecIndex: \"execution trans sends start \n                (fe index) (ft index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution trans sends start (fe index) (ft index)", "using  BasicProperties[rule_format, of index]"], ["proof (prove)\nusing this:\n  nonUniform (last (fe index)) \\<and>\n  prefixList (fe index) (fe (index + 1)) \\<and>\n  prefixList (ft index) (ft (index + 1)) \\<and>\n  execution trans sends start (fe index) (ft index) \\<and>\n  initial (hd (fe (index + 1)))\n\ngoal (1 subgoal):\n 1. execution trans sends start (fe index) (ft index)", "by simp"], ["proof (state)\nthis:\n  execution trans sends start (fe index) (ft index)\n\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       \\<exists>OccM'.\n          execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n          (\\<forall>msg OccM.\n              execution.firstOccurrence (fe index) (ft index) msg\n               OccM \\<longrightarrow>\n              OccM' \\<le> OccM)", "have \"(\\<exists> p . isReceiverOf p msg') \\<and> \n                (enabled (last (fe index)) msg')\n                \\<and> (\\<exists> n .  n < length (fe index) \n                  \\<and> enabled ( (fe index) ! n) msg' \n                  \\<and> (\\<forall> n' \\<ge> n . n' < length (ft index) \n                  \\<longrightarrow> msg' \\<noteq> ((ft index)! n'))\n                  \\<and> (\\<forall> n' msg' . ((\\<exists> p . isReceiverOf p msg') \n                    \\<and> (enabled (last (fe index)) msg') \n                    \\<and> n' < length (ft index) \n                    \\<and> enabled ((fe index)! n') msg' \n                    \\<and> (\\<forall> n'' \\<ge> n' . n'' < length (ft index) \n                    \\<longrightarrow> msg' \\<noteq> ((ft index) ! n''))) \\<longrightarrow> n' \\<ge> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg') \\<and>\n    enabled (last (fe index)) msg' \\<and>\n    (\\<exists>n<length (fe index).\n        enabled (fe index ! n) msg' \\<and>\n        (\\<forall>n'\\<ge>n.\n            n' < length (ft index) \\<longrightarrow>\n            msg' \\<noteq> ft index ! n') \\<and>\n        (\\<forall>n' msg'.\n            (\\<exists>p. isReceiverOf p msg') \\<and>\n            enabled (last (fe index)) msg' \\<and>\n            n' < length (ft index) \\<and>\n            enabled (fe index ! n') msg' \\<and>\n            (\\<forall>n''\\<ge>n'.\n                n'' < length (ft index) \\<longrightarrow>\n                msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n            n \\<le> n'))", "using execution.minimalEnabled_def[of trans sends start \n                \"(fe index)\" \"(ft index)\" msg'] \n                AssumpMinImplAllBigger IsExecIndex"], ["proof (prove)\nusing this:\n  execution trans sends start (fe index) (ft index) \\<Longrightarrow>\n  execution.minimalEnabled (fe index) (ft index) msg' \\<equiv>\n  (\\<exists>p. isReceiverOf p msg') \\<and>\n  enabled (last (fe index)) msg' \\<and>\n  (\\<exists>n<length (fe index).\n      enabled (fe index ! n) msg' \\<and>\n      (\\<forall>n'\\<ge>n.\n          n' < length (ft index) \\<longrightarrow>\n          msg' \\<noteq> ft index ! n') \\<and>\n      (\\<forall>n' msg'.\n          (\\<exists>p. isReceiverOf p msg') \\<and>\n          enabled (last (fe index)) msg' \\<and>\n          n' < length (ft index) \\<and>\n          enabled (fe index ! n') msg' \\<and>\n          (\\<forall>n''\\<ge>n'.\n              n'' < length (ft index) \\<longrightarrow>\n              msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n          n \\<le> n'))\n  execution.minimalEnabled (fe index) (ft index) msg'\n  execution trans sends start (fe index) (ft index)\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg') \\<and>\n    enabled (last (fe index)) msg' \\<and>\n    (\\<exists>n<length (fe index).\n        enabled (fe index ! n) msg' \\<and>\n        (\\<forall>n'\\<ge>n.\n            n' < length (ft index) \\<longrightarrow>\n            msg' \\<noteq> ft index ! n') \\<and>\n        (\\<forall>n' msg'.\n            (\\<exists>p. isReceiverOf p msg') \\<and>\n            enabled (last (fe index)) msg' \\<and>\n            n' < length (ft index) \\<and>\n            enabled (fe index ! n') msg' \\<and>\n            (\\<forall>n''\\<ge>n'.\n                n'' < length (ft index) \\<longrightarrow>\n                msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n            n \\<le> n'))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>p. isReceiverOf p msg') \\<and>\n  enabled (last (fe index)) msg' \\<and>\n  (\\<exists>n<length (fe index).\n      enabled (fe index ! n) msg' \\<and>\n      (\\<forall>n'\\<ge>n.\n          n' < length (ft index) \\<longrightarrow>\n          msg' \\<noteq> ft index ! n') \\<and>\n      (\\<forall>n' msg'.\n          (\\<exists>p. isReceiverOf p msg') \\<and>\n          enabled (last (fe index)) msg' \\<and>\n          n' < length (ft index) \\<and>\n          enabled (fe index ! n') msg' \\<and>\n          (\\<forall>n''\\<ge>n'.\n              n'' < length (ft index) \\<longrightarrow>\n              msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n          n \\<le> n'))\n\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       \\<exists>OccM'.\n          execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n          (\\<forall>msg OccM.\n              execution.firstOccurrence (fe index) (ft index) msg\n               OccM \\<longrightarrow>\n              OccM' \\<le> OccM)", "then"], ["proof (chain)\npicking this:\n  (\\<exists>p. isReceiverOf p msg') \\<and>\n  enabled (last (fe index)) msg' \\<and>\n  (\\<exists>n<length (fe index).\n      enabled (fe index ! n) msg' \\<and>\n      (\\<forall>n'\\<ge>n.\n          n' < length (ft index) \\<longrightarrow>\n          msg' \\<noteq> ft index ! n') \\<and>\n      (\\<forall>n' msg'.\n          (\\<exists>p. isReceiverOf p msg') \\<and>\n          enabled (last (fe index)) msg' \\<and>\n          n' < length (ft index) \\<and>\n          enabled (fe index ! n') msg' \\<and>\n          (\\<forall>n''\\<ge>n'.\n              n'' < length (ft index) \\<longrightarrow>\n              msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n          n \\<le> n'))", "obtain OccM' where OccM': \n                \"(\\<exists> p . isReceiverOf p msg')\" \n                \"(enabled (last (fe index)) msg')\"\n                \"OccM' < length (fe index)\" \n                \"enabled ( (fe index) ! OccM') msg'\"  \n                \"(\\<forall> n' \\<ge> OccM' . n' < length (ft index) \n                \\<longrightarrow> msg' \\<noteq> ((ft index)! n'))\"\n                \"(\\<forall> n' msg' . ((\\<exists> p . isReceiverOf p msg') \n                  \\<and> (enabled (last (fe index)) msg') \n                  \\<and> n' < length (ft index) \n                  \\<and> enabled ((fe index)! n') msg' \n                  \\<and> (\\<forall> n'' \\<ge> n' . n'' < length (ft index) \n                  \\<longrightarrow> msg' \\<noteq> ((ft index) ! n''))) \\<longrightarrow> n' \\<ge> OccM')\""], ["proof (prove)\nusing this:\n  (\\<exists>p. isReceiverOf p msg') \\<and>\n  enabled (last (fe index)) msg' \\<and>\n  (\\<exists>n<length (fe index).\n      enabled (fe index ! n) msg' \\<and>\n      (\\<forall>n'\\<ge>n.\n          n' < length (ft index) \\<longrightarrow>\n          msg' \\<noteq> ft index ! n') \\<and>\n      (\\<forall>n' msg'.\n          (\\<exists>p. isReceiverOf p msg') \\<and>\n          enabled (last (fe index)) msg' \\<and>\n          n' < length (ft index) \\<and>\n          enabled (fe index ! n') msg' \\<and>\n          (\\<forall>n''\\<ge>n'.\n              n'' < length (ft index) \\<longrightarrow>\n              msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n          n \\<le> n'))\n\ngoal (1 subgoal):\n 1. (\\<And>OccM'.\n        \\<lbrakk>\\<exists>p. isReceiverOf p msg';\n         enabled (last (fe index)) msg'; OccM' < length (fe index);\n         enabled (fe index ! OccM') msg';\n         \\<forall>n'\\<ge>OccM'.\n            n' < length (ft index) \\<longrightarrow>\n            msg' \\<noteq> ft index ! n';\n         \\<forall>n' msg'.\n            (\\<exists>p. isReceiverOf p msg') \\<and>\n            enabled (last (fe index)) msg' \\<and>\n            n' < length (ft index) \\<and>\n            enabled (fe index ! n') msg' \\<and>\n            (\\<forall>n''\\<ge>n'.\n                n'' < length (ft index) \\<longrightarrow>\n                msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n            OccM' \\<le> n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<exists>p. isReceiverOf p msg'\n  enabled (last (fe index)) msg'\n  OccM' < length (fe index)\n  enabled (fe index ! OccM') msg'\n  \\<forall>n'\\<ge>OccM'.\n     n' < length (ft index) \\<longrightarrow> msg' \\<noteq> ft index ! n'\n  \\<forall>n' msg'.\n     (\\<exists>p. isReceiverOf p msg') \\<and>\n     enabled (last (fe index)) msg' \\<and>\n     n' < length (ft index) \\<and>\n     enabled (fe index ! n') msg' \\<and>\n     (\\<forall>n''\\<ge>n'.\n         n'' < length (ft index) \\<longrightarrow>\n         msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n     OccM' \\<le> n'\n\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       \\<exists>OccM'.\n          execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n          (\\<forall>msg OccM.\n              execution.firstOccurrence (fe index) (ft index) msg\n               OccM \\<longrightarrow>\n              OccM' \\<le> OccM)", "have \"0 < OccM' \\<Longrightarrow> enabled (fe index ! (OccM' - Suc 0)) msg' \n                      \\<Longrightarrow> msg' \\<noteq> ft index ! (OccM' - Suc 0) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n     msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "proof(-)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n     msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n     msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "assume AssumpContr: \n                  \"0 < OccM'\"\n                  \"enabled (fe index ! (OccM' - Suc 0)) msg'\"\n                  \"msg' \\<noteq> ft index ! (OccM' - Suc 0)\""], ["proof (state)\nthis:\n  0 < OccM'\n  enabled (fe index ! (OccM' - Suc 0)) msg'\n  msg' \\<noteq> ft index ! (OccM' - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n     msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "have LengthOccM': \"(OccM' - 1) < length (ft index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OccM' - 1 < length (ft index)", "using OccM'(3) IndexIsExec AssumpContr(1)   \n                  AssumptionFair(1)"], ["proof (prove)\nusing this:\n  OccM' < length (fe index)\n  execution trans sends start (fe index) (ft index)\n  0 < OccM'\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n\ngoal (1 subgoal):\n 1. OccM' - 1 < length (ft index)", "by (metis  One_nat_def Suc_diff_1 Suc_eq_plus1_left \n                    Suc_less_eq le_add_diff_inverse)"], ["proof (state)\nthis:\n  OccM' - 1 < length (ft index)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n     msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "have BiggerIndices: \"(\\<forall>n''\\<ge>(OccM' - 1). \n                  n'' < length (ft index) \\<longrightarrow> msg' \\<noteq> ft index ! n'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n''\\<ge>OccM' - 1.\n       n'' < length (ft index) \\<longrightarrow>\n       msg' \\<noteq> ft index ! n''", "using OccM'(5)"], ["proof (prove)\nusing this:\n  \\<forall>n'\\<ge>OccM'.\n     n' < length (ft index) \\<longrightarrow> msg' \\<noteq> ft index ! n'\n\ngoal (1 subgoal):\n 1. \\<forall>n''\\<ge>OccM' - 1.\n       n'' < length (ft index) \\<longrightarrow>\n       msg' \\<noteq> ft index ! n''", "by (metis AssumpContr(3) One_nat_def \n                      Suc_eq_plus1 diff_Suc_1 le_SucE le_diff_conv)"], ["proof (state)\nthis:\n  \\<forall>n''\\<ge>OccM' - 1.\n     n'' < length (ft index) \\<longrightarrow> msg' \\<noteq> ft index ! n''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n     msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "have \"(\\<exists>p. isReceiverOf p msg') \\<and> enabled (last \n                  (fe index)) msg' \\<and> (OccM' - 1) < length (ft index)\n                    \\<and> enabled (fe index ! (OccM' - 1)) msg' \n                    \\<and> (\\<forall>n''\\<ge>(OccM' - 1). n'' < length (ft index) \n                      \\<longrightarrow> msg' \\<noteq> ft index ! n'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg') \\<and>\n    enabled (last (fe index)) msg' \\<and>\n    OccM' - 1 < length (ft index) \\<and>\n    enabled (fe index ! (OccM' - 1)) msg' \\<and>\n    (\\<forall>n''\\<ge>OccM' - 1.\n        n'' < length (ft index) \\<longrightarrow>\n        msg' \\<noteq> ft index ! n'')", "using OccM' LengthOccM' AssumpContr BiggerIndices"], ["proof (prove)\nusing this:\n  \\<exists>p. isReceiverOf p msg'\n  enabled (last (fe index)) msg'\n  OccM' < length (fe index)\n  enabled (fe index ! OccM') msg'\n  \\<forall>n'\\<ge>OccM'.\n     n' < length (ft index) \\<longrightarrow> msg' \\<noteq> ft index ! n'\n  \\<forall>n' msg'.\n     (\\<exists>p. isReceiverOf p msg') \\<and>\n     enabled (last (fe index)) msg' \\<and>\n     n' < length (ft index) \\<and>\n     enabled (fe index ! n') msg' \\<and>\n     (\\<forall>n''\\<ge>n'.\n         n'' < length (ft index) \\<longrightarrow>\n         msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n     OccM' \\<le> n'\n  OccM' - 1 < length (ft index)\n  0 < OccM'\n  enabled (fe index ! (OccM' - Suc 0)) msg'\n  msg' \\<noteq> ft index ! (OccM' - Suc 0)\n  \\<forall>n''\\<ge>OccM' - 1.\n     n'' < length (ft index) \\<longrightarrow> msg' \\<noteq> ft index ! n''\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg') \\<and>\n    enabled (last (fe index)) msg' \\<and>\n    OccM' - 1 < length (ft index) \\<and>\n    enabled (fe index ! (OccM' - 1)) msg' \\<and>\n    (\\<forall>n''\\<ge>OccM' - 1.\n        n'' < length (ft index) \\<longrightarrow>\n        msg' \\<noteq> ft index ! n'')", "by simp"], ["proof (state)\nthis:\n  (\\<exists>p. isReceiverOf p msg') \\<and>\n  enabled (last (fe index)) msg' \\<and>\n  OccM' - 1 < length (ft index) \\<and>\n  enabled (fe index ! (OccM' - 1)) msg' \\<and>\n  (\\<forall>n''\\<ge>OccM' - 1.\n      n'' < length (ft index) \\<longrightarrow>\n      msg' \\<noteq> ft index ! n'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n     msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"OccM' \\<le> OccM' - 1\""], ["proof (prove)\nusing this:\n  (\\<exists>p. isReceiverOf p msg') \\<and>\n  enabled (last (fe index)) msg' \\<and>\n  OccM' - 1 < length (ft index) \\<and>\n  enabled (fe index ! (OccM' - 1)) msg' \\<and>\n  (\\<forall>n''\\<ge>OccM' - 1.\n      n'' < length (ft index) \\<longrightarrow>\n      msg' \\<noteq> ft index ! n'')\n\ngoal (1 subgoal):\n 1. OccM' \\<le> OccM' - 1", "using OccM'(6)"], ["proof (prove)\nusing this:\n  (\\<exists>p. isReceiverOf p msg') \\<and>\n  enabled (last (fe index)) msg' \\<and>\n  OccM' - 1 < length (ft index) \\<and>\n  enabled (fe index ! (OccM' - 1)) msg' \\<and>\n  (\\<forall>n''\\<ge>OccM' - 1.\n      n'' < length (ft index) \\<longrightarrow>\n      msg' \\<noteq> ft index ! n'')\n  \\<forall>n' msg'.\n     (\\<exists>p. isReceiverOf p msg') \\<and>\n     enabled (last (fe index)) msg' \\<and>\n     n' < length (ft index) \\<and>\n     enabled (fe index ! n') msg' \\<and>\n     (\\<forall>n''\\<ge>n'.\n         n'' < length (ft index) \\<longrightarrow>\n         msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n     OccM' \\<le> n'\n\ngoal (1 subgoal):\n 1. OccM' \\<le> OccM' - 1", "by blast"], ["proof (state)\nthis:\n  OccM' \\<le> OccM' - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n     msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  OccM' \\<le> OccM' - 1\n\ngoal (1 subgoal):\n 1. False", "using AssumpContr(1) diff_less leD zero_less_one"], ["proof (prove)\nusing this:\n  OccM' \\<le> OccM' - 1\n  0 < OccM'\n  \\<lbrakk>0 < ?n; 0 < ?m\\<rbrakk> \\<Longrightarrow> ?m - ?n < ?m\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  (0::?'a) < (1::?'a)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n   msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       \\<exists>OccM'.\n          execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n          (\\<forall>msg OccM.\n              execution.firstOccurrence (fe index) (ft index) msg\n               OccM \\<longrightarrow>\n              OccM' \\<le> OccM)", "hence FirstOccMsg': \"execution.firstOccurrence (fe index)\n                  (ft index) msg' OccM'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n   msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. execution.firstOccurrence (fe index) (ft index) msg' OccM'", "unfolding execution_def\n                  execution.firstOccurrence_def[OF IsExecIndex, of msg' OccM']"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < OccM'; enabled (fe index ! (OccM' - Suc 0)) msg';\n   msg' \\<noteq> ft index ! (OccM' - Suc 0)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg') \\<and>\n    enabled (last (fe index)) msg' \\<and>\n    OccM' < length (fe index) \\<and>\n    enabled (fe index ! OccM') msg' \\<and>\n    (\\<forall>n'\\<ge>OccM'.\n        n' < length (ft index) \\<longrightarrow>\n        msg' \\<noteq> ft index ! n') \\<and>\n    (OccM' \\<noteq> 0 \\<longrightarrow>\n     \\<not> enabled (fe index ! (OccM' - 1)) msg' \\<or>\n     msg' = ft index ! (OccM' - 1))", "by (auto simp add: OccM'(1,2,3,4,5))"], ["proof (state)\nthis:\n  execution.firstOccurrence (fe index) (ft index) msg' OccM'\n\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       \\<exists>OccM'.\n          execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n          (\\<forall>msg OccM.\n              execution.firstOccurrence (fe index) (ft index) msg\n               OccM \\<longrightarrow>\n              OccM' \\<le> OccM)", "have \"\\<forall>msg OccM. execution.firstOccurrence (fe index) \n                (ft index) msg OccM \\<longrightarrow> OccM' \\<le> OccM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>msg OccM.\n       execution.firstOccurrence (fe index) (ft index) msg\n        OccM \\<longrightarrow>\n       OccM' \\<le> OccM", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msg OccM.\n       execution.firstOccurrence (fe index) (ft index) msg\n        OccM \\<Longrightarrow>\n       OccM' \\<le> OccM", "fix msg OccM"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msg OccM.\n       execution.firstOccurrence (fe index) (ft index) msg\n        OccM \\<Longrightarrow>\n       OccM' \\<le> OccM", "assume  \"execution.firstOccurrence (fe index) \n                  (ft index) msg OccM\""], ["proof (state)\nthis:\n  execution.firstOccurrence (fe index) (ft index) msg OccM\n\ngoal (1 subgoal):\n 1. \\<And>msg OccM.\n       execution.firstOccurrence (fe index) (ft index) msg\n        OccM \\<Longrightarrow>\n       OccM' \\<le> OccM", "hence AssumpOccMFirstOccurrence: \n                  \"\\<exists> p . isReceiverOf p msg\" \n                  \"enabled (last (fe index)) msg\" \n                  \"OccM < (length (fe index))\"\n                  \"enabled ((fe index) ! OccM) msg\" \n                  \"(\\<forall> n' \\<ge> OccM . n' < length (ft index) \n                  \\<longrightarrow> msg \\<noteq> ((ft index) ! n'))\"\n                  \"(OccM \\<noteq> 0 \\<longrightarrow> (\\<not> enabled ((fe index) ! (OccM - 1)) \n                  msg \\<or> msg = (ft index)!(OccM - 1)))\""], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe index) (ft index) msg OccM\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg &&&\n     enabled (last (fe index)) msg &&& OccM < length (fe index)) &&&\n    enabled (fe index ! OccM) msg &&&\n    \\<forall>n'\\<ge>OccM.\n       n' < length (ft index) \\<longrightarrow>\n       msg \\<noteq> ft index ! n' &&&\n    OccM \\<noteq> 0 \\<longrightarrow>\n    \\<not> enabled (fe index ! (OccM - 1)) msg \\<or>\n    msg = ft index ! (OccM - 1)", "by (auto simp add: execution.firstOccurrence_def[of \n                      trans sends start \"(fe index)\" \"(ft index)\" \n                      msg OccM] IsExecIndex)"], ["proof (state)\nthis:\n  \\<exists>p. isReceiverOf p msg\n  enabled (last (fe index)) msg\n  OccM < length (fe index)\n  enabled (fe index ! OccM) msg\n  \\<forall>n'\\<ge>OccM.\n     n' < length (ft index) \\<longrightarrow> msg \\<noteq> ft index ! n'\n  OccM \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe index ! (OccM - 1)) msg \\<or>\n  msg = ft index ! (OccM - 1)\n\ngoal (1 subgoal):\n 1. \\<And>msg OccM.\n       execution.firstOccurrence (fe index) (ft index) msg\n        OccM \\<Longrightarrow>\n       OccM' \\<le> OccM", "hence \"(\\<exists>p. isReceiverOf p msg) \\<and>\n                  enabled (last (fe index)) msg \\<and>\n                  enabled (fe index ! OccM) msg \\<and> \n                  (\\<forall>n''\\<ge> OccM. n'' < length (ft index) \n                    \\<longrightarrow> msg \\<noteq> ft index ! n'')\""], ["proof (prove)\nusing this:\n  \\<exists>p. isReceiverOf p msg\n  enabled (last (fe index)) msg\n  OccM < length (fe index)\n  enabled (fe index ! OccM) msg\n  \\<forall>n'\\<ge>OccM.\n     n' < length (ft index) \\<longrightarrow> msg \\<noteq> ft index ! n'\n  OccM \\<noteq> 0 \\<longrightarrow>\n  \\<not> enabled (fe index ! (OccM - 1)) msg \\<or>\n  msg = ft index ! (OccM - 1)\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isReceiverOf p msg) \\<and>\n    enabled (last (fe index)) msg \\<and>\n    enabled (fe index ! OccM) msg \\<and>\n    (\\<forall>n''\\<ge>OccM.\n        n'' < length (ft index) \\<longrightarrow>\n        msg \\<noteq> ft index ! n'')", "by simp"], ["proof (state)\nthis:\n  (\\<exists>p. isReceiverOf p msg) \\<and>\n  enabled (last (fe index)) msg \\<and>\n  enabled (fe index ! OccM) msg \\<and>\n  (\\<forall>n''\\<ge>OccM.\n      n'' < length (ft index) \\<longrightarrow> msg \\<noteq> ft index ! n'')\n\ngoal (1 subgoal):\n 1. \\<And>msg OccM.\n       execution.firstOccurrence (fe index) (ft index) msg\n        OccM \\<Longrightarrow>\n       OccM' \\<le> OccM", "thus \"OccM' \\<le> OccM\""], ["proof (prove)\nusing this:\n  (\\<exists>p. isReceiverOf p msg) \\<and>\n  enabled (last (fe index)) msg \\<and>\n  enabled (fe index ! OccM) msg \\<and>\n  (\\<forall>n''\\<ge>OccM.\n      n'' < length (ft index) \\<longrightarrow> msg \\<noteq> ft index ! n'')\n\ngoal (1 subgoal):\n 1. OccM' \\<le> OccM", "using OccM'"], ["proof (prove)\nusing this:\n  (\\<exists>p. isReceiverOf p msg) \\<and>\n  enabled (last (fe index)) msg \\<and>\n  enabled (fe index ! OccM) msg \\<and>\n  (\\<forall>n''\\<ge>OccM.\n      n'' < length (ft index) \\<longrightarrow> msg \\<noteq> ft index ! n'')\n  \\<exists>p. isReceiverOf p msg'\n  enabled (last (fe index)) msg'\n  OccM' < length (fe index)\n  enabled (fe index ! OccM') msg'\n  \\<forall>n'\\<ge>OccM'.\n     n' < length (ft index) \\<longrightarrow> msg' \\<noteq> ft index ! n'\n  \\<forall>n' msg'.\n     (\\<exists>p. isReceiverOf p msg') \\<and>\n     enabled (last (fe index)) msg' \\<and>\n     n' < length (ft index) \\<and>\n     enabled (fe index ! n') msg' \\<and>\n     (\\<forall>n''\\<ge>n'.\n         n'' < length (ft index) \\<longrightarrow>\n         msg' \\<noteq> ft index ! n'') \\<longrightarrow>\n     OccM' \\<le> n'\n\ngoal (1 subgoal):\n 1. OccM' \\<le> OccM", "proof(cases \"OccM < length (ft index)\",auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p pa.\n       \\<lbrakk>\\<forall>n'.\n                   (\\<exists>msg'.\n                       (\\<exists>p. isReceiverOf p msg') \\<and>\n                       enabled (last (fe index)) msg' \\<and>\n                       n' < length (ft index) \\<and>\n                       enabled (fe index ! n') msg' \\<and>\n                       (\\<forall>n''\\<ge>n'.\n                           n'' < length (ft index) \\<longrightarrow>\n                           msg' \\<noteq> ft index ! n'')) \\<longrightarrow>\n                   OccM' \\<le> n';\n        \\<not> OccM < length (ft index); enabled (last (fe index)) msg';\n        OccM' < length (fe index); enabled (fe index ! OccM') msg';\n        \\<forall>n'\\<ge>OccM'.\n           n' < length (ft index) \\<longrightarrow>\n           msg' \\<noteq> ft index ! n';\n        isReceiverOf p msg'; isReceiverOf pa msg;\n        enabled (last (fe index)) msg;\n        enabled (fe index ! OccM) msg\\<rbrakk>\n       \\<Longrightarrow> OccM' \\<le> OccM", "assume \"\\<not> OccM < length (ft index)\""], ["proof (state)\nthis:\n  \\<not> OccM < length (ft index)\n\ngoal (1 subgoal):\n 1. \\<And>p pa.\n       \\<lbrakk>\\<forall>n'.\n                   (\\<exists>msg'.\n                       (\\<exists>p. isReceiverOf p msg') \\<and>\n                       enabled (last (fe index)) msg' \\<and>\n                       n' < length (ft index) \\<and>\n                       enabled (fe index ! n') msg' \\<and>\n                       (\\<forall>n''\\<ge>n'.\n                           n'' < length (ft index) \\<longrightarrow>\n                           msg' \\<noteq> ft index ! n'')) \\<longrightarrow>\n                   OccM' \\<le> n';\n        \\<not> OccM < length (ft index); enabled (last (fe index)) msg';\n        OccM' < length (fe index); enabled (fe index ! OccM') msg';\n        \\<forall>n'\\<ge>OccM'.\n           n' < length (ft index) \\<longrightarrow>\n           msg' \\<noteq> ft index ! n';\n        isReceiverOf p msg'; isReceiverOf pa msg;\n        enabled (last (fe index)) msg;\n        enabled (fe index ! OccM) msg\\<rbrakk>\n       \\<Longrightarrow> OccM' \\<le> OccM", "hence \"OccM \\<ge> length (fe index) - 1\""], ["proof (prove)\nusing this:\n  \\<not> OccM < length (ft index)\n\ngoal (1 subgoal):\n 1. length (fe index) - 1 \\<le> OccM", "using AssumptionFair(1)"], ["proof (prove)\nusing this:\n  \\<not> OccM < length (ft index)\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n\ngoal (1 subgoal):\n 1. length (fe index) - 1 \\<le> OccM", "by (metis One_nat_def leI)"], ["proof (state)\nthis:\n  length (fe index) - 1 \\<le> OccM\n\ngoal (1 subgoal):\n 1. \\<And>p pa.\n       \\<lbrakk>\\<forall>n'.\n                   (\\<exists>msg'.\n                       (\\<exists>p. isReceiverOf p msg') \\<and>\n                       enabled (last (fe index)) msg' \\<and>\n                       n' < length (ft index) \\<and>\n                       enabled (fe index ! n') msg' \\<and>\n                       (\\<forall>n''\\<ge>n'.\n                           n'' < length (ft index) \\<longrightarrow>\n                           msg' \\<noteq> ft index ! n'')) \\<longrightarrow>\n                   OccM' \\<le> n';\n        \\<not> OccM < length (ft index); enabled (last (fe index)) msg';\n        OccM' < length (fe index); enabled (fe index ! OccM') msg';\n        \\<forall>n'\\<ge>OccM'.\n           n' < length (ft index) \\<longrightarrow>\n           msg' \\<noteq> ft index ! n';\n        isReceiverOf p msg'; isReceiverOf pa msg;\n        enabled (last (fe index)) msg;\n        enabled (fe index ! OccM) msg\\<rbrakk>\n       \\<Longrightarrow> OccM' \\<le> OccM", "hence \"OccM = length (fe index) - 1\""], ["proof (prove)\nusing this:\n  length (fe index) - 1 \\<le> OccM\n\ngoal (1 subgoal):\n 1. OccM = length (fe index) - 1", "using AssumpOccMFirstOccurrence(3)"], ["proof (prove)\nusing this:\n  length (fe index) - 1 \\<le> OccM\n  OccM < length (fe index)\n\ngoal (1 subgoal):\n 1. OccM = length (fe index) - 1", "by simp"], ["proof (state)\nthis:\n  OccM = length (fe index) - 1\n\ngoal (1 subgoal):\n 1. \\<And>p pa.\n       \\<lbrakk>\\<forall>n'.\n                   (\\<exists>msg'.\n                       (\\<exists>p. isReceiverOf p msg') \\<and>\n                       enabled (last (fe index)) msg' \\<and>\n                       n' < length (ft index) \\<and>\n                       enabled (fe index ! n') msg' \\<and>\n                       (\\<forall>n''\\<ge>n'.\n                           n'' < length (ft index) \\<longrightarrow>\n                           msg' \\<noteq> ft index ! n'')) \\<longrightarrow>\n                   OccM' \\<le> n';\n        \\<not> OccM < length (ft index); enabled (last (fe index)) msg';\n        OccM' < length (fe index); enabled (fe index ! OccM') msg';\n        \\<forall>n'\\<ge>OccM'.\n           n' < length (ft index) \\<longrightarrow>\n           msg' \\<noteq> ft index ! n';\n        isReceiverOf p msg'; isReceiverOf pa msg;\n        enabled (last (fe index)) msg;\n        enabled (fe index ! OccM) msg\\<rbrakk>\n       \\<Longrightarrow> OccM' \\<le> OccM", "thus \"OccM' \\<le> OccM\""], ["proof (prove)\nusing this:\n  OccM = length (fe index) - 1\n\ngoal (1 subgoal):\n 1. OccM' \\<le> OccM", "using OccM'(3)"], ["proof (prove)\nusing this:\n  OccM = length (fe index) - 1\n  OccM' < length (fe index)\n\ngoal (1 subgoal):\n 1. OccM' \\<le> OccM", "by simp"], ["proof (state)\nthis:\n  OccM' \\<le> OccM\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  OccM' \\<le> OccM\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>msg OccM.\n     execution.firstOccurrence (fe index) (ft index) msg\n      OccM \\<longrightarrow>\n     OccM' \\<le> OccM\n\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       \\<exists>OccM'.\n          execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n          (\\<forall>msg OccM.\n              execution.firstOccurrence (fe index) (ft index) msg\n               OccM \\<longrightarrow>\n              OccM' \\<le> OccM)", "with FirstOccMsg'"], ["proof (chain)\npicking this:\n  execution.firstOccurrence (fe index) (ft index) msg' OccM'\n  \\<forall>msg OccM.\n     execution.firstOccurrence (fe index) (ft index) msg\n      OccM \\<longrightarrow>\n     OccM' \\<le> OccM", "show \"\\<exists>OccM'. \n                execution.firstOccurrence (fe index) (ft index) \n                  msg' OccM' \n                \\<and> (\\<forall>msg OccM. execution.firstOccurrence (fe index) \n                  (ft index) msg OccM \\<longrightarrow> OccM' \\<le> OccM)\""], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe index) (ft index) msg' OccM'\n  \\<forall>msg OccM.\n     execution.firstOccurrence (fe index) (ft index) msg\n      OccM \\<longrightarrow>\n     OccM' \\<le> OccM\n\ngoal (1 subgoal):\n 1. \\<exists>OccM'.\n       execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n       (\\<forall>msg OccM.\n           execution.firstOccurrence (fe index) (ft index) msg\n            OccM \\<longrightarrow>\n           OccM' \\<le> OccM)", "by blast"], ["proof (state)\nthis:\n  \\<exists>OccM'.\n     execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n     (\\<forall>msg OccM.\n         execution.firstOccurrence (fe index) (ft index) msg\n          OccM \\<longrightarrow>\n         OccM' \\<le> OccM)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execution.minimalEnabled (fe index) (ft index) ?msg' \\<longrightarrow>\n  (\\<exists>OccM'.\n      execution.firstOccurrence (fe index) (ft index) ?msg' OccM' \\<and>\n      (\\<forall>msg OccM.\n          execution.firstOccurrence (fe index) (ft index) msg\n           OccM \\<longrightarrow>\n          OccM' \\<le> OccM))\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "have MinImplFirstOcc: \"\\<And> msg' . execution.minimalEnabled \n              (fe index) (ft index) msg' \n              \\<Longrightarrow> msg' \\<in> firstOccSet index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       msg' \\<in> firstOccSet index", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       msg' \\<in> firstOccSet index", "fix msg'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       msg' \\<in> firstOccSet index", "assume AssumpMinImplFirstOcc: \n                \"execution.minimalEnabled (fe index) (ft index) msg'\""], ["proof (state)\nthis:\n  execution.minimalEnabled (fe index) (ft index) msg'\n\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       msg' \\<in> firstOccSet index", "then"], ["proof (chain)\npicking this:\n  execution.minimalEnabled (fe index) (ft index) msg'", "obtain OccM' where OccM': \n                \"execution.firstOccurrence (fe index) (ft index) \n                  msg' OccM'\"\n                \"\\<forall> msg . \\<forall> OccM . execution.firstOccurrence \n                (fe index) (ft index) msg OccM \n              \\<longrightarrow> OccM' \\<le> OccM\""], ["proof (prove)\nusing this:\n  execution.minimalEnabled (fe index) (ft index) msg'\n\ngoal (1 subgoal):\n 1. (\\<And>OccM'.\n        \\<lbrakk>execution.firstOccurrence (fe index) (ft index) msg' OccM';\n         \\<forall>msg OccM.\n            execution.firstOccurrence (fe index) (ft index) msg\n             OccM \\<longrightarrow>\n            OccM' \\<le> OccM\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using MinImplAllBigger"], ["proof (prove)\nusing this:\n  execution.minimalEnabled (fe index) (ft index) msg'\n  execution.minimalEnabled (fe index) (ft index) ?msg' \\<longrightarrow>\n  (\\<exists>OccM'.\n      execution.firstOccurrence (fe index) (ft index) ?msg' OccM' \\<and>\n      (\\<forall>msg OccM.\n          execution.firstOccurrence (fe index) (ft index) msg\n           OccM \\<longrightarrow>\n          OccM' \\<le> OccM))\n\ngoal (1 subgoal):\n 1. (\\<And>OccM'.\n        \\<lbrakk>execution.firstOccurrence (fe index) (ft index) msg' OccM';\n         \\<forall>msg OccM.\n            execution.firstOccurrence (fe index) (ft index) msg\n             OccM \\<longrightarrow>\n            OccM' \\<le> OccM\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution.firstOccurrence (fe index) (ft index) msg' OccM'\n  \\<forall>msg OccM.\n     execution.firstOccurrence (fe index) (ft index) msg\n      OccM \\<longrightarrow>\n     OccM' \\<le> OccM\n\ngoal (1 subgoal):\n 1. \\<And>msg'.\n       execution.minimalEnabled (fe index) (ft index) msg' \\<Longrightarrow>\n       msg' \\<in> firstOccSet index", "thus \"msg' \\<in> firstOccSet index\""], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe index) (ft index) msg' OccM'\n  \\<forall>msg OccM.\n     execution.firstOccurrence (fe index) (ft index) msg\n      OccM \\<longrightarrow>\n     OccM' \\<le> OccM\n\ngoal (1 subgoal):\n 1. msg' \\<in> firstOccSet index", "using OccM'"], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe index) (ft index) msg' OccM'\n  \\<forall>msg OccM.\n     execution.firstOccurrence (fe index) (ft index) msg\n      OccM \\<longrightarrow>\n     OccM' \\<le> OccM\n  execution.firstOccurrence (fe index) (ft index) msg' OccM'\n  \\<forall>msg OccM.\n     execution.firstOccurrence (fe index) (ft index) msg\n      OccM \\<longrightarrow>\n     OccM' \\<le> OccM\n\ngoal (1 subgoal):\n 1. msg' \\<in> firstOccSet index", "proof (auto simp add: firstOccSet_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>execution.firstOccurrence (fe index) (ft index) msg' OccM';\n     \\<forall>msg OccM.\n        execution.firstOccurrence (fe index) (ft index) msg\n         OccM \\<longrightarrow>\n        OccM' \\<le> OccM\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nMsg n1.\n                         n1 \\<le> nMsg \\<and>\n                         execution.firstOccurrence (fe index) (ft index)\n                          msg' n1 \\<and>\n                         execution.firstOccurrence (fe index) (ft index) msg\n                          nMsg", "have \"enabled (last (fe index)) msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled (last (fe index)) msg", "using AssumptionFirstOccSetDecrOrConsumed(1)"], ["proof (prove)\nusing this:\n  enabled (last (fe index)) msg\n\ngoal (1 subgoal):\n 1. enabled (last (fe index)) msg", "by blast"], ["proof (state)\nthis:\n  enabled (last (fe index)) msg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>execution.firstOccurrence (fe index) (ft index) msg' OccM';\n     \\<forall>msg OccM.\n        execution.firstOccurrence (fe index) (ft index) msg\n         OccM \\<longrightarrow>\n        OccM' \\<le> OccM\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nMsg n1.\n                         n1 \\<le> nMsg \\<and>\n                         execution.firstOccurrence (fe index) (ft index)\n                          msg' n1 \\<and>\n                         execution.firstOccurrence (fe index) (ft index) msg\n                          nMsg", "hence \"\\<exists>nMsg .  execution.firstOccurrence (fe index) \n                  (ft index) msg nMsg\""], ["proof (prove)\nusing this:\n  enabled (last (fe index)) msg\n\ngoal (1 subgoal):\n 1. \\<exists>nMsg. execution.firstOccurrence (fe index) (ft index) msg nMsg", "using execution.FirstOccurrenceExists IndexIsExec \n                  AssumptionFair(4)"], ["proof (prove)\nusing this:\n  enabled (last (fe index)) msg\n  \\<lbrakk>execution ?trans ?sends ?start ?exec ?trace;\n   enabled (last ?exec) ?msg; \\<exists>p. isReceiverOf p ?msg\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n.\n                       execution.firstOccurrence ?exec ?trace ?msg n\n  execution trans sends start (fe index) (ft index)\n  isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<exists>nMsg. execution.firstOccurrence (fe index) (ft index) msg nMsg", "by blast"], ["proof (state)\nthis:\n  \\<exists>nMsg. execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>execution.firstOccurrence (fe index) (ft index) msg' OccM';\n     \\<forall>msg OccM.\n        execution.firstOccurrence (fe index) (ft index) msg\n         OccM \\<longrightarrow>\n        OccM' \\<le> OccM\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nMsg n1.\n                         n1 \\<le> nMsg \\<and>\n                         execution.firstOccurrence (fe index) (ft index)\n                          msg' n1 \\<and>\n                         execution.firstOccurrence (fe index) (ft index) msg\n                          nMsg", "then"], ["proof (chain)\npicking this:\n  \\<exists>nMsg. execution.firstOccurrence (fe index) (ft index) msg nMsg", "obtain nMsg where NMsg: \"execution.firstOccurrence\n                  (fe index) (ft index) msg nMsg\""], ["proof (prove)\nusing this:\n  \\<exists>nMsg. execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal (1 subgoal):\n 1. (\\<And>nMsg.\n        execution.firstOccurrence (fe index) (ft index) msg\n         nMsg \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>execution.firstOccurrence (fe index) (ft index) msg' OccM';\n     \\<forall>msg OccM.\n        execution.firstOccurrence (fe index) (ft index) msg\n         OccM \\<longrightarrow>\n        OccM' \\<le> OccM\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nMsg n1.\n                         n1 \\<le> nMsg \\<and>\n                         execution.firstOccurrence (fe index) (ft index)\n                          msg' n1 \\<and>\n                         execution.firstOccurrence (fe index) (ft index) msg\n                          nMsg", "hence \"OccM' \\<le> nMsg\""], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal (1 subgoal):\n 1. OccM' \\<le> nMsg", "using OccM'"], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe index) (ft index) msg nMsg\n  execution.firstOccurrence (fe index) (ft index) msg' OccM'\n  \\<forall>msg OccM.\n     execution.firstOccurrence (fe index) (ft index) msg\n      OccM \\<longrightarrow>\n     OccM' \\<le> OccM\n\ngoal (1 subgoal):\n 1. OccM' \\<le> nMsg", "by simp"], ["proof (state)\nthis:\n  OccM' \\<le> nMsg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>execution.firstOccurrence (fe index) (ft index) msg' OccM';\n     \\<forall>msg OccM.\n        execution.firstOccurrence (fe index) (ft index) msg\n         OccM \\<longrightarrow>\n        OccM' \\<le> OccM\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nMsg n1.\n                         n1 \\<le> nMsg \\<and>\n                         execution.firstOccurrence (fe index) (ft index)\n                          msg' n1 \\<and>\n                         execution.firstOccurrence (fe index) (ft index) msg\n                          nMsg", "hence \"\\<exists>nMsg . OccM' \\<le> nMsg \\<and>\n                  execution.firstOccurrence (fe index) (ft index) msg'\n                    OccM' \\<and>\n                  execution.firstOccurrence (fe index) (ft index) msg \n                    nMsg\""], ["proof (prove)\nusing this:\n  OccM' \\<le> nMsg\n\ngoal (1 subgoal):\n 1. \\<exists>nMsg\\<ge>OccM'.\n       execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n       execution.firstOccurrence (fe index) (ft index) msg nMsg", "using OccM'(1) NMsg"], ["proof (prove)\nusing this:\n  OccM' \\<le> nMsg\n  execution.firstOccurrence (fe index) (ft index) msg' OccM'\n  execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal (1 subgoal):\n 1. \\<exists>nMsg\\<ge>OccM'.\n       execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n       execution.firstOccurrence (fe index) (ft index) msg nMsg", "by blast"], ["proof (state)\nthis:\n  \\<exists>nMsg\\<ge>OccM'.\n     execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n     execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>execution.firstOccurrence (fe index) (ft index) msg' OccM';\n     \\<forall>msg OccM.\n        execution.firstOccurrence (fe index) (ft index) msg\n         OccM \\<longrightarrow>\n        OccM' \\<le> OccM\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nMsg n1.\n                         n1 \\<le> nMsg \\<and>\n                         execution.firstOccurrence (fe index) (ft index)\n                          msg' n1 \\<and>\n                         execution.firstOccurrence (fe index) (ft index) msg\n                          nMsg", "thus \"\\<exists>nMsg n1 . n1 \\<le> nMsg \\<and>\n                  execution.firstOccurrence (fe index) (ft index) \n                    msg' n1 \\<and>\n                  execution.firstOccurrence (fe index) (ft index) \n                    msg nMsg\""], ["proof (prove)\nusing this:\n  \\<exists>nMsg\\<ge>OccM'.\n     execution.firstOccurrence (fe index) (ft index) msg' OccM' \\<and>\n     execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal (1 subgoal):\n 1. \\<exists>nMsg n1.\n       n1 \\<le> nMsg \\<and>\n       execution.firstOccurrence (fe index) (ft index) msg' n1 \\<and>\n       execution.firstOccurrence (fe index) (ft index) msg nMsg", "by blast"], ["proof (state)\nthis:\n  \\<exists>nMsg n1.\n     n1 \\<le> nMsg \\<and>\n     execution.firstOccurrence (fe index) (ft index) msg' n1 \\<and>\n     execution.firstOccurrence (fe index) (ft index) msg nMsg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  msg' \\<in> firstOccSet index\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execution.minimalEnabled (fe index) (ft index) ?msg' \\<Longrightarrow>\n  ?msg' \\<in> firstOccSet index\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "hence ConsumedInSet: \"consumedMsg \\<in> firstOccSet index\""], ["proof (prove)\nusing this:\n  execution.minimalEnabled (fe index) (ft index) ?msg' \\<Longrightarrow>\n  ?msg' \\<in> firstOccSet index\n\ngoal (1 subgoal):\n 1. consumedMsg \\<in> firstOccSet index", "using ConsumedMsg"], ["proof (prove)\nusing this:\n  execution.minimalEnabled (fe index) (ft index) ?msg' \\<Longrightarrow>\n  ?msg' \\<in> firstOccSet index\n  execution.minimalEnabled (fe index) (ft index) consumedMsg\n  consumedMsg\n  \\<in> set (drop (length (ft index)) (fStepMsg (fe index) (ft index)))\n\ngoal (1 subgoal):\n 1. consumedMsg \\<in> firstOccSet index", "by simp"], ["proof (state)\nthis:\n  consumedMsg \\<in> firstOccSet index\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "have GreaterOccurrence: \"\\<And> nMsg n1 . \n                execution.firstOccurrence (fe (Suc index)) \n                  (ft (Suc index)) consumedMsg n1 \\<and> \n                execution.firstOccurrence (fe (Suc index)) \n                  (ft (Suc index)) msg nMsg \n                \\<Longrightarrow> nMsg < n1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n        consumedMsg n1 \\<and>\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n        nMsg \\<Longrightarrow>\n       nMsg < n1", "proof(rule ccontr,auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       \\<lbrakk>\\<not> nMsg < n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n         consumedMsg n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> False", "fix nMsg n1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       \\<lbrakk>\\<not> nMsg < n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n         consumedMsg n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> False", "assume AssumpGreaterOccurrence: \"\\<not> nMsg < n1\"\n                \"execution.firstOccurrence (fe (Suc index)) \n                  (ft (Suc index)) consumedMsg n1\"\n                \"execution.firstOccurrence (fe (Suc index)) \n                  (ft (Suc index)) msg nMsg\""], ["proof (state)\nthis:\n  \\<not> nMsg < n1\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) consumedMsg n1\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       \\<lbrakk>\\<not> nMsg < n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n         consumedMsg n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> False", "have \"nMsg < length (fe index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nMsg < length (fe index)", "using SmallIndex AssumpGreaterOccurrence(3)"], ["proof (prove)\nusing this:\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   ?nMsg \\<Longrightarrow>\n  ?nMsg < length (fe index)\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n\ngoal (1 subgoal):\n 1. nMsg < length (fe index)", "by simp"], ["proof (state)\nthis:\n  nMsg < length (fe index)\n\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       \\<lbrakk>\\<not> nMsg < n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n         consumedMsg n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"n1 < length (fe index)\""], ["proof (prove)\nusing this:\n  nMsg < length (fe index)\n\ngoal (1 subgoal):\n 1. n1 < length (fe index)", "using AssumpGreaterOccurrence(1)"], ["proof (prove)\nusing this:\n  nMsg < length (fe index)\n  \\<not> nMsg < n1\n\ngoal (1 subgoal):\n 1. n1 < length (fe index)", "by (metis less_trans nat_neq_iff)"], ["proof (state)\nthis:\n  n1 < length (fe index)\n\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       \\<lbrakk>\\<not> nMsg < n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n         consumedMsg n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> False", "hence N1Small: \"n1 \\<le> length (ft index)\""], ["proof (prove)\nusing this:\n  n1 < length (fe index)\n\ngoal (1 subgoal):\n 1. n1 \\<le> length (ft index)", "using IndexIsExec AssumptionFair(1)"], ["proof (prove)\nusing this:\n  n1 < length (fe index)\n  execution trans sends start (fe index) (ft index)\n  \\<forall>n.\n     initReachable (last (fe n)) \\<and>\n     \\<not> vUniform False (last (fe n)) \\<and>\n     \\<not> vUniform True (last (fe n)) \\<and>\n     prefixList (fe n) (fe (Suc n)) \\<and>\n     prefixList (ft n) (ft (Suc n)) \\<and>\n     Suc 0 \\<le> length (fe n) \\<and>\n     length (fe n) - Suc 0 = length (ft n) \\<and>\n     initial (hd (fe n)) \\<and>\n     (\\<forall>i<length (fe n) - Suc 0.\n         fe n ! i \\<turnstile> ft n ! i \\<mapsto> fe n ! Suc i) \\<and>\n     initial (hd (fe (Suc n)))\n\ngoal (1 subgoal):\n 1. n1 \\<le> length (ft index)", "by (metis  One_nat_def Suc_eq_plus1 le_diff_conv2 \n                  not_le not_less_eq_eq)"], ["proof (state)\nthis:\n  n1 \\<le> length (ft index)\n\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       \\<lbrakk>\\<not> nMsg < n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n         consumedMsg n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> False", "have NotConsumed: \"\\<forall> i \\<ge> n1 . i < length (ft (Suc index))\n                \\<longrightarrow> consumedMsg \\<noteq> (ft (Suc index)) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>n1.\n       i < length (ft (Suc index)) \\<longrightarrow>\n       consumedMsg \\<noteq> ft (Suc index) ! i", "using execution.firstOccurrence_def[of \"trans\" \"sends\"\n                  \"start\" \"fe (Suc index)\" \"ft (Suc index)\" \n                  \"consumedMsg\" \"n1\"]\n                  AssumpGreaterOccurrence(2) SucIndexIsExec"], ["proof (prove)\nusing this:\n  execution trans sends start (fe (Suc index))\n   (ft (Suc index)) \\<Longrightarrow>\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) consumedMsg\n   n1 \\<equiv>\n  (\\<exists>p. isReceiverOf p consumedMsg) \\<and>\n  enabled (last (fe (Suc index))) consumedMsg \\<and>\n  n1 < length (fe (Suc index)) \\<and>\n  enabled (fe (Suc index) ! n1) consumedMsg \\<and>\n  (\\<forall>n'\\<ge>n1.\n      n' < length (ft (Suc index)) \\<longrightarrow>\n      consumedMsg \\<noteq> ft (Suc index) ! n') \\<and>\n  (n1 \\<noteq> 0 \\<longrightarrow>\n   \\<not> enabled (fe (Suc index) ! (n1 - 1)) consumedMsg \\<or>\n   consumedMsg = ft (Suc index) ! (n1 - 1))\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) consumedMsg n1\n  execution trans sends start (fe (Suc index)) (ft (Suc index))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>n1.\n       i < length (ft (Suc index)) \\<longrightarrow>\n       consumedMsg \\<noteq> ft (Suc index) ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<ge>n1.\n     i < length (ft (Suc index)) \\<longrightarrow>\n     consumedMsg \\<noteq> ft (Suc index) ! i\n\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       \\<lbrakk>\\<not> nMsg < n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n         consumedMsg n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<exists> i \\<ge> length (ft index) . \n                i < length (ft (Suc index)) \n                \\<and> consumedMsg = (ft (Suc index)) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<ge>length (ft index).\n       i < length (ft (Suc index)) \\<and> consumedMsg = ft (Suc index) ! i", "using DropToIndex[of \"consumedMsg\" \"length (ft index)\"]\n                ConsumedIsInDrop"], ["proof (prove)\nusing this:\n  consumedMsg \\<in> set (drop (length (ft index)) ?liste) \\<Longrightarrow>\n  \\<exists>i\\<ge>length (ft index).\n     i < length ?liste \\<and> consumedMsg = ?liste ! i\n  consumedMsg \\<in> set (drop (length (ft index)) (ft (Suc index)))\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<ge>length (ft index).\n       i < length (ft (Suc index)) \\<and> consumedMsg = ft (Suc index) ! i", "by simp"], ["proof (state)\nthis:\n  \\<exists>i\\<ge>length (ft index).\n     i < length (ft (Suc index)) \\<and> consumedMsg = ft (Suc index) ! i\n\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       \\<lbrakk>\\<not> nMsg < n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n         consumedMsg n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>i\\<ge>length (ft index).\n     i < length (ft (Suc index)) \\<and> consumedMsg = ft (Suc index) ! i", "obtain i where IDef: \"i \\<ge> length (ft index)\"\n                \"i < length (ft (Suc index))\" \n                \"consumedMsg = (ft (Suc index)) ! i\""], ["proof (prove)\nusing this:\n  \\<exists>i\\<ge>length (ft index).\n     i < length (ft (Suc index)) \\<and> consumedMsg = ft (Suc index) ! i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>length (ft index) \\<le> i; i < length (ft (Suc index));\n         consumedMsg = ft (Suc index) ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length (ft index) \\<le> i\n  i < length (ft (Suc index))\n  consumedMsg = ft (Suc index) ! i\n\ngoal (1 subgoal):\n 1. \\<And>nMsg n1.\n       \\<lbrakk>\\<not> nMsg < n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n         consumedMsg n1;\n        execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n         nMsg\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  length (ft index) \\<le> i\n  i < length (ft (Suc index))\n  consumedMsg = ft (Suc index) ! i\n\ngoal (1 subgoal):\n 1. False", "using NotConsumed N1Small"], ["proof (prove)\nusing this:\n  length (ft index) \\<le> i\n  i < length (ft (Suc index))\n  consumedMsg = ft (Suc index) ! i\n  \\<forall>i\\<ge>n1.\n     i < length (ft (Suc index)) \\<longrightarrow>\n     consumedMsg \\<noteq> ft (Suc index) ! i\n  n1 \\<le> length (ft index)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) consumedMsg\n   ?n1.0 \\<and>\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   ?nMsg \\<Longrightarrow>\n  ?nMsg < ?n1.0\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "have \"consumedMsg \\<notin> firstOccSet (Suc index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consumedMsg \\<notin> firstOccSet (Suc index)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. consumedMsg \\<in> firstOccSet (Suc index) \\<Longrightarrow> False", "assume AssumpConsumedInSucSet: \n                \"consumedMsg \\<in> firstOccSet (Suc index)\""], ["proof (state)\nthis:\n  consumedMsg \\<in> firstOccSet (Suc index)\n\ngoal (1 subgoal):\n 1. consumedMsg \\<in> firstOccSet (Suc index) \\<Longrightarrow> False", "hence \"\\<exists>nMsg n1. n1 \\<le> nMsg \\<and>\n                  execution.firstOccurrence (fe (Suc index)) \n                    (ft (Suc index)) consumedMsg n1 \\<and> \n                  execution.firstOccurrence (fe (Suc index)) \n                    (ft (Suc index)) msg nMsg\""], ["proof (prove)\nusing this:\n  consumedMsg \\<in> firstOccSet (Suc index)\n\ngoal (1 subgoal):\n 1. \\<exists>nMsg n1.\n       n1 \\<le> nMsg \\<and>\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n        consumedMsg n1 \\<and>\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg", "using firstOccSet_def"], ["proof (prove)\nusing this:\n  consumedMsg \\<in> firstOccSet (Suc index)\n  firstOccSet ?n =\n  {msg1.\n   \\<exists>nMsg n1.\n      n1 \\<le> nMsg \\<and>\n      execution.firstOccurrence (fe ?n) (ft ?n) msg1 n1 \\<and>\n      execution.firstOccurrence (fe ?n) (ft ?n) msg nMsg}\n\ngoal (1 subgoal):\n 1. \\<exists>nMsg n1.\n       n1 \\<le> nMsg \\<and>\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index))\n        consumedMsg n1 \\<and>\n       execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg", "by blast"], ["proof (state)\nthis:\n  \\<exists>nMsg n1.\n     n1 \\<le> nMsg \\<and>\n     execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) consumedMsg\n      n1 \\<and>\n     execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n\ngoal (1 subgoal):\n 1. consumedMsg \\<in> firstOccSet (Suc index) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>nMsg n1.\n     n1 \\<le> nMsg \\<and>\n     execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) consumedMsg\n      n1 \\<and>\n     execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n\ngoal (1 subgoal):\n 1. False", "using GreaterOccurrence"], ["proof (prove)\nusing this:\n  \\<exists>nMsg n1.\n     n1 \\<le> nMsg \\<and>\n     execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) consumedMsg\n      n1 \\<and>\n     execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg nMsg\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) consumedMsg\n   ?n1.0 \\<and>\n  execution.firstOccurrence (fe (Suc index)) (ft (Suc index)) msg\n   ?nMsg \\<Longrightarrow>\n  ?nMsg < ?n1.0\n\ngoal (1 subgoal):\n 1. False", "by (metis less_le_trans less_not_refl3)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  consumedMsg \\<notin> firstOccSet (Suc index)\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "thus ?thesis"], ["proof (prove)\nusing this:\n  consumedMsg \\<notin> firstOccSet (Suc index)\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "using ConsumedInSet"], ["proof (prove)\nusing this:\n  consumedMsg \\<notin> firstOccSet (Suc index)\n  consumedMsg \\<in> firstOccSet index\n\ngoal (1 subgoal):\n 1. \\<exists>msg'.\n       msg' \\<in> firstOccSet index \\<and>\n       msg' \\<notin> firstOccSet (Suc index)", "by blast"], ["proof (state)\nthis:\n  \\<exists>msg'.\n     msg' \\<in> firstOccSet index \\<and>\n     msg' \\<notin> firstOccSet (Suc index)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>msg'.\n     msg' \\<in> firstOccSet index \\<and>\n     msg' \\<notin> firstOccSet (Suc index)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "hence \"firstOccSet (Suc index) \\<subset> firstOccSet index\""], ["proof (prove)\nusing this:\n  \\<exists>msg'.\n     msg' \\<in> firstOccSet index \\<and>\n     msg' \\<notin> firstOccSet (Suc index)\n\ngoal (1 subgoal):\n 1. firstOccSet (Suc index) \\<subset> firstOccSet index", "using Subset"], ["proof (prove)\nusing this:\n  \\<exists>msg'.\n     msg' \\<in> firstOccSet index \\<and>\n     msg' \\<notin> firstOccSet (Suc index)\n  ?msgInSet \\<in> firstOccSet (Suc index) \\<Longrightarrow>\n  ?msgInSet \\<in> firstOccSet index\n\ngoal (1 subgoal):\n 1. firstOccSet (Suc index) \\<subset> firstOccSet index", "by blast"], ["proof (state)\nthis:\n  firstOccSet (Suc index) \\<subset> firstOccSet index\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>enabled (last (fe index)) msg;\n        msg\n        \\<notin> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> firstOccSet (Suc index)\n                         \\<subset> firstOccSet index \\<and>\n                         enabled (last (fe (Suc index))) msg", "thus \"firstOccSet (Suc index) \\<subset> firstOccSet index \n            \\<and> enabled (last (fe (Suc index))) msg\""], ["proof (prove)\nusing this:\n  firstOccSet (Suc index) \\<subset> firstOccSet index\n\ngoal (1 subgoal):\n 1. firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n    enabled (last (fe (Suc index))) msg", "using EnabledInSuc"], ["proof (prove)\nusing this:\n  firstOccSet (Suc index) \\<subset> firstOccSet index\n  enabled (last (fe (Suc index))) msg\n\ngoal (1 subgoal):\n 1. firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n    enabled (last (fe (Suc index))) msg", "by blast"], ["proof (state)\nthis:\n  firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n  enabled (last (fe (Suc index))) msg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>index.\n     enabled (last (fe index)) msg \\<longrightarrow>\n     firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n     enabled (last (fe (Suc index))) msg \\<or>\n     msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "have NotConsumed: \"\\<forall> index \\<ge> n . \\<not> msg \\<in> \n          (set (drop (length (ft index)) (ft (Suc index))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>index\\<ge>n.\n       msg \\<notin> set (drop (length (ft index)) (ft (Suc index)))", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>n \\<le> index;\n        msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> False", "fix index"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>n \\<le> index;\n        msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> False", "assume AssumpMsgNotConsumed: \"n \\<le> index\" \n            \"msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\""], ["proof (state)\nthis:\n  n \\<le> index\n  msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>n \\<le> index;\n        msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<exists> n0' \\<ge> length (ft index) . \n            n0' < length (ft (Suc index)) \n            \\<and> msg = (ft (Suc index)) ! n0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n0'\\<ge>length (ft index).\n       n0' < length (ft (Suc index)) \\<and> msg = ft (Suc index) ! n0'", "using AssumpMsgNotConsumed(2) DropToIndex[of \"msg\" \n              \"length (ft index)\" \"ft (Suc index)\"]"], ["proof (prove)\nusing this:\n  msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\n  msg\n  \\<in> set (drop (length (ft index)) (ft (Suc index))) \\<Longrightarrow>\n  \\<exists>i\\<ge>length (ft index).\n     i < length (ft (Suc index)) \\<and> msg = ft (Suc index) ! i\n\ngoal (1 subgoal):\n 1. \\<exists>n0'\\<ge>length (ft index).\n       n0' < length (ft (Suc index)) \\<and> msg = ft (Suc index) ! n0'", "by auto"], ["proof (state)\nthis:\n  \\<exists>n0'\\<ge>length (ft index).\n     n0' < length (ft (Suc index)) \\<and> msg = ft (Suc index) ! n0'\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>n \\<le> index;\n        msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>n0'\\<ge>length (ft index).\n     n0' < length (ft (Suc index)) \\<and> msg = ft (Suc index) ! n0'", "obtain n0' where MessageIndex: \"n0' \\<ge> length (ft index)\" \n            \"n0' < length (ft (Suc index))\" \n            \"msg = (ft (Suc index)) ! n0'\""], ["proof (prove)\nusing this:\n  \\<exists>n0'\\<ge>length (ft index).\n     n0' < length (ft (Suc index)) \\<and> msg = ft (Suc index) ! n0'\n\ngoal (1 subgoal):\n 1. (\\<And>n0'.\n        \\<lbrakk>length (ft index) \\<le> n0'; n0' < length (ft (Suc index));\n         msg = ft (Suc index) ! n0'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length (ft index) \\<le> n0'\n  n0' < length (ft (Suc index))\n  msg = ft (Suc index) ! n0'\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>n \\<le> index;\n        msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> False", "have LengthIncreasing: \"length (ft n) \\<le> length (ft index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ft n) \\<le> length (ft index)", "using AssumpMsgNotConsumed(1)"], ["proof (prove)\nusing this:\n  n \\<le> index\n\ngoal (1 subgoal):\n 1. length (ft n) \\<le> length (ft index)", "proof(induct index,auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>n \\<le> indexa \\<Longrightarrow>\n                length (ft n) \\<le> length (ft indexa);\n        n \\<le> Suc indexa; n \\<le> index\\<rbrakk>\n       \\<Longrightarrow> length (ft n) \\<le> length (ft (Suc indexa))", "fix indexa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>n \\<le> indexa \\<Longrightarrow>\n                length (ft n) \\<le> length (ft indexa);\n        n \\<le> Suc indexa; n \\<le> index\\<rbrakk>\n       \\<Longrightarrow> length (ft n) \\<le> length (ft (Suc indexa))", "assume AssumpLengthIncreasing: \n              \"n \\<le> indexa \\<Longrightarrow> length (ft n) \\<le> length (ft indexa)\" \n              \"n \\<le> Suc indexa\" \"n \\<le> index\""], ["proof (state)\nthis:\n  n \\<le> indexa \\<Longrightarrow> length (ft n) \\<le> length (ft indexa)\n  n \\<le> Suc indexa\n  n \\<le> index\n\ngoal (1 subgoal):\n 1. \\<And>indexa.\n       \\<lbrakk>n \\<le> indexa \\<Longrightarrow>\n                length (ft n) \\<le> length (ft indexa);\n        n \\<le> Suc indexa; n \\<le> index\\<rbrakk>\n       \\<Longrightarrow> length (ft n) \\<le> length (ft (Suc indexa))", "show \"length (ft n) \\<le> length (ft (Suc indexa))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ft n) \\<le> length (ft (Suc indexa))", "proof(cases \"n = Suc indexa\",auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> Suc indexa \\<Longrightarrow>\n    length (ft n) \\<le> length (ft (Suc indexa))", "assume \"n \\<noteq> Suc indexa\""], ["proof (state)\nthis:\n  n \\<noteq> Suc indexa\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc indexa \\<Longrightarrow>\n    length (ft n) \\<le> length (ft (Suc indexa))", "hence \"n \\<le> indexa\""], ["proof (prove)\nusing this:\n  n \\<noteq> Suc indexa\n\ngoal (1 subgoal):\n 1. n \\<le> indexa", "using AssumpLengthIncreasing(2)"], ["proof (prove)\nusing this:\n  n \\<noteq> Suc indexa\n  n \\<le> Suc indexa\n\ngoal (1 subgoal):\n 1. n \\<le> indexa", "by (metis le_SucE)"], ["proof (state)\nthis:\n  n \\<le> indexa\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc indexa \\<Longrightarrow>\n    length (ft n) \\<le> length (ft (Suc indexa))", "hence LengthNA: \"length (ft n) \\<le> length (ft indexa)\""], ["proof (prove)\nusing this:\n  n \\<le> indexa\n\ngoal (1 subgoal):\n 1. length (ft n) \\<le> length (ft indexa)", "using AssumpLengthIncreasing(1)"], ["proof (prove)\nusing this:\n  n \\<le> indexa\n  n \\<le> indexa \\<Longrightarrow> length (ft n) \\<le> length (ft indexa)\n\ngoal (1 subgoal):\n 1. length (ft n) \\<le> length (ft indexa)", "by blast"], ["proof (state)\nthis:\n  length (ft n) \\<le> length (ft indexa)\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc indexa \\<Longrightarrow>\n    length (ft n) \\<le> length (ft (Suc indexa))", "have PrefixIndexA: \"prefixList (ft indexa) (ft (Suc indexa))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList (ft indexa) (ft (Suc indexa))", "using BasicProperties"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. prefixList (ft indexa) (ft (Suc indexa))", "by simp"], ["proof (state)\nthis:\n  prefixList (ft indexa) (ft (Suc indexa))\n\ngoal (1 subgoal):\n 1. n \\<noteq> Suc indexa \\<Longrightarrow>\n    length (ft n) \\<le> length (ft (Suc indexa))", "show \"length (ft n) \\<le> length (ft (Suc indexa))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ft n) \\<le> length (ft (Suc indexa))", "using LengthNA PrefixListMonotonicity[OF PrefixIndexA]"], ["proof (prove)\nusing this:\n  length (ft n) \\<le> length (ft indexa)\n  length (ft indexa) < length (ft (Suc indexa))\n\ngoal (1 subgoal):\n 1. length (ft n) \\<le> length (ft (Suc indexa))", "by (metis (hide_lams, no_types) antisym le_cases \n                  less_imp_le less_le_trans)"], ["proof (state)\nthis:\n  length (ft n) \\<le> length (ft (Suc indexa))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (ft n) \\<le> length (ft (Suc indexa))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (ft n) \\<le> length (ft index)\n\ngoal (1 subgoal):\n 1. \\<And>index.\n       \\<lbrakk>n \\<le> index;\n        msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  length (ft n) \\<le> length (ft index)\n\ngoal (1 subgoal):\n 1. False", "using AssumptionFairContr MessageIndex \n            AssumpMsgNotConsumed(1)"], ["proof (prove)\nusing this:\n  length (ft n) \\<le> length (ft index)\n  \\<forall>n'\\<ge>n.\n     \\<forall>n0'<length (ft n').\n        length (ft n) \\<le> n0' \\<longrightarrow> msg \\<noteq> ft n' ! n0'\n  length (ft index) \\<le> n0'\n  n0' < length (ft (Suc index))\n  msg = ft (Suc index) ! n0'\n  n \\<le> index\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>length (ft index) \\<le> n0'\\<close> le_SucI le_trans)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>index\\<ge>n.\n     msg \\<notin> set (drop (length (ft index)) (ft (Suc index)))\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence FirstOccSetDecrImpl: \n          \"\\<forall> index \\<ge> n . (enabled (last (fe index)) msg) \n          \\<longrightarrow> firstOccSet (Suc index) \\<subset> firstOccSet index \n            \\<and> (enabled (last (fe (Suc index))) msg)\""], ["proof (prove)\nusing this:\n  \\<forall>index\\<ge>n.\n     msg \\<notin> set (drop (length (ft index)) (ft (Suc index)))\n\ngoal (1 subgoal):\n 1. \\<forall>index\\<ge>n.\n       enabled (last (fe index)) msg \\<longrightarrow>\n       firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n       enabled (last (fe (Suc index))) msg", "using FirstOccSetDecrOrConsumed"], ["proof (prove)\nusing this:\n  \\<forall>index\\<ge>n.\n     msg \\<notin> set (drop (length (ft index)) (ft (Suc index)))\n  \\<forall>index.\n     enabled (last (fe index)) msg \\<longrightarrow>\n     firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n     enabled (last (fe (Suc index))) msg \\<or>\n     msg \\<in> set (drop (length (ft index)) (ft (Suc index)))\n\ngoal (1 subgoal):\n 1. \\<forall>index\\<ge>n.\n       enabled (last (fe index)) msg \\<longrightarrow>\n       firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n       enabled (last (fe (Suc index))) msg", "by blast"], ["proof (state)\nthis:\n  \\<forall>index\\<ge>n.\n     enabled (last (fe index)) msg \\<longrightarrow>\n     firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n     enabled (last (fe (Suc index))) msg\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence FirstOccSetDecrImpl: \"\\<forall> index \\<ge> n . firstOccSet \n          (Suc index) \\<subset> firstOccSet index\""], ["proof (prove)\nusing this:\n  \\<forall>index\\<ge>n.\n     enabled (last (fe index)) msg \\<longrightarrow>\n     firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n     enabled (last (fe (Suc index))) msg\n\ngoal (1 subgoal):\n 1. \\<forall>index\\<ge>n.\n       firstOccSet (Suc index) \\<subset> firstOccSet index", "using KeepProperty[of \"n\" \"\\<lambda>x.(enabled (last (fe x)) msg)\" \n            \"\\<lambda>x.(firstOccSet (Suc x) \\<subset> firstOccSet x)\"]\n            AssumptionCase1ImplThesis'"], ["proof (prove)\nusing this:\n  \\<forall>index\\<ge>n.\n     enabled (last (fe index)) msg \\<longrightarrow>\n     firstOccSet (Suc index) \\<subset> firstOccSet index \\<and>\n     enabled (last (fe (Suc index))) msg\n  \\<lbrakk>\\<forall>i\\<ge>n.\n              enabled (last (fe i)) msg \\<longrightarrow>\n              enabled (last (fe (Suc i))) msg \\<and>\n              firstOccSet (Suc i) \\<subset> firstOccSet i;\n   enabled (last (fe n)) msg\\<rbrakk>\n  \\<Longrightarrow> \\<forall>i\\<ge>n.\n                       firstOccSet (Suc i) \\<subset> firstOccSet i\n  enabled (last (fe n)) msg\n\ngoal (1 subgoal):\n 1. \\<forall>index\\<ge>n.\n       firstOccSet (Suc index) \\<subset> firstOccSet index", "by blast"], ["proof (state)\nthis:\n  \\<forall>index\\<ge>n. firstOccSet (Suc index) \\<subset> firstOccSet index\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence FirstOccSetDecr': \"\\<forall> index \\<ge> n . \n          card (firstOccSet (Suc index)) < card (firstOccSet index)\""], ["proof (prove)\nusing this:\n  \\<forall>index\\<ge>n. firstOccSet (Suc index) \\<subset> firstOccSet index\n\ngoal (1 subgoal):\n 1. \\<forall>index\\<ge>n.\n       card (firstOccSet (Suc index)) < card (firstOccSet index)", "using FiniteMsgs psubset_card_mono"], ["proof (prove)\nusing this:\n  \\<forall>index\\<ge>n. firstOccSet (Suc index) \\<subset> firstOccSet index\n  \\<forall>n. finite (firstOccSet n)\n  \\<lbrakk>finite ?B; ?A \\<subset> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A < card ?B\n\ngoal (1 subgoal):\n 1. \\<forall>index\\<ge>n.\n       card (firstOccSet (Suc index)) < card (firstOccSet index)", "by metis"], ["proof (state)\nthis:\n  \\<forall>index\\<ge>n.\n     card (firstOccSet (Suc index)) < card (firstOccSet index)\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence \"card (firstOccSet (n + (card (firstOccSet n) + 1))) \n          \\<le> card (firstOccSet n) - (card (firstOccSet n) + 1)\""], ["proof (prove)\nusing this:\n  \\<forall>index\\<ge>n.\n     card (firstOccSet (Suc index)) < card (firstOccSet index)\n\ngoal (1 subgoal):\n 1. card (firstOccSet (n + (card (firstOccSet n) + 1)))\n    \\<le> card (firstOccSet n) - (card (firstOccSet n) + 1)", "using SmallerMultipleStepsWithLimit[of \"n\" \n            \"\\<lambda>x. card (firstOccSet x)\" \"card (firstOccSet n) + 1\"]"], ["proof (prove)\nusing this:\n  \\<forall>index\\<ge>n.\n     card (firstOccSet (Suc index)) < card (firstOccSet index)\n  \\<forall>na\\<ge>n.\n     card (firstOccSet (Suc na)) < card (firstOccSet na) \\<Longrightarrow>\n  \\<forall>na\\<ge>n.\n     card (firstOccSet (na + (card (firstOccSet n) + 1)))\n     \\<le> card (firstOccSet na) - (card (firstOccSet n) + 1)\n\ngoal (1 subgoal):\n 1. card (firstOccSet (n + (card (firstOccSet n) + 1)))\n    \\<le> card (firstOccSet n) - (card (firstOccSet n) + 1)", "by blast"], ["proof (state)\nthis:\n  card (firstOccSet (n + (card (firstOccSet n) + 1)))\n  \\<le> card (firstOccSet n) - (card (firstOccSet n) + 1)\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "hence IsNegative:\"card (firstOccSet (n + (card \n          (firstOccSet n) + 1))) < 0\""], ["proof (prove)\nusing this:\n  card (firstOccSet (n + (card (firstOccSet n) + 1)))\n  \\<le> card (firstOccSet n) - (card (firstOccSet n) + 1)\n\ngoal (1 subgoal):\n 1. card (firstOccSet (n + (card (firstOccSet n) + 1))) < 0", "by (metis FirstOccSetDecr' diff_add_zero leD le_add1 \n            less_nat_zero_code neq0_conv)"], ["proof (state)\nthis:\n  card (firstOccSet (n + (card (firstOccSet n) + 1))) < 0\n\ngoal (1 subgoal):\n 1. \\<forall>n'\\<ge>n.\n       \\<forall>n0'<length (ft n').\n          length (ft n) \\<le> n0' \\<longrightarrow>\n          msg \\<noteq> ft n' ! n0' \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  card (firstOccSet (n + (card (firstOccSet n) + 1))) < 0\n\ngoal (1 subgoal):\n 1. False", "by (metis less_nat_zero_code)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n'\\<ge>n.\n     \\<exists>n0'\\<ge>length (ft n).\n        n0' < length (ft n') \\<and> msg = ft n' ! n0'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enabled (last (fe n)) msg \\<longrightarrow>\n  (\\<exists>n'\\<ge>n.\n      \\<exists>n0'\\<ge>length (ft n).\n         n0' < length (ft n') \\<and> msg = ft n' ! n0')\n\ngoal (1 subgoal):\n 1. \\<And>n n0 p msg.\n       \\<lbrakk>\\<forall>n.\n                   initReachable (last (fe n)) \\<and>\n                   \\<not> vUniform False (last (fe n)) \\<and>\n                   \\<not> vUniform True (last (fe n)) \\<and>\n                   prefixList (fe n) (fe (Suc n)) \\<and>\n                   prefixList (ft n) (ft (Suc n)) \\<and>\n                   Suc 0 \\<le> length (fe n) \\<and>\n                   length (fe n) - Suc 0 = length (ft n) \\<and>\n                   initial (hd (fe n)) \\<and>\n                   (\\<forall>i<length (fe n) - Suc 0.\n                       fe n !\n                       i \\<turnstile> ft n !\ni \\<mapsto> fe n ! Suc i) \\<and>\n                   initial (hd (fe (Suc n)));\n        n0 < length (fe n); enabled (fe n ! n0) msg; isReceiverOf p msg;\n        correctInfinite fe ft p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                            \\<exists>n0'\\<ge>n0.\n                               n0' < length (ft n') \\<and> msg = ft n' ! n0'", "hence Case1ImplThesis: \"enabled (last (fe n)) msg \n      \\<Longrightarrow> (\\<exists>n'\\<ge>n. \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0')\""], ["proof (prove)\nusing this:\n  enabled (last (fe n)) msg \\<longrightarrow>\n  (\\<exists>n'\\<ge>n.\n      \\<exists>n0'\\<ge>length (ft n).\n         n0' < length (ft n') \\<and> msg = ft n' ! n0')\n\ngoal (1 subgoal):\n 1. enabled (last (fe n)) msg \\<Longrightarrow>\n    \\<exists>n'\\<ge>n.\n       \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0'", "using AssumptionFair(2) execution.length[of trans sends start \n        \"fe n\" \"ft n\"] BasicProperties"], ["proof (prove)\nusing this:\n  enabled (last (fe n)) msg \\<longrightarrow>\n  (\\<exists>n'\\<ge>n.\n      \\<exists>n0'\\<ge>length (ft n).\n         n0' < length (ft n') \\<and> msg = ft n' ! n0')\n  n0 < length (fe n)\n  execution trans sends start (fe n) (ft n) \\<Longrightarrow>\n  length (fe n) - 1 = length (ft n)\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. enabled (last (fe n)) msg \\<Longrightarrow>\n    \\<exists>n'\\<ge>n.\n       \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0'", "by (metis One_nat_def Suc_eq_plus1 Suc_lessI leI le_less_trans \n        less_asym less_diff_conv)"], ["proof (state)\nthis:\n  enabled (last (fe n)) msg \\<Longrightarrow>\n  \\<exists>n'\\<ge>n.\n     \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0'\n\ngoal (1 subgoal):\n 1. \\<And>n n0 p msg.\n       \\<lbrakk>\\<forall>n.\n                   initReachable (last (fe n)) \\<and>\n                   \\<not> vUniform False (last (fe n)) \\<and>\n                   \\<not> vUniform True (last (fe n)) \\<and>\n                   prefixList (fe n) (fe (Suc n)) \\<and>\n                   prefixList (ft n) (ft (Suc n)) \\<and>\n                   Suc 0 \\<le> length (fe n) \\<and>\n                   length (fe n) - Suc 0 = length (ft n) \\<and>\n                   initial (hd (fe n)) \\<and>\n                   (\\<forall>i<length (fe n) - Suc 0.\n                       fe n !\n                       i \\<turnstile> ft n !\ni \\<mapsto> fe n ! Suc i) \\<and>\n                   initial (hd (fe (Suc n)));\n        n0 < length (fe n); enabled (fe n ! n0) msg; isReceiverOf p msg;\n        correctInfinite fe ft p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                            \\<exists>n0'\\<ge>n0.\n                               n0' < length (ft n') \\<and> msg = ft n' ! n0'", "show \"\\<exists>n'\\<ge>n. \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'\\<ge>n.\n       \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0'", "using disjE[OF EnabledOrConsumedAtLast Case1ImplThesis Case2ImplThesis]"], ["proof (prove)\nusing this:\n  \\<lbrakk>enabled (last (fe n)) msg \\<Longrightarrow>\n           enabled (last (fe n)) msg;\n   \\<exists>n0'\\<ge>n0.\n      n0' < length (ft n) \\<and> ft n ! n0' = msg \\<Longrightarrow>\n   \\<exists>n0'\\<ge>n0. n0' < length (ft n) \\<and> ft n ! n0' = msg\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n'\\<ge>n.\n                       \\<exists>n0'\\<ge>n0.\n                          n0' < length (ft n') \\<and> msg = ft n' ! n0'\n\ngoal (1 subgoal):\n 1. \\<exists>n'\\<ge>n.\n       \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0'", "."], ["proof (state)\nthis:\n  \\<exists>n'\\<ge>n.\n     \\<exists>n0'\\<ge>n0. n0' < length (ft n') \\<and> msg = ft n' ! n0'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fairInfiniteExecution fe ft\n\ngoal (1 subgoal):\n 1. \\<exists>fe ft.\n       fe 0 = [cfg] \\<and>\n       fairInfiniteExecution fe ft \\<and>\n       (\\<forall>n.\n           nonUniform (last (fe n)) \\<and>\n           prefixList (fe n) (fe (n + 1)) \\<and>\n           prefixList (ft n) (ft (n + 1)) \\<and>\n           execution trans sends start (fe n) (ft n))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>fe ft.\n       fe 0 = [cfg] \\<and>\n       fairInfiniteExecution fe ft \\<and>\n       (\\<forall>n.\n           nonUniform (last (fe n)) \\<and>\n           prefixList (fe n) (fe (n + 1)) \\<and>\n           prefixList (ft n) (ft (n + 1)) \\<and>\n           execution trans sends start (fe n) (ft n))", "proof (rule exI[of _ fe], rule exI[of _ ft])"], ["proof (state)\ngoal (1 subgoal):\n 1. fe 0 = [cfg] \\<and>\n    fairInfiniteExecution fe ft \\<and>\n    (\\<forall>n.\n        nonUniform (last (fe n)) \\<and>\n        prefixList (fe n) (fe (n + 1)) \\<and>\n        prefixList (ft n) (ft (n + 1)) \\<and>\n        execution trans sends start (fe n) (ft n))", "show \"fe 0 = [cfg] \\<and> fairInfiniteExecution fe ft \n      \\<and> (\\<forall>n. nonUniform (last (fe n)) \\<and> prefixList (fe n) (fe (n + 1)) \n          \\<and> prefixList (ft n) (ft (n + 1))\n          \\<and> execution trans sends start (fe n) (ft n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe 0 = [cfg] \\<and>\n    fairInfiniteExecution fe ft \\<and>\n    (\\<forall>n.\n        nonUniform (last (fe n)) \\<and>\n        prefixList (fe n) (fe (n + 1)) \\<and>\n        prefixList (ft n) (ft (n + 1)) \\<and>\n        execution trans sends start (fe n) (ft n))", "using Fair fe_def FStep BasicProperties"], ["proof (prove)\nusing this:\n  fairInfiniteExecution fe ft\n  fe = infiniteExecutionCfg cfg fStepCfg fStepMsg\n  \\<forall>cfgList msgList.\n     \\<exists>cfgList' msgList'.\n        fStepCfg cfgList msgList = cfgList' \\<and>\n        fStepMsg cfgList msgList = msgList' \\<and>\n        (initial (hd cfgList) \\<and>\n         nonUniform (last cfgList) \\<and>\n         execution trans sends start cfgList msgList \\<longrightarrow>\n         nonUniform (last (fStepCfg cfgList msgList)) \\<and>\n         prefixList cfgList (fStepCfg cfgList msgList) \\<and>\n         prefixList msgList (fStepMsg cfgList msgList) \\<and>\n         execution trans sends start (fStepCfg cfgList msgList)\n          (fStepMsg cfgList msgList) \\<and>\n         initial (hd (fStepCfg cfgList msgList)) \\<and>\n         (\\<exists>msg'.\n             execution.minimalEnabled cfgList msgList msg' \\<and>\n             msg'\n             \\<in> set (drop (length msgList) (fStepMsg cfgList msgList))))\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n) \\<and>\n     initial (hd (fe (n + 1)))\n\ngoal (1 subgoal):\n 1. fe 0 = [cfg] \\<and>\n    fairInfiniteExecution fe ft \\<and>\n    (\\<forall>n.\n        nonUniform (last (fe n)) \\<and>\n        prefixList (fe n) (fe (n + 1)) \\<and>\n        prefixList (ft n) (ft (n + 1)) \\<and>\n        execution trans sends start (fe n) (ft n))", "by auto"], ["proof (state)\nthis:\n  fe 0 = [cfg] \\<and>\n  fairInfiniteExecution fe ft \\<and>\n  (\\<forall>n.\n      nonUniform (last (fe n)) \\<and>\n      prefixList (fe n) (fe (n + 1)) \\<and>\n      prefixList (ft n) (ft (n + 1)) \\<and>\n      execution trans sends start (fe n) (ft n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>fe ft.\n     fe 0 = [cfg] \\<and>\n     fairInfiniteExecution fe ft \\<and>\n     (\\<forall>n.\n         nonUniform (last (fe n)) \\<and>\n         prefixList (fe n) (fe (n + 1)) \\<and>\n         prefixList (ft n) (ft (n + 1)) \\<and>\n         execution trans sends start (fe n) (ft n))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Contradiction\\<close>"], ["", "text \\<open>\n  An infinite execution is said to be a terminating FLP execution if each process\n  at some point sends a decision message or if it stops, which is expressed\n  by the process not processing any further messages.\n\\<close>"], ["", "definition (in flpSystem) terminationFLP::\n  \"(nat \\<Rightarrow> ('p, 'v, 's) configuration list) \n  \\<Rightarrow> (nat \\<Rightarrow> ('p, 'v) message list) \\<Rightarrow> bool\"\nwhere\n  \"terminationFLP fe ft \\<equiv> infiniteExecution fe ft \\<longrightarrow> \n  (\\<forall> p . \\<exists> n .\n     (\\<exists> i0 < length (ft n). \\<exists> b . \n      (<\\<bottom>, outM b> \\<in># sends p (states ((fe n) ! i0) p) (unpackMessage ((ft n) ! i0)))\n      \\<and> isReceiverOf p ((ft n) ! i0))\n  \\<or> (\\<forall> n1 > n . \\<forall> m \\<in> set (drop (length (ft n)) (ft n1)) . \\<not> isReceiverOf p m))\""], ["", "theorem ConsensusFails:\nassumes \n  Termination:\n    \"\\<And> fe ft . (fairInfiniteExecution fe ft \\<Longrightarrow> terminationFLP fe ft)\" and\n  Validity: \"\\<forall> i c . validity i c\" and\n  Agreement: \"\\<forall> i c . agreementInit i c\"\nshows\n  \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "obtain cfg where Cfg: \"initial cfg\" \"nonUniform cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cfg.\n        \\<lbrakk>initial cfg; nonUniform cfg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using InitialNonUniformCfg[OF PseudoTermination Validity Agreement]"], ["proof (prove)\nusing this:\n  \\<exists>cfg. initial cfg \\<and> nonUniform cfg\n\ngoal (1 subgoal):\n 1. (\\<And>cfg.\n        \\<lbrakk>initial cfg; nonUniform cfg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  initial cfg\n  nonUniform cfg\n\ngoal (1 subgoal):\n 1. False", "obtain fe:: \"nat \\<Rightarrow> ('p, 'v, 's) configuration list\" and\n              ft:: \"nat \\<Rightarrow> ('p, 'v) message list\"\n    where FE: \"(fe 0) = [cfg]\" \"fairInfiniteExecution fe ft\"\n        \"(\\<forall>(n::nat) . nonUniform (last (fe n)) \n          \\<and> prefixList (fe n) (fe (n+1)) \n          \\<and> prefixList (ft n) (ft (n+1))\n          \\<and> (execution trans sends start (fe n) (ft n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fe ft.\n        \\<lbrakk>fe 0 = [cfg]; fairInfiniteExecution fe ft;\n         \\<forall>n.\n            nonUniform (last (fe n)) \\<and>\n            prefixList (fe n) (fe (n + 1)) \\<and>\n            prefixList (ft n) (ft (n + 1)) \\<and>\n            execution trans sends start (fe n) (ft n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using FairNonUniformExecution[OF Cfg]"], ["proof (prove)\nusing this:\n  \\<exists>fe ft.\n     fe 0 = [cfg] \\<and>\n     fairInfiniteExecution fe ft \\<and>\n     (\\<forall>n.\n         nonUniform (last (fe n)) \\<and>\n         prefixList (fe n) (fe (n + 1)) \\<and>\n         prefixList (ft n) (ft (n + 1)) \\<and>\n         execution trans sends start (fe n) (ft n))\n\ngoal (1 subgoal):\n 1. (\\<And>fe ft.\n        \\<lbrakk>fe 0 = [cfg]; fairInfiniteExecution fe ft;\n         \\<forall>n.\n            nonUniform (last (fe n)) \\<and>\n            prefixList (fe n) (fe (n + 1)) \\<and>\n            prefixList (ft n) (ft (n + 1)) \\<and>\n            execution trans sends start (fe n) (ft n)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. False", "have AllArePrefixesExec: \"\\<forall> m . \\<forall> n > m . prefixList (fe m) (fe n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m n. m < n \\<longrightarrow> prefixList (fe m) (fe n)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n. m < n \\<Longrightarrow> prefixList (fe m) (fe n)", "fix m::nat and n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n. m < n \\<Longrightarrow> prefixList (fe m) (fe n)", "assume MLessN: \"m < n\""], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>m n. m < n \\<Longrightarrow> prefixList (fe m) (fe n)", "have \"prefixList (fe m) (fe n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList (fe m) (fe n)", "using MLessN"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. prefixList (fe m) (fe n)", "proof(induct n, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>m < n \\<Longrightarrow> prefixList (fe m) (fe n);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>m < n \\<Longrightarrow> prefixList (fe m) (fe n);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "assume IA: \"(m < n) \\<Longrightarrow> (prefixList (fe m) (fe n))\" \"m < (Suc n)\""], ["proof (state)\nthis:\n  m < n \\<Longrightarrow> prefixList (fe m) (fe n)\n  m < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>m < n \\<Longrightarrow> prefixList (fe m) (fe n);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "have \"m = n \\<or> m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = n \\<or> m < n", "using IA(2)"], ["proof (prove)\nusing this:\n  m < Suc n\n\ngoal (1 subgoal):\n 1. m = n \\<or> m < n", "by (metis less_SucE)"], ["proof (state)\nthis:\n  m = n \\<or> m < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>m < n \\<Longrightarrow> prefixList (fe m) (fe n);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "thus \"prefixList (fe m) (fe (Suc n))\""], ["proof (prove)\nusing this:\n  m = n \\<or> m < n\n\ngoal (1 subgoal):\n 1. prefixList (fe m) (fe (Suc n))", "proof(cases \"m = n\", auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = n \\<Longrightarrow> prefixList (fe n) (fe (Suc n))\n 2. m < n \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "show \"prefixList (fe n) (fe (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList (fe n) (fe (Suc n))", "using FE"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. prefixList (fe n) (fe (Suc n))", "by simp"], ["proof (state)\nthis:\n  prefixList (fe n) (fe (Suc n))\n\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "assume \"m < n\""], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "hence IA2: \"prefixList (fe m) (fe n)\""], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. prefixList (fe m) (fe n)", "using IA(1)"], ["proof (prove)\nusing this:\n  m < n\n  m < n \\<Longrightarrow> prefixList (fe m) (fe n)\n\ngoal (1 subgoal):\n 1. prefixList (fe m) (fe n)", "by simp"], ["proof (state)\nthis:\n  prefixList (fe m) (fe n)\n\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "have \"prefixList (fe n) (fe (n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList (fe n) (fe (n + 1))", "using FE"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. prefixList (fe n) (fe (n + 1))", "by simp"], ["proof (state)\nthis:\n  prefixList (fe n) (fe (n + 1))\n\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (fe m) (fe (Suc n))", "thus \"prefixList (fe m) (fe (Suc n))\""], ["proof (prove)\nusing this:\n  prefixList (fe n) (fe (n + 1))\n\ngoal (1 subgoal):\n 1. prefixList (fe m) (fe (Suc n))", "using PrefixListTransitive \n          IA2"], ["proof (prove)\nusing this:\n  prefixList (fe n) (fe (n + 1))\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n  prefixList (fe m) (fe n)\n\ngoal (1 subgoal):\n 1. prefixList (fe m) (fe (Suc n))", "by simp"], ["proof (state)\nthis:\n  prefixList (fe m) (fe (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixList (fe m) (fe (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixList (fe m) (fe n)\n\ngoal (1 subgoal):\n 1. \\<And>m n. m < n \\<Longrightarrow> prefixList (fe m) (fe n)", "thus \"prefixList (fe m) (fe n)\""], ["proof (prove)\nusing this:\n  prefixList (fe m) (fe n)\n\ngoal (1 subgoal):\n 1. prefixList (fe m) (fe n)", "by simp"], ["proof (state)\nthis:\n  prefixList (fe m) (fe n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m n. m < n \\<longrightarrow> prefixList (fe m) (fe n)\n\ngoal (1 subgoal):\n 1. False", "have AllArePrefixesTrace: \"\\<forall> m . \\<forall> n > m . prefixList (ft m) (ft n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m n. m < n \\<longrightarrow> prefixList (ft m) (ft n)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n. m < n \\<Longrightarrow> prefixList (ft m) (ft n)", "fix m::nat and n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n. m < n \\<Longrightarrow> prefixList (ft m) (ft n)", "assume MLessN: \"m < n\""], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. \\<And>m n. m < n \\<Longrightarrow> prefixList (ft m) (ft n)", "have \"prefixList (ft m) (ft n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList (ft m) (ft n)", "using MLessN"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. prefixList (ft m) (ft n)", "proof(induct n, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>m < n \\<Longrightarrow> prefixList (ft m) (ft n);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>m < n \\<Longrightarrow> prefixList (ft m) (ft n);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "assume IA: \"(m < n) \\<Longrightarrow> (prefixList (ft m) (ft n))\" \"m < (Suc n)\""], ["proof (state)\nthis:\n  m < n \\<Longrightarrow> prefixList (ft m) (ft n)\n  m < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>m < n \\<Longrightarrow> prefixList (ft m) (ft n);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "have \"m = n \\<or> m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = n \\<or> m < n", "using IA(2)"], ["proof (prove)\nusing this:\n  m < Suc n\n\ngoal (1 subgoal):\n 1. m = n \\<or> m < n", "by (metis less_SucE)"], ["proof (state)\nthis:\n  m = n \\<or> m < n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>m < n \\<Longrightarrow> prefixList (ft m) (ft n);\n        m < Suc n\\<rbrakk>\n       \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "thus \"prefixList (ft m) (ft (Suc n))\""], ["proof (prove)\nusing this:\n  m = n \\<or> m < n\n\ngoal (1 subgoal):\n 1. prefixList (ft m) (ft (Suc n))", "proof(cases \"m = n\", auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. m = n \\<Longrightarrow> prefixList (ft n) (ft (Suc n))\n 2. m < n \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "show \"prefixList (ft n) (ft (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList (ft n) (ft (Suc n))", "using FE"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. prefixList (ft n) (ft (Suc n))", "by simp"], ["proof (state)\nthis:\n  prefixList (ft n) (ft (Suc n))\n\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "assume \"m < n\""], ["proof (state)\nthis:\n  m < n\n\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "hence IA2: \"prefixList (ft m) (ft n)\""], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. prefixList (ft m) (ft n)", "using IA(1)"], ["proof (prove)\nusing this:\n  m < n\n  m < n \\<Longrightarrow> prefixList (ft m) (ft n)\n\ngoal (1 subgoal):\n 1. prefixList (ft m) (ft n)", "by simp"], ["proof (state)\nthis:\n  prefixList (ft m) (ft n)\n\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "have \"prefixList (ft n) (ft (n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList (ft n) (ft (n + 1))", "using FE"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. prefixList (ft n) (ft (n + 1))", "by simp"], ["proof (state)\nthis:\n  prefixList (ft n) (ft (n + 1))\n\ngoal (1 subgoal):\n 1. m < n \\<Longrightarrow> prefixList (ft m) (ft (Suc n))", "thus \"prefixList (ft m) (ft (Suc n))\""], ["proof (prove)\nusing this:\n  prefixList (ft n) (ft (n + 1))\n\ngoal (1 subgoal):\n 1. prefixList (ft m) (ft (Suc n))", "using PrefixListTransitive \n          IA2"], ["proof (prove)\nusing this:\n  prefixList (ft n) (ft (n + 1))\n  \\<lbrakk>prefixList ?l1.0 ?l2.0; prefixList ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> prefixList ?l1.0 ?l3.0\n  prefixList (ft m) (ft n)\n\ngoal (1 subgoal):\n 1. prefixList (ft m) (ft (Suc n))", "by simp"], ["proof (state)\nthis:\n  prefixList (ft m) (ft (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixList (ft m) (ft (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefixList (ft m) (ft n)\n\ngoal (1 subgoal):\n 1. \\<And>m n. m < n \\<Longrightarrow> prefixList (ft m) (ft n)", "thus \"prefixList (ft m) (ft n)\""], ["proof (prove)\nusing this:\n  prefixList (ft m) (ft n)\n\ngoal (1 subgoal):\n 1. prefixList (ft m) (ft n)", "by simp"], ["proof (state)\nthis:\n  prefixList (ft m) (ft n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>m n. m < n \\<longrightarrow> prefixList (ft m) (ft n)\n\ngoal (1 subgoal):\n 1. False", "have Length: \"\\<forall> n . length (fe n) \\<ge> n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. n + 1 \\<le> length (fe n)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. n + 1 \\<le> length (fe n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. n + 1 \\<le> length (fe n)", "show \"length (fe n) \\<ge> n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n + 1 \\<le> length (fe n)", "proof(induct n, simp add: FE(1))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n + 1 \\<le> length (fe n) \\<Longrightarrow>\n       Suc n + 1 \\<le> length (fe (Suc n))", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n + 1 \\<le> length (fe n) \\<Longrightarrow>\n       Suc n + 1 \\<le> length (fe (Suc n))", "assume IH: \"(n + (1::nat)) \\<le> (length (fe n))\""], ["proof (state)\nthis:\n  n + 1 \\<le> length (fe n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n + 1 \\<le> length (fe n) \\<Longrightarrow>\n       Suc n + 1 \\<le> length (fe (Suc n))", "have \"length (fe (n+1)) \\<ge> length (fe n) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fe n) + 1 \\<le> length (fe (n + 1))", "using FE(3) \n        PrefixListMonotonicity"], ["proof (prove)\nusing this:\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n  prefixList ?l1.0 ?l2.0 \\<Longrightarrow> length ?l1.0 < length ?l2.0\n\ngoal (1 subgoal):\n 1. length (fe n) + 1 \\<le> length (fe (n + 1))", "by (metis Suc_eq_plus1 Suc_le_eq)"], ["proof (state)\nthis:\n  length (fe n) + 1 \\<le> length (fe (n + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n + 1 \\<le> length (fe n) \\<Longrightarrow>\n       Suc n + 1 \\<le> length (fe (Suc n))", "thus \"(Suc n) + (1::nat) \\<le> (length (fe (Suc n)))\""], ["proof (prove)\nusing this:\n  length (fe n) + 1 \\<le> length (fe (n + 1))\n\ngoal (1 subgoal):\n 1. Suc n + 1 \\<le> length (fe (Suc n))", "using IH"], ["proof (prove)\nusing this:\n  length (fe n) + 1 \\<le> length (fe (n + 1))\n  n + 1 \\<le> length (fe n)\n\ngoal (1 subgoal):\n 1. Suc n + 1 \\<le> length (fe (Suc n))", "by auto"], ["proof (state)\nthis:\n  Suc n + 1 \\<le> length (fe (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n + 1 \\<le> length (fe n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n. n + 1 \\<le> length (fe n)\n\ngoal (1 subgoal):\n 1. False", "have AllExecsFromInit: \"\\<forall> n . \\<forall> n0 < length (fe n) . \n    reachable cfg ((fe n) ! n0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n n0.\n       n0 < length (fe n) \\<longrightarrow> reachable cfg (fe n ! n0)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n0.\n       n0 < length (fe n) \\<Longrightarrow> reachable cfg (fe n ! n0)", "fix n::nat and n0::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n0.\n       n0 < length (fe n) \\<Longrightarrow> reachable cfg (fe n ! n0)", "assume \"n0 < length (fe n)\""], ["proof (state)\nthis:\n  n0 < length (fe n)\n\ngoal (1 subgoal):\n 1. \\<And>n n0.\n       n0 < length (fe n) \\<Longrightarrow> reachable cfg (fe n ! n0)", "thus \"reachable cfg ((fe n) ! n0)\""], ["proof (prove)\nusing this:\n  n0 < length (fe n)\n\ngoal (1 subgoal):\n 1. reachable cfg (fe n ! n0)", "proof(cases \"0 = n\", auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n0 < length (fe 0); n = 0\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe 0 ! n0)\n 2. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "assume N0Less: \"n0 < length (fe 0)\""], ["proof (state)\nthis:\n  n0 < length (fe 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n0 < length (fe 0); n = 0\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe 0 ! n0)\n 2. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "have NoStep: \"reachable cfg cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable cfg cfg", "using reachable.simps"], ["proof (prove)\nusing this:\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. reachable cfg cfg", "by blast"], ["proof (state)\nthis:\n  reachable cfg cfg\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n0 < length (fe 0); n = 0\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe 0 ! n0)\n 2. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "have \"length (fe 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fe 0) = 1", "using FE(1)"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n\ngoal (1 subgoal):\n 1. length (fe 0) = 1", "by simp"], ["proof (state)\nthis:\n  length (fe 0) = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n0 < length (fe 0); n = 0\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe 0 ! n0)\n 2. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "hence N0Zero: \"n0 = 0\""], ["proof (prove)\nusing this:\n  length (fe 0) = 1\n\ngoal (1 subgoal):\n 1. n0 = 0", "using N0Less FE"], ["proof (prove)\nusing this:\n  length (fe 0) = 1\n  n0 < length (fe 0)\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. n0 = 0", "by simp"], ["proof (state)\nthis:\n  n0 = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n0 < length (fe 0); n = 0\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe 0 ! n0)\n 2. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "hence \"(fe 0) ! n0 = cfg\""], ["proof (prove)\nusing this:\n  n0 = 0\n\ngoal (1 subgoal):\n 1. fe 0 ! n0 = cfg", "using FE(1)"], ["proof (prove)\nusing this:\n  n0 = 0\n  fe 0 = [cfg]\n\ngoal (1 subgoal):\n 1. fe 0 ! n0 = cfg", "by simp"], ["proof (state)\nthis:\n  fe 0 ! n0 = cfg\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n0 < length (fe 0); n = 0\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe 0 ! n0)\n 2. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "thus \"reachable cfg ((fe 0) ! n0)\""], ["proof (prove)\nusing this:\n  fe 0 ! n0 = cfg\n\ngoal (1 subgoal):\n 1. reachable cfg (fe 0 ! n0)", "using FE(1) NoStep N0Zero"], ["proof (prove)\nusing this:\n  fe 0 ! n0 = cfg\n  fe 0 = [cfg]\n  reachable cfg cfg\n  n0 = 0\n\ngoal (1 subgoal):\n 1. reachable cfg (fe 0 ! n0)", "by simp"], ["proof (state)\nthis:\n  reachable cfg (fe 0 ! n0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "assume NNotZero: \"0 < n\" \"n0 < (length (fe n))\""], ["proof (state)\nthis:\n  0 < n\n  n0 < length (fe n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "have ZeroCfg: \"(fe 0) = [cfg]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe 0 = [cfg]", "using FE"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. fe 0 = [cfg]", "by simp"], ["proof (state)\nthis:\n  fe 0 = [cfg]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "have \"prefixList (fe 0) (fe n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefixList (fe 0) (fe n)", "using AllArePrefixesExec NNotZero"], ["proof (prove)\nusing this:\n  \\<forall>m n. m < n \\<longrightarrow> prefixList (fe m) (fe n)\n  0 < n\n  n0 < length (fe n)\n\ngoal (1 subgoal):\n 1. prefixList (fe 0) (fe n)", "by simp"], ["proof (state)\nthis:\n  prefixList (fe 0) (fe n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "hence PrList: \"prefixList [cfg] (fe n)\""], ["proof (prove)\nusing this:\n  prefixList (fe 0) (fe n)\n\ngoal (1 subgoal):\n 1. prefixList [cfg] (fe n)", "using ZeroCfg"], ["proof (prove)\nusing this:\n  prefixList (fe 0) (fe n)\n  fe 0 = [cfg]\n\ngoal (1 subgoal):\n 1. prefixList [cfg] (fe n)", "by simp"], ["proof (state)\nthis:\n  prefixList [cfg] (fe n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "have CfgFirst: \"cfg = (fe n) ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg = fe n ! 0", "using prefixList.cases[OF PrList]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x xs.\n              \\<lbrakk>[cfg] = []; fe n = x # xs\\<rbrakk>\n              \\<Longrightarrow> ?P;\n   \\<And>xa xb x.\n      \\<lbrakk>[cfg] = x # xa; fe n = x # xb; prefixList xa xb\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. cfg = fe n ! 0", "by (metis (full_types) ZeroCfg list.distinct(1) nth_Cons_0)"], ["proof (state)\nthis:\n  cfg = fe n ! 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "have \"reachable ((fe n) ! 0) ((fe n) ! n0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (fe n ! 0) (fe n ! n0)", "using execution.ReachableInExecution FE NNotZero(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>execution ?trans ?sends ?start ?exec ?trace; ?i < length ?exec;\n   ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> asynchronousSystem.reachable ?trans ?sends (?exec ! ?j)\n                     (?exec ! ?i)\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n  n0 < length (fe n)\n\ngoal (1 subgoal):\n 1. reachable (fe n ! 0) (fe n ! n0)", "by (metis le0)"], ["proof (state)\nthis:\n  reachable (fe n ! 0) (fe n ! n0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n0 < length (fe n)\\<rbrakk>\n    \\<Longrightarrow> reachable cfg (fe n ! n0)", "thus \"(reachable cfg ((fe n) ! n0))\""], ["proof (prove)\nusing this:\n  reachable (fe n ! 0) (fe n ! n0)\n\ngoal (1 subgoal):\n 1. reachable cfg (fe n ! n0)", "using assms CfgFirst"], ["proof (prove)\nusing this:\n  reachable (fe n ! 0) (fe n ! n0)\n  fairInfiniteExecution ?fe ?ft \\<Longrightarrow> terminationFLP ?fe ?ft\n  \\<forall>i c. validity i c\n  \\<forall>i c. agreementInit i c\n  cfg = fe n ! 0\n\ngoal (1 subgoal):\n 1. reachable cfg (fe n ! n0)", "by simp"], ["proof (state)\nthis:\n  reachable cfg (fe n ! n0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable cfg (fe n ! n0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n n0.\n     n0 < length (fe n) \\<longrightarrow> reachable cfg (fe n ! n0)\n\ngoal (1 subgoal):\n 1. False", "have NoDecided: \"(\\<forall> n n0 v . (n0 < length (fe n)) \n                  \\<longrightarrow> \\<not> vDecided v ((fe n) ! n0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n n0 v.\n       n0 < length (fe n) \\<longrightarrow>\n       \\<not> (initReachable (fe n ! n0) \\<and>\n               <\\<bottom>, outM v> \\<in># msgs (fe n ! n0))", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "fix n n0 v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "assume AssmNoDecided: \"n0 < length (fe n)\" \n      \"initReachable ((fe n) ! n0)\"\n      \"0 < (msgs ((fe n) ! n0) <\\<bottom>, outM v>)\""], ["proof (state)\nthis:\n  n0 < length (fe n)\n  initReachable (fe n ! n0)\n  <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "have LastNonUniform: \"nonUniform (last (fe n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonUniform (last (fe n))", "using FE"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. nonUniform (last (fe n))", "by simp"], ["proof (state)\nthis:\n  nonUniform (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "have LastIsLastIndex: \"\\<And> l . l \\<noteq> [] \\<longrightarrow> last l = l ! ((length l) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l. l \\<noteq> [] \\<longrightarrow> last l = l ! (length l - 1)", "by (metis last_conv_nth)"], ["proof (state)\nthis:\n  ?l \\<noteq> [] \\<longrightarrow> last ?l = ?l ! (length ?l - 1)\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "have Fou: \"n0 \\<le> length (fe n) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n0 \\<le> length (fe n) - 1", "using AssmNoDecided"], ["proof (prove)\nusing this:\n  n0 < length (fe n)\n  initReachable (fe n ! n0)\n  <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\n\ngoal (1 subgoal):\n 1. n0 \\<le> length (fe n) - 1", "by simp"], ["proof (state)\nthis:\n  n0 \\<le> length (fe n) - 1\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "have FeNNotEmpty:\"fe n \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fe n \\<noteq> []", "using FE(1) AllArePrefixesExec"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  \\<forall>m n. m < n \\<longrightarrow> prefixList (fe m) (fe n)\n\ngoal (1 subgoal):\n 1. fe n \\<noteq> []", "by (metis AssmNoDecided(1) less_nat_zero_code list.size(3))"], ["proof (state)\nthis:\n  fe n \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "hence Fou2: \"length (fe n) - 1 < length (fe n)\""], ["proof (prove)\nusing this:\n  fe n \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (fe n) - 1 < length (fe n)", "by simp"], ["proof (state)\nthis:\n  length (fe n) - 1 < length (fe n)\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"last (fe n) = (fe n) ! (length (fe n) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (fe n) = fe n ! (length (fe n) - 1)", "using LastIsLastIndex FeNNotEmpty"], ["proof (prove)\nusing this:\n  ?l \\<noteq> [] \\<longrightarrow> last ?l = ?l ! (length ?l - 1)\n  fe n \\<noteq> []\n\ngoal (1 subgoal):\n 1. last (fe n) = fe n ! (length (fe n) - 1)", "by auto"], ["proof (state)\nthis:\n  last (fe n) = fe n ! (length (fe n) - 1)\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "have LastNonUniform: \"nonUniform (last (fe n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonUniform (last (fe n))", "using FE"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. nonUniform (last (fe n))", "by simp"], ["proof (state)\nthis:\n  nonUniform (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "have \"reachable ((fe n) ! n0) ((fe n) ! (length (fe n) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (fe n ! n0) (fe n ! (length (fe n) - 1))", "using FE execution.ReachableInExecution Fou Fou2"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n  \\<lbrakk>execution ?trans ?sends ?start ?exec ?trace; ?i < length ?exec;\n   ?j \\<le> ?i\\<rbrakk>\n  \\<Longrightarrow> asynchronousSystem.reachable ?trans ?sends (?exec ! ?j)\n                     (?exec ! ?i)\n  n0 \\<le> length (fe n) - 1\n  length (fe n) - 1 < length (fe n)\n\ngoal (1 subgoal):\n 1. reachable (fe n ! n0) (fe n ! (length (fe n) - 1))", "by metis"], ["proof (state)\nthis:\n  reachable (fe n ! n0) (fe n ! (length (fe n) - 1))\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "hence N0ToLast: \"reachable ((fe n) ! n0) (last (fe n))\""], ["proof (prove)\nusing this:\n  reachable (fe n ! n0) (fe n ! (length (fe n) - 1))\n\ngoal (1 subgoal):\n 1. reachable (fe n ! n0) (last (fe n))", "using LastIsLastIndex[of \"fe n\"] FeNNotEmpty"], ["proof (prove)\nusing this:\n  reachable (fe n ! n0) (fe n ! (length (fe n) - 1))\n  fe n \\<noteq> [] \\<longrightarrow>\n  last (fe n) = fe n ! (length (fe n) - 1)\n  fe n \\<noteq> []\n\ngoal (1 subgoal):\n 1. reachable (fe n ! n0) (last (fe n))", "by simp"], ["proof (state)\nthis:\n  reachable (fe n ! n0) (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "hence LastVDecided: \"vDecided v (last (fe n))\""], ["proof (prove)\nusing this:\n  reachable (fe n ! n0) (last (fe n))\n\ngoal (1 subgoal):\n 1. initReachable (last (fe n)) \\<and>\n    <\\<bottom>, outM v> \\<in># msgs (last (fe n))", "using NoOutMessageLoss[of \"((fe n) ! n0)\" \"(last (fe n))\"] \n        AssmNoDecided"], ["proof (prove)\nusing this:\n  reachable (fe n ! n0) (last (fe n))\n  reachable (fe n ! n0) (last (fe n)) \\<Longrightarrow>\n  msgs (fe n ! n0) <\\<bottom>, outM ?v>\n  \\<le> msgs (last (fe n)) <\\<bottom>, outM ?v>\n  n0 < length (fe n)\n  initReachable (fe n ! n0)\n  <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\n\ngoal (1 subgoal):\n 1. initReachable (last (fe n)) \\<and>\n    <\\<bottom>, outM v> \\<in># msgs (last (fe n))", "by (simp,\n        metis LastNonUniform le_neq_implies_less less_nat_zero_code neq0_conv)"], ["proof (state)\nthis:\n  initReachable (last (fe n)) \\<and>\n  <\\<bottom>, outM v> \\<in># msgs (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "have AllAgree: \"\\<forall> cfg' . reachable (last (fe n)) cfg' \n      \\<longrightarrow> agreement cfg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cfg'.\n       reachable (last (fe n)) cfg' \\<longrightarrow> agreement cfg'", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       reachable (last (fe n)) cfg' \\<Longrightarrow> agreement cfg'", "fix cfg'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       reachable (last (fe n)) cfg' \\<Longrightarrow> agreement cfg'", "assume LastToNext: \"reachable (last (fe n)) cfg'\""], ["proof (state)\nthis:\n  reachable (last (fe n)) cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       reachable (last (fe n)) cfg' \\<Longrightarrow> agreement cfg'", "hence \"reachable cfg  ((fe n) ! (length (fe n) - 1))\""], ["proof (prove)\nusing this:\n  reachable (last (fe n)) cfg'\n\ngoal (1 subgoal):\n 1. reachable cfg (fe n ! (length (fe n) - 1))", "using AllExecsFromInit AssmNoDecided(1)"], ["proof (prove)\nusing this:\n  reachable (last (fe n)) cfg'\n  \\<forall>n n0.\n     n0 < length (fe n) \\<longrightarrow> reachable cfg (fe n ! n0)\n  n0 < length (fe n)\n\ngoal (1 subgoal):\n 1. reachable cfg (fe n ! (length (fe n) - 1))", "by auto"], ["proof (state)\nthis:\n  reachable cfg (fe n ! (length (fe n) - 1))\n\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       reachable (last (fe n)) cfg' \\<Longrightarrow> agreement cfg'", "hence \"reachable cfg (last (fe n))\""], ["proof (prove)\nusing this:\n  reachable cfg (fe n ! (length (fe n) - 1))\n\ngoal (1 subgoal):\n 1. reachable cfg (last (fe n))", "using LastIsLastIndex[of \"fe n\"] \n        FeNNotEmpty"], ["proof (prove)\nusing this:\n  reachable cfg (fe n ! (length (fe n) - 1))\n  fe n \\<noteq> [] \\<longrightarrow>\n  last (fe n) = fe n ! (length (fe n) - 1)\n  fe n \\<noteq> []\n\ngoal (1 subgoal):\n 1. reachable cfg (last (fe n))", "by simp"], ["proof (state)\nthis:\n  reachable cfg (last (fe n))\n\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       reachable (last (fe n)) cfg' \\<Longrightarrow> agreement cfg'", "hence FirstToLast: \"reachable cfg cfg'\""], ["proof (prove)\nusing this:\n  reachable cfg (last (fe n))\n\ngoal (1 subgoal):\n 1. reachable cfg cfg'", "using initReachable_def Cfg \n        LastToNext ReachableTrans"], ["proof (prove)\nusing this:\n  reachable cfg (last (fe n))\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  initial cfg\n  nonUniform cfg\n  reachable (last (fe n)) cfg'\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n\ngoal (1 subgoal):\n 1. reachable cfg cfg'", "by blast"], ["proof (state)\nthis:\n  reachable cfg cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       reachable (last (fe n)) cfg' \\<Longrightarrow> agreement cfg'", "hence \"agreementInit cfg cfg'\""], ["proof (prove)\nusing this:\n  reachable cfg cfg'\n\ngoal (1 subgoal):\n 1. agreementInit cfg cfg'", "using Agreement"], ["proof (prove)\nusing this:\n  reachable cfg cfg'\n  \\<forall>i c. agreementInit i c\n\ngoal (1 subgoal):\n 1. agreementInit cfg cfg'", "by simp"], ["proof (state)\nthis:\n  agreementInit cfg cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       reachable (last (fe n)) cfg' \\<Longrightarrow> agreement cfg'", "hence \"\\<forall>v1. (<\\<bottom>, outM v1> \\<in># msgs cfg') \\<longrightarrow> (\\<forall>v2. (<\\<bottom>, outM v2> \\<in># \n        msgs cfg') \\<longleftrightarrow> v2 = v1)\""], ["proof (prove)\nusing this:\n  agreementInit cfg cfg'\n\ngoal (1 subgoal):\n 1. \\<forall>v1.\n       <\\<bottom>, outM v1> \\<in># msgs cfg' \\<longrightarrow>\n       (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs cfg' = (v2 = v1))", "using Cfg FirstToLast"], ["proof (prove)\nusing this:\n  agreementInit cfg cfg'\n  initial cfg\n  nonUniform cfg\n  reachable cfg cfg'\n\ngoal (1 subgoal):\n 1. \\<forall>v1.\n       <\\<bottom>, outM v1> \\<in># msgs cfg' \\<longrightarrow>\n       (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs cfg' = (v2 = v1))", "by (simp add: agreementInit_def)"], ["proof (state)\nthis:\n  \\<forall>v1.\n     <\\<bottom>, outM v1> \\<in># msgs cfg' \\<longrightarrow>\n     (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs cfg' = (v2 = v1))\n\ngoal (1 subgoal):\n 1. \\<And>cfg'.\n       reachable (last (fe n)) cfg' \\<Longrightarrow> agreement cfg'", "thus \"agreement cfg'\""], ["proof (prove)\nusing this:\n  \\<forall>v1.\n     <\\<bottom>, outM v1> \\<in># msgs cfg' \\<longrightarrow>\n     (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs cfg' = (v2 = v1))\n\ngoal (1 subgoal):\n 1. agreement cfg'", "by (simp add: agreement_def)"], ["proof (state)\nthis:\n  agreement cfg'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>cfg'.\n     reachable (last (fe n)) cfg' \\<longrightarrow> agreement cfg'\n\ngoal (1 subgoal):\n 1. \\<And>n n0 v.\n       \\<lbrakk>n0 < length (fe n); initReachable (fe n ! n0);\n        <\\<bottom>, outM v> \\<in># msgs (fe n ! n0)\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<forall>cfg'.\n     reachable (last (fe n)) cfg' \\<longrightarrow> agreement cfg'\n\ngoal (1 subgoal):\n 1. False", "using NonUniformImpliesNotDecided LastNonUniform \n      PseudoTermination LastVDecided"], ["proof (prove)\nusing this:\n  \\<forall>cfg'.\n     reachable (last (fe n)) cfg' \\<longrightarrow> agreement cfg'\n  \\<lbrakk>\\<forall>cfg. reachable ?c cfg \\<longrightarrow> agreement cfg;\n   \\<And>cc Q. terminationPseudo 1 cc Q; nonUniform ?c;\n   initReachable ?c \\<and> <\\<bottom>, outM ?v> \\<in># msgs ?c\\<rbrakk>\n  \\<Longrightarrow> False\n  nonUniform (last (fe n))\n  terminationPseudo 1 ?cc ?Q\n  initReachable (last (fe n)) \\<and>\n  <\\<bottom>, outM v> \\<in># msgs (last (fe n))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n n0 v.\n     n0 < length (fe n) \\<longrightarrow>\n     \\<not> (initReachable (fe n ! n0) \\<and>\n             <\\<bottom>, outM v> \\<in># msgs (fe n ! n0))\n\ngoal (1 subgoal):\n 1. False", "have Termination: \"terminationFLP fe ft\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminationFLP fe ft", "using assms(1)[OF FE(2)]"], ["proof (prove)\nusing this:\n  terminationFLP fe ft\n\ngoal (1 subgoal):\n 1. terminationFLP fe ft", "."], ["proof (state)\nthis:\n  terminationFLP fe ft\n\ngoal (1 subgoal):\n 1. False", "hence AllDecideOrCrash: \n    \"\\<forall>p. \\<exists>n . \n       (\\<exists> i0 < length (ft n) . \\<exists>b. \n          (<\\<bottom>, outM b> \\<in># \n            sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))) \n          \\<and> isReceiverOf p (ft n ! i0)) \n      \\<or> (\\<forall> n1 > n . \\<forall> m \\<in> (set (drop (length (ft n)) (ft n1))) .\n          \\<not> isReceiverOf p m)\""], ["proof (prove)\nusing this:\n  terminationFLP fe ft\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       \\<exists>n.\n          (\\<exists>i0<length (ft n).\n              \\<exists>b.\n                 <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n       (unpackMessage (ft n ! i0)) \\<and>\n                 isReceiverOf p (ft n ! i0)) \\<or>\n          (\\<forall>n1>n.\n              \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                 \\<not> isReceiverOf p m)", "using FE(2)"], ["proof (prove)\nusing this:\n  terminationFLP fe ft\n  fairInfiniteExecution fe ft\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       \\<exists>n.\n          (\\<exists>i0<length (ft n).\n              \\<exists>b.\n                 <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n       (unpackMessage (ft n ! i0)) \\<and>\n                 isReceiverOf p (ft n ! i0)) \\<or>\n          (\\<forall>n1>n.\n              \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                 \\<not> isReceiverOf p m)", "unfolding terminationFLP_def fairInfiniteExecution_def"], ["proof (prove)\nusing this:\n  infiniteExecution fe ft \\<longrightarrow>\n  (\\<forall>p.\n      \\<exists>n.\n         (\\<exists>i0<length (ft n).\n             \\<exists>b.\n                <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n      (unpackMessage (ft n ! i0)) \\<and>\n                isReceiverOf p (ft n ! i0)) \\<or>\n         (\\<forall>n1>n.\n             \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                \\<not> isReceiverOf p m))\n  infiniteExecution fe ft \\<and>\n  (\\<forall>n n0.\n      n0 < length (fe n) \\<longrightarrow>\n      (\\<forall>p msg.\n          enabled (fe n ! n0) msg \\<and>\n          isReceiverOf p msg \\<and>\n          correctInfinite fe ft p \\<longrightarrow>\n          (\\<exists>n'\\<ge>n.\n              \\<exists>n0'\\<ge>n0.\n                 n0' < length (ft n') \\<and> msg = ft n' ! n0')))\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       \\<exists>n.\n          (\\<exists>i0<length (ft n).\n              \\<exists>b.\n                 <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n       (unpackMessage (ft n ! i0)) \\<and>\n                 isReceiverOf p (ft n ! i0)) \\<or>\n          (\\<forall>n1>n.\n              \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                 \\<not> isReceiverOf p m)", "by blast"], ["proof (state)\nthis:\n  \\<forall>p.\n     \\<exists>n.\n        (\\<exists>i0<length (ft n).\n            \\<exists>b.\n               <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n     (unpackMessage (ft n ! i0)) \\<and>\n               isReceiverOf p (ft n ! i0)) \\<or>\n        (\\<forall>n1>n.\n            \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n               \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. False", "have \"\\<forall> p . \\<exists> n . (\\<forall> n1 > n . \\<forall> m \\<in> (set (drop (length (ft n)) (ft n1))) .\n    \\<not> isReceiverOf p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       \\<exists>n.\n          \\<forall>n1>n.\n             \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                \\<not> isReceiverOf p m", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<exists>n.\n          \\<forall>n1>n.\n             \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                \\<not> isReceiverOf p m", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<exists>n.\n          \\<forall>n1>n.\n             \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                \\<not> isReceiverOf p m", "from AllDecideOrCrash"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     \\<exists>n.\n        (\\<exists>i0<length (ft n).\n            \\<exists>b.\n               <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n     (unpackMessage (ft n ! i0)) \\<and>\n               isReceiverOf p (ft n ! i0)) \\<or>\n        (\\<forall>n1>n.\n            \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n               \\<not> isReceiverOf p m)", "have\n    \"\\<exists> n . \n       (\\<exists> i0 < length (ft n) . \\<exists>b. \n        (<\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))) \n       \\<and> isReceiverOf p (ft n ! i0)) \n      \\<or> (\\<forall> n1 > n . \\<forall> m \\<in> (set (drop (length (ft n)) (ft n1))). \n        \\<not> isReceiverOf p m)\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     \\<exists>n.\n        (\\<exists>i0<length (ft n).\n            \\<exists>b.\n               <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n     (unpackMessage (ft n ! i0)) \\<and>\n               isReceiverOf p (ft n ! i0)) \\<or>\n        (\\<forall>n1>n.\n            \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n               \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       (\\<exists>i0<length (ft n).\n           \\<exists>b.\n              <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n    (unpackMessage (ft n ! i0)) \\<and>\n              isReceiverOf p (ft n ! i0)) \\<or>\n       (\\<forall>n1>n.\n           \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n              \\<not> isReceiverOf p m)", "by simp"], ["proof (state)\nthis:\n  \\<exists>n.\n     (\\<exists>i0<length (ft n).\n         \\<exists>b.\n            <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n  (unpackMessage (ft n ! i0)) \\<and>\n            isReceiverOf p (ft n ! i0)) \\<or>\n     (\\<forall>n1>n.\n         \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n            \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<exists>n.\n          \\<forall>n1>n.\n             \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                \\<not> isReceiverOf p m", "hence \"(\\<exists> n . \\<exists> i0 < length (ft n) . \n         (\\<exists>b. (<\\<bottom>, outM b> \\<in># \n            sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))) \n          \\<and> isReceiverOf p (ft n ! i0)))\n         \\<or> (\\<exists> n .\\<forall> n1 > n . \\<forall> m \\<in> (set (drop (length (ft n)) (ft n1))) .\n           \\<not> isReceiverOf p m)\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     (\\<exists>i0<length (ft n).\n         \\<exists>b.\n            <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n  (unpackMessage (ft n ! i0)) \\<and>\n            isReceiverOf p (ft n ! i0)) \\<or>\n     (\\<forall>n1>n.\n         \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n            \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. (\\<exists>n i0.\n        i0 < length (ft n) \\<and>\n        (\\<exists>b.\n            <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n  (unpackMessage (ft n ! i0)) \\<and>\n            isReceiverOf p (ft n ! i0))) \\<or>\n    (\\<exists>n.\n        \\<forall>n1>n.\n           \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n              \\<not> isReceiverOf p m)", "by blast"], ["proof (state)\nthis:\n  (\\<exists>n i0.\n      i0 < length (ft n) \\<and>\n      (\\<exists>b.\n          <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n(unpackMessage (ft n ! i0)) \\<and>\n          isReceiverOf p (ft n ! i0))) \\<or>\n  (\\<exists>n.\n      \\<forall>n1>n.\n         \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n            \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<exists>n.\n          \\<forall>n1>n.\n             \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                \\<not> isReceiverOf p m", "thus \"\\<exists>n. (\\<forall>n1>n. (\\<forall> m \\<in> (set (drop (length (ft n)) (ft n1))).\n      (\\<not> (isReceiverOf p m))))\""], ["proof (prove)\nusing this:\n  (\\<exists>n i0.\n      i0 < length (ft n) \\<and>\n      (\\<exists>b.\n          <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n(unpackMessage (ft n ! i0)) \\<and>\n          isReceiverOf p (ft n ! i0))) \\<or>\n  (\\<exists>n.\n      \\<forall>n1>n.\n         \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n            \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<forall>n1>n.\n          \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n             \\<not> isReceiverOf p m", "proof(elim disjE, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "fix n i0 b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "assume DecidingPoint:\n        \"i0 < length (ft n)\"\n        \"isReceiverOf p (ft n ! i0)\"\n        \"<\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))\""], ["proof (state)\nthis:\n  i0 < length (ft n)\n  isReceiverOf p (ft n ! i0)\n  <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                              (unpackMessage (ft n ! i0))\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "have \"i0 < length (fe n) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i0 < length (fe n) - 1", "using DecidingPoint(1)"], ["proof (prove)\nusing this:\n  i0 < length (ft n)\n\ngoal (1 subgoal):\n 1. i0 < length (fe n) - 1", "by (metis (no_types) FE(3) execution.length)"], ["proof (state)\nthis:\n  i0 < length (fe n) - 1\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "hence StepN0: \"((fe n) ! i0) \\<turnstile> ((ft n) ! i0) \\<mapsto> ((fe n) ! (i0 + 1))\""], ["proof (prove)\nusing this:\n  i0 < length (fe n) - 1\n\ngoal (1 subgoal):\n 1. fe n ! i0 \\<turnstile> ft n ! i0 \\<mapsto> fe n ! (i0 + 1)", "using FE"], ["proof (prove)\nusing this:\n  i0 < length (fe n) - 1\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. fe n ! i0 \\<turnstile> ft n ! i0 \\<mapsto> fe n ! (i0 + 1)", "by (metis execution.step)"], ["proof (state)\nthis:\n  fe n ! i0 \\<turnstile> ft n ! i0 \\<mapsto> fe n ! (i0 + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "hence \"msgs ((fe n) ! (i0 + 1)) <\\<bottom>, outM b> \n        = (msgs ((fe n) ! i0) <\\<bottom>, outM b>) +\n        (sends p (states ((fe n) ! i0) p) \n        (unpackMessage ((ft n) ! i0)) <\\<bottom>, outM b>)\""], ["proof (prove)\nusing this:\n  fe n ! i0 \\<turnstile> ft n ! i0 \\<mapsto> fe n ! (i0 + 1)\n\ngoal (1 subgoal):\n 1. msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b> =\n    (msgs\n      (fe n !\n       i0) \\<union># sends p (states (fe n ! i0) p)\n                      (unpackMessage (ft n ! i0)))\n     <\\<bottom>, outM b>", "using DecidingPoint(2) OutOnlyGrowing[of \"(fe n) ! i0\" \"(ft n) ! i0\"\n          \"(fe n) ! (i0 + 1)\" \"p\"]"], ["proof (prove)\nusing this:\n  fe n ! i0 \\<turnstile> ft n ! i0 \\<mapsto> fe n ! (i0 + 1)\n  isReceiverOf p (ft n ! i0)\n  \\<lbrakk>fe n ! i0 \\<turnstile> ft n ! i0 \\<mapsto> fe n ! (i0 + 1);\n   isReceiverOf p (ft n ! i0)\\<rbrakk>\n  \\<Longrightarrow> msgs (fe n ! (i0 + 1)) <\\<bottom>, outM ?b> =\n                    (msgs\n                      (fe n !\n                       i0) \\<union># sends p (states (fe n ! i0) p)\n(unpackMessage (ft n ! i0)))\n                     <\\<bottom>, outM ?b>\n\ngoal (1 subgoal):\n 1. msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b> =\n    (msgs\n      (fe n !\n       i0) \\<union># sends p (states (fe n ! i0) p)\n                      (unpackMessage (ft n ! i0)))\n     <\\<bottom>, outM b>", "by auto"], ["proof (state)\nthis:\n  msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b> =\n  (msgs\n    (fe n !\n     i0) \\<union># sends p (states (fe n ! i0) p)\n                    (unpackMessage (ft n ! i0)))\n   <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "hence \"(sends p (states ((fe n) ! i0) p) \n        (unpackMessage ((ft n) ! i0)) <\\<bottom>, outM b>) \n        \\<le> msgs ((fe n) ! (i0 + 1)) <\\<bottom>, outM b>\""], ["proof (prove)\nusing this:\n  msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b> =\n  (msgs\n    (fe n !\n     i0) \\<union># sends p (states (fe n ! i0) p)\n                    (unpackMessage (ft n ! i0)))\n   <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))\n     <\\<bottom>, outM b>\n    \\<le> msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b>", "using asynchronousSystem.steps_def"], ["proof (prove)\nusing this:\n  msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b> =\n  (msgs\n    (fe n !\n     i0) \\<union># sends p (states (fe n ! i0) p)\n                    (unpackMessage (ft n ! i0)))\n   <\\<bottom>, outM b>\n  asynchronousSystem.steps ?trans ?sends \\<equiv>\n  \\<lambda>uu uua.\n     rec_message\n      (\\<lambda>p v cfg1 cfg2.\n          (\\<forall>s.\n              (s = p \\<longrightarrow>\n               states cfg2 p = ?trans p (states cfg1 p) (Bool v)) \\<and>\n              (s \\<noteq> p \\<longrightarrow>\n               states cfg2 s = states cfg1 s)) \\<and>\n          enabled cfg1 <p, inM v> \\<and>\n          msgs cfg2 =\n          ?sends p (states cfg1 p)\n           (Bool v) \\<union># msgs cfg1 -# <p, inM v>)\n      (\\<lambda>v cfg1 cfg2. False)\n      (\\<lambda>p v cfg1 cfg2.\n          (\\<forall>s.\n              (s = p \\<longrightarrow>\n               states cfg2 p = ?trans p (states cfg1 p) (Value v)) \\<and>\n              (s \\<noteq> p \\<longrightarrow>\n               states cfg2 s = states cfg1 s)) \\<and>\n          enabled cfg1 <p, v> \\<and>\n          msgs cfg2 =\n          ?sends p (states cfg1 p) (Value v) \\<union># msgs cfg1 -# <p, v>)\n      uua uu\n\ngoal (1 subgoal):\n 1. sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))\n     <\\<bottom>, outM b>\n    \\<le> msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b>", "by auto"], ["proof (state)\nthis:\n  sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))\n   <\\<bottom>, outM b>\n  \\<le> msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "hence OutMsgEx: \"0 < msgs ((fe n) ! (i0 + 1)) <\\<bottom>, outM b>\""], ["proof (prove)\nusing this:\n  sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))\n   <\\<bottom>, outM b>\n  \\<le> msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1))", "using asynchronousSystem.steps_def DecidingPoint(3)"], ["proof (prove)\nusing this:\n  sends p (states (fe n ! i0) p) (unpackMessage (ft n ! i0))\n   <\\<bottom>, outM b>\n  \\<le> msgs (fe n ! (i0 + 1)) <\\<bottom>, outM b>\n  asynchronousSystem.steps ?trans ?sends \\<equiv>\n  \\<lambda>uu uua.\n     rec_message\n      (\\<lambda>p v cfg1 cfg2.\n          (\\<forall>s.\n              (s = p \\<longrightarrow>\n               states cfg2 p = ?trans p (states cfg1 p) (Bool v)) \\<and>\n              (s \\<noteq> p \\<longrightarrow>\n               states cfg2 s = states cfg1 s)) \\<and>\n          enabled cfg1 <p, inM v> \\<and>\n          msgs cfg2 =\n          ?sends p (states cfg1 p)\n           (Bool v) \\<union># msgs cfg1 -# <p, inM v>)\n      (\\<lambda>v cfg1 cfg2. False)\n      (\\<lambda>p v cfg1 cfg2.\n          (\\<forall>s.\n              (s = p \\<longrightarrow>\n               states cfg2 p = ?trans p (states cfg1 p) (Value v)) \\<and>\n              (s \\<noteq> p \\<longrightarrow>\n               states cfg2 s = states cfg1 s)) \\<and>\n          enabled cfg1 <p, v> \\<and>\n          msgs cfg2 =\n          ?sends p (states cfg1 p) (Value v) \\<union># msgs cfg1 -# <p, v>)\n      uua uu\n  <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                              (unpackMessage (ft n ! i0))\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1))", "by auto"], ["proof (state)\nthis:\n  <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "have \"(i0 + 1) < length (fe n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i0 + 1 < length (fe n)", "using DecidingPoint(1) \\<open>i0 < length (fe n) - 1\\<close>"], ["proof (prove)\nusing this:\n  i0 < length (ft n)\n  i0 < length (fe n) - 1\n\ngoal (1 subgoal):\n 1. i0 + 1 < length (fe n)", "by auto"], ["proof (state)\nthis:\n  i0 + 1 < length (fe n)\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "hence \"initReachable ((fe n) ! (i0 + 1))\""], ["proof (prove)\nusing this:\n  i0 + 1 < length (fe n)\n\ngoal (1 subgoal):\n 1. initReachable (fe n ! (i0 + 1))", "using AllExecsFromInit Cfg(1)"], ["proof (prove)\nusing this:\n  i0 + 1 < length (fe n)\n  \\<forall>n n0.\n     n0 < length (fe n) \\<longrightarrow> reachable cfg (fe n ! n0)\n  initial cfg\n\ngoal (1 subgoal):\n 1. initReachable (fe n ! (i0 + 1))", "by (metis asynchronousSystem.initReachable_def)"], ["proof (state)\nthis:\n  initReachable (fe n ! (i0 + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "hence Decided: \"vDecided b ((fe n) ! (i0 + 1))\""], ["proof (prove)\nusing this:\n  initReachable (fe n ! (i0 + 1))\n\ngoal (1 subgoal):\n 1. initReachable (fe n ! (i0 + 1)) \\<and>\n    <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1))", "using OutMsgEx"], ["proof (prove)\nusing this:\n  initReachable (fe n ! (i0 + 1))\n  <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1))\n\ngoal (1 subgoal):\n 1. initReachable (fe n ! (i0 + 1)) \\<and>\n    <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1))", "by auto"], ["proof (state)\nthis:\n  initReachable (fe n ! (i0 + 1)) \\<and>\n  <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1))\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "have \"i0 + 1 < length (fe n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i0 + 1 < length (fe n)", "using DecidingPoint(1)"], ["proof (prove)\nusing this:\n  i0 < length (ft n)\n\ngoal (1 subgoal):\n 1. i0 + 1 < length (fe n)", "by (metis \\<open>(((i0::nat) + (1::nat)) < (length (\n          (fe::(nat \\<Rightarrow> ('p, 'v, 's) configuration list)) (n::nat))))\\<close>)"], ["proof (state)\nthis:\n  i0 + 1 < length (fe n)\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "hence \"\\<not> vDecided b ((fe n) ! (i0 + 1))\""], ["proof (prove)\nusing this:\n  i0 + 1 < length (fe n)\n\ngoal (1 subgoal):\n 1. \\<not> (initReachable (fe n ! (i0 + 1)) \\<and>\n            <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1)))", "using NoDecided"], ["proof (prove)\nusing this:\n  i0 + 1 < length (fe n)\n  \\<forall>n n0 v.\n     n0 < length (fe n) \\<longrightarrow>\n     \\<not> (initReachable (fe n ! n0) \\<and>\n             <\\<bottom>, outM v> \\<in># msgs (fe n ! n0))\n\ngoal (1 subgoal):\n 1. \\<not> (initReachable (fe n ! (i0 + 1)) \\<and>\n            <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1)))", "by auto"], ["proof (state)\nthis:\n  \\<not> (initReachable (fe n ! (i0 + 1)) \\<and>\n          <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "hence \"False\""], ["proof (prove)\nusing this:\n  \\<not> (initReachable (fe n ! (i0 + 1)) \\<and>\n          <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1)))\n\ngoal (1 subgoal):\n 1. False", "using Decided"], ["proof (prove)\nusing this:\n  \\<not> (initReachable (fe n ! (i0 + 1)) \\<and>\n          <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1)))\n  initReachable (fe n ! (i0 + 1)) \\<and>\n  <\\<bottom>, outM b> \\<in># msgs (fe n ! (i0 + 1))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>n i0 b.\n       \\<lbrakk>i0 < length (ft n); isReceiverOf p (ft n ! i0);\n        <\\<bottom>, outM b> \\<in># sends p (states (fe n ! i0) p)\n                                    (unpackMessage (ft n ! i0))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n.\n                            \\<forall>n1>n.\n                               \\<forall>m\n  \\<in>set (drop (length (ft n)) (ft n1)).\n                                  \\<not> isReceiverOf p m", "thus \"\\<exists>n. (\\<forall>n1>n. (\\<forall> m \\<in> (set (drop (length (ft n)) (ft n1))). \n        (\\<not> (isReceiverOf p m))))\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       \\<forall>n1>n.\n          \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n             \\<not> isReceiverOf p m", "by simp"], ["proof (state)\nthis:\n  \\<exists>n.\n     \\<forall>n1>n.\n        \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n           \\<not> isReceiverOf p m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n.\n     \\<forall>n1>n.\n        \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n           \\<not> isReceiverOf p m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p.\n     \\<exists>n.\n        \\<forall>n1>n.\n           \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n              \\<not> isReceiverOf p m\n\ngoal (1 subgoal):\n 1. False", "hence \"\\<exists> (crashPoint::'p \\<Rightarrow> nat) . \n    \\<forall> p . \\<exists>  n . crashPoint p = n \\<and> (\\<forall> n1 > n . \\<forall> m \\<in> (set (drop \n    (length (ft n)) (ft n1))) . (\\<not> isReceiverOf p m))\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     \\<exists>n.\n        \\<forall>n1>n.\n           \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n              \\<not> isReceiverOf p m\n\ngoal (1 subgoal):\n 1. \\<exists>crashPoint.\n       \\<forall>p.\n          \\<exists>n.\n             crashPoint p = n \\<and>\n             (\\<forall>n1>n.\n                 \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                    \\<not> isReceiverOf p m)", "by metis"], ["proof (state)\nthis:\n  \\<exists>crashPoint.\n     \\<forall>p.\n        \\<exists>n.\n           crashPoint p = n \\<and>\n           (\\<forall>n1>n.\n               \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                  \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>crashPoint.\n     \\<forall>p.\n        \\<exists>n.\n           crashPoint p = n \\<and>\n           (\\<forall>n1>n.\n               \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                  \\<not> isReceiverOf p m)", "obtain crashPoint where CrashPoint:\n    \"\\<forall> p . (\\<forall> n1 > (crashPoint p) . \\<forall> m \\<in> (set (drop (length \n    (ft (crashPoint p))) (ft n1))) . (\\<not> isReceiverOf p m))\""], ["proof (prove)\nusing this:\n  \\<exists>crashPoint.\n     \\<forall>p.\n        \\<exists>n.\n           crashPoint p = n \\<and>\n           (\\<forall>n1>n.\n               \\<forall>m\\<in>set (drop (length (ft n)) (ft n1)).\n                  \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. (\\<And>crashPoint.\n        \\<forall>p n1.\n           crashPoint p < n1 \\<longrightarrow>\n           (\\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft n1)).\n               \\<not> isReceiverOf p m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>p n1.\n     crashPoint p < n1 \\<longrightarrow>\n     (\\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft n1)).\n         \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. False", "define limitSet where \"limitSet = {crashPoint p | p . p \\<in> Proc}\""], ["proof (state)\nthis:\n  limitSet = {crashPoint p |p. p \\<in> Proc}\n\ngoal (1 subgoal):\n 1. False", "have \"finite {p. p \\<in> Proc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p. p \\<in> Proc}", "using finiteProcs"], ["proof (prove)\nusing this:\n  finite Proc\n\ngoal (1 subgoal):\n 1. finite {p. p \\<in> Proc}", "by simp"], ["proof (state)\nthis:\n  finite {p. p \\<in> Proc}\n\ngoal (1 subgoal):\n 1. False", "hence \"finite limitSet\""], ["proof (prove)\nusing this:\n  finite {p. p \\<in> Proc}\n\ngoal (1 subgoal):\n 1. finite limitSet", "using limitSet_def finite_image_set[]"], ["proof (prove)\nusing this:\n  finite {p. p \\<in> Proc}\n  limitSet = {crashPoint p |p. p \\<in> Proc}\n  finite {x. ?P x} \\<Longrightarrow> finite {?f x |x. ?P x}\n\ngoal (1 subgoal):\n 1. finite limitSet", "by blast"], ["proof (state)\nthis:\n  finite limitSet\n\ngoal (1 subgoal):\n 1. False", "hence \"\\<exists> limit . \\<forall> l \\<in> limitSet . l < limit\""], ["proof (prove)\nusing this:\n  finite limitSet\n\ngoal (1 subgoal):\n 1. \\<exists>limit. \\<forall>l\\<in>limitSet. l < limit", "using \n    finite_nat_set_iff_bounded"], ["proof (prove)\nusing this:\n  finite limitSet\n  finite ?N = (\\<exists>m. \\<forall>n\\<in>?N. n < m)\n\ngoal (1 subgoal):\n 1. \\<exists>limit. \\<forall>l\\<in>limitSet. l < limit", "by auto"], ["proof (state)\nthis:\n  \\<exists>limit. \\<forall>l\\<in>limitSet. l < limit\n\ngoal (1 subgoal):\n 1. False", "hence \"\\<exists> limit . \\<forall> p . (crashPoint p) < limit\""], ["proof (prove)\nusing this:\n  \\<exists>limit. \\<forall>l\\<in>limitSet. l < limit\n\ngoal (1 subgoal):\n 1. \\<exists>limit. \\<forall>p. crashPoint p < limit", "using limitSet_def"], ["proof (prove)\nusing this:\n  \\<exists>limit. \\<forall>l\\<in>limitSet. l < limit\n  limitSet = {crashPoint p |p. p \\<in> Proc}\n\ngoal (1 subgoal):\n 1. \\<exists>limit. \\<forall>p. crashPoint p < limit", "by auto"], ["proof (state)\nthis:\n  \\<exists>limit. \\<forall>p. crashPoint p < limit\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>limit. \\<forall>p. crashPoint p < limit", "obtain limit where Limit: \"\\<forall> p . (crashPoint p) < limit\""], ["proof (prove)\nusing this:\n  \\<exists>limit. \\<forall>p. crashPoint p < limit\n\ngoal (1 subgoal):\n 1. (\\<And>limit.\n        \\<forall>p. crashPoint p < limit \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>p. crashPoint p < limit\n\ngoal (1 subgoal):\n 1. False", "define lengthLimit where \"lengthLimit = length (ft limit) - 1\""], ["proof (state)\nthis:\n  lengthLimit = length (ft limit) - 1\n\ngoal (1 subgoal):\n 1. False", "define lateMessage where \"lateMessage = last (ft limit)\""], ["proof (state)\nthis:\n  lateMessage = last (ft limit)\n\ngoal (1 subgoal):\n 1. False", "hence \"lateMessage = (ft limit) ! (length (ft limit) - 1)\""], ["proof (prove)\nusing this:\n  lateMessage = last (ft limit)\n\ngoal (1 subgoal):\n 1. lateMessage = ft limit ! (length (ft limit) - 1)", "by (metis AllArePrefixesTrace Limit last_conv_nth less_nat_zero_code \n      list.size(3) PrefixListMonotonicity)"], ["proof (state)\nthis:\n  lateMessage = ft limit ! (length (ft limit) - 1)\n\ngoal (1 subgoal):\n 1. False", "hence LateIsLast: \"lateMessage = (ft limit) ! lengthLimit\""], ["proof (prove)\nusing this:\n  lateMessage = ft limit ! (length (ft limit) - 1)\n\ngoal (1 subgoal):\n 1. lateMessage = ft limit ! lengthLimit", "using lateMessage_def lengthLimit_def"], ["proof (prove)\nusing this:\n  lateMessage = ft limit ! (length (ft limit) - 1)\n  lateMessage = last (ft limit)\n  lengthLimit = length (ft limit) - 1\n\ngoal (1 subgoal):\n 1. lateMessage = ft limit ! lengthLimit", "by auto"], ["proof (state)\nthis:\n  lateMessage = ft limit ! lengthLimit\n\ngoal (1 subgoal):\n 1. False", "have \"\\<exists> p . isReceiverOf p lateMessage\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. isReceiverOf p lateMessage", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>p. isReceiverOf p lateMessage \\<Longrightarrow> False", "assume \"\\<not> (\\<exists>(p::'p). (isReceiverOf p lateMessage))\""], ["proof (state)\nthis:\n  \\<nexists>p. isReceiverOf p lateMessage\n\ngoal (1 subgoal):\n 1. \\<nexists>p. isReceiverOf p lateMessage \\<Longrightarrow> False", "hence IsOutMsg: \"\\<exists> v . lateMessage = <\\<bottom>, outM v>\""], ["proof (prove)\nusing this:\n  \\<nexists>p. isReceiverOf p lateMessage\n\ngoal (1 subgoal):\n 1. \\<exists>v. lateMessage = <\\<bottom>, outM v>", "by (metis isReceiverOf.simps(1) isReceiverOf.simps(2) message.exhaust)"], ["proof (state)\nthis:\n  \\<exists>v. lateMessage = <\\<bottom>, outM v>\n\ngoal (1 subgoal):\n 1. \\<nexists>p. isReceiverOf p lateMessage \\<Longrightarrow> False", "have \"execution trans sends start (fe limit) (ft limit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution trans sends start (fe limit) (ft limit)", "using FE"], ["proof (prove)\nusing this:\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. execution trans sends start (fe limit) (ft limit)", "by auto"], ["proof (state)\nthis:\n  execution trans sends start (fe limit) (ft limit)\n\ngoal (1 subgoal):\n 1. \\<nexists>p. isReceiverOf p lateMessage \\<Longrightarrow> False", "hence \"length (fe limit) - 1 = length (ft limit)\""], ["proof (prove)\nusing this:\n  execution trans sends start (fe limit) (ft limit)\n\ngoal (1 subgoal):\n 1. length (fe limit) - 1 = length (ft limit)", "using execution.length"], ["proof (prove)\nusing this:\n  execution trans sends start (fe limit) (ft limit)\n  execution ?trans ?sends ?start ?exec ?trace \\<Longrightarrow>\n  length ?exec - 1 = length ?trace\n\ngoal (1 subgoal):\n 1. length (fe limit) - 1 = length (ft limit)", "by simp"], ["proof (state)\nthis:\n  length (fe limit) - 1 = length (ft limit)\n\ngoal (1 subgoal):\n 1. \\<nexists>p. isReceiverOf p lateMessage \\<Longrightarrow> False", "hence \"lengthLimit < length (fe limit) - 1\""], ["proof (prove)\nusing this:\n  length (fe limit) - 1 = length (ft limit)\n\ngoal (1 subgoal):\n 1. lengthLimit < length (fe limit) - 1", "using lengthLimit_def"], ["proof (prove)\nusing this:\n  length (fe limit) - 1 = length (ft limit)\n  lengthLimit = length (ft limit) - 1\n\ngoal (1 subgoal):\n 1. lengthLimit < length (fe limit) - 1", "by (metis (hide_lams, no_types) Length Limit One_nat_def Suc_eq_plus1\n        Suc_le_eq diff_less \n        diffs0_imp_equal gr_implies_not0 less_Suc0 neq0_conv)"], ["proof (state)\nthis:\n  lengthLimit < length (fe limit) - 1\n\ngoal (1 subgoal):\n 1. \\<nexists>p. isReceiverOf p lateMessage \\<Longrightarrow> False", "hence \"((fe limit) ! lengthLimit) \\<turnstile> ((ft limit) ! lengthLimit) \n      \\<mapsto> ((fe limit) ! (lengthLimit + 1))\""], ["proof (prove)\nusing this:\n  lengthLimit < length (fe limit) - 1\n\ngoal (1 subgoal):\n 1. fe limit !\n    lengthLimit \\<turnstile> ft limit !\n                             lengthLimit \\<mapsto> fe limit !\n             (lengthLimit + 1)", "using FE"], ["proof (prove)\nusing this:\n  lengthLimit < length (fe limit) - 1\n  fe 0 = [cfg]\n  fairInfiniteExecution fe ft\n  \\<forall>n.\n     nonUniform (last (fe n)) \\<and>\n     prefixList (fe n) (fe (n + 1)) \\<and>\n     prefixList (ft n) (ft (n + 1)) \\<and>\n     execution trans sends start (fe n) (ft n)\n\ngoal (1 subgoal):\n 1. fe limit !\n    lengthLimit \\<turnstile> ft limit !\n                             lengthLimit \\<mapsto> fe limit !\n             (lengthLimit + 1)", "by (metis execution.step)"], ["proof (state)\nthis:\n  fe limit !\n  lengthLimit \\<turnstile> ft limit !\n                           lengthLimit \\<mapsto> fe limit !\n           (lengthLimit + 1)\n\ngoal (1 subgoal):\n 1. \\<nexists>p. isReceiverOf p lateMessage \\<Longrightarrow> False", "hence \"((fe limit) ! lengthLimit) \\<turnstile> lateMessage \\<mapsto> ((fe limit) ! \n      (lengthLimit + 1))\""], ["proof (prove)\nusing this:\n  fe limit !\n  lengthLimit \\<turnstile> ft limit !\n                           lengthLimit \\<mapsto> fe limit !\n           (lengthLimit + 1)\n\ngoal (1 subgoal):\n 1. fe limit !\n    lengthLimit \\<turnstile> lateMessage \\<mapsto> fe limit !\n             (lengthLimit + 1)", "using LateIsLast"], ["proof (prove)\nusing this:\n  fe limit !\n  lengthLimit \\<turnstile> ft limit !\n                           lengthLimit \\<mapsto> fe limit !\n           (lengthLimit + 1)\n  lateMessage = ft limit ! lengthLimit\n\ngoal (1 subgoal):\n 1. fe limit !\n    lengthLimit \\<turnstile> lateMessage \\<mapsto> fe limit !\n             (lengthLimit + 1)", "by auto"], ["proof (state)\nthis:\n  fe limit !\n  lengthLimit \\<turnstile> lateMessage \\<mapsto> fe limit !\n           (lengthLimit + 1)\n\ngoal (1 subgoal):\n 1. \\<nexists>p. isReceiverOf p lateMessage \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  fe limit !\n  lengthLimit \\<turnstile> lateMessage \\<mapsto> fe limit !\n           (lengthLimit + 1)\n\ngoal (1 subgoal):\n 1. False", "using IsOutMsg steps_def"], ["proof (prove)\nusing this:\n  fe limit !\n  lengthLimit \\<turnstile> lateMessage \\<mapsto> fe limit !\n           (lengthLimit + 1)\n  \\<exists>v. lateMessage = <\\<bottom>, outM v>\n  steps \\<equiv>\n  \\<lambda>uu uua.\n     rec_message\n      (\\<lambda>p v cfg1 cfg2.\n          (\\<forall>s.\n              (s = p \\<longrightarrow>\n               states cfg2 p = trans p (states cfg1 p) (Bool v)) \\<and>\n              (s \\<noteq> p \\<longrightarrow>\n               states cfg2 s = states cfg1 s)) \\<and>\n          enabled cfg1 <p, inM v> \\<and>\n          msgs cfg2 =\n          sends p (states cfg1 p)\n           (Bool v) \\<union># msgs cfg1 -# <p, inM v>)\n      (\\<lambda>v cfg1 cfg2. False)\n      (\\<lambda>p v cfg1 cfg2.\n          (\\<forall>s.\n              (s = p \\<longrightarrow>\n               states cfg2 p = trans p (states cfg1 p) (Value v)) \\<and>\n              (s \\<noteq> p \\<longrightarrow>\n               states cfg2 s = states cfg1 s)) \\<and>\n          enabled cfg1 <p, v> \\<and>\n          msgs cfg2 =\n          sends p (states cfg1 p) (Value v) \\<union># msgs cfg1 -# <p, v>)\n      uua uu\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p. isReceiverOf p lateMessage\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. isReceiverOf p lateMessage", "obtain p where ReceiverOfLate: \"isReceiverOf p lateMessage\""], ["proof (prove)\nusing this:\n  \\<exists>p. isReceiverOf p lateMessage\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        isReceiverOf p lateMessage \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  isReceiverOf p lateMessage\n\ngoal (1 subgoal):\n 1. False", "have \"\\<forall> n1 > (crashPoint p) . \n    \\<forall> m \\<in> (set (drop (length (ft (crashPoint p))) (ft n1))) . \n      (\\<not> isReceiverOf p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n1>crashPoint p.\n       \\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft n1)).\n          \\<not> isReceiverOf p m", "using CrashPoint"], ["proof (prove)\nusing this:\n  \\<forall>p n1.\n     crashPoint p < n1 \\<longrightarrow>\n     (\\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft n1)).\n         \\<not> isReceiverOf p m)\n\ngoal (1 subgoal):\n 1. \\<forall>n1>crashPoint p.\n       \\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft n1)).\n          \\<not> isReceiverOf p m", "by simp"], ["proof (state)\nthis:\n  \\<forall>n1>crashPoint p.\n     \\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft n1)).\n        \\<not> isReceiverOf p m\n\ngoal (1 subgoal):\n 1. False", "hence NoMsgAfterLimit: \"\\<forall> m \\<in> (set (drop (length (ft (crashPoint p))) \n    (ft limit))) . (\\<not> isReceiverOf p m)\""], ["proof (prove)\nusing this:\n  \\<forall>n1>crashPoint p.\n     \\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft n1)).\n        \\<not> isReceiverOf p m\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft limit)).\n       \\<not> isReceiverOf p m", "using Limit"], ["proof (prove)\nusing this:\n  \\<forall>n1>crashPoint p.\n     \\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft n1)).\n        \\<not> isReceiverOf p m\n  \\<forall>p. crashPoint p < limit\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft limit)).\n       \\<not> isReceiverOf p m", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft limit)).\n     \\<not> isReceiverOf p m\n\ngoal (1 subgoal):\n 1. False", "have \"lateMessage \\<in> set (drop (length(ft (crashPoint p))) (ft limit))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))", "have \"crashPoint p < limit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crashPoint p < limit", "using Limit"], ["proof (prove)\nusing this:\n  \\<forall>p. crashPoint p < limit\n\ngoal (1 subgoal):\n 1. crashPoint p < limit", "by simp"], ["proof (state)\nthis:\n  crashPoint p < limit\n\ngoal (1 subgoal):\n 1. lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))", "hence \"prefixList (ft (crashPoint p)) (ft limit)\""], ["proof (prove)\nusing this:\n  crashPoint p < limit\n\ngoal (1 subgoal):\n 1. prefixList (ft (crashPoint p)) (ft limit)", "using AllArePrefixesTrace"], ["proof (prove)\nusing this:\n  crashPoint p < limit\n  \\<forall>m n. m < n \\<longrightarrow> prefixList (ft m) (ft n)\n\ngoal (1 subgoal):\n 1. prefixList (ft (crashPoint p)) (ft limit)", "by auto"], ["proof (state)\nthis:\n  prefixList (ft (crashPoint p)) (ft limit)\n\ngoal (1 subgoal):\n 1. lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))", "hence CrashShorterLimit: \"length (ft (crashPoint p)) \n      < length (ft limit)\""], ["proof (prove)\nusing this:\n  prefixList (ft (crashPoint p)) (ft limit)\n\ngoal (1 subgoal):\n 1. length (ft (crashPoint p)) < length (ft limit)", "using PrefixListMonotonicity"], ["proof (prove)\nusing this:\n  prefixList (ft (crashPoint p)) (ft limit)\n  prefixList ?l1.0 ?l2.0 \\<Longrightarrow> length ?l1.0 < length ?l2.0\n\ngoal (1 subgoal):\n 1. length (ft (crashPoint p)) < length (ft limit)", "by auto"], ["proof (state)\nthis:\n  length (ft (crashPoint p)) < length (ft limit)\n\ngoal (1 subgoal):\n 1. lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))", "hence \"last (drop (length (ft (crashPoint p))) (ft limit)) \n      = last (ft limit)\""], ["proof (prove)\nusing this:\n  length (ft (crashPoint p)) < length (ft limit)\n\ngoal (1 subgoal):\n 1. last (drop (length (ft (crashPoint p))) (ft limit)) = last (ft limit)", "by (metis last_drop)"], ["proof (state)\nthis:\n  last (drop (length (ft (crashPoint p))) (ft limit)) = last (ft limit)\n\ngoal (1 subgoal):\n 1. lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))", "hence \"lateMessage = last (drop (length (ft (crashPoint p))) \n      (ft limit))\""], ["proof (prove)\nusing this:\n  last (drop (length (ft (crashPoint p))) (ft limit)) = last (ft limit)\n\ngoal (1 subgoal):\n 1. lateMessage = last (drop (length (ft (crashPoint p))) (ft limit))", "using lateMessage_def"], ["proof (prove)\nusing this:\n  last (drop (length (ft (crashPoint p))) (ft limit)) = last (ft limit)\n  lateMessage = last (ft limit)\n\ngoal (1 subgoal):\n 1. lateMessage = last (drop (length (ft (crashPoint p))) (ft limit))", "by auto"], ["proof (state)\nthis:\n  lateMessage = last (drop (length (ft (crashPoint p))) (ft limit))\n\ngoal (1 subgoal):\n 1. lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))", "thus \"lateMessage \\<in> set (drop (length(ft (crashPoint p))) (ft limit))\""], ["proof (prove)\nusing this:\n  lateMessage = last (drop (length (ft (crashPoint p))) (ft limit))\n\ngoal (1 subgoal):\n 1. lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))", "by (metis CrashShorterLimit drop_eq_Nil last_in_set not_le)"], ["proof (state)\nthis:\n  lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))\n\ngoal (1 subgoal):\n 1. False", "hence \"\\<not> isReceiverOf p lateMessage\""], ["proof (prove)\nusing this:\n  lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))\n\ngoal (1 subgoal):\n 1. \\<not> isReceiverOf p lateMessage", "using NoMsgAfterLimit"], ["proof (prove)\nusing this:\n  lateMessage \\<in> set (drop (length (ft (crashPoint p))) (ft limit))\n  \\<forall>m\\<in>set (drop (length (ft (crashPoint p))) (ft limit)).\n     \\<not> isReceiverOf p m\n\ngoal (1 subgoal):\n 1. \\<not> isReceiverOf p lateMessage", "by auto"], ["proof (state)\nthis:\n  \\<not> isReceiverOf p lateMessage\n\ngoal (1 subgoal):\n 1. False", "thus \"False\""], ["proof (prove)\nusing this:\n  \\<not> isReceiverOf p lateMessage\n\ngoal (1 subgoal):\n 1. False", "using ReceiverOfLate"], ["proof (prove)\nusing this:\n  \\<not> isReceiverOf p lateMessage\n  isReceiverOf p lateMessage\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}