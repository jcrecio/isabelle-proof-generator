{"file_name": "/home/qj213/afp-2021-10-22/thys/FLP/AsynchronousSystem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FLP", "problem_names": ["lemma UniqueReceiverOf:\nfixes \n  msg  :: \"('p, 'v) message\" and\n  p q :: 'p\nassumes\n  \"isReceiverOf q msg\"\n  \"p \\<noteq> q\"\nshows \n  \"\\<not> isReceiverOf p msg\"", "lemma NoReceivingNoChange:\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  m :: \"('p,'v) message\" and\n  p :: 'p\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\" and\n  Rec: \"\\<not> isReceiverOf p m\"\nshows\n  \"states cfg1 p = states cfg2 p \"", "lemma ExistsMsg:\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  m :: \"('p,'v) message\"\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\"\nshows\n  \"m \\<in># (msgs cfg1)\"", "lemma NoMessageLossStep:\nfixes\n  cfg1 :: \"('p,'v,'s) configuration\" and\n  cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  m :: \"('p,'v) message\" and\n  m' :: \"('p,'v) message\"\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\" and\n  Rec1: \"isReceiverOf p m\" and\n  Rec2: \"\\<not>isReceiverOf p m'\"\nshows \n  \"msgs cfg1 m' \\<le> msgs cfg2 m'\"", "lemma OutOnlyGrowing:\nfixes \n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  b::bool and\n  m::\"('p, 'v) message\" and\n  p::'p\nassumes\n  \"cfg1 \\<turnstile> m \\<mapsto> cfg2\"\n  \"isReceiverOf p m\"\nshows \n  \"msgs cfg2 <\\<bottom>, outM b> \n  = (msgs cfg1 <\\<bottom>, outM b>) + \n    sends p (states cfg1 p) (unpackMessage m) <\\<bottom>, outM b>\"", "lemma OtherMessagesOnlyGrowing:\nfixes\n  cfg1 :: \"('p,'v,'s) configuration\" and\n  cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  m :: \"('p,'v) message\" and\n  m' :: \"('p,'v) message\"\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\" and\n  \"m \\<noteq> m'\"\nshows\n  \"msgs cfg1 m' \\<le> msgs cfg2 m'\"", "lemma OnlyOccurenceDisables:\nfixes\n  cfg1 :: \"('p,'v,'s) configuration\" and\n  cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  m :: \"('p,'v) message\" and\n  m' :: \"('p,'v) message\"\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\" and\n  En: \"enabled cfg1 m'\" and\n  NotEn: \"\\<not> (enabled cfg2 m')\"\nshows\n  \"m = m'\"", "lemma ReachableStepFirst: \nassumes\n  \"reachable cfg cfg'\"\nshows \n  \"cfg = cfg' \\<or> (\\<exists> cfg1 msg p . (cfg \\<turnstile> msg \\<mapsto> cfg1) \\<and> enabled cfg msg \n                    \\<and> isReceiverOf p msg  \n                    \\<and> reachable cfg1 cfg')\"", "lemma ReachableTrans: \nfixes \n  cfg1 cfg2 cfg3 :: \"('p, 'v, 's ) configuration\" and \n  Q :: \" 'p set\"\nassumes \n  \"reachable cfg1 cfg2\" and \n  \"reachable cfg2 cfg3\"\nshows \"reachable cfg1 cfg3\"", "lemma StepReachable:\nfixes\n  cfg cfg' :: \"('p,'v,'s) configuration\" and\n  msg :: \"('p, 'v) message\"\nassumes\n  \"reachable cfg cfg'\" and\n  \"enabled cfg msg\" and\n  \"\\<not> (enabled cfg' msg)\"\nshows \"stepReachable cfg msg cfg'\"", "lemma QReachImplReach:\nfixes\n  cfg1 cfg2::  \"('p, 'v, 's ) configuration\" and\n  Q :: \" 'p set\"\nassumes\n  \"qReachable cfg1 Q cfg2\"\nshows \n  \"reachable cfg1 cfg2\"", "lemma QReachableTrans: \nfixes cfg1 cfg2 cfg3 :: \"('p, 'v, 's ) configuration\" and\n  Q :: \" 'p set\"\nassumes \"qReachable cfg2 Q cfg3\" and\n  \"qReachable cfg1 Q cfg2\"\nshows \"qReachable cfg1 Q cfg3\"", "lemma NotInQFrozenQReachability: \nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  Q :: \"'p set\"\nassumes\n  \"qReachable cfg1 Q cfg2\" and\n  \"p \\<notin> Q\"\nshows\n  \"states cfg1 p = states cfg2 p\"", "lemma NoActivityNoMessageLoss :\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  Q :: \"'p set\" and\n  m' :: \"('p, 'v) message\"\nassumes\n  \"qReachable cfg1 Q cfg2\" and\n  \"p \\<notin> Q\" and\n  \"isReceiverOf p m'\"\nshows\n  \"(msgs cfg1 m') \\<le> (msgs cfg2 m')\"", "lemma NoMessageLoss:\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  Q :: \"'p set\" and\n  m' :: \"('p, 'v) message\"\nassumes\n  \"withoutQReachable cfg1 Q cfg2\" and\n  \"p \\<in> Q\" and\n  \"isReceiverOf p m'\"\nshows\n  \"(msgs cfg1 m') \\<le> (msgs cfg2 m')\"", "lemma NoOutMessageLoss:\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  v :: bool\nassumes\n  \"reachable cfg1 cfg2\"\nshows\n  \"(msgs cfg1 <\\<bottom>, outM v>) \\<le> (msgs cfg2 <\\<bottom>, outM v>)\"", "lemma StillEnabled:\nfixes \n  cfg1 cfg2:: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  msg :: \"('p,'v) message\" and\n  Q :: \"'p set\"\nassumes \n  \"withoutQReachable cfg1 Q cfg2\" and\n  \"p \\<in> Q\" and\n  \"isReceiverOf p msg\" and\n  \"enabled cfg1 msg\"\nshows\n  \"enabled cfg2 msg\"", "lemma InitialIsInitReachable :\nassumes \"initial c\"\nshows \"initReachable c\"", "lemma DiamondOne:\nfixes\n  cfg cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  p q :: 'p and\n  m m' :: \"('p,'v) message\"\nassumes\n  StepP: \"cfg \\<turnstile> m  \\<mapsto> cfg1\" and\n  PNotQ: \"p \\<noteq> q\" and\n  Rec: \"isReceiverOf p m\" \"\\<not> (isReceiverOf p m')\" and\n  Rec': \"isReceiverOf q m'\" \"\\<not> (isReceiverOf q m)\" and\n  StepWithoutP: \"cfg \\<turnstile> m' \\<mapsto> cfg2\"\nshows\n  \"\\<exists> cfg' :: ('p,'v,'s) configuration . (cfg1 \\<turnstile> m' \\<mapsto> cfg')\n        \\<and> (cfg2 \\<turnstile> m \\<mapsto> cfg')\"", "lemma DiamondTwo:\nfixes\n  cfg cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  Q :: \"'p set\" and\n  msg :: \"('p, 'v) message\"\nassumes\n  QReach: \"qReachable cfg Q cfg1\" and\n  Step: \"cfg  \\<turnstile> msg \\<mapsto> cfg2\"\n        \"\\<exists>p\\<in>Proc - Q. isReceiverOf p msg\"\nshows\n  \"\\<exists> (cfg' :: ('p,'v,'s) configuration) . (cfg1  \\<turnstile> msg \\<mapsto> cfg') \n  \\<and> qReachable cfg2 Q cfg'\"", "lemma Diamond:\nfixes\n  cfg cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  Q :: \"'p set\"\nassumes\n  QReach: \"qReachable cfg Q cfg1\" and\n  WithoutQReach: \"withoutQReachable cfg Q cfg2\"\nshows \n  \"\\<exists> cfg'. withoutQReachable cfg1 Q cfg' \n     \\<and> qReachable cfg2 Q cfg'\"", "lemma FiniteMessages:\nfixes \n  cfg  :: \"('p, 'v, 's) configuration\"\nassumes\n  FiniteProcs: \"finite Proc\" and\n  FiniteSends: \"\\<And> p s m. finite {v. v \\<in># (sends p s m)}\" and\n  InitReachable: \"initReachable cfg\"\nshows \"finite {msg . msg \\<in># msgs cfg}\""], "translations": [["", "lemma UniqueReceiverOf:\nfixes \n  msg  :: \"('p, 'v) message\" and\n  p q :: 'p\nassumes\n  \"isReceiverOf q msg\"\n  \"p \\<noteq> q\"\nshows \n  \"\\<not> isReceiverOf p msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> isReceiverOf p msg", "using assms"], ["proof (prove)\nusing this:\n  isReceiverOf q msg\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<not> isReceiverOf p msg", "by (cases msg, auto)"], ["", "subsection\\<open>Configurations\\<close>"], ["", "text \\<open>\n  Here we formalize a configuration as detailed in section 2 of V?lzer's paper.\n\n  Note that V?lzer imposes the finiteness of the message multiset by\n  definition while we do not do so. In \\isb{FiniteMessages}\n  We prove the finiteness to follow from the assumption that only\n  finitely many messages can be sent at once.\n\\<close>"], ["", "record ('p, 'v, 's) configuration =\n  states :: \"'p \\<Rightarrow> 's\"\n  msgs :: \"(('p, 'v) message) multiset\""], ["", "text \\<open>\n  C.f. V?lzer: \\textquote{A step is identified with a message $(p, m)$. A step $(p, m)$ is enabled\n  in a configuration c if $\\var{msgs}_c$ contains the message $(p, m)$.}\n\\<close>"], ["", "definition enabled ::\n  \"('p, 'v, 's) configuration \\<Rightarrow> ('p, 'v) message \\<Rightarrow> bool\"\nwhere \n  \"enabled cfg msg \\<equiv> (msg \\<in># msgs cfg)\""], ["", "subsection \\<open>The system locale\\<close>"], ["", "text \\<open>\n  The locale describing a system is derived by slight refactoring from the\n  following passage of V?lzer:\n  \\begin{displayquote}\n    A process $p$ consists of an initial state $s_p \\in S$ and a step transition\n    function, which assigns to each pair $(m, s)$ of a message value $m$ and\n    a process state $s$ a follower state and a finite set of messages (the\n    messages to be sent by $p$ in a step).\n  \\end{displayquote}\n\\<close>"], ["", "locale asynchronousSystem =\nfixes \n  trans :: \"'p \\<Rightarrow> 's \\<Rightarrow> 'v messageValue \\<Rightarrow> 's\" and\n  sends :: \"'p \\<Rightarrow> 's \\<Rightarrow> 'v messageValue \\<Rightarrow> ('p, 'v) message multiset\" and\n  start :: \"'p \\<Rightarrow> 's\"\nbegin"], ["", "abbreviation Proc :: \"'p set\"\nwhere \"Proc \\<equiv> (UNIV :: 'p set)\""], ["", "subsection \\<open>The step relation\\<close>"], ["", "text \\<open>\n  The step relation is defined analogously to V?lzer:\n  \\begin{displayquote}\n    {[}If enabled, a step may{]} occur, resulting in a follower\n    configuration $c^\\prime$, where $c^\\prime$ is obtained from $c$ by removing\n    $(p, m)$ from $\\var{msgs}_c$, changing $p$'s state and adding the set of\n    messages to $\\var{msgs}_c$ according to the step transition function\n    associated with $p$. We denote this by $c \\xrightarrow{p,m} c^\\prime$.\n  \\end{displayquote}\n  There are no steps consuming output messages.\n\\<close>"], ["", "primrec steps :: \n  \"('p, 'v, 's) configuration\n   \\<Rightarrow> ('p, 'v) message\n   \\<Rightarrow> ('p, 'v, 's) configuration\n   \\<Rightarrow> bool\"\n   (\"_ \\<turnstile> _ \\<mapsto> _\" [70,70,70])\nwhere \n  StepInMsg: \"cfg1 \\<turnstile> <p, inM v> \\<mapsto> cfg2 = (\n  (\\<forall> s. ((s = p) \\<longrightarrow> states cfg2 p = trans p (states cfg1 p) (Bool v))\n      \\<and> ((s \\<noteq> p) \\<longrightarrow> states cfg2 s = states cfg1 s))\n   \\<and> enabled cfg1 <p, inM v>\n   \\<and> msgs cfg2 = (sends p (states cfg1 p) (Bool v)\n                  \\<union># (msgs cfg1 -# <p, inM v>)))\"\n| StepMsg: \"cfg1 \\<turnstile> <p, v> \\<mapsto> cfg2 = (\n  (\\<forall> s. ((s = p) \\<longrightarrow> states cfg2 p = trans p (states cfg1 p) (Value v))\n      \\<and> ((s \\<noteq> p) \\<longrightarrow> states cfg2 s = states cfg1 s))\n   \\<and> enabled cfg1 <p, v>\n   \\<and> msgs cfg2 = (sends p (states cfg1 p) (Value v)\n                  \\<union># (msgs cfg1 -# <p, v>)))\"\n| StepOutMsg: \"cfg1 \\<turnstile> <\\<bottom>,outM v> \\<mapsto> cfg2 = \n    False\""], ["", "text \\<open>\n  The system is distributed and asynchronous in the sense that the processing\n  of messages only affects the process the message is directed to while the\n  rest stays unchanged.\n\\<close>"], ["", "lemma NoReceivingNoChange:\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  m :: \"('p,'v) message\" and\n  p :: 'p\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\" and\n  Rec: \"\\<not> isReceiverOf p m\"\nshows\n  \"states cfg1 p = states cfg2 p \""], ["proof (prove)\ngoal (1 subgoal):\n 1. states cfg1 p = states cfg2 p", "proof(cases m)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow> states cfg1 p = states cfg2 p\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       states cfg1 p = states cfg2 p\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "case (OutMsg b')"], ["proof (state)\nthis:\n  m = <\\<bottom>, outM b'>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow> states cfg1 p = states cfg2 p\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       states cfg1 p = states cfg2 p\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "thus ?thesis"], ["proof (prove)\nusing this:\n  m = <\\<bottom>, outM b'>\n\ngoal (1 subgoal):\n 1. states cfg1 p = states cfg2 p", "using Step"], ["proof (prove)\nusing this:\n  m = <\\<bottom>, outM b'>\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n\ngoal (1 subgoal):\n 1. states cfg1 p = states cfg2 p", "by auto"], ["proof (state)\nthis:\n  states cfg1 p = states cfg2 p\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow> states cfg1 p = states cfg2 p\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow> states cfg1 p = states cfg2 p\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "case (InMsg q b')"], ["proof (state)\nthis:\n  m = <q, inM b'>\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow> states cfg1 p = states cfg2 p\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "assume CaseM:  \"m = <q, inM b'>\""], ["proof (state)\nthis:\n  m = <q, inM b'>\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow> states cfg1 p = states cfg2 p\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "with assms"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  \\<not> isReceiverOf p m\n  m = <q, inM b'>", "have \"p \\<noteq> q\""], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  \\<not> isReceiverOf p m\n  m = <q, inM b'>\n\ngoal (1 subgoal):\n 1. p \\<noteq> q", "by simp"], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow> states cfg1 p = states cfg2 p\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "with Step CaseM"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <q, inM b'>\n  p \\<noteq> q", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <q, inM b'>\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. states cfg1 p = states cfg2 p", "by simp"], ["proof (state)\nthis:\n  states cfg1 p = states cfg2 p\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "case (Msg q v')"], ["proof (state)\nthis:\n  m = <q, v'>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "assume CaseM:  \"m = <q, v'>\""], ["proof (state)\nthis:\n  m = <q, v'>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "with assms"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  \\<not> isReceiverOf p m\n  m = <q, v'>", "have \"p \\<noteq> q\""], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  \\<not> isReceiverOf p m\n  m = <q, v'>\n\ngoal (1 subgoal):\n 1. p \\<noteq> q", "by simp"], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow> states cfg1 p = states cfg2 p", "with Step CaseM"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <q, v'>\n  p \\<noteq> q", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <q, v'>\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. states cfg1 p = states cfg2 p", "by simp"], ["proof (state)\nthis:\n  states cfg1 p = states cfg2 p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ExistsMsg:\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  m :: \"('p,'v) message\"\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\"\nshows\n  \"m \\<in># (msgs cfg1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in># msgs cfg1", "using assms enabled_def"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  enabled ?cfg ?msg \\<equiv> ?msg \\<in># msgs ?cfg\n\ngoal (1 subgoal):\n 1. m \\<in># msgs cfg1", "by (cases m, auto)"], ["", "lemma NoMessageLossStep:\nfixes\n  cfg1 :: \"('p,'v,'s) configuration\" and\n  cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  m :: \"('p,'v) message\" and\n  m' :: \"('p,'v) message\"\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\" and\n  Rec1: \"isReceiverOf p m\" and\n  Rec2: \"\\<not>isReceiverOf p m'\"\nshows \n  \"msgs cfg1 m' \\<le> msgs cfg2 m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cfg1 m' \\<le> msgs cfg2 m'", "using assms"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  isReceiverOf p m\n  \\<not> isReceiverOf p m'\n\ngoal (1 subgoal):\n 1. msgs cfg1 m' \\<le> msgs cfg2 m'", "by (induct m, simp_all, auto)"], ["", "lemma OutOnlyGrowing:\nfixes \n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  b::bool and\n  m::\"('p, 'v) message\" and\n  p::'p\nassumes\n  \"cfg1 \\<turnstile> m \\<mapsto> cfg2\"\n  \"isReceiverOf p m\"\nshows \n  \"msgs cfg2 <\\<bottom>, outM b> \n  = (msgs cfg1 <\\<bottom>, outM b>) + \n    sends p (states cfg1 p) (unpackMessage m) <\\<bottom>, outM b>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cfg2 <\\<bottom>, outM b> =\n    (msgs cfg1 \\<union># sends p (states cfg1 p) (unpackMessage m))\n     <\\<bottom>, outM b>", "proof(-)"], ["proof (state)\ngoal (1 subgoal):\n 1. msgs cfg2 <\\<bottom>, outM b> =\n    (msgs cfg1 \\<union># sends p (states cfg1 p) (unpackMessage m))\n     <\\<bottom>, outM b>", "have \"m = <\\<bottom>, outM b> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = <\\<bottom>, outM b> \\<Longrightarrow> False", "using assms"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  isReceiverOf p m\n\ngoal (1 subgoal):\n 1. m = <\\<bottom>, outM b> \\<Longrightarrow> False", "proof(auto)"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m = <\\<bottom>, outM b> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. msgs cfg2 <\\<bottom>, outM b> =\n    (msgs cfg1 \\<union># sends p (states cfg1 p) (unpackMessage m))\n     <\\<bottom>, outM b>", "hence MNotOut: \"m \\<noteq> <\\<bottom>, outM b>\""], ["proof (prove)\nusing this:\n  m = <\\<bottom>, outM b> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. m \\<noteq> <\\<bottom>, outM b>", "by auto"], ["proof (state)\nthis:\n  m \\<noteq> <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. msgs cfg2 <\\<bottom>, outM b> =\n    (msgs cfg1 \\<union># sends p (states cfg1 p) (unpackMessage m))\n     <\\<bottom>, outM b>", "have MsgFunction: \"msgs cfg2 \n                    = ((sends p (states cfg1 p) (unpackMessage m)) \n                      \\<union># ((msgs cfg1) -# m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "proof(cases m)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "case (InMsg pa bool)"], ["proof (state)\nthis:\n  m = <pa, inM bool>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "then"], ["proof (chain)\npicking this:\n  m = <pa, inM bool>", "have PaIsP: \"pa = p\" \"(unpackMessage m) = Bool bool\""], ["proof (prove)\nusing this:\n  m = <pa, inM bool>\n\ngoal (1 subgoal):\n 1. pa = p &&& unpackMessage m = Bool bool", "using isReceiverOf_def assms(2)"], ["proof (prove)\nusing this:\n  m = <pa, inM bool>\n  isReceiverOf \\<equiv>\n  \\<lambda>uu uua.\n     rec_message (\\<lambda>p2 v p1. p1 = p2) (\\<lambda>v p1. False)\n      (\\<lambda>p2 v p1. p1 = p2) uua uu\n  isReceiverOf p m\n\ngoal (1 subgoal):\n 1. pa = p &&& unpackMessage m = Bool bool", "by (auto simp add: UniqueReceiverOf)"], ["proof (state)\nthis:\n  pa = p\n  unpackMessage m = Bool bool\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "hence \"cfg1 \\<turnstile> <p, inM bool> \\<mapsto> cfg2\""], ["proof (prove)\nusing this:\n  pa = p\n  unpackMessage m = Bool bool\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> <p, inM bool> \\<mapsto> cfg2", "using assms(1) InMsg"], ["proof (prove)\nusing this:\n  pa = p\n  unpackMessage m = Bool bool\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <pa, inM bool>\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> <p, inM bool> \\<mapsto> cfg2", "by simp"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> <p, inM bool> \\<mapsto> cfg2\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "hence \"msgs cfg2 = (sends p (states cfg1 p) (Bool bool) \n                       \\<union># (msgs cfg1 -# <p, inM bool>))\""], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> <p, inM bool> \\<mapsto> cfg2\n\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# <p, inM bool>", "by simp"], ["proof (state)\nthis:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# <p, inM bool>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "hence \"msgs cfg2 = (sends p (states cfg1 p) (Bool bool) \n                       \\<union># (msgs cfg1 -# m))\""], ["proof (prove)\nusing this:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# <p, inM bool>\n\ngoal (1 subgoal):\n 1. msgs cfg2 = sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# m", "using PaIsP(1) InMsg"], ["proof (prove)\nusing this:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# <p, inM bool>\n  pa = p\n  m = <pa, inM bool>\n\ngoal (1 subgoal):\n 1. msgs cfg2 = sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# m", "by simp"], ["proof (state)\nthis:\n  msgs cfg2 = sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# m\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "thus ?thesis"], ["proof (prove)\nusing this:\n  msgs cfg2 = sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# m\n\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "using StepInMsg assms PaIsP"], ["proof (prove)\nusing this:\n  msgs cfg2 = sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# m\n  ?cfg1.0 \\<turnstile> <?p, inM ?v> \\<mapsto> ?cfg2.0 =\n  ((\\<forall>s.\n       (s = ?p \\<longrightarrow>\n        states ?cfg2.0 ?p = trans ?p (states ?cfg1.0 ?p) (Bool ?v)) \\<and>\n       (s \\<noteq> ?p \\<longrightarrow>\n        states ?cfg2.0 s = states ?cfg1.0 s)) \\<and>\n   enabled ?cfg1.0 <?p, inM ?v> \\<and>\n   msgs ?cfg2.0 =\n   sends ?p (states ?cfg1.0 ?p)\n    (Bool ?v) \\<union># msgs ?cfg1.0 -# <?p, inM ?v>)\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  isReceiverOf p m\n  pa = p\n  unpackMessage m = Bool bool\n\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "by simp"], ["proof (state)\nthis:\n  msgs cfg2 =\n  sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "case (OutMsg b)"], ["proof (state)\nthis:\n  m = <\\<bottom>, outM b>\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "hence False"], ["proof (prove)\nusing this:\n  m = <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  m = <\\<bottom>, outM b>\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  isReceiverOf p m\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "by simp"], ["proof (state)\nthis:\n  msgs cfg2 =\n  sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "case (Msg pa va)"], ["proof (state)\nthis:\n  m = <pa, va>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "hence PaIsP: \"pa = p\" \"(unpackMessage m) = Value va\""], ["proof (prove)\nusing this:\n  m = <pa, va>\n\ngoal (1 subgoal):\n 1. pa = p &&& unpackMessage m = Value va", "using isReceiverOf_def assms(2)"], ["proof (prove)\nusing this:\n  m = <pa, va>\n  isReceiverOf \\<equiv>\n  \\<lambda>uu uua.\n     rec_message (\\<lambda>p2 v p1. p1 = p2) (\\<lambda>v p1. False)\n      (\\<lambda>p2 v p1. p1 = p2) uua uu\n  isReceiverOf p m\n\ngoal (1 subgoal):\n 1. pa = p &&& unpackMessage m = Value va", "by (auto simp add: UniqueReceiverOf)"], ["proof (state)\nthis:\n  pa = p\n  unpackMessage m = Value va\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "hence \"cfg1 \\<turnstile> <p, va> \\<mapsto> cfg2\""], ["proof (prove)\nusing this:\n  pa = p\n  unpackMessage m = Value va\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> <p, va> \\<mapsto> cfg2", "using assms(1) Msg"], ["proof (prove)\nusing this:\n  pa = p\n  unpackMessage m = Value va\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <pa, va>\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> <p, va> \\<mapsto> cfg2", "by simp"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> <p, va> \\<mapsto> cfg2\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "hence \"msgs cfg2 = (sends p (states cfg1 p) (Value va) \n                       \\<union># (msgs cfg1 -# <p, va>))\""], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> <p, va> \\<mapsto> cfg2\n\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (Value va) \\<union># msgs cfg1 -# <p, va>", "by simp"], ["proof (state)\nthis:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Value va) \\<union># msgs cfg1 -# <p, va>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "hence \"msgs cfg2 = (sends p (states cfg1 p) (Value va) \n                       \\<union># (msgs cfg1 -# m))\""], ["proof (prove)\nusing this:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Value va) \\<union># msgs cfg1 -# <p, va>\n\ngoal (1 subgoal):\n 1. msgs cfg2 = sends p (states cfg1 p) (Value va) \\<union># msgs cfg1 -# m", "using PaIsP(1) Msg"], ["proof (prove)\nusing this:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Value va) \\<union># msgs cfg1 -# <p, va>\n  pa = p\n  m = <pa, va>\n\ngoal (1 subgoal):\n 1. msgs cfg2 = sends p (states cfg1 p) (Value va) \\<union># msgs cfg1 -# m", "by simp"], ["proof (state)\nthis:\n  msgs cfg2 = sends p (states cfg1 p) (Value va) \\<union># msgs cfg1 -# m\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       msgs cfg2 =\n       sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "thus ?thesis"], ["proof (prove)\nusing this:\n  msgs cfg2 = sends p (states cfg1 p) (Value va) \\<union># msgs cfg1 -# m\n\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "using StepInMsg assms PaIsP"], ["proof (prove)\nusing this:\n  msgs cfg2 = sends p (states cfg1 p) (Value va) \\<union># msgs cfg1 -# m\n  ?cfg1.0 \\<turnstile> <?p, inM ?v> \\<mapsto> ?cfg2.0 =\n  ((\\<forall>s.\n       (s = ?p \\<longrightarrow>\n        states ?cfg2.0 ?p = trans ?p (states ?cfg1.0 ?p) (Bool ?v)) \\<and>\n       (s \\<noteq> ?p \\<longrightarrow>\n        states ?cfg2.0 s = states ?cfg1.0 s)) \\<and>\n   enabled ?cfg1.0 <?p, inM ?v> \\<and>\n   msgs ?cfg2.0 =\n   sends ?p (states ?cfg1.0 ?p)\n    (Bool ?v) \\<union># msgs ?cfg1.0 -# <?p, inM ?v>)\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  isReceiverOf p m\n  pa = p\n  unpackMessage m = Value va\n\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m", "by simp"], ["proof (state)\nthis:\n  msgs cfg2 =\n  sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  msgs cfg2 =\n  sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n\ngoal (1 subgoal):\n 1. msgs cfg2 <\\<bottom>, outM b> =\n    (msgs cfg1 \\<union># sends p (states cfg1 p) (unpackMessage m))\n     <\\<bottom>, outM b>", "have \"((sends p (states cfg1 p) (unpackMessage m)) \n         \\<union># ((msgs cfg1) -# m)) <\\<bottom>, outM b> \n       = ((sends p (states cfg1 p) (unpackMessage m)) \n         \\<union># (msgs cfg1)) <\\<bottom>, outM b>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m)\n     <\\<bottom>, outM b> =\n    (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1)\n     <\\<bottom>, outM b>", "using MNotOut"], ["proof (prove)\nusing this:\n  m \\<noteq> <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m)\n     <\\<bottom>, outM b> =\n    (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1)\n     <\\<bottom>, outM b>", "by auto"], ["proof (state)\nthis:\n  (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m)\n   <\\<bottom>, outM b> =\n  (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1)\n   <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. msgs cfg2 <\\<bottom>, outM b> =\n    (msgs cfg1 \\<union># sends p (states cfg1 p) (unpackMessage m))\n     <\\<bottom>, outM b>", "thus \"msgs cfg2 <\\<bottom>, outM b> \n       = (msgs cfg1 <\\<bottom>, outM b>) + \n         sends p (states cfg1 p) (unpackMessage m) <\\<bottom>, outM b>\""], ["proof (prove)\nusing this:\n  (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m)\n   <\\<bottom>, outM b> =\n  (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1)\n   <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. msgs cfg2 <\\<bottom>, outM b> =\n    (msgs cfg1 \\<union># sends p (states cfg1 p) (unpackMessage m))\n     <\\<bottom>, outM b>", "using MsgFunction"], ["proof (prove)\nusing this:\n  (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m)\n   <\\<bottom>, outM b> =\n  (sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1)\n   <\\<bottom>, outM b>\n  msgs cfg2 =\n  sends p (states cfg1 p) (unpackMessage m) \\<union># msgs cfg1 -# m\n\ngoal (1 subgoal):\n 1. msgs cfg2 <\\<bottom>, outM b> =\n    (msgs cfg1 \\<union># sends p (states cfg1 p) (unpackMessage m))\n     <\\<bottom>, outM b>", "by simp"], ["proof (state)\nthis:\n  msgs cfg2 <\\<bottom>, outM b> =\n  (msgs cfg1 \\<union># sends p (states cfg1 p) (unpackMessage m))\n   <\\<bottom>, outM b>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OtherMessagesOnlyGrowing:\nfixes\n  cfg1 :: \"('p,'v,'s) configuration\" and\n  cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  m :: \"('p,'v) message\" and\n  m' :: \"('p,'v) message\"\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\" and\n  \"m \\<noteq> m'\"\nshows\n  \"msgs cfg1 m' \\<le> msgs cfg2 m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cfg1 m' \\<le> msgs cfg2 m'", "using assms"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m \\<noteq> m'\n\ngoal (1 subgoal):\n 1. msgs cfg1 m' \\<le> msgs cfg2 m'", "by (cases m, auto)"], ["", "text \\<open>\n  V?lzer: \\textquote{Note that steps are enabled persistently, i.e., an\n  enabled step remains enabled as long as it does not occur.}\n\\<close>"], ["", "lemma OnlyOccurenceDisables:\nfixes\n  cfg1 :: \"('p,'v,'s) configuration\" and\n  cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  m :: \"('p,'v) message\" and\n  m' :: \"('p,'v) message\"\nassumes\n  Step: \"cfg1 \\<turnstile> m \\<mapsto> cfg2\" and\n  En: \"enabled cfg1 m'\" and\n  NotEn: \"\\<not> (enabled cfg2 m')\"\nshows\n  \"m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = m'", "using assms"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  enabled cfg1 m'\n  \\<not> enabled cfg2 m'\n\ngoal (1 subgoal):\n 1. m = m'", "proof (cases m)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>x2.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 3. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "print_cases"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>x2.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 3. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "case (InMsg p bool)"], ["proof (state)\nthis:\n  m = <p, inM bool>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>x2.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 3. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "with Step"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <p, inM bool>", "have \"msgs cfg2 = (sends p (states cfg1 p) (Bool bool) \n                              \\<union># (msgs cfg1 -# <p, inM bool>))\""], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <p, inM bool>\n\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# <p, inM bool>", "by auto"], ["proof (state)\nthis:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# <p, inM bool>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>x2.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 3. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "thus \"m = m'\""], ["proof (prove)\nusing this:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# <p, inM bool>\n\ngoal (1 subgoal):\n 1. m = m'", "using InMsg En NotEn"], ["proof (prove)\nusing this:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Bool bool) \\<union># msgs cfg1 -# <p, inM bool>\n  m = <p, inM bool>\n  enabled cfg1 m'\n  \\<not> enabled cfg2 m'\n\ngoal (1 subgoal):\n 1. m = m'", "by (auto simp add: enabled_def, metis less_nat_zero_code)"], ["proof (state)\nthis:\n  m = m'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "case (OutMsg bool)"], ["proof (state)\nthis:\n  m = <\\<bottom>, outM bool>\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> m = m'\n 2. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "with Step"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <\\<bottom>, outM bool>", "show \"m = m'\""], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <\\<bottom>, outM bool>\n\ngoal (1 subgoal):\n 1. m = m'", "by auto"], ["proof (state)\nthis:\n  m = m'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "case (Msg p v)"], ["proof (state)\nthis:\n  m = <p, v>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "with Step"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <p, v>", "have \"msgs cfg2 = (sends p (states cfg1 p) (Value v) \n                              \\<union># (msgs cfg1 -# <p, v>))\""], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m \\<mapsto> cfg2\n  m = <p, v>\n\ngoal (1 subgoal):\n 1. msgs cfg2 =\n    sends p (states cfg1 p) (Value v) \\<union># msgs cfg1 -# <p, v>", "by auto"], ["proof (state)\nthis:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Value v) \\<union># msgs cfg1 -# <p, v>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2; enabled cfg1 m';\n        \\<not> enabled cfg2 m'; m = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> m = m'", "thus \"m = m'\""], ["proof (prove)\nusing this:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Value v) \\<union># msgs cfg1 -# <p, v>\n\ngoal (1 subgoal):\n 1. m = m'", "using Msg En NotEn"], ["proof (prove)\nusing this:\n  msgs cfg2 =\n  sends p (states cfg1 p) (Value v) \\<union># msgs cfg1 -# <p, v>\n  m = <p, v>\n  enabled cfg1 m'\n  \\<not> enabled cfg2 m'\n\ngoal (1 subgoal):\n 1. m = m'", "by (auto simp add: enabled_def, metis less_nat_zero_code)"], ["proof (state)\nthis:\n  m = m'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Reachability\\<close>"], ["", "inductive reachable :: \n  \"  ('p, 'v, 's) configuration \n  \\<Rightarrow> ('p, 'v, 's) configuration\n  \\<Rightarrow> bool\"\nwhere \n  init: \"reachable cfg1 cfg1\"\n| step: \"\\<lbrakk> reachable cfg1 cfg2; (cfg2 \\<turnstile> msg \\<mapsto> cfg3) \\<rbrakk> \n          \\<Longrightarrow> reachable cfg1 cfg3\""], ["", "lemma ReachableStepFirst: \nassumes\n  \"reachable cfg cfg'\"\nshows \n  \"cfg = cfg' \\<or> (\\<exists> cfg1 msg p . (cfg \\<turnstile> msg \\<mapsto> cfg1) \\<and> enabled cfg msg \n                    \\<and> isReceiverOf p msg  \n                    \\<and> reachable cfg1 cfg')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg = cfg' \\<or>\n    (\\<exists>cfg1 msg p.\n        cfg \\<turnstile> msg \\<mapsto> cfg1 \\<and>\n        enabled cfg msg \\<and>\n        isReceiverOf p msg \\<and> reachable cfg1 cfg')", "using assms"], ["proof (prove)\nusing this:\n  reachable cfg cfg'\n\ngoal (1 subgoal):\n 1. cfg = cfg' \\<or>\n    (\\<exists>cfg1 msg p.\n        cfg \\<turnstile> msg \\<mapsto> cfg1 \\<and>\n        enabled cfg msg \\<and>\n        isReceiverOf p msg \\<and> reachable cfg1 cfg')", "by (induct rule: reachable.induct, auto, \n    metis StepOutMsg ExistsMsg init enabled_def isReceiverOf.simps(1) \n    isReceiverOf.simps(2) message.exhaust, metis asynchronousSystem.step)"], ["", "lemma ReachableTrans: \nfixes \n  cfg1 cfg2 cfg3 :: \"('p, 'v, 's ) configuration\" and \n  Q :: \" 'p set\"\nassumes \n  \"reachable cfg1 cfg2\" and \n  \"reachable cfg2 cfg3\"\nshows \"reachable cfg1 cfg3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable cfg1 cfg3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable cfg1 cfg3", "have \"reachable cfg2 cfg3 \\<Longrightarrow> reachable cfg1 cfg2 \\<Longrightarrow> reachable cfg1 cfg3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reachable cfg2 cfg3; reachable cfg1 cfg2\\<rbrakk>\n    \\<Longrightarrow> reachable cfg1 cfg3", "proof (induct rule: reachable.induct, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1a cfg2; reachable cfg1 cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; reachable cfg1 cfg1a\\<rbrakk>\n       \\<Longrightarrow> reachable cfg1 cfg3", "fix cfg1' cfg2' msg cfg3'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1a cfg2; reachable cfg1 cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; reachable cfg1 cfg1a\\<rbrakk>\n       \\<Longrightarrow> reachable cfg1 cfg3", "assume \n      \"reachable cfg1 cfg2'\"\n      \"cfg2' \\<turnstile> msg \\<mapsto> cfg3'\""], ["proof (state)\nthis:\n  reachable cfg1 cfg2'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1a cfg2; reachable cfg1 cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; reachable cfg1 cfg1a\\<rbrakk>\n       \\<Longrightarrow> reachable cfg1 cfg3", "thus \"reachable cfg1 cfg3'\""], ["proof (prove)\nusing this:\n  reachable cfg1 cfg2'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3'\n\ngoal (1 subgoal):\n 1. reachable cfg1 cfg3'", "using reachable.simps"], ["proof (prove)\nusing this:\n  reachable cfg1 cfg2'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3'\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. reachable cfg1 cfg3'", "by metis"], ["proof (state)\nthis:\n  reachable cfg1 cfg3'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>reachable cfg2 cfg3; reachable cfg1 cfg2\\<rbrakk>\n  \\<Longrightarrow> reachable cfg1 cfg3\n\ngoal (1 subgoal):\n 1. reachable cfg1 cfg3", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>reachable cfg2 cfg3; reachable cfg1 cfg2\\<rbrakk>\n  \\<Longrightarrow> reachable cfg1 cfg3\n\ngoal (1 subgoal):\n 1. reachable cfg1 cfg3", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>reachable cfg2 cfg3; reachable cfg1 cfg2\\<rbrakk>\n  \\<Longrightarrow> reachable cfg1 cfg3\n  reachable cfg1 cfg2\n  reachable cfg2 cfg3\n\ngoal (1 subgoal):\n 1. reachable cfg1 cfg3", "by simp"], ["proof (state)\nthis:\n  reachable cfg1 cfg3\n\ngoal:\nNo subgoals!", "qed"], ["", "definition stepReachable ::\n    \"('p, 'v, 's) configuration\n  \\<Rightarrow> ('p ,'v) message\n  \\<Rightarrow> ('p, 'v, 's) configuration\n  \\<Rightarrow> bool\" \nwhere\n  \"stepReachable c1 msg c2 \\<equiv> \n    \\<exists> c' c''. reachable c1 c' \\<and> (c' \\<turnstile> msg \\<mapsto> c'') \\<and> reachable c'' c2 \""], ["", "lemma StepReachable:\nfixes\n  cfg cfg' :: \"('p,'v,'s) configuration\" and\n  msg :: \"('p, 'v) message\"\nassumes\n  \"reachable cfg cfg'\" and\n  \"enabled cfg msg\" and\n  \"\\<not> (enabled cfg' msg)\"\nshows \"stepReachable cfg msg cfg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stepReachable cfg msg cfg'", "using assms"], ["proof (prove)\nusing this:\n  reachable cfg cfg'\n  enabled cfg msg\n  \\<not> enabled cfg' msg\n\ngoal (1 subgoal):\n 1. stepReachable cfg msg cfg'", "proof(induct rule: reachable.induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msga cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>enabled cfg1 msg; \\<not> enabled cfg2 msg\\<rbrakk>\n        \\<Longrightarrow> stepReachable cfg1 msg cfg2;\n        cfg2 \\<turnstile> msga \\<mapsto> cfg3; enabled cfg1 msg;\n        \\<not> enabled cfg3 msg\\<rbrakk>\n       \\<Longrightarrow> stepReachable cfg1 msg cfg3", "fix cfg1 cfg2 msga cfg3"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msga cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>enabled cfg1 msg; \\<not> enabled cfg2 msg\\<rbrakk>\n        \\<Longrightarrow> stepReachable cfg1 msg cfg2;\n        cfg2 \\<turnstile> msga \\<mapsto> cfg3; enabled cfg1 msg;\n        \\<not> enabled cfg3 msg\\<rbrakk>\n       \\<Longrightarrow> stepReachable cfg1 msg cfg3", "assume Step: \"cfg2 \\<turnstile> msga \\<mapsto> cfg3\" and\n    ReachCfg1Cfg2: \"reachable cfg1 cfg2\" and\n    IV: \"(enabled cfg1 msg \\<Longrightarrow> \\<not> enabled cfg2 msg \n        \\<Longrightarrow> stepReachable cfg1 msg cfg2)\" and\n    AssumpInduct: \"enabled cfg1 msg\" \"\\<not> enabled cfg3 msg\""], ["proof (state)\nthis:\n  cfg2 \\<turnstile> msga \\<mapsto> cfg3\n  reachable cfg1 cfg2\n  \\<lbrakk>enabled cfg1 msg; \\<not> enabled cfg2 msg\\<rbrakk>\n  \\<Longrightarrow> stepReachable cfg1 msg cfg2\n  enabled cfg1 msg\n  \\<not> enabled cfg3 msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msga cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>enabled cfg1 msg; \\<not> enabled cfg2 msg\\<rbrakk>\n        \\<Longrightarrow> stepReachable cfg1 msg cfg2;\n        cfg2 \\<turnstile> msga \\<mapsto> cfg3; enabled cfg1 msg;\n        \\<not> enabled cfg3 msg\\<rbrakk>\n       \\<Longrightarrow> stepReachable cfg1 msg cfg3", "have ReachCfg2Cfg3: \"reachable cfg2 cfg3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable cfg2 cfg3", "using Step"], ["proof (prove)\nusing this:\n  cfg2 \\<turnstile> msga \\<mapsto> cfg3\n\ngoal (1 subgoal):\n 1. reachable cfg2 cfg3", "by (metis reachable.init reachable.step)"], ["proof (state)\nthis:\n  reachable cfg2 cfg3\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msga cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>enabled cfg1 msg; \\<not> enabled cfg2 msg\\<rbrakk>\n        \\<Longrightarrow> stepReachable cfg1 msg cfg2;\n        cfg2 \\<turnstile> msga \\<mapsto> cfg3; enabled cfg1 msg;\n        \\<not> enabled cfg3 msg\\<rbrakk>\n       \\<Longrightarrow> stepReachable cfg1 msg cfg3", "show \"stepReachable cfg1 msg cfg3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stepReachable cfg1 msg cfg3", "proof (cases \"enabled cfg2 msg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3\n 2. \\<not> enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3", "assume AssumpEnabled: \"enabled cfg2 msg\""], ["proof (state)\nthis:\n  enabled cfg2 msg\n\ngoal (2 subgoals):\n 1. enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3\n 2. \\<not> enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3", "hence \"msga = msg\""], ["proof (prove)\nusing this:\n  enabled cfg2 msg\n\ngoal (1 subgoal):\n 1. msga = msg", "using OnlyOccurenceDisables Step AssumpInduct(2)"], ["proof (prove)\nusing this:\n  enabled cfg2 msg\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0; enabled ?cfg1.0 ?m';\n   \\<not> enabled ?cfg2.0 ?m'\\<rbrakk>\n  \\<Longrightarrow> ?m = ?m'\n  cfg2 \\<turnstile> msga \\<mapsto> cfg3\n  \\<not> enabled cfg3 msg\n\ngoal (1 subgoal):\n 1. msga = msg", "by blast"], ["proof (state)\nthis:\n  msga = msg\n\ngoal (2 subgoals):\n 1. enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3\n 2. \\<not> enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3", "thus \"stepReachable cfg1 msg cfg3\""], ["proof (prove)\nusing this:\n  msga = msg\n\ngoal (1 subgoal):\n 1. stepReachable cfg1 msg cfg3", "using ReachCfg1Cfg2 Step"], ["proof (prove)\nusing this:\n  msga = msg\n  reachable cfg1 cfg2\n  cfg2 \\<turnstile> msga \\<mapsto> cfg3\n\ngoal (1 subgoal):\n 1. stepReachable cfg1 msg cfg3", "unfolding stepReachable_def"], ["proof (prove)\nusing this:\n  msga = msg\n  reachable cfg1 cfg2\n  cfg2 \\<turnstile> msga \\<mapsto> cfg3\n\ngoal (1 subgoal):\n 1. \\<exists>c' c''.\n       reachable cfg1 c' \\<and>\n       c' \\<turnstile> msg \\<mapsto> c'' \\<and> reachable c'' cfg3", "by (metis init)"], ["proof (state)\nthis:\n  stepReachable cfg1 msg cfg3\n\ngoal (1 subgoal):\n 1. \\<not> enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3", "assume AssumpNotEnabled: \"\\<not> enabled cfg2 msg\""], ["proof (state)\nthis:\n  \\<not> enabled cfg2 msg\n\ngoal (1 subgoal):\n 1. \\<not> enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3", "hence \"stepReachable cfg1 msg cfg2\""], ["proof (prove)\nusing this:\n  \\<not> enabled cfg2 msg\n\ngoal (1 subgoal):\n 1. stepReachable cfg1 msg cfg2", "using IV AssumpInduct(1)"], ["proof (prove)\nusing this:\n  \\<not> enabled cfg2 msg\n  \\<lbrakk>enabled cfg1 msg; \\<not> enabled cfg2 msg\\<rbrakk>\n  \\<Longrightarrow> stepReachable cfg1 msg cfg2\n  enabled cfg1 msg\n\ngoal (1 subgoal):\n 1. stepReachable cfg1 msg cfg2", "by simp"], ["proof (state)\nthis:\n  stepReachable cfg1 msg cfg2\n\ngoal (1 subgoal):\n 1. \\<not> enabled cfg2 msg \\<Longrightarrow> stepReachable cfg1 msg cfg3", "thus \"stepReachable cfg1 msg cfg3\""], ["proof (prove)\nusing this:\n  stepReachable cfg1 msg cfg2\n\ngoal (1 subgoal):\n 1. stepReachable cfg1 msg cfg3", "using ReachCfg2Cfg3 ReachableTrans asynchronousSystem.stepReachable_def"], ["proof (prove)\nusing this:\n  stepReachable cfg1 msg cfg2\n  reachable cfg2 cfg3\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n  asynchronousSystem.stepReachable ?trans ?sends ?c1.0 ?msg ?c2.0 \\<equiv>\n  \\<exists>c' c''.\n     asynchronousSystem.reachable ?trans ?sends ?c1.0 c' \\<and>\n     asynchronousSystem.steps ?trans ?sends c' ?msg c'' \\<and>\n     asynchronousSystem.reachable ?trans ?sends c'' ?c2.0\n\ngoal (1 subgoal):\n 1. stepReachable cfg1 msg cfg3", "by blast"], ["proof (state)\nthis:\n  stepReachable cfg1 msg cfg3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  stepReachable cfg1 msg cfg3\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Reachability with special process activity\\<close>"], ["", "text \\<open>\n  We say that \\isb{qReachable cfg1 Q cfg2} iff cfg2 is reachable from cfg1\n  only by activity of processes from Q.\n\\<close>"], ["", "inductive qReachable ::\n  \"('p,'v,'s) configuration \n  \\<Rightarrow> 'p set \n  \\<Rightarrow> ('p,'v,'s) configuration \n  \\<Rightarrow> bool\"\nwhere  \n  InitQ: \"qReachable cfg1 Q cfg1\"\n| StepQ: \"\\<lbrakk> qReachable cfg1 Q cfg2; (cfg2 \\<turnstile> msg \\<mapsto> cfg3) ;\n            \\<exists> p \\<in> Q . isReceiverOf p msg \\<rbrakk> \n          \\<Longrightarrow> qReachable cfg1 Q cfg3\""], ["", "text \\<open>\n  We say that \\isb{withoutQReachable cfg1 Q cfg2} iff cfg2 is reachable from cfg1\n  with no activity of processes from Q.\n\\<close>"], ["", "abbreviation withoutQReachable ::\n   \"('p,'v,'s) configuration \n  \\<Rightarrow> 'p set \n  \\<Rightarrow> ('p,'v,'s) configuration \n  \\<Rightarrow> bool\"\nwhere\n  \"withoutQReachable cfg1 Q cfg2 \\<equiv> \n    qReachable cfg1 ((UNIV :: 'p set ) - Q) cfg2\""], ["", "text\\<open>\n  Obviously q-reachability (and thus also without-q-reachability) implies \n  reachability.\n\\<close>"], ["", "lemma QReachImplReach:\nfixes\n  cfg1 cfg2::  \"('p, 'v, 's ) configuration\" and\n  Q :: \" 'p set\"\nassumes\n  \"qReachable cfg1 Q cfg2\"\nshows \n  \"reachable cfg1 cfg2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable cfg1 cfg2", "using assms"], ["proof (prove)\nusing this:\n  qReachable cfg1 Q cfg2\n\ngoal (1 subgoal):\n 1. reachable cfg1 cfg2", "proof (induct rule: qReachable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q. reachable cfg1 cfg1\n 2. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2; reachable cfg1 cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> reachable cfg1 cfg3", "case InitQ"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q. reachable cfg1 cfg1\n 2. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2; reachable cfg1 cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> reachable cfg1 cfg3", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable cfg1_ cfg1_", "using reachable.simps"], ["proof (prove)\nusing this:\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. reachable cfg1_ cfg1_", "by blast"], ["proof (state)\nthis:\n  reachable cfg1_ cfg1_\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2; reachable cfg1 cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> reachable cfg1 cfg3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2; reachable cfg1 cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> reachable cfg1 cfg3", "case StepQ"], ["proof (state)\nthis:\n  qReachable cfg1_ Q_ cfg2_\n  reachable cfg1_ cfg2_\n  cfg2_ \\<turnstile> msg_ \\<mapsto> cfg3_\n  \\<exists>p\\<in>Q_. isReceiverOf p msg_\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2; reachable cfg1 cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> reachable cfg1 cfg3", "thus ?case"], ["proof (prove)\nusing this:\n  qReachable cfg1_ Q_ cfg2_\n  reachable cfg1_ cfg2_\n  cfg2_ \\<turnstile> msg_ \\<mapsto> cfg3_\n  \\<exists>p\\<in>Q_. isReceiverOf p msg_\n\ngoal (1 subgoal):\n 1. reachable cfg1_ cfg3_", "using reachable.step"], ["proof (prove)\nusing this:\n  qReachable cfg1_ Q_ cfg2_\n  reachable cfg1_ cfg2_\n  cfg2_ \\<turnstile> msg_ \\<mapsto> cfg3_\n  \\<exists>p\\<in>Q_. isReceiverOf p msg_\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0;\n   ?cfg2.0 \\<turnstile> ?msg \\<mapsto> ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n\ngoal (1 subgoal):\n 1. reachable cfg1_ cfg3_", "by simp"], ["proof (state)\nthis:\n  reachable cfg1_ cfg3_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma QReachableTrans: \nfixes cfg1 cfg2 cfg3 :: \"('p, 'v, 's ) configuration\" and\n  Q :: \" 'p set\"\nassumes \"qReachable cfg2 Q cfg3\" and\n  \"qReachable cfg1 Q cfg2\"\nshows \"qReachable cfg1 Q cfg3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qReachable cfg1 Q cfg3", "using assms"], ["proof (prove)\nusing this:\n  qReachable cfg2 Q cfg3\n  qReachable cfg1 Q cfg2\n\ngoal (1 subgoal):\n 1. qReachable cfg1 Q cfg3", "proof (induct rule: qReachable.induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1a Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a Q cfg2;\n        qReachable cfg1 Q cfg1a \\<Longrightarrow> qReachable cfg1 Q cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg;\n        qReachable cfg1 Q cfg1a\\<rbrakk>\n       \\<Longrightarrow> qReachable cfg1 Q cfg3", "case (StepQ)"], ["proof (state)\nthis:\n  qReachable cfg1_ Q_ cfg2_\n  qReachable cfg1 Q_ cfg1_ \\<Longrightarrow> qReachable cfg1 Q_ cfg2_\n  cfg2_ \\<turnstile> msg_ \\<mapsto> cfg3_\n  \\<exists>p\\<in>Q_. isReceiverOf p msg_\n  qReachable cfg1 Q_ cfg1_\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a Q cfg2;\n        qReachable cfg1 Q cfg1a \\<Longrightarrow> qReachable cfg1 Q cfg2;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg;\n        qReachable cfg1 Q cfg1a\\<rbrakk>\n       \\<Longrightarrow> qReachable cfg1 Q cfg3", "thus ?case"], ["proof (prove)\nusing this:\n  qReachable cfg1_ Q_ cfg2_\n  qReachable cfg1 Q_ cfg1_ \\<Longrightarrow> qReachable cfg1 Q_ cfg2_\n  cfg2_ \\<turnstile> msg_ \\<mapsto> cfg3_\n  \\<exists>p\\<in>Q_. isReceiverOf p msg_\n  qReachable cfg1 Q_ cfg1_\n\ngoal (1 subgoal):\n 1. qReachable cfg1 Q_ cfg3_", "using qReachable.simps"], ["proof (prove)\nusing this:\n  qReachable cfg1_ Q_ cfg2_\n  qReachable cfg1 Q_ cfg1_ \\<Longrightarrow> qReachable cfg1 Q_ cfg2_\n  cfg2_ \\<turnstile> msg_ \\<mapsto> cfg3_\n  \\<exists>p\\<in>Q_. isReceiverOf p msg_\n  qReachable cfg1 Q_ cfg1_\n  qReachable ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>cfg1 Q.\n       ?a1.0 = cfg1 \\<and> ?a2.0 = Q \\<and> ?a3.0 = cfg1) \\<or>\n   (\\<exists>cfg1 Q cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = Q \\<and>\n       ?a3.0 = cfg3 \\<and>\n       qReachable cfg1 Q cfg2 \\<and>\n       cfg2 \\<turnstile> msg \\<mapsto> cfg3 \\<and>\n       (\\<exists>p\\<in>Q. isReceiverOf p msg)))\n\ngoal (1 subgoal):\n 1. qReachable cfg1 Q_ cfg3_", "by metis"], ["proof (state)\nthis:\n  qReachable cfg1 Q_ cfg3_\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NotInQFrozenQReachability: \nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  Q :: \"'p set\"\nassumes\n  \"qReachable cfg1 Q cfg2\" and\n  \"p \\<notin> Q\"\nshows\n  \"states cfg1 p = states cfg2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states cfg1 p = states cfg2 p", "using assms"], ["proof (prove)\nusing this:\n  qReachable cfg1 Q cfg2\n  p \\<notin> Q\n\ngoal (1 subgoal):\n 1. states cfg1 p = states cfg2 p", "proof(induct rule: qReachable.induct, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1a Qa cfg2a msg cfg3 pa.\n       \\<lbrakk>qReachable cfg1a Qa cfg2a; states cfg1a p = states cfg2a p;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; p \\<notin> Qa;\n        qReachable cfg1 Q cfg2; p \\<notin> Q; pa \\<in> Qa;\n        isReceiverOf pa msg\\<rbrakk>\n       \\<Longrightarrow> states cfg2a p = states cfg3 p", "fix cfg1' Q' cfg2' msg cfg3 p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1a Qa cfg2a msg cfg3 pa.\n       \\<lbrakk>qReachable cfg1a Qa cfg2a; states cfg1a p = states cfg2a p;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; p \\<notin> Qa;\n        qReachable cfg1 Q cfg2; p \\<notin> Q; pa \\<in> Qa;\n        isReceiverOf pa msg\\<rbrakk>\n       \\<Longrightarrow> states cfg2a p = states cfg3 p", "assume \"qReachable cfg1' Q' cfg2'\""], ["proof (state)\nthis:\n  qReachable cfg1' Q' cfg2'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a Qa cfg2a msg cfg3 pa.\n       \\<lbrakk>qReachable cfg1a Qa cfg2a; states cfg1a p = states cfg2a p;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; p \\<notin> Qa;\n        qReachable cfg1 Q cfg2; p \\<notin> Q; pa \\<in> Qa;\n        isReceiverOf pa msg\\<rbrakk>\n       \\<Longrightarrow> states cfg2a p = states cfg3 p", "assume Step: \"cfg2' \\<turnstile> msg \\<mapsto> cfg3\""], ["proof (state)\nthis:\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a Qa cfg2a msg cfg3 pa.\n       \\<lbrakk>qReachable cfg1a Qa cfg2a; states cfg1a p = states cfg2a p;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; p \\<notin> Qa;\n        qReachable cfg1 Q cfg2; p \\<notin> Q; pa \\<in> Qa;\n        isReceiverOf pa msg\\<rbrakk>\n       \\<Longrightarrow> states cfg2a p = states cfg3 p", "assume Rec: \"isReceiverOf p' msg\""], ["proof (state)\nthis:\n  isReceiverOf p' msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a Qa cfg2a msg cfg3 pa.\n       \\<lbrakk>qReachable cfg1a Qa cfg2a; states cfg1a p = states cfg2a p;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; p \\<notin> Qa;\n        qReachable cfg1 Q cfg2; p \\<notin> Q; pa \\<in> Qa;\n        isReceiverOf pa msg\\<rbrakk>\n       \\<Longrightarrow> states cfg2a p = states cfg3 p", "assume \"p' \\<in> Q'\"  \"p \\<notin> Q'\""], ["proof (state)\nthis:\n  p' \\<in> Q'\n  p \\<notin> Q'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a Qa cfg2a msg cfg3 pa.\n       \\<lbrakk>qReachable cfg1a Qa cfg2a; states cfg1a p = states cfg2a p;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; p \\<notin> Qa;\n        qReachable cfg1 Q cfg2; p \\<notin> Q; pa \\<in> Qa;\n        isReceiverOf pa msg\\<rbrakk>\n       \\<Longrightarrow> states cfg2a p = states cfg3 p", "hence notEq: \"p \\<noteq> p'\""], ["proof (prove)\nusing this:\n  p' \\<in> Q'\n  p \\<notin> Q'\n\ngoal (1 subgoal):\n 1. p \\<noteq> p'", "by blast"], ["proof (state)\nthis:\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a Qa cfg2a msg cfg3 pa.\n       \\<lbrakk>qReachable cfg1a Qa cfg2a; states cfg1a p = states cfg2a p;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; p \\<notin> Qa;\n        qReachable cfg1 Q cfg2; p \\<notin> Q; pa \\<in> Qa;\n        isReceiverOf pa msg\\<rbrakk>\n       \\<Longrightarrow> states cfg2a p = states cfg3 p", "with Rec"], ["proof (chain)\npicking this:\n  isReceiverOf p' msg\n  p \\<noteq> p'", "have \"\\<not> (isReceiverOf p msg)\""], ["proof (prove)\nusing this:\n  isReceiverOf p' msg\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. \\<not> isReceiverOf p msg", "by (cases msg, simp_all)"], ["proof (state)\nthis:\n  \\<not> isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a Qa cfg2a msg cfg3 pa.\n       \\<lbrakk>qReachable cfg1a Qa cfg2a; states cfg1a p = states cfg2a p;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; p \\<notin> Qa;\n        qReachable cfg1 Q cfg2; p \\<notin> Q; pa \\<in> Qa;\n        isReceiverOf pa msg\\<rbrakk>\n       \\<Longrightarrow> states cfg2a p = states cfg3 p", "thus \"states cfg2' p = states cfg3 p\""], ["proof (prove)\nusing this:\n  \\<not> isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. states cfg2' p = states cfg3 p", "using Step NoReceivingNoChange"], ["proof (prove)\nusing this:\n  \\<not> isReceiverOf p msg\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0;\n   \\<not> isReceiverOf ?p ?m\\<rbrakk>\n  \\<Longrightarrow> states ?cfg1.0 ?p = states ?cfg2.0 ?p\n\ngoal (1 subgoal):\n 1. states cfg2' p = states cfg3 p", "by simp"], ["proof (state)\nthis:\n  states cfg2' p = states cfg3 p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary WithoutQReachablFrozenQ:\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  Q :: \"'p set\"\nassumes\n  Steps: \"withoutQReachable cfg1 Q cfg2\" and\n  P: \"p \\<in> Q\"\nshows\n  \"states cfg1 p = states cfg2 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states cfg1 p = states cfg2 p", "using assms NotInQFrozenQReachability"], ["proof (prove)\nusing this:\n  qReachable cfg1 (Proc - Q) cfg2\n  p \\<in> Q\n  \\<lbrakk>qReachable ?cfg1.0 ?Q ?cfg2.0; ?p \\<notin> ?Q\\<rbrakk>\n  \\<Longrightarrow> states ?cfg1.0 ?p = states ?cfg2.0 ?p\n\ngoal (1 subgoal):\n 1. states cfg1 p = states cfg2 p", "by simp"], ["", "lemma NoActivityNoMessageLoss :\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  Q :: \"'p set\" and\n  m' :: \"('p, 'v) message\"\nassumes\n  \"qReachable cfg1 Q cfg2\" and\n  \"p \\<notin> Q\" and\n  \"isReceiverOf p m'\"\nshows\n  \"(msgs cfg1 m') \\<le> (msgs cfg2 m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cfg1 m' \\<le> msgs cfg2 m'", "using assms"], ["proof (prove)\nusing this:\n  qReachable cfg1 Q cfg2\n  p \\<notin> Q\n  isReceiverOf p m'\n\ngoal (1 subgoal):\n 1. msgs cfg1 m' \\<le> msgs cfg2 m'", "proof (induct rule: qReachable.induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>p \\<notin> Q; isReceiverOf p m'\\<rbrakk>\n        \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg2 m';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; p \\<notin> Q;\n        isReceiverOf p m'\\<rbrakk>\n       \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg3 m'", "case (StepQ cfg1' Q' cfg2' msg cfg3)"], ["proof (state)\nthis:\n  qReachable cfg1' Q' cfg2'\n  \\<lbrakk>p \\<notin> Q'; isReceiverOf p m'\\<rbrakk>\n  \\<Longrightarrow> msgs cfg1' m' \\<le> msgs cfg2' m'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Q'. isReceiverOf p msg\n  p \\<notin> Q'\n  isReceiverOf p m'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>p \\<notin> Q; isReceiverOf p m'\\<rbrakk>\n        \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg2 m';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; p \\<notin> Q;\n        isReceiverOf p m'\\<rbrakk>\n       \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg3 m'", "then"], ["proof (chain)\npicking this:\n  qReachable cfg1' Q' cfg2'\n  \\<lbrakk>p \\<notin> Q'; isReceiverOf p m'\\<rbrakk>\n  \\<Longrightarrow> msgs cfg1' m' \\<le> msgs cfg2' m'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Q'. isReceiverOf p msg\n  p \\<notin> Q'\n  isReceiverOf p m'", "obtain p' where\n    P': \"p' \\<in> Q'\" \"isReceiverOf p' msg\" \"p \\<noteq> p'\""], ["proof (prove)\nusing this:\n  qReachable cfg1' Q' cfg2'\n  \\<lbrakk>p \\<notin> Q'; isReceiverOf p m'\\<rbrakk>\n  \\<Longrightarrow> msgs cfg1' m' \\<le> msgs cfg2' m'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Q'. isReceiverOf p msg\n  p \\<notin> Q'\n  isReceiverOf p m'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> Q'; isReceiverOf p' msg; p \\<noteq> p'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p' \\<in> Q'\n  isReceiverOf p' msg\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>p \\<notin> Q; isReceiverOf p m'\\<rbrakk>\n        \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg2 m';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; p \\<notin> Q;\n        isReceiverOf p m'\\<rbrakk>\n       \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg3 m'", "with assms(3)"], ["proof (chain)\npicking this:\n  isReceiverOf p m'\n  p' \\<in> Q'\n  isReceiverOf p' msg\n  p \\<noteq> p'", "have \"\\<not>(isReceiverOf p' m')\""], ["proof (prove)\nusing this:\n  isReceiverOf p m'\n  p' \\<in> Q'\n  isReceiverOf p' msg\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. \\<not> isReceiverOf p' m'", "by (cases m', simp_all)"], ["proof (state)\nthis:\n  \\<not> isReceiverOf p' m'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>p \\<notin> Q; isReceiverOf p m'\\<rbrakk>\n        \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg2 m';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; p \\<notin> Q;\n        isReceiverOf p m'\\<rbrakk>\n       \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg3 m'", "with NoMessageLossStep StepQ(3) P'"], ["proof (chain)\npicking this:\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0; isReceiverOf ?p ?m;\n   \\<not> isReceiverOf ?p ?m'\\<rbrakk>\n  \\<Longrightarrow> msgs ?cfg1.0 ?m' \\<le> msgs ?cfg2.0 ?m'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3\n  p' \\<in> Q'\n  isReceiverOf p' msg\n  p \\<noteq> p'\n  \\<not> isReceiverOf p' m'", "have \"msgs cfg2' m' \\<le> msgs cfg3 m'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0; isReceiverOf ?p ?m;\n   \\<not> isReceiverOf ?p ?m'\\<rbrakk>\n  \\<Longrightarrow> msgs ?cfg1.0 ?m' \\<le> msgs ?cfg2.0 ?m'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3\n  p' \\<in> Q'\n  isReceiverOf p' msg\n  p \\<noteq> p'\n  \\<not> isReceiverOf p' m'\n\ngoal (1 subgoal):\n 1. msgs cfg2' m' \\<le> msgs cfg3 m'", "by simp"], ["proof (state)\nthis:\n  msgs cfg2' m' \\<le> msgs cfg3 m'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>p \\<notin> Q; isReceiverOf p m'\\<rbrakk>\n        \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg2 m';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; p \\<notin> Q;\n        isReceiverOf p m'\\<rbrakk>\n       \\<Longrightarrow> msgs cfg1 m' \\<le> msgs cfg3 m'", "with StepQ"], ["proof (chain)\npicking this:\n  qReachable cfg1' Q' cfg2'\n  \\<lbrakk>p \\<notin> Q'; isReceiverOf p m'\\<rbrakk>\n  \\<Longrightarrow> msgs cfg1' m' \\<le> msgs cfg2' m'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Q'. isReceiverOf p msg\n  p \\<notin> Q'\n  isReceiverOf p m'\n  msgs cfg2' m' \\<le> msgs cfg3 m'", "show \"msgs cfg1' m' \\<le> msgs cfg3 m'\""], ["proof (prove)\nusing this:\n  qReachable cfg1' Q' cfg2'\n  \\<lbrakk>p \\<notin> Q'; isReceiverOf p m'\\<rbrakk>\n  \\<Longrightarrow> msgs cfg1' m' \\<le> msgs cfg2' m'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Q'. isReceiverOf p msg\n  p \\<notin> Q'\n  isReceiverOf p m'\n  msgs cfg2' m' \\<le> msgs cfg3 m'\n\ngoal (1 subgoal):\n 1. msgs cfg1' m' \\<le> msgs cfg3 m'", "by simp"], ["proof (state)\nthis:\n  msgs cfg1' m' \\<le> msgs cfg3 m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma NoMessageLoss:\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  Q :: \"'p set\" and\n  m' :: \"('p, 'v) message\"\nassumes\n  \"withoutQReachable cfg1 Q cfg2\" and\n  \"p \\<in> Q\" and\n  \"isReceiverOf p m'\"\nshows\n  \"(msgs cfg1 m') \\<le> (msgs cfg2 m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cfg1 m' \\<le> msgs cfg2 m'", "using assms NoActivityNoMessageLoss"], ["proof (prove)\nusing this:\n  qReachable cfg1 (Proc - Q) cfg2\n  p \\<in> Q\n  isReceiverOf p m'\n  \\<lbrakk>qReachable ?cfg1.0 ?Q ?cfg2.0; ?p \\<notin> ?Q;\n   isReceiverOf ?p ?m'\\<rbrakk>\n  \\<Longrightarrow> msgs ?cfg1.0 ?m' \\<le> msgs ?cfg2.0 ?m'\n\ngoal (1 subgoal):\n 1. msgs cfg1 m' \\<le> msgs cfg2 m'", "by simp"], ["", "lemma NoOutMessageLoss:\nfixes\n  cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  v :: bool\nassumes\n  \"reachable cfg1 cfg2\"\nshows\n  \"(msgs cfg1 <\\<bottom>, outM v>) \\<le> (msgs cfg2 <\\<bottom>, outM v>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>", "using assms"], ["proof (prove)\nusing this:\n  reachable cfg1 cfg2\n\ngoal (1 subgoal):\n 1. msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>", "proof(induct rule: reachable.induct, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2a msg cfg3.\n       \\<lbrakk>reachable cfg1a cfg2a;\n        msgs cfg1a <\\<bottom>, outM v> \\<le> msgs cfg2a <\\<bottom>, outM v>;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; reachable cfg1 cfg2\\<rbrakk>\n       \\<Longrightarrow> msgs cfg1a <\\<bottom>, outM v>\n                         \\<le> msgs cfg3 <\\<bottom>, outM v>", "fix cfg1 cfg' msg cfg2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2a msg cfg3.\n       \\<lbrakk>reachable cfg1a cfg2a;\n        msgs cfg1a <\\<bottom>, outM v> \\<le> msgs cfg2a <\\<bottom>, outM v>;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; reachable cfg1 cfg2\\<rbrakk>\n       \\<Longrightarrow> msgs cfg1a <\\<bottom>, outM v>\n                         \\<le> msgs cfg3 <\\<bottom>, outM v>", "assume AssInduct:\n    \"reachable cfg1 cfg'\"\n    \"msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg' <\\<bottom>, outM v>\" \n    \"cfg' \\<turnstile> msg \\<mapsto> cfg2\""], ["proof (state)\nthis:\n  reachable cfg1 cfg'\n  msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg' <\\<bottom>, outM v>\n  cfg' \\<turnstile> msg \\<mapsto> cfg2\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2a msg cfg3.\n       \\<lbrakk>reachable cfg1a cfg2a;\n        msgs cfg1a <\\<bottom>, outM v> \\<le> msgs cfg2a <\\<bottom>, outM v>;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; reachable cfg1 cfg2\\<rbrakk>\n       \\<Longrightarrow> msgs cfg1a <\\<bottom>, outM v>\n                         \\<le> msgs cfg3 <\\<bottom>, outM v>", "from AssInduct(3)"], ["proof (chain)\npicking this:\n  cfg' \\<turnstile> msg \\<mapsto> cfg2", "have \"msgs cfg' <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>\""], ["proof (prove)\nusing this:\n  cfg' \\<turnstile> msg \\<mapsto> cfg2\n\ngoal (1 subgoal):\n 1. msgs cfg' <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>", "by (cases msg, auto)"], ["proof (state)\nthis:\n  msgs cfg' <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2a msg cfg3.\n       \\<lbrakk>reachable cfg1a cfg2a;\n        msgs cfg1a <\\<bottom>, outM v> \\<le> msgs cfg2a <\\<bottom>, outM v>;\n        cfg2a \\<turnstile> msg \\<mapsto> cfg3; reachable cfg1 cfg2\\<rbrakk>\n       \\<Longrightarrow> msgs cfg1a <\\<bottom>, outM v>\n                         \\<le> msgs cfg3 <\\<bottom>, outM v>", "with AssInduct(2)"], ["proof (chain)\npicking this:\n  msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg' <\\<bottom>, outM v>\n  msgs cfg' <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>", "show \" msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>\""], ["proof (prove)\nusing this:\n  msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg' <\\<bottom>, outM v>\n  msgs cfg' <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>\n\ngoal (1 subgoal):\n 1. msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>", "using le_trans"], ["proof (prove)\nusing this:\n  msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg' <\\<bottom>, outM v>\n  msgs cfg' <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n\ngoal (1 subgoal):\n 1. msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>", "by blast"], ["proof (state)\nthis:\n  msgs cfg1 <\\<bottom>, outM v> \\<le> msgs cfg2 <\\<bottom>, outM v>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma StillEnabled:\nfixes \n  cfg1 cfg2:: \"('p,'v,'s) configuration\" and\n  p :: 'p and\n  msg :: \"('p,'v) message\" and\n  Q :: \"'p set\"\nassumes \n  \"withoutQReachable cfg1 Q cfg2\" and\n  \"p \\<in> Q\" and\n  \"isReceiverOf p msg\" and\n  \"enabled cfg1 msg\"\nshows\n  \"enabled cfg2 msg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled cfg2 msg", "using assms enabled_def NoMessageLoss"], ["proof (prove)\nusing this:\n  qReachable cfg1 (Proc - Q) cfg2\n  p \\<in> Q\n  isReceiverOf p msg\n  enabled cfg1 msg\n  enabled ?cfg ?msg \\<equiv> ?msg \\<in># msgs ?cfg\n  \\<lbrakk>qReachable ?cfg1.0 (Proc - ?Q) ?cfg2.0; ?p \\<in> ?Q;\n   isReceiverOf ?p ?m'\\<rbrakk>\n  \\<Longrightarrow> msgs ?cfg1.0 ?m' \\<le> msgs ?cfg2.0 ?m'\n\ngoal (1 subgoal):\n 1. enabled cfg2 msg", "by (metis le_0_eq neq0_conv)"], ["", "subsection\\<open>Initial reachability\\<close>"], ["", "definition initial :: \n  \"('p, 'v, 's) configuration \\<Rightarrow> bool\"\nwhere\n  \"initial cfg \\<equiv>\n        (\\<forall> p::'p . (\\<exists> v::bool . ((msgs cfg (<p, inM v>)) = 1)))\n      \\<and> (\\<forall> p m1 m2 . ((m1 \\<in># (msgs cfg)) \\<and> (m2 \\<in># (msgs cfg)) \n         \\<and> isReceiverOf p m1 \\<and> isReceiverOf p m2) \\<longrightarrow> (m1 = m2))\n      \\<and> (\\<forall> v::bool . (msgs cfg) (<\\<bottom>, outM v>) = 0)\n      \\<and> (\\<forall> p v. (msgs cfg) (<p, v>) = 0)\n      \\<and> states cfg = start\""], ["", "definition initReachable ::\n  \"('p, 'v, 's) configuration \\<Rightarrow> bool\"\nwhere\n  \"initReachable cfg \\<equiv> \\<exists>cfg0 . initial cfg0 \\<and> reachable cfg0 cfg\""], ["", "lemma InitialIsInitReachable :\nassumes \"initial c\"\nshows \"initReachable c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initReachable c", "using assms reachable.init"], ["proof (prove)\nusing this:\n  initial c\n  reachable ?cfg1.0 ?cfg1.0\n\ngoal (1 subgoal):\n 1. initReachable c", "unfolding initReachable_def"], ["proof (prove)\nusing this:\n  initial c\n  reachable ?cfg1.0 ?cfg1.0\n\ngoal (1 subgoal):\n 1. \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 c", "by blast"], ["", "subsection \\<open>Diamond property of reachability\\<close>"], ["", "lemma DiamondOne:\nfixes\n  cfg cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  p q :: 'p and\n  m m' :: \"('p,'v) message\"\nassumes\n  StepP: \"cfg \\<turnstile> m  \\<mapsto> cfg1\" and\n  PNotQ: \"p \\<noteq> q\" and\n  Rec: \"isReceiverOf p m\" \"\\<not> (isReceiverOf p m')\" and\n  Rec': \"isReceiverOf q m'\" \"\\<not> (isReceiverOf q m)\" and\n  StepWithoutP: \"cfg \\<turnstile> m' \\<mapsto> cfg2\"\nshows\n  \"\\<exists> cfg' :: ('p,'v,'s) configuration . (cfg1 \\<turnstile> m' \\<mapsto> cfg')\n        \\<and> (cfg2 \\<turnstile> m \\<mapsto> cfg')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "proof (cases m)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "case (InMsg p b)"], ["proof (state)\nthis:\n  m = <p, inM b>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "from StepWithoutP ExistsMsg"], ["proof (chain)\npicking this:\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  ?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0 \\<Longrightarrow>\n  ?m \\<in># msgs ?cfg1.0", "have \" m' \\<in># (msgs cfg) \""], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  ?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0 \\<Longrightarrow>\n  ?m \\<in># msgs ?cfg1.0\n\ngoal (1 subgoal):\n 1. m' \\<in># msgs cfg", "by simp"], ["proof (state)\nthis:\n  m' \\<in># msgs cfg\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence \"m' \\<in># (msgs cfg1)\""], ["proof (prove)\nusing this:\n  m' \\<in># msgs cfg\n\ngoal (1 subgoal):\n 1. m' \\<in># msgs cfg1", "using StepP Rec NoMessageLossStep le_neq_implies_less le_antisym"], ["proof (prove)\nusing this:\n  m' \\<in># msgs cfg\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  isReceiverOf p m\n  \\<not> isReceiverOf p m'\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0; isReceiverOf ?p ?m;\n   \\<not> isReceiverOf ?p ?m'\\<rbrakk>\n  \\<Longrightarrow> msgs ?cfg1.0 ?m' \\<le> msgs ?cfg2.0 ?m'\n  \\<lbrakk>?m \\<le> ?n; ?m \\<noteq> ?n\\<rbrakk> \\<Longrightarrow> ?m < ?n\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. m' \\<in># msgs cfg1", "by (metis  gr_implies_not0 neq0_conv)"], ["proof (state)\nthis:\n  m' \\<in># msgs cfg1\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence EnM': \"enabled cfg1 m'\""], ["proof (prove)\nusing this:\n  m' \\<in># msgs cfg1\n\ngoal (1 subgoal):\n 1. enabled cfg1 m'", "using enabled_def"], ["proof (prove)\nusing this:\n  m' \\<in># msgs cfg1\n  enabled ?cfg ?msg \\<equiv> ?msg \\<in># msgs ?cfg\n\ngoal (1 subgoal):\n 1. enabled cfg1 m'", "by auto"], ["proof (state)\nthis:\n  enabled cfg1 m'\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "from StepP ExistsMsg"], ["proof (chain)\npicking this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  ?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0 \\<Longrightarrow>\n  ?m \\<in># msgs ?cfg1.0", "have \"m \\<in># (msgs cfg) \""], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  ?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0 \\<Longrightarrow>\n  ?m \\<in># msgs ?cfg1.0\n\ngoal (1 subgoal):\n 1. m \\<in># msgs cfg", "by simp"], ["proof (state)\nthis:\n  m \\<in># msgs cfg\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence \"m \\<in># (msgs cfg2)\""], ["proof (prove)\nusing this:\n  m \\<in># msgs cfg\n\ngoal (1 subgoal):\n 1. m \\<in># msgs cfg2", "using StepWithoutP Rec' NoMessageLossStep"], ["proof (prove)\nusing this:\n  m \\<in># msgs cfg\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0; isReceiverOf ?p ?m;\n   \\<not> isReceiverOf ?p ?m'\\<rbrakk>\n  \\<Longrightarrow> msgs ?cfg1.0 ?m' \\<le> msgs ?cfg2.0 ?m'\n\ngoal (1 subgoal):\n 1. m \\<in># msgs cfg2", "by (metis le_0_eq neq0_conv)"], ["proof (state)\nthis:\n  m \\<in># msgs cfg2\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence EnM: \"enabled cfg2 m\""], ["proof (prove)\nusing this:\n  m \\<in># msgs cfg2\n\ngoal (1 subgoal):\n 1. enabled cfg2 m", "using enabled_def"], ["proof (prove)\nusing this:\n  m \\<in># msgs cfg2\n  enabled ?cfg ?msg \\<equiv> ?msg \\<in># msgs ?cfg\n\ngoal (1 subgoal):\n 1. enabled cfg2 m", "by auto"], ["proof (state)\nthis:\n  enabled cfg2 m\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "assume CaseM:  \"m = <p, inM b>\""], ["proof (state)\nthis:\n  m = <p, inM b>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       m = <x11, inM x12> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "thus ?thesis"], ["proof (prove)\nusing this:\n  m = <p, inM b>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "proof (cases m')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, inM b>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       \\<lbrakk>m = <p, inM b>; m' = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "case (OutMsg b')"], ["proof (state)\nthis:\n  m' = <\\<bottom>, outM b'>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, inM b>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       \\<lbrakk>m = <p, inM b>; m' = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "thus ?thesis"], ["proof (prove)\nusing this:\n  m' = <\\<bottom>, outM b'>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "using StepWithoutP"], ["proof (prove)\nusing this:\n  m' = <\\<bottom>, outM b'>\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "by simp"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n     cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, inM b>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, inM b>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "case (InMsg q b')"], ["proof (state)\nthis:\n  m' = <q, inM b'>\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, inM b>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "define cfg' where \"cfg' = \\<lparr>states = \\<lambda>s. (\n      if s = q then\n        trans q (states cfg q) (Bool b')\n      else if s = p then\n        trans p (states cfg p) (Bool b)\n      else\n        states cfg s),\n      msgs = ((sends q (states cfg q) (Bool b')) \n        \\<union># (((sends p (states cfg p) (Bool b))\n            \\<union># ((msgs cfg)-# m)) -# m'))\\<rparr> \""], ["proof (state)\nthis:\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Bool b')\n               else if s = p then trans p (states cfg p) (Bool b)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Bool\n          b') \\<union># sends p (states cfg p)\n                         (Bool b) \\<union># msgs cfg -# m -# m'\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, inM b>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "have StepP': \"(cfg1 \\<turnstile> m' \\<mapsto> cfg')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> m' \\<mapsto> cfg'", "using StepP  EnM' Rec"], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  enabled cfg1 m'\n  isReceiverOf p m\n  \\<not> isReceiverOf p m'\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> m' \\<mapsto> cfg'", "unfolding cfg'_def InMsg CaseM"], ["proof (prove)\nusing this:\n  cfg \\<turnstile> <p, inM b> \\<mapsto> cfg1\n  enabled cfg1 <q, inM b'>\n  isReceiverOf p <p, inM b>\n  \\<not> isReceiverOf p <q, inM b'>\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> <q, inM b'> \\<mapsto> \\<lparr>states =\n                \\<lambda>s.\n                   if s = q then trans q (states cfg q) (Bool b')\n                   else if s = p then trans p (states cfg p) (Bool b)\n                        else states cfg s,\n         msgs =\n           sends q (states cfg q)\n            (Bool\n              b') \\<union># sends p (states cfg p)\n                             (Bool\n                               b) \\<union># msgs\n       cfg -# <p, inM b> -# <q, inM b'>\\<rparr>", "by auto"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, inM b>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "moreover"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, inM b>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "from EnM"], ["proof (chain)\npicking this:\n  enabled cfg2 m", "have \"(cfg2 \\<turnstile> m \\<mapsto> cfg')\""], ["proof (prove)\nusing this:\n  enabled cfg2 m\n\ngoal (1 subgoal):\n 1. cfg2 \\<turnstile> m \\<mapsto> cfg'", "using InMsg cfg'_def StepP StepP' StepWithoutP NoReceivingNoChange  \n            Rec' CaseM EnM'"], ["proof (prove)\nusing this:\n  enabled cfg2 m\n  m' = <q, inM b'>\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Bool b')\n               else if s = p then trans p (states cfg p) (Bool b)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Bool\n          b') \\<union># sends p (states cfg p)\n                         (Bool b) \\<union># msgs cfg -# m -# m'\\<rparr>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0;\n   \\<not> isReceiverOf ?p ?m\\<rbrakk>\n  \\<Longrightarrow> states ?cfg1.0 ?p = states ?cfg2.0 ?p\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  m = <p, inM b>\n  enabled cfg1 m'\n\ngoal (1 subgoal):\n 1. cfg2 \\<turnstile> m \\<mapsto> cfg'", "proof (simp, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, inM b>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Bool b')\n                  else if s = p then trans p (states cfg p) (Bool b)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, inM b>;\n     cfg \\<turnstile> <p, inM b> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, inM b'> \\<mapsto> \\<lparr>states =\n                 \\<lambda>s.\n                    if s = q then trans q (states cfg q) (Bool b')\n                    else if s = p then trans p (states cfg p) (Bool b)\n                         else states cfg s,\n          msgs =\n            sends q (states cfg q)\n             (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     cfg \\<turnstile> <q, inM b'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, inM b'>; \\<not> isReceiverOf q <p, inM b>;\n     enabled cfg1 <q, inM b'>; m' = <q, inM b'>; m = <p, inM b>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Bool b)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Bool b) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Bool b')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, inM b>;\n     msgs cfg1 =\n     sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>;\n     enabled cfg1 <q, inM b'>;\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs\n cfg -# <p, inM b> -# <q, inM b'> =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'>;\n     enabled cfg <q, inM b'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>;\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs\n cfg -# <p, inM b> -# <q, inM b'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n                      sends p (states cfg p)\n                       (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "assume msgCfg:\n        \"msgs cfg1 = (sends p (states cfg p) (Bool b)  \n                     \\<union># (msgs cfg -# <p, inM b>))\"\n        \"msgs cfg2 = (sends q (states cfg q) (Bool b') \n                     \\<union># (msgs cfg -# <q, inM b'>))\""], ["proof (state)\nthis:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, inM b>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Bool b')\n                  else if s = p then trans p (states cfg p) (Bool b)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, inM b>;\n     cfg \\<turnstile> <p, inM b> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, inM b'> \\<mapsto> \\<lparr>states =\n                 \\<lambda>s.\n                    if s = q then trans q (states cfg q) (Bool b')\n                    else if s = p then trans p (states cfg p) (Bool b)\n                         else states cfg s,\n          msgs =\n            sends q (states cfg q)\n             (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     cfg \\<turnstile> <q, inM b'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, inM b'>; \\<not> isReceiverOf q <p, inM b>;\n     enabled cfg1 <q, inM b'>; m' = <q, inM b'>; m = <p, inM b>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Bool b)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Bool b) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Bool b')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, inM b>;\n     msgs cfg1 =\n     sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>;\n     enabled cfg1 <q, inM b'>;\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs\n cfg -# <p, inM b> -# <q, inM b'> =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'>;\n     enabled cfg <q, inM b'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>;\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs\n cfg -# <p, inM b> -# <q, inM b'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n                      sends p (states cfg p)\n                       (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "have \"enabled cfg m\" \"enabled cfg m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled cfg m &&& enabled cfg m'", "using StepP StepWithoutP CaseM InMsg"], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  m = <p, inM b>\n  m' = <q, inM b'>\n\ngoal (1 subgoal):\n 1. enabled cfg m &&& enabled cfg m'", "by auto"], ["proof (state)\nthis:\n  enabled cfg m\n  enabled cfg m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, inM b>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Bool b')\n                  else if s = p then trans p (states cfg p) (Bool b)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, inM b>;\n     cfg \\<turnstile> <p, inM b> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, inM b'> \\<mapsto> \\<lparr>states =\n                 \\<lambda>s.\n                    if s = q then trans q (states cfg q) (Bool b')\n                    else if s = p then trans p (states cfg p) (Bool b)\n                         else states cfg s,\n          msgs =\n            sends q (states cfg q)\n             (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     cfg \\<turnstile> <q, inM b'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, inM b'>; \\<not> isReceiverOf q <p, inM b>;\n     enabled cfg1 <q, inM b'>; m' = <q, inM b'>; m = <p, inM b>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Bool b)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Bool b) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Bool b')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, inM b>;\n     msgs cfg1 =\n     sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>;\n     enabled cfg1 <q, inM b'>;\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs\n cfg -# <p, inM b> -# <q, inM b'> =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'>;\n     enabled cfg <q, inM b'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>;\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs\n cfg -# <p, inM b> -# <q, inM b'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n                      sends p (states cfg p)\n                       (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "with msgCfg"], ["proof (chain)\npicking this:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n  enabled cfg m\n  enabled cfg m'", "show \n        \"(sends q (states cfg q) (Bool b') \\<union># (msgs cfg1 -# <q, inM b'>)) =\n         (sends p (states cfg p) (Bool b) \\<union># (msgs cfg2 -# <p, inM b>))\""], ["proof (prove)\nusing this:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n  enabled cfg m\n  enabled cfg m'\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n    sends p (states cfg p) (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "using CaseM InMsg StepP StepWithoutP Rec' AXc[of \"m'\" \"m\" \"msgs cfg\"\n          \"sends q (states cfg q) (Bool b')\" \n          \"sends p (states cfg p) (Bool b)\"]"], ["proof (prove)\nusing this:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n  enabled cfg m\n  enabled cfg m'\n  m = <p, inM b>\n  m' = <q, inM b'>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  \\<lbrakk>m' \\<noteq> m; m' \\<in># msgs cfg; m \\<in># msgs cfg\\<rbrakk>\n  \\<Longrightarrow> sends q (states cfg q)\n                     (Bool\n                       b') \\<union># sends p (states cfg p)\n(Bool b) \\<union># msgs cfg -# m -# m' =\n                    sends p (states cfg p)\n                     (Bool\n                       b) \\<union># sends q (states cfg q)\n                                     (Bool b') \\<union># msgs cfg -# m' -# m\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n    sends p (states cfg p) (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "unfolding enabled_def"], ["proof (prove)\nusing this:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n  m \\<in># msgs cfg\n  m' \\<in># msgs cfg\n  m = <p, inM b>\n  m' = <q, inM b'>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  \\<lbrakk>m' \\<noteq> m; m' \\<in># msgs cfg; m \\<in># msgs cfg\\<rbrakk>\n  \\<Longrightarrow> sends q (states cfg q)\n                     (Bool\n                       b') \\<union># sends p (states cfg p)\n(Bool b) \\<union># msgs cfg -# m -# m' =\n                    sends p (states cfg p)\n                     (Bool\n                       b) \\<union># sends q (states cfg q)\n                                     (Bool b') \\<union># msgs cfg -# m' -# m\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n    sends p (states cfg p) (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "by metis"], ["proof (state)\nthis:\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg2 -# <p, inM b>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, inM b>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "ultimately"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg2 \\<turnstile> m \\<mapsto> cfg'", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n     cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "case (Msg q v')"], ["proof (state)\nthis:\n  m' = <q, v'>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "define cfg' where \"cfg' = \\<lparr>states = \\<lambda>s. (\n      if s = q then\n        trans q (states cfg q) (Value v')\n      else if s = p then\n        trans p (states cfg p) (Bool b)\n      else\n        states cfg s),\n      msgs = ((sends q (states cfg q) (Value v')) \n        \\<union># (((sends p (states cfg p) (Bool b))\n            \\<union># ((msgs cfg)-# m))\n            -# m'))\\<rparr>\""], ["proof (state)\nthis:\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Value v')\n               else if s = p then trans p (states cfg p) (Bool b)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Value\n          v') \\<union># sends p (states cfg p)\n                         (Bool b) \\<union># msgs cfg -# m -# m'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "have StepP': \"(cfg1 \\<turnstile> m' \\<mapsto> cfg')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> m' \\<mapsto> cfg'", "using StepP EnM' Rec"], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  enabled cfg1 m'\n  isReceiverOf p m\n  \\<not> isReceiverOf p m'\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> m' \\<mapsto> cfg'", "unfolding Msg CaseM cfg'_def"], ["proof (prove)\nusing this:\n  cfg \\<turnstile> <p, inM b> \\<mapsto> cfg1\n  enabled cfg1 <q, v'>\n  isReceiverOf p <p, inM b>\n  \\<not> isReceiverOf p <q, v'>\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> <q, v'> \\<mapsto> \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Value v')\n               else if s = p then trans p (states cfg p) (Bool b)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Value\n          v') \\<union># sends p (states cfg p)\n                         (Bool\n                           b) \\<union># msgs\n   cfg -# <p, inM b> -# <q, v'>\\<rparr>", "by auto"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "moreover"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "from EnM"], ["proof (chain)\npicking this:\n  enabled cfg2 m", "have \"(cfg2 \\<turnstile> m \\<mapsto> cfg')\""], ["proof (prove)\nusing this:\n  enabled cfg2 m\n\ngoal (1 subgoal):\n 1. cfg2 \\<turnstile> m \\<mapsto> cfg'", "using Msg cfg'_def StepP StepP' StepWithoutP NoReceivingNoChange Rec' CaseM EnM'"], ["proof (prove)\nusing this:\n  enabled cfg2 m\n  m' = <q, v'>\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Value v')\n               else if s = p then trans p (states cfg p) (Bool b)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Value\n          v') \\<union># sends p (states cfg p)\n                         (Bool b) \\<union># msgs cfg -# m -# m'\\<rparr>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0;\n   \\<not> isReceiverOf ?p ?m\\<rbrakk>\n  \\<Longrightarrow> states ?cfg1.0 ?p = states ?cfg2.0 ?p\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  m = <p, inM b>\n  enabled cfg1 m'\n\ngoal (1 subgoal):\n 1. cfg2 \\<turnstile> m \\<mapsto> cfg'", "proof (simp,clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, inM b>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Value v')\n                  else if s = p then trans p (states cfg p) (Bool b)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, inM b>;\n     cfg \\<turnstile> <p, inM b> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, v'> \\<mapsto> \\<lparr>states =\n             \\<lambda>s.\n                if s = q then trans q (states cfg q) (Value v')\n                else if s = p then trans p (states cfg p) (Bool b)\n                     else states cfg s,\n      msgs =\n        sends q (states cfg q)\n         (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     cfg \\<turnstile> <q, v'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, v'>; \\<not> isReceiverOf q <p, inM b>;\n     enabled cfg1 <q, v'>; m' = <q, v'>; m = <p, inM b>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Bool b)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Bool b) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Value v')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, inM b>;\n     msgs cfg1 =\n     sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>;\n     enabled cfg1 <q, v'>;\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs cfg -# <p, inM b> -# <q, v'> =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'>;\n     enabled cfg <q, v'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>;\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs\n cfg -# <p, inM b> -# <q, v'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Value v') \\<union># msgs cfg1 -# <q, v'> =\n                      sends p (states cfg p)\n                       (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "assume msgCfg1:\n        \"msgs cfg1 = (sends p (states cfg p) (Bool b)   \n                      \\<union># (msgs cfg -# <p, inM b>))\"\n        \"msgs cfg2 = (sends q (states cfg q) (Value v') \n                      \\<union># (msgs cfg -# <q,  v'>))\""], ["proof (state)\nthis:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, inM b>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Value v')\n                  else if s = p then trans p (states cfg p) (Bool b)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, inM b>;\n     cfg \\<turnstile> <p, inM b> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, v'> \\<mapsto> \\<lparr>states =\n             \\<lambda>s.\n                if s = q then trans q (states cfg q) (Value v')\n                else if s = p then trans p (states cfg p) (Bool b)\n                     else states cfg s,\n      msgs =\n        sends q (states cfg q)\n         (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     cfg \\<turnstile> <q, v'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, v'>; \\<not> isReceiverOf q <p, inM b>;\n     enabled cfg1 <q, v'>; m' = <q, v'>; m = <p, inM b>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Bool b)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Bool b) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Value v')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, inM b>;\n     msgs cfg1 =\n     sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>;\n     enabled cfg1 <q, v'>;\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs cfg -# <p, inM b> -# <q, v'> =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'>;\n     enabled cfg <q, v'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>;\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs\n cfg -# <p, inM b> -# <q, v'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Value v') \\<union># msgs cfg1 -# <q, v'> =\n                      sends p (states cfg p)\n                       (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "have \"enabled cfg m\" \"enabled cfg m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled cfg m &&& enabled cfg m'", "using StepP StepWithoutP CaseM Msg"], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  m = <p, inM b>\n  m' = <q, v'>\n\ngoal (1 subgoal):\n 1. enabled cfg m &&& enabled cfg m'", "by auto"], ["proof (state)\nthis:\n  enabled cfg m\n  enabled cfg m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, inM b>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Value v')\n                  else if s = p then trans p (states cfg p) (Bool b)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, inM b>;\n     cfg \\<turnstile> <p, inM b> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, v'> \\<mapsto> \\<lparr>states =\n             \\<lambda>s.\n                if s = q then trans q (states cfg q) (Value v')\n                else if s = p then trans p (states cfg p) (Bool b)\n                     else states cfg s,\n      msgs =\n        sends q (states cfg q)\n         (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     cfg \\<turnstile> <q, v'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, v'>; \\<not> isReceiverOf q <p, inM b>;\n     enabled cfg1 <q, v'>; m' = <q, v'>; m = <p, inM b>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Bool b)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Bool b) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Value v')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, inM b>;\n     msgs cfg1 =\n     sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>;\n     enabled cfg1 <q, v'>;\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs cfg -# <p, inM b> -# <q, v'> =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'>;\n     enabled cfg <q, v'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>;\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Bool\n                         b) \\<union># msgs\n cfg -# <p, inM b> -# <q, v'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Value v') \\<union># msgs cfg1 -# <q, v'> =\n                      sends p (states cfg p)\n                       (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "with msgCfg1"], ["proof (chain)\npicking this:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n  enabled cfg m\n  enabled cfg m'", "show \n        \"(sends q (states cfg q) (Value v') \\<union># (msgs cfg1 -# <q, v'>)) =\n         (sends p (states cfg p) (Bool b) \\<union># (msgs cfg2 -# <p, inM b>))\""], ["proof (prove)\nusing this:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n  enabled cfg m\n  enabled cfg m'\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n    sends p (states cfg p) (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "using CaseM Msg StepP StepWithoutP Rec' AXc[of \"m'\" \"m\" \"msgs cfg\"\n          \"sends q (states cfg q) (Value v')\" \n          \"sends p (states cfg p) (Bool b)\"]"], ["proof (prove)\nusing this:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n  enabled cfg m\n  enabled cfg m'\n  m = <p, inM b>\n  m' = <q, v'>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  \\<lbrakk>m' \\<noteq> m; m' \\<in># msgs cfg; m \\<in># msgs cfg\\<rbrakk>\n  \\<Longrightarrow> sends q (states cfg q)\n                     (Value\n                       v') \\<union># sends p (states cfg p)\n(Bool b) \\<union># msgs cfg -# m -# m' =\n                    sends p (states cfg p)\n                     (Bool\n                       b) \\<union># sends q (states cfg q)\n                                     (Value\n v') \\<union># msgs cfg -# m' -# m\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n    sends p (states cfg p) (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "unfolding enabled_def"], ["proof (prove)\nusing this:\n  msgs cfg1 =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg -# <p, inM b>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n  m \\<in># msgs cfg\n  m' \\<in># msgs cfg\n  m = <p, inM b>\n  m' = <q, v'>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  \\<lbrakk>m' \\<noteq> m; m' \\<in># msgs cfg; m \\<in># msgs cfg\\<rbrakk>\n  \\<Longrightarrow> sends q (states cfg q)\n                     (Value\n                       v') \\<union># sends p (states cfg p)\n(Bool b) \\<union># msgs cfg -# m -# m' =\n                    sends p (states cfg p)\n                     (Bool\n                       b) \\<union># sends q (states cfg q)\n                                     (Value\n v') \\<union># msgs cfg -# m' -# m\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n    sends p (states cfg p) (Bool b) \\<union># msgs cfg2 -# <p, inM b>", "by metis"], ["proof (state)\nthis:\n  sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n  sends p (states cfg p) (Bool b) \\<union># msgs cfg2 -# <p, inM b>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, inM b>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "ultimately"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg2 \\<turnstile> m \\<mapsto> cfg'", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n     cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n     cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "case (OutMsg b)"], ["proof (state)\nthis:\n  m = <\\<bottom>, outM b>\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       m = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "thus ?thesis"], ["proof (prove)\nusing this:\n  m = <\\<bottom>, outM b>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "using StepP"], ["proof (prove)\nusing this:\n  m = <\\<bottom>, outM b>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "by simp"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n     cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "case (Msg p v)"], ["proof (state)\nthis:\n  m = <p, v>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "from StepWithoutP ExistsMsg"], ["proof (chain)\npicking this:\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  ?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0 \\<Longrightarrow>\n  ?m \\<in># msgs ?cfg1.0", "have \" m' \\<in># (msgs cfg) \""], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  ?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0 \\<Longrightarrow>\n  ?m \\<in># msgs ?cfg1.0\n\ngoal (1 subgoal):\n 1. m' \\<in># msgs cfg", "by simp"], ["proof (state)\nthis:\n  m' \\<in># msgs cfg\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence \"m' \\<in># (msgs cfg1)\""], ["proof (prove)\nusing this:\n  m' \\<in># msgs cfg\n\ngoal (1 subgoal):\n 1. m' \\<in># msgs cfg1", "using StepP Rec NoMessageLossStep le_neq_implies_less le_antisym"], ["proof (prove)\nusing this:\n  m' \\<in># msgs cfg\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  isReceiverOf p m\n  \\<not> isReceiverOf p m'\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0; isReceiverOf ?p ?m;\n   \\<not> isReceiverOf ?p ?m'\\<rbrakk>\n  \\<Longrightarrow> msgs ?cfg1.0 ?m' \\<le> msgs ?cfg2.0 ?m'\n  \\<lbrakk>?m \\<le> ?n; ?m \\<noteq> ?n\\<rbrakk> \\<Longrightarrow> ?m < ?n\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. m' \\<in># msgs cfg1", "by (metis  gr_implies_not0 neq0_conv)"], ["proof (state)\nthis:\n  m' \\<in># msgs cfg1\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence EnM': \"enabled cfg1 m'\""], ["proof (prove)\nusing this:\n  m' \\<in># msgs cfg1\n\ngoal (1 subgoal):\n 1. enabled cfg1 m'", "using enabled_def"], ["proof (prove)\nusing this:\n  m' \\<in># msgs cfg1\n  enabled ?cfg ?msg \\<equiv> ?msg \\<in># msgs ?cfg\n\ngoal (1 subgoal):\n 1. enabled cfg1 m'", "by auto"], ["proof (state)\nthis:\n  enabled cfg1 m'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "from StepP ExistsMsg"], ["proof (chain)\npicking this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  ?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0 \\<Longrightarrow>\n  ?m \\<in># msgs ?cfg1.0", "have \"m \\<in># (msgs cfg) \""], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  ?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0 \\<Longrightarrow>\n  ?m \\<in># msgs ?cfg1.0\n\ngoal (1 subgoal):\n 1. m \\<in># msgs cfg", "by simp"], ["proof (state)\nthis:\n  m \\<in># msgs cfg\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence \"m \\<in># (msgs cfg2)\""], ["proof (prove)\nusing this:\n  m \\<in># msgs cfg\n\ngoal (1 subgoal):\n 1. m \\<in># msgs cfg2", "using StepWithoutP Rec' NoMessageLossStep"], ["proof (prove)\nusing this:\n  m \\<in># msgs cfg\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0; isReceiverOf ?p ?m;\n   \\<not> isReceiverOf ?p ?m'\\<rbrakk>\n  \\<Longrightarrow> msgs ?cfg1.0 ?m' \\<le> msgs ?cfg2.0 ?m'\n\ngoal (1 subgoal):\n 1. m \\<in># msgs cfg2", "by (metis le_0_eq neq0_conv)"], ["proof (state)\nthis:\n  m \\<in># msgs cfg2\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence EnM: \"enabled cfg2 m\""], ["proof (prove)\nusing this:\n  m \\<in># msgs cfg2\n\ngoal (1 subgoal):\n 1. enabled cfg2 m", "using enabled_def"], ["proof (prove)\nusing this:\n  m \\<in># msgs cfg2\n  enabled ?cfg ?msg \\<equiv> ?msg \\<in># msgs ?cfg\n\ngoal (1 subgoal):\n 1. enabled cfg2 m", "by auto"], ["proof (state)\nthis:\n  enabled cfg2 m\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "assume CaseM:  \"m = <p, v>\""], ["proof (state)\nthis:\n  m = <p, v>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       m = <x31, x32> \\<Longrightarrow>\n       \\<exists>cfg'.\n          cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n          cfg2 \\<turnstile> m \\<mapsto> cfg'", "thus ?thesis"], ["proof (prove)\nusing this:\n  m = <p, v>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "proof (cases m')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, v>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       \\<lbrakk>m = <p, v>; m' = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "case (OutMsg b')"], ["proof (state)\nthis:\n  m' = <\\<bottom>, outM b'>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, v>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x2.\n       \\<lbrakk>m = <p, v>; m' = <\\<bottom>, outM x2>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 3. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "thus ?thesis"], ["proof (prove)\nusing this:\n  m' = <\\<bottom>, outM b'>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "using StepWithoutP"], ["proof (prove)\nusing this:\n  m' = <\\<bottom>, outM b'>\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "by simp"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n     cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, v>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, v>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "case (InMsg q b')"], ["proof (state)\nthis:\n  m' = <q, inM b'>\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, v>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "define cfg' where \"cfg' = \\<lparr>states = \\<lambda>s. (\n      if s = q then\n        trans q (states cfg q) (Bool b')\n      else if s = p then\n        trans p (states cfg p) (Value v)\n      else\n        states cfg s),\n      msgs = ((sends q (states cfg q) (Bool b')) \n        \\<union># (((sends p (states cfg p) (Value v))\n        \\<union># ((msgs cfg)-# m))\n        -# m'))\\<rparr> \""], ["proof (state)\nthis:\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Bool b')\n               else if s = p then trans p (states cfg p) (Value v)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Bool\n          b') \\<union># sends p (states cfg p)\n                         (Value v) \\<union># msgs cfg -# m -# m'\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, v>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence StepP': \"(cfg1 \\<turnstile> m' \\<mapsto> cfg')\""], ["proof (prove)\nusing this:\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Bool b')\n               else if s = p then trans p (states cfg p) (Value v)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Bool\n          b') \\<union># sends p (states cfg p)\n                         (Value v) \\<union># msgs cfg -# m -# m'\\<rparr>\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> m' \\<mapsto> cfg'", "using StepP InMsg EnM' Rec CaseM"], ["proof (prove)\nusing this:\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Bool b')\n               else if s = p then trans p (states cfg p) (Value v)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Bool\n          b') \\<union># sends p (states cfg p)\n                         (Value v) \\<union># msgs cfg -# m -# m'\\<rparr>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  m' = <q, inM b'>\n  enabled cfg1 m'\n  isReceiverOf p m\n  \\<not> isReceiverOf p m'\n  m = <p, v>\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> m' \\<mapsto> cfg'", "by auto"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, v>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "moreover"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, v>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "from EnM"], ["proof (chain)\npicking this:\n  enabled cfg2 m", "have \"(cfg2 \\<turnstile> m \\<mapsto> cfg')\""], ["proof (prove)\nusing this:\n  enabled cfg2 m\n\ngoal (1 subgoal):\n 1. cfg2 \\<turnstile> m \\<mapsto> cfg'", "using InMsg cfg'_def StepP StepP' StepWithoutP NoReceivingNoChange Rec' \n            CaseM EnM'"], ["proof (prove)\nusing this:\n  enabled cfg2 m\n  m' = <q, inM b'>\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Bool b')\n               else if s = p then trans p (states cfg p) (Value v)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Bool\n          b') \\<union># sends p (states cfg p)\n                         (Value v) \\<union># msgs cfg -# m -# m'\\<rparr>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0;\n   \\<not> isReceiverOf ?p ?m\\<rbrakk>\n  \\<Longrightarrow> states ?cfg1.0 ?p = states ?cfg2.0 ?p\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  m = <p, v>\n  enabled cfg1 m'\n\ngoal (1 subgoal):\n 1. cfg2 \\<turnstile> m \\<mapsto> cfg'", "proof (simp, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, v>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Bool b')\n                  else if s = p then trans p (states cfg p) (Value v)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, v>;\n     cfg \\<turnstile> <p, v> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, inM b'> \\<mapsto> \\<lparr>states =\n                 \\<lambda>s.\n                    if s = q then trans q (states cfg q) (Bool b')\n                    else if s = p then trans p (states cfg p) (Value v)\n                         else states cfg s,\n          msgs =\n            sends q (states cfg q)\n             (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     cfg \\<turnstile> <q, inM b'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, inM b'>; \\<not> isReceiverOf q <p, v>;\n     enabled cfg1 <q, inM b'>; m' = <q, inM b'>; m = <p, v>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Value v)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Value v) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Bool b')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, v>;\n     msgs cfg1 =\n     sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>;\n     enabled cfg1 <q, inM b'>;\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Value\n                         v) \\<union># msgs cfg -# <p, v> -# <q, inM b'> =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'>;\n     enabled cfg <q, inM b'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>;\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Value\n                         v) \\<union># msgs\n cfg -# <p, v> -# <q, inM b'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n                      sends p (states cfg p)\n                       (Value v) \\<union># msgs cfg2 -# <p, v>", "assume msgCfg:\n        \"msgs cfg1 = (sends p (states cfg p) (Value v)\n          \\<union># (msgs cfg -# <p, v>))\"\n        \"msgs cfg2 = (sends q (states cfg q) (Bool b')\n          \\<union># (msgs cfg -# <q, inM b'>))\""], ["proof (state)\nthis:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, v>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Bool b')\n                  else if s = p then trans p (states cfg p) (Value v)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, v>;\n     cfg \\<turnstile> <p, v> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, inM b'> \\<mapsto> \\<lparr>states =\n                 \\<lambda>s.\n                    if s = q then trans q (states cfg q) (Bool b')\n                    else if s = p then trans p (states cfg p) (Value v)\n                         else states cfg s,\n          msgs =\n            sends q (states cfg q)\n             (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     cfg \\<turnstile> <q, inM b'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, inM b'>; \\<not> isReceiverOf q <p, v>;\n     enabled cfg1 <q, inM b'>; m' = <q, inM b'>; m = <p, v>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Value v)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Value v) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Bool b')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, v>;\n     msgs cfg1 =\n     sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>;\n     enabled cfg1 <q, inM b'>;\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Value\n                         v) \\<union># msgs cfg -# <p, v> -# <q, inM b'> =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'>;\n     enabled cfg <q, inM b'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>;\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Value\n                         v) \\<union># msgs\n cfg -# <p, v> -# <q, inM b'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n                      sends p (states cfg p)\n                       (Value v) \\<union># msgs cfg2 -# <p, v>", "have \"enabled cfg m\" \"enabled cfg m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled cfg m &&& enabled cfg m'", "using StepP StepWithoutP CaseM InMsg"], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  m = <p, v>\n  m' = <q, inM b'>\n\ngoal (1 subgoal):\n 1. enabled cfg m &&& enabled cfg m'", "by auto"], ["proof (state)\nthis:\n  enabled cfg m\n  enabled cfg m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, v>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Bool b')\n                  else if s = p then trans p (states cfg p) (Value v)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, v>;\n     cfg \\<turnstile> <p, v> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, inM b'> \\<mapsto> \\<lparr>states =\n                 \\<lambda>s.\n                    if s = q then trans q (states cfg q) (Bool b')\n                    else if s = p then trans p (states cfg p) (Value v)\n                         else states cfg s,\n          msgs =\n            sends q (states cfg q)\n             (Bool b') \\<union># msgs cfg1 -# <q, inM b'>\\<rparr>;\n     cfg \\<turnstile> <q, inM b'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, inM b'>; \\<not> isReceiverOf q <p, v>;\n     enabled cfg1 <q, inM b'>; m' = <q, inM b'>; m = <p, v>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Value v)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Value v) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Bool b')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, v>;\n     msgs cfg1 =\n     sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>;\n     enabled cfg1 <q, inM b'>;\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Value\n                         v) \\<union># msgs cfg -# <p, v> -# <q, inM b'> =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'>;\n     enabled cfg <q, inM b'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>;\n     sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n     sends q (states cfg q)\n      (Bool\n        b') \\<union># sends p (states cfg p)\n                       (Value\n                         v) \\<union># msgs\n cfg -# <p, v> -# <q, inM b'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n                      sends p (states cfg p)\n                       (Value v) \\<union># msgs cfg2 -# <p, v>", "with msgCfg"], ["proof (chain)\npicking this:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n  enabled cfg m\n  enabled cfg m'", "show \" (sends q (states cfg q) (Bool b') \n                         \\<union># (msgs cfg1 -# <q, inM b'>)) \n                       = (sends p (states cfg p) (Value v) \n                         \\<union># (msgs cfg2 -# <p, v>))\""], ["proof (prove)\nusing this:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n  enabled cfg m\n  enabled cfg m'\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n    sends p (states cfg p) (Value v) \\<union># msgs cfg2 -# <p, v>", "using CaseM StepP StepWithoutP Rec' InMsg AXc[of \"m'\" \"m\" \"msgs cfg\"\n          \"sends q (states cfg q) (Bool b')\"\n          \"sends p (states cfg p) (Value v)\"]"], ["proof (prove)\nusing this:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n  enabled cfg m\n  enabled cfg m'\n  m = <p, v>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  m' = <q, inM b'>\n  \\<lbrakk>m' \\<noteq> m; m' \\<in># msgs cfg; m \\<in># msgs cfg\\<rbrakk>\n  \\<Longrightarrow> sends q (states cfg q)\n                     (Bool\n                       b') \\<union># sends p (states cfg p)\n(Value v) \\<union># msgs cfg -# m -# m' =\n                    sends p (states cfg p)\n                     (Value\n                       v) \\<union># sends q (states cfg q)\n                                     (Bool b') \\<union># msgs cfg -# m' -# m\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n    sends p (states cfg p) (Value v) \\<union># msgs cfg2 -# <p, v>", "unfolding enabled_def"], ["proof (prove)\nusing this:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg -# <q, inM b'>\n  m \\<in># msgs cfg\n  m' \\<in># msgs cfg\n  m = <p, v>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  m' = <q, inM b'>\n  \\<lbrakk>m' \\<noteq> m; m' \\<in># msgs cfg; m \\<in># msgs cfg\\<rbrakk>\n  \\<Longrightarrow> sends q (states cfg q)\n                     (Bool\n                       b') \\<union># sends p (states cfg p)\n(Value v) \\<union># msgs cfg -# m -# m' =\n                    sends p (states cfg p)\n                     (Value\n                       v) \\<union># sends q (states cfg q)\n                                     (Bool b') \\<union># msgs cfg -# m' -# m\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n    sends p (states cfg p) (Value v) \\<union># msgs cfg2 -# <p, v>", "by metis"], ["proof (state)\nthis:\n  sends q (states cfg q) (Bool b') \\<union># msgs cfg1 -# <q, inM b'> =\n  sends p (states cfg p) (Value v) \\<union># msgs cfg2 -# <p, v>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>m = <p, v>; m' = <x11, inM x12>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'\n 2. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "ultimately"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg2 \\<turnstile> m \\<mapsto> cfg'", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n     cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "case (Msg q v')"], ["proof (state)\nthis:\n  m' = <q, v'>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "define cfg' where \"cfg' = \\<lparr>states = \\<lambda>s. (\n      if s = q then\n        trans q (states cfg q) (Value v')\n      else if s = p then\n        trans p (states cfg p) (Value v)\n      else\n        states cfg s),\n      msgs = ((sends q (states cfg q) (Value v')) \n        \\<union># (((sends p (states cfg p) (Value v))\n        \\<union># ((msgs cfg)-# m))\n        -# m'))\\<rparr> \""], ["proof (state)\nthis:\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Value v')\n               else if s = p then trans p (states cfg p) (Value v)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Value\n          v') \\<union># sends p (states cfg p)\n                         (Value v) \\<union># msgs cfg -# m -# m'\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "hence StepP': \"(cfg1 \\<turnstile> m' \\<mapsto> cfg')\""], ["proof (prove)\nusing this:\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Value v')\n               else if s = p then trans p (states cfg p) (Value v)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Value\n          v') \\<union># sends p (states cfg p)\n                         (Value v) \\<union># msgs cfg -# m -# m'\\<rparr>\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> m' \\<mapsto> cfg'", "using StepP Msg EnM' Rec CaseM"], ["proof (prove)\nusing this:\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Value v')\n               else if s = p then trans p (states cfg p) (Value v)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Value\n          v') \\<union># sends p (states cfg p)\n                         (Value v) \\<union># msgs cfg -# m -# m'\\<rparr>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  m' = <q, v'>\n  enabled cfg1 m'\n  isReceiverOf p m\n  \\<not> isReceiverOf p m'\n  m = <p, v>\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> m' \\<mapsto> cfg'", "by auto"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "moreover"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "from EnM"], ["proof (chain)\npicking this:\n  enabled cfg2 m", "have \"(cfg2 \\<turnstile> m \\<mapsto> cfg')\""], ["proof (prove)\nusing this:\n  enabled cfg2 m\n\ngoal (1 subgoal):\n 1. cfg2 \\<turnstile> m \\<mapsto> cfg'", "using Msg cfg'_def StepP StepP' StepWithoutP NoReceivingNoChange Rec' CaseM EnM'"], ["proof (prove)\nusing this:\n  enabled cfg2 m\n  m' = <q, v'>\n  cfg' =\n  \\<lparr>states =\n            \\<lambda>s.\n               if s = q then trans q (states cfg q) (Value v')\n               else if s = p then trans p (states cfg p) (Value v)\n                    else states cfg s,\n     msgs =\n       sends q (states cfg q)\n        (Value\n          v') \\<union># sends p (states cfg p)\n                         (Value v) \\<union># msgs cfg -# m -# m'\\<rparr>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  \\<lbrakk>?cfg1.0 \\<turnstile> ?m \\<mapsto> ?cfg2.0;\n   \\<not> isReceiverOf ?p ?m\\<rbrakk>\n  \\<Longrightarrow> states ?cfg1.0 ?p = states ?cfg2.0 ?p\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  m = <p, v>\n  enabled cfg1 m'\n\ngoal (1 subgoal):\n 1. cfg2 \\<turnstile> m \\<mapsto> cfg'", "proof (simp, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, v>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Value v')\n                  else if s = p then trans p (states cfg p) (Value v)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, v>;\n     cfg \\<turnstile> <p, v> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, v'> \\<mapsto> \\<lparr>states =\n             \\<lambda>s.\n                if s = q then trans q (states cfg q) (Value v')\n                else if s = p then trans p (states cfg p) (Value v)\n                     else states cfg s,\n      msgs =\n        sends q (states cfg q)\n         (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     cfg \\<turnstile> <q, v'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, v'>; \\<not> isReceiverOf q <p, v>;\n     enabled cfg1 <q, v'>; m' = <q, v'>; m = <p, v>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Value v)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Value v) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Value v')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, v>;\n     msgs cfg1 =\n     sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>;\n     enabled cfg1 <q, v'>;\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Value v) \\<union># msgs cfg -# <p, v> -# <q, v'> =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'>;\n     enabled cfg <q, v'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>;\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Value\n                         v) \\<union># msgs cfg -# <p, v> -# <q, v'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Value v') \\<union># msgs cfg1 -# <q, v'> =\n                      sends p (states cfg p)\n                       (Value v) \\<union># msgs cfg2 -# <p, v>", "assume msgCfg:\n        \"msgs cfg1 = (sends p (states cfg p) (Value v)\n          \\<union># (msgs cfg -# <p, v>))\"\n        \"msgs cfg2 = (sends q (states cfg q) (Value v')\n          \\<union># (msgs cfg -# <q, v'>))\""], ["proof (state)\nthis:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, v>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Value v')\n                  else if s = p then trans p (states cfg p) (Value v)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, v>;\n     cfg \\<turnstile> <p, v> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, v'> \\<mapsto> \\<lparr>states =\n             \\<lambda>s.\n                if s = q then trans q (states cfg q) (Value v')\n                else if s = p then trans p (states cfg p) (Value v)\n                     else states cfg s,\n      msgs =\n        sends q (states cfg q)\n         (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     cfg \\<turnstile> <q, v'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, v'>; \\<not> isReceiverOf q <p, v>;\n     enabled cfg1 <q, v'>; m' = <q, v'>; m = <p, v>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Value v)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Value v) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Value v')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, v>;\n     msgs cfg1 =\n     sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>;\n     enabled cfg1 <q, v'>;\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Value v) \\<union># msgs cfg -# <p, v> -# <q, v'> =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'>;\n     enabled cfg <q, v'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>;\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Value\n                         v) \\<union># msgs cfg -# <p, v> -# <q, v'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Value v') \\<union># msgs cfg1 -# <q, v'> =\n                      sends p (states cfg p)\n                       (Value v) \\<union># msgs cfg2 -# <p, v>", "have \"enabled cfg m\" \"enabled cfg m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled cfg m &&& enabled cfg m'", "using StepP StepWithoutP CaseM Msg"], ["proof (prove)\nusing this:\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  m = <p, v>\n  m' = <q, v'>\n\ngoal (1 subgoal):\n 1. enabled cfg m &&& enabled cfg m'", "by auto"], ["proof (state)\nthis:\n  enabled cfg m\n  enabled cfg m'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>enabled cfg2 <p, v>;\n     cfg' =\n     \\<lparr>states =\n               \\<lambda>s.\n                  if s = q then trans q (states cfg q) (Value v')\n                  else if s = p then trans p (states cfg p) (Value v)\n                       else states cfg s,\n        msgs =\n          sends q (states cfg q)\n           (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     q = q; q \\<noteq> p; enabled cfg2 <p, v>;\n     cfg \\<turnstile> <p, v> \\<mapsto> cfg1;\n     cfg1 \\<turnstile> <q, v'> \\<mapsto> \\<lparr>states =\n             \\<lambda>s.\n                if s = q then trans q (states cfg q) (Value v')\n                else if s = p then trans p (states cfg p) (Value v)\n                     else states cfg s,\n      msgs =\n        sends q (states cfg q)\n         (Value v') \\<union># msgs cfg1 -# <q, v'>\\<rparr>;\n     cfg \\<turnstile> <q, v'> \\<mapsto> cfg2;\n     \\<And>cfg1 m cfg2 p.\n        \\<lbrakk>cfg1 \\<turnstile> m \\<mapsto> cfg2;\n         \\<not> isReceiverOf p m\\<rbrakk>\n        \\<Longrightarrow> states cfg1 p = states cfg2 p;\n     isReceiverOf q <q, v'>; \\<not> isReceiverOf q <p, v>;\n     enabled cfg1 <q, v'>; m' = <q, v'>; m = <p, v>;\n     \\<forall>s.\n        (s = p \\<longrightarrow>\n         states cfg1 p = trans p (states cfg p) (Value v)) \\<and>\n        (s \\<noteq> p \\<longrightarrow> states cfg1 s = states cfg s);\n     \\<forall>s.\n        s \\<noteq> q \\<longrightarrow>\n        (if s = p then trans p (states cfg p) (Value v) else states cfg s) =\n        states cfg1 s;\n     \\<forall>s.\n        (s = q \\<longrightarrow>\n         states cfg2 q = trans q (states cfg q) (Value v')) \\<and>\n        (s \\<noteq> q \\<longrightarrow> states cfg2 s = states cfg s);\n     enabled cfg <p, v>;\n     msgs cfg1 =\n     sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>;\n     enabled cfg1 <q, v'>;\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Value v) \\<union># msgs cfg -# <p, v> -# <q, v'> =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'>;\n     enabled cfg <q, v'>;\n     msgs cfg2 =\n     sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>;\n     sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n     sends q (states cfg q)\n      (Value\n        v') \\<union># sends p (states cfg p)\n                       (Value\n                         v) \\<union># msgs cfg -# <p, v> -# <q, v'>\\<rbrakk>\n    \\<Longrightarrow> sends q (states cfg q)\n                       (Value v') \\<union># msgs cfg1 -# <q, v'> =\n                      sends p (states cfg p)\n                       (Value v) \\<union># msgs cfg2 -# <p, v>", "with msgCfg"], ["proof (chain)\npicking this:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n  enabled cfg m\n  enabled cfg m'", "show \" (sends q (states cfg q) (Value v') \n                         \\<union># (msgs cfg1 -# <q, v'>)) \n                       = (sends p (states cfg p) (Value v) \n                         \\<union># (msgs cfg2 -# <p, v>))\""], ["proof (prove)\nusing this:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n  enabled cfg m\n  enabled cfg m'\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n    sends p (states cfg p) (Value v) \\<union># msgs cfg2 -# <p, v>", "using CaseM StepP StepWithoutP Rec' Msg \n          AXc[of \"m'\" \"m\" \"msgs cfg\" \"sends q (states cfg q) (Value v')\"\n          \"sends p (states cfg p) (Value v)\"]"], ["proof (prove)\nusing this:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n  enabled cfg m\n  enabled cfg m'\n  m = <p, v>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  m' = <q, v'>\n  \\<lbrakk>m' \\<noteq> m; m' \\<in># msgs cfg; m \\<in># msgs cfg\\<rbrakk>\n  \\<Longrightarrow> sends q (states cfg q)\n                     (Value\n                       v') \\<union># sends p (states cfg p)\n(Value v) \\<union># msgs cfg -# m -# m' =\n                    sends p (states cfg p)\n                     (Value\n                       v) \\<union># sends q (states cfg q)\n                                     (Value\n v') \\<union># msgs cfg -# m' -# m\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n    sends p (states cfg p) (Value v) \\<union># msgs cfg2 -# <p, v>", "unfolding enabled_def"], ["proof (prove)\nusing this:\n  msgs cfg1 = sends p (states cfg p) (Value v) \\<union># msgs cfg -# <p, v>\n  msgs cfg2 =\n  sends q (states cfg q) (Value v') \\<union># msgs cfg -# <q, v'>\n  m \\<in># msgs cfg\n  m' \\<in># msgs cfg\n  m = <p, v>\n  cfg \\<turnstile> m \\<mapsto> cfg1\n  cfg \\<turnstile> m' \\<mapsto> cfg2\n  isReceiverOf q m'\n  \\<not> isReceiverOf q m\n  m' = <q, v'>\n  \\<lbrakk>m' \\<noteq> m; m' \\<in># msgs cfg; m \\<in># msgs cfg\\<rbrakk>\n  \\<Longrightarrow> sends q (states cfg q)\n                     (Value\n                       v') \\<union># sends p (states cfg p)\n(Value v) \\<union># msgs cfg -# m -# m' =\n                    sends p (states cfg p)\n                     (Value\n                       v) \\<union># sends q (states cfg q)\n                                     (Value\n v') \\<union># msgs cfg -# m' -# m\n\ngoal (1 subgoal):\n 1. sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n    sends p (states cfg p) (Value v) \\<union># msgs cfg2 -# <p, v>", "by metis"], ["proof (state)\nthis:\n  sends q (states cfg q) (Value v') \\<union># msgs cfg1 -# <q, v'> =\n  sends p (states cfg p) (Value v) \\<union># msgs cfg2 -# <p, v>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       \\<lbrakk>m = <p, v>; m' = <x31, x32>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n                            cfg2 \\<turnstile> m \\<mapsto> cfg'", "ultimately"], ["proof (chain)\npicking this:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg2 \\<turnstile> m \\<mapsto> cfg'", "show ?thesis"], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> m' \\<mapsto> cfg'\n  cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n       cfg2 \\<turnstile> m \\<mapsto> cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n     cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> m' \\<mapsto> cfg' \\<and>\n     cfg2 \\<turnstile> m \\<mapsto> cfg'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DiamondTwo:\nfixes\n  cfg cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  Q :: \"'p set\" and\n  msg :: \"('p, 'v) message\"\nassumes\n  QReach: \"qReachable cfg Q cfg1\" and\n  Step: \"cfg  \\<turnstile> msg \\<mapsto> cfg2\"\n        \"\\<exists>p\\<in>Proc - Q. isReceiverOf p msg\"\nshows\n  \"\\<exists> (cfg' :: ('p,'v,'s) configuration) . (cfg1  \\<turnstile> msg \\<mapsto> cfg') \n  \\<and> qReachable cfg2 Q cfg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and> qReachable cfg2 Q cfg'", "using assms"], ["proof (prove)\nusing this:\n  qReachable cfg Q cfg1\n  cfg \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and> qReachable cfg2 Q cfg'", "proof(induct rule: qReachable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'\n 2. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "fix cfg Q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'\n 2. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "have \"qReachable cfg2 Q cfg2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qReachable cfg2 Q cfg2", "using qReachable.simps(1)"], ["proof (prove)\nusing this:\n  qReachable ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>cfg1 Q.\n       ?a1.0 = cfg1 \\<and> ?a2.0 = Q \\<and> ?a3.0 = cfg1) \\<or>\n   (\\<exists>cfg1 Q cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = Q \\<and>\n       ?a3.0 = cfg3 \\<and>\n       qReachable cfg1 Q cfg2 \\<and>\n       cfg2 \\<turnstile> msg \\<mapsto> cfg3 \\<and>\n       (\\<exists>p\\<in>Q. isReceiverOf p msg)))\n\ngoal (1 subgoal):\n 1. qReachable cfg2 Q cfg2", "by blast"], ["proof (state)\nthis:\n  qReachable cfg2 Q cfg2\n\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'\n 2. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "moreover"], ["proof (state)\nthis:\n  qReachable cfg2 Q cfg2\n\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'\n 2. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "assume \"cfg \\<turnstile> msg \\<mapsto> cfg2\" \"\\<exists>p\\<in>UNIV - Q. isReceiverOf p msg\""], ["proof (state)\nthis:\n  cfg \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'\n 2. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "ultimately"], ["proof (chain)\npicking this:\n  qReachable cfg2 Q cfg2\n  cfg \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg", "have \"(cfg \\<turnstile> msg \\<mapsto> cfg2) \\<and> qReachable cfg2 Q cfg2\""], ["proof (prove)\nusing this:\n  qReachable cfg2 Q cfg2\n  cfg \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. cfg \\<turnstile> msg \\<mapsto> cfg2 \\<and> qReachable cfg2 Q cfg2", "by blast"], ["proof (state)\nthis:\n  cfg \\<turnstile> msg \\<mapsto> cfg2 \\<and> qReachable cfg2 Q cfg2\n\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'\n 2. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "thus \"\\<exists>cfg'.(cfg \\<turnstile> msg \\<mapsto> cfg') \\<and> qReachable cfg2 Q cfg'\""], ["proof (prove)\nusing this:\n  cfg \\<turnstile> msg \\<mapsto> cfg2 \\<and> qReachable cfg2 Q cfg2\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg \\<turnstile> msg \\<mapsto> cfg' \\<and> qReachable cfg2 Q cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg \\<turnstile> msg \\<mapsto> cfg' \\<and> qReachable cfg2 Q cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "fix cfg Q cfg1' msga cfg1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "assume   \"(cfg \\<turnstile> msg \\<mapsto> cfg2)\"\n    \"(\\<exists>p\\<in>UNIV - Q. isReceiverOf p msg)\"\n    \"((cfg \\<turnstile> msg \\<mapsto> cfg2) \\<Longrightarrow>\n     (\\<exists>p\\<in>UNIV - Q. isReceiverOf p msg) \\<Longrightarrow>\n     (\\<exists>cfg'. (cfg1' \\<turnstile> msg \\<mapsto> cfg') \\<and> qReachable cfg2 Q cfg'))\""], ["proof (state)\nthis:\n  cfg \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n  \\<lbrakk>cfg \\<turnstile> msg \\<mapsto> cfg2;\n   \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cfg'.\n                       cfg1' \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                       qReachable cfg2 Q cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "hence \"(\\<exists>cfg'. (cfg1' \\<turnstile> msg \\<mapsto> cfg') \\<and> (\\<exists>p\\<in>UNIV - Q. isReceiverOf p msg) \n        \\<and> qReachable cfg2 Q cfg')\""], ["proof (prove)\nusing this:\n  cfg \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n  \\<lbrakk>cfg \\<turnstile> msg \\<mapsto> cfg2;\n   \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cfg'.\n                       cfg1' \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                       qReachable cfg2 Q cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1' \\<turnstile> msg \\<mapsto> cfg' \\<and>\n       (\\<exists>p\\<in>Proc - Q. isReceiverOf p msg) \\<and>\n       qReachable cfg2 Q cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1' \\<turnstile> msg \\<mapsto> cfg' \\<and>\n     (\\<exists>p\\<in>Proc - Q. isReceiverOf p msg) \\<and>\n     qReachable cfg2 Q cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "then"], ["proof (chain)\npicking this:\n  \\<exists>cfg'.\n     cfg1' \\<turnstile> msg \\<mapsto> cfg' \\<and>\n     (\\<exists>p\\<in>Proc - Q. isReceiverOf p msg) \\<and>\n     qReachable cfg2 Q cfg'", "obtain cfg' where Cfg': \"(cfg1' \\<turnstile> msg \\<mapsto> cfg')\" \n    \"(\\<exists>p\\<in>UNIV - Q. isReceiverOf p msg)\" \"qReachable cfg2 Q cfg'\""], ["proof (prove)\nusing this:\n  \\<exists>cfg'.\n     cfg1' \\<turnstile> msg \\<mapsto> cfg' \\<and>\n     (\\<exists>p\\<in>Proc - Q. isReceiverOf p msg) \\<and>\n     qReachable cfg2 Q cfg'\n\ngoal (1 subgoal):\n 1. (\\<And>cfg'.\n        \\<lbrakk>cfg1' \\<turnstile> msg \\<mapsto> cfg';\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n         qReachable cfg2 Q cfg'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cfg1' \\<turnstile> msg \\<mapsto> cfg'\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n  qReachable cfg2 Q cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "then"], ["proof (chain)\npicking this:\n  cfg1' \\<turnstile> msg \\<mapsto> cfg'\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n  qReachable cfg2 Q cfg'", "obtain p where P: \"p\\<in>UNIV - Q\" \"isReceiverOf p msg\""], ["proof (prove)\nusing this:\n  cfg1' \\<turnstile> msg \\<mapsto> cfg'\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n  qReachable cfg2 Q cfg'\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> Proc - Q; isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> Proc - Q\n  isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "assume Step2: \"(cfg1' \\<turnstile> msga \\<mapsto> cfg1)\"\n    \"(\\<exists>p\\<in>Q. isReceiverOf p msga)\"\n    \"(qReachable cfg Q cfg1')\""], ["proof (state)\nthis:\n  cfg1' \\<turnstile> msga \\<mapsto> cfg1\n  \\<exists>p\\<in>Q. isReceiverOf p msga\n  qReachable cfg Q cfg1'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "then"], ["proof (chain)\npicking this:\n  cfg1' \\<turnstile> msga \\<mapsto> cfg1\n  \\<exists>p\\<in>Q. isReceiverOf p msga\n  qReachable cfg Q cfg1'", "obtain p' where P': \"p'\\<in>Q\" \"isReceiverOf p' msga\""], ["proof (prove)\nusing this:\n  cfg1' \\<turnstile> msga \\<mapsto> cfg1\n  \\<exists>p\\<in>Q. isReceiverOf p msga\n  qReachable cfg Q cfg1'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>p' \\<in> Q; isReceiverOf p' msga\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p' \\<in> Q\n  isReceiverOf p' msga\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "from P'(1) P(1)"], ["proof (chain)\npicking this:\n  p' \\<in> Q\n  p \\<in> Proc - Q", "have notEq: \"p \\<noteq> p'\""], ["proof (prove)\nusing this:\n  p' \\<in> Q\n  p \\<in> Proc - Q\n\ngoal (1 subgoal):\n 1. p \\<noteq> p'", "by blast"], ["proof (state)\nthis:\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "with P(2) P'(2)"], ["proof (chain)\npicking this:\n  isReceiverOf p msg\n  isReceiverOf p' msga\n  p \\<noteq> p'", "have \"\\<not> isReceiverOf p' msg\" \"\\<not> isReceiverOf p msga\""], ["proof (prove)\nusing this:\n  isReceiverOf p msg\n  isReceiverOf p' msga\n  p \\<noteq> p'\n\ngoal (1 subgoal):\n 1. \\<not> isReceiverOf p' msg &&& \\<not> isReceiverOf p msga", "using UniqueReceiverOf[of p' msga p] UniqueReceiverOf[of p msg p']"], ["proof (prove)\nusing this:\n  isReceiverOf p msg\n  isReceiverOf p' msga\n  p \\<noteq> p'\n  \\<lbrakk>isReceiverOf p' msga; p \\<noteq> p'\\<rbrakk>\n  \\<Longrightarrow> \\<not> isReceiverOf p msga\n  \\<lbrakk>isReceiverOf p msg; p' \\<noteq> p\\<rbrakk>\n  \\<Longrightarrow> \\<not> isReceiverOf p' msg\n\ngoal (1 subgoal):\n 1. \\<not> isReceiverOf p' msg &&& \\<not> isReceiverOf p msga", "by auto"], ["proof (state)\nthis:\n  \\<not> isReceiverOf p' msg\n  \\<not> isReceiverOf p msga\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "with notEq P'(2) P(2) Cfg'(1) Step2(1)"], ["proof (chain)\npicking this:\n  p \\<noteq> p'\n  isReceiverOf p' msga\n  isReceiverOf p msg\n  cfg1' \\<turnstile> msg \\<mapsto> cfg'\n  cfg1' \\<turnstile> msga \\<mapsto> cfg1\n  \\<not> isReceiverOf p' msg\n  \\<not> isReceiverOf p msga", "have \n    \"\\<exists>cfg''. (cfg' \\<turnstile> msga \\<mapsto> cfg'') \\<and> (cfg1 \\<turnstile> msg \\<mapsto> cfg'')\""], ["proof (prove)\nusing this:\n  p \\<noteq> p'\n  isReceiverOf p' msga\n  isReceiverOf p msg\n  cfg1' \\<turnstile> msg \\<mapsto> cfg'\n  cfg1' \\<turnstile> msga \\<mapsto> cfg1\n  \\<not> isReceiverOf p' msg\n  \\<not> isReceiverOf p msga\n\ngoal (1 subgoal):\n 1. \\<exists>cfg''.\n       cfg' \\<turnstile> msga \\<mapsto> cfg'' \\<and>\n       cfg1 \\<turnstile> msg \\<mapsto> cfg''", "using DiamondOne"], ["proof (prove)\nusing this:\n  p \\<noteq> p'\n  isReceiverOf p' msga\n  isReceiverOf p msg\n  cfg1' \\<turnstile> msg \\<mapsto> cfg'\n  cfg1' \\<turnstile> msga \\<mapsto> cfg1\n  \\<not> isReceiverOf p' msg\n  \\<not> isReceiverOf p msga\n  \\<lbrakk>?cfg \\<turnstile> ?m \\<mapsto> ?cfg1.0; ?p \\<noteq> ?q;\n   isReceiverOf ?p ?m; \\<not> isReceiverOf ?p ?m'; isReceiverOf ?q ?m';\n   \\<not> isReceiverOf ?q ?m;\n   ?cfg \\<turnstile> ?m' \\<mapsto> ?cfg2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cfg'.\n                       ?cfg1.0 \\<turnstile> ?m' \\<mapsto> cfg' \\<and>\n                       ?cfg2.0 \\<turnstile> ?m \\<mapsto> cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfg''.\n       cfg' \\<turnstile> msga \\<mapsto> cfg'' \\<and>\n       cfg1 \\<turnstile> msg \\<mapsto> cfg''", "by simp"], ["proof (state)\nthis:\n  \\<exists>cfg''.\n     cfg' \\<turnstile> msga \\<mapsto> cfg'' \\<and>\n     cfg1 \\<turnstile> msg \\<mapsto> cfg''\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "then"], ["proof (chain)\npicking this:\n  \\<exists>cfg''.\n     cfg' \\<turnstile> msga \\<mapsto> cfg'' \\<and>\n     cfg1 \\<turnstile> msg \\<mapsto> cfg''", "obtain cfg'' where Cfg'': \"cfg' \\<turnstile> msga \\<mapsto> cfg''\" \"cfg1 \\<turnstile> msg \\<mapsto> cfg''\""], ["proof (prove)\nusing this:\n  \\<exists>cfg''.\n     cfg' \\<turnstile> msga \\<mapsto> cfg'' \\<and>\n     cfg1 \\<turnstile> msg \\<mapsto> cfg''\n\ngoal (1 subgoal):\n 1. (\\<And>cfg''.\n        \\<lbrakk>cfg' \\<turnstile> msga \\<mapsto> cfg'';\n         cfg1 \\<turnstile> msg \\<mapsto> cfg''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cfg' \\<turnstile> msga \\<mapsto> cfg''\n  cfg1 \\<turnstile> msg \\<mapsto> cfg''\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "from Cfg''(1) Step2(2) Cfg'(3)"], ["proof (chain)\npicking this:\n  cfg' \\<turnstile> msga \\<mapsto> cfg''\n  \\<exists>p\\<in>Q. isReceiverOf p msga\n  qReachable cfg2 Q cfg'", "have \"qReachable cfg2 Q cfg''\""], ["proof (prove)\nusing this:\n  cfg' \\<turnstile> msga \\<mapsto> cfg''\n  \\<exists>p\\<in>Q. isReceiverOf p msga\n  qReachable cfg2 Q cfg'\n\ngoal (1 subgoal):\n 1. qReachable cfg2 Q cfg''", "using qReachable.simps[of cfg2 Q cfg'']"], ["proof (prove)\nusing this:\n  cfg' \\<turnstile> msga \\<mapsto> cfg''\n  \\<exists>p\\<in>Q. isReceiverOf p msga\n  qReachable cfg2 Q cfg'\n  qReachable cfg2 Q cfg'' =\n  ((\\<exists>cfg1 Q. cfg2 = cfg1 \\<and> Q = Q \\<and> cfg'' = cfg1) \\<or>\n   (\\<exists>cfg1 Q cfg2a msg cfg3.\n       cfg2 = cfg1 \\<and>\n       Q = Q \\<and>\n       cfg'' = cfg3 \\<and>\n       qReachable cfg1 Q cfg2a \\<and>\n       cfg2a \\<turnstile> msg \\<mapsto> cfg3 \\<and>\n       (\\<exists>p\\<in>Q. isReceiverOf p msg)))\n\ngoal (1 subgoal):\n 1. qReachable cfg2 Q cfg''", "by auto"], ["proof (state)\nthis:\n  qReachable cfg2 Q cfg''\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "with Cfg'(2) Cfg''(2)"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n  cfg1 \\<turnstile> msg \\<mapsto> cfg''\n  qReachable cfg2 Q cfg''", "have \n    \"(cfg1 \\<turnstile> msg \\<mapsto> cfg'') \\<and> qReachable cfg2 Q cfg''\""], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n  cfg1 \\<turnstile> msg \\<mapsto> cfg''\n  qReachable cfg2 Q cfg''\n\ngoal (1 subgoal):\n 1. cfg1 \\<turnstile> msg \\<mapsto> cfg'' \\<and> qReachable cfg2 Q cfg''", "by simp"], ["proof (state)\nthis:\n  cfg1 \\<turnstile> msg \\<mapsto> cfg'' \\<and> qReachable cfg2 Q cfg''\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2a msga cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2a;\n        \\<lbrakk>cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n         \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg'.\n                             cfg2a \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                             qReachable cfg2 Q cfg';\n        cfg2a \\<turnstile> msga \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msga;\n        cfg1 \\<turnstile> msg \\<mapsto> cfg2;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            cfg3 \\<turnstile> msg \\<mapsto> cfg' \\<and>\n                            qReachable cfg2 Q cfg'", "thus \"\\<exists>cfg'. (cfg1 \\<turnstile> msg \\<mapsto> cfg') \\<and> qReachable cfg2 Q cfg'\""], ["proof (prove)\nusing this:\n  cfg1 \\<turnstile> msg \\<mapsto> cfg'' \\<and> qReachable cfg2 Q cfg''\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and> qReachable cfg2 Q cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     cfg1 \\<turnstile> msg \\<mapsto> cfg' \\<and> qReachable cfg2 Q cfg'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Proposition 1 of V?lzer.\\<close>"], ["", "lemma Diamond:\nfixes\n  cfg cfg1 cfg2 :: \"('p,'v,'s) configuration\" and\n  Q :: \"'p set\"\nassumes\n  QReach: \"qReachable cfg Q cfg1\" and\n  WithoutQReach: \"withoutQReachable cfg Q cfg2\"\nshows \n  \"\\<exists> cfg'. withoutQReachable cfg1 Q cfg' \n     \\<and> qReachable cfg2 Q cfg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'", "define notQ where \"notQ \\<equiv> UNIV - Q\""], ["proof (state)\nthis:\n  notQ \\<equiv> Proc - Q\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'", "with WithoutQReach"], ["proof (chain)\npicking this:\n  qReachable cfg (Proc - Q) cfg2\n  notQ \\<equiv> Proc - Q", "have \"qReachable cfg notQ cfg2\""], ["proof (prove)\nusing this:\n  qReachable cfg (Proc - Q) cfg2\n  notQ \\<equiv> Proc - Q\n\ngoal (1 subgoal):\n 1. qReachable cfg notQ cfg2", "by simp"], ["proof (state)\nthis:\n  qReachable cfg notQ cfg2\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'", "thus ?thesis"], ["proof (prove)\nusing this:\n  qReachable cfg notQ cfg2\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'", "using QReach notQ_def"], ["proof (prove)\nusing this:\n  qReachable cfg notQ cfg2\n  qReachable cfg Q cfg1\n  notQ \\<equiv> Proc - Q\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'", "proof (induct rule: qReachable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg1a.\n       qReachable cfg1a Q cfg1 \\<Longrightarrow>\n       \\<exists>cfg'.\n          qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg1a Q cfg'\n 2. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "fix cfg2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg1a.\n       qReachable cfg1a Q cfg1 \\<Longrightarrow>\n       \\<exists>cfg'.\n          qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg1a Q cfg'\n 2. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "assume \"qReachable cfg2 Q cfg1\""], ["proof (state)\nthis:\n  qReachable cfg2 Q cfg1\n\ngoal (2 subgoals):\n 1. \\<And>cfg1a.\n       qReachable cfg1a Q cfg1 \\<Longrightarrow>\n       \\<exists>cfg'.\n          qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg1a Q cfg'\n 2. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "moreover"], ["proof (state)\nthis:\n  qReachable cfg2 Q cfg1\n\ngoal (2 subgoals):\n 1. \\<And>cfg1a.\n       qReachable cfg1a Q cfg1 \\<Longrightarrow>\n       \\<exists>cfg'.\n          qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg1a Q cfg'\n 2. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "have \"qReachable cfg1 (UNIV - Q) cfg1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qReachable cfg1 (Proc - Q) cfg1", "using qReachable.simps"], ["proof (prove)\nusing this:\n  qReachable ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>cfg1 Q.\n       ?a1.0 = cfg1 \\<and> ?a2.0 = Q \\<and> ?a3.0 = cfg1) \\<or>\n   (\\<exists>cfg1 Q cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = Q \\<and>\n       ?a3.0 = cfg3 \\<and>\n       qReachable cfg1 Q cfg2 \\<and>\n       cfg2 \\<turnstile> msg \\<mapsto> cfg3 \\<and>\n       (\\<exists>p\\<in>Q. isReceiverOf p msg)))\n\ngoal (1 subgoal):\n 1. qReachable cfg1 (Proc - Q) cfg1", "by blast"], ["proof (state)\nthis:\n  qReachable cfg1 (Proc - Q) cfg1\n\ngoal (2 subgoals):\n 1. \\<And>cfg1a.\n       qReachable cfg1a Q cfg1 \\<Longrightarrow>\n       \\<exists>cfg'.\n          qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg1a Q cfg'\n 2. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "ultimately"], ["proof (chain)\npicking this:\n  qReachable cfg2 Q cfg1\n  qReachable cfg1 (Proc - Q) cfg1", "show \n      \"\\<exists>cfg'. qReachable cfg1 (UNIV - Q) cfg' \n        \\<and> qReachable cfg2 Q cfg'\""], ["proof (prove)\nusing this:\n  qReachable cfg2 Q cfg1\n  qReachable cfg1 (Proc - Q) cfg1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "fix cfg cfg2' cfg2 msg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "assume Ass1: \" qReachable cfg Q cfg1\" \"qReachable cfg (UNIV - Q) cfg2' \""], ["proof (state)\nthis:\n  qReachable cfg Q cfg1\n  qReachable cfg (Proc - Q) cfg2'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "assume Ass2:  \"cfg2' \\<turnstile> msg \\<mapsto> cfg2\" \"\\<exists>p\\<in>UNIV - Q. isReceiverOf p msg\""], ["proof (state)\nthis:\n  cfg2' \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "assume \"qReachable cfg Q cfg1 \\<Longrightarrow> \\<exists>cfg'. qReachable cfg1 (UNIV - Q) cfg' \n      \\<and> qReachable cfg2' Q cfg'\""], ["proof (state)\nthis:\n  qReachable cfg Q cfg1 \\<Longrightarrow>\n  \\<exists>cfg'.\n     qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2' Q cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "with Ass1(1)"], ["proof (chain)\npicking this:\n  qReachable cfg Q cfg1\n  qReachable cfg Q cfg1 \\<Longrightarrow>\n  \\<exists>cfg'.\n     qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2' Q cfg'", "have \"\\<exists>cfg'. qReachable cfg1 (UNIV - Q) cfg' \n      \\<and> qReachable cfg2' Q cfg'\""], ["proof (prove)\nusing this:\n  qReachable cfg Q cfg1\n  qReachable cfg Q cfg1 \\<Longrightarrow>\n  \\<exists>cfg'.\n     qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2' Q cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2' Q cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2' Q cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "then"], ["proof (chain)\npicking this:\n  \\<exists>cfg'.\n     qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2' Q cfg'", "obtain cfg' where \n      Cfg'1: \"qReachable cfg2' Q cfg'\" and \n      Cfg':  \"qReachable cfg1 (UNIV - Q) cfg'\""], ["proof (prove)\nusing this:\n  \\<exists>cfg'.\n     qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2' Q cfg'\n\ngoal (1 subgoal):\n 1. (\\<And>cfg'.\n        \\<lbrakk>qReachable cfg2' Q cfg';\n         qReachable cfg1 (Proc - Q) cfg'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  qReachable cfg2' Q cfg'\n  qReachable cfg1 (Proc - Q) cfg'\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "from Cfg'1 Ass2"], ["proof (chain)\npicking this:\n  qReachable cfg2' Q cfg'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg", "have \n      \"\\<exists>cfg''.(cfg' \\<turnstile> msg \\<mapsto> cfg'') \\<and> qReachable cfg2 Q cfg''\""], ["proof (prove)\nusing this:\n  qReachable cfg2' Q cfg'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<exists>cfg''.\n       cfg' \\<turnstile> msg \\<mapsto> cfg'' \\<and> qReachable cfg2 Q cfg''", "using DiamondTwo"], ["proof (prove)\nusing this:\n  qReachable cfg2' Q cfg'\n  cfg2' \\<turnstile> msg \\<mapsto> cfg2\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n  \\<lbrakk>qReachable ?cfg ?Q ?cfg1.0;\n   ?cfg \\<turnstile> ?msg \\<mapsto> ?cfg2.0;\n   \\<exists>p\\<in>Proc - ?Q. isReceiverOf p ?msg\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cfg'.\n                       ?cfg1.0 \\<turnstile> ?msg \\<mapsto> cfg' \\<and>\n                       qReachable ?cfg2.0 ?Q cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>cfg''.\n       cfg' \\<turnstile> msg \\<mapsto> cfg'' \\<and> qReachable cfg2 Q cfg''", "by simp"], ["proof (state)\nthis:\n  \\<exists>cfg''.\n     cfg' \\<turnstile> msg \\<mapsto> cfg'' \\<and> qReachable cfg2 Q cfg''\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "then"], ["proof (chain)\npicking this:\n  \\<exists>cfg''.\n     cfg' \\<turnstile> msg \\<mapsto> cfg'' \\<and> qReachable cfg2 Q cfg''", "obtain cfg'' where\n      Cfg'': \"cfg' \\<turnstile> msg \\<mapsto> cfg''\" \"qReachable cfg2 Q cfg''\""], ["proof (prove)\nusing this:\n  \\<exists>cfg''.\n     cfg' \\<turnstile> msg \\<mapsto> cfg'' \\<and> qReachable cfg2 Q cfg''\n\ngoal (1 subgoal):\n 1. (\\<And>cfg''.\n        \\<lbrakk>cfg' \\<turnstile> msg \\<mapsto> cfg'';\n         qReachable cfg2 Q cfg''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cfg' \\<turnstile> msg \\<mapsto> cfg''\n  qReachable cfg2 Q cfg''\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "from Cfg' Cfg''(1) Ass2(2)"], ["proof (chain)\npicking this:\n  qReachable cfg1 (Proc - Q) cfg'\n  cfg' \\<turnstile> msg \\<mapsto> cfg''\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg", "have \"qReachable cfg1 (UNIV - Q) cfg''\""], ["proof (prove)\nusing this:\n  qReachable cfg1 (Proc - Q) cfg'\n  cfg' \\<turnstile> msg \\<mapsto> cfg''\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. qReachable cfg1 (Proc - Q) cfg''", "using qReachable.simps[of cfg1 \"UNIV-Q\" cfg'']"], ["proof (prove)\nusing this:\n  qReachable cfg1 (Proc - Q) cfg'\n  cfg' \\<turnstile> msg \\<mapsto> cfg''\n  \\<exists>p\\<in>Proc - Q. isReceiverOf p msg\n  qReachable cfg1 (Proc - Q) cfg'' =\n  ((\\<exists>cfg1a Qa.\n       cfg1 = cfg1a \\<and> Proc - Q = Qa \\<and> cfg'' = cfg1a) \\<or>\n   (\\<exists>cfg1a Qa cfg2 msg cfg3.\n       cfg1 = cfg1a \\<and>\n       Proc - Q = Qa \\<and>\n       cfg'' = cfg3 \\<and>\n       qReachable cfg1a Qa cfg2 \\<and>\n       cfg2 \\<turnstile> msg \\<mapsto> cfg3 \\<and>\n       (\\<exists>p\\<in>Qa. isReceiverOf p msg)))\n\ngoal (1 subgoal):\n 1. qReachable cfg1 (Proc - Q) cfg''", "by auto"], ["proof (state)\nthis:\n  qReachable cfg1 (Proc - Q) cfg''\n\ngoal (1 subgoal):\n 1. \\<And>cfg1a cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1a (Proc - Q) cfg2;\n        qReachable cfg1a Q cfg1 \\<Longrightarrow>\n        \\<exists>cfg'.\n           qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg';\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Proc - Q. isReceiverOf p msg;\n        qReachable cfg1a Q cfg1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg'.\n                            qReachable cfg1 (Proc - Q) cfg' \\<and>\n                            qReachable cfg3 Q cfg'", "with Cfg''"], ["proof (chain)\npicking this:\n  cfg' \\<turnstile> msg \\<mapsto> cfg''\n  qReachable cfg2 Q cfg''\n  qReachable cfg1 (Proc - Q) cfg''", "show \n      \"\\<exists>cfg'. qReachable cfg1 (UNIV - Q) cfg' \n        \\<and> qReachable cfg2 Q cfg'\""], ["proof (prove)\nusing this:\n  cfg' \\<turnstile> msg \\<mapsto> cfg''\n  qReachable cfg2 Q cfg''\n  qReachable cfg1 (Proc - Q) cfg''\n\ngoal (1 subgoal):\n 1. \\<exists>cfg'.\n       qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cfg'.\n     qReachable cfg1 (Proc - Q) cfg' \\<and> qReachable cfg2 Q cfg'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Invariant finite message count\\<close>"], ["", "lemma FiniteMessages:\nfixes \n  cfg  :: \"('p, 'v, 's) configuration\"\nassumes\n  FiniteProcs: \"finite Proc\" and\n  FiniteSends: \"\\<And> p s m. finite {v. v \\<in># (sends p s m)}\" and\n  InitReachable: \"initReachable cfg\"\nshows \"finite {msg . msg \\<in># msgs cfg}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "proof(-)"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "have \"\\<exists> init . initial init \\<and> reachable init cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>init. initial init \\<and> reachable init cfg", "using assms"], ["proof (prove)\nusing this:\n  finite Proc\n  finite {v. v \\<in># sends ?p ?s ?m}\n  initReachable cfg\n\ngoal (1 subgoal):\n 1. \\<exists>init. initial init \\<and> reachable init cfg", "unfolding initReachable_def"], ["proof (prove)\nusing this:\n  finite Proc\n  finite {v. v \\<in># sends ?p ?s ?m}\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 cfg\n\ngoal (1 subgoal):\n 1. \\<exists>init. initial init \\<and> reachable init cfg", "by simp"], ["proof (state)\nthis:\n  \\<exists>init. initial init \\<and> reachable init cfg\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "then"], ["proof (chain)\npicking this:\n  \\<exists>init. initial init \\<and> reachable init cfg", "obtain init where Init: \"initial init\" \"reachable init cfg\""], ["proof (prove)\nusing this:\n  \\<exists>init. initial init \\<and> reachable init cfg\n\ngoal (1 subgoal):\n 1. (\\<And>init.\n        \\<lbrakk>initial init; reachable init cfg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  initial init\n  reachable init cfg\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "have InitMsgs:\"{msg . msg \\<in># msgs init} \n    = { msg . (msg \\<in># msgs init) \\<and> (\\<exists> p v. <p, v> = msg)} \n      \\<union> { msg . (msg \\<in># msgs init) \\<and> (\\<exists> v.  <\\<bottom>, outM v> = msg)}\n      \\<union> { msg . (msg \\<in># msgs init) \\<and> (\\<exists> p v.  <p, inM v> = msg)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {msg. msg \\<in># msgs init} =\n    {msg. msg \\<in># msgs init \\<and> (\\<exists>p v. <p, v> = msg)} \\<union>\n    {msg.\n     msg \\<in># msgs init \\<and>\n     (\\<exists>v. <\\<bottom>, outM v> = msg)} \\<union>\n    {msg. msg \\<in># msgs init \\<and> (\\<exists>p v. <p, inM v> = msg)}", "by (auto,metis message.exhaust)"], ["proof (state)\nthis:\n  {msg. msg \\<in># msgs init} =\n  {msg. msg \\<in># msgs init \\<and> (\\<exists>p v. <p, v> = msg)} \\<union>\n  {msg.\n   msg \\<in># msgs init \\<and>\n   (\\<exists>v. <\\<bottom>, outM v> = msg)} \\<union>\n  {msg. msg \\<in># msgs init \\<and> (\\<exists>p v. <p, inM v> = msg)}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "have A:\"{ msg . (msg \\<in># msgs init) \\<and> (\\<exists> p v. <p, v> = msg)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {msg. msg \\<in># msgs init \\<and> (\\<exists>p v. <p, v> = msg)} = {}", "using initial_def[of init] Init(1)"], ["proof (prove)\nusing this:\n  initial init \\<equiv>\n  (\\<forall>p. \\<exists>v. msgs init <p, inM v> = 1) \\<and>\n  (\\<forall>p m1 m2.\n      m1 \\<in># msgs init \\<and>\n      m2 \\<in># msgs init \\<and>\n      isReceiverOf p m1 \\<and> isReceiverOf p m2 \\<longrightarrow>\n      m1 = m2) \\<and>\n  (\\<forall>v. msgs init <\\<bottom>, outM v> = 0) \\<and>\n  (\\<forall>p v. msgs init <p, v> = 0) \\<and> states init = start\n  initial init\n\ngoal (1 subgoal):\n 1. {msg. msg \\<in># msgs init \\<and> (\\<exists>p v. <p, v> = msg)} = {}", "by (auto, metis less_not_refl3)"], ["proof (state)\nthis:\n  {msg. msg \\<in># msgs init \\<and> (\\<exists>p v. <p, v> = msg)} = {}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "have B:\"{ msg . (msg \\<in># msgs init) \\<and> (\\<exists> v.  <\\<bottom>, outM v> = msg)} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {msg.\n     msg \\<in># msgs init \\<and> (\\<exists>v. <\\<bottom>, outM v> = msg)} =\n    {}", "using initial_def[of init] Init(1)"], ["proof (prove)\nusing this:\n  initial init \\<equiv>\n  (\\<forall>p. \\<exists>v. msgs init <p, inM v> = 1) \\<and>\n  (\\<forall>p m1 m2.\n      m1 \\<in># msgs init \\<and>\n      m2 \\<in># msgs init \\<and>\n      isReceiverOf p m1 \\<and> isReceiverOf p m2 \\<longrightarrow>\n      m1 = m2) \\<and>\n  (\\<forall>v. msgs init <\\<bottom>, outM v> = 0) \\<and>\n  (\\<forall>p v. msgs init <p, v> = 0) \\<and> states init = start\n  initial init\n\ngoal (1 subgoal):\n 1. {msg.\n     msg \\<in># msgs init \\<and> (\\<exists>v. <\\<bottom>, outM v> = msg)} =\n    {}", "by (auto, metis less_not_refl3)"], ["proof (state)\nthis:\n  {msg.\n   msg \\<in># msgs init \\<and> (\\<exists>v. <\\<bottom>, outM v> = msg)} =\n  {}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "have \"\\<forall> p . finite {<p, inM True>, <p, inM False>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. finite {<p, inM True>, <p, inM False>}", "by auto"], ["proof (state)\nthis:\n  \\<forall>p. finite {<p, inM True>, <p, inM False>}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "moreover"], ["proof (state)\nthis:\n  \\<forall>p. finite {<p, inM True>, <p, inM False>}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "have SubsetMsg:\n    \"\\<forall> p. { msg . (msg \\<in># msgs init) \n      \\<and> (\\<exists> v::bool .  <p, inM v> = msg)} \n      \\<subseteq> {<p, inM True>, <p, inM False>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)}\n       \\<subseteq> {<p, inM True>, <p, inM False>}", "by auto"], ["proof (state)\nthis:\n  \\<forall>p.\n     {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)}\n     \\<subseteq> {<p, inM True>, <p, inM False>}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>p. finite {<p, inM True>, <p, inM False>}\n  \\<forall>p.\n     {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)}\n     \\<subseteq> {<p, inM True>, <p, inM False>}", "have AllFinite:\n    \"\\<forall> p. finite { msg . (msg \\<in># msgs init) \n      \\<and> (\\<exists> v::bool .  <p, inM v> = msg)}\""], ["proof (prove)\nusing this:\n  \\<forall>p. finite {<p, inM True>, <p, inM False>}\n  \\<forall>p.\n     {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)}\n     \\<subseteq> {<p, inM True>, <p, inM False>}\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       finite\n        {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)}", "using finite_subset"], ["proof (prove)\nusing this:\n  \\<forall>p. finite {<p, inM True>, <p, inM False>}\n  \\<forall>p.\n     {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)}\n     \\<subseteq> {<p, inM True>, <p, inM False>}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       finite\n        {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)}", "by (clarify, auto)"], ["proof (state)\nthis:\n  \\<forall>p.\n     finite\n      {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "have \" { msg . (msg \\<in># msgs init) \n    \\<and> (\\<exists> p\\<in>Proc . \\<exists> v::bool.  <p, inM v> = msg)} \n      = (\\<Union> p \\<in> Proc . { msg . (msg \\<in># msgs init) \n    \\<and> (\\<exists> v::bool .  <p, inM v> = msg)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {msg.\n     msg \\<in># msgs init \\<and>\n     (\\<exists>p\\<in>Proc. \\<exists>v. <p, inM v> = msg)} =\n    (\\<Union>p.\n        {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)})", "by auto"], ["proof (state)\nthis:\n  {msg.\n   msg \\<in># msgs init \\<and>\n   (\\<exists>p\\<in>Proc. \\<exists>v. <p, inM v> = msg)} =\n  (\\<Union>p.\n      {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)})\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "hence \"finite  { msg . (msg \\<in># msgs init) \n    \\<and> (\\<exists> p\\<in>Proc . \\<exists> v::bool.  <p, inM v> = msg)}\""], ["proof (prove)\nusing this:\n  {msg.\n   msg \\<in># msgs init \\<and>\n   (\\<exists>p\\<in>Proc. \\<exists>v. <p, inM v> = msg)} =\n  (\\<Union>p.\n      {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)})\n\ngoal (1 subgoal):\n 1. finite\n     {msg.\n      msg \\<in># msgs init \\<and>\n      (\\<exists>p\\<in>Proc. \\<exists>v. <p, inM v> = msg)}", "using AllFinite FiniteProcs"], ["proof (prove)\nusing this:\n  {msg.\n   msg \\<in># msgs init \\<and>\n   (\\<exists>p\\<in>Proc. \\<exists>v. <p, inM v> = msg)} =\n  (\\<Union>p.\n      {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)})\n  \\<forall>p.\n     finite\n      {msg. msg \\<in># msgs init \\<and> (\\<exists>v. <p, inM v> = msg)}\n  finite Proc\n\ngoal (1 subgoal):\n 1. finite\n     {msg.\n      msg \\<in># msgs init \\<and>\n      (\\<exists>p\\<in>Proc. \\<exists>v. <p, inM v> = msg)}", "by auto"], ["proof (state)\nthis:\n  finite\n   {msg.\n    msg \\<in># msgs init \\<and>\n    (\\<exists>p\\<in>Proc. \\<exists>v. <p, inM v> = msg)}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "hence InitFinite:\"finite {msg . msg \\<in># msgs init}\""], ["proof (prove)\nusing this:\n  finite\n   {msg.\n    msg \\<in># msgs init \\<and>\n    (\\<exists>p\\<in>Proc. \\<exists>v. <p, inM v> = msg)}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs init}", "by (auto simp add: A B InitMsgs)"], ["proof (state)\nthis:\n  finite {msg. msg \\<in># msgs init}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "using Init(2) InitFinite"], ["proof (prove)\nusing this:\n  reachable init cfg\n  finite {msg. msg \\<in># msgs init}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg}", "proof(induct rule: reachable.induct, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2; finite {msg. msg \\<in># msgs cfg2};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        finite {msg. msg \\<in># msgs cfg1}; reachable init cfg;\n        finite {msg. msg \\<in># msgs init}\\<rbrakk>\n       \\<Longrightarrow> finite {msg. msg \\<in># msgs cfg3}", "fix cfg1 cfg2 msg cfg3"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2; finite {msg. msg \\<in># msgs cfg2};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        finite {msg. msg \\<in># msgs cfg1}; reachable init cfg;\n        finite {msg. msg \\<in># msgs init}\\<rbrakk>\n       \\<Longrightarrow> finite {msg. msg \\<in># msgs cfg3}", "assume assmsInduct:\"reachable cfg1 cfg2\" \n      \"finite {msg. msg \\<in># msgs cfg2}\" \"cfg2 \\<turnstile> msg \\<mapsto> cfg3\" \n      \"finite {msg. msg \\<in># msgs cfg1}\" \"reachable init cfg\" \n      \"finite {msg. msg \\<in># msgs init}\""], ["proof (state)\nthis:\n  reachable cfg1 cfg2\n  finite {msg. msg \\<in># msgs cfg2}\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  finite {msg. msg \\<in># msgs cfg1}\n  reachable init cfg\n  finite {msg. msg \\<in># msgs init}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2; finite {msg. msg \\<in># msgs cfg2};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        finite {msg. msg \\<in># msgs cfg1}; reachable init cfg;\n        finite {msg. msg \\<in># msgs init}\\<rbrakk>\n       \\<Longrightarrow> finite {msg. msg \\<in># msgs cfg3}", "from assmsInduct(3)"], ["proof (chain)\npicking this:\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3", "obtain p where \"isReceiverOf p msg \""], ["proof (prove)\nusing this:\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n\ngoal (1 subgoal):\n 1. (\\<And>p. isReceiverOf p msg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis StepOutMsg isReceiverOf.simps(1) isReceiverOf.simps(2) \n       message.exhaust)"], ["proof (state)\nthis:\n  isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2; finite {msg. msg \\<in># msgs cfg2};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        finite {msg. msg \\<in># msgs cfg1}; reachable init cfg;\n        finite {msg. msg \\<in># msgs init}\\<rbrakk>\n       \\<Longrightarrow> finite {msg. msg \\<in># msgs cfg3}", "hence \"msgs cfg3 = ((msgs cfg2 -# msg) \\<union># (sends p (states cfg2 p) \n      (unpackMessage msg) ))\""], ["proof (prove)\nusing this:\n  isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. msgs cfg3 =\n    msgs cfg2 -# msg \\<union># sends p (states cfg2 p) (unpackMessage msg)", "using assmsInduct(3)"], ["proof (prove)\nusing this:\n  isReceiverOf p msg\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n\ngoal (1 subgoal):\n 1. msgs cfg3 =\n    msgs cfg2 -# msg \\<union># sends p (states cfg2 p) (unpackMessage msg)", "by (cases msg, auto simp add: add.commute)"], ["proof (state)\nthis:\n  msgs cfg3 =\n  msgs cfg2 -# msg \\<union># sends p (states cfg2 p) (unpackMessage msg)\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2; finite {msg. msg \\<in># msgs cfg2};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        finite {msg. msg \\<in># msgs cfg1}; reachable init cfg;\n        finite {msg. msg \\<in># msgs init}\\<rbrakk>\n       \\<Longrightarrow> finite {msg. msg \\<in># msgs cfg3}", "hence MsgSet: \"{msg. msg \\<in>#  msgs cfg3 } \n      = {m. m \\<in># ((msgs cfg2 -# msg) \\<union># (sends p (states cfg2 p) \n        (unpackMessage msg) )) } \""], ["proof (prove)\nusing this:\n  msgs cfg3 =\n  msgs cfg2 -# msg \\<union># sends p (states cfg2 p) (unpackMessage msg)\n\ngoal (1 subgoal):\n 1. {msg. msg \\<in># msgs cfg3} =\n    {m. sends p (states cfg2 p) (unpackMessage msg)\n         m \\<in># (+) ((msgs cfg2 -# msg) m)}", "by simp"], ["proof (state)\nthis:\n  {msg. msg \\<in># msgs cfg3} =\n  {m. sends p (states cfg2 p) (unpackMessage msg)\n       m \\<in># (+) ((msgs cfg2 -# msg) m)}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2; finite {msg. msg \\<in># msgs cfg2};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        finite {msg. msg \\<in># msgs cfg1}; reachable init cfg;\n        finite {msg. msg \\<in># msgs init}\\<rbrakk>\n       \\<Longrightarrow> finite {msg. msg \\<in># msgs cfg3}", "have \"{v. v \\<in># (msgs cfg2 -# msg)} \\<subseteq> {msg. msg \\<in># msgs cfg2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}\n    \\<subseteq> {msg. msg \\<in># msgs cfg2}", "by auto"], ["proof (state)\nthis:\n  {v. msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}\n  \\<subseteq> {msg. msg \\<in># msgs cfg2}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2; finite {msg. msg \\<in># msgs cfg2};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        finite {msg. msg \\<in># msgs cfg1}; reachable init cfg;\n        finite {msg. msg \\<in># msgs init}\\<rbrakk>\n       \\<Longrightarrow> finite {msg. msg \\<in># msgs cfg3}", "from finite_subset[OF this]"], ["proof (chain)\npicking this:\n  finite {msg. msg \\<in># msgs cfg2} \\<Longrightarrow>\n  finite {v. msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}", "have \"finite {v. (v \\<in># sends p (states cfg2 p) (unpackMessage msg))\n        \\<or> (v \\<in># (msgs cfg2 -# msg))}\""], ["proof (prove)\nusing this:\n  finite {msg. msg \\<in># msgs cfg2} \\<Longrightarrow>\n  finite {v. msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}\n\ngoal (1 subgoal):\n 1. finite\n     {v. v \\<in># sends p (states cfg2 p) (unpackMessage msg) \\<or>\n         msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}", "using FiniteSends assmsInduct(2)"], ["proof (prove)\nusing this:\n  finite {msg. msg \\<in># msgs cfg2} \\<Longrightarrow>\n  finite {v. msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}\n  finite {v. v \\<in># sends ?p ?s ?m}\n  finite {msg. msg \\<in># msgs cfg2}\n\ngoal (1 subgoal):\n 1. finite\n     {v. v \\<in># sends p (states cfg2 p) (unpackMessage msg) \\<or>\n         msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}", "by auto"], ["proof (state)\nthis:\n  finite\n   {v. v \\<in># sends p (states cfg2 p) (unpackMessage msg) \\<or>\n       msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2; finite {msg. msg \\<in># msgs cfg2};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        finite {msg. msg \\<in># msgs cfg1}; reachable init cfg;\n        finite {msg. msg \\<in># msgs init}\\<rbrakk>\n       \\<Longrightarrow> finite {msg. msg \\<in># msgs cfg3}", "thus \"finite {msg. msg \\<in># msgs cfg3}\""], ["proof (prove)\nusing this:\n  finite\n   {v. v \\<in># sends p (states cfg2 p) (unpackMessage msg) \\<or>\n       msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}\n\ngoal (1 subgoal):\n 1. finite {msg. msg \\<in># msgs cfg3}", "unfolding MsgSet"], ["proof (prove)\nusing this:\n  finite\n   {v. v \\<in># sends p (states cfg2 p) (unpackMessage msg) \\<or>\n       msgs cfg2 v \\<in># If (v = msg) (msgs cfg2 v - 1)}\n\ngoal (1 subgoal):\n 1. finite\n     {m. sends p (states cfg2 p) (unpackMessage msg)\n          m \\<in># (+) ((msgs cfg2 -# msg) m)}", "by auto"], ["proof (state)\nthis:\n  finite {msg. msg \\<in># msgs cfg3}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite {msg. msg \\<in># msgs cfg}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}