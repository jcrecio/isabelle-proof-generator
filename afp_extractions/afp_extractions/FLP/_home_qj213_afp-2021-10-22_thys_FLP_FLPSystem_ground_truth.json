{"file_name": "/home/qj213/afp-2021-10-22/thys/FLP/FLPSystem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FLP", "problem_names": ["lemma DecisionValuesExist:\nfixes\n  c :: \"('p, 'v, 's) configuration\" and\n  p :: \"'p\" \nassumes\n  Termination: \"\\<And>cc Q . terminationPseudo 1 cc Q\" and\n  Reachable: \"initReachable c\"      \nshows\n  \"val[p,c] \\<noteq> {}\"", "lemma DecidedImpliesUniform:\nfixes\n  c :: \"('p, 'v, 's) configuration\" and\n  v :: \"bool\"\nassumes\n  AllAgree: \"\\<forall> cfg . reachable c cfg \\<longrightarrow> agreement cfg\" and\n  Termination: \"\\<And>cc Q . terminationPseudo 1 cc Q\" and\n  VDec: \"vDecided v c\"\nshows\n  \"vUniform v c\"", "lemma InactiveProcessSilentDecisionValuesDecrease:\nfixes \n  p q :: 'p and\n  c c' :: \"('p, 'v, 's) configuration\" and\n  msg :: \"('p, 'v) message\"\nassumes \n  \"p \\<noteq> q\" and\n  \"c \\<turnstile> msg \\<mapsto> c'\" and\n  \"isReceiverOf p msg\" and\n  \"initReachable c\"\nshows \n  \"val[q,c'] \\<subseteq> val[q,c]\"", "lemma ActiveProcessSilentDecisionValuesIncrease :\nfixes \n  p q :: 'p and\n  c c' :: \"('p, 'v, 's) configuration\" and\n  msg :: \"('p, 'v) message\"\nassumes \n  \"p = q\" and\n  \"c \\<turnstile> msg \\<mapsto> c'\" and\n  \"isReceiverOf p msg\" and\n  \"initReachable c\"\nshows \"val[q,c] \\<subseteq> val[q,c']\"", "lemma SilentDecisionValueNotInverting:\nfixes \n  p q :: 'p and\n  c c' :: \"('p, 'v, 's) configuration\" and\n  msg :: \"('p, 'v) message\" and\n  v :: bool\nassumes \n  Val: \"val[q,c] = {v}\" and\n  Step:  \"c \\<turnstile> msg \\<mapsto> c'\" and\n  Rec:  \"isReceiverOf p msg\" and\n  Init: \"initReachable c\"\nshows \n  \"val[q,c'] \\<noteq> {\\<not> v}\"", "lemma InitialNonUniformCfg:\nassumes\n  Termination: \"\\<And>cc Q . terminationPseudo 1 cc Q\" and\n  Validity: \"\\<forall> i c . validity i c\" and\n  Agreement: \"\\<forall> i c . agreementInit i c\"\nshows \n  \"\\<exists> cfg . initial cfg \\<and> nonUniform cfg\"", "lemma NonUniformCanReachSilentBivalence:\nfixes \n  p:: 'p and\n  c:: \"('p, 'v, 's) configuration\"\nassumes \n  NonUni: \"nonUniform c\" and\n  PseudoTermination: \"\\<And>cc Q . terminationPseudo 1 cc Q\" and\n  Agree: \"\\<And> cfg . reachable c cfg \\<longrightarrow> agreement cfg\"\nshows \n   \"\\<exists> c' . reachable c c' \\<and> val[p,c'] = {True, False}\""], "translations": [["", "lemma DecisionValuesExist:\nfixes\n  c :: \"('p, 'v, 's) configuration\" and\n  p :: \"'p\" \nassumes\n  Termination: \"\\<And>cc Q . terminationPseudo 1 cc Q\" and\n  Reachable: \"initReachable c\"      \nshows\n  \"val[p,c] \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {}", "from Termination"], ["proof (chain)\npicking this:\n  terminationPseudo 1 ?cc ?Q", "have \"(initReachable c \\<and> card Proc \\<le> card (UNIV - {p}) + 1) \n      \\<longrightarrow> (\\<exists>c'. qReachable c (UNIV-{p}) c' \\<and> initReachable c' \n      \\<and> (\\<exists>v. 0 < msgs c' <\\<bottom>, outM v>))\""], ["proof (prove)\nusing this:\n  terminationPseudo 1 ?cc ?Q\n\ngoal (1 subgoal):\n 1. initReachable c \\<and>\n    card Proc \\<le> card (Proc - {p}) + 1 \\<longrightarrow>\n    (\\<exists>c'.\n        qReachable c (Proc - {p}) c' \\<and>\n        initReachable c' \\<and>\n        (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c'))", "unfolding terminationPseudo_def"], ["proof (prove)\nusing this:\n  initReachable ?cc \\<and> card Proc \\<le> card ?Q + 1 \\<longrightarrow>\n  (\\<exists>c'.\n      qReachable ?cc ?Q c' \\<and>\n      (\\<exists>v.\n          initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'))\n\ngoal (1 subgoal):\n 1. initReachable c \\<and>\n    card Proc \\<le> card (Proc - {p}) + 1 \\<longrightarrow>\n    (\\<exists>c'.\n        qReachable c (Proc - {p}) c' \\<and>\n        initReachable c' \\<and>\n        (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c'))", "by simp"], ["proof (state)\nthis:\n  initReachable c \\<and>\n  card Proc \\<le> card (Proc - {p}) + 1 \\<longrightarrow>\n  (\\<exists>c'.\n      qReachable c (Proc - {p}) c' \\<and>\n      initReachable c' \\<and>\n      (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c'))\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {}", "with Reachable minimalProcs finiteProcs"], ["proof (chain)\npicking this:\n  initReachable c\n  2 \\<le> card Proc\n  finite Proc\n  initReachable c \\<and>\n  card Proc \\<le> card (Proc - {p}) + 1 \\<longrightarrow>\n  (\\<exists>c'.\n      qReachable c (Proc - {p}) c' \\<and>\n      initReachable c' \\<and>\n      (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c'))", "have \"\\<exists>c'. qReachable c (UNIV - {p}) c' \\<and> initReachable c' \n    \\<and> (\\<exists>v. 0 < msgs c' <\\<bottom>, outM v>)\""], ["proof (prove)\nusing this:\n  initReachable c\n  2 \\<le> card Proc\n  finite Proc\n  initReachable c \\<and>\n  card Proc \\<le> card (Proc - {p}) + 1 \\<longrightarrow>\n  (\\<exists>c'.\n      qReachable c (Proc - {p}) c' \\<and>\n      initReachable c' \\<and>\n      (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c'))\n\ngoal (1 subgoal):\n 1. \\<exists>c'.\n       qReachable c (Proc - {p}) c' \\<and>\n       initReachable c' \\<and>\n       (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c')", "unfolding terminationPseudo_def initReachable_def"], ["proof (prove)\nusing this:\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 c\n  2 \\<le> card Proc\n  finite Proc\n  (\\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 c) \\<and>\n  card Proc \\<le> card (Proc - {p}) + 1 \\<longrightarrow>\n  (\\<exists>c'.\n      qReachable c (Proc - {p}) c' \\<and>\n      (\\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 c') \\<and>\n      (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c'))\n\ngoal (1 subgoal):\n 1. \\<exists>c'.\n       qReachable c (Proc - {p}) c' \\<and>\n       (\\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 c') \\<and>\n       (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c')", "by simp"], ["proof (state)\nthis:\n  \\<exists>c'.\n     qReachable c (Proc - {p}) c' \\<and>\n     initReachable c' \\<and>\n     (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c')\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>c'.\n     qReachable c (Proc - {p}) c' \\<and>\n     initReachable c' \\<and>\n     (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c')\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {}", "unfolding pSilDecVal_def"], ["proof (prove)\nusing this:\n  \\<exists>c'.\n     qReachable c (Proc - {p}) c' \\<and>\n     initReachable c' \\<and>\n     (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c')\n\ngoal (1 subgoal):\n 1. {v. initReachable c \\<and>\n        (\\<exists>c'.\n            qReachable c (Proc - {p}) c' \\<and>\n            initReachable c' \\<and>\n            <\\<bottom>, outM v> \\<in># msgs c')} \\<noteq>\n    {}", "using Reachable"], ["proof (prove)\nusing this:\n  \\<exists>c'.\n     qReachable c (Proc - {p}) c' \\<and>\n     initReachable c' \\<and>\n     (\\<exists>v. <\\<bottom>, outM v> \\<in># msgs c')\n  initReachable c\n\ngoal (1 subgoal):\n 1. {v. initReachable c \\<and>\n        (\\<exists>c'.\n            qReachable c (Proc - {p}) c' \\<and>\n            initReachable c' \\<and>\n            <\\<bottom>, outM v> \\<in># msgs c')} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  val[p,c] \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n  The lemma \\isb{DecidedImpliesUniform} proves that every \\isb{vDecided}\n  configuration \\var{c} is also \\isb{vUniform}. V?lzer claims that this\n  follows directly from the definitions of \\isb{vDecided} and \\isb{vUniform}.\n  But this is not quite enough: One must also assume \\isb{terminationPseudo}\n  and \\isb{agreement} for all reachable configurations.\n\n  \\voelzer{Proposition 2(b)}\n\\<close>"], ["", "lemma DecidedImpliesUniform:\nfixes\n  c :: \"('p, 'v, 's) configuration\" and\n  v :: \"bool\"\nassumes\n  AllAgree: \"\\<forall> cfg . reachable c cfg \\<longrightarrow> agreement cfg\" and\n  Termination: \"\\<And>cc Q . terminationPseudo 1 cc Q\" and\n  VDec: \"vDecided v c\"\nshows\n  \"vUniform v c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vUniform v c", "using AllAgree VDec"], ["proof (prove)\nusing this:\n  \\<forall>cfg. reachable c cfg \\<longrightarrow> agreement cfg\n  initReachable c \\<and> <\\<bottom>, outM v> \\<in># msgs c\n\ngoal (1 subgoal):\n 1. vUniform v c", "unfolding agreement_def vUniform_def pSilDecVal_def"], ["proof (prove)\nusing this:\n  \\<forall>cfg.\n     reachable c cfg \\<longrightarrow>\n     (\\<forall>v1.\n         <\\<bottom>, outM v1> \\<in># msgs cfg \\<longrightarrow>\n         (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs cfg = (v2 = v1)))\n  initReachable c \\<and> <\\<bottom>, outM v> \\<in># msgs c\n\ngoal (1 subgoal):\n 1. initReachable c \\<and>\n    (\\<forall>p.\n        {v. initReachable c \\<and>\n            (\\<exists>c'.\n                qReachable c (Proc - {p}) c' \\<and>\n                initReachable c' \\<and>\n                <\\<bottom>, outM v> \\<in># msgs c')} =\n        {v})", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>cfg.\n                reachable c cfg \\<longrightarrow>\n                (\\<forall>v1.\n                    <\\<bottom>, outM v1> \\<in># msgs cfg \\<longrightarrow>\n                    (\\<forall>v2.\n                        <\\<bottom>, outM v2> \\<in># msgs cfg = (v2 = v1)));\n     initReachable c \\<and> <\\<bottom>, outM v> \\<in># msgs c\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         {v. \\<exists>c'.\n                                qReachable c (Proc - {p}) c' \\<and>\n                                initReachable c' \\<and>\n                                <\\<bottom>, outM v> \\<in># msgs c'} =\n                         {v}", "assume \n    Agree: \"\\<forall>cfg. reachable c cfg \\<longrightarrow>\n      (\\<forall>v1. 0 < msgs cfg <\\<bottom>, outM v1> \n      \\<longrightarrow> (\\<forall>v2. (0 < msgs cfg <\\<bottom>, outM v2>) = (v2 = v1)))\" and \n    vDec: \"initReachable c \\<and> 0 < msgs c <\\<bottom>, outM v>\""], ["proof (state)\nthis:\n  \\<forall>cfg.\n     reachable c cfg \\<longrightarrow>\n     (\\<forall>v1.\n         <\\<bottom>, outM v1> \\<in># msgs cfg \\<longrightarrow>\n         (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs cfg = (v2 = v1)))\n  initReachable c \\<and> <\\<bottom>, outM v> \\<in># msgs c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>cfg.\n                reachable c cfg \\<longrightarrow>\n                (\\<forall>v1.\n                    <\\<bottom>, outM v1> \\<in># msgs cfg \\<longrightarrow>\n                    (\\<forall>v2.\n                        <\\<bottom>, outM v2> \\<in># msgs cfg = (v2 = v1)));\n     initReachable c \\<and> <\\<bottom>, outM v> \\<in># msgs c\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         {v. \\<exists>c'.\n                                qReachable c (Proc - {p}) c' \\<and>\n                                initReachable c' \\<and>\n                                <\\<bottom>, outM v> \\<in># msgs c'} =\n                         {v}", "show \n    \"(\\<forall>p. {v. \\<exists>c'. qReachable c (Proc - {p}) c' \\<and> initReachable c' \\<and> \n      0 < msgs c' <\\<bottom>, outM v>} = {v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       {v. \\<exists>c'.\n              qReachable c (Proc - {p}) c' \\<and>\n              initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n       {v}", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       {v. \\<exists>c'.\n              qReachable c (Proc - {p}) c' \\<and>\n              initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n       {v}", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       {v. \\<exists>c'.\n              qReachable c (Proc - {p}) c' \\<and>\n              initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n       {v}", "have \"val[p,c] \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {}", "using Termination DecisionValuesExist vDec"], ["proof (prove)\nusing this:\n  terminationPseudo 1 ?cc ?Q\n  \\<lbrakk>\\<And>cc Q. terminationPseudo 1 cc Q; initReachable ?c\\<rbrakk>\n  \\<Longrightarrow> val[?p,?c] \\<noteq> {}\n  initReachable c \\<and> <\\<bottom>, outM v> \\<in># msgs c\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  val[p,c] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       {v. \\<exists>c'.\n              qReachable c (Proc - {p}) c' \\<and>\n              initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n       {v}", "hence NotEmpty: \"{v. \\<exists>c'. qReachable c (UNIV - {p}) c' \n      \\<and> initReachable c' \\<and> 0 < msgs c' <\\<bottom>, outM v>} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  val[p,c] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {v. \\<exists>c'.\n           qReachable c (Proc - {p}) c' \\<and>\n           initReachable c' \\<and>\n           <\\<bottom>, outM v> \\<in># msgs c'} \\<noteq>\n    {}", "using pSilDecVal_def"], ["proof (prove)\nusing this:\n  val[p,c] \\<noteq> {}\n  pSilDecVal ?v ?p ?c \\<equiv>\n  initReachable ?c \\<and>\n  (\\<exists>c'.\n      qReachable ?c (Proc - {?p}) c' \\<and>\n      initReachable c' \\<and> <\\<bottom>, outM ?v> \\<in># msgs c')\n\ngoal (1 subgoal):\n 1. {v. \\<exists>c'.\n           qReachable c (Proc - {p}) c' \\<and>\n           initReachable c' \\<and>\n           <\\<bottom>, outM v> \\<in># msgs c'} \\<noteq>\n    {}", "by simp"], ["proof (state)\nthis:\n  {v. \\<exists>c'.\n         qReachable c (Proc - {p}) c' \\<and>\n         initReachable c' \\<and>\n         <\\<bottom>, outM v> \\<in># msgs c'} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       {v. \\<exists>c'.\n              qReachable c (Proc - {p}) c' \\<and>\n              initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n       {v}", "have U: \"\\<forall> u . u \\<in> {v. \\<exists>c'. qReachable c (UNIV - {p}) c' \n      \\<and> initReachable c' \\<and> 0 < msgs c' <\\<bottom>, outM v>} \\<longrightarrow> (u = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       u \\<in> {v. \\<exists>c'.\n                      qReachable c (Proc - {p}) c' \\<and>\n                      initReachable c' \\<and>\n                      <\\<bottom>, outM v> \\<in># msgs c'} \\<longrightarrow>\n       u = v", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u c'.\n       \\<lbrakk>qReachable c (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM u> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> u = v", "fix u c'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u c'.\n       \\<lbrakk>qReachable c (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM u> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> u = v", "assume \"qReachable c (UNIV - {p}) c'\" \"initReachable c'\""], ["proof (state)\nthis:\n  qReachable c (Proc - {p}) c'\n  initReachable c'\n\ngoal (1 subgoal):\n 1. \\<And>u c'.\n       \\<lbrakk>qReachable c (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM u> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> u = v", "hence Reach: \"reachable c c'\""], ["proof (prove)\nusing this:\n  qReachable c (Proc - {p}) c'\n  initReachable c'\n\ngoal (1 subgoal):\n 1. reachable c c'", "using QReachImplReach"], ["proof (prove)\nusing this:\n  qReachable c (Proc - {p}) c'\n  initReachable c'\n  qReachable ?cfg1.0 ?Q ?cfg2.0 \\<Longrightarrow> reachable ?cfg1.0 ?cfg2.0\n\ngoal (1 subgoal):\n 1. reachable c c'", "by simp"], ["proof (state)\nthis:\n  reachable c c'\n\ngoal (1 subgoal):\n 1. \\<And>u c'.\n       \\<lbrakk>qReachable c (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM u> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> u = v", "from VDec"], ["proof (chain)\npicking this:\n  initReachable c \\<and> <\\<bottom>, outM v> \\<in># msgs c", "have Msg: \"0 < msgs c <\\<bottom>, outM v>\""], ["proof (prove)\nusing this:\n  initReachable c \\<and> <\\<bottom>, outM v> \\<in># msgs c\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM v> \\<in># msgs c", "by simp"], ["proof (state)\nthis:\n  <\\<bottom>, outM v> \\<in># msgs c\n\ngoal (1 subgoal):\n 1. \\<And>u c'.\n       \\<lbrakk>qReachable c (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM u> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> u = v", "from Reach NoOutMessageLoss"], ["proof (chain)\npicking this:\n  reachable c c'\n  reachable ?cfg1.0 ?cfg2.0 \\<Longrightarrow>\n  msgs ?cfg1.0 <\\<bottom>, outM ?v> \\<le> msgs ?cfg2.0 <\\<bottom>, outM ?v>", "have \n        \"msgs c <\\<bottom>, outM v> \\<le> msgs c' <\\<bottom>, outM v>\""], ["proof (prove)\nusing this:\n  reachable c c'\n  reachable ?cfg1.0 ?cfg2.0 \\<Longrightarrow>\n  msgs ?cfg1.0 <\\<bottom>, outM ?v> \\<le> msgs ?cfg2.0 <\\<bottom>, outM ?v>\n\ngoal (1 subgoal):\n 1. msgs c <\\<bottom>, outM v> \\<le> msgs c' <\\<bottom>, outM v>", "by simp"], ["proof (state)\nthis:\n  msgs c <\\<bottom>, outM v> \\<le> msgs c' <\\<bottom>, outM v>\n\ngoal (1 subgoal):\n 1. \\<And>u c'.\n       \\<lbrakk>qReachable c (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM u> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> u = v", "with Msg"], ["proof (chain)\npicking this:\n  <\\<bottom>, outM v> \\<in># msgs c\n  msgs c <\\<bottom>, outM v> \\<le> msgs c' <\\<bottom>, outM v>", "have VMsg: \"0 < msgs c' <\\<bottom>, outM v>\""], ["proof (prove)\nusing this:\n  <\\<bottom>, outM v> \\<in># msgs c\n  msgs c <\\<bottom>, outM v> \\<le> msgs c' <\\<bottom>, outM v>\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM v> \\<in># msgs c'", "using NoOutMessageLoss Reach"], ["proof (prove)\nusing this:\n  <\\<bottom>, outM v> \\<in># msgs c\n  msgs c <\\<bottom>, outM v> \\<le> msgs c' <\\<bottom>, outM v>\n  reachable ?cfg1.0 ?cfg2.0 \\<Longrightarrow>\n  msgs ?cfg1.0 <\\<bottom>, outM ?v> \\<le> msgs ?cfg2.0 <\\<bottom>, outM ?v>\n  reachable c c'\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM v> \\<in># msgs c'", "by (metis less_le_trans)"], ["proof (state)\nthis:\n  <\\<bottom>, outM v> \\<in># msgs c'\n\ngoal (1 subgoal):\n 1. \\<And>u c'.\n       \\<lbrakk>qReachable c (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM u> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> u = v", "assume \"0 < msgs c' <\\<bottom>, outM u>\""], ["proof (state)\nthis:\n  <\\<bottom>, outM u> \\<in># msgs c'\n\ngoal (1 subgoal):\n 1. \\<And>u c'.\n       \\<lbrakk>qReachable c (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM u> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> u = v", "with Agree VMsg Reach"], ["proof (chain)\npicking this:\n  \\<forall>cfg.\n     reachable c cfg \\<longrightarrow>\n     (\\<forall>v1.\n         <\\<bottom>, outM v1> \\<in># msgs cfg \\<longrightarrow>\n         (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs cfg = (v2 = v1)))\n  <\\<bottom>, outM v> \\<in># msgs c'\n  reachable c c'\n  <\\<bottom>, outM u> \\<in># msgs c'", "show \"u = v\""], ["proof (prove)\nusing this:\n  \\<forall>cfg.\n     reachable c cfg \\<longrightarrow>\n     (\\<forall>v1.\n         <\\<bottom>, outM v1> \\<in># msgs cfg \\<longrightarrow>\n         (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs cfg = (v2 = v1)))\n  <\\<bottom>, outM v> \\<in># msgs c'\n  reachable c c'\n  <\\<bottom>, outM u> \\<in># msgs c'\n\ngoal (1 subgoal):\n 1. u = v", "by simp"], ["proof (state)\nthis:\n  u = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u.\n     u \\<in> {v. \\<exists>c'.\n                    qReachable c (Proc - {p}) c' \\<and>\n                    initReachable c' \\<and>\n                    <\\<bottom>, outM v> \\<in># msgs c'} \\<longrightarrow>\n     u = v\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       {v. \\<exists>c'.\n              qReachable c (Proc - {p}) c' \\<and>\n              initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n       {v}", "thus \" {v. \\<exists>c'. qReachable c (UNIV - {p}) c' \\<and> initReachable c' \\<and> \n      0 < msgs c' <\\<bottom>, outM v>} = {v}\""], ["proof (prove)\nusing this:\n  \\<forall>u.\n     u \\<in> {v. \\<exists>c'.\n                    qReachable c (Proc - {p}) c' \\<and>\n                    initReachable c' \\<and>\n                    <\\<bottom>, outM v> \\<in># msgs c'} \\<longrightarrow>\n     u = v\n\ngoal (1 subgoal):\n 1. {v. \\<exists>c'.\n           qReachable c (Proc - {p}) c' \\<and>\n           initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n    {v}", "using NotEmpty U"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     u \\<in> {v. \\<exists>c'.\n                    qReachable c (Proc - {p}) c' \\<and>\n                    initReachable c' \\<and>\n                    <\\<bottom>, outM v> \\<in># msgs c'} \\<longrightarrow>\n     u = v\n  {v. \\<exists>c'.\n         qReachable c (Proc - {p}) c' \\<and>\n         initReachable c' \\<and>\n         <\\<bottom>, outM v> \\<in># msgs c'} \\<noteq>\n  {}\n  \\<forall>u.\n     u \\<in> {v. \\<exists>c'.\n                    qReachable c (Proc - {p}) c' \\<and>\n                    initReachable c' \\<and>\n                    <\\<bottom>, outM v> \\<in># msgs c'} \\<longrightarrow>\n     u = v\n\ngoal (1 subgoal):\n 1. {v. \\<exists>c'.\n           qReachable c (Proc - {p}) c' \\<and>\n           initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n    {v}", "by auto"], ["proof (state)\nthis:\n  {v. \\<exists>c'.\n         qReachable c (Proc - {p}) c' \\<and>\n         initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n  {v}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p.\n     {v. \\<exists>c'.\n            qReachable c (Proc - {p}) c' \\<and>\n            initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'} =\n     {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary NonUniformImpliesNotDecided:\nfixes\n  c :: \"('p, 'v, 's) configuration\" and\n  v :: \"bool\"\nassumes\n  \"\\<forall> cfg . reachable c cfg \\<longrightarrow> agreement cfg\"\n  \"\\<And>cc Q . terminationPseudo 1 cc Q\"\n  \"nonUniform c\"\n  \"vDecided v c\"\nshows\n  \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using DecidedImpliesUniform[OF assms(1,2,4)] assms(3)"], ["proof (prove)\nusing this:\n  vUniform v c\n  nonUniform c\n\ngoal (1 subgoal):\n 1. False", "by (cases v, simp_all)"], ["", "text\\<open>\n  All three parts of V?lzer's Proposition 3 consider a single step from an\n  arbitrary \\isb{initReachable} configuration \\var{c} with a message\n  $\\var{msg}$ to a succeeding configuration \\var{c'}.\n\\<close>"], ["", "text\\<open>\n  The silent decision values of a process which is not active in a step only\n  decrease or stay the same.\n  \n  This follows directly from the definitions and the transitivity of the\n  reachability properties \\isb{reachable} and \\isb{qReachable}.\n\n  \\voelzer{Proposition 3(a)}\n\\<close>"], ["", "lemma InactiveProcessSilentDecisionValuesDecrease:\nfixes \n  p q :: 'p and\n  c c' :: \"('p, 'v, 's) configuration\" and\n  msg :: \"('p, 'v) message\"\nassumes \n  \"p \\<noteq> q\" and\n  \"c \\<turnstile> msg \\<mapsto> c'\" and\n  \"isReceiverOf p msg\" and\n  \"initReachable c\"\nshows \n  \"val[q,c'] \\<subseteq> val[q,c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val[q,c'] \\<subseteq> val[q,c]", "proof(auto simp add: pSilDecVal_def assms(4))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>initReachable c'; qReachable c' (Proc - {q}) c'a;\n        initReachable c'a; <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'.\n                            qReachable c (Proc - {q}) c' \\<and>\n                            initReachable c' \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'", "fix x cfg'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>initReachable c'; qReachable c' (Proc - {q}) c'a;\n        initReachable c'a; <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'.\n                            qReachable c (Proc - {q}) c' \\<and>\n                            initReachable c' \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'", "assume \n    Msg: \"0 < msgs cfg' <\\<bottom>, outM x>\" and \n    Cfg': \"qReachable c' (Proc - {q}) cfg'\""], ["proof (state)\nthis:\n  <\\<bottom>, outM x> \\<in># msgs cfg'\n  qReachable c' (Proc - {q}) cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>initReachable c'; qReachable c' (Proc - {q}) c'a;\n        initReachable c'a; <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'.\n                            qReachable c (Proc - {q}) c' \\<and>\n                            initReachable c' \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'", "have \"initReachable c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initReachable c'", "using assms initReachable_def reachable.simps"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  c \\<turnstile> msg \\<mapsto> c'\n  isReceiverOf p msg\n  initReachable c\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. initReachable c'", "by blast"], ["proof (state)\nthis:\n  initReachable c'\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>initReachable c'; qReachable c' (Proc - {q}) c'a;\n        initReachable c'a; <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'.\n                            qReachable c (Proc - {q}) c' \\<and>\n                            initReachable c' \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'", "hence Init: \"initReachable cfg'\""], ["proof (prove)\nusing this:\n  initReachable c'\n\ngoal (1 subgoal):\n 1. initReachable cfg'", "using Cfg' initReachable_def QReachImplReach[of c' \"(Proc - {q})\" cfg'] \n    ReachableTrans"], ["proof (prove)\nusing this:\n  initReachable c'\n  qReachable c' (Proc - {q}) cfg'\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  qReachable c' (Proc - {q}) cfg' \\<Longrightarrow> reachable c' cfg'\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n\ngoal (1 subgoal):\n 1. initReachable cfg'", "by blast"], ["proof (state)\nthis:\n  initReachable cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>initReachable c'; qReachable c' (Proc - {q}) c'a;\n        initReachable c'a; <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'.\n                            qReachable c (Proc - {q}) c' \\<and>\n                            initReachable c' \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'", "have \"p \\<in> Proc - {q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> Proc - {q}", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  c \\<turnstile> msg \\<mapsto> c'\n  isReceiverOf p msg\n  initReachable c\n\ngoal (1 subgoal):\n 1. p \\<in> Proc - {q}", "by blast"], ["proof (state)\nthis:\n  p \\<in> Proc - {q}\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>initReachable c'; qReachable c' (Proc - {q}) c'a;\n        initReachable c'a; <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'.\n                            qReachable c (Proc - {q}) c' \\<and>\n                            initReachable c' \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'", "hence \"qReachable c (Proc - {q}) c'\""], ["proof (prove)\nusing this:\n  p \\<in> Proc - {q}\n\ngoal (1 subgoal):\n 1. qReachable c (Proc - {q}) c'", "using assms qReachable.simps"], ["proof (prove)\nusing this:\n  p \\<in> Proc - {q}\n  p \\<noteq> q\n  c \\<turnstile> msg \\<mapsto> c'\n  isReceiverOf p msg\n  initReachable c\n  qReachable ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>cfg1 Q.\n       ?a1.0 = cfg1 \\<and> ?a2.0 = Q \\<and> ?a3.0 = cfg1) \\<or>\n   (\\<exists>cfg1 Q cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = Q \\<and>\n       ?a3.0 = cfg3 \\<and>\n       qReachable cfg1 Q cfg2 \\<and>\n       cfg2 \\<turnstile> msg \\<mapsto> cfg3 \\<and>\n       (\\<exists>p\\<in>Q. isReceiverOf p msg)))\n\ngoal (1 subgoal):\n 1. qReachable c (Proc - {q}) c'", "by metis"], ["proof (state)\nthis:\n  qReachable c (Proc - {q}) c'\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>initReachable c'; qReachable c' (Proc - {q}) c'a;\n        initReachable c'a; <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'.\n                            qReachable c (Proc - {q}) c' \\<and>\n                            initReachable c' \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'", "hence \"qReachable c (Proc - {q}) cfg'\""], ["proof (prove)\nusing this:\n  qReachable c (Proc - {q}) c'\n\ngoal (1 subgoal):\n 1. qReachable c (Proc - {q}) cfg'", "using Cfg' QReachableTrans"], ["proof (prove)\nusing this:\n  qReachable c (Proc - {q}) c'\n  qReachable c' (Proc - {q}) cfg'\n  \\<lbrakk>qReachable ?cfg2.0 ?Q ?cfg3.0;\n   qReachable ?cfg1.0 ?Q ?cfg2.0\\<rbrakk>\n  \\<Longrightarrow> qReachable ?cfg1.0 ?Q ?cfg3.0\n\ngoal (1 subgoal):\n 1. qReachable c (Proc - {q}) cfg'", "by blast"], ["proof (state)\nthis:\n  qReachable c (Proc - {q}) cfg'\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>initReachable c'; qReachable c' (Proc - {q}) c'a;\n        initReachable c'a; <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'.\n                            qReachable c (Proc - {q}) c' \\<and>\n                            initReachable c' \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'", "with Msg Init"], ["proof (chain)\npicking this:\n  <\\<bottom>, outM x> \\<in># msgs cfg'\n  initReachable cfg'\n  qReachable c (Proc - {q}) cfg'", "show \n    \"\\<exists>c'a. qReachable c (Proc - {q}) c'a \n      \\<and> initReachable c'a \\<and> \n      0 < msgs c'a <\\<bottom>, outM x>\""], ["proof (prove)\nusing this:\n  <\\<bottom>, outM x> \\<in># msgs cfg'\n  initReachable cfg'\n  qReachable c (Proc - {q}) cfg'\n\ngoal (1 subgoal):\n 1. \\<exists>c'a.\n       qReachable c (Proc - {q}) c'a \\<and>\n       initReachable c'a \\<and> <\\<bottom>, outM x> \\<in># msgs c'a", "by blast"], ["proof (state)\nthis:\n  \\<exists>c'a.\n     qReachable c (Proc - {q}) c'a \\<and>\n     initReachable c'a \\<and> <\\<bottom>, outM x> \\<in># msgs c'a\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n  ...while the silent decision values of the process which is active in\n  a step may only increase or stay the same.\n  \n  This follows as stated in \\cite{Voelzer} from the \\emph{diamond property}\n  for a reachable configuration and a single step, i.e. \\isb{DiamondTwo},\n  and in addition from the fact that output messages cannot get lost, i.e.\n  \\isb{NoOutMessageLoss}.\n\n  \\voelzer{Proposition 3(b)}\n\\<close>"], ["", "lemma ActiveProcessSilentDecisionValuesIncrease :\nfixes \n  p q :: 'p and\n  c c' :: \"('p, 'v, 's) configuration\" and\n  msg :: \"('p, 'v) message\"\nassumes \n  \"p = q\" and\n  \"c \\<turnstile> msg \\<mapsto> c'\" and\n  \"isReceiverOf p msg\" and\n  \"initReachable c\"\nshows \"val[q,c] \\<subseteq> val[q,c']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val[q,c] \\<subseteq> val[q,c']", "proof (auto simp add: pSilDecVal_def assms(4))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> initReachable c'\n 2. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "from assms initReachable_def reachable.simps"], ["proof (chain)\npicking this:\n  p = q\n  c \\<turnstile> msg \\<mapsto> c'\n  isReceiverOf p msg\n  initReachable c\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))", "show \"initReachable c'\""], ["proof (prove)\nusing this:\n  p = q\n  c \\<turnstile> msg \\<mapsto> c'\n  isReceiverOf p msg\n  initReachable c\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. initReachable c'", "by meson"], ["proof (state)\nthis:\n  initReachable c'\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "fix x cv"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "assume Cv: \"qReachable c (Proc - {q}) cv\" \"initReachable cv\" \n    \"0 < msgs cv <\\<bottom>, outM x>\""], ["proof (state)\nthis:\n  qReachable c (Proc - {q}) cv\n  initReachable cv\n  <\\<bottom>, outM x> \\<in># msgs cv\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "have \"\\<exists>c'a. (cv \\<turnstile> msg \\<mapsto> c'a) \\<and> qReachable c' (Proc - {q}) c'a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'a.\n       cv \\<turnstile> msg \\<mapsto> c'a \\<and>\n       qReachable c' (Proc - {q}) c'a", "using DiamondTwo Cv(1) assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>qReachable ?cfg ?Q ?cfg1.0;\n   ?cfg \\<turnstile> ?msg \\<mapsto> ?cfg2.0;\n   \\<exists>p\\<in>Proc - ?Q. isReceiverOf p ?msg\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cfg'.\n                       ?cfg1.0 \\<turnstile> ?msg \\<mapsto> cfg' \\<and>\n                       qReachable ?cfg2.0 ?Q cfg'\n  qReachable c (Proc - {q}) cv\n  p = q\n  c \\<turnstile> msg \\<mapsto> c'\n  isReceiverOf p msg\n  initReachable c\n\ngoal (1 subgoal):\n 1. \\<exists>c'a.\n       cv \\<turnstile> msg \\<mapsto> c'a \\<and>\n       qReachable c' (Proc - {q}) c'a", "by blast"], ["proof (state)\nthis:\n  \\<exists>c'a.\n     cv \\<turnstile> msg \\<mapsto> c'a \\<and> qReachable c' (Proc - {q}) c'a\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "then"], ["proof (chain)\npicking this:\n  \\<exists>c'a.\n     cv \\<turnstile> msg \\<mapsto> c'a \\<and> qReachable c' (Proc - {q}) c'a", "obtain c'' where C'': \"(cv \\<turnstile> msg \\<mapsto> c'')\" \n    \"qReachable c' (Proc - {q}) c''\""], ["proof (prove)\nusing this:\n  \\<exists>c'a.\n     cv \\<turnstile> msg \\<mapsto> c'a \\<and> qReachable c' (Proc - {q}) c'a\n\ngoal (1 subgoal):\n 1. (\\<And>c''.\n        \\<lbrakk>cv \\<turnstile> msg \\<mapsto> c'';\n         qReachable c' (Proc - {q}) c''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cv \\<turnstile> msg \\<mapsto> c''\n  qReachable c' (Proc - {q}) c''\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "with Cv(2) initReachable_def reachable.simps"], ["proof (chain)\npicking this:\n  initReachable cv\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n  cv \\<turnstile> msg \\<mapsto> c''\n  qReachable c' (Proc - {q}) c''", "have Init: \"initReachable c''\""], ["proof (prove)\nusing this:\n  initReachable cv\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n  cv \\<turnstile> msg \\<mapsto> c''\n  qReachable c' (Proc - {q}) c''\n\ngoal (1 subgoal):\n 1. initReachable c''", "by blast"], ["proof (state)\nthis:\n  initReachable c''\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "have \"reachable cv c''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable cv c''", "using C''(1) reachable.intros"], ["proof (prove)\nusing this:\n  cv \\<turnstile> msg \\<mapsto> c''\n  reachable ?cfg1.0 ?cfg1.0\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0;\n   ?cfg2.0 \\<turnstile> ?msg \\<mapsto> ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n\ngoal (1 subgoal):\n 1. reachable cv c''", "by blast"], ["proof (state)\nthis:\n  reachable cv c''\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "hence \"msgs cv <\\<bottom>, outM x> \\<le> msgs c'' <\\<bottom>, outM x>\""], ["proof (prove)\nusing this:\n  reachable cv c''\n\ngoal (1 subgoal):\n 1. msgs cv <\\<bottom>, outM x> \\<le> msgs c'' <\\<bottom>, outM x>", "using NoOutMessageLoss"], ["proof (prove)\nusing this:\n  reachable cv c''\n  reachable ?cfg1.0 ?cfg2.0 \\<Longrightarrow>\n  msgs ?cfg1.0 <\\<bottom>, outM ?v> \\<le> msgs ?cfg2.0 <\\<bottom>, outM ?v>\n\ngoal (1 subgoal):\n 1. msgs cv <\\<bottom>, outM x> \\<le> msgs c'' <\\<bottom>, outM x>", "by simp"], ["proof (state)\nthis:\n  msgs cv <\\<bottom>, outM x> \\<le> msgs c'' <\\<bottom>, outM x>\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "hence \"0 < msgs c'' <\\<bottom>, outM x>\""], ["proof (prove)\nusing this:\n  msgs cv <\\<bottom>, outM x> \\<le> msgs c'' <\\<bottom>, outM x>\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM x> \\<in># msgs c''", "using Cv(3)"], ["proof (prove)\nusing this:\n  msgs cv <\\<bottom>, outM x> \\<le> msgs c'' <\\<bottom>, outM x>\n  <\\<bottom>, outM x> \\<in># msgs cv\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM x> \\<in># msgs c''", "by auto"], ["proof (state)\nthis:\n  <\\<bottom>, outM x> \\<in># msgs c''\n\ngoal (1 subgoal):\n 1. \\<And>x c'a.\n       \\<lbrakk>qReachable c (Proc - {q}) c'a; initReachable c'a;\n        <\\<bottom>, outM x> \\<in># msgs c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'a.\n                            qReachable c' (Proc - {q}) c'a \\<and>\n                            initReachable c'a \\<and>\n                            <\\<bottom>, outM x> \\<in># msgs c'a", "thus \"\\<exists>c'a. qReachable c' (Proc - {q}) c'a  \n    \\<and> initReachable c'a \\<and> 0 < msgs c'a <\\<bottom>, outM x>\""], ["proof (prove)\nusing this:\n  <\\<bottom>, outM x> \\<in># msgs c''\n\ngoal (1 subgoal):\n 1. \\<exists>c'a.\n       qReachable c' (Proc - {q}) c'a \\<and>\n       initReachable c'a \\<and> <\\<bottom>, outM x> \\<in># msgs c'a", "using C''(2) Init"], ["proof (prove)\nusing this:\n  <\\<bottom>, outM x> \\<in># msgs c''\n  qReachable c' (Proc - {q}) c''\n  initReachable c''\n\ngoal (1 subgoal):\n 1. \\<exists>c'a.\n       qReachable c' (Proc - {q}) c'a \\<and>\n       initReachable c'a \\<and> <\\<bottom>, outM x> \\<in># msgs c'a", "by blast"], ["proof (state)\nthis:\n  \\<exists>c'a.\n     qReachable c' (Proc - {q}) c'a \\<and>\n     initReachable c'a \\<and> <\\<bottom>, outM x> \\<in># msgs c'a\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n  As a result from the previous two propositions, the silent decision values\n  of a process cannot go from {0} to {1} or vice versa in a step.\n\n  This is a slightly more generic version of Proposition 3 (c) from\n  \\cite{Voelzer} since it is proven for both values, while V?lzer is only\n  interested in the situation starting with $\\var{val(q,c) = \\{0\\}}$.\n\n  \\voelzer{Proposition 3(c)}\n\\<close>"], ["", "lemma SilentDecisionValueNotInverting:\nfixes \n  p q :: 'p and\n  c c' :: \"('p, 'v, 's) configuration\" and\n  msg :: \"('p, 'v) message\" and\n  v :: bool\nassumes \n  Val: \"val[q,c] = {v}\" and\n  Step:  \"c \\<turnstile> msg \\<mapsto> c'\" and\n  Rec:  \"isReceiverOf p msg\" and\n  Init: \"initReachable c\"\nshows \n  \"val[q,c'] \\<noteq> {\\<not> v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val[q,c'] \\<noteq> {\\<not> v}", "proof(cases \"p = q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}\n 2. p \\<noteq> q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}", "case False"], ["proof (state)\nthis:\n  p \\<noteq> q\n\ngoal (2 subgoals):\n 1. p = q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}\n 2. p \\<noteq> q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}", "hence \"val[q,c'] \\<subseteq> val[q,c]\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. val[q,c'] \\<subseteq> val[q,c]", "using Step Rec InactiveProcessSilentDecisionValuesDecrease Init"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  c \\<turnstile> msg \\<mapsto> c'\n  isReceiverOf p msg\n  \\<lbrakk>?p \\<noteq> ?q; ?c \\<turnstile> ?msg \\<mapsto> ?c';\n   isReceiverOf ?p ?msg; initReachable ?c\\<rbrakk>\n  \\<Longrightarrow> val[?q,?c'] \\<subseteq> val[?q,?c]\n  initReachable c\n\ngoal (1 subgoal):\n 1. val[q,c'] \\<subseteq> val[q,c]", "by simp"], ["proof (state)\nthis:\n  val[q,c'] \\<subseteq> val[q,c]\n\ngoal (2 subgoals):\n 1. p = q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}\n 2. p \\<noteq> q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}", "with Val"], ["proof (chain)\npicking this:\n  val[q,c] = {v}\n  val[q,c'] \\<subseteq> val[q,c]", "show \"val[q,c'] \\<noteq> {\\<not> v}\""], ["proof (prove)\nusing this:\n  val[q,c] = {v}\n  val[q,c'] \\<subseteq> val[q,c]\n\ngoal (1 subgoal):\n 1. val[q,c'] \\<noteq> {\\<not> v}", "by auto"], ["proof (state)\nthis:\n  val[q,c'] \\<noteq> {\\<not> v}\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}", "case True"], ["proof (state)\nthis:\n  p = q\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}", "hence \"val[q,c] \\<subseteq> val[q,c']\""], ["proof (prove)\nusing this:\n  p = q\n\ngoal (1 subgoal):\n 1. val[q,c] \\<subseteq> val[q,c']", "using Step Rec ActiveProcessSilentDecisionValuesIncrease Init"], ["proof (prove)\nusing this:\n  p = q\n  c \\<turnstile> msg \\<mapsto> c'\n  isReceiverOf p msg\n  \\<lbrakk>?p = ?q; ?c \\<turnstile> ?msg \\<mapsto> ?c';\n   isReceiverOf ?p ?msg; initReachable ?c\\<rbrakk>\n  \\<Longrightarrow> val[?q,?c] \\<subseteq> val[?q,?c']\n  initReachable c\n\ngoal (1 subgoal):\n 1. val[q,c] \\<subseteq> val[q,c']", "by simp"], ["proof (state)\nthis:\n  val[q,c] \\<subseteq> val[q,c']\n\ngoal (1 subgoal):\n 1. p = q \\<Longrightarrow> val[q,c'] \\<noteq> {\\<not> v}", "with Val"], ["proof (chain)\npicking this:\n  val[q,c] = {v}\n  val[q,c] \\<subseteq> val[q,c']", "show \"val[q,c'] \\<noteq> {\\<not> v}\""], ["proof (prove)\nusing this:\n  val[q,c] = {v}\n  val[q,c] \\<subseteq> val[q,c']\n\ngoal (1 subgoal):\n 1. val[q,c'] \\<noteq> {\\<not> v}", "by auto"], ["proof (state)\nthis:\n  val[q,c'] \\<noteq> {\\<not> v}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Towards a proof of FLP\\<close>"], ["", "text\\<open>\n  There is an \\isb{initial} configuration that is \\isb{nonUniform} under\n  the assumption of \\isb{validity}, \\isb{agreement} and \\isb{terminationPseudo}.\n\n  The lemma is used in the proof of the main theorem to construct the\n  \\isb{non\\-Uni\\-form} and \\isb{initial} configuration that leads to the\n  final contradiction.\n\n  \\voelzer{Lemma 1}\n\\<close>"], ["", "lemma InitialNonUniformCfg:\nassumes\n  Termination: \"\\<And>cc Q . terminationPseudo 1 cc Q\" and\n  Validity: \"\\<forall> i c . validity i c\" and\n  Agreement: \"\\<forall> i c . agreementInit i c\"\nshows \n  \"\\<exists> cfg . initial cfg \\<and> nonUniform cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "obtain n::nat where N: \"n = card Proc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. n = card Proc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = card Proc\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence \"\\<exists> procList::('p list). length procList = n \\<and> set procList = Proc \n    \\<and> distinct procList\""], ["proof (prove)\nusing this:\n  n = card Proc\n\ngoal (1 subgoal):\n 1. \\<exists>procList.\n       length procList = n \\<and>\n       set procList = Proc \\<and> distinct procList", "using finiteProcs"], ["proof (prove)\nusing this:\n  n = card Proc\n  finite Proc\n\ngoal (1 subgoal):\n 1. \\<exists>procList.\n       length procList = n \\<and>\n       set procList = Proc \\<and> distinct procList", "by (metis distinct_card finite_distinct_list)"], ["proof (state)\nthis:\n  \\<exists>procList.\n     length procList = n \\<and> set procList = Proc \\<and> distinct procList\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "then"], ["proof (chain)\npicking this:\n  \\<exists>procList.\n     length procList = n \\<and> set procList = Proc \\<and> distinct procList", "obtain procList where \n    ProcList: \"length procList = n\" \"set procList = Proc\" \n      \"distinct procList\""], ["proof (prove)\nusing this:\n  \\<exists>procList.\n     length procList = n \\<and> set procList = Proc \\<and> distinct procList\n\ngoal (1 subgoal):\n 1. (\\<And>procList.\n        \\<lbrakk>length procList = n; set procList = Proc;\n         distinct procList\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length procList = n\n  set procList = Proc\n  distinct procList\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have AllPInProclist: \"\\<forall>p. \\<exists>i<n. procList ! i = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. \\<exists>i<n. procList ! i = p", "using ProcList N"], ["proof (prove)\nusing this:\n  length procList = n\n  set procList = Proc\n  distinct procList\n  n = card Proc\n\ngoal (1 subgoal):\n 1. \\<forall>p. \\<exists>i<n. procList ! i = p", "proof auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>length procList = card Proc; set procList = Proc;\n        distinct procList; n = card Proc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<card Proc. procList ! i = p", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>length procList = card Proc; set procList = Proc;\n        distinct procList; n = card Proc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<card Proc. procList ! i = p", "assume Asm: \"set procList = Proc\" \"length procList = card Proc\""], ["proof (state)\nthis:\n  set procList = Proc\n  length procList = card Proc\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>length procList = card Proc; set procList = Proc;\n        distinct procList; n = card Proc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<card Proc. procList ! i = p", "have \"p \\<in> set procList\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set procList", "using ProcList"], ["proof (prove)\nusing this:\n  length procList = n\n  set procList = Proc\n  distinct procList\n\ngoal (1 subgoal):\n 1. p \\<in> set procList", "by auto"], ["proof (state)\nthis:\n  p \\<in> set procList\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>length procList = card Proc; set procList = Proc;\n        distinct procList; n = card Proc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<card Proc. procList ! i = p", "with Asm in_set_conv_nth"], ["proof (chain)\npicking this:\n  set procList = Proc\n  length procList = card Proc\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  p \\<in> set procList", "show \"\\<exists>i<card Proc. procList ! i = p\""], ["proof (prove)\nusing this:\n  set procList = Proc\n  length procList = card Proc\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n  p \\<in> set procList\n\ngoal (1 subgoal):\n 1. \\<exists>i<card Proc. procList ! i = p", "by metis"], ["proof (state)\nthis:\n  \\<exists>i<card Proc. procList ! i = p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p. \\<exists>i<n. procList ! i = p\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have NGr0: \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using N finiteProcs minimalProcs"], ["proof (prove)\nusing this:\n  n = card Proc\n  finite Proc\n  2 \\<le> card Proc\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "define initMsg :: \"nat \\<Rightarrow> ('p, 'v) message \\<Rightarrow> nat\"\n    where \"initMsg ind m = (if \\<exists>p. m = <p, inM (\\<exists>i<ind. procList!i = p)> then 1 else 0)\" for ind m"], ["proof (state)\nthis:\n  initMsg ?ind ?m =\n  (if \\<exists>p. ?m = <p, inM \\<exists>i<?ind. procList ! i = p> then 1\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "define initCfgList\n    where \"initCfgList = map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>) [0..<(n+1)]\""], ["proof (state)\nthis:\n  initCfgList =\n  map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n   [0..<n + 1]\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have InitCfgLength: \"length initCfgList = n + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length initCfgList = n + 1", "unfolding initCfgList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n       [0..<n + 1]) =\n    n + 1", "by auto"], ["proof (state)\nthis:\n  length initCfgList = n + 1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have InitCfgNonEmpty: \"initCfgList \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initCfgList \\<noteq> []", "unfolding initCfgList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n     [0..<n + 1] \\<noteq>\n    []", "by auto"], ["proof (state)\nthis:\n  initCfgList \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence InitCfgStart: \"(\\<forall>c \\<in> set initCfgList. states c = start)\""], ["proof (prove)\nusing this:\n  initCfgList \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set initCfgList. states c = start", "unfolding initCfgList_def"], ["proof (prove)\nusing this:\n  map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n   [0..<n + 1] \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (map (\\<lambda>ind.\n                                \\<lparr>states = start,\n                                   msgs = initMsg ind\\<rparr>)\n                         [0..<n + 1]).\n       states c = start", "by auto"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set initCfgList. states c = start\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have InitCfgSet: \"set initCfgList = \n    {x. \\<exists>ind < n+1. x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set initCfgList =\n    {x. \\<exists>ind<n + 1.\n           x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}", "unfolding initCfgList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map (\\<lambda>ind.\n                 \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n          [0..<n + 1]) =\n    {x. \\<exists>ind<n + 1.\n           x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}", "proof auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa < n \\<Longrightarrow> \\<exists>ind<Suc n. initMsg xa = initMsg ind\n 2. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "fix ind"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa < n \\<Longrightarrow> \\<exists>ind<Suc n. initMsg xa = initMsg ind\n 2. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "assume \"ind < n\""], ["proof (state)\nthis:\n  ind < n\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa < n \\<Longrightarrow> \\<exists>ind<Suc n. initMsg xa = initMsg ind\n 2. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "hence \"\\<exists>inda<Suc n. inda = ind \\<and> initMsg ind = initMsg inda\""], ["proof (prove)\nusing this:\n  ind < n\n\ngoal (1 subgoal):\n 1. \\<exists>inda<Suc n. inda = ind \\<and> initMsg ind = initMsg inda", "by auto"], ["proof (state)\nthis:\n  \\<exists>inda<Suc n. inda = ind \\<and> initMsg ind = initMsg inda\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa < n \\<Longrightarrow> \\<exists>ind<Suc n. initMsg xa = initMsg ind\n 2. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "thus \"\\<exists>inda<Suc n. initMsg ind = initMsg inda\""], ["proof (prove)\nusing this:\n  \\<exists>inda<Suc n. inda = ind \\<and> initMsg ind = initMsg inda\n\ngoal (1 subgoal):\n 1. \\<exists>inda<Suc n. initMsg ind = initMsg inda", "by blast"], ["proof (state)\nthis:\n  \\<exists>inda<Suc n. initMsg ind = initMsg inda\n\ngoal (1 subgoal):\n 1. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "fix ind"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "assume Asm:\n      \"\\<lparr>states = start, msgs = initMsg ind\\<rparr> \\<notin> (\\<lambda>ind::nat. \\<lparr>states = start, msgs = initMsg ind\\<rparr>) ` {0..<n}\"\n      \"ind < Suc n\""], ["proof (state)\nthis:\n  \\<lparr>states = start, msgs = initMsg ind\\<rparr>\n  \\<notin> (\\<lambda>ind.\n               \\<lparr>states = start, msgs = initMsg ind\\<rparr>) `\n           {0..<n}\n  ind < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "hence \"ind \\<ge> n\""], ["proof (prove)\nusing this:\n  \\<lparr>states = start, msgs = initMsg ind\\<rparr>\n  \\<notin> (\\<lambda>ind.\n               \\<lparr>states = start, msgs = initMsg ind\\<rparr>) `\n           {0..<n}\n  ind < Suc n\n\ngoal (1 subgoal):\n 1. n \\<le> ind", "by auto"], ["proof (state)\nthis:\n  n \\<le> ind\n\ngoal (1 subgoal):\n 1. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "with Asm"], ["proof (chain)\npicking this:\n  \\<lparr>states = start, msgs = initMsg ind\\<rparr>\n  \\<notin> (\\<lambda>ind.\n               \\<lparr>states = start, msgs = initMsg ind\\<rparr>) `\n           {0..<n}\n  ind < Suc n\n  n \\<le> ind", "have \"ind = n\""], ["proof (prove)\nusing this:\n  \\<lparr>states = start, msgs = initMsg ind\\<rparr>\n  \\<notin> (\\<lambda>ind.\n               \\<lparr>states = start, msgs = initMsg ind\\<rparr>) `\n           {0..<n}\n  ind < Suc n\n  n \\<le> ind\n\ngoal (1 subgoal):\n 1. ind = n", "by auto"], ["proof (state)\nthis:\n  ind = n\n\ngoal (1 subgoal):\n 1. \\<And>ind.\n       \\<lbrakk>\\<lparr>states = start, msgs = initMsg ind\\<rparr>\n                \\<notin> (\\<lambda>x.\n                             \\<lparr>states = start,\n                                msgs = initMsg x\\<rparr>) `\n                         {0..<n};\n        ind < Suc n\\<rbrakk>\n       \\<Longrightarrow> initMsg ind = initMsg n", "thus \"initMsg ind = initMsg n\""], ["proof (prove)\nusing this:\n  ind = n\n\ngoal (1 subgoal):\n 1. initMsg ind = initMsg n", "by auto"], ["proof (state)\nthis:\n  initMsg ind = initMsg n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set initCfgList =\n  {x. \\<exists>ind<n + 1.\n         x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have InitInitial: \"\\<forall>c \\<in> set initCfgList . initial c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set initCfgList) initial", "unfolding initial_def initCfgList_def initMsg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (map (\\<lambda>ind.\n                                \\<lparr>states = start,\n                                   msgs =\n                                     \\<lambda>m.\n  if \\<exists>p. m = <p, inM \\<exists>i<ind. procList ! i = p> then 1\n  else 0\\<rparr>)\n                         [0..<n + 1]).\n       (\\<forall>p. \\<exists>v. msgs c <p, inM v> = 1) \\<and>\n       (\\<forall>p m1 m2.\n           m1 \\<in># msgs c \\<and>\n           m2 \\<in># msgs c \\<and>\n           isReceiverOf p m1 \\<and> isReceiverOf p m2 \\<longrightarrow>\n           m1 = m2) \\<and>\n       (\\<forall>v. msgs c <\\<bottom>, outM v> = 0) \\<and>\n       (\\<forall>p v. msgs c <p, v> = 0) \\<and> states c = start", "using InitCfgStart"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set initCfgList. states c = start\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (map (\\<lambda>ind.\n                                \\<lparr>states = start,\n                                   msgs =\n                                     \\<lambda>m.\n  if \\<exists>p. m = <p, inM \\<exists>i<ind. procList ! i = p> then 1\n  else 0\\<rparr>)\n                         [0..<n + 1]).\n       (\\<forall>p. \\<exists>v. msgs c <p, inM v> = 1) \\<and>\n       (\\<forall>p m1 m2.\n           m1 \\<in># msgs c \\<and>\n           m2 \\<in># msgs c \\<and>\n           isReceiverOf p m1 \\<and> isReceiverOf p m2 \\<longrightarrow>\n           m1 = m2) \\<and>\n       (\\<forall>v. msgs c <\\<bottom>, outM v> = 0) \\<and>\n       (\\<forall>p v. msgs c <p, v> = 0) \\<and> states c = start", "by auto"], ["proof (state)\nthis:\n  Ball (set initCfgList) initial\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "with InitCfgSet"], ["proof (chain)\npicking this:\n  set initCfgList =\n  {x. \\<exists>ind<n + 1.\n         x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}\n  Ball (set initCfgList) initial", "have InitInitReachable: \n    \"\\<forall> c \\<in> set initCfgList . initReachable c\""], ["proof (prove)\nusing this:\n  set initCfgList =\n  {x. \\<exists>ind<n + 1.\n         x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}\n  Ball (set initCfgList) initial\n\ngoal (1 subgoal):\n 1. Ball (set initCfgList) initReachable", "using reachable.simps"], ["proof (prove)\nusing this:\n  set initCfgList =\n  {x. \\<exists>ind<n + 1.\n         x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}\n  Ball (set initCfgList) initial\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. Ball (set initCfgList) initReachable", "unfolding initReachable_def"], ["proof (prove)\nusing this:\n  set initCfgList =\n  {x. \\<exists>ind<n + 1.\n         x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}\n  Ball (set initCfgList) initial\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set initCfgList.\n       \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 c", "by blast"], ["proof (state)\nthis:\n  Ball (set initCfgList) initReachable\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "define c0 where \"c0 = initCfgList ! 0\""], ["proof (state)\nthis:\n  c0 = initCfgList ! 0\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence \"c0 = \\<lparr> states = start, msgs = initMsg 0 \\<rparr>\""], ["proof (prove)\nusing this:\n  c0 = initCfgList ! 0\n\ngoal (1 subgoal):\n 1. c0 = \\<lparr>states = start, msgs = initMsg 0\\<rparr>", "using InitCfgLength nth_map_upt[of 0 \"n+1\" 0]"], ["proof (prove)\nusing this:\n  c0 = initCfgList ! 0\n  length initCfgList = n + 1\n  0 \\<in># (-) (n + 1) \\<Longrightarrow> map ?f [0..<n + 1] ! 0 = ?f (0 + 0)\n\ngoal (1 subgoal):\n 1. c0 = \\<lparr>states = start, msgs = initMsg 0\\<rparr>", "unfolding initCfgList_def"], ["proof (prove)\nusing this:\n  c0 =\n  map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n   [0..<n + 1] !\n  0\n  length\n   (map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n     [0..<n + 1]) =\n  n + 1\n  0 \\<in># (-) (n + 1) \\<Longrightarrow> map ?f [0..<n + 1] ! 0 = ?f (0 + 0)\n\ngoal (1 subgoal):\n 1. c0 = \\<lparr>states = start, msgs = initMsg 0\\<rparr>", "by auto"], ["proof (state)\nthis:\n  c0 = \\<lparr>states = start, msgs = initMsg 0\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence MsgC0: \"msgs c0 = (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0)\""], ["proof (prove)\nusing this:\n  c0 = \\<lparr>states = start, msgs = initMsg 0\\<rparr>\n\ngoal (1 subgoal):\n 1. msgs c0 = (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0)", "unfolding initMsg_def"], ["proof (prove)\nusing this:\n  c0 =\n  \\<lparr>states = start,\n     msgs =\n       \\<lambda>m.\n          if \\<exists>p. m = <p, inM \\<exists>i<0. procList ! i = p> then 1\n          else 0\\<rparr>\n\ngoal (1 subgoal):\n 1. msgs c0 = (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  msgs c0 = (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "define cN where \"cN = initCfgList ! n\""], ["proof (state)\nthis:\n  cN = initCfgList ! n\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence \"cN = \\<lparr> states = start, msgs = initMsg n\\<rparr>\""], ["proof (prove)\nusing this:\n  cN = initCfgList ! n\n\ngoal (1 subgoal):\n 1. cN = \\<lparr>states = start, msgs = initMsg n\\<rparr>", "using InitCfgLength nth_map_upt[of n \"n+1\" 0]"], ["proof (prove)\nusing this:\n  cN = initCfgList ! n\n  length initCfgList = n + 1\n  n < n + 1 - 0 \\<Longrightarrow> map ?f [0..<n + 1] ! n = ?f (0 + n)\n\ngoal (1 subgoal):\n 1. cN = \\<lparr>states = start, msgs = initMsg n\\<rparr>", "unfolding initCfgList_def"], ["proof (prove)\nusing this:\n  cN =\n  map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n   [0..<n + 1] !\n  n\n  length\n   (map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n     [0..<n + 1]) =\n  n + 1\n  n < n + 1 - 0 \\<Longrightarrow> map ?f [0..<n + 1] ! n = ?f (0 + n)\n\ngoal (1 subgoal):\n 1. cN = \\<lparr>states = start, msgs = initMsg n\\<rparr>", "by auto"], ["proof (state)\nthis:\n  cN = \\<lparr>states = start, msgs = initMsg n\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence MsgCN: \"msgs cN = (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)\""], ["proof (prove)\nusing this:\n  cN = \\<lparr>states = start, msgs = initMsg n\\<rparr>\n\ngoal (1 subgoal):\n 1. msgs cN = (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)", "unfolding initMsg_def"], ["proof (prove)\nusing this:\n  cN =\n  \\<lparr>states = start,\n     msgs =\n       \\<lambda>m.\n          if \\<exists>p. m = <p, inM \\<exists>i<n. procList ! i = p> then 1\n          else 0\\<rparr>\n\ngoal (1 subgoal):\n 1. msgs cN = (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)", "using AllPInProclist"], ["proof (prove)\nusing this:\n  cN =\n  \\<lparr>states = start,\n     msgs =\n       \\<lambda>m.\n          if \\<exists>p. m = <p, inM \\<exists>i<n. procList ! i = p> then 1\n          else 0\\<rparr>\n  \\<forall>p. \\<exists>i<n. procList ! i = p\n\ngoal (1 subgoal):\n 1. msgs cN = (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  msgs cN = (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have C0NotCN: \"c0 \\<noteq> cN\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c0 \\<noteq> cN", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. c0 = cN \\<Longrightarrow> False", "assume \"c0 = cN\""], ["proof (state)\nthis:\n  c0 = cN\n\ngoal (1 subgoal):\n 1. c0 = cN \\<Longrightarrow> False", "hence StrangeEq: \"(\\<lambda>m::('p, 'v) message.\n        if \\<exists>p. m = <p, inM False> then 1 else 0 :: nat) =\n      (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)\""], ["proof (prove)\nusing this:\n  c0 = cN\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0) =\n    (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)", "using InitCfgLength N minimalProcs MsgC0 MsgCN"], ["proof (prove)\nusing this:\n  c0 = cN\n  length initCfgList = n + 1\n  n = card Proc\n  2 \\<le> card Proc\n  msgs c0 = (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0)\n  msgs cN = (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0) =\n    (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)", "unfolding c0_def cN_def"], ["proof (prove)\nusing this:\n  initCfgList ! 0 = initCfgList ! n\n  length initCfgList = n + 1\n  n = card Proc\n  2 \\<le> card Proc\n  msgs (initCfgList ! 0) =\n  (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0)\n  msgs (initCfgList ! n) =\n  (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0) =\n    (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0) =\n  (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)\n\ngoal (1 subgoal):\n 1. c0 = cN \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  (\\<lambda>m. if \\<exists>p. m = <p, inM False> then 1 else 0) =\n  (\\<lambda>m. if \\<exists>p. m = <p, inM True> then 1 else 0)\n\ngoal (1 subgoal):\n 1. False", "by (metis message.inject(1) zero_neq_one)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c0 \\<noteq> cN\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have C0NAreUniform: \"\\<And> cX . (cX = c0) \\<or> (cX = cN) \n                      \\<Longrightarrow> vUniform (cX = cN) cX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "fix cX"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "assume xIs0OrN: \"(cX = c0) \\<or> (cX = cN)\""], ["proof (state)\nthis:\n  cX = c0 \\<or> cX = cN\n\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "have xInit: \"initial cX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial cX", "using InitCfgLength InitCfgSet set_conv_nth[of initCfgList] xIs0OrN"], ["proof (prove)\nusing this:\n  length initCfgList = n + 1\n  set initCfgList =\n  {x. \\<exists>ind<n + 1.\n         x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}\n  set initCfgList = {initCfgList ! i |i. i < length initCfgList}\n  cX = c0 \\<or> cX = cN\n\ngoal (1 subgoal):\n 1. initial cX", "unfolding c0_def cN_def"], ["proof (prove)\nusing this:\n  length initCfgList = n + 1\n  set initCfgList =\n  {x. \\<exists>ind<n + 1.\n         x = \\<lparr>states = start, msgs = initMsg ind\\<rparr>}\n  set initCfgList = {initCfgList ! i |i. i < length initCfgList}\n  cX = initCfgList ! 0 \\<or> cX = initCfgList ! n\n\ngoal (1 subgoal):\n 1. initial cX", "by (auto simp add: InitInitial)"], ["proof (state)\nthis:\n  initial cX\n\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "from Validity"], ["proof (chain)\npicking this:\n  \\<forall>i c. validity i c", "have COnlyReachesOneDecision:\n        \"\\<forall> c . reachable cX c \\<and> decided c \\<longrightarrow> (vDecided (cX = cN) c)\""], ["proof (prove)\nusing this:\n  \\<forall>i c. validity i c\n\ngoal (1 subgoal):\n 1. \\<forall>c.\n       reachable cX c \\<and>\n       (\\<exists>v.\n           initReachable c \\<and>\n           <\\<bottom>, outM v> \\<in># msgs c) \\<longrightarrow>\n       initReachable c \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs c", "unfolding validity_def initReachable_def"], ["proof (prove)\nusing this:\n  \\<forall>i c.\n     initial i \\<and> reachable i c \\<longrightarrow>\n     (\\<forall>v.\n         <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n         (\\<exists>p. <p, inM v> \\<in># msgs i))\n\ngoal (1 subgoal):\n 1. \\<forall>c.\n       reachable cX c \\<and>\n       (\\<exists>v.\n           (\\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 c) \\<and>\n           <\\<bottom>, outM v> \\<in># msgs c) \\<longrightarrow>\n       (\\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 c) \\<and>\n       <\\<bottom>, outM cX = cN> \\<in># msgs c", "proof auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c cfg0 v.\n       \\<lbrakk>\\<forall>i c.\n                   initial i \\<and> reachable i c \\<longrightarrow>\n                   (\\<forall>v.\n                       <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n                       (\\<exists>p. <p, inM v> \\<in># msgs i));\n        reachable cX c; <\\<bottom>, outM v> \\<in># msgs c; initial cfg0;\n        reachable cfg0 c\\<rbrakk>\n       \\<Longrightarrow> <\\<bottom>, outM cX = cN> \\<in># msgs c", "fix c cfg0 v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c cfg0 v.\n       \\<lbrakk>\\<forall>i c.\n                   initial i \\<and> reachable i c \\<longrightarrow>\n                   (\\<forall>v.\n                       <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n                       (\\<exists>p. <p, inM v> \\<in># msgs i));\n        reachable cX c; <\\<bottom>, outM v> \\<in># msgs c; initial cfg0;\n        reachable cfg0 c\\<rbrakk>\n       \\<Longrightarrow> <\\<bottom>, outM cX = cN> \\<in># msgs c", "assume\n        Validity: \"(\\<forall>i c. ((initial i) \\<and> (reachable i c)) \\<longrightarrow>\n          (\\<forall>v. (0 < msgs c (<\\<bottom>, outM v>)) \n          \\<longrightarrow> (\\<exists>p. (0 < msgs i (<p, inM v>)))))\" and\n        OutMsg: \"0 < msgs c <\\<bottom>, outM v>\" and\n        InitCXReachable: \"reachable cX c\""], ["proof (state)\nthis:\n  \\<forall>i c.\n     initial i \\<and> reachable i c \\<longrightarrow>\n     (\\<forall>v.\n         <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n         (\\<exists>p. <p, inM v> \\<in># msgs i))\n  <\\<bottom>, outM v> \\<in># msgs c\n  reachable cX c\n\ngoal (1 subgoal):\n 1. \\<And>c cfg0 v.\n       \\<lbrakk>\\<forall>i c.\n                   initial i \\<and> reachable i c \\<longrightarrow>\n                   (\\<forall>v.\n                       <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n                       (\\<exists>p. <p, inM v> \\<in># msgs i));\n        reachable cX c; <\\<bottom>, outM v> \\<in># msgs c; initial cfg0;\n        reachable cfg0 c\\<rbrakk>\n       \\<Longrightarrow> <\\<bottom>, outM cX = cN> \\<in># msgs c", "thus \"0 < msgs c <\\<bottom>, outM (cX = cN)>\""], ["proof (prove)\nusing this:\n  \\<forall>i c.\n     initial i \\<and> reachable i c \\<longrightarrow>\n     (\\<forall>v.\n         <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n         (\\<exists>p. <p, inM v> \\<in># msgs i))\n  <\\<bottom>, outM v> \\<in># msgs c\n  reachable cX c\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM cX = cN> \\<in># msgs c", "using xIs0OrN"], ["proof (prove)\nusing this:\n  \\<forall>i c.\n     initial i \\<and> reachable i c \\<longrightarrow>\n     (\\<forall>v.\n         <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n         (\\<exists>p. <p, inM v> \\<in># msgs i))\n  <\\<bottom>, outM v> \\<in># msgs c\n  reachable cX c\n  cX = c0 \\<or> cX = cN\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM cX = cN> \\<in># msgs c", "proof (cases \"v = (cX = cN)\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i c.\n                initial i \\<and> reachable i c \\<longrightarrow>\n                (\\<forall>v.\n                    <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n                    (\\<exists>p. <p, inM v> \\<in># msgs i));\n     <\\<bottom>, outM v> \\<in># msgs c; reachable cX c;\n     cX = c0 \\<or> cX = cN; v \\<noteq> (cX = cN)\\<rbrakk>\n    \\<Longrightarrow> <\\<bottom>, outM cX = cN> \\<in># msgs c", "assume \"v \\<noteq> (cX = cN)\""], ["proof (state)\nthis:\n  v \\<noteq> (cX = cN)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i c.\n                initial i \\<and> reachable i c \\<longrightarrow>\n                (\\<forall>v.\n                    <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n                    (\\<exists>p. <p, inM v> \\<in># msgs i));\n     <\\<bottom>, outM v> \\<in># msgs c; reachable cX c;\n     cX = c0 \\<or> cX = cN; v \\<noteq> (cX = cN)\\<rbrakk>\n    \\<Longrightarrow> <\\<bottom>, outM cX = cN> \\<in># msgs c", "hence vDef: \"v = (cX \\<noteq> cN)\""], ["proof (prove)\nusing this:\n  v \\<noteq> (cX = cN)\n\ngoal (1 subgoal):\n 1. v = (cX \\<noteq> cN)", "by auto"], ["proof (state)\nthis:\n  v = (cX \\<noteq> cN)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i c.\n                initial i \\<and> reachable i c \\<longrightarrow>\n                (\\<forall>v.\n                    <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n                    (\\<exists>p. <p, inM v> \\<in># msgs i));\n     <\\<bottom>, outM v> \\<in># msgs c; reachable cX c;\n     cX = c0 \\<or> cX = cN; v \\<noteq> (cX = cN)\\<rbrakk>\n    \\<Longrightarrow> <\\<bottom>, outM cX = cN> \\<in># msgs c", "with Validity InitCXReachable OutMsg xInit"], ["proof (chain)\npicking this:\n  \\<forall>i c.\n     initial i \\<and> reachable i c \\<longrightarrow>\n     (\\<forall>v.\n         <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n         (\\<exists>p. <p, inM v> \\<in># msgs i))\n  reachable cX c\n  <\\<bottom>, outM v> \\<in># msgs c\n  initial cX\n  v = (cX \\<noteq> cN)", "have ExistMsg: \"\\<exists>p. (0 < msgs cX (<p, inM (cX \\<noteq> cN)>))\""], ["proof (prove)\nusing this:\n  \\<forall>i c.\n     initial i \\<and> reachable i c \\<longrightarrow>\n     (\\<forall>v.\n         <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n         (\\<exists>p. <p, inM v> \\<in># msgs i))\n  reachable cX c\n  <\\<bottom>, outM v> \\<in># msgs c\n  initial cX\n  v = (cX \\<noteq> cN)\n\ngoal (1 subgoal):\n 1. \\<exists>p. <p, inM cX \\<noteq> cN> \\<in># msgs cX", "by auto"], ["proof (state)\nthis:\n  \\<exists>p. <p, inM cX \\<noteq> cN> \\<in># msgs cX\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i c.\n                initial i \\<and> reachable i c \\<longrightarrow>\n                (\\<forall>v.\n                    <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n                    (\\<exists>p. <p, inM v> \\<in># msgs i));\n     <\\<bottom>, outM v> \\<in># msgs c; reachable cX c;\n     cX = c0 \\<or> cX = cN; v \\<noteq> (cX = cN)\\<rbrakk>\n    \\<Longrightarrow> <\\<bottom>, outM cX = cN> \\<in># msgs c", "with initMsg_def"], ["proof (chain)\npicking this:\n  initMsg ?ind ?m =\n  (if \\<exists>p. ?m = <p, inM \\<exists>i<?ind. procList ! i = p> then 1\n   else 0)\n  \\<exists>p. <p, inM cX \\<noteq> cN> \\<in># msgs cX", "have False"], ["proof (prove)\nusing this:\n  initMsg ?ind ?m =\n  (if \\<exists>p. ?m = <p, inM \\<exists>i<?ind. procList ! i = p> then 1\n   else 0)\n  \\<exists>p. <p, inM cX \\<noteq> cN> \\<in># msgs cX\n\ngoal (1 subgoal):\n 1. False", "using xIs0OrN"], ["proof (prove)\nusing this:\n  initMsg ?ind ?m =\n  (if \\<exists>p. ?m = <p, inM \\<exists>i<?ind. procList ! i = p> then 1\n   else 0)\n  \\<exists>p. <p, inM cX \\<noteq> cN> \\<in># msgs cX\n  cX = c0 \\<or> cX = cN\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: MsgC0 MsgCN C0NotCN)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i c.\n                initial i \\<and> reachable i c \\<longrightarrow>\n                (\\<forall>v.\n                    <\\<bottom>, outM v> \\<in># msgs c \\<longrightarrow>\n                    (\\<exists>p. <p, inM v> \\<in># msgs i));\n     <\\<bottom>, outM v> \\<in># msgs c; reachable cX c;\n     cX = c0 \\<or> cX = cN; v \\<noteq> (cX = cN)\\<rbrakk>\n    \\<Longrightarrow> <\\<bottom>, outM cX = cN> \\<in># msgs c", "thus \"0 < msgs c <\\<bottom>, outM cX = cN>\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM cX = cN> \\<in># msgs c", "by simp"], ["proof (state)\nthis:\n  <\\<bottom>, outM cX = cN> \\<in># msgs c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  <\\<bottom>, outM cX = cN> \\<in># msgs c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>c.\n     reachable cX c \\<and>\n     (\\<exists>v.\n         initReachable c \\<and>\n         <\\<bottom>, outM v> \\<in># msgs c) \\<longrightarrow>\n     initReachable c \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs c\n\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "have InitRInitC: \"initReachable cX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initReachable cX", "using xInit InitialIsInitReachable"], ["proof (prove)\nusing this:\n  initial cX\n  initial ?c \\<Longrightarrow> initReachable ?c\n\ngoal (1 subgoal):\n 1. initReachable cX", "by auto"], ["proof (state)\nthis:\n  initReachable cX\n\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "have NoWrongDecs: \"\\<And> v p cc::('p, 'v, 's) configuration.\n      qReachable cX (Proc - {p}) cc \\<and> initReachable cc \n      \\<and> 0 < msgs cc <\\<bottom>, outM v> \n        \\<Longrightarrow> v = (cX = cN)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v p cc.\n       qReachable cX (Proc - {p}) cc \\<and>\n       initReachable cc \\<and>\n       <\\<bottom>, outM v> \\<in># msgs cc \\<Longrightarrow>\n       v = (cX = cN)", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p cc.\n       \\<lbrakk>qReachable cX (Proc - {p}) cc; initReachable cc;\n        <\\<bottom>, outM v> \\<in># msgs cc\\<rbrakk>\n       \\<Longrightarrow> v = (cX = cN)", "fix v p cc"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v p cc.\n       \\<lbrakk>qReachable cX (Proc - {p}) cc; initReachable cc;\n        <\\<bottom>, outM v> \\<in># msgs cc\\<rbrakk>\n       \\<Longrightarrow> v = (cX = cN)", "assume Asm: \"qReachable cX (Proc - {p}) cc\" \"initReachable cc\" \n      \"0 < msgs cc <\\<bottom>, outM v>\""], ["proof (state)\nthis:\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. \\<And>v p cc.\n       \\<lbrakk>qReachable cX (Proc - {p}) cc; initReachable cc;\n        <\\<bottom>, outM v> \\<in># msgs cc\\<rbrakk>\n       \\<Longrightarrow> v = (cX = cN)", "hence \"reachable cX cc\" \"decided cc\""], ["proof (prove)\nusing this:\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. reachable cX cc &&&\n    \\<exists>v. initReachable cc \\<and> <\\<bottom>, outM v> \\<in># msgs cc", "using QReachImplReach"], ["proof (prove)\nusing this:\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n  qReachable ?cfg1.0 ?Q ?cfg2.0 \\<Longrightarrow> reachable ?cfg1.0 ?cfg2.0\n\ngoal (1 subgoal):\n 1. reachable cX cc &&&\n    \\<exists>v. initReachable cc \\<and> <\\<bottom>, outM v> \\<in># msgs cc", "by auto"], ["proof (state)\nthis:\n  reachable cX cc\n  \\<exists>v. initReachable cc \\<and> <\\<bottom>, outM v> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. \\<And>v p cc.\n       \\<lbrakk>qReachable cX (Proc - {p}) cc; initReachable cc;\n        <\\<bottom>, outM v> \\<in># msgs cc\\<rbrakk>\n       \\<Longrightarrow> v = (cX = cN)", "hence \"\\<not>(vDecided (cX \\<noteq> cN) cc)\""], ["proof (prove)\nusing this:\n  reachable cX cc\n  \\<exists>v. initReachable cc \\<and> <\\<bottom>, outM v> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. \\<not> (initReachable cc \\<and>\n            <\\<bottom>, outM cX \\<noteq> cN> \\<in># msgs cc)", "using COnlyReachesOneDecision Agreement Asm C0NotCN xInit xIs0OrN"], ["proof (prove)\nusing this:\n  reachable cX cc\n  \\<exists>v. initReachable cc \\<and> <\\<bottom>, outM v> \\<in># msgs cc\n  \\<forall>c.\n     reachable cX c \\<and>\n     (\\<exists>v.\n         initReachable c \\<and>\n         <\\<bottom>, outM v> \\<in># msgs c) \\<longrightarrow>\n     initReachable c \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs c\n  \\<forall>i c. agreementInit i c\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n  c0 \\<noteq> cN\n  initial cX\n  cX = c0 \\<or> cX = cN\n\ngoal (1 subgoal):\n 1. \\<not> (initReachable cc \\<and>\n            <\\<bottom>, outM cX \\<noteq> cN> \\<in># msgs cc)", "unfolding agreementInit_def"], ["proof (prove)\nusing this:\n  reachable cX cc\n  \\<exists>v. initReachable cc \\<and> <\\<bottom>, outM v> \\<in># msgs cc\n  \\<forall>c.\n     reachable cX c \\<and>\n     (\\<exists>v.\n         initReachable c \\<and>\n         <\\<bottom>, outM v> \\<in># msgs c) \\<longrightarrow>\n     initReachable c \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs c\n  \\<forall>i c.\n     initial i \\<and> reachable i c \\<longrightarrow>\n     (\\<forall>v1.\n         <\\<bottom>, outM v1> \\<in># msgs c \\<longrightarrow>\n         (\\<forall>v2. <\\<bottom>, outM v2> \\<in># msgs c = (v2 = v1)))\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n  c0 \\<noteq> cN\n  initial cX\n  cX = c0 \\<or> cX = cN\n\ngoal (1 subgoal):\n 1. \\<not> (initReachable cc \\<and>\n            <\\<bottom>, outM cX \\<noteq> cN> \\<in># msgs cc)", "by metis"], ["proof (state)\nthis:\n  \\<not> (initReachable cc \\<and>\n          <\\<bottom>, outM cX \\<noteq> cN> \\<in># msgs cc)\n\ngoal (1 subgoal):\n 1. \\<And>v p cc.\n       \\<lbrakk>qReachable cX (Proc - {p}) cc; initReachable cc;\n        <\\<bottom>, outM v> \\<in># msgs cc\\<rbrakk>\n       \\<Longrightarrow> v = (cX = cN)", "with Asm C0NotCN xIs0OrN"], ["proof (chain)\npicking this:\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n  c0 \\<noteq> cN\n  cX = c0 \\<or> cX = cN\n  \\<not> (initReachable cc \\<and>\n          <\\<bottom>, outM cX \\<noteq> cN> \\<in># msgs cc)", "show \"v = (cX = cN)\""], ["proof (prove)\nusing this:\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n  c0 \\<noteq> cN\n  cX = c0 \\<or> cX = cN\n  \\<not> (initReachable cc \\<and>\n          <\\<bottom>, outM cX \\<noteq> cN> \\<in># msgs cc)\n\ngoal (1 subgoal):\n 1. v = (cX = cN)", "by (auto, metis (full_types) neq0_conv)"], ["proof (state)\nthis:\n  v = (cX = cN)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  qReachable cX (Proc - {?p}) ?cc \\<and>\n  initReachable ?cc \\<and>\n  <\\<bottom>, outM ?v> \\<in># msgs ?cc \\<Longrightarrow>\n  ?v = (cX = cN)\n\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "have ExRightDecs: \"\\<And>p. \\<exists>cc. qReachable (cX) (Proc - {p}) cc\n      \\<and> initReachable cc \\<and> 0 < msgs cc <\\<bottom>, outM (cX = cN)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<exists>cc.\n          qReachable cX (Proc - {p}) cc \\<and>\n          initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<exists>cc.\n          qReachable cX (Proc - {p}) cc \\<and>\n          initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<exists>cc.\n          qReachable cX (Proc - {p}) cc \\<and>\n          initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc", "show \"\\<exists>cc::('p, 'v, 's) configuration.\n           qReachable cX (Proc - {p}) cc \\<and> initReachable cc \n           \\<and> (0::nat) < msgs cc <\\<bottom>, outM cX = cN>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cc.\n       qReachable cX (Proc - {p}) cc \\<and>\n       initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc", "using Termination[of \"cX\" \"Proc - {p}\"] finiteProcs minimalProcs \n          InitRInitC"], ["proof (prove)\nusing this:\n  terminationPseudo 1 cX (Proc - {p})\n  finite Proc\n  2 \\<le> card Proc\n  initReachable cX\n\ngoal (1 subgoal):\n 1. \\<exists>cc.\n       qReachable cX (Proc - {p}) cc \\<and>\n       initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc", "unfolding terminationPseudo_def"], ["proof (prove)\nusing this:\n  initReachable cX \\<and>\n  card Proc \\<le> card (Proc - {p}) + 1 \\<longrightarrow>\n  (\\<exists>c'.\n      qReachable cX (Proc - {p}) c' \\<and>\n      (\\<exists>v.\n          initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c'))\n  finite Proc\n  2 \\<le> card Proc\n  initReachable cX\n\ngoal (1 subgoal):\n 1. \\<exists>cc.\n       qReachable cX (Proc - {p}) cc \\<and>\n       initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc", "proof auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c' v.\n       \\<lbrakk>finite Proc; 2 \\<le> card Proc; initReachable cX;\n        qReachable cX (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM v> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cc.\n                            qReachable cX (Proc - {p}) cc \\<and>\n                            initReachable cc \\<and>\n                            <\\<bottom>, outM cX = cN> \\<in># msgs cc", "fix cc v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c' v.\n       \\<lbrakk>finite Proc; 2 \\<le> card Proc; initReachable cX;\n        qReachable cX (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM v> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cc.\n                            qReachable cX (Proc - {p}) cc \\<and>\n                            initReachable cc \\<and>\n                            <\\<bottom>, outM cX = cN> \\<in># msgs cc", "assume \n          Asm: \"initReachable cX\" \"qReachable (cX) (Proc - {p}) cc\"\n          \"initReachable cc\"  \"0 < msgs cc <\\<bottom>, outM v>\""], ["proof (state)\nthis:\n  initReachable cX\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. \\<And>c' v.\n       \\<lbrakk>finite Proc; 2 \\<le> card Proc; initReachable cX;\n        qReachable cX (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM v> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cc.\n                            qReachable cX (Proc - {p}) cc \\<and>\n                            initReachable cc \\<and>\n                            <\\<bottom>, outM cX = cN> \\<in># msgs cc", "with COnlyReachesOneDecision[rule_format, of \"cc\"] QReachImplReach"], ["proof (chain)\npicking this:\n  reachable cX cc \\<and>\n  (\\<exists>v.\n      initReachable cc \\<and>\n      <\\<bottom>, outM v> \\<in># msgs cc) \\<Longrightarrow>\n  initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc\n  qReachable ?cfg1.0 ?Q ?cfg2.0 \\<Longrightarrow> reachable ?cfg1.0 ?cfg2.0\n  initReachable cX\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc", "have \"0 < msgs cc <\\<bottom>, outM cX = cN>\""], ["proof (prove)\nusing this:\n  reachable cX cc \\<and>\n  (\\<exists>v.\n      initReachable cc \\<and>\n      <\\<bottom>, outM v> \\<in># msgs cc) \\<Longrightarrow>\n  initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc\n  qReachable ?cfg1.0 ?Q ?cfg2.0 \\<Longrightarrow> reachable ?cfg1.0 ?cfg2.0\n  initReachable cX\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. <\\<bottom>, outM cX = cN> \\<in># msgs cc", "by auto"], ["proof (state)\nthis:\n  <\\<bottom>, outM cX = cN> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. \\<And>c' v.\n       \\<lbrakk>finite Proc; 2 \\<le> card Proc; initReachable cX;\n        qReachable cX (Proc - {p}) c'; initReachable c';\n        <\\<bottom>, outM v> \\<in># msgs c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cc.\n                            qReachable cX (Proc - {p}) cc \\<and>\n                            initReachable cc \\<and>\n                            <\\<bottom>, outM cX = cN> \\<in># msgs cc", "with Asm"], ["proof (chain)\npicking this:\n  initReachable cX\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n  <\\<bottom>, outM cX = cN> \\<in># msgs cc", "show \"\\<exists>cc::('p, 'v, 's) configuration. \n            qReachable cX (Proc - {p}) cc\n            \\<and> initReachable cc \\<and> (0::nat) < msgs cc <\\<bottom>, outM cX = cN>\""], ["proof (prove)\nusing this:\n  initReachable cX\n  qReachable cX (Proc - {p}) cc\n  initReachable cc\n  <\\<bottom>, outM v> \\<in># msgs cc\n  <\\<bottom>, outM cX = cN> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. \\<exists>cc.\n       qReachable cX (Proc - {p}) cc \\<and>\n       initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc", "by blast"], ["proof (state)\nthis:\n  \\<exists>cc.\n     qReachable cX (Proc - {p}) cc \\<and>\n     initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cc.\n     qReachable cX (Proc - {p}) cc \\<and>\n     initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cc.\n     qReachable cX (Proc - {?p}) cc \\<and>\n     initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "have ZeroinPSilent: \"\\<forall> p v . v \\<in> val[p, cX] \\<longleftrightarrow> v = (cX = cN)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p v. (v \\<in> val[p,cX]) = (v = (cX = cN))", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v. (v \\<in> val[p,cX]) = (v = (cX = cN))", "fix p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v. (v \\<in> val[p,cX]) = (v = (cX = cN))", "show \"v \\<in> val[p, cX] \\<longleftrightarrow> v = (cX = cN)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> val[p,cX]) = (v = (cX = cN))", "unfolding pSilDecVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> {v. initReachable cX \\<and>\n                 (\\<exists>c'.\n                     qReachable cX (Proc - {p}) c' \\<and>\n                     initReachable c' \\<and>\n                     <\\<bottom>, outM v> \\<in># msgs c')}) =\n    (v = (cX = cN))", "using InitRInitC xIs0OrN C0NotCN NoWrongDecs ExRightDecs"], ["proof (prove)\nusing this:\n  initReachable cX\n  cX = c0 \\<or> cX = cN\n  c0 \\<noteq> cN\n  qReachable cX (Proc - {?p}) ?cc \\<and>\n  initReachable ?cc \\<and>\n  <\\<bottom>, outM ?v> \\<in># msgs ?cc \\<Longrightarrow>\n  ?v = (cX = cN)\n  \\<exists>cc.\n     qReachable cX (Proc - {?p}) cc \\<and>\n     initReachable cc \\<and> <\\<bottom>, outM cX = cN> \\<in># msgs cc\n\ngoal (1 subgoal):\n 1. (v \\<in> {v. initReachable cX \\<and>\n                 (\\<exists>c'.\n                     qReachable cX (Proc - {p}) c' \\<and>\n                     initReachable c' \\<and>\n                     <\\<bottom>, outM v> \\<in># msgs c')}) =\n    (v = (cX = cN))", "by auto"], ["proof (state)\nthis:\n  (v \\<in> val[p,cX]) = (v = (cX = cN))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p v. (v \\<in> val[p,cX]) = (v = (cX = cN))\n\ngoal (1 subgoal):\n 1. \\<And>cX. cX = c0 \\<or> cX = cN \\<Longrightarrow> vUniform (cX = cN) cX", "thus \"vUniform (cX = cN) cX\""], ["proof (prove)\nusing this:\n  \\<forall>p v. (v \\<in> val[p,cX]) = (v = (cX = cN))\n\ngoal (1 subgoal):\n 1. vUniform (cX = cN) cX", "using InitRInitC"], ["proof (prove)\nusing this:\n  \\<forall>p v. (v \\<in> val[p,cX]) = (v = (cX = cN))\n  initReachable cX\n\ngoal (1 subgoal):\n 1. vUniform (cX = cN) cX", "unfolding vUniform_def"], ["proof (prove)\nusing this:\n  \\<forall>p v. (v \\<in> val[p,cX]) = (v = (cX = cN))\n  initReachable cX\n\ngoal (1 subgoal):\n 1. initReachable cX \\<and> (\\<forall>p. val[p,cX] = {cX = cN})", "by auto"], ["proof (state)\nthis:\n  vUniform (cX = cN) cX\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?cX = c0 \\<or> ?cX = cN \\<Longrightarrow> vUniform (?cX = cN) ?cX\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence\n    C0Is0Uniform: \"vUniform False c0\" and\n    CNNot0Uniform: \"\\<not> vUniform False cN\""], ["proof (prove)\nusing this:\n  ?cX = c0 \\<or> ?cX = cN \\<Longrightarrow> vUniform (?cX = cN) ?cX\n\ngoal (1 subgoal):\n 1. vUniform False c0 &&& \\<not> vUniform False cN", "using C0NAreUniform"], ["proof (prove)\nusing this:\n  ?cX = c0 \\<or> ?cX = cN \\<Longrightarrow> vUniform (?cX = cN) ?cX\n  ?cX = c0 \\<or> ?cX = cN \\<Longrightarrow> vUniform (?cX = cN) ?cX\n\ngoal (1 subgoal):\n 1. vUniform False c0 &&& \\<not> vUniform False cN", "unfolding vUniform_def"], ["proof (prove)\nusing this:\n  ?cX = c0 \\<or> ?cX = cN \\<Longrightarrow>\n  initReachable ?cX \\<and> (\\<forall>p. val[p,?cX] = {?cX = cN})\n  ?cX = c0 \\<or> ?cX = cN \\<Longrightarrow>\n  initReachable ?cX \\<and> (\\<forall>p. val[p,?cX] = {?cX = cN})\n\ngoal (1 subgoal):\n 1. initReachable c0 \\<and> (\\<forall>p. val[p,c0] = {False}) &&&\n    \\<not> (initReachable cN \\<and> (\\<forall>p. val[p,cN] = {False}))", "using C0NotCN"], ["proof (prove)\nusing this:\n  ?cX = c0 \\<or> ?cX = cN \\<Longrightarrow>\n  initReachable ?cX \\<and> (\\<forall>p. val[p,?cX] = {?cX = cN})\n  ?cX = c0 \\<or> ?cX = cN \\<Longrightarrow>\n  initReachable ?cX \\<and> (\\<forall>p. val[p,?cX] = {?cX = cN})\n  c0 \\<noteq> cN\n\ngoal (1 subgoal):\n 1. initReachable c0 \\<and> (\\<forall>p. val[p,c0] = {False}) &&&\n    \\<not> (initReachable cN \\<and> (\\<forall>p. val[p,cN] = {False}))", "by auto"], ["proof (state)\nthis:\n  vUniform False c0\n  \\<not> vUniform False cN\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence \"\\<exists> j < n. vUniform False (initCfgList ! j) \n    \\<and> \\<not>(vUniform False (initCfgList ! Suc j))\""], ["proof (prove)\nusing this:\n  vUniform False c0\n  \\<not> vUniform False cN\n\ngoal (1 subgoal):\n 1. \\<exists>j<n.\n       vUniform False (initCfgList ! j) \\<and>\n       \\<not> vUniform False (initCfgList ! Suc j)", "unfolding c0_def cN_def"], ["proof (prove)\nusing this:\n  vUniform False (initCfgList ! 0)\n  \\<not> vUniform False (initCfgList ! n)\n\ngoal (1 subgoal):\n 1. \\<exists>j<n.\n       vUniform False (initCfgList ! j) \\<and>\n       \\<not> vUniform False (initCfgList ! Suc j)", "using NatPredicateTippingPoint\n      [of n \"\\<lambda>x. vUniform False (initCfgList ! x)\"] NGr0"], ["proof (prove)\nusing this:\n  vUniform False (initCfgList ! 0)\n  \\<not> vUniform False (initCfgList ! n)\n  \\<lbrakk>0 < n; vUniform False (initCfgList ! 0);\n   \\<not> vUniform False (initCfgList ! n)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>na<n.\n                       vUniform False (initCfgList ! na) \\<and>\n                       \\<not> vUniform False (initCfgList ! Suc na)\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>j<n.\n       vUniform False (initCfgList ! j) \\<and>\n       \\<not> vUniform False (initCfgList ! Suc j)", "by auto"], ["proof (state)\nthis:\n  \\<exists>j<n.\n     vUniform False (initCfgList ! j) \\<and>\n     \\<not> vUniform False (initCfgList ! Suc j)\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "then"], ["proof (chain)\npicking this:\n  \\<exists>j<n.\n     vUniform False (initCfgList ! j) \\<and>\n     \\<not> vUniform False (initCfgList ! Suc j)", "obtain j\n    where J: \"j < n\"\n      \"vUniform False (initCfgList ! j)\"\n      \"\\<not>(vUniform False (initCfgList ! Suc j))\""], ["proof (prove)\nusing this:\n  \\<exists>j<n.\n     vUniform False (initCfgList ! j) \\<and>\n     \\<not> vUniform False (initCfgList ! Suc j)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < n; vUniform False (initCfgList ! j);\n         \\<not> vUniform False (initCfgList ! Suc j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j < n\n  vUniform False (initCfgList ! j)\n  \\<not> vUniform False (initCfgList ! Suc j)\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "define pJ where \"pJ = procList ! j\""], ["proof (state)\nthis:\n  pJ = procList ! j\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "define cJ where \"cJ = initCfgList ! j\""], ["proof (state)\nthis:\n  cJ = initCfgList ! j\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence cJDef: \"cJ = \\<lparr> states = start, msgs = initMsg j\\<rparr>\""], ["proof (prove)\nusing this:\n  cJ = initCfgList ! j\n\ngoal (1 subgoal):\n 1. cJ = \\<lparr>states = start, msgs = initMsg j\\<rparr>", "using J(1) InitCfgLength nth_map_upt[of 0 \"j- 1\" 1] \n      nth_map_upt[of \"j\" \"n + 1\" 0]"], ["proof (prove)\nusing this:\n  cJ = initCfgList ! j\n  j < n\n  length initCfgList = n + 1\n  1 \\<in># (-) (j - 1) \\<Longrightarrow> map ?f [1..<j - 1] ! 0 = ?f (1 + 0)\n  j < n + 1 - 0 \\<Longrightarrow> map ?f [0..<n + 1] ! j = ?f (0 + j)\n\ngoal (1 subgoal):\n 1. cJ = \\<lparr>states = start, msgs = initMsg j\\<rparr>", "unfolding initCfgList_def"], ["proof (prove)\nusing this:\n  cJ =\n  map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n   [0..<n + 1] !\n  j\n  j < n\n  length\n   (map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n     [0..<n + 1]) =\n  n + 1\n  1 \\<in># (-) (j - 1) \\<Longrightarrow> map ?f [1..<j - 1] ! 0 = ?f (1 + 0)\n  j < n + 1 - 0 \\<Longrightarrow> map ?f [0..<n + 1] ! j = ?f (0 + j)\n\ngoal (1 subgoal):\n 1. cJ = \\<lparr>states = start, msgs = initMsg j\\<rparr>", "by auto"], ["proof (state)\nthis:\n  cJ = \\<lparr>states = start, msgs = initMsg j\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence MsgCJ: \"msgs cJ = (\\<lambda>m::('p, 'v) message.\n    if \\<exists>p::'p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1::nat\n    else (0::nat))\""], ["proof (prove)\nusing this:\n  cJ = \\<lparr>states = start, msgs = initMsg j\\<rparr>\n\ngoal (1 subgoal):\n 1. msgs cJ =\n    (\\<lambda>m.\n        if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n        else 0)", "unfolding initMsg_def"], ["proof (prove)\nusing this:\n  cJ =\n  \\<lparr>states = start,\n     msgs =\n       \\<lambda>m.\n          if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n          else 0\\<rparr>\n\ngoal (1 subgoal):\n 1. msgs cJ =\n    (\\<lambda>m.\n        if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n        else 0)", "using AllPInProclist"], ["proof (prove)\nusing this:\n  cJ =\n  \\<lparr>states = start,\n     msgs =\n       \\<lambda>m.\n          if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n          else 0\\<rparr>\n  \\<forall>p. \\<exists>i<n. procList ! i = p\n\ngoal (1 subgoal):\n 1. msgs cJ =\n    (\\<lambda>m.\n        if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n        else 0)", "by auto"], ["proof (state)\nthis:\n  msgs cJ =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n      else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "define cJ1 where \"cJ1 = initCfgList ! (Suc j)\""], ["proof (state)\nthis:\n  cJ1 = initCfgList ! Suc j\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence cJ1Def: \"cJ1 = \\<lparr> states = start, msgs = initMsg (Suc j)\\<rparr>\""], ["proof (prove)\nusing this:\n  cJ1 = initCfgList ! Suc j\n\ngoal (1 subgoal):\n 1. cJ1 = \\<lparr>states = start, msgs = initMsg (Suc j)\\<rparr>", "using J(1) InitCfgLength nth_map_upt[of 0 \"j\" 1] \n    nth_map_upt[of \"j + 1\" \"n + 1\" 0]"], ["proof (prove)\nusing this:\n  cJ1 = initCfgList ! Suc j\n  j < n\n  length initCfgList = n + 1\n  1 \\<in># (-) j \\<Longrightarrow> map ?f [1..<j] ! 0 = ?f (1 + 0)\n  j + 1 < n + 1 - 0 \\<Longrightarrow>\n  map ?f [0..<n + 1] ! (j + 1) = ?f (0 + (j + 1))\n\ngoal (1 subgoal):\n 1. cJ1 = \\<lparr>states = start, msgs = initMsg (Suc j)\\<rparr>", "unfolding initCfgList_def"], ["proof (prove)\nusing this:\n  cJ1 =\n  map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n   [0..<n + 1] !\n  Suc j\n  j < n\n  length\n   (map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n     [0..<n + 1]) =\n  n + 1\n  1 \\<in># (-) j \\<Longrightarrow> map ?f [1..<j] ! 0 = ?f (1 + 0)\n  j + 1 < n + 1 - 0 \\<Longrightarrow>\n  map ?f [0..<n + 1] ! (j + 1) = ?f (0 + (j + 1))\n\ngoal (1 subgoal):\n 1. cJ1 = \\<lparr>states = start, msgs = initMsg (Suc j)\\<rparr>", "by auto"], ["proof (state)\nthis:\n  cJ1 = \\<lparr>states = start, msgs = initMsg (Suc j)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence MsgCJ1: \"msgs cJ1 = (\\<lambda>m::('p, 'v) message.\n    if \\<exists>p::'p. m = <p, inM \\<exists>i<(Suc j). procList ! i = p> then 1::nat\n    else (0::nat))\""], ["proof (prove)\nusing this:\n  cJ1 = \\<lparr>states = start, msgs = initMsg (Suc j)\\<rparr>\n\ngoal (1 subgoal):\n 1. msgs cJ1 =\n    (\\<lambda>m.\n        if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n        then 1 else 0)", "unfolding initMsg_def"], ["proof (prove)\nusing this:\n  cJ1 =\n  \\<lparr>states = start,\n     msgs =\n       \\<lambda>m.\n          if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n          then 1 else 0\\<rparr>\n\ngoal (1 subgoal):\n 1. msgs cJ1 =\n    (\\<lambda>m.\n        if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n        then 1 else 0)", "using AllPInProclist"], ["proof (prove)\nusing this:\n  cJ1 =\n  \\<lparr>states = start,\n     msgs =\n       \\<lambda>m.\n          if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n          then 1 else 0\\<rparr>\n  \\<forall>p. \\<exists>i<n. procList ! i = p\n\ngoal (1 subgoal):\n 1. msgs cJ1 =\n    (\\<lambda>m.\n        if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n        then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  msgs cJ1 =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p> then 1\n      else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have CJ1Init: \"initial cJ1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial cJ1", "using InitInitial[rule_format, of cJ1]  J(1) InitCfgLength"], ["proof (prove)\nusing this:\n  cJ1 \\<in> set initCfgList \\<Longrightarrow> initial cJ1\n  j < n\n  length initCfgList = n + 1\n\ngoal (1 subgoal):\n 1. initial cJ1", "unfolding cJ1_def"], ["proof (prove)\nusing this:\n  initCfgList ! Suc j \\<in> set initCfgList \\<Longrightarrow>\n  initial (initCfgList ! Suc j)\n  j < n\n  length initCfgList = n + 1\n\ngoal (1 subgoal):\n 1. initial (initCfgList ! Suc j)", "by auto"], ["proof (state)\nthis:\n  initial cJ1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence CJ1InitR: \"initReachable cJ1\""], ["proof (prove)\nusing this:\n  initial cJ1\n\ngoal (1 subgoal):\n 1. initReachable cJ1", "using InitialIsInitReachable"], ["proof (prove)\nusing this:\n  initial cJ1\n  initial ?c \\<Longrightarrow> initReachable ?c\n\ngoal (1 subgoal):\n 1. initReachable cJ1", "by simp"], ["proof (state)\nthis:\n  initReachable cJ1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have ValPj0: \"False \\<in> val[pJ, cJ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False \\<in> val[pJ,cJ]", "using J(2)"], ["proof (prove)\nusing this:\n  vUniform False (initCfgList ! j)\n\ngoal (1 subgoal):\n 1. False \\<in> val[pJ,cJ]", "unfolding cJ_def vUniform_def"], ["proof (prove)\nusing this:\n  initReachable (initCfgList ! j) \\<and>\n  (\\<forall>p. val[p,initCfgList ! j] = {False})\n\ngoal (1 subgoal):\n 1. False \\<in> val[pJ,initCfgList ! j]", "by auto"], ["proof (state)\nthis:\n  False \\<in> val[pJ,cJ]\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence \"\\<exists>cc. vDecided False cc \\<and> withoutQReachable cJ {pJ} cc\""], ["proof (prove)\nusing this:\n  False \\<in> val[pJ,cJ]\n\ngoal (1 subgoal):\n 1. \\<exists>cc.\n       (initReachable cc \\<and>\n        <\\<bottom>, outM False> \\<in># msgs cc) \\<and>\n       qReachable cJ (Proc - {pJ}) cc", "unfolding pSilDecVal_def"], ["proof (prove)\nusing this:\n  False\n  \\<in> {v. initReachable cJ \\<and>\n            (\\<exists>c'.\n                qReachable cJ (Proc - {pJ}) c' \\<and>\n                initReachable c' \\<and> <\\<bottom>, outM v> \\<in># msgs c')}\n\ngoal (1 subgoal):\n 1. \\<exists>cc.\n       (initReachable cc \\<and>\n        <\\<bottom>, outM False> \\<in># msgs cc) \\<and>\n       qReachable cJ (Proc - {pJ}) cc", "by auto"], ["proof (state)\nthis:\n  \\<exists>cc.\n     (initReachable cc \\<and> <\\<bottom>, outM False> \\<in># msgs cc) \\<and>\n     qReachable cJ (Proc - {pJ}) cc\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "then"], ["proof (chain)\npicking this:\n  \\<exists>cc.\n     (initReachable cc \\<and> <\\<bottom>, outM False> \\<in># msgs cc) \\<and>\n     qReachable cJ (Proc - {pJ}) cc", "obtain cc\n    where CC: \"vDecided False cc\" \"withoutQReachable cJ {pJ} cc\""], ["proof (prove)\nusing this:\n  \\<exists>cc.\n     (initReachable cc \\<and> <\\<bottom>, outM False> \\<in># msgs cc) \\<and>\n     qReachable cJ (Proc - {pJ}) cc\n\ngoal (1 subgoal):\n 1. (\\<And>cc.\n        \\<lbrakk>initReachable cc \\<and>\n                 <\\<bottom>, outM False> \\<in># msgs cc;\n         qReachable cJ (Proc - {pJ}) cc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  initReachable cc \\<and> <\\<bottom>, outM False> \\<in># msgs cc\n  qReachable cJ (Proc - {pJ}) cc\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence \"\\<exists>Q. qReachable cJ Q cc \\<and> Q = Proc - {pJ}\""], ["proof (prove)\nusing this:\n  initReachable cc \\<and> <\\<bottom>, outM False> \\<in># msgs cc\n  qReachable cJ (Proc - {pJ}) cc\n\ngoal (1 subgoal):\n 1. \\<exists>Q. qReachable cJ Q cc \\<and> Q = Proc - {pJ}", "by blast"], ["proof (state)\nthis:\n  \\<exists>Q. qReachable cJ Q cc \\<and> Q = Proc - {pJ}\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "then"], ["proof (chain)\npicking this:\n  \\<exists>Q. qReachable cJ Q cc \\<and> Q = Proc - {pJ}", "obtain ccQ where CCQ: \"qReachable cJ ccQ cc\" \"ccQ = Proc - {pJ}\""], ["proof (prove)\nusing this:\n  \\<exists>Q. qReachable cJ Q cc \\<and> Q = Proc - {pJ}\n\ngoal (1 subgoal):\n 1. (\\<And>ccQ.\n        \\<lbrakk>qReachable cJ ccQ cc; ccQ = Proc - {pJ}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  qReachable cJ ccQ cc\n  ccQ = Proc - {pJ}\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have StatescJcJ1: \"states cJ = states cJ1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states cJ = states cJ1", "using  cJ_def cJ1_def initCfgList_def"], ["proof (prove)\nusing this:\n  cJ = initCfgList ! j\n  cJ1 = initCfgList ! Suc j\n  initCfgList =\n  map (\\<lambda>ind. \\<lparr>states = start, msgs = initMsg ind\\<rparr>)\n   [0..<n + 1]\n\ngoal (1 subgoal):\n 1. states cJ = states cJ1", "by (metis InitCfgLength InitCfgStart J(1) Suc_eq_plus1 Suc_mono \n      less_SucI nth_mem)"], ["proof (state)\nthis:\n  states cJ = states cJ1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have Distinct: \"\\<And> i . distinct procList \\<Longrightarrow> i<j \n    \\<Longrightarrow> procList ! i = procList ! j \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>distinct procList; i < j;\n        procList ! i = procList ! j\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis J(1) ProcList(1) distinct_conv_nth less_trans \n       not_less_iff_gr_or_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct procList; ?i < j; procList ! ?i = procList ! j\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have A: \"msgs cJ (<pJ ,inM False>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cJ <pJ, inM False> = 1", "using pJ_def ProcList J(1) MsgCJ"], ["proof (prove)\nusing this:\n  pJ = procList ! j\n  length procList = n\n  set procList = Proc\n  distinct procList\n  j < n\n  msgs cJ =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n      else 0)\n\ngoal (1 subgoal):\n 1. msgs cJ <pJ, inM False> = 1", "using Distinct"], ["proof (prove)\nusing this:\n  pJ = procList ! j\n  length procList = n\n  set procList = Proc\n  distinct procList\n  j < n\n  msgs cJ =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n      else 0)\n  \\<lbrakk>distinct procList; ?i < j; procList ! ?i = procList ! j\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. msgs cJ <pJ, inM False> = 1", "by auto"], ["proof (state)\nthis:\n  msgs cJ <pJ, inM False> = 1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have B: \"msgs cJ1 (<pJ ,inM True>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cJ1 <pJ, inM True> = 1", "using pJ_def ProcList J(1) MsgCJ1"], ["proof (prove)\nusing this:\n  pJ = procList ! j\n  length procList = n\n  set procList = Proc\n  distinct procList\n  j < n\n  msgs cJ1 =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p> then 1\n      else 0)\n\ngoal (1 subgoal):\n 1. msgs cJ1 <pJ, inM True> = 1", "by auto"], ["proof (state)\nthis:\n  msgs cJ1 <pJ, inM True> = 1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have C: \"msgs cJ (<pJ ,inM True>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cJ <pJ, inM True> = 0", "using pJ_def ProcList J(1) MsgCJ"], ["proof (prove)\nusing this:\n  pJ = procList ! j\n  length procList = n\n  set procList = Proc\n  distinct procList\n  j < n\n  msgs cJ =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n      else 0)\n\ngoal (1 subgoal):\n 1. msgs cJ <pJ, inM True> = 0", "using Distinct"], ["proof (prove)\nusing this:\n  pJ = procList ! j\n  length procList = n\n  set procList = Proc\n  distinct procList\n  j < n\n  msgs cJ =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n      else 0)\n  \\<lbrakk>distinct procList; ?i < j; procList ! ?i = procList ! j\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. msgs cJ <pJ, inM True> = 0", "by auto"], ["proof (state)\nthis:\n  msgs cJ <pJ, inM True> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have D: \"msgs cJ1 (<pJ ,inM False>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cJ1 <pJ, inM False> = 0", "using pJ_def ProcList J(1) MsgCJ1"], ["proof (prove)\nusing this:\n  pJ = procList ! j\n  length procList = n\n  set procList = Proc\n  distinct procList\n  j < n\n  msgs cJ1 =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p> then 1\n      else 0)\n\ngoal (1 subgoal):\n 1. msgs cJ1 <pJ, inM False> = 0", "by auto"], ["proof (state)\nthis:\n  msgs cJ1 <pJ, inM False> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "define msgsCJ' where\n    \"msgsCJ' m = (if m = (<pJ ,inM False>) \\<or> m = (<pJ ,inM True>) then 0 else (msgs cJ) m)\" for m"], ["proof (state)\nthis:\n  msgsCJ' ?m =\n  (if ?m = <pJ, inM False> \\<or> ?m = <pJ, inM True> then 0 else msgs cJ ?m)\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have MsgsCJ': \"msgsCJ' = ((msgs cJ) -# (<pJ ,inM False>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgsCJ' = msgs cJ -# <pJ, inM False>", "using A C msgsCJ'_def"], ["proof (prove)\nusing this:\n  msgs cJ <pJ, inM False> = 1\n  msgs cJ <pJ, inM True> = 0\n  msgsCJ' ?m =\n  (if ?m = <pJ, inM False> \\<or> ?m = <pJ, inM True> then 0 else msgs cJ ?m)\n\ngoal (1 subgoal):\n 1. msgsCJ' = msgs cJ -# <pJ, inM False>", "by auto"], ["proof (state)\nthis:\n  msgsCJ' = msgs cJ -# <pJ, inM False>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have AllOther: \"\\<forall> m . msgsCJ' m = ((msgs cJ1) -# (<pJ ,inM True>)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m. msgsCJ' m = (msgs cJ1 -# <pJ, inM True>) m", "using B D MsgCJ1 MsgCJ  J(1) N ProcList AllPInProclist"], ["proof (prove)\nusing this:\n  msgs cJ1 <pJ, inM True> = 1\n  msgs cJ1 <pJ, inM False> = 0\n  msgs cJ1 =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p> then 1\n      else 0)\n  msgs cJ =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n      else 0)\n  j < n\n  n = card Proc\n  length procList = n\n  set procList = Proc\n  distinct procList\n  \\<forall>p. \\<exists>i<n. procList ! i = p\n\ngoal (1 subgoal):\n 1. \\<forall>m. msgsCJ' m = (msgs cJ1 -# <pJ, inM True>) m", "unfolding msgsCJ'_def pJ_def"], ["proof (prove)\nusing this:\n  msgs cJ1 <procList ! j, inM True> = 1\n  msgs cJ1 <procList ! j, inM False> = 0\n  msgs cJ1 =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p> then 1\n      else 0)\n  msgs cJ =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n      else 0)\n  j < n\n  n = card Proc\n  length procList = n\n  set procList = Proc\n  distinct procList\n  \\<forall>p. \\<exists>i<n. procList ! i = p\n\ngoal (1 subgoal):\n 1. \\<forall>m.\n       (if m = <procList ! j, inM False> \\<or> m = <procList ! j, inM True>\n        then 0 else msgs cJ m) =\n       (msgs cJ1 -# <procList ! j, inM True>) m", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>msgs cJ1 <procList ! j, inM True> = 1;\n        msgs cJ1 <procList ! j, inM False> = 0;\n        msgs cJ1 =\n        (\\<lambda>m.\n            if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n            then 1 else 0);\n        msgs cJ =\n        (\\<lambda>m.\n            if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p>\n            then 1 else 0);\n        j < card Proc; length procList = card Proc; set procList = Proc;\n        distinct procList;\n        \\<forall>p. \\<exists>i<card Proc. procList ! i = p;\n        n = card Proc\\<rbrakk>\n       \\<Longrightarrow> (if m = <procList ! j, inM False> \\<or>\n                             m = <procList ! j, inM True>\n                          then 0 else msgs cJ m) =\n                         (msgs cJ1 -# <procList ! j, inM True>) m", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>msgs cJ1 <procList ! j, inM True> = 1;\n        msgs cJ1 <procList ! j, inM False> = 0;\n        msgs cJ1 =\n        (\\<lambda>m.\n            if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n            then 1 else 0);\n        msgs cJ =\n        (\\<lambda>m.\n            if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p>\n            then 1 else 0);\n        j < card Proc; length procList = card Proc; set procList = Proc;\n        distinct procList;\n        \\<forall>p. \\<exists>i<card Proc. procList ! i = p;\n        n = card Proc\\<rbrakk>\n       \\<Longrightarrow> (if m = <procList ! j, inM False> \\<or>\n                             m = <procList ! j, inM True>\n                          then 0 else msgs cJ m) =\n                         (msgs cJ1 -# <procList ! j, inM True>) m", "show \"(if m = <procList ! j, inM False> \\<or> \n        m = <procList ! j, inM True> then 0 else msgs cJ m) \n      = (msgs cJ1 -# <procList ! j, inM True>) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if m = <procList ! j, inM False> \\<or> m = <procList ! j, inM True>\n     then 0 else msgs cJ m) =\n    (msgs cJ1 -# <procList ! j, inM True>) m", "proof(cases \"m = <procList ! j, inM False> \\<or> m \n      = <procList ! j, inM True>\",auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>m = <procList ! j, inM False>;\n     <procList ! j, inM False> \\<in># msgs cJ1\\<rbrakk>\n    \\<Longrightarrow> False\n 2. m = <procList ! j, inM True> \\<Longrightarrow>\n    msgs cJ1 <procList ! j, inM True> \\<le> Suc 0\n 3. \\<lbrakk>m \\<noteq> <procList ! j, inM False>;\n     m \\<noteq> <procList ! j, inM True>\\<rbrakk>\n    \\<Longrightarrow> msgs cJ m = msgs cJ1 m", "assume \"0 < (msgs cJ1 <procList ! j, inM False>)\""], ["proof (state)\nthis:\n  <procList ! j, inM False> \\<in># msgs cJ1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>m = <procList ! j, inM False>;\n     <procList ! j, inM False> \\<in># msgs cJ1\\<rbrakk>\n    \\<Longrightarrow> False\n 2. m = <procList ! j, inM True> \\<Longrightarrow>\n    msgs cJ1 <procList ! j, inM True> \\<le> Suc 0\n 3. \\<lbrakk>m \\<noteq> <procList ! j, inM False>;\n     m \\<noteq> <procList ! j, inM True>\\<rbrakk>\n    \\<Longrightarrow> msgs cJ m = msgs cJ1 m", "thus False"], ["proof (prove)\nusing this:\n  <procList ! j, inM False> \\<in># msgs cJ1\n\ngoal (1 subgoal):\n 1. False", "using D pJ_def"], ["proof (prove)\nusing this:\n  <procList ! j, inM False> \\<in># msgs cJ1\n  msgs cJ1 <pJ, inM False> = 0\n  pJ = procList ! j\n\ngoal (1 subgoal):\n 1. False", "by (metis less_nat_zero_code)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. m = <procList ! j, inM True> \\<Longrightarrow>\n    msgs cJ1 <procList ! j, inM True> \\<le> Suc 0\n 2. \\<lbrakk>m \\<noteq> <procList ! j, inM False>;\n     m \\<noteq> <procList ! j, inM True>\\<rbrakk>\n    \\<Longrightarrow> msgs cJ m = msgs cJ1 m", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. m = <procList ! j, inM True> \\<Longrightarrow>\n    msgs cJ1 <procList ! j, inM True> \\<le> Suc 0\n 2. \\<lbrakk>m \\<noteq> <procList ! j, inM False>;\n     m \\<noteq> <procList ! j, inM True>\\<rbrakk>\n    \\<Longrightarrow> msgs cJ m = msgs cJ1 m", "show \"msgs cJ1 <procList ! j, inM True> \\<le> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs cJ1 <procList ! j, inM True> \\<le> Suc 0", "by (metis B One_nat_def order_refl pJ_def)"], ["proof (state)\nthis:\n  msgs cJ1 <procList ! j, inM True> \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> <procList ! j, inM False>;\n     m \\<noteq> <procList ! j, inM True>\\<rbrakk>\n    \\<Longrightarrow> msgs cJ m = msgs cJ1 m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> <procList ! j, inM False>;\n     m \\<noteq> <procList ! j, inM True>\\<rbrakk>\n    \\<Longrightarrow> msgs cJ m = msgs cJ1 m", "assume AssumpMJ: \"m \\<noteq> <procList ! j, inM False>\" \n                       \"m \\<noteq> <procList ! j, inM True>\""], ["proof (state)\nthis:\n  m \\<noteq> <procList ! j, inM False>\n  m \\<noteq> <procList ! j, inM True>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> <procList ! j, inM False>;\n     m \\<noteq> <procList ! j, inM True>\\<rbrakk>\n    \\<Longrightarrow> msgs cJ m = msgs cJ1 m", "hence \"(if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1 else 0)\n           = (if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p> then 1 else 0)\""], ["proof (prove)\nusing this:\n  m \\<noteq> <procList ! j, inM False>\n  m \\<noteq> <procList ! j, inM True>\n\ngoal (1 subgoal):\n 1. (if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1::'a\n     else (0::'a)) =\n    (if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n     then 1::'a else (0::'a))", "by (induct m, auto simp add: less_Suc_eq)"], ["proof (state)\nthis:\n  (if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1::?'a1\n   else (0::?'a1)) =\n  (if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n   then 1::?'a1 else (0::?'a1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<noteq> <procList ! j, inM False>;\n     m \\<noteq> <procList ! j, inM True>\\<rbrakk>\n    \\<Longrightarrow> msgs cJ m = msgs cJ1 m", "thus \"msgs cJ m = msgs cJ1 m\""], ["proof (prove)\nusing this:\n  (if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1::?'a1\n   else (0::?'a1)) =\n  (if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n   then 1::?'a1 else (0::?'a1))\n\ngoal (1 subgoal):\n 1. msgs cJ m = msgs cJ1 m", "using MsgCJ MsgCJ1"], ["proof (prove)\nusing this:\n  (if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1::?'a1\n   else (0::?'a1)) =\n  (if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p>\n   then 1::?'a1 else (0::?'a1))\n  msgs cJ =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<j. procList ! i = p> then 1\n      else 0)\n  msgs cJ1 =\n  (\\<lambda>m.\n      if \\<exists>p. m = <p, inM \\<exists>i<Suc j. procList ! i = p> then 1\n      else 0)\n\ngoal (1 subgoal):\n 1. msgs cJ m = msgs cJ1 m", "by auto"], ["proof (state)\nthis:\n  msgs cJ m = msgs cJ1 m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if m = <procList ! j, inM False> \\<or> m = <procList ! j, inM True>\n   then 0 else msgs cJ m) =\n  (msgs cJ1 -# <procList ! j, inM True>) m\n\ngoal:\nNo subgoals!", "qed \\<comment> \\<open>of AllOther\\<close>"], ["proof (state)\nthis:\n  \\<forall>m. msgsCJ' m = (msgs cJ1 -# <pJ, inM True>) m\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "with MsgsCJ'"], ["proof (chain)\npicking this:\n  msgsCJ' = msgs cJ -# <pJ, inM False>\n  \\<forall>m. msgsCJ' m = (msgs cJ1 -# <pJ, inM True>) m", "have InitMsgs: \"((msgs cJ) -# (<pJ ,inM False>)) \n    = ((msgs cJ1) -# (<pJ, inM True>))\""], ["proof (prove)\nusing this:\n  msgsCJ' = msgs cJ -# <pJ, inM False>\n  \\<forall>m. msgsCJ' m = (msgs cJ1 -# <pJ, inM True>) m\n\ngoal (1 subgoal):\n 1. msgs cJ -# <pJ, inM False> = msgs cJ1 -# <pJ, inM True>", "by simp"], ["proof (state)\nthis:\n  msgs cJ -# <pJ, inM False> = msgs cJ1 -# <pJ, inM True>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence F: \"(((msgs cJ) -# (<pJ ,inM False>)) \\<union># ({#<pJ, inM True>})) =\n    (((msgs cJ1) -# (<pJ, inM True>))  \\<union># ({#<pJ, inM True>}))\""], ["proof (prove)\nusing this:\n  msgs cJ -# <pJ, inM False> = msgs cJ1 -# <pJ, inM True>\n\ngoal (1 subgoal):\n 1. msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n    msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> }", "by (metis (full_types))"], ["proof (state)\nthis:\n  msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n  msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> }\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "from B"], ["proof (chain)\npicking this:\n  msgs cJ1 <pJ, inM True> = 1", "have One: \"(((msgs cJ1) -# (<pJ, inM True>)) \n    \\<union># ({#<pJ, inM True>})) <pJ, inM True> = 1\""], ["proof (prove)\nusing this:\n  msgs cJ1 <pJ, inM True> = 1\n\ngoal (1 subgoal):\n 1. (msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> })\n     <pJ, inM True> =\n    1", "by simp"], ["proof (state)\nthis:\n  (msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> })\n   <pJ, inM True> =\n  1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "with B"], ["proof (chain)\npicking this:\n  msgs cJ1 <pJ, inM True> = 1\n  (msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> })\n   <pJ, inM True> =\n  1", "have \"\\<forall> m :: ('p, 'v) message . (msgs cJ1) m \n    = (((msgs cJ1) -# (<pJ, inM True>))  \\<union># \n    ({#<pJ, inM True>})) m\""], ["proof (prove)\nusing this:\n  msgs cJ1 <pJ, inM True> = 1\n  (msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> })\n   <pJ, inM True> =\n  1\n\ngoal (1 subgoal):\n 1. \\<forall>m.\n       msgs cJ1 m =\n       (msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> }) m", "by simp"], ["proof (state)\nthis:\n  \\<forall>m.\n     msgs cJ1 m =\n     (msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> }) m\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "with B"], ["proof (chain)\npicking this:\n  msgs cJ1 <pJ, inM True> = 1\n  \\<forall>m.\n     msgs cJ1 m =\n     (msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> }) m", "have \"(((msgs cJ1) -# (<pJ, inM True>))  \\<union># ({#<pJ, inM True>})) \n    = (msgs cJ1)\""], ["proof (prove)\nusing this:\n  msgs cJ1 <pJ, inM True> = 1\n  \\<forall>m.\n     msgs cJ1 m =\n     (msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> }) m\n\ngoal (1 subgoal):\n 1. msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> } = msgs cJ1", "by simp"], ["proof (state)\nthis:\n  msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> } = msgs cJ1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "with F"], ["proof (chain)\npicking this:\n  msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n  msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> }\n  msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> } = msgs cJ1", "have InitMsgs: \"(((msgs cJ) -# (<pJ ,inM False>)) \n    \\<union># ({#<pJ, inM True>})) = (msgs cJ1)\""], ["proof (prove)\nusing this:\n  msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n  msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> }\n  msgs cJ1 -# <pJ, inM True> \\<union># {# <pJ, inM True> } = msgs cJ1\n\ngoal (1 subgoal):\n 1. msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1", "by simp"], ["proof (state)\nthis:\n  msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "define cc' where \"cc' = \\<lparr>states = (states cc),\n    msgs = (((msgs cc) -# (<pJ,inM False>)) \\<union># {# (<pJ, inM True>)})\\<rparr>\""], ["proof (state)\nthis:\n  cc' =\n  \\<lparr>states = states cc,\n     msgs = msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "have \"\\<lbrakk>qReachable cJ ccQ cc; ccQ = Proc - {pJ}; \n    (((msgs cJ) -# (<pJ ,inM False>)) \\<union># ({#<pJ, inM True>})) \n      = (msgs cJ1); states cJ = states cJ1\\<rbrakk> \n      \\<Longrightarrow> withoutQReachable cJ1 {pJ} \\<lparr>states = (states cc), \n      msgs = (((msgs cc) -# (<pJ,inM False>)) \\<union># {# (<pJ, inM True>)}) \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>qReachable cJ ccQ cc; ccQ = Proc - {pJ};\n     msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1;\n     states cJ = states cJ1\\<rbrakk>\n    \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                       \\<lparr>states = states cc,\n                          msgs =\n                            msgs\n                             cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "proof (induct rule: qReachable.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg1,\n                             msgs =\n                               msgs\n                                cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "fix cfg1::\"('p, 'v, 's) configuration\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg1,\n                             msgs =\n                               msgs\n                                cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "fix Q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg1,\n                             msgs =\n                               msgs\n                                cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "assume \n        Assm: \"(((msgs cfg1) -#(<pJ, inM False>)) \\<union># {# <pJ, inM True> })\n        = msgs cJ1\" \n        \"states cfg1 = states cJ1\""], ["proof (state)\nthis:\n  msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cfg1 = states cJ1\n\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg1,\n                             msgs =\n                               msgs\n                                cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "hence CJ1: \"cJ1 = \\<lparr>states = states cfg1, \n        msgs = ((msgs cfg1) -# <pJ, inM False>) \\<union># {# <pJ, inM True> }\\<rparr>\""], ["proof (prove)\nusing this:\n  msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cfg1 = states cJ1\n\ngoal (1 subgoal):\n 1. cJ1 =\n    \\<lparr>states = states cfg1,\n       msgs =\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "by auto"], ["proof (state)\nthis:\n  cJ1 =\n  \\<lparr>states = states cfg1,\n     msgs =\n       msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg1,\n                             msgs =\n                               msgs\n                                cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "have \"qReachable cJ1  (Proc - {pJ}) cJ1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qReachable cJ1 (Proc - {pJ}) cJ1", "using qReachable.simps"], ["proof (prove)\nusing this:\n  qReachable ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>cfg1 Q.\n       ?a1.0 = cfg1 \\<and> ?a2.0 = Q \\<and> ?a3.0 = cfg1) \\<or>\n   (\\<exists>cfg1 Q cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = Q \\<and>\n       ?a3.0 = cfg3 \\<and>\n       qReachable cfg1 Q cfg2 \\<and>\n       cfg2 \\<turnstile> msg \\<mapsto> cfg3 \\<and>\n       (\\<exists>p\\<in>Q. isReceiverOf p msg)))\n\ngoal (1 subgoal):\n 1. qReachable cJ1 (Proc - {pJ}) cJ1", "by blast"], ["proof (state)\nthis:\n  qReachable cJ1 (Proc - {pJ}) cJ1\n\ngoal (2 subgoals):\n 1. \\<And>cfg1 Q.\n       \\<lbrakk>Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg1,\n                             msgs =\n                               msgs\n                                cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "with Assm"], ["proof (chain)\npicking this:\n  msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cfg1 = states cJ1\n  qReachable cJ1 (Proc - {pJ}) cJ1", "show \"qReachable cJ1 (Proc - {pJ})\n        \\<lparr>states = states cfg1, msgs = ((msgs cfg1) -# <pJ, inM False>) \n        \\<union># {# <pJ, inM True> }\\<rparr>\""], ["proof (prove)\nusing this:\n  msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cfg1 = states cJ1\n  qReachable cJ1 (Proc - {pJ}) cJ1\n\ngoal (1 subgoal):\n 1. qReachable cJ1 (Proc - {pJ})\n     \\<lparr>states = states cfg1,\n        msgs =\n          msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "using CJ1"], ["proof (prove)\nusing this:\n  msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cfg1 = states cJ1\n  qReachable cJ1 (Proc - {pJ}) cJ1\n  cJ1 =\n  \\<lparr>states = states cfg1,\n     msgs =\n       msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. qReachable cJ1 (Proc - {pJ})\n     \\<lparr>states = states cfg1,\n        msgs =\n          msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "by blast"], ["proof (state)\nthis:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cfg1,\n      msgs =\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "fix cfg1 cfg2 cfg3 :: \"('p, 'v, 's) configuration\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "fix msg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "assume Q: \"Q = (Proc - {pJ})\""], ["proof (state)\nthis:\n  Q = Proc - {pJ}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "assume \"(((msgs cfg1) -# <pJ, inM False>) \\<union># {# <pJ, inM True> }) \n        = (msgs cJ1)\"\n        \"(states cfg1) = (states cJ1)\"\n        \"Q = (Proc - {pJ}) \\<Longrightarrow>\n          (((msgs cfg1) -# <pJ, inM False>) \\<union># {# <pJ, inM True> }) \n            = (msgs cJ1) \n          \\<Longrightarrow> (states cfg1) = (states cJ1) \n          \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n          \\<lparr>states = (states cfg2),\n          msgs = (((msgs cfg2) -# <pJ, inM False>) \\<union># {# <pJ, inM True> })\\<rparr>\""], ["proof (state)\nthis:\n  msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cfg1 = states cJ1\n  \\<lbrakk>Q = Proc - {pJ};\n   msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1;\n   states cfg1 = states cJ1\\<rbrakk>\n  \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                     \\<lparr>states = states cfg2,\n                        msgs =\n                          msgs\n                           cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "with Q"], ["proof (chain)\npicking this:\n  Q = Proc - {pJ}\n  msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cfg1 = states cJ1\n  \\<lbrakk>Q = Proc - {pJ};\n   msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1;\n   states cfg1 = states cJ1\\<rbrakk>\n  \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                     \\<lparr>states = states cfg2,\n                        msgs =\n                          msgs\n                           cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "have Cfg2: \n        \"qReachable cJ1 (Proc - {pJ}) \\<lparr>states = (states cfg2),\n        msgs = (((msgs cfg2) -# <pJ, inM False>) \\<union># {# <pJ, inM True> })\\<rparr>\""], ["proof (prove)\nusing this:\n  Q = Proc - {pJ}\n  msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cfg1 = states cJ1\n  \\<lbrakk>Q = Proc - {pJ};\n   msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1;\n   states cfg1 = states cJ1\\<rbrakk>\n  \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                     \\<lparr>states = states cfg2,\n                        msgs =\n                          msgs\n                           cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. qReachable cJ1 (Proc - {pJ})\n     \\<lparr>states = states cfg2,\n        msgs =\n          msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "by simp"], ["proof (state)\nthis:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "assume \"qReachable cfg1 Q cfg2\" \n        \"cfg2 \\<turnstile> msg \\<mapsto> cfg3\"\n        \"\\<exists>(p::'p)\\<in>Q. (isReceiverOf p msg)\""], ["proof (state)\nthis:\n  qReachable cfg1 Q cfg2\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Q. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "with Q"], ["proof (chain)\npicking this:\n  Q = Proc - {pJ}\n  qReachable cfg1 Q cfg2\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Q. isReceiverOf p msg", "have Step: \"qReachable cfg1 (Proc - {pJ}) cfg2\" \n        \"cfg2 \\<turnstile> msg \\<mapsto> cfg3\"\n        \"\\<exists>(p::'p)\\<in>(Proc - {pJ}). (isReceiverOf p msg)\""], ["proof (prove)\nusing this:\n  Q = Proc - {pJ}\n  qReachable cfg1 Q cfg2\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Q. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. qReachable cfg1 (Proc - {pJ}) cfg2 &&&\n    cfg2 \\<turnstile> msg \\<mapsto> cfg3 &&&\n    \\<exists>p\\<in>Proc - {pJ}. isReceiverOf p msg", "by auto"], ["proof (state)\nthis:\n  qReachable cfg1 (Proc - {pJ}) cfg2\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Proc - {pJ}. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "then"], ["proof (chain)\npicking this:\n  qReachable cfg1 (Proc - {pJ}) cfg2\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Proc - {pJ}. isReceiverOf p msg", "obtain p where P: \"p\\<in>(Proc - {pJ})\" \"isReceiverOf p msg\""], ["proof (prove)\nusing this:\n  qReachable cfg1 (Proc - {pJ}) cfg2\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  \\<exists>p\\<in>Proc - {pJ}. isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p \\<in> Proc - {pJ}; isReceiverOf p msg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p \\<in> Proc - {pJ}\n  isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "hence NotEq: \"pJ \\<noteq> p\""], ["proof (prove)\nusing this:\n  p \\<in> Proc - {pJ}\n  isReceiverOf p msg\n\ngoal (1 subgoal):\n 1. pJ \\<noteq> p", "by blast"], ["proof (state)\nthis:\n  pJ \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "with UniqueReceiverOf[of \"p\" \"msg\" \"pJ\"] P(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>isReceiverOf p msg; pJ \\<noteq> p\\<rbrakk>\n  \\<Longrightarrow> \\<not> isReceiverOf pJ msg\n  isReceiverOf p msg\n  pJ \\<noteq> p", "have notRec: \"\\<not> (isReceiverOf pJ msg)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>isReceiverOf p msg; pJ \\<noteq> p\\<rbrakk>\n  \\<Longrightarrow> \\<not> isReceiverOf pJ msg\n  isReceiverOf p msg\n  pJ \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<not> isReceiverOf pJ msg", "by blast"], ["proof (state)\nthis:\n  \\<not> isReceiverOf pJ msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "hence MsgNoIn:\"msg \\<noteq>  <pJ, inM False> \\<and> msg \\<noteq>  <pJ, inM True>\""], ["proof (prove)\nusing this:\n  \\<not> isReceiverOf pJ msg\n\ngoal (1 subgoal):\n 1. msg \\<noteq> <pJ, inM False> \\<and> msg \\<noteq> <pJ, inM True>", "by auto"], ["proof (state)\nthis:\n  msg \\<noteq> <pJ, inM False> \\<and> msg \\<noteq> <pJ, inM True>\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "from Step(2)"], ["proof (chain)\npicking this:\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3", "have \"enabled cfg2 msg\""], ["proof (prove)\nusing this:\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n\ngoal (1 subgoal):\n 1. enabled cfg2 msg", "using steps.simps"], ["proof (prove)\nusing this:\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  ?cfg1.0 \\<turnstile> <?p, inM ?v> \\<mapsto> ?cfg2.0 =\n  ((\\<forall>s.\n       (s = ?p \\<longrightarrow>\n        states ?cfg2.0 ?p = trans ?p (states ?cfg1.0 ?p) (Bool ?v)) \\<and>\n       (s \\<noteq> ?p \\<longrightarrow>\n        states ?cfg2.0 s = states ?cfg1.0 s)) \\<and>\n   enabled ?cfg1.0 <?p, inM ?v> \\<and>\n   msgs ?cfg2.0 =\n   sends ?p (states ?cfg1.0 ?p)\n    (Bool ?v) \\<union># msgs ?cfg1.0 -# <?p, inM ?v>)\n  ?cfg1.0 \\<turnstile> <?p, ?v> \\<mapsto> ?cfg2.0 =\n  ((\\<forall>s.\n       (s = ?p \\<longrightarrow>\n        states ?cfg2.0 ?p = trans ?p (states ?cfg1.0 ?p) (Value ?v)) \\<and>\n       (s \\<noteq> ?p \\<longrightarrow>\n        states ?cfg2.0 s = states ?cfg1.0 s)) \\<and>\n   enabled ?cfg1.0 <?p, ?v> \\<and>\n   msgs ?cfg2.0 =\n   sends ?p (states ?cfg1.0 ?p)\n    (Value ?v) \\<union># msgs ?cfg1.0 -# <?p, ?v>)\n  ?cfg1.0 \\<turnstile> <\\<bottom>, outM ?v> \\<mapsto> ?cfg2.0 = False\n\ngoal (1 subgoal):\n 1. enabled cfg2 msg", "by (auto, cases msg, auto)"], ["proof (state)\nthis:\n  enabled cfg2 msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "hence MsgEnabled: \"enabled \\<lparr>states = (states cfg2),\n        msgs = (((msgs cfg2) -# <pJ, inM False>) \n        \\<union># {# <pJ, inM True> })\\<rparr> msg\""], ["proof (prove)\nusing this:\n  enabled cfg2 msg\n\ngoal (1 subgoal):\n 1. enabled\n     \\<lparr>states = states cfg2,\n        msgs =\n          msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n     msg", "using MsgNoIn"], ["proof (prove)\nusing this:\n  enabled cfg2 msg\n  msg \\<noteq> <pJ, inM False> \\<and> msg \\<noteq> <pJ, inM True>\n\ngoal (1 subgoal):\n 1. enabled\n     \\<lparr>states = states cfg2,\n        msgs =\n          msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n     msg", "by (simp add: enabled_def)"], ["proof (state)\nthis:\n  enabled\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n   msg\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "have  \"\\<lparr>states = (states cfg2),\n              msgs = (((msgs cfg2) -# <pJ, inM False>) \n              \\<union># {# <pJ, inM True> })\\<rparr>\n                \\<turnstile> msg \\<mapsto> \\<lparr>states = (states cfg3),\n                msgs = (((msgs cfg3) -# <pJ, inM False>) \n                \\<union># {# <pJ, inM True> })\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>states = states cfg2,\n       msgs =\n         msgs\n          cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                 states cfg3,\n                          msgs =\n                            msgs\n                             cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "proof (cases msg)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       msg = <x11, inM x12> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>x2.\n       msg = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 3. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "fix p' bool"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       msg = <x11, inM x12> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>x2.\n       msg = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 3. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "assume MsgIn :\"(msg = <p', inM bool>)\""], ["proof (state)\nthis:\n  msg = <p', inM bool>\n\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       msg = <x11, inM x12> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>x2.\n       msg = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 3. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "with noInSends MsgIn MsgNoIn MsgEnabled"], ["proof (chain)\npicking this:\n  sends ?p ?s ?m <?p2.0, inM ?v> = 0\n  msg = <p', inM bool>\n  msg \\<noteq> <pJ, inM False> \\<and> msg \\<noteq> <pJ, inM True>\n  enabled\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n   msg\n  msg = <p', inM bool>", "show \"\\<lparr>states = (states cfg2),\n          msgs = (((msgs cfg2) -# <pJ, inM False>) \\<union># {# <pJ, inM True> })\\<rparr>\n            \\<turnstile> msg \\<mapsto> \\<lparr>states = (states cfg3),\n              msgs = (((msgs cfg3) -# <pJ, inM False>) \n              \\<union># {# <pJ, inM True> })\\<rparr>\""], ["proof (prove)\nusing this:\n  sends ?p ?s ?m <?p2.0, inM ?v> = 0\n  msg = <p', inM bool>\n  msg \\<noteq> <pJ, inM False> \\<and> msg \\<noteq> <pJ, inM True>\n  enabled\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n   msg\n  msg = <p', inM bool>\n\ngoal (1 subgoal):\n 1. \\<lparr>states = states cfg2,\n       msgs =\n         msgs\n          cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                 states cfg3,\n                          msgs =\n                            msgs\n                             cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "using steps.simps(1) Step(2) select_convs(2) select_convs(1)"], ["proof (prove)\nusing this:\n  sends ?p ?s ?m <?p2.0, inM ?v> = 0\n  msg = <p', inM bool>\n  msg \\<noteq> <pJ, inM False> \\<and> msg \\<noteq> <pJ, inM True>\n  enabled\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n   msg\n  msg = <p', inM bool>\n  ?cfg1.0 \\<turnstile> <?p, inM ?v> \\<mapsto> ?cfg2.0 =\n  ((\\<forall>s.\n       (s = ?p \\<longrightarrow>\n        states ?cfg2.0 ?p = trans ?p (states ?cfg1.0 ?p) (Bool ?v)) \\<and>\n       (s \\<noteq> ?p \\<longrightarrow>\n        states ?cfg2.0 s = states ?cfg1.0 s)) \\<and>\n   enabled ?cfg1.0 <?p, inM ?v> \\<and>\n   msgs ?cfg2.0 =\n   sends ?p (states ?cfg1.0 ?p)\n    (Bool ?v) \\<union># msgs ?cfg1.0 -# <?p, inM ?v>)\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  msgs \\<lparr>states = ?states, msgs = ?msgs, \\<dots> = ?more\\<rparr> =\n  ?msgs\n  states \\<lparr>states = ?states, msgs = ?msgs, \\<dots> = ?more\\<rparr> =\n  ?states\n\ngoal (1 subgoal):\n 1. \\<lparr>states = states cfg2,\n       msgs =\n         msgs\n          cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                 states cfg3,\n                          msgs =\n                            msgs\n                             cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "by auto"], ["proof (state)\nthis:\n  \\<lparr>states = states cfg2,\n     msgs =\n       msgs\n        cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                               states cfg3,\n                        msgs =\n                          msgs\n                           cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       msg = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       msg = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "fix bool"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       msg = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "assume \"(msg = <\\<bottom>, outM bool>)\""], ["proof (state)\nthis:\n  msg = <\\<bottom>, outM bool>\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       msg = <\\<bottom>, outM x2> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n 2. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "thus \"\\<lparr>states = (states cfg2),\n          msgs = (((msgs cfg2) -# <pJ, inM False>) \\<union># {# <pJ, inM True> })\\<rparr>\n            \\<turnstile> msg \\<mapsto> \\<lparr>states = (states cfg3),\n              msgs = (((msgs cfg3) -# <pJ, inM False>) \n              \\<union># {# <pJ, inM True> })\\<rparr>\""], ["proof (prove)\nusing this:\n  msg = <\\<bottom>, outM bool>\n\ngoal (1 subgoal):\n 1. \\<lparr>states = states cfg2,\n       msgs =\n         msgs\n          cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                 states cfg3,\n                          msgs =\n                            msgs\n                             cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "using steps_def Step(2)"], ["proof (prove)\nusing this:\n  msg = <\\<bottom>, outM bool>\n  steps \\<equiv>\n  \\<lambda>uu uua.\n     rec_message\n      (\\<lambda>p v cfg1 cfg2.\n          (\\<forall>s.\n              (s = p \\<longrightarrow>\n               states cfg2 p = trans p (states cfg1 p) (Bool v)) \\<and>\n              (s \\<noteq> p \\<longrightarrow>\n               states cfg2 s = states cfg1 s)) \\<and>\n          enabled cfg1 <p, inM v> \\<and>\n          msgs cfg2 =\n          sends p (states cfg1 p)\n           (Bool v) \\<union># msgs cfg1 -# <p, inM v>)\n      (\\<lambda>v cfg1 cfg2. False)\n      (\\<lambda>p v cfg1 cfg2.\n          (\\<forall>s.\n              (s = p \\<longrightarrow>\n               states cfg2 p = trans p (states cfg1 p) (Value v)) \\<and>\n              (s \\<noteq> p \\<longrightarrow>\n               states cfg2 s = states cfg1 s)) \\<and>\n          enabled cfg1 <p, v> \\<and>\n          msgs cfg2 =\n          sends p (states cfg1 p) (Value v) \\<union># msgs cfg1 -# <p, v>)\n      uua uu\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n\ngoal (1 subgoal):\n 1. \\<lparr>states = states cfg2,\n       msgs =\n         msgs\n          cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                 states cfg3,\n                          msgs =\n                            msgs\n                             cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "by auto"], ["proof (state)\nthis:\n  \\<lparr>states = states cfg2,\n     msgs =\n       msgs\n        cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                               states cfg3,\n                        msgs =\n                          msgs\n                           cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "fix p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "assume \"(msg = <p, v>)\""], ["proof (state)\nthis:\n  msg = <p, v>\n\ngoal (1 subgoal):\n 1. \\<And>x31 x32.\n       msg = <x31, x32> \\<Longrightarrow>\n       \\<lparr>states = states cfg2,\n          msgs =\n            msgs\n             cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                    states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "with noInSends MsgNoIn MsgEnabled"], ["proof (chain)\npicking this:\n  sends ?p ?s ?m <?p2.0, inM ?v> = 0\n  msg \\<noteq> <pJ, inM False> \\<and> msg \\<noteq> <pJ, inM True>\n  enabled\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n   msg\n  msg = <p, v>", "show \"\\<lparr>states = (states cfg2),\n          msgs = (((msgs cfg2) -# <pJ, inM False>) \\<union># {# <pJ, inM True> })\\<rparr>\n            \\<turnstile> msg \\<mapsto> \\<lparr>states = (states cfg3),\n              msgs = (((msgs cfg3) -# <pJ, inM False>) \n              \\<union># {# <pJ, inM True> })\\<rparr>\""], ["proof (prove)\nusing this:\n  sends ?p ?s ?m <?p2.0, inM ?v> = 0\n  msg \\<noteq> <pJ, inM False> \\<and> msg \\<noteq> <pJ, inM True>\n  enabled\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n   msg\n  msg = <p, v>\n\ngoal (1 subgoal):\n 1. \\<lparr>states = states cfg2,\n       msgs =\n         msgs\n          cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                 states cfg3,\n                          msgs =\n                            msgs\n                             cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "using steps.simps(1) Step(2) select_convs(2) select_convs(1)"], ["proof (prove)\nusing this:\n  sends ?p ?s ?m <?p2.0, inM ?v> = 0\n  msg \\<noteq> <pJ, inM False> \\<and> msg \\<noteq> <pJ, inM True>\n  enabled\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n   msg\n  msg = <p, v>\n  ?cfg1.0 \\<turnstile> <?p, inM ?v> \\<mapsto> ?cfg2.0 =\n  ((\\<forall>s.\n       (s = ?p \\<longrightarrow>\n        states ?cfg2.0 ?p = trans ?p (states ?cfg1.0 ?p) (Bool ?v)) \\<and>\n       (s \\<noteq> ?p \\<longrightarrow>\n        states ?cfg2.0 s = states ?cfg1.0 s)) \\<and>\n   enabled ?cfg1.0 <?p, inM ?v> \\<and>\n   msgs ?cfg2.0 =\n   sends ?p (states ?cfg1.0 ?p)\n    (Bool ?v) \\<union># msgs ?cfg1.0 -# <?p, inM ?v>)\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  msgs \\<lparr>states = ?states, msgs = ?msgs, \\<dots> = ?more\\<rparr> =\n  ?msgs\n  states \\<lparr>states = ?states, msgs = ?msgs, \\<dots> = ?more\\<rparr> =\n  ?states\n\ngoal (1 subgoal):\n 1. \\<lparr>states = states cfg2,\n       msgs =\n         msgs\n          cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                                 states cfg3,\n                          msgs =\n                            msgs\n                             cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "by auto"], ["proof (state)\nthis:\n  \\<lparr>states = states cfg2,\n     msgs =\n       msgs\n        cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                               states cfg3,\n                        msgs =\n                          msgs\n                           cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lparr>states = states cfg2,\n     msgs =\n       msgs\n        cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                               states cfg3,\n                        msgs =\n                          msgs\n                           cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 Q cfg2 msg cfg3.\n       \\<lbrakk>qReachable cfg1 Q cfg2;\n        \\<lbrakk>Q = Proc - {pJ};\n         msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n         msgs cJ1;\n         states cfg1 = states cJ1\\<rbrakk>\n        \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                           \\<lparr>states = states cfg2,\n                              msgs =\n                                msgs\n                                 cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>;\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3;\n        \\<exists>p\\<in>Q. isReceiverOf p msg; Q = Proc - {pJ};\n        msgs cfg1 -# <pJ, inM False> \\<union># {# <pJ, inM True> } =\n        msgs cJ1;\n        states cfg1 = states cJ1\\<rbrakk>\n       \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                          \\<lparr>states = states cfg3,\n                             msgs =\n                               msgs\n                                cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "with Cfg2 Step(3)"], ["proof (chain)\npicking this:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n  \\<exists>p\\<in>Proc - {pJ}. isReceiverOf p msg\n  \\<lparr>states = states cfg2,\n     msgs =\n       msgs\n        cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                               states cfg3,\n                        msgs =\n                          msgs\n                           cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "show \"qReachable cJ1 (Proc - {pJ})\n        \\<lparr>states = (states cfg3),\n          msgs = (((msgs cfg3) -# <pJ, inM False>) \\<union># {# <pJ, inM True> })\\<rparr>\""], ["proof (prove)\nusing this:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n  \\<exists>p\\<in>Proc - {pJ}. isReceiverOf p msg\n  \\<lparr>states = states cfg2,\n     msgs =\n       msgs\n        cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                               states cfg3,\n                        msgs =\n                          msgs\n                           cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. qReachable cJ1 (Proc - {pJ})\n     \\<lparr>states = states cfg3,\n        msgs =\n          msgs cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "using\n          qReachable.simps[of \"cJ1\" \"(Proc - {pJ})\" \n          \"\\<lparr>states = (states cfg3),\n          msgs = (((msgs cfg3) -# <pJ, inM False>) \n          \\<union># {# <pJ, inM True> })\\<rparr>\"]"], ["proof (prove)\nusing this:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cfg2,\n      msgs =\n        msgs cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n  \\<exists>p\\<in>Proc - {pJ}. isReceiverOf p msg\n  \\<lparr>states = states cfg2,\n     msgs =\n       msgs\n        cfg2 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> \\<turnstile> msg \\<mapsto> \\<lparr>states =\n                               states cfg3,\n                        msgs =\n                          msgs\n                           cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cfg3,\n      msgs =\n        msgs cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> =\n  ((\\<exists>cfg1 Q.\n       cJ1 = cfg1 \\<and>\n       Proc - {pJ} = Q \\<and>\n       \\<lparr>states = states cfg3,\n          msgs =\n            msgs\n             cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> =\n       cfg1) \\<or>\n   (\\<exists>cfg1 Q cfg2 msg cfg3a.\n       cJ1 = cfg1 \\<and>\n       Proc - {pJ} = Q \\<and>\n       \\<lparr>states = states cfg3,\n          msgs =\n            msgs\n             cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr> =\n       cfg3a \\<and>\n       qReachable cfg1 Q cfg2 \\<and>\n       cfg2 \\<turnstile> msg \\<mapsto> cfg3a \\<and>\n       (\\<exists>p\\<in>Q. isReceiverOf p msg)))\n\ngoal (1 subgoal):\n 1. qReachable cJ1 (Proc - {pJ})\n     \\<lparr>states = states cfg3,\n        msgs =\n          msgs cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "by auto"], ["proof (state)\nthis:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cfg3,\n      msgs =\n        msgs cfg3 -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>qReachable cJ ccQ cc; ccQ = Proc - {pJ};\n   msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1;\n   states cJ = states cJ1\\<rbrakk>\n  \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                     \\<lparr>states = states cc,\n                        msgs =\n                          msgs\n                           cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "with CCQ(1) CCQ(2) InitMsgs StatescJcJ1"], ["proof (chain)\npicking this:\n  qReachable cJ ccQ cc\n  ccQ = Proc - {pJ}\n  msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cJ = states cJ1\n  \\<lbrakk>qReachable cJ ccQ cc; ccQ = Proc - {pJ};\n   msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1;\n   states cJ = states cJ1\\<rbrakk>\n  \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                     \\<lparr>states = states cc,\n                        msgs =\n                          msgs\n                           cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "have CC':\n    \"withoutQReachable cJ1 {pJ} \\<lparr>states = (states cc), \n      msgs = (((msgs cc) -# (<pJ,inM False>)) \n      \\<union># {# (<pJ, inM True>)}) \\<rparr>\""], ["proof (prove)\nusing this:\n  qReachable cJ ccQ cc\n  ccQ = Proc - {pJ}\n  msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1\n  states cJ = states cJ1\n  \\<lbrakk>qReachable cJ ccQ cc; ccQ = Proc - {pJ};\n   msgs cJ -# <pJ, inM False> \\<union># {# <pJ, inM True> } = msgs cJ1;\n   states cJ = states cJ1\\<rbrakk>\n  \\<Longrightarrow> qReachable cJ1 (Proc - {pJ})\n                     \\<lparr>states = states cc,\n                        msgs =\n                          msgs\n                           cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. qReachable cJ1 (Proc - {pJ})\n     \\<lparr>states = states cc,\n        msgs =\n          msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "by auto"], ["proof (state)\nthis:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "with QReachImplReach CJ1InitR initReachable_def reachable.simps \n    ReachableTrans"], ["proof (chain)\npicking this:\n  qReachable ?cfg1.0 ?Q ?cfg2.0 \\<Longrightarrow> reachable ?cfg1.0 ?cfg2.0\n  initReachable cJ1\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "have \"initReachable \\<lparr>states = (states cc), \n      msgs = (((msgs cc) -# (<pJ,inM False>)) \n      \\<union># {# (<pJ, inM True>)}) \\<rparr>\""], ["proof (prove)\nusing this:\n  qReachable ?cfg1.0 ?Q ?cfg2.0 \\<Longrightarrow> reachable ?cfg1.0 ?cfg2.0\n  initReachable cJ1\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. initReachable\n     \\<lparr>states = states cc,\n        msgs =\n          msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "by meson"], ["proof (state)\nthis:\n  initReachable\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "with CC'"], ["proof (chain)\npicking this:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n  initReachable\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>", "have \"False \\<in> val[pJ, cJ1]\""], ["proof (prove)\nusing this:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n  initReachable\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. False \\<in> val[pJ,cJ1]", "unfolding pSilDecVal_def"], ["proof (prove)\nusing this:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n  initReachable\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n\ngoal (1 subgoal):\n 1. False\n    \\<in> {v. initReachable cJ1 \\<and>\n              (\\<exists>c'.\n                  qReachable cJ1 (Proc - {pJ}) c' \\<and>\n                  initReachable c' \\<and>\n                  <\\<bottom>, outM v> \\<in># msgs c')}", "using CJ1InitR CC(1) select_convs(2)"], ["proof (prove)\nusing this:\n  qReachable cJ1 (Proc - {pJ})\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n  initReachable\n   \\<lparr>states = states cc,\n      msgs =\n        msgs cc -# <pJ, inM False> \\<union># {# <pJ, inM True> }\\<rparr>\n  initReachable cJ1\n  initReachable cc \\<and> <\\<bottom>, outM False> \\<in># msgs cc\n  msgs \\<lparr>states = ?states, msgs = ?msgs, \\<dots> = ?more\\<rparr> =\n  ?msgs\n\ngoal (1 subgoal):\n 1. False\n    \\<in> {v. initReachable cJ1 \\<and>\n              (\\<exists>c'.\n                  qReachable cJ1 (Proc - {pJ}) c' \\<and>\n                  initReachable c' \\<and>\n                  <\\<bottom>, outM v> \\<in># msgs c')}", "by auto"], ["proof (state)\nthis:\n  False \\<in> val[pJ,cJ1]\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence \"\\<not>(vUniform True (cJ1))\""], ["proof (prove)\nusing this:\n  False \\<in> val[pJ,cJ1]\n\ngoal (1 subgoal):\n 1. \\<not> vUniform True cJ1", "unfolding vUniform_def"], ["proof (prove)\nusing this:\n  False \\<in> val[pJ,cJ1]\n\ngoal (1 subgoal):\n 1. \\<not> (initReachable cJ1 \\<and> (\\<forall>p. val[p,cJ1] = {True}))", "using CJ1InitR"], ["proof (prove)\nusing this:\n  False \\<in> val[pJ,cJ1]\n  initReachable cJ1\n\ngoal (1 subgoal):\n 1. \\<not> (initReachable cJ1 \\<and> (\\<forall>p. val[p,cJ1] = {True}))", "by blast"], ["proof (state)\nthis:\n  \\<not> vUniform True cJ1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "hence \"nonUniform cJ1\""], ["proof (prove)\nusing this:\n  \\<not> vUniform True cJ1\n\ngoal (1 subgoal):\n 1. nonUniform cJ1", "using J(3) CJ1InitR"], ["proof (prove)\nusing this:\n  \\<not> vUniform True cJ1\n  \\<not> vUniform False (initCfgList ! Suc j)\n  initReachable cJ1\n\ngoal (1 subgoal):\n 1. nonUniform cJ1", "unfolding cJ1_def"], ["proof (prove)\nusing this:\n  \\<not> vUniform True (initCfgList ! Suc j)\n  \\<not> vUniform False (initCfgList ! Suc j)\n  initReachable (initCfgList ! Suc j)\n\ngoal (1 subgoal):\n 1. nonUniform (initCfgList ! Suc j)", "by auto"], ["proof (state)\nthis:\n  nonUniform cJ1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "thus ?thesis"], ["proof (prove)\nusing this:\n  nonUniform cJ1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "using CJ1Init"], ["proof (prove)\nusing this:\n  nonUniform cJ1\n  initial cJ1\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. initial cfg \\<and> nonUniform cfg", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg. initial cfg \\<and> nonUniform cfg\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n  V?lzer's Lemma 2 proves that for every process $p$ in the consensus setting \n  \\isb{nonUniform} configurations can reach a configuration where the silent\n  decision values of $p$ are True and False. This is key to the construction of\n  non-deciding executions.\n\n  \\voelzer{Lemma 2}\n\\<close>"], ["", "lemma NonUniformCanReachSilentBivalence:\nfixes \n  p:: 'p and\n  c:: \"('p, 'v, 's) configuration\"\nassumes \n  NonUni: \"nonUniform c\" and\n  PseudoTermination: \"\\<And>cc Q . terminationPseudo 1 cc Q\" and\n  Agree: \"\\<And> cfg . reachable c cfg \\<longrightarrow> agreement cfg\"\nshows \n   \"\\<exists> c' . reachable c c' \\<and> val[p,c'] = {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "proof(cases \"val[p,c] = {True, False}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. val[p,c] = {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}\n 2. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "case True"], ["proof (state)\nthis:\n  val[p,c] = {True, False}\n\ngoal (2 subgoals):\n 1. val[p,c] = {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}\n 2. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "have \"reachable c c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable c c", "using reachable.simps"], ["proof (prove)\nusing this:\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n\ngoal (1 subgoal):\n 1. reachable c c", "by metis"], ["proof (state)\nthis:\n  reachable c c\n\ngoal (2 subgoals):\n 1. val[p,c] = {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}\n 2. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "thus ?thesis"], ["proof (prove)\nusing this:\n  reachable c c\n\ngoal (1 subgoal):\n 1. \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "using True"], ["proof (prove)\nusing this:\n  reachable c c\n  val[p,c] = {True, False}\n\ngoal (1 subgoal):\n 1. \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "by blast"], ["proof (state)\nthis:\n  \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "case False"], ["proof (state)\nthis:\n  val[p,c] \\<noteq> {True, False}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "hence notEq: \"val[p,c] \\<noteq> {True, False}\""], ["proof (prove)\nusing this:\n  val[p,c] \\<noteq> {True, False}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False}", "by simp"], ["proof (state)\nthis:\n  val[p,c] \\<noteq> {True, False}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "from NonUni PseudoTermination DecisionValuesExist"], ["proof (chain)\npicking this:\n  nonUniform c\n  terminationPseudo 1 ?cc ?Q\n  \\<lbrakk>\\<And>cc Q. terminationPseudo 1 cc Q; initReachable ?c\\<rbrakk>\n  \\<Longrightarrow> val[?p,?c] \\<noteq> {}", "have notE: \"\\<forall>q. val[q,c] \\<noteq> {}\""], ["proof (prove)\nusing this:\n  nonUniform c\n  terminationPseudo 1 ?cc ?Q\n  \\<lbrakk>\\<And>cc Q. terminationPseudo 1 cc Q; initReachable ?c\\<rbrakk>\n  \\<Longrightarrow> val[?p,?c] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>q. val[q,c] \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  \\<forall>q. val[q,c] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "hence notEP: \"val[p,c] \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<forall>q. val[q,c] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  val[p,c] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "have valType: \"\\<forall>q. val[q,c] \\<subseteq> {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q. val[q,c] \\<subseteq> {True, False}", "using pSilDecVal_def"], ["proof (prove)\nusing this:\n  pSilDecVal ?v ?p ?c \\<equiv>\n  initReachable ?c \\<and>\n  (\\<exists>c'.\n      qReachable ?c (Proc - {?p}) c' \\<and>\n      initReachable c' \\<and> <\\<bottom>, outM ?v> \\<in># msgs c')\n\ngoal (1 subgoal):\n 1. \\<forall>q. val[q,c] \\<subseteq> {True, False}", "by (metis (full_types) insertCI subsetI)"], ["proof (state)\nthis:\n  \\<forall>q. val[q,c] \\<subseteq> {True, False}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "hence \"val[p,c] \\<subseteq> {True, False}\""], ["proof (prove)\nusing this:\n  \\<forall>q. val[q,c] \\<subseteq> {True, False}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<subseteq> {True, False}", "by blast"], ["proof (state)\nthis:\n  val[p,c] \\<subseteq> {True, False}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "with notEq notEP"], ["proof (chain)\npicking this:\n  val[p,c] \\<noteq> {True, False}\n  val[p,c] \\<noteq> {}\n  val[p,c] \\<subseteq> {True, False}", "have \"\\<exists>b:: bool. val[p,c] = {b}\""], ["proof (prove)\nusing this:\n  val[p,c] \\<noteq> {True, False}\n  val[p,c] \\<noteq> {}\n  val[p,c] \\<subseteq> {True, False}\n\ngoal (1 subgoal):\n 1. \\<exists>b. val[p,c] = {b}", "by blast"], ["proof (state)\nthis:\n  \\<exists>b. val[p,c] = {b}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. val[p,c] = {b}", "obtain b where B: \"val[p,c] = {b}\""], ["proof (prove)\nusing this:\n  \\<exists>b. val[p,c] = {b}\n\ngoal (1 subgoal):\n 1. (\\<And>b. val[p,c] = {b} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  val[p,c] = {b}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "from NonUni vUniform_def"], ["proof (chain)\npicking this:\n  nonUniform c\n  vUniform ?v ?c \\<equiv>\n  initReachable ?c \\<and> (\\<forall>p. val[p,?c] = {?v})", "have \n    NonUni: \"(\\<exists>q. val[q,c] \\<noteq> {True}) \\<and> (\\<exists>q. val[q,c] \\<noteq> {False})\""], ["proof (prove)\nusing this:\n  nonUniform c\n  vUniform ?v ?c \\<equiv>\n  initReachable ?c \\<and> (\\<forall>p. val[p,?c] = {?v})\n\ngoal (1 subgoal):\n 1. (\\<exists>q. val[q,c] \\<noteq> {True}) \\<and>\n    (\\<exists>q. val[q,c] \\<noteq> {False})", "by simp"], ["proof (state)\nthis:\n  (\\<exists>q. val[q,c] \\<noteq> {True}) \\<and>\n  (\\<exists>q. val[q,c] \\<noteq> {False})\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "have Bool: \"b = True \\<or> b = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = True \\<or> b = False", "by simp"], ["proof (state)\nthis:\n  b = True \\<or> b = False\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "with NonUni"], ["proof (chain)\npicking this:\n  (\\<exists>q. val[q,c] \\<noteq> {True}) \\<and>\n  (\\<exists>q. val[q,c] \\<noteq> {False})\n  b = True \\<or> b = False", "have \"\\<exists>q. val[q,c] \\<noteq> {b}\""], ["proof (prove)\nusing this:\n  (\\<exists>q. val[q,c] \\<noteq> {True}) \\<and>\n  (\\<exists>q. val[q,c] \\<noteq> {False})\n  b = True \\<or> b = False\n\ngoal (1 subgoal):\n 1. \\<exists>q. val[q,c] \\<noteq> {b}", "by blast"], ["proof (state)\nthis:\n  \\<exists>q. val[q,c] \\<noteq> {b}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. val[q,c] \\<noteq> {b}", "obtain q where Q: \"val[q,c] \\<noteq> {b}\""], ["proof (prove)\nusing this:\n  \\<exists>q. val[q,c] \\<noteq> {b}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        val[q,c] \\<noteq> {b} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  val[q,c] \\<noteq> {b}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "from notE valType"], ["proof (chain)\npicking this:\n  \\<forall>q. val[q,c] \\<noteq> {}\n  \\<forall>q. val[q,c] \\<subseteq> {True, False}", "have \"val[q,c] = {True} \\<or> val[q,c] = {False} \\<or> val[q,c] = {True, False}\""], ["proof (prove)\nusing this:\n  \\<forall>q. val[q,c] \\<noteq> {}\n  \\<forall>q. val[q,c] \\<subseteq> {True, False}\n\ngoal (1 subgoal):\n 1. val[q,c] = {True} \\<or>\n    val[q,c] = {False} \\<or> val[q,c] = {True, False}", "by auto"], ["proof (state)\nthis:\n  val[q,c] = {True} \\<or> val[q,c] = {False} \\<or> val[q,c] = {True, False}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "with Bool Q"], ["proof (chain)\npicking this:\n  b = True \\<or> b = False\n  val[q,c] \\<noteq> {b}\n  val[q,c] = {True} \\<or> val[q,c] = {False} \\<or> val[q,c] = {True, False}", "have \"val[q,c] = {\\<not>b} \\<or> val[q,c] = {b, \\<not>b}\""], ["proof (prove)\nusing this:\n  b = True \\<or> b = False\n  val[q,c] \\<noteq> {b}\n  val[q,c] = {True} \\<or> val[q,c] = {False} \\<or> val[q,c] = {True, False}\n\ngoal (1 subgoal):\n 1. val[q,c] = {\\<not> b} \\<or> val[q,c] = {b, \\<not> b}", "by blast"], ["proof (state)\nthis:\n  val[q,c] = {\\<not> b} \\<or> val[q,c] = {b, \\<not> b}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "hence \"(\\<not>b) \\<in> val[q,c]\""], ["proof (prove)\nusing this:\n  val[q,c] = {\\<not> b} \\<or> val[q,c] = {b, \\<not> b}\n\ngoal (1 subgoal):\n 1. (\\<not> b) \\<in> val[q,c]", "by blast"], ["proof (state)\nthis:\n  (\\<not> b) \\<in> val[q,c]\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "with pSilDecVal_def"], ["proof (chain)\npicking this:\n  pSilDecVal ?v ?p ?c \\<equiv>\n  initReachable ?c \\<and>\n  (\\<exists>c'.\n      qReachable ?c (Proc - {?p}) c' \\<and>\n      initReachable c' \\<and> <\\<bottom>, outM ?v> \\<in># msgs c')\n  (\\<not> b) \\<in> val[q,c]", "have \"\\<exists> c'::('p, 'v, 's) configuration . (withoutQReachable c {q} c') \\<and>\n    vDecided (\\<not>b) c'\""], ["proof (prove)\nusing this:\n  pSilDecVal ?v ?p ?c \\<equiv>\n  initReachable ?c \\<and>\n  (\\<exists>c'.\n      qReachable ?c (Proc - {?p}) c' \\<and>\n      initReachable c' \\<and> <\\<bottom>, outM ?v> \\<in># msgs c')\n  (\\<not> b) \\<in> val[q,c]\n\ngoal (1 subgoal):\n 1. \\<exists>c'.\n       qReachable c (Proc - {q}) c' \\<and>\n       initReachable c' \\<and> <\\<bottom>, outM \\<not> b> \\<in># msgs c'", "by simp"], ["proof (state)\nthis:\n  \\<exists>c'.\n     qReachable c (Proc - {q}) c' \\<and>\n     initReachable c' \\<and> <\\<bottom>, outM \\<not> b> \\<in># msgs c'\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "then"], ["proof (chain)\npicking this:\n  \\<exists>c'.\n     qReachable c (Proc - {q}) c' \\<and>\n     initReachable c' \\<and> <\\<bottom>, outM \\<not> b> \\<in># msgs c'", "obtain c' where C': \"withoutQReachable c {q} c'\" \"vDecided (\\<not>b) c'\""], ["proof (prove)\nusing this:\n  \\<exists>c'.\n     qReachable c (Proc - {q}) c' \\<and>\n     initReachable c' \\<and> <\\<bottom>, outM \\<not> b> \\<in># msgs c'\n\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        \\<lbrakk>qReachable c (Proc - {q}) c';\n         initReachable c' \\<and>\n         <\\<bottom>, outM \\<not> b> \\<in># msgs c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qReachable c (Proc - {q}) c'\n  initReachable c' \\<and> <\\<bottom>, outM \\<not> b> \\<in># msgs c'\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "hence Reach: \"reachable c c'\""], ["proof (prove)\nusing this:\n  qReachable c (Proc - {q}) c'\n  initReachable c' \\<and> <\\<bottom>, outM \\<not> b> \\<in># msgs c'\n\ngoal (1 subgoal):\n 1. reachable c c'", "using QReachImplReach"], ["proof (prove)\nusing this:\n  qReachable c (Proc - {q}) c'\n  initReachable c' \\<and> <\\<bottom>, outM \\<not> b> \\<in># msgs c'\n  qReachable ?cfg1.0 ?Q ?cfg2.0 \\<Longrightarrow> reachable ?cfg1.0 ?cfg2.0\n\ngoal (1 subgoal):\n 1. reachable c c'", "by simp"], ["proof (state)\nthis:\n  reachable c c'\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "have \"\\<forall> cfg . reachable c' cfg \\<longrightarrow> agreement cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cfg. reachable c' cfg \\<longrightarrow> agreement cfg", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg. reachable c' cfg \\<Longrightarrow> agreement cfg", "fix cfg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg. reachable c' cfg \\<Longrightarrow> agreement cfg", "assume \"reachable c' cfg\""], ["proof (state)\nthis:\n  reachable c' cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg. reachable c' cfg \\<Longrightarrow> agreement cfg", "with Reach"], ["proof (chain)\npicking this:\n  reachable c c'\n  reachable c' cfg", "have \"reachable c cfg\""], ["proof (prove)\nusing this:\n  reachable c c'\n  reachable c' cfg\n\ngoal (1 subgoal):\n 1. reachable c cfg", "using ReachableTrans[of c c']"], ["proof (prove)\nusing this:\n  reachable c c'\n  reachable c' cfg\n  \\<lbrakk>reachable c c'; reachable c' ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable c ?cfg3.0\n\ngoal (1 subgoal):\n 1. reachable c cfg", "by simp"], ["proof (state)\nthis:\n  reachable c cfg\n\ngoal (1 subgoal):\n 1. \\<And>cfg. reachable c' cfg \\<Longrightarrow> agreement cfg", "with Agree"], ["proof (chain)\npicking this:\n  reachable c ?cfg \\<longrightarrow> agreement ?cfg\n  reachable c cfg", "show \"agreement cfg\""], ["proof (prove)\nusing this:\n  reachable c ?cfg \\<longrightarrow> agreement ?cfg\n  reachable c cfg\n\ngoal (1 subgoal):\n 1. agreement cfg", "by simp"], ["proof (state)\nthis:\n  agreement cfg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>cfg. reachable c' cfg \\<longrightarrow> agreement cfg\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "with PseudoTermination C'(2) DecidedImpliesUniform"], ["proof (chain)\npicking this:\n  terminationPseudo 1 ?cc ?Q\n  initReachable c' \\<and> <\\<bottom>, outM \\<not> b> \\<in># msgs c'\n  \\<lbrakk>\\<forall>cfg. reachable ?c cfg \\<longrightarrow> agreement cfg;\n   \\<And>cc Q. terminationPseudo 1 cc Q;\n   initReachable ?c \\<and> <\\<bottom>, outM ?v> \\<in># msgs ?c\\<rbrakk>\n  \\<Longrightarrow> vUniform ?v ?c\n  \\<forall>cfg. reachable c' cfg \\<longrightarrow> agreement cfg", "have \"vUniform (\\<not>b) c'\""], ["proof (prove)\nusing this:\n  terminationPseudo 1 ?cc ?Q\n  initReachable c' \\<and> <\\<bottom>, outM \\<not> b> \\<in># msgs c'\n  \\<lbrakk>\\<forall>cfg. reachable ?c cfg \\<longrightarrow> agreement cfg;\n   \\<And>cc Q. terminationPseudo 1 cc Q;\n   initReachable ?c \\<and> <\\<bottom>, outM ?v> \\<in># msgs ?c\\<rbrakk>\n  \\<Longrightarrow> vUniform ?v ?c\n  \\<forall>cfg. reachable c' cfg \\<longrightarrow> agreement cfg\n\ngoal (1 subgoal):\n 1. vUniform (\\<not> b) c'", "by simp"], ["proof (state)\nthis:\n  vUniform (\\<not> b) c'\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "hence notB: \"val[p,c'] = {\\<not>b}\""], ["proof (prove)\nusing this:\n  vUniform (\\<not> b) c'\n\ngoal (1 subgoal):\n 1. val[p,c'] = {\\<not> b}", "using vUniform_def"], ["proof (prove)\nusing this:\n  vUniform (\\<not> b) c'\n  vUniform ?v ?c \\<equiv>\n  initReachable ?c \\<and> (\\<forall>p. val[p,?c] = {?v})\n\ngoal (1 subgoal):\n 1. val[p,c'] = {\\<not> b}", "by simp"], ["proof (state)\nthis:\n  val[p,c'] = {\\<not> b}\n\ngoal (1 subgoal):\n 1. val[p,c] \\<noteq> {True, False} \\<Longrightarrow>\n    \\<exists>c'. reachable c c' \\<and> val[p,c'] = {True, False}", "with Reach B"], ["proof (chain)\npicking this:\n  reachable c c'\n  val[p,c] = {b}\n  val[p,c'] = {\\<not> b}", "show \"\\<exists> cfg. reachable c cfg \\<and> val[p,cfg] = {True, False}\""], ["proof (prove)\nusing this:\n  reachable c c'\n  val[p,c] = {b}\n  val[p,c'] = {\\<not> b}\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. reachable c cfg \\<and> val[p,cfg] = {True, False}", "proof(induct rule: reachable.induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg.\n                             reachable cfg1 cfg \\<and>\n                             val[p,cfg] = {True, False};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; val[p,cfg1] = {b};\n        val[p,cfg3] = {\\<not> b}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            reachable cfg1 cfg \\<and>\n                            val[p,cfg] = {True, False}", "fix cfg1 cfg2 cfg3 msg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg.\n                             reachable cfg1 cfg \\<and>\n                             val[p,cfg] = {True, False};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; val[p,cfg1] = {b};\n        val[p,cfg3] = {\\<not> b}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            reachable cfg1 cfg \\<and>\n                            val[p,cfg] = {True, False}", "assume\n      IV: \"val[p,cfg1] = {b} \\<Longrightarrow>\n        val[p,cfg2] = {\\<not> b} \\<Longrightarrow>\n          \\<exists>cfg::('p, 'v, 's) configuration. reachable cfg1 cfg \n          \\<and> val[p,cfg] = {True, False}\" and\n      Reach:  \"reachable cfg1 cfg2\" and\n      Step: \"cfg2 \\<turnstile> msg \\<mapsto> cfg3\" and\n      ValCfg1: \"val[p,cfg1] = {b}\" and\n      ValCfg3: \"val[p,cfg3] = {\\<not> b}\""], ["proof (state)\nthis:\n  \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cfg.\n                       reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n  reachable cfg1 cfg2\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  val[p,cfg1] = {b}\n  val[p,cfg3] = {\\<not> b}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg.\n                             reachable cfg1 cfg \\<and>\n                             val[p,cfg] = {True, False};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; val[p,cfg1] = {b};\n        val[p,cfg3] = {\\<not> b}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            reachable cfg1 cfg \\<and>\n                            val[p,cfg] = {True, False}", "from ValCfg1"], ["proof (chain)\npicking this:\n  val[p,cfg1] = {b}", "have InitCfg1: \"initReachable cfg1\""], ["proof (prove)\nusing this:\n  val[p,cfg1] = {b}\n\ngoal (1 subgoal):\n 1. initReachable cfg1", "using pSilDecVal_def"], ["proof (prove)\nusing this:\n  val[p,cfg1] = {b}\n  pSilDecVal ?v ?p ?c \\<equiv>\n  initReachable ?c \\<and>\n  (\\<exists>c'.\n      qReachable ?c (Proc - {?p}) c' \\<and>\n      initReachable c' \\<and> <\\<bottom>, outM ?v> \\<in># msgs c')\n\ngoal (1 subgoal):\n 1. initReachable cfg1", "by auto"], ["proof (state)\nthis:\n  initReachable cfg1\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg.\n                             reachable cfg1 cfg \\<and>\n                             val[p,cfg] = {True, False};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; val[p,cfg1] = {b};\n        val[p,cfg3] = {\\<not> b}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            reachable cfg1 cfg \\<and>\n                            val[p,cfg] = {True, False}", "from Reach InitCfg1 initReachable_def reachable.simps ReachableTrans"], ["proof (chain)\npicking this:\n  reachable cfg1 cfg2\n  initReachable cfg1\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0", "have InitCfg2: \"initReachable cfg2\""], ["proof (prove)\nusing this:\n  reachable cfg1 cfg2\n  initReachable cfg1\n  initReachable ?cfg \\<equiv>\n  \\<exists>cfg0. initial cfg0 \\<and> reachable cfg0 ?cfg\n  reachable ?a1.0 ?a2.0 =\n  ((\\<exists>cfg1. ?a1.0 = cfg1 \\<and> ?a2.0 = cfg1) \\<or>\n   (\\<exists>cfg1 cfg2 msg cfg3.\n       ?a1.0 = cfg1 \\<and>\n       ?a2.0 = cfg3 \\<and>\n       reachable cfg1 cfg2 \\<and> cfg2 \\<turnstile> msg \\<mapsto> cfg3))\n  \\<lbrakk>reachable ?cfg1.0 ?cfg2.0; reachable ?cfg2.0 ?cfg3.0\\<rbrakk>\n  \\<Longrightarrow> reachable ?cfg1.0 ?cfg3.0\n\ngoal (1 subgoal):\n 1. initReachable cfg2", "by blast"], ["proof (state)\nthis:\n  initReachable cfg2\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg.\n                             reachable cfg1 cfg \\<and>\n                             val[p,cfg] = {True, False};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; val[p,cfg1] = {b};\n        val[p,cfg3] = {\\<not> b}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            reachable cfg1 cfg \\<and>\n                            val[p,cfg] = {True, False}", "with PseudoTermination DecisionValuesExist"], ["proof (chain)\npicking this:\n  terminationPseudo 1 ?cc ?Q\n  \\<lbrakk>\\<And>cc Q. terminationPseudo 1 cc Q; initReachable ?c\\<rbrakk>\n  \\<Longrightarrow> val[?p,?c] \\<noteq> {}\n  initReachable cfg2", "have notE: \"\\<forall>q. val[q,cfg2] \\<noteq> {}\""], ["proof (prove)\nusing this:\n  terminationPseudo 1 ?cc ?Q\n  \\<lbrakk>\\<And>cc Q. terminationPseudo 1 cc Q; initReachable ?c\\<rbrakk>\n  \\<Longrightarrow> val[?p,?c] \\<noteq> {}\n  initReachable cfg2\n\ngoal (1 subgoal):\n 1. \\<forall>q. val[q,cfg2] \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  \\<forall>q. val[q,cfg2] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg.\n                             reachable cfg1 cfg \\<and>\n                             val[p,cfg] = {True, False};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; val[p,cfg1] = {b};\n        val[p,cfg3] = {\\<not> b}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            reachable cfg1 cfg \\<and>\n                            val[p,cfg] = {True, False}", "have valType: \"\\<forall>q. val[q,cfg2] \\<subseteq> {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q. val[q,cfg2] \\<subseteq> {True, False}", "using pSilDecVal_def"], ["proof (prove)\nusing this:\n  pSilDecVal ?v ?p ?c \\<equiv>\n  initReachable ?c \\<and>\n  (\\<exists>c'.\n      qReachable ?c (Proc - {?p}) c' \\<and>\n      initReachable c' \\<and> <\\<bottom>, outM ?v> \\<in># msgs c')\n\ngoal (1 subgoal):\n 1. \\<forall>q. val[q,cfg2] \\<subseteq> {True, False}", "by (metis (full_types) insertCI subsetI)"], ["proof (state)\nthis:\n  \\<forall>q. val[q,cfg2] \\<subseteq> {True, False}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg.\n                             reachable cfg1 cfg \\<and>\n                             val[p,cfg] = {True, False};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; val[p,cfg1] = {b};\n        val[p,cfg3] = {\\<not> b}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            reachable cfg1 cfg \\<and>\n                            val[p,cfg] = {True, False}", "from notE valType"], ["proof (chain)\npicking this:\n  \\<forall>q. val[q,cfg2] \\<noteq> {}\n  \\<forall>q. val[q,cfg2] \\<subseteq> {True, False}", "have \"val[p,cfg2] = {True} \\<or> val[p,cfg2] = {False} \n        \\<or> val[p,cfg2] = {True, False}\""], ["proof (prove)\nusing this:\n  \\<forall>q. val[q,cfg2] \\<noteq> {}\n  \\<forall>q. val[q,cfg2] \\<subseteq> {True, False}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] = {True} \\<or>\n    val[p,cfg2] = {False} \\<or> val[p,cfg2] = {True, False}", "by auto"], ["proof (state)\nthis:\n  val[p,cfg2] = {True} \\<or>\n  val[p,cfg2] = {False} \\<or> val[p,cfg2] = {True, False}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg.\n                             reachable cfg1 cfg \\<and>\n                             val[p,cfg] = {True, False};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; val[p,cfg1] = {b};\n        val[p,cfg3] = {\\<not> b}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            reachable cfg1 cfg \\<and>\n                            val[p,cfg] = {True, False}", "with Bool"], ["proof (chain)\npicking this:\n  b = True \\<or> b = False\n  val[p,cfg2] = {True} \\<or>\n  val[p,cfg2] = {False} \\<or> val[p,cfg2] = {True, False}", "have Val: \"val[p,cfg2] = {b} \\<or> val[p,cfg2] = {\\<not>b} \n      \\<or> val[p,cfg2] = {True, False}\""], ["proof (prove)\nusing this:\n  b = True \\<or> b = False\n  val[p,cfg2] = {True} \\<or>\n  val[p,cfg2] = {False} \\<or> val[p,cfg2] = {True, False}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] = {b} \\<or>\n    val[p,cfg2] = {\\<not> b} \\<or> val[p,cfg2] = {True, False}", "by blast"], ["proof (state)\nthis:\n  val[p,cfg2] = {b} \\<or>\n  val[p,cfg2] = {\\<not> b} \\<or> val[p,cfg2] = {True, False}\n\ngoal (1 subgoal):\n 1. \\<And>cfg1 cfg2 msg cfg3.\n       \\<lbrakk>reachable cfg1 cfg2;\n        \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n        \\<Longrightarrow> \\<exists>cfg.\n                             reachable cfg1 cfg \\<and>\n                             val[p,cfg] = {True, False};\n        cfg2 \\<turnstile> msg \\<mapsto> cfg3; val[p,cfg1] = {b};\n        val[p,cfg3] = {\\<not> b}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cfg.\n                            reachable cfg1 cfg \\<and>\n                            val[p,cfg] = {True, False}", "show \"\\<exists>cfg::('p, 'v, 's) configuration. reachable cfg1 cfg \n      \\<and> val[p,cfg] = {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "proof(cases \"val[p,cfg2] = {b}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. val[p,cfg2] = {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "case True"], ["proof (state)\nthis:\n  val[p,cfg2] = {b}\n\ngoal (2 subgoals):\n 1. val[p,cfg2] = {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "hence B: \"val[p,cfg2] = {b}\""], ["proof (prove)\nusing this:\n  val[p,cfg2] = {b}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] = {b}", "by simp"], ["proof (state)\nthis:\n  val[p,cfg2] = {b}\n\ngoal (2 subgoals):\n 1. val[p,cfg2] = {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "from Step"], ["proof (chain)\npicking this:\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3", "have RecOrOut: \"\\<exists>q. isReceiverOf q msg\""], ["proof (prove)\nusing this:\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n\ngoal (1 subgoal):\n 1. \\<exists>q. isReceiverOf q msg", "by(cases msg, auto)"], ["proof (state)\nthis:\n  \\<exists>q. isReceiverOf q msg\n\ngoal (2 subgoals):\n 1. val[p,cfg2] = {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "then"], ["proof (chain)\npicking this:\n  \\<exists>q. isReceiverOf q msg", "obtain q where Rec: \"isReceiverOf q msg\""], ["proof (prove)\nusing this:\n  \\<exists>q. isReceiverOf q msg\n\ngoal (1 subgoal):\n 1. (\\<And>q. isReceiverOf q msg \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  isReceiverOf q msg\n\ngoal (2 subgoals):\n 1. val[p,cfg2] = {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "with B Step InitCfg2 SilentDecisionValueNotInverting"], ["proof (chain)\npicking this:\n  val[p,cfg2] = {b}\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  initReachable cfg2\n  \\<lbrakk>val[?q,?c] = {?v}; ?c \\<turnstile> ?msg \\<mapsto> ?c';\n   isReceiverOf ?p ?msg; initReachable ?c\\<rbrakk>\n  \\<Longrightarrow> val[?q,?c'] \\<noteq> {\\<not> ?v}\n  isReceiverOf q msg", "have \"val[p,cfg3] \\<noteq> {\\<not>b}\""], ["proof (prove)\nusing this:\n  val[p,cfg2] = {b}\n  cfg2 \\<turnstile> msg \\<mapsto> cfg3\n  initReachable cfg2\n  \\<lbrakk>val[?q,?c] = {?v}; ?c \\<turnstile> ?msg \\<mapsto> ?c';\n   isReceiverOf ?p ?msg; initReachable ?c\\<rbrakk>\n  \\<Longrightarrow> val[?q,?c'] \\<noteq> {\\<not> ?v}\n  isReceiverOf q msg\n\ngoal (1 subgoal):\n 1. val[p,cfg3] \\<noteq> {\\<not> b}", "by simp"], ["proof (state)\nthis:\n  val[p,cfg3] \\<noteq> {\\<not> b}\n\ngoal (2 subgoals):\n 1. val[p,cfg2] = {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "with ValCfg3"], ["proof (chain)\npicking this:\n  val[p,cfg3] = {\\<not> b}\n  val[p,cfg3] \\<noteq> {\\<not> b}", "have \"False\""], ["proof (prove)\nusing this:\n  val[p,cfg3] = {\\<not> b}\n  val[p,cfg3] \\<noteq> {\\<not> b}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. val[p,cfg2] = {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "thus \"\\<exists>cfg::('p, 'v, 's) configuration. reachable cfg1 cfg \\<and> \n        val[p,cfg] = {True, False}\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "by simp"], ["proof (state)\nthis:\n  \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "case False"], ["proof (state)\nthis:\n  val[p,cfg2] \\<noteq> {b}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "with Val"], ["proof (chain)\npicking this:\n  val[p,cfg2] = {b} \\<or>\n  val[p,cfg2] = {\\<not> b} \\<or> val[p,cfg2] = {True, False}\n  val[p,cfg2] \\<noteq> {b}", "have Val: \"val[p,cfg2] = {\\<not>b} \\<or> val[p,cfg2] = {True, False}\""], ["proof (prove)\nusing this:\n  val[p,cfg2] = {b} \\<or>\n  val[p,cfg2] = {\\<not> b} \\<or> val[p,cfg2] = {True, False}\n  val[p,cfg2] \\<noteq> {b}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] = {\\<not> b} \\<or> val[p,cfg2] = {True, False}", "by simp"], ["proof (state)\nthis:\n  val[p,cfg2] = {\\<not> b} \\<or> val[p,cfg2] = {True, False}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] \\<noteq> {b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "show \"\\<exists>cfg::('p, 'v, 's) configuration. reachable cfg1 cfg \\<and> \n            val[p,cfg] = {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "proof(cases \"val[p,cfg2] = {\\<not>b}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. val[p,cfg2] = {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "case True"], ["proof (state)\nthis:\n  val[p,cfg2] = {\\<not> b}\n\ngoal (2 subgoals):\n 1. val[p,cfg2] = {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "hence \"val[p,cfg2] = {\\<not>b}\""], ["proof (prove)\nusing this:\n  val[p,cfg2] = {\\<not> b}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] = {\\<not> b}", "by simp"], ["proof (state)\nthis:\n  val[p,cfg2] = {\\<not> b}\n\ngoal (2 subgoals):\n 1. val[p,cfg2] = {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n 2. val[p,cfg2] \\<noteq> {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "with ValCfg1 IV"], ["proof (chain)\npicking this:\n  val[p,cfg1] = {b}\n  \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cfg.\n                       reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n  val[p,cfg2] = {\\<not> b}", "show \n          \"\\<exists>cfg::('p, 'v, 's) configuration. \n          reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\""], ["proof (prove)\nusing this:\n  val[p,cfg1] = {b}\n  \\<lbrakk>val[p,cfg1] = {b}; val[p,cfg2] = {\\<not> b}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cfg.\n                       reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n  val[p,cfg2] = {\\<not> b}\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "by simp"], ["proof (state)\nthis:\n  \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] \\<noteq> {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. val[p,cfg2] \\<noteq> {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "case False"], ["proof (state)\nthis:\n  val[p,cfg2] \\<noteq> {\\<not> b}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] \\<noteq> {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "with Val"], ["proof (chain)\npicking this:\n  val[p,cfg2] = {\\<not> b} \\<or> val[p,cfg2] = {True, False}\n  val[p,cfg2] \\<noteq> {\\<not> b}", "have \"val[p,cfg2] = {True, False}\""], ["proof (prove)\nusing this:\n  val[p,cfg2] = {\\<not> b} \\<or> val[p,cfg2] = {True, False}\n  val[p,cfg2] \\<noteq> {\\<not> b}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] = {True, False}", "by simp"], ["proof (state)\nthis:\n  val[p,cfg2] = {True, False}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] \\<noteq> {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "with Reach"], ["proof (chain)\npicking this:\n  reachable cfg1 cfg2\n  val[p,cfg2] = {True, False}", "have \"reachable cfg1 cfg2 \\<and> val[p,cfg2] = {True, False}\""], ["proof (prove)\nusing this:\n  reachable cfg1 cfg2\n  val[p,cfg2] = {True, False}\n\ngoal (1 subgoal):\n 1. reachable cfg1 cfg2 \\<and> val[p,cfg2] = {True, False}", "by blast"], ["proof (state)\nthis:\n  reachable cfg1 cfg2 \\<and> val[p,cfg2] = {True, False}\n\ngoal (1 subgoal):\n 1. val[p,cfg2] \\<noteq> {\\<not> b} \\<Longrightarrow>\n    \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "from this"], ["proof (chain)\npicking this:\n  reachable cfg1 cfg2 \\<and> val[p,cfg2] = {True, False}", "show \"\\<exists>cfg::('p, 'v, 's) configuration. \n          reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\""], ["proof (prove)\nusing this:\n  reachable cfg1 cfg2 \\<and> val[p,cfg2] = {True, False}\n\ngoal (1 subgoal):\n 1. \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}", "by blast"], ["proof (state)\nthis:\n  \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cfg. reachable cfg1 cfg \\<and> val[p,cfg] = {True, False}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cfg. reachable c cfg \\<and> val[p,cfg] = {True, False}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}