{"file_name": "/home/qj213/afp-2021-10-22/thys/FLP/FLPExistingSystem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FLP", "problem_names": ["lemma ProcUniv: \"(UNIV :: proc set) = {p0, p1}\""], "translations": [["", "lemma ProcUniv: \"(UNIV :: proc set) = {p0, p1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {p0, p1}", "by (metis UNIV_eq_I insert_iff proc.exhaust)"], ["", "subsection \\<open>Interpretation as FLP Locale\\<close>"], ["", "interpretation FLPSys: flpSystem trans sends start"], ["proof (prove)\ngoal (1 subgoal):\n 1. flpSystem sends", "proof\n  \\<comment> \\<open>finiteProcs\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. finite UNIV\n 2. 2 \\<le> card UNIV\n 3. \\<And>p s m. finite {v. v \\<in># sends p s m}\n 4. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "show \"finite (UNIV :: proc set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "unfolding ProcUniv"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {p0, p1}", "by simp"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (3 subgoals):\n 1. 2 \\<le> card UNIV\n 2. \\<And>p s m. finite {v. v \\<in># sends p s m}\n 3. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "next\n  \\<comment> \\<open>minimalProcs\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. 2 \\<le> card UNIV\n 2. \\<And>p s m. finite {v. v \\<in># sends p s m}\n 3. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "have \"card (UNIV :: proc set) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card UNIV = 2", "unfolding ProcUniv"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {p0, p1} = 2", "by simp"], ["proof (state)\nthis:\n  card UNIV = 2\n\ngoal (3 subgoals):\n 1. 2 \\<le> card UNIV\n 2. \\<And>p s m. finite {v. v \\<in># sends p s m}\n 3. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "thus \"2 \\<le> card (UNIV :: proc set)\""], ["proof (prove)\nusing this:\n  card UNIV = 2\n\ngoal (1 subgoal):\n 1. 2 \\<le> card UNIV", "by simp"], ["proof (state)\nthis:\n  2 \\<le> card UNIV\n\ngoal (2 subgoals):\n 1. \\<And>p s m. finite {v. v \\<in># sends p s m}\n 2. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "next\n  \\<comment> \\<open>finiteSends\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p s m. finite {v. v \\<in># sends p s m}\n 2. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "fix p s m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p s m. finite {v. v \\<in># sends p s m}\n 2. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "have FinExplSends: \"finite {<p0, v1>, <p1, v0>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {<p0, v1>, <p1, v0>}", "by auto"], ["proof (state)\nthis:\n  finite {<p0, v1>, <p1, v0>}\n\ngoal (2 subgoals):\n 1. \\<And>p s m. finite {v. v \\<in># sends p s m}\n 2. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "have \"{v. 0 < sends p s m v} \\<subseteq> {<p0, v1>, <p1, v0>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. v \\<in># sends p s m} \\<subseteq> {<p0, v1>, <p1, v0>}", "proof auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> <p0, v1>; x \\<in># sends p s m\\<rbrakk>\n       \\<Longrightarrow> x = <p1, v0>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> <p0, v1>; x \\<in># sends p s m\\<rbrakk>\n       \\<Longrightarrow> x = <p1, v0>", "assume \"x \\<noteq> <p0, v1>\" \"0 < sends p s m x\""], ["proof (state)\nthis:\n  x \\<noteq> <p0, v1>\n  x \\<in># sends p s m\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> <p0, v1>; x \\<in># sends p s m\\<rbrakk>\n       \\<Longrightarrow> x = <p1, v0>", "thus \"x = <p1, v0>\""], ["proof (prove)\nusing this:\n  x \\<noteq> <p0, v1>\n  x \\<in># sends p s m\n\ngoal (1 subgoal):\n 1. x = <p1, v0>", "by (metis (full_types) neq0_conv sends.simps(1,2) state.exhaust)"], ["proof (state)\nthis:\n  x = <p1, v0>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {v. v \\<in># sends p s m} \\<subseteq> {<p0, v1>, <p1, v0>}\n\ngoal (2 subgoals):\n 1. \\<And>p s m. finite {v. v \\<in># sends p s m}\n 2. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "thus \"finite {v. 0 < sends p s m v}\""], ["proof (prove)\nusing this:\n  {v. v \\<in># sends p s m} \\<subseteq> {<p0, v1>, <p1, v0>}\n\ngoal (1 subgoal):\n 1. finite {v. v \\<in># sends p s m}", "using FinExplSends finite_subset"], ["proof (prove)\nusing this:\n  {v. v \\<in># sends p s m} \\<subseteq> {<p0, v1>, <p1, v0>}\n  finite {<p0, v1>, <p1, v0>}\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite {v. v \\<in># sends p s m}", "by blast"], ["proof (state)\nthis:\n  finite {v. v \\<in># sends p s m}\n\ngoal (1 subgoal):\n 1. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "next\n  \\<comment> \\<open>noInSends\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "fix p s m p2 v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p s m p2 v. sends p s m <p2, inM v> = 0", "show \"sends p s m <p2, inM v> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sends p s m <p2, inM v> = 0", "by (induct s, auto)"], ["proof (state)\nthis:\n  sends p s m <p2, inM v> = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation FLPExec: execution trans sends start exec \"[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execution FLPExistingSystem.trans sends start exec []", "proof\n  \\<comment> \\<open>notEmpty\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. 1 \\<le> length exec\n 2. length exec - 1 = length []\n 3. FLPSys.initial (hd exec)\n 4. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "show \"1 \\<le> length exec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> length exec", "by (simp add:exec_def)"], ["proof (state)\nthis:\n  1 \\<le> length exec\n\ngoal (3 subgoals):\n 1. length exec - 1 = length []\n 2. FLPSys.initial (hd exec)\n 3. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "next\n  \\<comment> \\<open>length\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. length exec - 1 = length []\n 2. FLPSys.initial (hd exec)\n 3. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "show \"length exec - 1 = length []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length exec - 1 = length []", "by (simp add:exec_def)"], ["proof (state)\nthis:\n  length exec - 1 = length []\n\ngoal (2 subgoals):\n 1. FLPSys.initial (hd exec)\n 2. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "next\n  \\<comment> \\<open>base\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. FLPSys.initial (hd exec)\n 2. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "show \"asynchronousSystem.initial start (hd exec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FLPSys.initial (hd exec)", "unfolding asynchronousSystem.initial_def isReceiverOf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p. \\<exists>v. msgs (hd exec) <p, inM v> = 1) \\<and>\n    (\\<forall>p m1 m2.\n        m1 \\<in># msgs (hd exec) \\<and>\n        m2 \\<in># msgs (hd exec) \\<and>\n        rec_message (\\<lambda>p2 v p1. p1 = p2) (\\<lambda>v p1. False)\n         (\\<lambda>p2 v p1. p1 = p2) m1 p \\<and>\n        rec_message (\\<lambda>p2 v p1. p1 = p2) (\\<lambda>v p1. False)\n         (\\<lambda>p2 v p1. p1 = p2) m2 p \\<longrightarrow>\n        m1 = m2) \\<and>\n    (\\<forall>v. msgs (hd exec) <\\<bottom>, outM v> = 0) \\<and>\n    (\\<forall>p v. msgs (hd exec) <p, v> = 0) \\<and>\n    states (hd exec) = start", "by (auto simp add: start_def exec_def, metis proc.exhaust)"], ["proof (state)\nthis:\n  FLPSys.initial (hd exec)\n\ngoal (1 subgoal):\n 1. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "next\n  \\<comment> \\<open>step\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "fix i cfg1 cfg2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "assume \"i < length exec - 1\""], ["proof (state)\nthis:\n  i < length exec - 1\n\ngoal (1 subgoal):\n 1. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "hence \"False\""], ["proof (prove)\nusing this:\n  i < length exec - 1\n\ngoal (1 subgoal):\n 1. False", "by (simp add:exec_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i cfg1 cfg2.\n       \\<lbrakk>i < length exec - 1; cfg1 = exec ! i;\n        cfg2 = exec ! (i + 1)\\<rbrakk>\n       \\<Longrightarrow> FLPSys.steps cfg1 ([] ! i) cfg2", "thus \"asynchronousSystem.steps FLPExistingSystem.trans sends cfg1 ([] ! i) cfg2\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. FLPSys.steps cfg1 ([] ! i) cfg2", "by rule"], ["proof (state)\nthis:\n  FLPSys.steps cfg1 ([] ! i) cfg2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}