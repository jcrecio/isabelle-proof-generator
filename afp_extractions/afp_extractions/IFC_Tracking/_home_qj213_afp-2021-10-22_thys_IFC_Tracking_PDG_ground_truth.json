{"file_name": "/home/qj213/afp-2021-10-22/thys/IFC_Tracking/PDG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IFC_Tracking", "problem_names": ["lemma dcd_pdg: assumes \\<open>n dcd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m via \\<pi>' m'\\<close> obtains l where \\<open>(\\<pi> m,l)\\<in> pdg\\<close> and \\<open>(l,\\<pi> n)\\<in>pdg\\<close>", "lemma scp_slice: \\<open>(\\<pi>, i)\\<in> scp \\<Longrightarrow> \\<pi> i \\<in> slice\\<close>", "lemma scop_slice: \\<open>(\\<pi>, i) \\<in> scop \\<Longrightarrow> \\<pi> i \\<in> slice \\<inter> dom(att)\\<close>", "lemma pdg_correct: assumes \\<open>slice \\<inter> dom(att) = {}\\<close> shows \\<open>secure\\<close>"], "translations": [["", "lemma dcd_pdg: assumes \\<open>n dcd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m via \\<pi>' m'\\<close> obtains l where \\<open>(\\<pi> m,l)\\<in> pdg\\<close> and \\<open>(l,\\<pi> n)\\<in>pdg\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>(\\<pi> m, l) \\<in> pdg; (l, \\<pi> n) \\<in> pdg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>(\\<pi> m, l) \\<in> pdg; (l, \\<pi> n) \\<in> pdg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume r: \\<open>(\\<And>l. (\\<pi> m, l) \\<in> pdg \\<Longrightarrow> (l, \\<pi> n) \\<in> pdg \\<Longrightarrow> thesis)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<pi> m, ?l1) \\<in> pdg; (?l1, \\<pi> n) \\<in> pdg\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>(\\<pi> m, l) \\<in> pdg; (l, \\<pi> n) \\<in> pdg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain l' n' where ln: \\<open>cs\\<^bsup>\\<pi>\\<^esup> m = cs\\<^bsup>\\<pi>'\\<^esup> m' \\<and> cs\\<^bsup>\\<pi>\\<^esup> n = cs\\<^bsup>\\<pi>'\\<^esup> n' \\<and> n' dd\\<^bsup>\\<pi>',v\\<^esup>\\<rightarrow> l' \\<and> l' cd\\<^bsup>\\<pi>'\\<^esup>\\<rightarrow> m'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n' l'.\n        cs\\<^bsup>\\<pi>\\<^esup> m = cs\\<^bsup>\\<pi>'\\<^esup> m' \\<and>\n        cs\\<^bsup>\\<pi>\\<^esup> n = cs\\<^bsup>\\<pi>'\\<^esup> n' \\<and>\n        n' dd\\<^bsup>\\<pi>',v\\<^esup>\\<rightarrow> l' \\<and>\n        l' cd\\<^bsup>\\<pi>'\\<^esup>\\<rightarrow> m' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  n dcd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m via \\<pi>' m'\n\ngoal (1 subgoal):\n 1. (\\<And>n' l'.\n        cs\\<^bsup>\\<pi>\\<^esup> m = cs\\<^bsup>\\<pi>'\\<^esup> m' \\<and>\n        cs\\<^bsup>\\<pi>\\<^esup> n = cs\\<^bsup>\\<pi>'\\<^esup> n' \\<and>\n        n' dd\\<^bsup>\\<pi>',v\\<^esup>\\<rightarrow> l' \\<and>\n        l' cd\\<^bsup>\\<pi>'\\<^esup>\\<rightarrow> m' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_dcdi_via_def"], ["proof (prove)\nusing this:\n  is_path \\<pi> \\<and>\n  m < n \\<and>\n  (\\<exists>l' n'.\n      cs\\<^bsup>\\<pi>\\<^esup> m = cs\\<^bsup>\\<pi>'\\<^esup> m' \\<and>\n      cs\\<^bsup>\\<pi>\\<^esup> n = cs\\<^bsup>\\<pi>'\\<^esup> n' \\<and>\n      n' dd\\<^bsup>\\<pi>',v\\<^esup>\\<rightarrow> l' \\<and>\n      l' cd\\<^bsup>\\<pi>'\\<^esup>\\<rightarrow> m') \\<and>\n  (\\<forall>l\\<in>{m..<n}. v \\<notin> local.writes (\\<pi> l))\n\ngoal (1 subgoal):\n 1. (\\<And>n' l'.\n        cs\\<^bsup>\\<pi>\\<^esup> m = cs\\<^bsup>\\<pi>'\\<^esup> m' \\<and>\n        cs\\<^bsup>\\<pi>\\<^esup> n = cs\\<^bsup>\\<pi>'\\<^esup> n' \\<and>\n        n' dd\\<^bsup>\\<pi>',v\\<^esup>\\<rightarrow> l' \\<and>\n        l' cd\\<^bsup>\\<pi>'\\<^esup>\\<rightarrow> m' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  cs\\<^bsup>\\<pi>\\<^esup> m = cs\\<^bsup>\\<pi>'\\<^esup> m' \\<and>\n  cs\\<^bsup>\\<pi>\\<^esup> n = cs\\<^bsup>\\<pi>'\\<^esup> n' \\<and>\n  n' dd\\<^bsup>\\<pi>',v\\<^esup>\\<rightarrow> l' \\<and>\n  l' cd\\<^bsup>\\<pi>'\\<^esup>\\<rightarrow> m'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>(\\<pi> m, l) \\<in> pdg; (l, \\<pi> n) \\<in> pdg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence  mn: \\<open>\\<pi>' m' = \\<pi> m \\<and> \\<pi>' n' = \\<pi> n\\<close>"], ["proof (prove)\nusing this:\n  cs\\<^bsup>\\<pi>\\<^esup> m = cs\\<^bsup>\\<pi>'\\<^esup> m' \\<and>\n  cs\\<^bsup>\\<pi>\\<^esup> n = cs\\<^bsup>\\<pi>'\\<^esup> n' \\<and>\n  n' dd\\<^bsup>\\<pi>',v\\<^esup>\\<rightarrow> l' \\<and>\n  l' cd\\<^bsup>\\<pi>'\\<^esup>\\<rightarrow> m'\n\ngoal (1 subgoal):\n 1. \\<pi>' m' = \\<pi> m \\<and> \\<pi>' n' = \\<pi> n", "by (metis last_cs ln)"], ["proof (state)\nthis:\n  \\<pi>' m' = \\<pi> m \\<and> \\<pi>' n' = \\<pi> n\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>(\\<pi> m, l) \\<in> pdg; (l, \\<pi> n) \\<in> pdg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 1: \\<open>(\\<pi> m, \\<pi>' l') \\<in> pdg\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi> m, \\<pi>' l') \\<in> pdg", "by (metis ln mn pdg.intros(1))"], ["proof (state)\nthis:\n  (\\<pi> m, \\<pi>' l') \\<in> pdg\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>(\\<pi> m, l) \\<in> pdg; (l, \\<pi> n) \\<in> pdg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have 2: \\<open>(\\<pi>' l', \\<pi> n) \\<in> pdg\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi>' l', \\<pi> n) \\<in> pdg", "by (metis ln mn pdg.intros(2))"], ["proof (state)\nthis:\n  (\\<pi>' l', \\<pi> n) \\<in> pdg\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>(\\<pi> m, l) \\<in> pdg; (l, \\<pi> n) \\<in> pdg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using 1 2 r"], ["proof (prove)\nusing this:\n  (\\<pi> m, \\<pi>' l') \\<in> pdg\n  (\\<pi>' l', \\<pi> n) \\<in> pdg\n  \\<lbrakk>(\\<pi> m, ?l1) \\<in> pdg; (?l1, \\<pi> n) \\<in> pdg\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>By induction it directly follows that the slice is an approximation of the single critical paths.\\<close>"], ["", "lemma scp_slice: \\<open>(\\<pi>, i)\\<in> scp \\<Longrightarrow> \\<pi> i \\<in> slice\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi>, i) \\<in> scp \\<Longrightarrow> \\<pi> i \\<in> slice", "apply (induction rule: scp.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h \\<sigma> n.\n       \\<lbrakk>h \\<in> local.hvars; h \\<in> local.reads (path \\<sigma> n);\n        \\<forall>k<n. h \\<notin> local.writes (path \\<sigma> k)\\<rbrakk>\n       \\<Longrightarrow> path \\<sigma> n \\<in> slice\n 2. \\<And>\\<pi> m n.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        n cd\\<^bsup>\\<pi>\\<^esup>\\<rightarrow> m\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice\n 3. \\<And>\\<pi> m n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        n dd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice\n 4. \\<And>\\<pi> m \\<pi>' m' n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        (\\<pi>', m') \\<in> scp; \\<pi>' m' \\<in> slice;\n        n dcd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m via \\<pi>' m'\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice", "apply (simp add: path_in_nodes slice.intros(1) sources.intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<pi> m n.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        n cd\\<^bsup>\\<pi>\\<^esup>\\<rightarrow> m\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice\n 2. \\<And>\\<pi> m n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        n dd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice\n 3. \\<And>\\<pi> m \\<pi>' m' n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        (\\<pi>', m') \\<in> scp; \\<pi>' m' \\<in> slice;\n        n dcd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m via \\<pi>' m'\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice", "using pdg.intros(1) slice.intros(2)"], ["proof (prove)\nusing this:\n  ?i cd\\<^bsup>?\\<pi>\\<^esup>\\<rightarrow> ?k \\<Longrightarrow>\n  (?\\<pi> ?k, ?\\<pi> ?i) \\<in> pdg\n  \\<lbrakk>?m \\<in> slice; (?m, ?n) \\<in> pdg\\<rbrakk>\n  \\<Longrightarrow> ?n \\<in> slice\n\ngoal (3 subgoals):\n 1. \\<And>\\<pi> m n.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        n cd\\<^bsup>\\<pi>\\<^esup>\\<rightarrow> m\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice\n 2. \\<And>\\<pi> m n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        n dd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice\n 3. \\<And>\\<pi> m \\<pi>' m' n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        (\\<pi>', m') \\<in> scp; \\<pi>' m' \\<in> slice;\n        n dcd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m via \\<pi>' m'\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<pi> m n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        n dd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice\n 2. \\<And>\\<pi> m \\<pi>' m' n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        (\\<pi>', m') \\<in> scp; \\<pi>' m' \\<in> slice;\n        n dcd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m via \\<pi>' m'\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice", "using pdg.intros(2) slice.intros(2)"], ["proof (prove)\nusing this:\n  ?i dd\\<^bsup>?\\<pi>,?v\\<^esup>\\<rightarrow> ?k \\<Longrightarrow>\n  (?\\<pi> ?k, ?\\<pi> ?i) \\<in> pdg\n  \\<lbrakk>?m \\<in> slice; (?m, ?n) \\<in> pdg\\<rbrakk>\n  \\<Longrightarrow> ?n \\<in> slice\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> m n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        n dd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice\n 2. \\<And>\\<pi> m \\<pi>' m' n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        (\\<pi>', m') \\<in> scp; \\<pi>' m' \\<in> slice;\n        n dcd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m via \\<pi>' m'\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> m \\<pi>' m' n v.\n       \\<lbrakk>(\\<pi>, m) \\<in> scp; \\<pi> m \\<in> slice;\n        (\\<pi>', m') \\<in> scp; \\<pi>' m' \\<in> slice;\n        n dcd\\<^bsup>\\<pi>,v\\<^esup>\\<rightarrow> m via \\<pi>' m'\\<rbrakk>\n       \\<Longrightarrow> \\<pi> n \\<in> slice", "by (metis dcd_pdg slice.intros(2))"], ["", "lemma scop_slice: \\<open>(\\<pi>, i) \\<in> scop \\<Longrightarrow> \\<pi> i \\<in> slice \\<inter> dom(att)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi>, i) \\<in> scop \\<Longrightarrow>\n    \\<pi> i \\<in> slice \\<inter> dom local.att", "by (metis IntI scop.cases scp_slice)"], ["", "text \\<open>The requirement targeted by slicing, that no observable node is contained in the slice, \nis thereby a sound criteria for security.\\<close>"], ["", "lemma pdg_correct: assumes \\<open>slice \\<inter> dom(att) = {}\\<close> shows \\<open>secure\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> secure \\<Longrightarrow> False", "assume \\<open>\\<not> secure\\<close>"], ["proof (state)\nthis:\n  \\<not> secure\n\ngoal (1 subgoal):\n 1. \\<not> secure \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> secure", "obtain \\<pi> i where \\<open>(\\<pi>, i) \\<in> scop\\<close>"], ["proof (prove)\nusing this:\n  \\<not> secure\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi> i.\n        (\\<pi>, i) \\<in> scop \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using scop_correct"], ["proof (prove)\nusing this:\n  \\<not> secure\n  scop = {} \\<Longrightarrow> secure\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi> i.\n        (\\<pi>, i) \\<in> scop \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (\\<pi>, i) \\<in> scop\n\ngoal (1 subgoal):\n 1. \\<not> secure \\<Longrightarrow> False", "thus \\<open>False\\<close>"], ["proof (prove)\nusing this:\n  (\\<pi>, i) \\<in> scop\n\ngoal (1 subgoal):\n 1. False", "using scop_slice assms"], ["proof (prove)\nusing this:\n  (\\<pi>, i) \\<in> scop\n  (?\\<pi>, ?i) \\<in> scop \\<Longrightarrow>\n  ?\\<pi> ?i \\<in> slice \\<inter> dom local.att\n  slice \\<inter> dom local.att = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}