{"file_name": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker/BetaNorm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker", "problem_names": ["lemma rtrancl_beta_Abs [intro!]:\n    \"s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' \\<Longrightarrow> Abs T s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* Abs T s'\"", "lemma rtrancl_beta_AppL:\n    \"s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' \\<Longrightarrow> s $ t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' $ t\"", "lemma rtrancl_beta_AppR:\n    \"t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t' \\<Longrightarrow> s $ t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s $ t'\"", "lemma rtrancl_beta_App [intro]:\n    \"s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t' \\<Longrightarrow> s $ t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' $ t'\"", "theorem subst_bv2_preserves_beta [simp]:\n    \"r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> subst_bv2 r k u \\<rightarrow>\\<^sub>\\<beta> subst_bv2 s k u\"", "theorem subst_bv2_preserves_beta': \"r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow> subst_bv2 r i t  \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 s i t\"", "theorem lift_preserves_beta [simp]:\n    \"r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> lift r i \\<rightarrow>\\<^sub>\\<beta> lift s i\"", "theorem lift_preserves_beta': \"r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow> lift r i \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* lift s i\"", "theorem subst_bv2_preserves_beta2 [simp]: \"r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 t i s\"", "theorem subst_bv2_preserves_beta2': \"r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow> subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 t i s\"", "lemma beta_preserves_typ_of1: \"typ_of1 Ts r = Some T \\<Longrightarrow> r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> typ_of1 Ts s = Some T\"", "lemma beta_preserves_typ_of: \"typ_of r = Some T \\<Longrightarrow> r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> typ_of s = Some T\"", "lemma beta_star_preserves_typ_of1: \"r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow> typ_of1 Ts r = Some T  \\<Longrightarrow> typ_of1 Ts s = Some T\"", "lemma beta_reducible_imp_beta_step: \"beta_reducible t \\<Longrightarrow> \\<exists>t'. t \\<rightarrow>\\<^sub>\\<beta> t'\"", "lemma beta_step_imp_beta_reducible: \"t \\<rightarrow>\\<^sub>\\<beta> t' \\<Longrightarrow> beta_reducible t\"", "lemma beta_norm_imp_beta_reds: assumes \"beta_norm t = Some t'\" shows \"t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\"", "lemma beta_imp_beta_norm: assumes \"t \\<rightarrow>\\<^sub>\\<beta> t'\" \"\\<not> beta_reducible t'\" shows \"beta_norm t = Some t'\"", "lemma beta_subst_bv1: \"s \\<rightarrow>\\<^sub>\\<beta> t \\<Longrightarrow> subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta> subst_bv1 t lev x\"", "lemma beta_subst_bv: \"s \\<rightarrow>\\<^sub>\\<beta> t \\<Longrightarrow> subst_bv x s \\<rightarrow>\\<^sub>\\<beta> subst_bv x t\"", "lemma subst_bv1_beta:\n  \"subst_bv1 s (length (T#Ts)) x \\<rightarrow>\\<^sub>\\<beta> subst_bv1 t (length (T#Ts)) x \n  \\<Longrightarrow> typ_of1 Ts s = Some ty\n  \\<Longrightarrow> typ_of1 Ts t = Some ty\n  \\<Longrightarrow> s \\<rightarrow>\\<^sub>\\<beta> t\"", "lemma subst_bvs1'_empty [simp]: \"subst_bvs1' t lev [] = t\"", "lemma subst_bvs1'_eq [simp]: \"args \\<noteq> [] \\<Longrightarrow> subst_bvs1' (Bv k) k args = args ! 0\"", "lemma subst_bvs1'_eq' [simp]: \"i < length args \\<Longrightarrow> subst_bvs1' (Bv (k+i)) k args = args ! i\"", "lemma subst_bvs1'_gt [simp]: \n  \"i + length args < j \\<Longrightarrow> subst_bvs1' (Bv j) i args = Bv (j - length args)\"", "lemma subst_bv2_lt [simp]: \"j < i \\<Longrightarrow> subst_bvs1' (Bv j) i u = Bv j\"", "lemma subst_bvs1'_App[simp]: \"subst_bvs1' (s$t) k args\n  = subst_bvs1' s k args $ subst_bvs1' t k args\"", "lemma incr_bv_incr_bv:\n    \"i < k + 1 \\<Longrightarrow> incr_bv inc2 (k+inc1) (incr_bv inc1 i t) = incr_bv inc1 i (incr_bv inc2 k t)\"", "lemma subst_bvs1_subst_bvs1': \"subst_bvs1 t n s = subst_bvs1' t n (map (incr_bv n 0) s)\"", "theorem subst_bvs1_subst_bvs1'_0: \"subst_bvs1 t 0 s = subst_bvs1' t 0 s\"", "lemma no_loose_bvar_subst_bvs1'_unchanged: \"\\<not> loose_bvar t lev \\<Longrightarrow> subst_bvs1' t lev args = t\"", "lemma subst_bvs1'_step: \"\\<forall>x \\<in> set (a#args) . is_closed x \\<Longrightarrow>\n  subst_bvs1' t lev (a#args) = subst_bvs1' (subst_bv2 t lev a) lev args\"", "lemma not_loose_bvar_incr_bv: \"\\<not> loose_bvar a lev \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc lev a) (lev+inc)\"", "lemma not_loose_bvar_incr_bv_less: \n  \"i < j \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc i a) (lev+inc) \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j a) (lev+inc)\"", "lemma subst_bvs1'_step_work: \"\\<forall>x \\<in> set args . is_closed x \\<Longrightarrow> \\<not> loose_bvar (subst_bv2 t lev a) lev \\<Longrightarrow>\n  subst_bvs1' t lev (a#args) = subst_bvs1' (subst_bv2 t lev a) lev args\"", "lemma is_closed_subst_bv2_unchanged: \"is_closed t \\<Longrightarrow> subst_bv2 t n u = t\"", "lemma subst_bvs1'_step_extend_lower_level: \"\\<forall>x \\<in> set (a#args) . is_closed x \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' t (Suc lev) args) lev a\n    = subst_bvs1' t lev (a#args)\"", "lemma subst_bvs1'_preserves_beta:\n  \"\\<forall>x \\<in> set u . is_closed x \\<Longrightarrow> r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> subst_bvs1' r k u \\<rightarrow>\\<^sub>\\<beta> subst_bvs1' s k u\"", "lemma subst_bvs1'_fold: \"\\<forall>x \\<in> set args . is_closed x \\<Longrightarrow>\n  subst_bvs1' t lev args = fold (\\<lambda>arg t . subst_bv2 t lev arg) args t\"", "lemma subst_bvs1'_Abs[simp]: \"\\<forall>x \\<in> set args . is_closed x \\<Longrightarrow>\n  subst_bvs1' (Abs T t) lev args = Abs T (subst_bvs1' t (Suc lev) args)\"", "lemma subst_bvs_Abs[simp]: \"\\<forall>x \\<in> set args . is_closed x \\<Longrightarrow>\n  subst_bvs args (Abs T t) = Abs T (subst_bvs1' t 1 args)\"", "lemma subst_bvs1'_incr_bv [simp]:\n    \"subst_bvs1' (incr_bv (length ss) k t) k ss = t\"", "lemma lift_subst_bvs1' [simp]:\n    \"j < i + 1 \\<Longrightarrow> lift (subst_bvs1' t j ss) i \n    = subst_bvs1' (lift t (i + length ss)) j (map (\\<lambda>s . lift s i) ss)\"", "lemma lift_subst_bvs1'_lt:\n    \"i < j + 1 \\<Longrightarrow> lift (subst_bvs1' t j ss) i \n  = subst_bvs1' (lift t i) (j + 1) (map (\\<lambda>s . lift s i) ss)\"", "lemma subst_bvs1'_subst_bv2:\n  \"i < j + 1 \\<Longrightarrow> \n    subst_bv2(subst_bvs1' t (Suc j) (map (\\<lambda>v. lift v i) vs)) i (subst_bvs1' u j vs) \n    = subst_bvs1' (subst_bv2 t i u) j vs\"", "lemma fv_subst_bv2_upper_bound: \"fv (subst_bv2 t lev u) \\<subseteq> fv t \\<union> fv u\"", "lemma beta_fv: \"s \\<rightarrow>\\<^sub>\\<beta> t \\<Longrightarrow> fv t \\<subseteq> fv s\"", "lemma loose_bvar1_subst_bvs1'_closeds: \"\\<not> loose_bvar1 t lev \\<Longrightarrow> lev < k \\<Longrightarrow> \\<forall>x\\<in>set us . is_closed x\n  \\<Longrightarrow> \\<not> loose_bvar1 (subst_bvs1' t k us) lev\"", "lemma is_closed_subst_bvs1'_closeds: \"\\<not> is_dependent t \\<Longrightarrow> \\<forall>x\\<in>set us . is_closed x\n  \\<Longrightarrow> \\<not> is_dependent (subst_bvs1' t (Suc k) us)\""], "translations": [["", "lemma rtrancl_beta_Abs [intro!]:\n    \"s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' \\<Longrightarrow> Abs T s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* Abs T s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' \\<Longrightarrow>\n    Abs T s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* Abs T s'", "by (induct set: rtranclp) (blast intro: rtranclp.rtrancl_into_rtrancl)+"], ["", "lemma rtrancl_beta_AppL:\n    \"s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' \\<Longrightarrow> s $ t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' $ t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' \\<Longrightarrow>\n    s $ t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' $ t", "by (induct set: rtranclp) (blast intro: rtranclp.rtrancl_into_rtrancl)+"], ["", "lemma rtrancl_beta_AppR:\n    \"t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t' \\<Longrightarrow> s $ t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s $ t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t' \\<Longrightarrow>\n    s $ t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s $ t'", "by (induct set: rtranclp) (blast intro: rtranclp.rtrancl_into_rtrancl)+"], ["", "lemma rtrancl_beta_App [intro]:\n    \"s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t' \\<Longrightarrow> s $ t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' $ t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s';\n     t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\\<rbrakk>\n    \\<Longrightarrow> s $ t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s' $ t'", "by (blast intro!: rtrancl_beta_AppL rtrancl_beta_AppR intro: rtranclp_trans)"], ["", "theorem subst_bv2_preserves_beta [simp]:\n    \"r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> subst_bv2 r k u \\<rightarrow>\\<^sub>\\<beta> subst_bv2 s k u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n    subst_bv2 r k u \\<rightarrow>\\<^sub>\\<beta> subst_bv2 s k u", "by (induct arbitrary: k u set: beta) (simp_all add: subst_bv2_subst_bv2[symmetric])"], ["", "theorem subst_bv2_preserves_beta': \"r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow> subst_bv2 r i t  \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 s i t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow>\n    subst_bv2 r i t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 s i t", "apply (induct set: rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. subst_bv2 r i t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 r i t\n 2. \\<And>y z.\n       \\<lbrakk>r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* y;\n        y \\<rightarrow>\\<^sub>\\<beta> z;\n        subst_bv2 r i t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n        subst_bv2 y i t\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 r i t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         subst_bv2 z i t", "apply (rule rtranclp.rtrancl_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* y;\n        y \\<rightarrow>\\<^sub>\\<beta> z;\n        subst_bv2 r i t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n        subst_bv2 y i t\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 r i t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         subst_bv2 z i t", "apply (erule rtranclp.rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* y;\n        y \\<rightarrow>\\<^sub>\\<beta> z\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 y i t \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv2 z i t", "apply (erule subst_bv2_preserves_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem lift_preserves_beta [simp]:\n    \"r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> lift r i \\<rightarrow>\\<^sub>\\<beta> lift s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n    lift r i \\<rightarrow>\\<^sub>\\<beta> lift s i", "proof (induction arbitrary: i set: beta)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>T s t i.\n       lift (Abs T s $ t) i \\<rightarrow>\\<^sub>\\<beta>\n       lift (subst_bv2 s 0 t) i\n 2. \\<And>s t u i.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>i. lift s i \\<rightarrow>\\<^sub>\\<beta> lift t i\\<rbrakk>\n       \\<Longrightarrow> lift (s $ u) i \\<rightarrow>\\<^sub>\\<beta>\n                         lift (t $ u) i\n 3. \\<And>s t u i.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>i. lift s i \\<rightarrow>\\<^sub>\\<beta> lift t i\\<rbrakk>\n       \\<Longrightarrow> lift (u $ s) i \\<rightarrow>\\<^sub>\\<beta>\n                         lift (u $ t) i\n 4. \\<And>s t T i.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>i. lift s i \\<rightarrow>\\<^sub>\\<beta> lift t i\\<rbrakk>\n       \\<Longrightarrow> lift (Abs T s) i \\<rightarrow>\\<^sub>\\<beta>\n                         lift (Abs T t) i", "case (beta T s t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>T s t i.\n       lift (Abs T s $ t) i \\<rightarrow>\\<^sub>\\<beta>\n       lift (subst_bv2 s 0 t) i\n 2. \\<And>s t u i.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>i. lift s i \\<rightarrow>\\<^sub>\\<beta> lift t i\\<rbrakk>\n       \\<Longrightarrow> lift (s $ u) i \\<rightarrow>\\<^sub>\\<beta>\n                         lift (t $ u) i\n 3. \\<And>s t u i.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>i. lift s i \\<rightarrow>\\<^sub>\\<beta> lift t i\\<rbrakk>\n       \\<Longrightarrow> lift (u $ s) i \\<rightarrow>\\<^sub>\\<beta>\n                         lift (u $ t) i\n 4. \\<And>s t T i.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>i. lift s i \\<rightarrow>\\<^sub>\\<beta> lift t i\\<rbrakk>\n       \\<Longrightarrow> lift (Abs T s) i \\<rightarrow>\\<^sub>\\<beta>\n                         lift (Abs T t) i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (Abs T s $ t) i \\<rightarrow>\\<^sub>\\<beta>\n    lift (subst_bv2 s 0 t) i", "using lift_subst"], ["proof (prove)\nusing this:\n  ?j < ?i + 1 \\<Longrightarrow>\n  lift (subst_bv2 ?t ?j ?s) ?i =\n  subst_bv2 (lift ?t (?i + 1)) ?j (lift ?s ?i)\n\ngoal (1 subgoal):\n 1. lift (Abs T s $ t) i \\<rightarrow>\\<^sub>\\<beta>\n    lift (subst_bv2 s 0 t) i", "by force"], ["proof (state)\nthis:\n  lift (Abs T s $ t) i \\<rightarrow>\\<^sub>\\<beta> lift (subst_bv2 s 0 t) i\n\ngoal (3 subgoals):\n 1. \\<And>s t u i.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>i. lift s i \\<rightarrow>\\<^sub>\\<beta> lift t i\\<rbrakk>\n       \\<Longrightarrow> lift (s $ u) i \\<rightarrow>\\<^sub>\\<beta>\n                         lift (t $ u) i\n 2. \\<And>s t u i.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>i. lift s i \\<rightarrow>\\<^sub>\\<beta> lift t i\\<rbrakk>\n       \\<Longrightarrow> lift (u $ s) i \\<rightarrow>\\<^sub>\\<beta>\n                         lift (u $ t) i\n 3. \\<And>s t T i.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>i. lift s i \\<rightarrow>\\<^sub>\\<beta> lift t i\\<rbrakk>\n       \\<Longrightarrow> lift (Abs T s) i \\<rightarrow>\\<^sub>\\<beta>\n                         lift (Abs T t) i", "qed auto"], ["", "theorem lift_preserves_beta': \"r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow> lift r i \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* lift s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow>\n    lift r i \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* lift s i", "apply (induct set: rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. lift r i \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* lift r i\n 2. \\<And>y z.\n       \\<lbrakk>r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* y;\n        y \\<rightarrow>\\<^sub>\\<beta> z;\n        lift r i \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* lift y i\\<rbrakk>\n       \\<Longrightarrow> lift r i \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         lift z i", "apply (rule rtranclp.rtrancl_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* y;\n        y \\<rightarrow>\\<^sub>\\<beta> z;\n        lift r i \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* lift y i\\<rbrakk>\n       \\<Longrightarrow> lift r i \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         lift z i", "apply (erule rtranclp.rtrancl_into_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* y;\n        y \\<rightarrow>\\<^sub>\\<beta> z\\<rbrakk>\n       \\<Longrightarrow> lift y i \\<rightarrow>\\<^sub>\\<beta> lift z i", "apply (erule lift_preserves_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem subst_bv2_preserves_beta2 [simp]: \"r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 t i s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n    subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 t i s", "apply (induct t arbitrary: r s i)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 r s i.\n       r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n       subst_bv2 (Ct x1 x2) i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n       subst_bv2 (Ct x1 x2) i s\n 2. \\<And>x1 x2 r s i.\n       r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n       subst_bv2 (Fv x1 x2) i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n       subst_bv2 (Fv x1 x2) i s\n 3. \\<And>x r s i.\n       r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n       subst_bv2 (Bv x) i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n       subst_bv2 (Bv x) i s\n 4. \\<And>x1 t r s i.\n       \\<lbrakk>\\<And>r s i.\n                   r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n                   subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                   subst_bv2 t i s;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (Abs x1 t) i\n                          r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         subst_bv2 (Abs x1 t) i s\n 5. \\<And>t1 t2 r s i.\n       \\<lbrakk>\\<And>r s i.\n                   r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n                   subst_bv2 t1 i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                   subst_bv2 t1 i s;\n        \\<And>r s i.\n           r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n           subst_bv2 t2 i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n           subst_bv2 t2 i s;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (t1 $ t2) i\n                          r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         subst_bv2 (t1 $ t2) i s", "apply (solves \\<open>simp add: r_into_rtranclp\\<close>)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 t r s i.\n       \\<lbrakk>\\<And>r s i.\n                   r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n                   subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                   subst_bv2 t i s;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (Abs x1 t) i\n                          r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         subst_bv2 (Abs x1 t) i s\n 2. \\<And>t1 t2 r s i.\n       \\<lbrakk>\\<And>r s i.\n                   r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n                   subst_bv2 t1 i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                   subst_bv2 t1 i s;\n        \\<And>r s i.\n           r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n           subst_bv2 t2 i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n           subst_bv2 t2 i s;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (t1 $ t2) i\n                          r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         subst_bv2 (t1 $ t2) i s", "using lift_preserves_beta"], ["proof (prove)\nusing this:\n  ?r \\<rightarrow>\\<^sub>\\<beta> ?s \\<Longrightarrow>\n  lift ?r ?i \\<rightarrow>\\<^sub>\\<beta> lift ?s ?i\n\ngoal (2 subgoals):\n 1. \\<And>x1 t r s i.\n       \\<lbrakk>\\<And>r s i.\n                   r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n                   subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                   subst_bv2 t i s;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (Abs x1 t) i\n                          r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         subst_bv2 (Abs x1 t) i s\n 2. \\<And>t1 t2 r s i.\n       \\<lbrakk>\\<And>r s i.\n                   r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n                   subst_bv2 t1 i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                   subst_bv2 t1 i s;\n        \\<And>r s i.\n           r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow>\n           subst_bv2 t2 i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n           subst_bv2 t2 i s;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (t1 $ t2) i\n                          r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         subst_bv2 (t1 $ t2) i s", "by (auto simp add: rtrancl_beta_App)"], ["", "theorem subst_bv2_preserves_beta2': \"r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow> subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 t i s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow>\n    subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 t i s", "apply (induct set: rtranclp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* subst_bv2 t i r\n 2. \\<And>y z.\n       \\<lbrakk>r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* y;\n        y \\<rightarrow>\\<^sub>\\<beta> z;\n        subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n        subst_bv2 t i y\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 t i r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         subst_bv2 t i z", "apply (auto elim: rtranclp_trans subst_bv2_preserves_beta2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma beta_preserves_typ_of1: \"typ_of1 Ts r = Some T \\<Longrightarrow> r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> typ_of1 Ts s = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typ_of1 Ts r = Some T; r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n    \\<Longrightarrow> typ_of1 Ts s = Some T", "proof (induction Ts r arbitrary: s T rule: typ_of1.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>uu_ uv_ T s Ta.\n       \\<lbrakk>typ_of1 uu_ (Ct uv_ T) = Some Ta;\n        Ct uv_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ s = Some Ta\n 2. \\<And>Ts i s T.\n       \\<lbrakk>typ_of1 Ts (Bv i) = Some T;\n        Bv i \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 3. \\<And>uw_ ux_ T s Ta.\n       \\<lbrakk>typ_of1 uw_ (Fv ux_ T) = Some Ta;\n        Fv ux_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ s = Some Ta\n 4. \\<And>Ts T body s Ta.\n       \\<lbrakk>\\<And>s Ta.\n                   \\<lbrakk>typ_of1 (T # Ts) body = Some Ta;\n                    body \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 (T # Ts) s = Some Ta;\n        typ_of1 Ts (Abs T body) = Some Ta;\n        Abs T body \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some Ta\n 5. \\<And>Ts t u s T.\n       \\<lbrakk>\\<And>s T.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a s T.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some T;\n            t \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (t $ u) = Some T;\n        t $ u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T", "case (4 Ts T body)"], ["proof (state)\nthis:\n  \\<lbrakk>typ_of1 (Ta__ # Ts) body = Some ?T;\n   body \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (Ta__ # Ts) ?s = Some ?T\n  typ_of1 Ts (Abs Ta__ body) = Some T\n  Abs Ta__ body \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (5 subgoals):\n 1. \\<And>uu_ uv_ T s Ta.\n       \\<lbrakk>typ_of1 uu_ (Ct uv_ T) = Some Ta;\n        Ct uv_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ s = Some Ta\n 2. \\<And>Ts i s T.\n       \\<lbrakk>typ_of1 Ts (Bv i) = Some T;\n        Bv i \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 3. \\<And>uw_ ux_ T s Ta.\n       \\<lbrakk>typ_of1 uw_ (Fv ux_ T) = Some Ta;\n        Fv ux_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ s = Some Ta\n 4. \\<And>Ts T body s Ta.\n       \\<lbrakk>\\<And>s Ta.\n                   \\<lbrakk>typ_of1 (T # Ts) body = Some Ta;\n                    body \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 (T # Ts) s = Some Ta;\n        typ_of1 Ts (Abs T body) = Some Ta;\n        Abs T body \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some Ta\n 5. \\<And>Ts t u s T.\n       \\<lbrakk>\\<And>s T.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a s T.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some T;\n            t \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (t $ u) = Some T;\n        t $ u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>typ_of1 (Ta__ # Ts) body = Some ?T;\n   body \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (Ta__ # Ts) ?s = Some ?T\n  typ_of1 Ts (Abs Ta__ body) = Some T\n  Abs Ta__ body \\<rightarrow>\\<^sub>\\<beta> s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>typ_of1 (Ta__ # Ts) body = Some ?T;\n   body \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (Ta__ # Ts) ?s = Some ?T\n  typ_of1 Ts (Abs Ta__ body) = Some T\n  Abs Ta__ body \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (1 subgoal):\n 1. typ_of1 Ts s = Some T", "by (smt beta_cases(3) typ_of1.simps(4) typ_of_Abs_body_typ')"], ["proof (state)\nthis:\n  typ_of1 Ts s = Some T\n\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T s Ta.\n       \\<lbrakk>typ_of1 uu_ (Ct uv_ T) = Some Ta;\n        Ct uv_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ s = Some Ta\n 2. \\<And>Ts i s T.\n       \\<lbrakk>typ_of1 Ts (Bv i) = Some T;\n        Bv i \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 3. \\<And>uw_ ux_ T s Ta.\n       \\<lbrakk>typ_of1 uw_ (Fv ux_ T) = Some Ta;\n        Fv ux_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ s = Some Ta\n 4. \\<And>Ts t u s T.\n       \\<lbrakk>\\<And>s T.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a s T.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some T;\n            t \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (t $ u) = Some T;\n        t $ u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T s Ta.\n       \\<lbrakk>typ_of1 uu_ (Ct uv_ T) = Some Ta;\n        Ct uv_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ s = Some Ta\n 2. \\<And>Ts i s T.\n       \\<lbrakk>typ_of1 Ts (Bv i) = Some T;\n        Bv i \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 3. \\<And>uw_ ux_ T s Ta.\n       \\<lbrakk>typ_of1 uw_ (Fv ux_ T) = Some Ta;\n        Fv ux_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ s = Some Ta\n 4. \\<And>Ts t u s T.\n       \\<lbrakk>\\<And>s T.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a s T.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some T;\n            t \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (t $ u) = Some T;\n        t $ u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T", "case (5 Ts f u)"], ["proof (state)\nthis:\n  \\<lbrakk>typ_of1 Ts u = Some ?T; u \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  \\<lbrakk>typ_of1 Ts u = Some ?a; typ_of1 Ts f = Some ?T;\n   f \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  typ_of1 Ts (f $ u) = Some T\n  f $ u \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T s Ta.\n       \\<lbrakk>typ_of1 uu_ (Ct uv_ T) = Some Ta;\n        Ct uv_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ s = Some Ta\n 2. \\<And>Ts i s T.\n       \\<lbrakk>typ_of1 Ts (Bv i) = Some T;\n        Bv i \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 3. \\<And>uw_ ux_ T s Ta.\n       \\<lbrakk>typ_of1 uw_ (Fv ux_ T) = Some Ta;\n        Fv ux_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ s = Some Ta\n 4. \\<And>Ts t u s T.\n       \\<lbrakk>\\<And>s T.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a s T.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some T;\n            t \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (t $ u) = Some T;\n        t $ u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>typ_of1 Ts u = Some ?T; u \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  \\<lbrakk>typ_of1 Ts u = Some ?a; typ_of1 Ts f = Some ?T;\n   f \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  typ_of1 Ts (f $ u) = Some T\n  f $ u \\<rightarrow>\\<^sub>\\<beta> s", "obtain argT where argT: \"typ_of1 Ts u = Some argT\" and \"typ_of1 Ts f = Some (argT \\<rightarrow> T)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>typ_of1 Ts u = Some ?T; u \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  \\<lbrakk>typ_of1 Ts u = Some ?a; typ_of1 Ts f = Some ?T;\n   f \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  typ_of1 Ts (f $ u) = Some T\n  f $ u \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (1 subgoal):\n 1. (\\<And>argT.\n        \\<lbrakk>typ_of1 Ts u = Some argT;\n         typ_of1 Ts f = Some (argT \\<rightarrow> T)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson typ_of1_split_App_obtains)"], ["proof (state)\nthis:\n  typ_of1 Ts u = Some argT\n  typ_of1 Ts f = Some (argT \\<rightarrow> T)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T s Ta.\n       \\<lbrakk>typ_of1 uu_ (Ct uv_ T) = Some Ta;\n        Ct uv_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ s = Some Ta\n 2. \\<And>Ts i s T.\n       \\<lbrakk>typ_of1 Ts (Bv i) = Some T;\n        Bv i \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 3. \\<And>uw_ ux_ T s Ta.\n       \\<lbrakk>typ_of1 uw_ (Fv ux_ T) = Some Ta;\n        Fv ux_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ s = Some Ta\n 4. \\<And>Ts t u s T.\n       \\<lbrakk>\\<And>s T.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a s T.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some T;\n            t \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (t $ u) = Some T;\n        t $ u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T", "from 5"], ["proof (chain)\npicking this:\n  \\<lbrakk>typ_of1 Ts u = Some ?T; u \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  \\<lbrakk>typ_of1 Ts u = Some ?a; typ_of1 Ts f = Some ?T;\n   f \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  typ_of1 Ts (f $ u) = Some T\n  f $ u \\<rightarrow>\\<^sub>\\<beta> s", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>typ_of1 Ts u = Some ?T; u \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  \\<lbrakk>typ_of1 Ts u = Some ?a; typ_of1 Ts f = Some ?T;\n   f \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts ?s = Some ?T\n  typ_of1 Ts (f $ u) = Some T\n  f $ u \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (1 subgoal):\n 1. typ_of1 Ts s = Some T", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>T s.\n                \\<lbrakk>typ_of1 Ts u = Some T;\n                 u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                \\<Longrightarrow> typ_of1 Ts s = Some T;\n     \\<And>a T s.\n        \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts f = Some T;\n         f \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n        \\<Longrightarrow> typ_of1 Ts s = Some T;\n     typ_of1 Ts (f $ u) = Some T;\n     f $ u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n    \\<Longrightarrow> typ_of1 Ts s = Some T", "apply (ind_cases \"f $ u \\<rightarrow>\\<^sub>\\<beta> s\" for f u s)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>T s.\n       \\<lbrakk>\\<And>T s.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a T s.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts f = Some T;\n            f \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (f $ u) = Some T; f = Abs T s;\n        s = subst_bv2 s 0 u\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 2. \\<And>t.\n       \\<lbrakk>\\<And>T s.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a T s.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts f = Some T;\n            f \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (f $ u) = Some T; s = t $ u;\n        f \\<rightarrow>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 3. \\<And>t.\n       \\<lbrakk>\\<And>T s.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a T s.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts f = Some T;\n            f \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (f $ u) = Some T; s = f $ t;\n        u \\<rightarrow>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T", "using \\<open>typ_of1 Ts f = Some (argT \\<rightarrow> T)\\<close> argT typ_of1_subst_bv_gen' \n      typ_of_Abs_body_typ'"], ["proof (prove)\nusing this:\n  typ_of1 Ts f = Some (argT \\<rightarrow> T)\n  typ_of1 Ts u = Some argT\n  \\<lbrakk>typ_of1 (?uty # ?Ts) ?t = Some ?tty;\n   typ_of1 ?Ts ?u = Some ?uty\\<rbrakk>\n  \\<Longrightarrow> typ_of1 ?Ts (subst_bv1 ?t 0 ?u) = Some ?tty\n  typ_of1 ?Ts (Abs ?T ?t) = Some ?ty \\<Longrightarrow>\n  \\<exists>rty.\n     ?ty = ?T \\<rightarrow> rty \\<and> typ_of1 (?T # ?Ts) ?t = Some rty\n\ngoal (3 subgoals):\n 1. \\<And>T s.\n       \\<lbrakk>\\<And>T s.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a T s.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts f = Some T;\n            f \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (f $ u) = Some T; f = Abs T s;\n        s = subst_bv2 s 0 u\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 2. \\<And>t.\n       \\<lbrakk>\\<And>T s.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a T s.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts f = Some T;\n            f \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (f $ u) = Some T; s = t $ u;\n        f \\<rightarrow>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 3. \\<And>t.\n       \\<lbrakk>\\<And>T s.\n                   \\<lbrakk>typ_of1 Ts u = Some T;\n                    u \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts s = Some T;\n        \\<And>a T s.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts f = Some T;\n            f \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts s = Some T;\n        typ_of1 Ts (f $ u) = Some T; s = f $ t;\n        u \\<rightarrow>\\<^sub>\\<beta> t\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T", "by (fastforce simp add: substn_subst_n)+"], ["proof (state)\nthis:\n  typ_of1 Ts s = Some T\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T s Ta.\n       \\<lbrakk>typ_of1 uu_ (Ct uv_ T) = Some Ta;\n        Ct uv_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ s = Some Ta\n 2. \\<And>Ts i s T.\n       \\<lbrakk>typ_of1 Ts (Bv i) = Some T;\n        Bv i \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts s = Some T\n 3. \\<And>uw_ ux_ T s Ta.\n       \\<lbrakk>typ_of1 uw_ (Fv ux_ T) = Some Ta;\n        Fv ux_ T \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ s = Some Ta", "qed (use beta.cases in \\<open>blast+\\<close>)"], ["", "lemma beta_preserves_typ_of: \"typ_of r = Some T \\<Longrightarrow> r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> typ_of s = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typ_of r = Some T; r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n    \\<Longrightarrow> typ_of s = Some T", "by (metis beta_preserves_typ_of1 typ_of_def)"], ["", "lemma beta_star_preserves_typ_of1: \"r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s \\<Longrightarrow> typ_of1 Ts r = Some T  \\<Longrightarrow> typ_of1 Ts s = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* s;\n     typ_of1 Ts r = Some T\\<rbrakk>\n    \\<Longrightarrow> typ_of1 Ts s = Some T", "proof (induction rule: rtranclp.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts a = Some T\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* b;\n        typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts b = Some T;\n        b \\<rightarrow>\\<^sub>\\<beta> c; typ_of1 Ts a = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts c = Some T", "case (rtrancl_refl a)"], ["proof (state)\nthis:\n  typ_of1 Ts a = Some T\n\ngoal (2 subgoals):\n 1. \\<And>a. typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts a = Some T\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* b;\n        typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts b = Some T;\n        b \\<rightarrow>\\<^sub>\\<beta> c; typ_of1 Ts a = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts c = Some T", "then"], ["proof (chain)\npicking this:\n  typ_of1 Ts a = Some T", "show ?case"], ["proof (prove)\nusing this:\n  typ_of1 Ts a = Some T\n\ngoal (1 subgoal):\n 1. typ_of1 Ts a = Some T", "by simp"], ["proof (state)\nthis:\n  typ_of1 Ts a = Some T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* b;\n        typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts b = Some T;\n        b \\<rightarrow>\\<^sub>\\<beta> c; typ_of1 Ts a = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts c = Some T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* b;\n        typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts b = Some T;\n        b \\<rightarrow>\\<^sub>\\<beta> c; typ_of1 Ts a = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts c = Some T", "case (rtrancl_into_rtrancl a b c)"], ["proof (state)\nthis:\n  a \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* b\n  b \\<rightarrow>\\<^sub>\\<beta> c\n  typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts b = Some T\n  typ_of1 Ts a = Some T\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* b;\n        typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts b = Some T;\n        b \\<rightarrow>\\<^sub>\\<beta> c; typ_of1 Ts a = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts c = Some T", "then"], ["proof (chain)\npicking this:\n  a \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* b\n  b \\<rightarrow>\\<^sub>\\<beta> c\n  typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts b = Some T\n  typ_of1 Ts a = Some T", "show ?case"], ["proof (prove)\nusing this:\n  a \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* b\n  b \\<rightarrow>\\<^sub>\\<beta> c\n  typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts b = Some T\n  typ_of1 Ts a = Some T\n\ngoal (1 subgoal):\n 1. typ_of1 Ts c = Some T", "using beta_preserves_typ_of1"], ["proof (prove)\nusing this:\n  a \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* b\n  b \\<rightarrow>\\<^sub>\\<beta> c\n  typ_of1 Ts a = Some T \\<Longrightarrow> typ_of1 Ts b = Some T\n  typ_of1 Ts a = Some T\n  \\<lbrakk>typ_of1 ?Ts ?r = Some ?T;\n   ?r \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> typ_of1 ?Ts ?s = Some ?T\n\ngoal (1 subgoal):\n 1. typ_of1 Ts c = Some T", "by blast"], ["proof (state)\nthis:\n  typ_of1 Ts c = Some T\n\ngoal:\nNo subgoals!", "qed"], ["", "(* \n  Convert beta_norm to the inductive predicates. Then later show that one beta step can be justified\n  using proves\n*)"], ["", "lemma beta_reducible_imp_beta_step: \"beta_reducible t \\<Longrightarrow> \\<exists>t'. t \\<rightarrow>\\<^sub>\\<beta> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_reducible t \\<Longrightarrow>\n    \\<exists>t'. t \\<rightarrow>\\<^sub>\\<beta> t'", "proof (induction t)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       beta_reducible (Ct x1 x2) \\<Longrightarrow>\n       Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Ct x1 x2))\n 2. \\<And>x1 x2.\n       beta_reducible (Fv x1 x2) \\<Longrightarrow>\n       Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Fv x1 x2))\n 3. \\<And>x.\n       beta_reducible (Bv x) \\<Longrightarrow>\n       Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Bv x))\n 4. \\<And>x1 t.\n       \\<lbrakk>beta_reducible t \\<Longrightarrow>\n                Ex ((\\<rightarrow>\\<^sub>\\<beta>) t);\n        beta_reducible (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Abs x1 t))\n 5. \\<And>t1 t2.\n       \\<lbrakk>beta_reducible t1 \\<Longrightarrow>\n                Ex ((\\<rightarrow>\\<^sub>\\<beta>) t1);\n        beta_reducible t2 \\<Longrightarrow>\n        Ex ((\\<rightarrow>\\<^sub>\\<beta>) t2);\n        beta_reducible (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> Ex ((\\<rightarrow>\\<^sub>\\<beta>) (t1 $ t2))", "case (App t1 t2)"], ["proof (state)\nthis:\n  beta_reducible t1 \\<Longrightarrow>\n  \\<exists>a. t1 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible t2 \\<Longrightarrow>\n  \\<exists>a. t2 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible (t1 $ t2)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       beta_reducible (Ct x1 x2) \\<Longrightarrow>\n       Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Ct x1 x2))\n 2. \\<And>x1 x2.\n       beta_reducible (Fv x1 x2) \\<Longrightarrow>\n       Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Fv x1 x2))\n 3. \\<And>x.\n       beta_reducible (Bv x) \\<Longrightarrow>\n       Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Bv x))\n 4. \\<And>x1 t.\n       \\<lbrakk>beta_reducible t \\<Longrightarrow>\n                Ex ((\\<rightarrow>\\<^sub>\\<beta>) t);\n        beta_reducible (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Abs x1 t))\n 5. \\<And>t1 t2.\n       \\<lbrakk>beta_reducible t1 \\<Longrightarrow>\n                Ex ((\\<rightarrow>\\<^sub>\\<beta>) t1);\n        beta_reducible t2 \\<Longrightarrow>\n        Ex ((\\<rightarrow>\\<^sub>\\<beta>) t2);\n        beta_reducible (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> Ex ((\\<rightarrow>\\<^sub>\\<beta>) (t1 $ t2))", "then"], ["proof (chain)\npicking this:\n  beta_reducible t1 \\<Longrightarrow>\n  \\<exists>a. t1 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible t2 \\<Longrightarrow>\n  \\<exists>a. t2 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible (t1 $ t2)", "show ?case"], ["proof (prove)\nusing this:\n  beta_reducible t1 \\<Longrightarrow>\n  \\<exists>a. t1 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible t2 \\<Longrightarrow>\n  \\<exists>a. t2 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible (t1 $ t2)\n\ngoal (1 subgoal):\n 1. \\<exists>a. t1 $ t2 \\<rightarrow>\\<^sub>\\<beta> a", "using App"], ["proof (prove)\nusing this:\n  beta_reducible t1 \\<Longrightarrow>\n  \\<exists>a. t1 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible t2 \\<Longrightarrow>\n  \\<exists>a. t2 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible (t1 $ t2)\n  beta_reducible t1 \\<Longrightarrow>\n  \\<exists>a. t1 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible t2 \\<Longrightarrow>\n  \\<exists>a. t2 \\<rightarrow>\\<^sub>\\<beta> a\n  beta_reducible (t1 $ t2)\n\ngoal (1 subgoal):\n 1. \\<exists>a. t1 $ t2 \\<rightarrow>\\<^sub>\\<beta> a", "by (cases t1) auto"], ["proof (state)\nthis:\n  \\<exists>a. t1 $ t2 \\<rightarrow>\\<^sub>\\<beta> a\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       beta_reducible (Ct x1 x2) \\<Longrightarrow>\n       Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Ct x1 x2))\n 2. \\<And>x1 x2.\n       beta_reducible (Fv x1 x2) \\<Longrightarrow>\n       Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Fv x1 x2))\n 3. \\<And>x.\n       beta_reducible (Bv x) \\<Longrightarrow>\n       Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Bv x))\n 4. \\<And>x1 t.\n       \\<lbrakk>beta_reducible t \\<Longrightarrow>\n                Ex ((\\<rightarrow>\\<^sub>\\<beta>) t);\n        beta_reducible (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> Ex ((\\<rightarrow>\\<^sub>\\<beta>) (Abs x1 t))", "qed auto"], ["", "lemma beta_step_imp_beta_reducible: \"t \\<rightarrow>\\<^sub>\\<beta> t' \\<Longrightarrow> beta_reducible t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta> t' \\<Longrightarrow> beta_reducible t", "proof (induction t t' rule: beta.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>T s t. beta_reducible (Abs T s $ t)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (s $ u)\n 3. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (u $ s)\n 4. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "case (beta T s t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>T s t. beta_reducible (Abs T s $ t)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (s $ u)\n 3. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (u $ s)\n 4. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_reducible (Abs T s $ t)", "by simp"], ["proof (state)\nthis:\n  beta_reducible (Abs T s $ t)\n\ngoal (3 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (s $ u)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (u $ s)\n 3. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (s $ u)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (u $ s)\n 3. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "case (appL s t u)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s\n\ngoal (3 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (s $ u)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (u $ s)\n 3. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "then"], ["proof (chain)\npicking this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s", "show ?case"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s\n\ngoal (1 subgoal):\n 1. beta_reducible (s $ u)", "by (cases s) auto"], ["proof (state)\nthis:\n  beta_reducible (s $ u)\n\ngoal (2 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (u $ s)\n 2. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (u $ s)\n 2. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "case (appR s t u)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s\n\ngoal (2 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (u $ s)\n 2. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "then"], ["proof (chain)\npicking this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s", "show ?case"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s\n\ngoal (1 subgoal):\n 1. beta_reducible (u $ s)", "using beta_reducible.elims"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s\n  \\<lbrakk>beta_reducible ?x = ?y;\n   \\<And>uu_ uv_ uw_.\n      \\<lbrakk>?x = Abs uu_ uv_ $ uw_; ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; ?y = beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       ?y = (beta_reducible (Ct v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       ?y = (beta_reducible (Fv v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       ?y = (beta_reducible (Bv v) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       ?y = (beta_reducible (v $ va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va.\n      \\<lbrakk>?x = Ct v va; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v va.\n      \\<lbrakk>?x = Fv v va; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v.\n      \\<lbrakk>?x = Bv v; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>beta_reducible ?x;\n   \\<And>uu_ uv_ uw_. ?x = Abs uu_ uv_ $ uw_ \\<Longrightarrow> ?P;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       beta_reducible (Ct v va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       beta_reducible (Fv v va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       beta_reducible (Bv v) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       beta_reducible (v $ va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>\\<not> beta_reducible ?x;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; \\<not> beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       \\<not> (beta_reducible (Ct v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       \\<not> (beta_reducible (Fv v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       \\<not> (beta_reducible (Bv v) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       \\<not> (beta_reducible (v $ va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = Ct v va \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = Fv v va \\<Longrightarrow> ?P;\n   \\<And>v. ?x = Bv v \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. beta_reducible (u $ s)", "by blast"], ["proof (state)\nthis:\n  beta_reducible (u $ s)\n\ngoal (1 subgoal):\n 1. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "case (abs s t T)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s\n\ngoal (1 subgoal):\n 1. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t; beta_reducible s\\<rbrakk>\n       \\<Longrightarrow> beta_reducible (Abs T s)", "then"], ["proof (chain)\npicking this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s", "show ?case"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  beta_reducible s\n\ngoal (1 subgoal):\n 1. beta_reducible (Abs T s)", "by simp"], ["proof (state)\nthis:\n  beta_reducible (Abs T s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beta_norm_imp_beta_reds: assumes \"beta_norm t = Some t'\" shows \"t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "using assms"], ["proof (prove)\nusing this:\n  beta_norm t = Some t'\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof (induction arbitrary: t t' rule: beta_norm.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. option.admissible\n     (\\<lambda>beta_norm.\n         \\<forall>x xa.\n            beta_norm x = Some xa \\<longrightarrow>\n            x \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* xa)\n 2. \\<And>t t'.\n       None = Some t' \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>t ta t'.\n       \\<lbrakk>\\<And>ta t'.\n                   t ta = Some t' \\<Longrightarrow>\n                   ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case ta of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (t body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case t (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case t (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Bv nat $ u \\<Rightarrow>\n             case t (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Abs T body $ u \\<Rightarrow> t (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case t (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)) =\n        Some t'\\<rbrakk>\n       \\<Longrightarrow> ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. option.admissible\n     (\\<lambda>beta_norm.\n         \\<forall>x xa.\n            beta_norm x = Some xa \\<longrightarrow>\n            x \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* xa)\n 2. \\<And>t t'.\n       None = Some t' \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>t ta t'.\n       \\<lbrakk>\\<And>ta t'.\n                   t ta = Some t' \\<Longrightarrow>\n                   ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case ta of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (t body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case t (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case t (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Bv nat $ u \\<Rightarrow>\n             case t (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Abs T body $ u \\<Rightarrow> t (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case t (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)) =\n        Some t'\\<rbrakk>\n       \\<Longrightarrow> ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. option.admissible\n     (\\<lambda>beta_norm.\n         \\<forall>x xa.\n            beta_norm x = Some xa \\<longrightarrow>\n            x \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* xa)", "by (smt Option.is_none_def ccpo.admissibleI chain_fun flat_lub_def flat_ord_def fun_lub_def \n        insertCI is_none_code(2) mem_Collect_eq option.lub_upper subsetI)"], ["proof (state)\nthis:\n  option.admissible\n   (\\<lambda>beta_norm.\n       \\<forall>x xa.\n          beta_norm x = Some xa \\<longrightarrow>\n          x \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* xa)\n\ngoal (2 subgoals):\n 1. \\<And>t t'.\n       None = Some t' \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>t ta t'.\n       \\<lbrakk>\\<And>ta t'.\n                   t ta = Some t' \\<Longrightarrow>\n                   ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case ta of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (t body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case t (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case t (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Bv nat $ u \\<Rightarrow>\n             case t (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Abs T body $ u \\<Rightarrow> t (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case t (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)) =\n        Some t'\\<rbrakk>\n       \\<Longrightarrow> ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t'.\n       None = Some t' \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>t ta t'.\n       \\<lbrakk>\\<And>ta t'.\n                   t ta = Some t' \\<Longrightarrow>\n                   ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case ta of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (t body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case t (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case t (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Bv nat $ u \\<Rightarrow>\n             case t (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Abs T body $ u \\<Rightarrow> t (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case t (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)) =\n        Some t'\\<rbrakk>\n       \\<Longrightarrow> ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case 2"], ["proof (state)\nthis:\n  None = Some t'\n\ngoal (2 subgoals):\n 1. \\<And>t t'.\n       None = Some t' \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>t ta t'.\n       \\<lbrakk>\\<And>ta t'.\n                   t ta = Some t' \\<Longrightarrow>\n                   ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case ta of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (t body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case t (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case t (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Bv nat $ u \\<Rightarrow>\n             case t (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Abs T body $ u \\<Rightarrow> t (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case t (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)) =\n        Some t'\\<rbrakk>\n       \\<Longrightarrow> ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  None = Some t'", "show ?case"], ["proof (prove)\nusing this:\n  None = Some t'\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by simp"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (1 subgoal):\n 1. \\<And>t ta t'.\n       \\<lbrakk>\\<And>ta t'.\n                   t ta = Some t' \\<Longrightarrow>\n                   ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case ta of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (t body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case t (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case t (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Bv nat $ u \\<Rightarrow>\n             case t (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Abs T body $ u \\<Rightarrow> t (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case t (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)) =\n        Some t'\\<rbrakk>\n       \\<Longrightarrow> ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t ta t'.\n       \\<lbrakk>\\<And>ta t'.\n                   t ta = Some t' \\<Longrightarrow>\n                   ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case ta of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (t body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case t (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case t (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Bv nat $ u \\<Rightarrow>\n             case t (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Abs T body $ u \\<Rightarrow> t (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case t (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)) =\n        Some t'\\<rbrakk>\n       \\<Longrightarrow> ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (3 comp)"], ["proof (state)\nthis:\n  comp ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n   | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n   | Bv nat \\<Rightarrow> Some (Bv nat)\n   | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n   | Ct literal typ $ u \\<Rightarrow>\n       case comp (Ct literal typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Fv variable typ $ u \\<Rightarrow>\n       case comp (Fv variable typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Bv nat $ u \\<Rightarrow>\n       case comp (Bv nat) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n   | term1 $ term2 $ u \\<Rightarrow>\n       case comp (term1 $ term2) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)) =\n  Some t'\n\ngoal (1 subgoal):\n 1. \\<And>t ta t'.\n       \\<lbrakk>\\<And>ta t'.\n                   t ta = Some t' \\<Longrightarrow>\n                   ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case ta of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (t body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case t (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case t (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Bv nat $ u \\<Rightarrow>\n             case t (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)\n         | Abs T body $ u \\<Rightarrow> t (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case t (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (t u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (t u)\n             | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (t u)\n             | Some (Abs T body) \\<Rightarrow> t (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (t u)) =\n        Some t'\\<rbrakk>\n       \\<Longrightarrow> ta \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  comp ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n   | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n   | Bv nat \\<Rightarrow> Some (Bv nat)\n   | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n   | Ct literal typ $ u \\<Rightarrow>\n       case comp (Ct literal typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Fv variable typ $ u \\<Rightarrow>\n       case comp (Fv variable typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Bv nat $ u \\<Rightarrow>\n       case comp (Bv nat) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n   | term1 $ term2 $ u \\<Rightarrow>\n       case comp (term1 $ term2) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)) =\n  Some t'", "show ?case"], ["proof (prove)\nusing this:\n  comp ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n   | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n   | Bv nat \\<Rightarrow> Some (Bv nat)\n   | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n   | Ct literal typ $ u \\<Rightarrow>\n       case comp (Ct literal typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Fv variable typ $ u \\<Rightarrow>\n       case comp (Fv variable typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Bv nat $ u \\<Rightarrow>\n       case comp (Bv nat) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n   | term1 $ term2 $ u \\<Rightarrow>\n       case comp (term1 $ term2) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)) =\n  Some t'\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof(cases t)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (App f u)"], ["proof (state)\nthis:\n  t = f $ u\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "note fu = App"], ["proof (state)\nthis:\n  t = f $ u\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  t = f $ u", "show ?thesis"], ["proof (prove)\nusing this:\n  t = f $ u\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof (cases \"comp f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>t = f $ u; comp f = None\\<rbrakk>\n    \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>a.\n       \\<lbrakk>t = f $ u; comp f = Some a\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case None"], ["proof (state)\nthis:\n  comp f = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t = f $ u; comp f = None\\<rbrakk>\n    \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>a.\n       \\<lbrakk>t = f $ u; comp f = Some a\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof(cases f)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       f = Ct x11 x12 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       f = Fv x21 x22 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       f = Bv x3 \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       f = Abs x41 x42 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       f = x51 $ x52 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Abs B b)"], ["proof (state)\nthis:\n  f = Abs B b\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       f = Ct x11 x12 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       f = Fv x21 x22 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       f = Bv x3 \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       f = Abs x41 x42 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       f = x51 $ x52 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Abs B b", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Abs B b\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by (metis (mono_tags, lifting) \"3.IH\" \"3.prems\" Core.subst_bv_def Core.term.simps(29) \n              Core.term.simps(30) beta fu rtranclp.rtrancl_into_rtrancl rtranclp.rtrancl_refl rtranclp_trans)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       f = Ct x11 x12 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       f = Fv x21 x22 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       f = Bv x3 \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       f = x51 $ x52 \\<Longrightarrow>\n       t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "qed (use 3 None in \\<open>simp_all add: fu split: term.splits option.splits if_splits\\<close>)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>t = f $ u; comp f = Some a\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>t = f $ u; comp f = Some a\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Some fo)"], ["proof (state)\nthis:\n  comp f = Some fo\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>t = f $ u; comp f = Some a\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  comp f = Some fo", "show ?thesis"], ["proof (prove)\nusing this:\n  comp f = Some fo\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof(cases fo)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>comp f = Some fo; fo = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>comp f = Some fo; fo = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>comp f = Some fo; fo = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Ct n T)"], ["proof (state)\nthis:\n  fo = Ct n T\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>comp f = Some fo; fo = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>comp f = Some fo; fo = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>comp f = Some fo; fo = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  fo = Ct n T", "show ?thesis"], ["proof (prove)\nusing this:\n  fo = Ct n T\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof(cases f)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Ct n T; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Ct n T; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Ct n T; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = Ct n T; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = Ct n T; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Abs B b)"], ["proof (state)\nthis:\n  f = Abs B b\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Ct n T; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Ct n T; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Ct n T; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = Ct n T; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = Ct n T; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Abs B b", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Abs B b\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by (metis (no_types, lifting) \"3.IH\" \"3.prems\" Core.subst_bv_def Core.term.simps(29)\n                Core.term.simps(30) beta converse_rtranclp_into_rtranclp fu)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Ct n T; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Ct n T; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Ct n T; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>fo = Ct n T; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "qed (use 3 Some in \\<open>auto simp add: fu split: term.splits option.splits if_split\\<close>)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>comp f = Some fo; fo = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x3.\n       \\<lbrakk>comp f = Some fo; fo = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>comp f = Some fo; fo = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x3.\n       \\<lbrakk>comp f = Some fo; fo = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Fv n T)"], ["proof (state)\nthis:\n  fo = Fv n T\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>comp f = Some fo; fo = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x3.\n       \\<lbrakk>comp f = Some fo; fo = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  fo = Fv n T", "show ?thesis"], ["proof (prove)\nusing this:\n  fo = Fv n T\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof(cases f)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Fv n T; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Fv n T; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Fv n T; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = Fv n T; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = Fv n T; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Abs B b)"], ["proof (state)\nthis:\n  f = Abs B b\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Fv n T; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Fv n T; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Fv n T; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = Fv n T; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = Fv n T; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Abs B b", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Abs B b\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by (metis (no_types, lifting) \"3.IH\" \"3.prems\" Core.subst_bv_def Core.term.simps(29)\n                Core.term.simps(30) beta converse_rtranclp_into_rtranclp fu)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Fv n T; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Fv n T; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Fv n T; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>fo = Fv n T; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "qed (use 3 Some in \\<open>auto simp add: fu split: term.splits option.splits if_split\\<close>)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>comp f = Some fo; fo = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>comp f = Some fo; fo = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Bv n)"], ["proof (state)\nthis:\n  fo = Bv n\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>comp f = Some fo; fo = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  fo = Bv n", "show ?thesis"], ["proof (prove)\nusing this:\n  fo = Bv n\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof(cases f)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Bv n; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Bv n; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Bv n; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = Bv n; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = Bv n; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Abs B b)"], ["proof (state)\nthis:\n  f = Abs B b\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Bv n; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Bv n; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Bv n; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = Bv n; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = Bv n; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Abs B b", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Abs B b\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by (metis (no_types, lifting) \"3.IH\" \"3.prems\" Core.subst_bv_def Core.term.simps(29)\n                Core.term.simps(30) beta converse_rtranclp_into_rtranclp fu)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Bv n; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Bv n; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Bv n; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>fo = Bv n; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "qed (use 3 Some in \\<open>auto simp add: fu split: term.splits option.splits if_split\\<close>)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Abs T t)"], ["proof (state)\nthis:\n  fo = Abs T t\n\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>comp f = Some fo; fo = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  fo = Abs T t", "show ?thesis"], ["proof (prove)\nusing this:\n  fo = Abs T t\n\ngoal (1 subgoal):\n 1. ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof(cases f)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Abs T t; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Abs T t; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Abs T t; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Ct n C)"], ["proof (state)\nthis:\n  f = Ct n C\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = Abs T t; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = Abs T t; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = Abs T t; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by (metis \"3.IH\" Abs Core.term.simps(11) Ct Some beta_reducible.simps(7) \n                beta_step_imp_beta_reducible converse_rtranclpE)"], ["proof (state)\nthis:\n  ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>fo = Abs T t; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x3.\n       \\<lbrakk>fo = Abs T t; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>fo = Abs T t; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x3.\n       \\<lbrakk>fo = Abs T t; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Fv n C)"], ["proof (state)\nthis:\n  f = Fv n C\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>fo = Abs T t; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x3.\n       \\<lbrakk>fo = Abs T t; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Fv n C", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Fv n C\n\ngoal (1 subgoal):\n 1. ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by (metis \"3.IH\" Abs Fv Some beta_reducible.simps(1,4,8) beta_step_imp_beta_reducible \n                converse_rtranclpE)"], ["proof (state)\nthis:\n  ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>fo = Abs T t; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>fo = Abs T t; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Bv n)"], ["proof (state)\nthis:\n  f = Bv n\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>fo = Abs T t; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Bv n", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Bv n\n\ngoal (1 subgoal):\n 1. ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by (metis \"3.IH\" Abs Some beta_cases(1) converse_rtranclpE term.distinct(15))"], ["proof (state)\nthis:\n  ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Abs B b)"], ["proof (state)\nthis:\n  f = Abs B b\n\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>fo = Abs T t; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Abs B b", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Abs B b\n\ngoal (1 subgoal):\n 1. ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by (metis (no_types, lifting) \"3.IH\" \"3.prems\" Core.subst_bv_def Core.term.simps(29)\n                Core.term.simps(30) beta converse_rtranclp_into_rtranclp fu)"], ["proof (state)\nthis:\n  ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (App a b)"], ["proof (state)\nthis:\n  f = a $ b\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>fo = Abs T t; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  f = a $ b\n\ngoal (1 subgoal):\n 1. ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "using 3"], ["proof (prove)\nusing this:\n  f = a $ b\n  comp ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  (case ta__ of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n   | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n   | Bv nat \\<Rightarrow> Some (Bv nat)\n   | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n   | Ct literal typ $ u \\<Rightarrow>\n       case comp (Ct literal typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Fv variable typ $ u \\<Rightarrow>\n       case comp (Fv variable typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Bv nat $ u \\<Rightarrow>\n       case comp (Bv nat) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n   | term1 $ term2 $ u \\<Rightarrow>\n       case comp (term1 $ term2) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)) =\n  Some t'\n\ngoal (1 subgoal):\n 1. ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "apply (simp add: fu Some split: term.splits option.splits if_splits; fast?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x41 x42.\n       \\<lbrakk>f = a $ b;\n        \\<And>t t'.\n           comp t = Some t' \\<Longrightarrow>\n           t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        comp (a $ b) = Some (Abs x41 x42); x2 = Abs x41 x42;\n        comp (subst_bv u x42) = Some t'\\<rbrakk>\n       \\<Longrightarrow> a $ b $ u \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "by (metis Core.subst_bv_def beta converse_rtranclp_into_rtranclp rtrancl_beta_AppL rtranclp_trans)"], ["proof (state)\nthis:\n  ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> ta__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>comp f = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case AppO: (App f u)"], ["proof (state)\nthis:\n  fo = f $ u\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>comp f__ = Some fo; fo = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  fo = f $ u", "show ?thesis"], ["proof (prove)\nusing this:\n  fo = f $ u\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "proof(cases f)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = f $ u; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = f $ u; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = f $ u; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Ct n C)"], ["proof (state)\nthis:\n  f = Ct n C\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>fo = f $ u; f = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>fo = f $ u; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>fo = f $ u; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 5. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "using 3 Some"], ["proof (prove)\nusing this:\n  comp ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n   | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n   | Bv nat \\<Rightarrow> Some (Bv nat)\n   | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n   | Ct literal typ $ u \\<Rightarrow>\n       case comp (Ct literal typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Fv variable typ $ u \\<Rightarrow>\n       case comp (Fv variable typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Bv nat $ u \\<Rightarrow>\n       case comp (Bv nat) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n   | term1 $ term2 $ u \\<Rightarrow>\n       case comp (term1 $ term2) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)) =\n  Some t'\n  comp f__ = Some fo\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "apply (simp add: Ct AppO fu split: term.splits option.splits if_split; fast?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>comp (Abs x41 x42) = Some (Ct n C $ u);\n        \\<And>t t'.\n           comp t = Some t' \\<Longrightarrow>\n           t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        f__ = Abs x41 x42; comp (subst_bv u__ x42) = Some t'\\<rbrakk>\n       \\<Longrightarrow> Abs x41 x42 $\n                         u__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         t'", "by (metis Core.subst_bv_def beta converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>fo = f $ u; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x3.\n       \\<lbrakk>fo = f $ u; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>fo = f $ u; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x3.\n       \\<lbrakk>fo = f $ u; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Fv n C)"], ["proof (state)\nthis:\n  f = Fv n C\n\ngoal (4 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>fo = f $ u; f = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x3.\n       \\<lbrakk>fo = f $ u; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Fv n C", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Fv n C\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "using 3 Some"], ["proof (prove)\nusing this:\n  f = Fv n C\n  comp ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n   | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n   | Bv nat \\<Rightarrow> Some (Bv nat)\n   | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n   | Ct literal typ $ u \\<Rightarrow>\n       case comp (Ct literal typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Fv variable typ $ u \\<Rightarrow>\n       case comp (Fv variable typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Bv nat $ u \\<Rightarrow>\n       case comp (Bv nat) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n   | term1 $ term2 $ u \\<Rightarrow>\n       case comp (term1 $ term2) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)) =\n  Some t'\n  comp f__ = Some fo\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "apply (simp add: Fv AppO fu split: term.splits option.splits if_split; fast?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>comp (Abs x41 x42) = Some (Fv n C $ u);\n        \\<And>t t'.\n           comp t = Some t' \\<Longrightarrow>\n           t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        f__ = Abs x41 x42; comp (subst_bv u__ x42) = Some t'\\<rbrakk>\n       \\<Longrightarrow> Abs x41 x42 $\n                         u__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         t'", "by (metis Core.subst_bv_def beta converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>fo = f $ u; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>fo = f $ u; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Bv n)"], ["proof (state)\nthis:\n  f = Bv n\n\ngoal (3 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>fo = f $ u; f = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Bv n", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Bv n\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "using 3 Some"], ["proof (prove)\nusing this:\n  f = Bv n\n  comp ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n   | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n   | Bv nat \\<Rightarrow> Some (Bv nat)\n   | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n   | Ct literal typ $ u \\<Rightarrow>\n       case comp (Ct literal typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Fv variable typ $ u \\<Rightarrow>\n       case comp (Fv variable typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Bv nat $ u \\<Rightarrow>\n       case comp (Bv nat) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n   | term1 $ term2 $ u \\<Rightarrow>\n       case comp (term1 $ term2) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)) =\n  Some t'\n  comp f__ = Some fo\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "apply (simp add: Bv AppO fu split: term.splits option.splits if_split; fast?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>comp (Abs x41 x42) = Some (Bv n $ u);\n        \\<And>t t'.\n           comp t = Some t' \\<Longrightarrow>\n           t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        f__ = Abs x41 x42; comp (subst_bv u__ x42) = Some t'\\<rbrakk>\n       \\<Longrightarrow> Abs x41 x42 $\n                         u__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         t'", "by (metis Core.subst_bv_def beta converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (Abs B b)"], ["proof (state)\nthis:\n  f = Abs B b\n\ngoal (2 subgoals):\n 1. \\<And>x41 x42.\n       \\<lbrakk>fo = f $ u; f = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = Abs B b", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Abs B b\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "using 3 Some"], ["proof (prove)\nusing this:\n  f = Abs B b\n  comp ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n   | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n   | Bv nat \\<Rightarrow> Some (Bv nat)\n   | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n   | Ct literal typ $ u \\<Rightarrow>\n       case comp (Ct literal typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Fv variable typ $ u \\<Rightarrow>\n       case comp (Fv variable typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Bv nat $ u \\<Rightarrow>\n       case comp (Bv nat) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n   | term1 $ term2 $ u \\<Rightarrow>\n       case comp (term1 $ term2) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)) =\n  Some t'\n  comp f__ = Some fo\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "apply (simp add: Abs AppO fu split: term.splits option.splits if_split; fast?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>comp (Abs x41 x42) = Some (Abs B b $ u);\n        \\<And>t t'.\n           comp t = Some t' \\<Longrightarrow>\n           t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        f__ = Abs x41 x42; comp (subst_bv u__ x42) = Some t'\\<rbrakk>\n       \\<Longrightarrow> Abs x41 x42 $\n                         u__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         t'", "by (metis Core.subst_bv_def beta converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "case (App a b)"], ["proof (state)\nthis:\n  f = a $ b\n\ngoal (1 subgoal):\n 1. \\<And>x51 x52.\n       \\<lbrakk>fo = f $ u; f = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "then"], ["proof (chain)\npicking this:\n  f = a $ b", "show ?thesis"], ["proof (prove)\nusing this:\n  f = a $ b\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "using 3 Some"], ["proof (prove)\nusing this:\n  f = a $ b\n  comp ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n   | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n   | Bv nat \\<Rightarrow> Some (Bv nat)\n   | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n   | Ct literal typ $ u \\<Rightarrow>\n       case comp (Ct literal typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Fv variable typ $ u \\<Rightarrow>\n       case comp (Fv variable typ) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Bv nat $ u \\<Rightarrow>\n       case comp (Bv nat) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)\n   | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n   | term1 $ term2 $ u \\<Rightarrow>\n       case comp (term1 $ term2) of None \\<Rightarrow> None\n       | Some (Ct literal typ) \\<Rightarrow>\n           map_option (($) (Ct literal typ)) (comp u)\n       | Some (Fv variable typ) \\<Rightarrow>\n           map_option (($) (Fv variable typ)) (comp u)\n       | Some (Bv nat) \\<Rightarrow> map_option (($) (Bv nat)) (comp u)\n       | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n       | Some (term1 $ term2) \\<Rightarrow>\n           map_option (($) (term1 $ term2)) (comp u)) =\n  Some t'\n  comp f__ = Some fo\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "apply (simp add: App AppO fu split: term.splits option.splits if_split; fast?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x41 x42.\n       \\<lbrakk>comp (Abs x41 x42) = Some (a $ b $ u);\n        \\<And>t t'.\n           comp t = Some t' \\<Longrightarrow>\n           t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        f__ = Abs x41 x42; comp (subst_bv u__ x42) = Some t'\\<rbrakk>\n       \\<Longrightarrow> Abs x41 x42 $\n                         u__ \\<rightarrow>\\<^sub>\\<beta>\\<^sup>*\n                         t'", "by (metis Core.subst_bv_def beta converse_rtranclp_into_rtranclp)"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 3. \\<And>x3.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Bv x3\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n 4. \\<And>x41 x42.\n       \\<lbrakk>\\<And>t t'.\n                   comp t = Some t' \\<Longrightarrow>\n                   t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t';\n        (case t of Ct literal typ \\<Rightarrow> Some (Ct literal typ)\n         | Fv variable typ \\<Rightarrow> Some (Fv variable typ)\n         | Bv nat \\<Rightarrow> Some (Bv nat)\n         | Abs T body \\<Rightarrow> map_option (Abs T) (comp body)\n         | Ct literal typ $ u \\<Rightarrow>\n             case comp (Ct literal typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Fv variable typ $ u \\<Rightarrow>\n             case comp (Fv variable typ) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Bv nat $ u \\<Rightarrow>\n             case comp (Bv nat) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)\n         | Abs T body $ u \\<Rightarrow> comp (subst_bv u body)\n         | term1 $ term2 $ u \\<Rightarrow>\n             case comp (term1 $ term2) of None \\<Rightarrow> None\n             | Some (Ct literal typ) \\<Rightarrow>\n                 map_option (($) (Ct literal typ)) (comp u)\n             | Some (Fv variable typ) \\<Rightarrow>\n                 map_option (($) (Fv variable typ)) (comp u)\n             | Some (Bv nat) \\<Rightarrow>\n                 map_option (($) (Bv nat)) (comp u)\n             | Some (Abs T body) \\<Rightarrow> comp (subst_bv u body)\n             | Some (term1 $ term2) \\<Rightarrow>\n                 map_option (($) (term1 $ term2)) (comp u)) =\n        Some t';\n        t = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'", "qed auto"], ["proof (state)\nthis:\n  t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* t'\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \"beta_norm t = Some t' \\<Longrightarrow> typ_of1 Ts t = Some T \\<Longrightarrow> typ_of1 Ts t' = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>beta_norm t = Some t'; typ_of1 Ts t = Some T\\<rbrakk>\n    \\<Longrightarrow> typ_of1 Ts t' = Some T", "using beta_norm_imp_beta_reds beta_star_preserves_typ_of1"], ["proof (prove)\nusing this:\n  beta_norm ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  \\<lbrakk>?r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?s;\n   typ_of1 ?Ts ?r = Some ?T\\<rbrakk>\n  \\<Longrightarrow> typ_of1 ?Ts ?s = Some ?T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>beta_norm t = Some t'; typ_of1 Ts t = Some T\\<rbrakk>\n    \\<Longrightarrow> typ_of1 Ts t' = Some T", "by blast"], ["", "lemma beta_imp_beta_norm: assumes \"t \\<rightarrow>\\<^sub>\\<beta> t'\" \"\\<not> beta_reducible t'\" shows \"beta_norm t = Some t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_norm t = Some t'", "using assms"], ["proof (prove)\nusing this:\n  t \\<rightarrow>\\<^sub>\\<beta> t'\n  \\<not> beta_reducible t'\n\ngoal (1 subgoal):\n 1. beta_norm t = Some t'", "proof (induction rule: beta.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>T s t.\n       \\<not> beta_reducible (subst_bv2 s 0 t) \\<Longrightarrow>\n       beta_norm (Abs T s $ t) = Some (subst_bv2 s 0 t)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (t $ u)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 3. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 4. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "case (beta T s t)"], ["proof (state)\nthis:\n  \\<not> beta_reducible (subst_bv2 s 0 t)\n\ngoal (4 subgoals):\n 1. \\<And>T s t.\n       \\<not> beta_reducible (subst_bv2 s 0 t) \\<Longrightarrow>\n       beta_norm (Abs T s $ t) = Some (subst_bv2 s 0 t)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (t $ u)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 3. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 4. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "then"], ["proof (chain)\npicking this:\n  \\<not> beta_reducible (subst_bv2 s 0 t)", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> beta_reducible (subst_bv2 s 0 t)\n\ngoal (1 subgoal):\n 1. beta_norm (Abs T s $ t) = Some (subst_bv2 s 0 t)", "using not_beta_reducible_imp_beta_norm_unchanged"], ["proof (prove)\nusing this:\n  \\<not> beta_reducible (subst_bv2 s 0 t)\n  \\<not> beta_reducible ?t \\<Longrightarrow> beta_norm ?t = Some ?t\n\ngoal (1 subgoal):\n 1. beta_norm (Abs T s $ t) = Some (subst_bv2 s 0 t)", "by (auto simp add: subst_bv_def substn_subst_n)"], ["proof (state)\nthis:\n  beta_norm (Abs T s $ t) = Some (subst_bv2 s 0 t)\n\ngoal (3 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (t $ u)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 3. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (t $ u)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 3. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "case (appL s t u)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (t $ u)\n\ngoal (3 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (t $ u)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 3. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "hence t: \"\\<not> beta_reducible t\""], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (t $ u)\n\ngoal (1 subgoal):\n 1. \\<not> beta_reducible t", "by (fastforce elim: beta_reducible.elims)"], ["proof (state)\nthis:\n  \\<not> beta_reducible t\n\ngoal (3 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (t $ u)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 3. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "hence IH: \"beta_norm s = Some t\""], ["proof (prove)\nusing this:\n  \\<not> beta_reducible t\n\ngoal (1 subgoal):\n 1. beta_norm s = Some t", "using appL.IH"], ["proof (prove)\nusing this:\n  \\<not> beta_reducible t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n\ngoal (1 subgoal):\n 1. beta_norm s = Some t", "by simp"], ["proof (state)\nthis:\n  beta_norm s = Some t\n\ngoal (3 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (t $ u)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 3. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "from appL"], ["proof (chain)\npicking this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (t $ u)", "have u: \"\\<not> beta_reducible u\""], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (t $ u)\n\ngoal (1 subgoal):\n 1. \\<not> beta_reducible u", "using beta_reducible.elims"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (t $ u)\n  \\<lbrakk>beta_reducible ?x = ?y;\n   \\<And>uu_ uv_ uw_.\n      \\<lbrakk>?x = Abs uu_ uv_ $ uw_; ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; ?y = beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       ?y = (beta_reducible (Ct v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       ?y = (beta_reducible (Fv v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       ?y = (beta_reducible (Bv v) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       ?y = (beta_reducible (v $ va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va.\n      \\<lbrakk>?x = Ct v va; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v va.\n      \\<lbrakk>?x = Fv v va; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v.\n      \\<lbrakk>?x = Bv v; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>beta_reducible ?x;\n   \\<And>uu_ uv_ uw_. ?x = Abs uu_ uv_ $ uw_ \\<Longrightarrow> ?P;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       beta_reducible (Ct v va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       beta_reducible (Fv v va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       beta_reducible (Bv v) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       beta_reducible (v $ va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>\\<not> beta_reducible ?x;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; \\<not> beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       \\<not> (beta_reducible (Ct v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       \\<not> (beta_reducible (Fv v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       \\<not> (beta_reducible (Bv v) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       \\<not> (beta_reducible (v $ va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = Ct v va \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = Fv v va \\<Longrightarrow> ?P;\n   \\<And>v. ?x = Bv v \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<not> beta_reducible u", "by blast"], ["proof (state)\nthis:\n  \\<not> beta_reducible u\n\ngoal (3 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (t $ u)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 2. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 3. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_norm (s $ u) = Some (t $ u)", "apply (cases s; cases t)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x11 x12 x11a x12a.\n       \\<lbrakk>s = Ct x11 x12; t = Ct x11a x12a\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 2. \\<And>x11 x12 x21 x22.\n       \\<lbrakk>s = Ct x11 x12; t = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 3. \\<And>x11 x12 x3.\n       \\<lbrakk>s = Ct x11 x12; t = Bv x3\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 4. \\<And>x11 x12 x41 x42.\n       \\<lbrakk>s = Ct x11 x12; t = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 5. \\<And>x11 x12 x51 x52.\n       \\<lbrakk>s = Ct x11 x12; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 6. \\<And>x21 x22 x11 x12.\n       \\<lbrakk>s = Fv x21 x22; t = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 7. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>s = Fv x21 x22; t = Fv x21a x22a\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 8. \\<And>x21 x22 x3.\n       \\<lbrakk>s = Fv x21 x22; t = Bv x3\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 9. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>s = Fv x21 x22; t = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 10. \\<And>x21 x22 x51 x52.\n        \\<lbrakk>s = Fv x21 x22; t = x51 $ x52\\<rbrakk>\n        \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\nA total of 25 subgoals...", "using not_beta_reducible_imp_beta_norm_unchanged IH t u appL.prems"], ["proof (prove)\nusing this:\n  \\<not> beta_reducible ?t \\<Longrightarrow> beta_norm ?t = Some ?t\n  beta_norm s = Some t\n  \\<not> beta_reducible t\n  \\<not> beta_reducible u\n  \\<not> beta_reducible (t $ u)\n\ngoal (25 subgoals):\n 1. \\<And>x11 x12 x11a x12a.\n       \\<lbrakk>s = Ct x11 x12; t = Ct x11a x12a\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 2. \\<And>x11 x12 x21 x22.\n       \\<lbrakk>s = Ct x11 x12; t = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 3. \\<And>x11 x12 x3.\n       \\<lbrakk>s = Ct x11 x12; t = Bv x3\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 4. \\<And>x11 x12 x41 x42.\n       \\<lbrakk>s = Ct x11 x12; t = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 5. \\<And>x11 x12 x51 x52.\n       \\<lbrakk>s = Ct x11 x12; t = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 6. \\<And>x21 x22 x11 x12.\n       \\<lbrakk>s = Fv x21 x22; t = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 7. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>s = Fv x21 x22; t = Fv x21a x22a\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 8. \\<And>x21 x22 x3.\n       \\<lbrakk>s = Fv x21 x22; t = Bv x3\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 9. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>s = Fv x21 x22; t = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\n 10. \\<And>x21 x22 x51 x52.\n        \\<lbrakk>s = Fv x21 x22; t = x51 $ x52\\<rbrakk>\n        \\<Longrightarrow> beta_norm (s $ u) = Some (t $ u)\nA total of 25 subgoals...", "by auto"], ["proof (state)\nthis:\n  beta_norm (s $ u) = Some (t $ u)\n\ngoal (2 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 2. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 2. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "case (appR s t u)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (u $ t)\n\ngoal (2 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 2. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "hence t: \"\\<not> beta_reducible t\""], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (u $ t)\n\ngoal (1 subgoal):\n 1. \\<not> beta_reducible t", "using beta_reducible.elims"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (u $ t)\n  \\<lbrakk>beta_reducible ?x = ?y;\n   \\<And>uu_ uv_ uw_.\n      \\<lbrakk>?x = Abs uu_ uv_ $ uw_; ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; ?y = beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       ?y = (beta_reducible (Ct v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       ?y = (beta_reducible (Fv v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       ?y = (beta_reducible (Bv v) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       ?y = (beta_reducible (v $ va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va.\n      \\<lbrakk>?x = Ct v va; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v va.\n      \\<lbrakk>?x = Fv v va; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v.\n      \\<lbrakk>?x = Bv v; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>beta_reducible ?x;\n   \\<And>uu_ uv_ uw_. ?x = Abs uu_ uv_ $ uw_ \\<Longrightarrow> ?P;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       beta_reducible (Ct v va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       beta_reducible (Fv v va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       beta_reducible (Bv v) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       beta_reducible (v $ va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>\\<not> beta_reducible ?x;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; \\<not> beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       \\<not> (beta_reducible (Ct v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       \\<not> (beta_reducible (Fv v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       \\<not> (beta_reducible (Bv v) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       \\<not> (beta_reducible (v $ va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = Ct v va \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = Fv v va \\<Longrightarrow> ?P;\n   \\<And>v. ?x = Bv v \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<not> beta_reducible t", "by blast"], ["proof (state)\nthis:\n  \\<not> beta_reducible t\n\ngoal (2 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 2. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "hence IH: \"beta_norm s = Some t\""], ["proof (prove)\nusing this:\n  \\<not> beta_reducible t\n\ngoal (1 subgoal):\n 1. beta_norm s = Some t", "using appR.IH"], ["proof (prove)\nusing this:\n  \\<not> beta_reducible t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n\ngoal (1 subgoal):\n 1. beta_norm s = Some t", "by simp"], ["proof (state)\nthis:\n  beta_norm s = Some t\n\ngoal (2 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 2. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "from appR"], ["proof (chain)\npicking this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (u $ t)", "have u: \"\\<not> beta_reducible u\""], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (u $ t)\n\ngoal (1 subgoal):\n 1. \\<not> beta_reducible u", "using beta_reducible.elims"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (u $ t)\n  \\<lbrakk>beta_reducible ?x = ?y;\n   \\<And>uu_ uv_ uw_.\n      \\<lbrakk>?x = Abs uu_ uv_ $ uw_; ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; ?y = beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       ?y = (beta_reducible (Ct v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       ?y = (beta_reducible (Fv v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       ?y = (beta_reducible (Bv v) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       ?y = (beta_reducible (v $ va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va.\n      \\<lbrakk>?x = Ct v va; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v va.\n      \\<lbrakk>?x = Fv v va; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v.\n      \\<lbrakk>?x = Bv v; \\<not> ?y\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>beta_reducible ?x;\n   \\<And>uu_ uv_ uw_. ?x = Abs uu_ uv_ $ uw_ \\<Longrightarrow> ?P;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       beta_reducible (Ct v va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       beta_reducible (Fv v va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       beta_reducible (Bv v) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       beta_reducible (v $ va) \\<or> beta_reducible u\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>\\<not> beta_reducible ?x;\n   \\<And>ux_ t.\n      \\<lbrakk>?x = Abs ux_ t; \\<not> beta_reducible t\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Ct v va $ u;\n       \\<not> (beta_reducible (Ct v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = Fv v va $ u;\n       \\<not> (beta_reducible (Fv v va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v u.\n      \\<lbrakk>?x = Bv v $ u;\n       \\<not> (beta_reducible (Bv v) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va u.\n      \\<lbrakk>?x = v $ va $ u;\n       \\<not> (beta_reducible (v $ va) \\<or> beta_reducible u)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = Ct v va \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = Fv v va \\<Longrightarrow> ?P;\n   \\<And>v. ?x = Bv v \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<not> beta_reducible u", "by blast"], ["proof (state)\nthis:\n  \\<not> beta_reducible u\n\ngoal (2 subgoals):\n 1. \\<And>s t u.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (u $ t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 2. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_norm (u $ s) = Some (u $ t)", "apply (cases s; cases u)"], ["proof (prove)\ngoal (25 subgoals):\n 1. \\<And>x11 x12 x11a x12a.\n       \\<lbrakk>s = Ct x11 x12; u = Ct x11a x12a\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 2. \\<And>x11 x12 x21 x22.\n       \\<lbrakk>s = Ct x11 x12; u = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 3. \\<And>x11 x12 x3.\n       \\<lbrakk>s = Ct x11 x12; u = Bv x3\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 4. \\<And>x11 x12 x41 x42.\n       \\<lbrakk>s = Ct x11 x12; u = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 5. \\<And>x11 x12 x51 x52.\n       \\<lbrakk>s = Ct x11 x12; u = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 6. \\<And>x21 x22 x11 x12.\n       \\<lbrakk>s = Fv x21 x22; u = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 7. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>s = Fv x21 x22; u = Fv x21a x22a\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 8. \\<And>x21 x22 x3.\n       \\<lbrakk>s = Fv x21 x22; u = Bv x3\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 9. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>s = Fv x21 x22; u = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 10. \\<And>x21 x22 x51 x52.\n        \\<lbrakk>s = Fv x21 x22; u = x51 $ x52\\<rbrakk>\n        \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\nA total of 25 subgoals...", "using not_beta_reducible_imp_beta_norm_unchanged IH t u appR.prems"], ["proof (prove)\nusing this:\n  \\<not> beta_reducible ?t \\<Longrightarrow> beta_norm ?t = Some ?t\n  beta_norm s = Some t\n  \\<not> beta_reducible t\n  \\<not> beta_reducible u\n  \\<not> beta_reducible (u $ t)\n\ngoal (25 subgoals):\n 1. \\<And>x11 x12 x11a x12a.\n       \\<lbrakk>s = Ct x11 x12; u = Ct x11a x12a\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 2. \\<And>x11 x12 x21 x22.\n       \\<lbrakk>s = Ct x11 x12; u = Fv x21 x22\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 3. \\<And>x11 x12 x3.\n       \\<lbrakk>s = Ct x11 x12; u = Bv x3\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 4. \\<And>x11 x12 x41 x42.\n       \\<lbrakk>s = Ct x11 x12; u = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 5. \\<And>x11 x12 x51 x52.\n       \\<lbrakk>s = Ct x11 x12; u = x51 $ x52\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 6. \\<And>x21 x22 x11 x12.\n       \\<lbrakk>s = Fv x21 x22; u = Ct x11 x12\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 7. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>s = Fv x21 x22; u = Fv x21a x22a\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 8. \\<And>x21 x22 x3.\n       \\<lbrakk>s = Fv x21 x22; u = Bv x3\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 9. \\<And>x21 x22 x41 x42.\n       \\<lbrakk>s = Fv x21 x22; u = Abs x41 x42\\<rbrakk>\n       \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\n 10. \\<And>x21 x22 x51 x52.\n        \\<lbrakk>s = Fv x21 x22; u = x51 $ x52\\<rbrakk>\n        \\<Longrightarrow> beta_norm (u $ s) = Some (u $ t)\nA total of 25 subgoals...", "by auto"], ["proof (state)\nthis:\n  beta_norm (u $ s) = Some (u $ t)\n\ngoal (1 subgoal):\n 1. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "case (abs s t T)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (Abs T t)\n\ngoal (1 subgoal):\n 1. \\<And>s t T.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t;\n        \\<not> beta_reducible (Abs T t)\\<rbrakk>\n       \\<Longrightarrow> beta_norm (Abs T s) = Some (Abs T t)", "then"], ["proof (chain)\npicking this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (Abs T t)", "show ?case"], ["proof (prove)\nusing this:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<not> beta_reducible t \\<Longrightarrow> beta_norm s = Some t\n  \\<not> beta_reducible (Abs T t)\n\ngoal (1 subgoal):\n 1. beta_norm (Abs T s) = Some (Abs T t)", "by auto"], ["proof (state)\nthis:\n  beta_norm (Abs T s) = Some (Abs T t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma beta_subst_bv1: \"s \\<rightarrow>\\<^sub>\\<beta> t \\<Longrightarrow> subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta> subst_bv1 t lev x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^sub>\\<beta> t \\<Longrightarrow>\n    subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta> subst_bv1 t lev x", "proof (induction s t arbitrary: lev rule: beta.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>T s t lev.\n       subst_bv1 (Abs T s $ t) lev x \\<rightarrow>\\<^sub>\\<beta>\n       subst_bv1 (subst_bv2 s 0 t) lev x\n 2. \\<And>s t u lev.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>lev.\n           subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta>\n           subst_bv1 t lev x\\<rbrakk>\n       \\<Longrightarrow> subst_bv1 (s $ u) lev x \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv1 (t $ u) lev x\n 3. \\<And>s t u lev.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>lev.\n           subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta>\n           subst_bv1 t lev x\\<rbrakk>\n       \\<Longrightarrow> subst_bv1 (u $ s) lev x \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv1 (u $ t) lev x\n 4. \\<And>s t T lev.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>lev.\n           subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta>\n           subst_bv1 t lev x\\<rbrakk>\n       \\<Longrightarrow> subst_bv1 (Abs T s) lev\n                          x \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv1 (Abs T t) lev x", "case (beta T s t)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>T s t lev.\n       subst_bv1 (Abs T s $ t) lev x \\<rightarrow>\\<^sub>\\<beta>\n       subst_bv1 (subst_bv2 s 0 t) lev x\n 2. \\<And>s t u lev.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>lev.\n           subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta>\n           subst_bv1 t lev x\\<rbrakk>\n       \\<Longrightarrow> subst_bv1 (s $ u) lev x \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv1 (t $ u) lev x\n 3. \\<And>s t u lev.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>lev.\n           subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta>\n           subst_bv1 t lev x\\<rbrakk>\n       \\<Longrightarrow> subst_bv1 (u $ s) lev x \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv1 (u $ t) lev x\n 4. \\<And>s t T lev.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>lev.\n           subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta>\n           subst_bv1 t lev x\\<rbrakk>\n       \\<Longrightarrow> subst_bv1 (Abs T s) lev\n                          x \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv1 (Abs T t) lev x", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bv1 (Abs T s $ t) lev x \\<rightarrow>\\<^sub>\\<beta>\n    subst_bv1 (subst_bv2 s 0 t) lev x", "using beta.beta subst_bv2_preserves_beta substn_subst_n"], ["proof (prove)\nusing this:\n  Abs ?T ?s $ ?t \\<rightarrow>\\<^sub>\\<beta> subst_bv2 ?s 0 ?t\n  ?r \\<rightarrow>\\<^sub>\\<beta> ?s \\<Longrightarrow>\n  subst_bv2 ?r ?k ?u \\<rightarrow>\\<^sub>\\<beta> subst_bv2 ?s ?k ?u\n  subst_bv1 ?t ?n ?s = subst_bv2 ?t ?n (incr_bv ?n 0 ?s)\n\ngoal (1 subgoal):\n 1. subst_bv1 (Abs T s $ t) lev x \\<rightarrow>\\<^sub>\\<beta>\n    subst_bv1 (subst_bv2 s 0 t) lev x", "by presburger"], ["proof (state)\nthis:\n  subst_bv1 (Abs T s $ t) lev x \\<rightarrow>\\<^sub>\\<beta>\n  subst_bv1 (subst_bv2 s 0 t) lev x\n\ngoal (3 subgoals):\n 1. \\<And>s t u lev.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>lev.\n           subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta>\n           subst_bv1 t lev x\\<rbrakk>\n       \\<Longrightarrow> subst_bv1 (s $ u) lev x \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv1 (t $ u) lev x\n 2. \\<And>s t u lev.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>lev.\n           subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta>\n           subst_bv1 t lev x\\<rbrakk>\n       \\<Longrightarrow> subst_bv1 (u $ s) lev x \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv1 (u $ t) lev x\n 3. \\<And>s t T lev.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>lev.\n           subst_bv1 s lev x \\<rightarrow>\\<^sub>\\<beta>\n           subst_bv1 t lev x\\<rbrakk>\n       \\<Longrightarrow> subst_bv1 (Abs T s) lev\n                          x \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bv1 (Abs T t) lev x", "qed (auto simp add: subst_bv_def)"], ["", "lemma beta_subst_bv: \"s \\<rightarrow>\\<^sub>\\<beta> t \\<Longrightarrow> subst_bv x s \\<rightarrow>\\<^sub>\\<beta> subst_bv x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^sub>\\<beta> t \\<Longrightarrow>\n    subst_bv x s \\<rightarrow>\\<^sub>\\<beta> subst_bv x t", "by (simp add: substn_subst_0')"], ["", "(* typ_of to exclude terms like Bv 0 $ Bv 0\n  Probably can get rid of one typ_of somehow\n\n  Problem: Not useable for subst_bv (at lev 0)\n*)"], ["", "lemma subst_bv1_beta:\n  \"subst_bv1 s (length (T#Ts)) x \\<rightarrow>\\<^sub>\\<beta> subst_bv1 t (length (T#Ts)) x \n  \\<Longrightarrow> typ_of1 Ts s = Some ty\n  \\<Longrightarrow> typ_of1 Ts t = Some ty\n  \\<Longrightarrow> s \\<rightarrow>\\<^sub>\\<beta> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subst_bv1 s (length (T # Ts)) x \\<rightarrow>\\<^sub>\\<beta>\n             subst_bv1 t (length (T # Ts)) x;\n     typ_of1 Ts s = Some ty; typ_of1 Ts t = Some ty\\<rbrakk>\n    \\<Longrightarrow> s \\<rightarrow>\\<^sub>\\<beta> t", "proof (induction \"subst_bv1 s (length (T#Ts)) x\" \"subst_bv1 t (length (T#Ts)) x\"\n    arbitrary: s t T T Ts ty rule: beta.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>T s t sa ta Ta Ts ty.\n       \\<lbrakk>Abs T s $ t = subst_bv1 sa (length (Ta # Ts)) x;\n        subst_bv2 s 0 t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 2. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        s $ u = subst_bv1 sa (length (T # Ts)) x;\n        t $ u = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 3. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        u $ s = subst_bv1 sa (length (T # Ts)) x;\n        u $ t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 4. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "case (beta T s t)"], ["proof (state)\nthis:\n  Abs Ta__ sa__ $ ta__ = subst_bv1 s (length (T # Ts)) x\n  subst_bv2 sa__ 0 ta__ = subst_bv1 t (length (T # Ts)) x\n  typ_of1 Ts s = Some ty\n  typ_of1 Ts t = Some ty\n\ngoal (4 subgoals):\n 1. \\<And>T s t sa ta Ta Ts ty.\n       \\<lbrakk>Abs T s $ t = subst_bv1 sa (length (Ta # Ts)) x;\n        subst_bv2 s 0 t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 2. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        s $ u = subst_bv1 sa (length (T # Ts)) x;\n        t $ u = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 3. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        u $ s = subst_bv1 sa (length (T # Ts)) x;\n        u $ t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 4. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "then"], ["proof (chain)\npicking this:\n  Abs Ta__ sa__ $ ta__ = subst_bv1 s (length (T # Ts)) x\n  subst_bv2 sa__ 0 ta__ = subst_bv1 t (length (T # Ts)) x\n  typ_of1 Ts s = Some ty\n  typ_of1 Ts t = Some ty", "show ?case"], ["proof (prove)\nusing this:\n  Abs Ta__ sa__ $ ta__ = subst_bv1 s (length (T # Ts)) x\n  subst_bv2 sa__ 0 ta__ = subst_bv1 t (length (T # Ts)) x\n  typ_of1 Ts s = Some ty\n  typ_of1 Ts t = Some ty\n\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^sub>\\<beta> t", "by (metis beta.simps length_Cons loose_bvar_Suc no_loose_bvar_imp_no_subst_bv1 typ_of1_imp_no_loose_bvar)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n\ngoal (3 subgoals):\n 1. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        s $ u = subst_bv1 sa (length (T # Ts)) x;\n        t $ u = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 2. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        u $ s = subst_bv1 sa (length (T # Ts)) x;\n        u $ t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 3. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        s $ u = subst_bv1 sa (length (T # Ts)) x;\n        t $ u = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 2. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        u $ s = subst_bv1 sa (length (T # Ts)) x;\n        u $ t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 3. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "case (appL s t u)"], ["proof (state)\nthis:\n  sa__ \\<rightarrow>\\<^sub>\\<beta> ta__\n  \\<lbrakk>sa__ = subst_bv1 ?s (length (?T # ?Ts)) x;\n   ta__ = subst_bv1 ?t (length (?T # ?Ts)) x; typ_of1 ?Ts ?s = Some ?ty;\n   typ_of1 ?Ts ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> ?s \\<rightarrow>\\<^sub>\\<beta> ?t\n  sa__ $ u = subst_bv1 s (length (T # Ts)) x\n  ta__ $ u = subst_bv1 t (length (T # Ts)) x\n  typ_of1 Ts s = Some ty\n  typ_of1 Ts t = Some ty\n\ngoal (3 subgoals):\n 1. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        s $ u = subst_bv1 sa (length (T # Ts)) x;\n        t $ u = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 2. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        u $ s = subst_bv1 sa (length (T # Ts)) x;\n        u $ t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 3. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "then"], ["proof (chain)\npicking this:\n  sa__ \\<rightarrow>\\<^sub>\\<beta> ta__\n  \\<lbrakk>sa__ = subst_bv1 ?s (length (?T # ?Ts)) x;\n   ta__ = subst_bv1 ?t (length (?T # ?Ts)) x; typ_of1 ?Ts ?s = Some ?ty;\n   typ_of1 ?Ts ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> ?s \\<rightarrow>\\<^sub>\\<beta> ?t\n  sa__ $ u = subst_bv1 s (length (T # Ts)) x\n  ta__ $ u = subst_bv1 t (length (T # Ts)) x\n  typ_of1 Ts s = Some ty\n  typ_of1 Ts t = Some ty", "show ?case"], ["proof (prove)\nusing this:\n  sa__ \\<rightarrow>\\<^sub>\\<beta> ta__\n  \\<lbrakk>sa__ = subst_bv1 ?s (length (?T # ?Ts)) x;\n   ta__ = subst_bv1 ?t (length (?T # ?Ts)) x; typ_of1 ?Ts ?s = Some ?ty;\n   typ_of1 ?Ts ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> ?s \\<rightarrow>\\<^sub>\\<beta> ?t\n  sa__ $ u = subst_bv1 s (length (T # Ts)) x\n  ta__ $ u = subst_bv1 t (length (T # Ts)) x\n  typ_of1 Ts s = Some ty\n  typ_of1 Ts t = Some ty\n\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^sub>\\<beta> t", "by (metis beta.appL length_Cons loose_bvar_Suc no_loose_bvar_imp_no_subst_bv1 typ_of1_imp_no_loose_bvar)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n\ngoal (2 subgoals):\n 1. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        u $ s = subst_bv1 sa (length (T # Ts)) x;\n        u $ t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 2. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        u $ s = subst_bv1 sa (length (T # Ts)) x;\n        u $ t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 2. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "case (appR s t u)"], ["proof (state)\nthis:\n  sa__ \\<rightarrow>\\<^sub>\\<beta> ta__\n  \\<lbrakk>sa__ = subst_bv1 ?s (length (?T # ?Ts)) x;\n   ta__ = subst_bv1 ?t (length (?T # ?Ts)) x; typ_of1 ?Ts ?s = Some ?ty;\n   typ_of1 ?Ts ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> ?s \\<rightarrow>\\<^sub>\\<beta> ?t\n  u $ sa__ = subst_bv1 s (length (T # Ts)) x\n  u $ ta__ = subst_bv1 t (length (T # Ts)) x\n  typ_of1 Ts s = Some ty\n  typ_of1 Ts t = Some ty\n\ngoal (2 subgoals):\n 1. \\<And>s t u sa ta T Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        u $ s = subst_bv1 sa (length (T # Ts)) x;\n        u $ t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n        typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta\n 2. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "then"], ["proof (chain)\npicking this:\n  sa__ \\<rightarrow>\\<^sub>\\<beta> ta__\n  \\<lbrakk>sa__ = subst_bv1 ?s (length (?T # ?Ts)) x;\n   ta__ = subst_bv1 ?t (length (?T # ?Ts)) x; typ_of1 ?Ts ?s = Some ?ty;\n   typ_of1 ?Ts ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> ?s \\<rightarrow>\\<^sub>\\<beta> ?t\n  u $ sa__ = subst_bv1 s (length (T # Ts)) x\n  u $ ta__ = subst_bv1 t (length (T # Ts)) x\n  typ_of1 Ts s = Some ty\n  typ_of1 Ts t = Some ty", "show ?case"], ["proof (prove)\nusing this:\n  sa__ \\<rightarrow>\\<^sub>\\<beta> ta__\n  \\<lbrakk>sa__ = subst_bv1 ?s (length (?T # ?Ts)) x;\n   ta__ = subst_bv1 ?t (length (?T # ?Ts)) x; typ_of1 ?Ts ?s = Some ?ty;\n   typ_of1 ?Ts ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> ?s \\<rightarrow>\\<^sub>\\<beta> ?t\n  u $ sa__ = subst_bv1 s (length (T # Ts)) x\n  u $ ta__ = subst_bv1 t (length (T # Ts)) x\n  typ_of1 Ts s = Some ty\n  typ_of1 Ts t = Some ty\n\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^sub>\\<beta> t", "by (metis beta.simps length_Cons loose_bvar_Suc no_loose_bvar_imp_no_subst_bv1 typ_of1_imp_no_loose_bvar)"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n\ngoal (1 subgoal):\n 1. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "case (abs s t bT sa ta T Ts rT )"], ["proof (state)\nthis:\n  s \\<rightarrow>\\<^sub>\\<beta> t\n  \\<lbrakk>s = subst_bv1 ?s (length (?T # ?Ts)) x;\n   t = subst_bv1 ?t (length (?T # ?Ts)) x; typ_of1 ?Ts ?s = Some ?ty;\n   typ_of1 ?Ts ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> ?s \\<rightarrow>\\<^sub>\\<beta> ?t\n  Abs bT s = subst_bv1 sa (length (T # Ts)) x\n  Abs bT t = subst_bv1 ta (length (T # Ts)) x\n  typ_of1 Ts sa = Some rT\n  typ_of1 Ts ta = Some rT\n\ngoal (1 subgoal):\n 1. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "obtain s' where \"Abs bT s' = sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'. Abs bT s' = sa \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using abs.hyps(3) abs.prems loose_bvar_Suc no_loose_bvar_imp_no_subst_bv1 typ_of1_imp_no_loose_bvar"], ["proof (prove)\nusing this:\n  Abs bT s = subst_bv1 sa (length (T # Ts)) x\n  typ_of1 Ts sa = Some rT\n  typ_of1 Ts ta = Some rT\n  loose_bvar ?t (Suc ?k) \\<Longrightarrow> loose_bvar ?t ?k\n  \\<not> loose_bvar ?t ?lev \\<Longrightarrow> subst_bv1 ?t ?lev ?u = ?t\n  typ_of1 ?Ts ?t = Some ?ty \\<Longrightarrow>\n  \\<not> loose_bvar ?t (length ?Ts)\n\ngoal (1 subgoal):\n 1. (\\<And>s'. Abs bT s' = sa \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Cons)"], ["proof (state)\nthis:\n  Abs bT s' = sa\n\ngoal (1 subgoal):\n 1. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "moreover"], ["proof (state)\nthis:\n  Abs bT s' = sa\n\ngoal (1 subgoal):\n 1. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "obtain t' where \"Abs bT t' = ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'. Abs bT t' = ta \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using abs.hyps(4) abs.prems loose_bvar_Suc no_loose_bvar_imp_no_subst_bv1 typ_of1_imp_no_loose_bvar"], ["proof (prove)\nusing this:\n  Abs bT t = subst_bv1 ta (length (T # Ts)) x\n  typ_of1 Ts sa = Some rT\n  typ_of1 Ts ta = Some rT\n  loose_bvar ?t (Suc ?k) \\<Longrightarrow> loose_bvar ?t ?k\n  \\<not> loose_bvar ?t ?lev \\<Longrightarrow> subst_bv1 ?t ?lev ?u = ?t\n  typ_of1 ?Ts ?t = Some ?ty \\<Longrightarrow>\n  \\<not> loose_bvar ?t (length ?Ts)\n\ngoal (1 subgoal):\n 1. (\\<And>t'. Abs bT t' = ta \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Cons)"], ["proof (state)\nthis:\n  Abs bT t' = ta\n\ngoal (1 subgoal):\n 1. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "ultimately"], ["proof (chain)\npicking this:\n  Abs bT s' = sa\n  Abs bT t' = ta", "have \"s' \\<rightarrow>\\<^sub>\\<beta> t'\""], ["proof (prove)\nusing this:\n  Abs bT s' = sa\n  Abs bT t' = ta\n\ngoal (1 subgoal):\n 1. s' \\<rightarrow>\\<^sub>\\<beta> t'", "by (metis abs.hyps(1) abs.hyps(3) abs.hyps(4) abs.prems(1) abs.prems(2) length_Cons \n        loose_bvar_Suc no_loose_bvar_imp_no_subst_bv1 term.inject(4) typ_of1_imp_no_loose_bvar)"], ["proof (state)\nthis:\n  s' \\<rightarrow>\\<^sub>\\<beta> t'\n\ngoal (1 subgoal):\n 1. \\<And>s t T sa ta Ta Ts ty.\n       \\<lbrakk>s \\<rightarrow>\\<^sub>\\<beta> t;\n        \\<And>sa ta T Ts ty.\n           \\<lbrakk>s = subst_bv1 sa (length (T # Ts)) x;\n            t = subst_bv1 ta (length (T # Ts)) x; typ_of1 Ts sa = Some ty;\n            typ_of1 Ts ta = Some ty\\<rbrakk>\n           \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta;\n        Abs T s = subst_bv1 sa (length (Ta # Ts)) x;\n        Abs T t = subst_bv1 ta (length (Ta # Ts)) x;\n        typ_of1 Ts sa = Some ty; typ_of1 Ts ta = Some ty\\<rbrakk>\n       \\<Longrightarrow> sa \\<rightarrow>\\<^sub>\\<beta> ta", "then"], ["proof (chain)\npicking this:\n  s' \\<rightarrow>\\<^sub>\\<beta> t'", "show ?case"], ["proof (prove)\nusing this:\n  s' \\<rightarrow>\\<^sub>\\<beta> t'\n\ngoal (1 subgoal):\n 1. sa \\<rightarrow>\\<^sub>\\<beta> ta", "using \\<open>Abs bT s' = sa\\<close> \\<open>Abs bT t' = ta\\<close>"], ["proof (prove)\nusing this:\n  s' \\<rightarrow>\\<^sub>\\<beta> t'\n  Abs bT s' = sa\n  Abs bT t' = ta\n\ngoal (1 subgoal):\n 1. sa \\<rightarrow>\\<^sub>\\<beta> ta", "by blast"], ["proof (state)\nthis:\n  sa \\<rightarrow>\\<^sub>\\<beta> ta\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Longterm: Move to Term and unify with subst_bv2, so far only used for beta reduction *)"], ["", "fun subst_bvs1' :: \"term \\<Rightarrow> nat \\<Rightarrow> term list \\<Rightarrow> term\" where\n  \"subst_bvs1' (Bv i) lev args = (if i < lev then Bv i\n    else if i - lev < length args then (nth args (i-lev))\n    else Bv (i - length args))\" \n| \"subst_bvs1' (Abs T body) lev args = Abs T (subst_bvs1' body (lev + 1) (map (\\<lambda>t. lift t 0) args))\"\n| \"subst_bvs1' (f $ t) lev u = subst_bvs1' f lev u $ subst_bvs1' t lev u\"\n| \"subst_bvs1' t _ _ = t\""], ["", "lemma subst_bvs1'_empty [simp]: \"subst_bvs1' t lev [] = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bvs1' t lev [] = t", "by (induction t lev \"[]::term list\" rule: subst_bvs1.induct)auto"], ["", "lemma subst_bvs1'_eq [simp]: \"args \\<noteq> [] \\<Longrightarrow> subst_bvs1' (Bv k) k args = args ! 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args \\<noteq> [] \\<Longrightarrow> subst_bvs1' (Bv k) k args = args ! 0", "by simp"], ["", "lemma subst_bvs1'_eq' [simp]: \"i < length args \\<Longrightarrow> subst_bvs1' (Bv (k+i)) k args = args ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length args \\<Longrightarrow>\n    subst_bvs1' (Bv (k + i)) k args = args ! i", "by auto"], ["", "lemma subst_bvs1'_gt [simp]: \n  \"i + length args < j \\<Longrightarrow> subst_bvs1' (Bv j) i args = Bv (j - length args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + length args < j \\<Longrightarrow>\n    subst_bvs1' (Bv j) i args = Bv (j - length args)", "by auto"], ["", "lemma subst_bv2_lt [simp]: \"j < i \\<Longrightarrow> subst_bvs1' (Bv j) i u = Bv j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> subst_bvs1' (Bv j) i u = Bv j", "by simp"], ["", "lemma subst_bvs1'_App[simp]: \"subst_bvs1' (s$t) k args\n  = subst_bvs1' s k args $ subst_bvs1' t k args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bvs1' (s $ t) k args = subst_bvs1' s k args $ subst_bvs1' t k args", "by simp"], ["", "lemma incr_bv_incr_bv:\n    \"i < k + 1 \\<Longrightarrow> incr_bv inc2 (k+inc1) (incr_bv inc1 i t) = incr_bv inc1 i (incr_bv inc2 k t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k + 1 \\<Longrightarrow>\n    incr_bv inc2 (k + inc1) (incr_bv inc1 i t) =\n    incr_bv inc1 i (incr_bv inc2 k t)", "proof (induction t arbitrary: i k)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i k.\n       i < k + 1 \\<Longrightarrow>\n       incr_bv inc2 (k + inc1) (incr_bv inc1 i (Ct x1 x2)) =\n       incr_bv inc1 i (incr_bv inc2 k (Ct x1 x2))\n 2. \\<And>x1 x2 i k.\n       i < k + 1 \\<Longrightarrow>\n       incr_bv inc2 (k + inc1) (incr_bv inc1 i (Fv x1 x2)) =\n       incr_bv inc1 i (incr_bv inc2 k (Fv x1 x2))\n 3. \\<And>x i k.\n       i < k + 1 \\<Longrightarrow>\n       incr_bv inc2 (k + inc1) (incr_bv inc1 i (Bv x)) =\n       incr_bv inc1 i (incr_bv inc2 k (Bv x))\n 4. \\<And>x1 t i k.\n       \\<lbrakk>\\<And>i k.\n                   i < k + 1 \\<Longrightarrow>\n                   incr_bv inc2 (k + inc1) (incr_bv inc1 i t) =\n                   incr_bv inc1 i (incr_bv inc2 k t);\n        i < k + 1\\<rbrakk>\n       \\<Longrightarrow> incr_bv inc2 (k + inc1)\n                          (incr_bv inc1 i (Abs x1 t)) =\n                         incr_bv inc1 i (incr_bv inc2 k (Abs x1 t))\n 5. \\<And>t1 t2 i k.\n       \\<lbrakk>\\<And>i k.\n                   i < k + 1 \\<Longrightarrow>\n                   incr_bv inc2 (k + inc1) (incr_bv inc1 i t1) =\n                   incr_bv inc1 i (incr_bv inc2 k t1);\n        \\<And>i k.\n           i < k + 1 \\<Longrightarrow>\n           incr_bv inc2 (k + inc1) (incr_bv inc1 i t2) =\n           incr_bv inc1 i (incr_bv inc2 k t2);\n        i < k + 1\\<rbrakk>\n       \\<Longrightarrow> incr_bv inc2 (k + inc1)\n                          (incr_bv inc1 i (t1 $ t2)) =\n                         incr_bv inc1 i (incr_bv inc2 k (t1 $ t2))", "case (Abs T t)"], ["proof (state)\nthis:\n  ?i < ?k + 1 \\<Longrightarrow>\n  incr_bv inc2 (?k + inc1) (incr_bv inc1 ?i t) =\n  incr_bv inc1 ?i (incr_bv inc2 ?k t)\n  i < k + 1\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i k.\n       i < k + 1 \\<Longrightarrow>\n       incr_bv inc2 (k + inc1) (incr_bv inc1 i (Ct x1 x2)) =\n       incr_bv inc1 i (incr_bv inc2 k (Ct x1 x2))\n 2. \\<And>x1 x2 i k.\n       i < k + 1 \\<Longrightarrow>\n       incr_bv inc2 (k + inc1) (incr_bv inc1 i (Fv x1 x2)) =\n       incr_bv inc1 i (incr_bv inc2 k (Fv x1 x2))\n 3. \\<And>x i k.\n       i < k + 1 \\<Longrightarrow>\n       incr_bv inc2 (k + inc1) (incr_bv inc1 i (Bv x)) =\n       incr_bv inc1 i (incr_bv inc2 k (Bv x))\n 4. \\<And>x1 t i k.\n       \\<lbrakk>\\<And>i k.\n                   i < k + 1 \\<Longrightarrow>\n                   incr_bv inc2 (k + inc1) (incr_bv inc1 i t) =\n                   incr_bv inc1 i (incr_bv inc2 k t);\n        i < k + 1\\<rbrakk>\n       \\<Longrightarrow> incr_bv inc2 (k + inc1)\n                          (incr_bv inc1 i (Abs x1 t)) =\n                         incr_bv inc1 i (incr_bv inc2 k (Abs x1 t))\n 5. \\<And>t1 t2 i k.\n       \\<lbrakk>\\<And>i k.\n                   i < k + 1 \\<Longrightarrow>\n                   incr_bv inc2 (k + inc1) (incr_bv inc1 i t1) =\n                   incr_bv inc1 i (incr_bv inc2 k t1);\n        \\<And>i k.\n           i < k + 1 \\<Longrightarrow>\n           incr_bv inc2 (k + inc1) (incr_bv inc1 i t2) =\n           incr_bv inc1 i (incr_bv inc2 k t2);\n        i < k + 1\\<rbrakk>\n       \\<Longrightarrow> incr_bv inc2 (k + inc1)\n                          (incr_bv inc1 i (t1 $ t2)) =\n                         incr_bv inc1 i (incr_bv inc2 k (t1 $ t2))", "then"], ["proof (chain)\npicking this:\n  ?i < ?k + 1 \\<Longrightarrow>\n  incr_bv inc2 (?k + inc1) (incr_bv inc1 ?i t) =\n  incr_bv inc1 ?i (incr_bv inc2 ?k t)\n  i < k + 1", "show ?case"], ["proof (prove)\nusing this:\n  ?i < ?k + 1 \\<Longrightarrow>\n  incr_bv inc2 (?k + inc1) (incr_bv inc1 ?i t) =\n  incr_bv inc1 ?i (incr_bv inc2 ?k t)\n  i < k + 1\n\ngoal (1 subgoal):\n 1. incr_bv inc2 (k + inc1) (incr_bv inc1 i (Abs T t)) =\n    incr_bv inc1 i (incr_bv inc2 k (Abs T t))", "by (metis Suc_eq_plus1 add_Suc add_mono1 incr_bv.simps(2))"], ["proof (state)\nthis:\n  incr_bv inc2 (k + inc1) (incr_bv inc1 i (Abs T t)) =\n  incr_bv inc1 i (incr_bv inc2 k (Abs T t))\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 i k.\n       i < k + 1 \\<Longrightarrow>\n       incr_bv inc2 (k + inc1) (incr_bv inc1 i (Ct x1 x2)) =\n       incr_bv inc1 i (incr_bv inc2 k (Ct x1 x2))\n 2. \\<And>x1 x2 i k.\n       i < k + 1 \\<Longrightarrow>\n       incr_bv inc2 (k + inc1) (incr_bv inc1 i (Fv x1 x2)) =\n       incr_bv inc1 i (incr_bv inc2 k (Fv x1 x2))\n 3. \\<And>x i k.\n       i < k + 1 \\<Longrightarrow>\n       incr_bv inc2 (k + inc1) (incr_bv inc1 i (Bv x)) =\n       incr_bv inc1 i (incr_bv inc2 k (Bv x))\n 4. \\<And>t1 t2 i k.\n       \\<lbrakk>\\<And>i k.\n                   i < k + 1 \\<Longrightarrow>\n                   incr_bv inc2 (k + inc1) (incr_bv inc1 i t1) =\n                   incr_bv inc1 i (incr_bv inc2 k t1);\n        \\<And>i k.\n           i < k + 1 \\<Longrightarrow>\n           incr_bv inc2 (k + inc1) (incr_bv inc1 i t2) =\n           incr_bv inc1 i (incr_bv inc2 k t2);\n        i < k + 1\\<rbrakk>\n       \\<Longrightarrow> incr_bv inc2 (k + inc1)\n                          (incr_bv inc1 i (t1 $ t2)) =\n                         incr_bv inc1 i (incr_bv inc2 k (t1 $ t2))", "qed auto"], ["", "lemma subst_bvs1_subst_bvs1': \"subst_bvs1 t n s = subst_bvs1' t n (map (incr_bv n 0) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bvs1 t n s = subst_bvs1' t n (map (incr_bv n 0) s)", "proof (induction t arbitrary: n)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 n.\n       subst_bvs1 (Ct x1 x2) n s =\n       subst_bvs1' (Ct x1 x2) n (map (incr_bv n 0) s)\n 2. \\<And>x1 x2 n.\n       subst_bvs1 (Fv x1 x2) n s =\n       subst_bvs1' (Fv x1 x2) n (map (incr_bv n 0) s)\n 3. \\<And>x n.\n       subst_bvs1 (Bv x) n s = subst_bvs1' (Bv x) n (map (incr_bv n 0) s)\n 4. \\<And>x1 t n.\n       (\\<And>n.\n           subst_bvs1 t n s =\n           subst_bvs1' t n (map (incr_bv n 0) s)) \\<Longrightarrow>\n       subst_bvs1 (Abs x1 t) n s =\n       subst_bvs1' (Abs x1 t) n (map (incr_bv n 0) s)\n 5. \\<And>t1 t2 n.\n       \\<lbrakk>\\<And>n.\n                   subst_bvs1 t1 n s =\n                   subst_bvs1' t1 n (map (incr_bv n 0) s);\n        \\<And>n.\n           subst_bvs1 t2 n s =\n           subst_bvs1' t2 n (map (incr_bv n 0) s)\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1 (t1 $ t2) n s =\n                         subst_bvs1' (t1 $ t2) n (map (incr_bv n 0) s)", "case (Abs T t)"], ["proof (state)\nthis:\n  subst_bvs1 t ?n s = subst_bvs1' t ?n (map (incr_bv ?n 0) s)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 n.\n       subst_bvs1 (Ct x1 x2) n s =\n       subst_bvs1' (Ct x1 x2) n (map (incr_bv n 0) s)\n 2. \\<And>x1 x2 n.\n       subst_bvs1 (Fv x1 x2) n s =\n       subst_bvs1' (Fv x1 x2) n (map (incr_bv n 0) s)\n 3. \\<And>x n.\n       subst_bvs1 (Bv x) n s = subst_bvs1' (Bv x) n (map (incr_bv n 0) s)\n 4. \\<And>x1 t n.\n       (\\<And>n.\n           subst_bvs1 t n s =\n           subst_bvs1' t n (map (incr_bv n 0) s)) \\<Longrightarrow>\n       subst_bvs1 (Abs x1 t) n s =\n       subst_bvs1' (Abs x1 t) n (map (incr_bv n 0) s)\n 5. \\<And>t1 t2 n.\n       \\<lbrakk>\\<And>n.\n                   subst_bvs1 t1 n s =\n                   subst_bvs1' t1 n (map (incr_bv n 0) s);\n        \\<And>n.\n           subst_bvs1 t2 n s =\n           subst_bvs1' t2 n (map (incr_bv n 0) s)\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1 (t1 $ t2) n s =\n                         subst_bvs1' (t1 $ t2) n (map (incr_bv n 0) s)", "then"], ["proof (chain)\npicking this:\n  subst_bvs1 t ?n s = subst_bvs1' t ?n (map (incr_bv ?n 0) s)", "show ?case"], ["proof (prove)\nusing this:\n  subst_bvs1 t ?n s = subst_bvs1' t ?n (map (incr_bv ?n 0) s)\n\ngoal (1 subgoal):\n 1. subst_bvs1 (Abs T t) n s = subst_bvs1' (Abs T t) n (map (incr_bv n 0) s)", "by (simp add: incr_boundvars_def incr_bv_combine) \n      (metis One_nat_def comp_apply incr_bv_combine plus_1_eq_Suc)"], ["proof (state)\nthis:\n  subst_bvs1 (Abs T t) n s = subst_bvs1' (Abs T t) n (map (incr_bv n 0) s)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 n.\n       subst_bvs1 (Ct x1 x2) n s =\n       subst_bvs1' (Ct x1 x2) n (map (incr_bv n 0) s)\n 2. \\<And>x1 x2 n.\n       subst_bvs1 (Fv x1 x2) n s =\n       subst_bvs1' (Fv x1 x2) n (map (incr_bv n 0) s)\n 3. \\<And>x n.\n       subst_bvs1 (Bv x) n s = subst_bvs1' (Bv x) n (map (incr_bv n 0) s)\n 4. \\<And>t1 t2 n.\n       \\<lbrakk>\\<And>n.\n                   subst_bvs1 t1 n s =\n                   subst_bvs1' t1 n (map (incr_bv n 0) s);\n        \\<And>n.\n           subst_bvs1 t2 n s =\n           subst_bvs1' t2 n (map (incr_bv n 0) s)\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1 (t1 $ t2) n s =\n                         subst_bvs1' (t1 $ t2) n (map (incr_bv n 0) s)", "qed (auto simp add: incr_boundvars_def incr_bv_combine)"], ["", "theorem subst_bvs1_subst_bvs1'_0: \"subst_bvs1 t 0 s = subst_bvs1' t 0 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bvs1 t 0 s = subst_bvs1' t 0 s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_bvs1 t 0 s = subst_bvs1' t 0 s", "have \"subst_bvs1 t 0 s = subst_bvs1' t 0 (map (incr_bv 0 0) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bvs1 t 0 s = subst_bvs1' t 0 (map (incr_bv 0 0) s)", "using subst_bvs1_subst_bvs1'"], ["proof (prove)\nusing this:\n  subst_bvs1 ?t ?n ?s = subst_bvs1' ?t ?n (map (incr_bv ?n 0) ?s)\n\ngoal (1 subgoal):\n 1. subst_bvs1 t 0 s = subst_bvs1' t 0 (map (incr_bv 0 0) s)", "by blast"], ["proof (state)\nthis:\n  subst_bvs1 t 0 s = subst_bvs1' t 0 (map (incr_bv 0 0) s)\n\ngoal (1 subgoal):\n 1. subst_bvs1 t 0 s = subst_bvs1' t 0 s", "moreover"], ["proof (state)\nthis:\n  subst_bvs1 t 0 s = subst_bvs1' t 0 (map (incr_bv 0 0) s)\n\ngoal (1 subgoal):\n 1. subst_bvs1 t 0 s = subst_bvs1' t 0 s", "have \"map (incr_bv 0 0) s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (incr_bv 0 0) s = s", "by (induction s) auto"], ["proof (state)\nthis:\n  map (incr_bv 0 0) s = s\n\ngoal (1 subgoal):\n 1. subst_bvs1 t 0 s = subst_bvs1' t 0 s", "ultimately"], ["proof (chain)\npicking this:\n  subst_bvs1 t 0 s = subst_bvs1' t 0 (map (incr_bv 0 0) s)\n  map (incr_bv 0 0) s = s", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_bvs1 t 0 s = subst_bvs1' t 0 (map (incr_bv 0 0) s)\n  map (incr_bv 0 0) s = s\n\ngoal (1 subgoal):\n 1. subst_bvs1 t 0 s = subst_bvs1' t 0 s", "by simp"], ["proof (state)\nthis:\n  subst_bvs1 t 0 s = subst_bvs1' t 0 s\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_bvs_subst_bvs1': \"subst_bvs s t = subst_bvs1' t 0 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bvs s t = subst_bvs1' t 0 s", "using subst_bvs_def subst_bvs1_subst_bvs1'_0"], ["proof (prove)\nusing this:\n  subst_bvs ?args ?t \\<equiv> subst_bvs1 ?t 0 ?args\n  subst_bvs1 ?t 0 ?s = subst_bvs1' ?t 0 ?s\n\ngoal (1 subgoal):\n 1. subst_bvs s t = subst_bvs1' t 0 s", "by simp"], ["", "lemma no_loose_bvar_subst_bvs1'_unchanged: \"\\<not> loose_bvar t lev \\<Longrightarrow> subst_bvs1' t lev args = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> loose_bvar t lev \\<Longrightarrow> subst_bvs1' t lev args = t", "by (induction t lev args rule: subst_bvs1'.induct) auto"], ["", "(* This is enough when just substituting variables, however in the \\<beta> case I will have to\n  distribute subst_bvs through a single subst_bv(where the substituted term is not a var).\n*)"], ["", "lemma subst_bvs1'_step: \"\\<forall>x \\<in> set (a#args) . is_closed x \\<Longrightarrow>\n  subst_bvs1' t lev (a#args) = subst_bvs1' (subst_bv2 t lev a) lev args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n    subst_bvs1' t lev (a # args) = subst_bvs1' (subst_bv2 t lev a) lev args", "proof (induction t lev args rule: subst_bvs1'.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i lev args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bvs1' (Bv i) lev (a # args) =\n       subst_bvs1' (subst_bv2 (Bv i) lev a) lev args\n 2. \\<And>T body lev args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # map (\\<lambda>t. lift t 0) args).\n                   is_closed x \\<Longrightarrow>\n                subst_bvs1' body (lev + 1)\n                 (a # map (\\<lambda>t. lift t 0) args) =\n                subst_bvs1' (subst_bv2 body (lev + 1) a) (lev + 1)\n                 (map (\\<lambda>t. lift t 0) args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Abs T body) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args\n 3. \\<And>f t lev u.\n       \\<lbrakk>\\<forall>x\\<in>set (a # u). is_closed x \\<Longrightarrow>\n                subst_bvs1' f lev (a # u) =\n                subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<forall>x\\<in>set (a # u). is_closed x \\<Longrightarrow>\n        subst_bvs1' t lev (a # u) = subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set (a # u). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 4. \\<And>v va uu_ uv_.\n       \\<forall>x\\<in>set (a # uv_). is_closed x \\<Longrightarrow>\n       subst_bvs1' (Ct v va) uu_ (a # uv_) =\n       subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 5. \\<And>v va uu_ uv_.\n       \\<forall>x\\<in>set (a # uv_). is_closed x \\<Longrightarrow>\n       subst_bvs1' (Fv v va) uu_ (a # uv_) =\n       subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "case (1 i lev args)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (a # args). is_closed x\n\ngoal (5 subgoals):\n 1. \\<And>i lev args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bvs1' (Bv i) lev (a # args) =\n       subst_bvs1' (subst_bv2 (Bv i) lev a) lev args\n 2. \\<And>T body lev args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # map (\\<lambda>t. lift t 0) args).\n                   is_closed x \\<Longrightarrow>\n                subst_bvs1' body (lev + 1)\n                 (a # map (\\<lambda>t. lift t 0) args) =\n                subst_bvs1' (subst_bv2 body (lev + 1) a) (lev + 1)\n                 (map (\\<lambda>t. lift t 0) args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Abs T body) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args\n 3. \\<And>f t lev u.\n       \\<lbrakk>\\<forall>x\\<in>set (a # u). is_closed x \\<Longrightarrow>\n                subst_bvs1' f lev (a # u) =\n                subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<forall>x\\<in>set (a # u). is_closed x \\<Longrightarrow>\n        subst_bvs1' t lev (a # u) = subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set (a # u). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 4. \\<And>v va uu_ uv_.\n       \\<forall>x\\<in>set (a # uv_). is_closed x \\<Longrightarrow>\n       subst_bvs1' (Ct v va) uu_ (a # uv_) =\n       subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 5. \\<And>v va uu_ uv_.\n       \\<forall>x\\<in>set (a # uv_). is_closed x \\<Longrightarrow>\n       subst_bvs1' (Fv v va) uu_ (a # uv_) =\n       subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (a # args). is_closed x", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (a # args). is_closed x\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Bv i) lev (a # args) =\n    subst_bvs1' (subst_bv2 (Bv i) lev a) lev args", "using no_loose_bvar_subst_bvs1'_unchanged"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (a # args). is_closed x\n  \\<not> loose_bvar ?t ?lev \\<Longrightarrow> subst_bvs1' ?t ?lev ?args = ?t\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Bv i) lev (a # args) =\n    subst_bvs1' (subst_bv2 (Bv i) lev a) lev args", "by (simp add: is_open_def) \n      (metis Suc_diff_Suc le_add1 le_add_same_cancel1 less_antisym loose_bvar_leq not_less_eq)"], ["proof (state)\nthis:\n  subst_bvs1' (Bv i) lev (a # args) =\n  subst_bvs1' (subst_bv2 (Bv i) lev a) lev args\n\ngoal (4 subgoals):\n 1. \\<And>T body lev args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # map (\\<lambda>t. lift t 0) args).\n                   is_closed x \\<Longrightarrow>\n                subst_bvs1' body (lev + 1)\n                 (a # map (\\<lambda>t. lift t 0) args) =\n                subst_bvs1' (subst_bv2 body (lev + 1) a) (lev + 1)\n                 (map (\\<lambda>t. lift t 0) args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Abs T body) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args\n 2. \\<And>f t lev u.\n       \\<lbrakk>\\<forall>x\\<in>set (a # u). is_closed x \\<Longrightarrow>\n                subst_bvs1' f lev (a # u) =\n                subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<forall>x\\<in>set (a # u). is_closed x \\<Longrightarrow>\n        subst_bvs1' t lev (a # u) = subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set (a # u). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 3. \\<And>v va uu_ uv_.\n       \\<forall>x\\<in>set (a # uv_). is_closed x \\<Longrightarrow>\n       subst_bvs1' (Ct v va) uu_ (a # uv_) =\n       subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 4. \\<And>v va uu_ uv_.\n       \\<forall>x\\<in>set (a # uv_). is_closed x \\<Longrightarrow>\n       subst_bvs1' (Fv v va) uu_ (a # uv_) =\n       subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "qed (auto simp add: is_open_def)"], ["", "lemma not_loose_bvar_incr_bv: \"\\<not> loose_bvar a lev \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc lev a) (lev+inc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> loose_bvar a lev \\<Longrightarrow>\n    \\<not> loose_bvar (incr_bv inc lev a) (lev + inc)", "by (induction a lev rule: loose_bvar.induct) auto"], ["", "lemma not_loose_bvar_incr_bv_less: \n  \"i < j \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc i a) (lev+inc) \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j a) (lev+inc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; \\<not> loose_bvar (incr_bv inc i a) (lev + inc)\\<rbrakk>\n    \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j a) (lev + inc)", "proof (induction inc i a arbitrary: lev j rule: incr_bv.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>inc n i lev j.\n       \\<lbrakk>n < j;\n        \\<not> loose_bvar (incr_bv inc n (Bv i)) (lev + inc)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j (Bv i))\n                                 (lev + inc)\n 2. \\<And>inc n T body lev j.\n       \\<lbrakk>\\<And>lev j.\n                   \\<lbrakk>n + 1 < j;\n                    \\<not> loose_bvar (incr_bv inc (n + 1) body)\n                            (lev + inc)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j body)\n       (lev + inc);\n        n < j;\n        \\<not> loose_bvar (incr_bv inc n (Abs T body)) (lev + inc)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j (Abs T body))\n                                 (lev + inc)\n 3. \\<And>inc n f t lev j.\n       \\<lbrakk>\\<And>lev j.\n                   \\<lbrakk>n < j;\n                    \\<not> loose_bvar (incr_bv inc n f) (lev + inc)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j f)\n       (lev + inc);\n        \\<And>lev j.\n           \\<lbrakk>n < j;\n            \\<not> loose_bvar (incr_bv inc n t) (lev + inc)\\<rbrakk>\n           \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j t)\n                                     (lev + inc);\n        n < j;\n        \\<not> loose_bvar (incr_bv inc n (f $ t)) (lev + inc)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j (f $ t))\n                                 (lev + inc)\n 4. \\<And>uu_ uv_ v va lev j.\n       \\<lbrakk>uv_ < j;\n        \\<not> loose_bvar (incr_bv uu_ uv_ (Ct v va)) (lev + uu_)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv uu_ j (Ct v va))\n                                 (lev + uu_)\n 5. \\<And>uu_ uv_ v va lev j.\n       \\<lbrakk>uv_ < j;\n        \\<not> loose_bvar (incr_bv uu_ uv_ (Fv v va)) (lev + uu_)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv uu_ j (Fv v va))\n                                 (lev + uu_)", "case (2 inc n T body)"], ["proof (state)\nthis:\n  \\<lbrakk>n + 1 < ?j;\n   \\<not> loose_bvar (incr_bv inc (n + 1) body) (?lev + inc)\\<rbrakk>\n  \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc ?j body) (?lev + inc)\n  n < j\n  \\<not> loose_bvar (incr_bv inc n (Abs T body)) (lev + inc)\n\ngoal (5 subgoals):\n 1. \\<And>inc n i lev j.\n       \\<lbrakk>n < j;\n        \\<not> loose_bvar (incr_bv inc n (Bv i)) (lev + inc)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j (Bv i))\n                                 (lev + inc)\n 2. \\<And>inc n T body lev j.\n       \\<lbrakk>\\<And>lev j.\n                   \\<lbrakk>n + 1 < j;\n                    \\<not> loose_bvar (incr_bv inc (n + 1) body)\n                            (lev + inc)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j body)\n       (lev + inc);\n        n < j;\n        \\<not> loose_bvar (incr_bv inc n (Abs T body)) (lev + inc)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j (Abs T body))\n                                 (lev + inc)\n 3. \\<And>inc n f t lev j.\n       \\<lbrakk>\\<And>lev j.\n                   \\<lbrakk>n < j;\n                    \\<not> loose_bvar (incr_bv inc n f) (lev + inc)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j f)\n       (lev + inc);\n        \\<And>lev j.\n           \\<lbrakk>n < j;\n            \\<not> loose_bvar (incr_bv inc n t) (lev + inc)\\<rbrakk>\n           \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j t)\n                                     (lev + inc);\n        n < j;\n        \\<not> loose_bvar (incr_bv inc n (f $ t)) (lev + inc)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j (f $ t))\n                                 (lev + inc)\n 4. \\<And>uu_ uv_ v va lev j.\n       \\<lbrakk>uv_ < j;\n        \\<not> loose_bvar (incr_bv uu_ uv_ (Ct v va)) (lev + uu_)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv uu_ j (Ct v va))\n                                 (lev + uu_)\n 5. \\<And>uu_ uv_ v va lev j.\n       \\<lbrakk>uv_ < j;\n        \\<not> loose_bvar (incr_bv uu_ uv_ (Fv v va)) (lev + uu_)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv uu_ j (Fv v va))\n                                 (lev + uu_)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n + 1 < ?j;\n   \\<not> loose_bvar (incr_bv inc (n + 1) body) (?lev + inc)\\<rbrakk>\n  \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc ?j body) (?lev + inc)\n  n < j\n  \\<not> loose_bvar (incr_bv inc n (Abs T body)) (lev + inc)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n + 1 < ?j;\n   \\<not> loose_bvar (incr_bv inc (n + 1) body) (?lev + inc)\\<rbrakk>\n  \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc ?j body) (?lev + inc)\n  n < j\n  \\<not> loose_bvar (incr_bv inc n (Abs T body)) (lev + inc)\n\ngoal (1 subgoal):\n 1. \\<not> loose_bvar (incr_bv inc j (Abs T body)) (lev + inc)", "by (metis Suc_eq_plus1 add_Suc add_mono1 incr_bv.simps(2) loose_bvar.simps(3))"], ["proof (state)\nthis:\n  \\<not> loose_bvar (incr_bv inc j (Abs T body)) (lev + inc)\n\ngoal (4 subgoals):\n 1. \\<And>inc n i lev j.\n       \\<lbrakk>n < j;\n        \\<not> loose_bvar (incr_bv inc n (Bv i)) (lev + inc)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j (Bv i))\n                                 (lev + inc)\n 2. \\<And>inc n f t lev j.\n       \\<lbrakk>\\<And>lev j.\n                   \\<lbrakk>n < j;\n                    \\<not> loose_bvar (incr_bv inc n f) (lev + inc)\\<rbrakk>\n                   \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j f)\n       (lev + inc);\n        \\<And>lev j.\n           \\<lbrakk>n < j;\n            \\<not> loose_bvar (incr_bv inc n t) (lev + inc)\\<rbrakk>\n           \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j t)\n                                     (lev + inc);\n        n < j;\n        \\<not> loose_bvar (incr_bv inc n (f $ t)) (lev + inc)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv inc j (f $ t))\n                                 (lev + inc)\n 3. \\<And>uu_ uv_ v va lev j.\n       \\<lbrakk>uv_ < j;\n        \\<not> loose_bvar (incr_bv uu_ uv_ (Ct v va)) (lev + uu_)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv uu_ j (Ct v va))\n                                 (lev + uu_)\n 4. \\<And>uu_ uv_ v va lev j.\n       \\<lbrakk>uv_ < j;\n        \\<not> loose_bvar (incr_bv uu_ uv_ (Fv v va)) (lev + uu_)\\<rbrakk>\n       \\<Longrightarrow> \\<not> loose_bvar (incr_bv uu_ j (Fv v va))\n                                 (lev + uu_)", "qed (auto split: if_splits)"], ["", "lemma subst_bvs1'_step_work: \"\\<forall>x \\<in> set args . is_closed x \\<Longrightarrow> \\<not> loose_bvar (subst_bv2 t lev a) lev \\<Longrightarrow>\n  subst_bvs1' t lev (a#args) = subst_bvs1' (subst_bv2 t lev a) lev args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set args. is_closed x;\n     \\<not> loose_bvar (subst_bv2 t lev a) lev\\<rbrakk>\n    \\<Longrightarrow> subst_bvs1' t lev (a # args) =\n                      subst_bvs1' (subst_bv2 t lev a) lev args", "proof (induction t \"lev\" \"args\" arbitrary: a rule: subst_bvs1'.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i lev args a.\n       \\<lbrakk>\\<forall>x\\<in>set args. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Bv i) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Bv i) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Bv i) lev a) lev args\n 2. \\<And>T body lev args a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set\n      (map (\\<lambda>t. lift t 0) args).\n                               is_closed x;\n                    \\<not> loose_bvar (subst_bv2 body (lev + 1) a)\n                            (lev + 1)\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' body (lev + 1)\n(a # map (\\<lambda>t. lift t 0) args) =\n                                     subst_bvs1'\n(subst_bv2 body (lev + 1) a) (lev + 1) (map (\\<lambda>t. lift t 0) args);\n        \\<forall>x\\<in>set args. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Abs T body) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Abs T body) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args\n 3. \\<And>f t lev u a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    \\<not> loose_bvar (subst_bv2 f lev a) lev\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' f lev (a # u) =\n                                     subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n            \\<not> loose_bvar (subst_bv2 t lev a) lev\\<rbrakk>\n           \\<Longrightarrow> subst_bvs1' t lev (a # u) =\n                             subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set u. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 4. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 5. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "case (1 i )"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set args_. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Bv i) lev_ a) lev_\n\ngoal (5 subgoals):\n 1. \\<And>i lev args a.\n       \\<lbrakk>\\<forall>x\\<in>set args. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Bv i) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Bv i) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Bv i) lev a) lev args\n 2. \\<And>T body lev args a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set\n      (map (\\<lambda>t. lift t 0) args).\n                               is_closed x;\n                    \\<not> loose_bvar (subst_bv2 body (lev + 1) a)\n                            (lev + 1)\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' body (lev + 1)\n(a # map (\\<lambda>t. lift t 0) args) =\n                                     subst_bvs1'\n(subst_bv2 body (lev + 1) a) (lev + 1) (map (\\<lambda>t. lift t 0) args);\n        \\<forall>x\\<in>set args. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Abs T body) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Abs T body) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args\n 3. \\<And>f t lev u a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    \\<not> loose_bvar (subst_bv2 f lev a) lev\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' f lev (a # u) =\n                                     subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n            \\<not> loose_bvar (subst_bv2 t lev a) lev\\<rbrakk>\n           \\<Longrightarrow> subst_bvs1' t lev (a # u) =\n                             subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set u. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 4. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 5. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set args_. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Bv i) lev_ a) lev_", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set args_. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Bv i) lev_ a) lev_\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Bv i) lev_ (a # args_) =\n    subst_bvs1' (subst_bv2 (Bv i) lev_ a) lev_ args_", "using no_loose_bvar_subst_bvs1'_unchanged"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set args_. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Bv i) lev_ a) lev_\n  \\<not> loose_bvar ?t ?lev \\<Longrightarrow> subst_bvs1' ?t ?lev ?args = ?t\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Bv i) lev_ (a # args_) =\n    subst_bvs1' (subst_bv2 (Bv i) lev_ a) lev_ args_", "by (auto simp add: is_open_def)"], ["proof (state)\nthis:\n  subst_bvs1' (Bv i) lev_ (a # args_) =\n  subst_bvs1' (subst_bv2 (Bv i) lev_ a) lev_ args_\n\ngoal (4 subgoals):\n 1. \\<And>T body lev args a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set\n      (map (\\<lambda>t. lift t 0) args).\n                               is_closed x;\n                    \\<not> loose_bvar (subst_bv2 body (lev + 1) a)\n                            (lev + 1)\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' body (lev + 1)\n(a # map (\\<lambda>t. lift t 0) args) =\n                                     subst_bvs1'\n(subst_bv2 body (lev + 1) a) (lev + 1) (map (\\<lambda>t. lift t 0) args);\n        \\<forall>x\\<in>set args. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Abs T body) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Abs T body) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args\n 2. \\<And>f t lev u a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    \\<not> loose_bvar (subst_bv2 f lev a) lev\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' f lev (a # u) =\n                                     subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n            \\<not> loose_bvar (subst_bv2 t lev a) lev\\<rbrakk>\n           \\<Longrightarrow> subst_bvs1' t lev (a # u) =\n                             subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set u. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 3. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 4. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>T body lev args a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set\n      (map (\\<lambda>t. lift t 0) args).\n                               is_closed x;\n                    \\<not> loose_bvar (subst_bv2 body (lev + 1) a)\n                            (lev + 1)\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' body (lev + 1)\n(a # map (\\<lambda>t. lift t 0) args) =\n                                     subst_bvs1'\n(subst_bv2 body (lev + 1) a) (lev + 1) (map (\\<lambda>t. lift t 0) args);\n        \\<forall>x\\<in>set args. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Abs T body) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Abs T body) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args\n 2. \\<And>f t lev u a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    \\<not> loose_bvar (subst_bv2 f lev a) lev\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' f lev (a # u) =\n                                     subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n            \\<not> loose_bvar (subst_bv2 t lev a) lev\\<rbrakk>\n           \\<Longrightarrow> subst_bvs1' t lev (a # u) =\n                             subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set u. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 3. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 4. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "case (2 T body lev args)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set (map (\\<lambda>t. lift t 0) args).\n              is_closed x;\n   \\<not> loose_bvar (subst_bv2 body (lev + 1) ?a) (lev + 1)\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' body (lev + 1)\n                     (?a # map (\\<lambda>t. lift t 0) args) =\n                    subst_bvs1' (subst_bv2 body (lev + 1) ?a) (lev + 1)\n                     (map (\\<lambda>t. lift t 0) args)\n  \\<forall>x\\<in>set args. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Abs T body) lev a) lev\n\ngoal (4 subgoals):\n 1. \\<And>T body lev args a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set\n      (map (\\<lambda>t. lift t 0) args).\n                               is_closed x;\n                    \\<not> loose_bvar (subst_bv2 body (lev + 1) a)\n                            (lev + 1)\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' body (lev + 1)\n(a # map (\\<lambda>t. lift t 0) args) =\n                                     subst_bvs1'\n(subst_bv2 body (lev + 1) a) (lev + 1) (map (\\<lambda>t. lift t 0) args);\n        \\<forall>x\\<in>set args. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Abs T body) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Abs T body) lev (a # args) =\n                         subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args\n 2. \\<And>f t lev u a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    \\<not> loose_bvar (subst_bv2 f lev a) lev\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' f lev (a # u) =\n                                     subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n            \\<not> loose_bvar (subst_bv2 t lev a) lev\\<rbrakk>\n           \\<Longrightarrow> subst_bvs1' t lev (a # u) =\n                             subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set u. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 3. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 4. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x\\<in>set (map (\\<lambda>t. lift t 0) args).\n              is_closed x;\n   \\<not> loose_bvar (subst_bv2 body (lev + 1) ?a) (lev + 1)\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' body (lev + 1)\n                     (?a # map (\\<lambda>t. lift t 0) args) =\n                    subst_bvs1' (subst_bv2 body (lev + 1) ?a) (lev + 1)\n                     (map (\\<lambda>t. lift t 0) args)\n  \\<forall>x\\<in>set args. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Abs T body) lev a) lev", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set (map (\\<lambda>t. lift t 0) args).\n              is_closed x;\n   \\<not> loose_bvar (subst_bv2 body (lev + 1) ?a) (lev + 1)\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' body (lev + 1)\n                     (?a # map (\\<lambda>t. lift t 0) args) =\n                    subst_bvs1' (subst_bv2 body (lev + 1) ?a) (lev + 1)\n                     (map (\\<lambda>t. lift t 0) args)\n  \\<forall>x\\<in>set args. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Abs T body) lev a) lev\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Abs T body) lev (a # args) =\n    subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args", "using no_loose_bvar_subst_bvs1'_unchanged"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set (map (\\<lambda>t. lift t 0) args).\n              is_closed x;\n   \\<not> loose_bvar (subst_bv2 body (lev + 1) ?a) (lev + 1)\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' body (lev + 1)\n                     (?a # map (\\<lambda>t. lift t 0) args) =\n                    subst_bvs1' (subst_bv2 body (lev + 1) ?a) (lev + 1)\n                     (map (\\<lambda>t. lift t 0) args)\n  \\<forall>x\\<in>set args. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Abs T body) lev a) lev\n  \\<not> loose_bvar ?t ?lev \\<Longrightarrow> subst_bvs1' ?t ?lev ?args = ?t\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Abs T body) lev (a # args) =\n    subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args", "by (auto simp add: is_open_def)"], ["proof (state)\nthis:\n  subst_bvs1' (Abs T body) lev (a # args) =\n  subst_bvs1' (subst_bv2 (Abs T body) lev a) lev args\n\ngoal (3 subgoals):\n 1. \\<And>f t lev u a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    \\<not> loose_bvar (subst_bv2 f lev a) lev\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' f lev (a # u) =\n                                     subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n            \\<not> loose_bvar (subst_bv2 t lev a) lev\\<rbrakk>\n           \\<Longrightarrow> subst_bvs1' t lev (a # u) =\n                             subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set u. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 2. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 3. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f t lev u a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    \\<not> loose_bvar (subst_bv2 f lev a) lev\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' f lev (a # u) =\n                                     subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n            \\<not> loose_bvar (subst_bv2 t lev a) lev\\<rbrakk>\n           \\<Longrightarrow> subst_bvs1' t lev (a # u) =\n                             subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set u. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 2. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 3. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "case (3 f t lev u)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   \\<not> loose_bvar (subst_bv2 f lev ?a) lev\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' f lev (?a # u) =\n                    subst_bvs1' (subst_bv2 f lev ?a) lev u\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   \\<not> loose_bvar (subst_bv2 t lev ?a) lev\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' t lev (?a # u) =\n                    subst_bvs1' (subst_bv2 t lev ?a) lev u\n  \\<forall>x\\<in>set u. is_closed x\n  \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\n\ngoal (3 subgoals):\n 1. \\<And>f t lev u a.\n       \\<lbrakk>\\<And>a.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    \\<not> loose_bvar (subst_bv2 f lev a) lev\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' f lev (a # u) =\n                                     subst_bvs1' (subst_bv2 f lev a) lev u;\n        \\<And>a.\n           \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n            \\<not> loose_bvar (subst_bv2 t lev a) lev\\<rbrakk>\n           \\<Longrightarrow> subst_bvs1' t lev (a # u) =\n                             subst_bvs1' (subst_bv2 t lev a) lev u;\n        \\<forall>x\\<in>set u. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (f $ t) lev (a # u) =\n                         subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n 2. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 3. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   \\<not> loose_bvar (subst_bv2 f lev ?a) lev\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' f lev (?a # u) =\n                    subst_bvs1' (subst_bv2 f lev ?a) lev u\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   \\<not> loose_bvar (subst_bv2 t lev ?a) lev\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' t lev (?a # u) =\n                    subst_bvs1' (subst_bv2 t lev ?a) lev u\n  \\<forall>x\\<in>set u. is_closed x\n  \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   \\<not> loose_bvar (subst_bv2 f lev ?a) lev\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' f lev (?a # u) =\n                    subst_bvs1' (subst_bv2 f lev ?a) lev u\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   \\<not> loose_bvar (subst_bv2 t lev ?a) lev\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' t lev (?a # u) =\n                    subst_bvs1' (subst_bv2 t lev ?a) lev u\n  \\<forall>x\\<in>set u. is_closed x\n  \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\n\ngoal (1 subgoal):\n 1. subst_bvs1' (f $ t) lev (a # u) =\n    subst_bvs1' (subst_bv2 (f $ t) lev a) lev u", "using no_loose_bvar_subst_bvs1'_unchanged"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   \\<not> loose_bvar (subst_bv2 f lev ?a) lev\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' f lev (?a # u) =\n                    subst_bvs1' (subst_bv2 f lev ?a) lev u\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   \\<not> loose_bvar (subst_bv2 t lev ?a) lev\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' t lev (?a # u) =\n                    subst_bvs1' (subst_bv2 t lev ?a) lev u\n  \\<forall>x\\<in>set u. is_closed x\n  \\<not> loose_bvar (subst_bv2 (f $ t) lev a) lev\n  \\<not> loose_bvar ?t ?lev \\<Longrightarrow> subst_bvs1' ?t ?lev ?args = ?t\n\ngoal (1 subgoal):\n 1. subst_bvs1' (f $ t) lev (a # u) =\n    subst_bvs1' (subst_bv2 (f $ t) lev a) lev u", "by (auto simp add: is_open_def)"], ["proof (state)\nthis:\n  subst_bvs1' (f $ t) lev (a # u) =\n  subst_bvs1' (subst_bv2 (f $ t) lev a) lev u\n\ngoal (2 subgoals):\n 1. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 2. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 2. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "case (\"4_1\" v va uu uv)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set uv. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Ct v va) uu a) uu\n\ngoal (2 subgoals):\n 1. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Ct v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Ct v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Ct v va) uu_ a) uu_ uv_\n 2. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set uv. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Ct v va) uu a) uu", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set uv. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Ct v va) uu a) uu\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Ct v va) uu (a # uv) =\n    subst_bvs1' (subst_bv2 (Ct v va) uu a) uu uv", "using no_loose_bvar_subst_bvs1'_unchanged"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set uv. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Ct v va) uu a) uu\n  \\<not> loose_bvar ?t ?lev \\<Longrightarrow> subst_bvs1' ?t ?lev ?args = ?t\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Ct v va) uu (a # uv) =\n    subst_bvs1' (subst_bv2 (Ct v va) uu a) uu uv", "by (auto simp add: is_open_def)"], ["proof (state)\nthis:\n  subst_bvs1' (Ct v va) uu (a # uv) =\n  subst_bvs1' (subst_bv2 (Ct v va) uu a) uu uv\n\ngoal (1 subgoal):\n 1. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "case (\"4_2\" v va uu uv)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set uv. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Fv v va) uu a) uu\n\ngoal (1 subgoal):\n 1. \\<And>v va uu_ uv_ a.\n       \\<lbrakk>\\<forall>x\\<in>set uv_. is_closed x;\n        \\<not> loose_bvar (subst_bv2 (Fv v va) uu_ a) uu_\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (Fv v va) uu_ (a # uv_) =\n                         subst_bvs1' (subst_bv2 (Fv v va) uu_ a) uu_ uv_", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set uv. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Fv v va) uu a) uu", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set uv. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Fv v va) uu a) uu\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Fv v va) uu (a # uv) =\n    subst_bvs1' (subst_bv2 (Fv v va) uu a) uu uv", "using no_loose_bvar_subst_bvs1'_unchanged"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set uv. is_closed x\n  \\<not> loose_bvar (subst_bv2 (Fv v va) uu a) uu\n  \\<not> loose_bvar ?t ?lev \\<Longrightarrow> subst_bvs1' ?t ?lev ?args = ?t\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Fv v va) uu (a # uv) =\n    subst_bvs1' (subst_bv2 (Fv v va) uu a) uu uv", "by (auto simp add: is_open_def)"], ["proof (state)\nthis:\n  subst_bvs1' (Fv v va) uu (a # uv) =\n  subst_bvs1' (subst_bv2 (Fv v va) uu a) uu uv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_closed_subst_bv2_unchanged: \"is_closed t \\<Longrightarrow> subst_bv2 t n u = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_closed t \\<Longrightarrow> subst_bv2 t n u = t", "by (metis is_open_def lift_def loose_bvar_Suc no_loose_bvar_no_incr subst_bv2_lift zero_induct)"], ["", "(* This might do it, should be able to connect a new substitution to the pushed in one *)"], ["", "lemma subst_bvs1'_step_extend_lower_level: \"\\<forall>x \\<in> set (a#args) . is_closed x \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' t (Suc lev) args) lev a\n    = subst_bvs1' t lev (a#args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n    subst_bv2 (subst_bvs1' t (Suc lev) args) lev a =\n    subst_bvs1' t lev (a # args)", "proof (induction t lev \"a#args\" arbitrary: a args rule: subst_bvs1'.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i lev a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n       subst_bvs1' (Bv i) lev (a # args)\n 2. \\<And>T body lev a args.\n       \\<lbrakk>\\<And>aa argsa.\n                   \\<lbrakk>map (\\<lambda>t. lift t 0) (a # args) =\n                            aa # argsa;\n                    \\<forall>x\\<in>set (aa # argsa). is_closed x\\<rbrakk>\n                   \\<Longrightarrow> subst_bv2\n(subst_bvs1' body (Suc (lev + 1)) argsa) (lev + 1) aa =\n                                     subst_bvs1' body (lev + 1)\n(aa # argsa);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (Abs T body) (Suc lev) args)\n                          lev a =\n                         subst_bvs1' (Abs T body) lev (a # args)\n 3. \\<And>f t lev a args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n                subst_bv2 (subst_bvs1' f (Suc lev) args) lev a =\n                subst_bvs1' f lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n        subst_bv2 (subst_bvs1' t (Suc lev) args) lev a =\n        subst_bvs1' t lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (f $ t) (Suc lev) args) lev\n                          a =\n                         subst_bvs1' (f $ t) lev (a # args)\n 4. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Ct v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Ct v va) uu_ (a # args)\n 5. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Fv v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Fv v va) uu_ (a # args)", "case (1 i lev)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (a # args). is_closed x\n\ngoal (5 subgoals):\n 1. \\<And>i lev a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n       subst_bvs1' (Bv i) lev (a # args)\n 2. \\<And>T body lev a args.\n       \\<lbrakk>\\<And>aa argsa.\n                   \\<lbrakk>map (\\<lambda>t. lift t 0) (a # args) =\n                            aa # argsa;\n                    \\<forall>x\\<in>set (aa # argsa). is_closed x\\<rbrakk>\n                   \\<Longrightarrow> subst_bv2\n(subst_bvs1' body (Suc (lev + 1)) argsa) (lev + 1) aa =\n                                     subst_bvs1' body (lev + 1)\n(aa # argsa);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (Abs T body) (Suc lev) args)\n                          lev a =\n                         subst_bvs1' (Abs T body) lev (a # args)\n 3. \\<And>f t lev a args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n                subst_bv2 (subst_bvs1' f (Suc lev) args) lev a =\n                subst_bvs1' f lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n        subst_bv2 (subst_bvs1' t (Suc lev) args) lev a =\n        subst_bvs1' t lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (f $ t) (Suc lev) args) lev\n                          a =\n                         subst_bvs1' (f $ t) lev (a # args)\n 4. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Ct v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Ct v va) uu_ (a # args)\n 5. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Fv v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Fv v va) uu_ (a # args)", "have \"subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)\"\n    if \"i < Suc lev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "using that"], ["proof (prove)\nusing this:\n  i < Suc lev\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "by auto"], ["proof (state)\nthis:\n  i < Suc lev \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n  subst_bvs1' (Bv i) lev (a # args)\n\ngoal (5 subgoals):\n 1. \\<And>i lev a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n       subst_bvs1' (Bv i) lev (a # args)\n 2. \\<And>T body lev a args.\n       \\<lbrakk>\\<And>aa argsa.\n                   \\<lbrakk>map (\\<lambda>t. lift t 0) (a # args) =\n                            aa # argsa;\n                    \\<forall>x\\<in>set (aa # argsa). is_closed x\\<rbrakk>\n                   \\<Longrightarrow> subst_bv2\n(subst_bvs1' body (Suc (lev + 1)) argsa) (lev + 1) aa =\n                                     subst_bvs1' body (lev + 1)\n(aa # argsa);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (Abs T body) (Suc lev) args)\n                          lev a =\n                         subst_bvs1' (Abs T body) lev (a # args)\n 3. \\<And>f t lev a args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n                subst_bv2 (subst_bvs1' f (Suc lev) args) lev a =\n                subst_bvs1' f lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n        subst_bv2 (subst_bvs1' t (Suc lev) args) lev a =\n        subst_bvs1' t lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (f $ t) (Suc lev) args) lev\n                          a =\n                         subst_bvs1' (f $ t) lev (a # args)\n 4. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Ct v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Ct v va) uu_ (a # args)\n 5. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Fv v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Fv v va) uu_ (a # args)", "moreover"], ["proof (state)\nthis:\n  i < Suc lev \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n  subst_bvs1' (Bv i) lev (a # args)\n\ngoal (5 subgoals):\n 1. \\<And>i lev a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n       subst_bvs1' (Bv i) lev (a # args)\n 2. \\<And>T body lev a args.\n       \\<lbrakk>\\<And>aa argsa.\n                   \\<lbrakk>map (\\<lambda>t. lift t 0) (a # args) =\n                            aa # argsa;\n                    \\<forall>x\\<in>set (aa # argsa). is_closed x\\<rbrakk>\n                   \\<Longrightarrow> subst_bv2\n(subst_bvs1' body (Suc (lev + 1)) argsa) (lev + 1) aa =\n                                     subst_bvs1' body (lev + 1)\n(aa # argsa);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (Abs T body) (Suc lev) args)\n                          lev a =\n                         subst_bvs1' (Abs T body) lev (a # args)\n 3. \\<And>f t lev a args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n                subst_bv2 (subst_bvs1' f (Suc lev) args) lev a =\n                subst_bvs1' f lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n        subst_bv2 (subst_bvs1' t (Suc lev) args) lev a =\n        subst_bvs1' t lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (f $ t) (Suc lev) args) lev\n                          a =\n                         subst_bvs1' (f $ t) lev (a # args)\n 4. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Ct v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Ct v va) uu_ (a # args)\n 5. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Fv v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Fv v va) uu_ (a # args)", "have \"subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)\"\n    if \"i - Suc lev < length args\" \"\\<not> i < Suc lev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "have \"subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a = subst_bv2 (args ! (i - Suc lev)) lev a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bv2 (args ! (i - Suc lev)) lev a", "using that"], ["proof (prove)\nusing this:\n  i - Suc lev < length args\n  \\<not> i < Suc lev\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bv2 (args ! (i - Suc lev)) lev a", "by simp"], ["proof (state)\nthis:\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n  subst_bv2 (args ! (i - Suc lev)) lev a\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "also"], ["proof (state)\nthis:\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n  subst_bv2 (args ! (i - Suc lev)) lev a\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "have \"\\<dots> = args ! (i - Suc lev)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bv2 (args ! (i - Suc lev)) lev a = args ! (i - Suc lev)", "using 1 that(1)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (a # args). is_closed x\n  i - Suc lev < length args\n\ngoal (1 subgoal):\n 1. subst_bv2 (args ! (i - Suc lev)) lev a = args ! (i - Suc lev)", "by (auto simp add: is_closed_subst_bv2_unchanged)"], ["proof (state)\nthis:\n  subst_bv2 (args ! (i - Suc lev)) lev a = args ! (i - Suc lev)\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "also"], ["proof (state)\nthis:\n  subst_bv2 (args ! (i - Suc lev)) lev a = args ! (i - Suc lev)\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "have \"subst_bvs1' (Bv i) lev (a # args) = args ! (i - Suc lev)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bvs1' (Bv i) lev (a # args) = args ! (i - Suc lev)", "using that"], ["proof (prove)\nusing this:\n  i - Suc lev < length args\n  \\<not> i < Suc lev\n\ngoal (1 subgoal):\n 1. subst_bvs1' (Bv i) lev (a # args) = args ! (i - Suc lev)", "by auto"], ["proof (state)\nthis:\n  subst_bvs1' (Bv i) lev (a # args) = args ! (i - Suc lev)\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "finally"], ["proof (chain)\npicking this:\n  subst_bvs1' (Bv i) lev (a # args) =\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_bvs1' (Bv i) lev (a # args) =\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "by simp"], ["proof (state)\nthis:\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n  subst_bvs1' (Bv i) lev (a # args)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>i - Suc lev < length args; \\<not> i < Suc lev\\<rbrakk>\n  \\<Longrightarrow> subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n                    subst_bvs1' (Bv i) lev (a # args)\n\ngoal (5 subgoals):\n 1. \\<And>i lev a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n       subst_bvs1' (Bv i) lev (a # args)\n 2. \\<And>T body lev a args.\n       \\<lbrakk>\\<And>aa argsa.\n                   \\<lbrakk>map (\\<lambda>t. lift t 0) (a # args) =\n                            aa # argsa;\n                    \\<forall>x\\<in>set (aa # argsa). is_closed x\\<rbrakk>\n                   \\<Longrightarrow> subst_bv2\n(subst_bvs1' body (Suc (lev + 1)) argsa) (lev + 1) aa =\n                                     subst_bvs1' body (lev + 1)\n(aa # argsa);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (Abs T body) (Suc lev) args)\n                          lev a =\n                         subst_bvs1' (Abs T body) lev (a # args)\n 3. \\<And>f t lev a args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n                subst_bv2 (subst_bvs1' f (Suc lev) args) lev a =\n                subst_bvs1' f lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n        subst_bv2 (subst_bvs1' t (Suc lev) args) lev a =\n        subst_bvs1' t lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (f $ t) (Suc lev) args) lev\n                          a =\n                         subst_bvs1' (f $ t) lev (a # args)\n 4. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Ct v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Ct v va) uu_ (a # args)\n 5. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Fv v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Fv v va) uu_ (a # args)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>i - Suc lev < length args; \\<not> i < Suc lev\\<rbrakk>\n  \\<Longrightarrow> subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n                    subst_bvs1' (Bv i) lev (a # args)\n\ngoal (5 subgoals):\n 1. \\<And>i lev a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n       subst_bvs1' (Bv i) lev (a # args)\n 2. \\<And>T body lev a args.\n       \\<lbrakk>\\<And>aa argsa.\n                   \\<lbrakk>map (\\<lambda>t. lift t 0) (a # args) =\n                            aa # argsa;\n                    \\<forall>x\\<in>set (aa # argsa). is_closed x\\<rbrakk>\n                   \\<Longrightarrow> subst_bv2\n(subst_bvs1' body (Suc (lev + 1)) argsa) (lev + 1) aa =\n                                     subst_bvs1' body (lev + 1)\n(aa # argsa);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (Abs T body) (Suc lev) args)\n                          lev a =\n                         subst_bvs1' (Abs T body) lev (a # args)\n 3. \\<And>f t lev a args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n                subst_bv2 (subst_bvs1' f (Suc lev) args) lev a =\n                subst_bvs1' f lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n        subst_bv2 (subst_bvs1' t (Suc lev) args) lev a =\n        subst_bvs1' t lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (f $ t) (Suc lev) args) lev\n                          a =\n                         subst_bvs1' (f $ t) lev (a # args)\n 4. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Ct v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Ct v va) uu_ (a # args)\n 5. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Fv v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Fv v va) uu_ (a # args)", "have \"subst_bv2(subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)\"\n    if \"i \\<ge> Suc lev\" \"i - lev \\<ge> length args\" \"\\<not> i < Suc lev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "using that 1"], ["proof (prove)\nusing this:\n  Suc lev \\<le> i\n  length args \\<le> i - lev\n  \\<not> i < Suc lev\n  \\<forall>x\\<in>set (a # args). is_closed x\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "by (auto simp add: is_closed_subst_bv2_unchanged)"], ["proof (state)\nthis:\n  \\<lbrakk>Suc lev \\<le> i; length args \\<le> i - lev;\n   \\<not> i < Suc lev\\<rbrakk>\n  \\<Longrightarrow> subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n                    subst_bvs1' (Bv i) lev (a # args)\n\ngoal (5 subgoals):\n 1. \\<And>i lev a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n       subst_bvs1' (Bv i) lev (a # args)\n 2. \\<And>T body lev a args.\n       \\<lbrakk>\\<And>aa argsa.\n                   \\<lbrakk>map (\\<lambda>t. lift t 0) (a # args) =\n                            aa # argsa;\n                    \\<forall>x\\<in>set (aa # argsa). is_closed x\\<rbrakk>\n                   \\<Longrightarrow> subst_bv2\n(subst_bvs1' body (Suc (lev + 1)) argsa) (lev + 1) aa =\n                                     subst_bvs1' body (lev + 1)\n(aa # argsa);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (Abs T body) (Suc lev) args)\n                          lev a =\n                         subst_bvs1' (Abs T body) lev (a # args)\n 3. \\<And>f t lev a args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n                subst_bv2 (subst_bvs1' f (Suc lev) args) lev a =\n                subst_bvs1' f lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n        subst_bv2 (subst_bvs1' t (Suc lev) args) lev a =\n        subst_bvs1' t lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (f $ t) (Suc lev) args) lev\n                          a =\n                         subst_bvs1' (f $ t) lev (a # args)\n 4. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Ct v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Ct v va) uu_ (a # args)\n 5. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Fv v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Fv v va) uu_ (a # args)", "ultimately"], ["proof (chain)\npicking this:\n  i < Suc lev \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n  subst_bvs1' (Bv i) lev (a # args)\n  \\<lbrakk>i - Suc lev < length args; \\<not> i < Suc lev\\<rbrakk>\n  \\<Longrightarrow> subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n                    subst_bvs1' (Bv i) lev (a # args)\n  \\<lbrakk>Suc lev \\<le> i; length args \\<le> i - lev;\n   \\<not> i < Suc lev\\<rbrakk>\n  \\<Longrightarrow> subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n                    subst_bvs1' (Bv i) lev (a # args)", "show ?case"], ["proof (prove)\nusing this:\n  i < Suc lev \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n  subst_bvs1' (Bv i) lev (a # args)\n  \\<lbrakk>i - Suc lev < length args; \\<not> i < Suc lev\\<rbrakk>\n  \\<Longrightarrow> subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n                    subst_bvs1' (Bv i) lev (a # args)\n  \\<lbrakk>Suc lev \\<le> i; length args \\<le> i - lev;\n   \\<not> i < Suc lev\\<rbrakk>\n  \\<Longrightarrow> subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n                    subst_bvs1' (Bv i) lev (a # args)\n\ngoal (1 subgoal):\n 1. subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n    subst_bvs1' (Bv i) lev (a # args)", "by (auto simp add: is_open_def split: if_splits)"], ["proof (state)\nthis:\n  subst_bv2 (subst_bvs1' (Bv i) (Suc lev) args) lev a =\n  subst_bvs1' (Bv i) lev (a # args)\n\ngoal (4 subgoals):\n 1. \\<And>T body lev a args.\n       \\<lbrakk>\\<And>aa argsa.\n                   \\<lbrakk>map (\\<lambda>t. lift t 0) (a # args) =\n                            aa # argsa;\n                    \\<forall>x\\<in>set (aa # argsa). is_closed x\\<rbrakk>\n                   \\<Longrightarrow> subst_bv2\n(subst_bvs1' body (Suc (lev + 1)) argsa) (lev + 1) aa =\n                                     subst_bvs1' body (lev + 1)\n(aa # argsa);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (Abs T body) (Suc lev) args)\n                          lev a =\n                         subst_bvs1' (Abs T body) lev (a # args)\n 2. \\<And>f t lev a args.\n       \\<lbrakk>\\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n                subst_bv2 (subst_bvs1' f (Suc lev) args) lev a =\n                subst_bvs1' f lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n        subst_bv2 (subst_bvs1' t (Suc lev) args) lev a =\n        subst_bvs1' t lev (a # args);\n        \\<forall>x\\<in>set (a # args). is_closed x\\<rbrakk>\n       \\<Longrightarrow> subst_bv2 (subst_bvs1' (f $ t) (Suc lev) args) lev\n                          a =\n                         subst_bvs1' (f $ t) lev (a # args)\n 3. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Ct v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Ct v va) uu_ (a # args)\n 4. \\<And>v va uu_ a args.\n       \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n       subst_bv2 (subst_bvs1' (Fv v va) (Suc uu_) args) uu_ a =\n       subst_bvs1' (Fv v va) uu_ (a # args)", "qed (auto simp add: is_open_def)"], ["", "corollary subst_bvs_extend_lower_level:\n  \"\\<forall>x \\<in> set (a#args) . is_closed x \\<Longrightarrow>\n  subst_bv a (subst_bvs1' t 1 args) = subst_bvs (a#args) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n    subst_bv a (subst_bvs1' t 1 args) = subst_bvs (a # args) t", "using subst_bvs1'_step_extend_lower_level"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (?a # ?args). is_closed x \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' ?t (Suc ?lev) ?args) ?lev ?a =\n  subst_bvs1' ?t ?lev (?a # ?args)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (a # args). is_closed x \\<Longrightarrow>\n    subst_bv a (subst_bvs1' t 1 args) = subst_bvs (a # args) t", "by (simp add: subst_bvs_subst_bvs1' substn_subst_0')"], ["", "lemma subst_bvs1'_preserves_beta:\n  \"\\<forall>x \\<in> set u . is_closed x \\<Longrightarrow> r \\<rightarrow>\\<^sub>\\<beta> s \\<Longrightarrow> subst_bvs1' r k u \\<rightarrow>\\<^sub>\\<beta> subst_bvs1' s k u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n     r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n    \\<Longrightarrow> subst_bvs1' r k u \\<rightarrow>\\<^sub>\\<beta>\n                      subst_bvs1' s k u", "proof (induction u arbitrary: r s )"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>\\<forall>x\\<in>set []. is_closed x;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' r k [] \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bvs1' s k []\n 2. \\<And>a u r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' r k\nu \\<rightarrow>\\<^sub>\\<beta>\n                                     subst_bvs1' s k u;\n        \\<forall>x\\<in>set (a # u). is_closed x;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' r k (a # u) \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bvs1' s k (a # u)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. is_closed x\n  r \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (2 subgoals):\n 1. \\<And>r s.\n       \\<lbrakk>\\<forall>x\\<in>set []. is_closed x;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' r k [] \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bvs1' s k []\n 2. \\<And>a u r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' r k\nu \\<rightarrow>\\<^sub>\\<beta>\n                                     subst_bvs1' s k u;\n        \\<forall>x\\<in>set (a # u). is_closed x;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' r k (a # u) \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bvs1' s k (a # u)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set []. is_closed x\n  r \\<rightarrow>\\<^sub>\\<beta> s", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set []. is_closed x\n  r \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (1 subgoal):\n 1. subst_bvs1' r k [] \\<rightarrow>\\<^sub>\\<beta> subst_bvs1' s k []", "by auto"], ["proof (state)\nthis:\n  subst_bvs1' r k [] \\<rightarrow>\\<^sub>\\<beta> subst_bvs1' s k []\n\ngoal (1 subgoal):\n 1. \\<And>a u r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' r k\nu \\<rightarrow>\\<^sub>\\<beta>\n                                     subst_bvs1' s k u;\n        \\<forall>x\\<in>set (a # u). is_closed x;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' r k (a # u) \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bvs1' s k (a # u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a u r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' r k\nu \\<rightarrow>\\<^sub>\\<beta>\n                                     subst_bvs1' s k u;\n        \\<forall>x\\<in>set (a # u). is_closed x;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' r k (a # u) \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bvs1' s k (a # u)", "case (Cons a u)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   ?r \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' ?r k u \\<rightarrow>\\<^sub>\\<beta>\n                    subst_bvs1' ?s k u\n  \\<forall>x\\<in>set (a # u). is_closed x\n  r \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (1 subgoal):\n 1. \\<And>a u r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' r k\nu \\<rightarrow>\\<^sub>\\<beta>\n                                     subst_bvs1' s k u;\n        \\<forall>x\\<in>set (a # u). is_closed x;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' r k (a # u) \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bvs1' s k (a # u)", "hence \"subst_bv2 r k a \\<rightarrow>\\<^sub>\\<beta> subst_bv2 s k a\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   ?r \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' ?r k u \\<rightarrow>\\<^sub>\\<beta>\n                    subst_bvs1' ?s k u\n  \\<forall>x\\<in>set (a # u). is_closed x\n  r \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (1 subgoal):\n 1. subst_bv2 r k a \\<rightarrow>\\<^sub>\\<beta> subst_bv2 s k a", "by simp"], ["proof (state)\nthis:\n  subst_bv2 r k a \\<rightarrow>\\<^sub>\\<beta> subst_bv2 s k a\n\ngoal (1 subgoal):\n 1. \\<And>a u r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' r k\nu \\<rightarrow>\\<^sub>\\<beta>\n                                     subst_bvs1' s k u;\n        \\<forall>x\\<in>set (a # u). is_closed x;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' r k (a # u) \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bvs1' s k (a # u)", "hence \"subst_bvs1' (subst_bv2 r k a) k u \\<rightarrow>\\<^sub>\\<beta> subst_bvs1' (subst_bv2 s k a) k u\""], ["proof (prove)\nusing this:\n  subst_bv2 r k a \\<rightarrow>\\<^sub>\\<beta> subst_bv2 s k a\n\ngoal (1 subgoal):\n 1. subst_bvs1' (subst_bv2 r k a) k u \\<rightarrow>\\<^sub>\\<beta>\n    subst_bvs1' (subst_bv2 s k a) k u", "using Cons"], ["proof (prove)\nusing this:\n  subst_bv2 r k a \\<rightarrow>\\<^sub>\\<beta> subst_bv2 s k a\n  \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n   ?r \\<rightarrow>\\<^sub>\\<beta> ?s\\<rbrakk>\n  \\<Longrightarrow> subst_bvs1' ?r k u \\<rightarrow>\\<^sub>\\<beta>\n                    subst_bvs1' ?s k u\n  \\<forall>x\\<in>set (a # u). is_closed x\n  r \\<rightarrow>\\<^sub>\\<beta> s\n\ngoal (1 subgoal):\n 1. subst_bvs1' (subst_bv2 r k a) k u \\<rightarrow>\\<^sub>\\<beta>\n    subst_bvs1' (subst_bv2 s k a) k u", "by simp"], ["proof (state)\nthis:\n  subst_bvs1' (subst_bv2 r k a) k u \\<rightarrow>\\<^sub>\\<beta>\n  subst_bvs1' (subst_bv2 s k a) k u\n\ngoal (1 subgoal):\n 1. \\<And>a u r s.\n       \\<lbrakk>\\<And>r s.\n                   \\<lbrakk>\\<forall>x\\<in>set u. is_closed x;\n                    r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n                   \\<Longrightarrow> subst_bvs1' r k\nu \\<rightarrow>\\<^sub>\\<beta>\n                                     subst_bvs1' s k u;\n        \\<forall>x\\<in>set (a # u). is_closed x;\n        r \\<rightarrow>\\<^sub>\\<beta> s\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' r k (a # u) \\<rightarrow>\\<^sub>\\<beta>\n                         subst_bvs1' s k (a # u)", "then"], ["proof (chain)\npicking this:\n  subst_bvs1' (subst_bv2 r k a) k u \\<rightarrow>\\<^sub>\\<beta>\n  subst_bvs1' (subst_bv2 s k a) k u", "show ?case"], ["proof (prove)\nusing this:\n  subst_bvs1' (subst_bv2 r k a) k u \\<rightarrow>\\<^sub>\\<beta>\n  subst_bvs1' (subst_bv2 s k a) k u\n\ngoal (1 subgoal):\n 1. subst_bvs1' r k (a # u) \\<rightarrow>\\<^sub>\\<beta>\n    subst_bvs1' s k (a # u)", "by (simp add: subst_bvs1'_step[symmetric] Cons.prems(1))"], ["proof (state)\nthis:\n  subst_bvs1' r k (a # u) \\<rightarrow>\\<^sub>\\<beta>\n  subst_bvs1' s k (a # u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_bvs1'_fold: \"\\<forall>x \\<in> set args . is_closed x \\<Longrightarrow>\n  subst_bvs1' t lev args = fold (\\<lambda>arg t . subst_bv2 t lev arg) args t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set args. is_closed x \\<Longrightarrow>\n    subst_bvs1' t lev args =\n    fold (\\<lambda>arg t. subst_bv2 t lev arg) args t", "by (induction args arbitrary: t) (simp_all add: subst_bvs1'_step)"], ["", "lemma subst_bvs1'_Abs[simp]: \"\\<forall>x \\<in> set args . is_closed x \\<Longrightarrow>\n  subst_bvs1' (Abs T t) lev args = Abs T (subst_bvs1' t (Suc lev) args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set args. is_closed x \\<Longrightarrow>\n    subst_bvs1' (Abs T t) lev args = Abs T (subst_bvs1' t (Suc lev) args)", "by (simp add: is_open_def map_idI)"], ["", "lemma subst_bvs_Abs[simp]: \"\\<forall>x \\<in> set args . is_closed x \\<Longrightarrow>\n  subst_bvs args (Abs T t) = Abs T (subst_bvs1' t 1 args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set args. is_closed x \\<Longrightarrow>\n    subst_bvs args (Abs T t) = Abs T (subst_bvs1' t 1 args)", "using subst_bvs1'_Abs subst_bvs_subst_bvs1'"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ?args. is_closed x \\<Longrightarrow>\n  subst_bvs1' (Abs ?T ?t) ?lev ?args =\n  Abs ?T (subst_bvs1' ?t (Suc ?lev) ?args)\n  subst_bvs ?s ?t = subst_bvs1' ?t 0 ?s\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set args. is_closed x \\<Longrightarrow>\n    subst_bvs args (Abs T t) = Abs T (subst_bvs1' t 1 args)", "by auto"], ["", "lemma subst_bvs1'_incr_bv [simp]:\n    \"subst_bvs1' (incr_bv (length ss) k t) k ss = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bvs1' (incr_bv (length ss) k t) k ss = t", "proof (induct t arbitrary: k ss)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 k ss.\n       subst_bvs1' (incr_bv (length ss) k (Ct x1 x2)) k ss = Ct x1 x2\n 2. \\<And>x1 x2 k ss.\n       subst_bvs1' (incr_bv (length ss) k (Fv x1 x2)) k ss = Fv x1 x2\n 3. \\<And>x k ss. subst_bvs1' (incr_bv (length ss) k (Bv x)) k ss = Bv x\n 4. \\<And>x1 t k ss.\n       (\\<And>k ss.\n           subst_bvs1' (incr_bv (length ss) k t) k ss = t) \\<Longrightarrow>\n       subst_bvs1' (incr_bv (length ss) k (Abs x1 t)) k ss = Abs x1 t\n 5. \\<And>t1 t2 k ss.\n       \\<lbrakk>\\<And>k ss.\n                   subst_bvs1' (incr_bv (length ss) k t1) k ss = t1;\n        \\<And>k ss.\n           subst_bvs1' (incr_bv (length ss) k t2) k ss = t2\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (incr_bv (length ss) k (t1 $ t2)) k\n                          ss =\n                         t1 $ t2", "case (Abs T t)"], ["proof (state)\nthis:\n  subst_bvs1' (incr_bv (length ?ss) ?k t) ?k ?ss = t\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 k ss.\n       subst_bvs1' (incr_bv (length ss) k (Ct x1 x2)) k ss = Ct x1 x2\n 2. \\<And>x1 x2 k ss.\n       subst_bvs1' (incr_bv (length ss) k (Fv x1 x2)) k ss = Fv x1 x2\n 3. \\<And>x k ss. subst_bvs1' (incr_bv (length ss) k (Bv x)) k ss = Bv x\n 4. \\<And>x1 t k ss.\n       (\\<And>k ss.\n           subst_bvs1' (incr_bv (length ss) k t) k ss = t) \\<Longrightarrow>\n       subst_bvs1' (incr_bv (length ss) k (Abs x1 t)) k ss = Abs x1 t\n 5. \\<And>t1 t2 k ss.\n       \\<lbrakk>\\<And>k ss.\n                   subst_bvs1' (incr_bv (length ss) k t1) k ss = t1;\n        \\<And>k ss.\n           subst_bvs1' (incr_bv (length ss) k t2) k ss = t2\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (incr_bv (length ss) k (t1 $ t2)) k\n                          ss =\n                         t1 $ t2", "then"], ["proof (chain)\npicking this:\n  subst_bvs1' (incr_bv (length ?ss) ?k t) ?k ?ss = t", "show ?case"], ["proof (prove)\nusing this:\n  subst_bvs1' (incr_bv (length ?ss) ?k t) ?k ?ss = t\n\ngoal (1 subgoal):\n 1. subst_bvs1' (incr_bv (length ss) k (Abs T t)) k ss = Abs T t", "by simp (metis length_map)"], ["proof (state)\nthis:\n  subst_bvs1' (incr_bv (length ss) k (Abs T t)) k ss = Abs T t\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 k ss.\n       subst_bvs1' (incr_bv (length ss) k (Ct x1 x2)) k ss = Ct x1 x2\n 2. \\<And>x1 x2 k ss.\n       subst_bvs1' (incr_bv (length ss) k (Fv x1 x2)) k ss = Fv x1 x2\n 3. \\<And>x k ss. subst_bvs1' (incr_bv (length ss) k (Bv x)) k ss = Bv x\n 4. \\<And>t1 t2 k ss.\n       \\<lbrakk>\\<And>k ss.\n                   subst_bvs1' (incr_bv (length ss) k t1) k ss = t1;\n        \\<And>k ss.\n           subst_bvs1' (incr_bv (length ss) k t2) k ss = t2\\<rbrakk>\n       \\<Longrightarrow> subst_bvs1' (incr_bv (length ss) k (t1 $ t2)) k\n                          ss =\n                         t1 $ t2", "qed auto"], ["", "lemma lift_subst_bvs1' [simp]:\n    \"j < i + 1 \\<Longrightarrow> lift (subst_bvs1' t j ss) i \n    = subst_bvs1' (lift t (i + length ss)) j (map (\\<lambda>s . lift s i) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i + 1 \\<Longrightarrow>\n    lift (subst_bvs1' t j ss) i =\n    subst_bvs1' (lift t (i + length ss)) j (map (\\<lambda>s. lift s i) ss)", "proof (induct  t arbitrary: i j ss)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "case (Abs T t)"], ["proof (state)\nthis:\n  ?j < ?i + 1 \\<Longrightarrow>\n  lift (subst_bvs1' t ?j ?ss) ?i =\n  subst_bvs1' (lift t (?i + length ?ss)) ?j\n   (map (\\<lambda>s. lift s ?i) ?ss)\n  j < i + 1\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "hence I: \"lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i) =\n    subst_bvs1' (lift t (Suc i + length (map (\\<lambda>t. lift t 0) ss))) (Suc j) (map (\\<lambda>a. lift a (Suc i)) (map (\\<lambda>t. lift t 0) ss))\""], ["proof (prove)\nusing this:\n  ?j < ?i + 1 \\<Longrightarrow>\n  lift (subst_bvs1' t ?j ?ss) ?i =\n  subst_bvs1' (lift t (?i + length ?ss)) ?j\n   (map (\\<lambda>s. lift s ?i) ?ss)\n  j < i + 1\n\ngoal (1 subgoal):\n 1. lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i) =\n    subst_bvs1' (lift t (Suc i + length (map (\\<lambda>t. lift t 0) ss)))\n     (Suc j)\n     (map (\\<lambda>a. lift a (Suc i)) (map (\\<lambda>t. lift t 0) ss))", "by auto"], ["proof (state)\nthis:\n  lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i) =\n  subst_bvs1' (lift t (Suc i + length (map (\\<lambda>t. lift t 0) ss)))\n   (Suc j)\n   (map (\\<lambda>a. lift a (Suc i)) (map (\\<lambda>t. lift t 0) ss))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "have \"lift (subst_bvs1' (Abs T t) j ss) i \n    = Abs T (lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift (subst_bvs1' (Abs T t) j ss) i =\n    Abs T\n     (lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i))", "by simp"], ["proof (state)\nthis:\n  lift (subst_bvs1' (Abs T t) j ss) i =\n  Abs T\n   (lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "also"], ["proof (state)\nthis:\n  lift (subst_bvs1' (Abs T t) j ss) i =\n  Abs T\n   (lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "have \"\\<dots> = Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs T\n     (lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss))\n       (Suc i)) =\n    Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss)))", "using I"], ["proof (prove)\nusing this:\n  lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i) =\n  subst_bvs1' (lift t (Suc i + length (map (\\<lambda>t. lift t 0) ss)))\n   (Suc j)\n   (map (\\<lambda>a. lift a (Suc i)) (map (\\<lambda>t. lift t 0) ss))\n\ngoal (1 subgoal):\n 1. Abs T\n     (lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss))\n       (Suc i)) =\n    Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss)))", "by auto"], ["proof (state)\nthis:\n  Abs T\n   (lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i)) =\n  Abs T\n   (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n     (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss)))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "also"], ["proof (state)\nthis:\n  Abs T\n   (lift (subst_bvs1' t (Suc j) (map (\\<lambda>t. lift t 0) ss)) (Suc i)) =\n  Abs T\n   (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n     (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss)))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "have \"\\<dots> = Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss))) =\n    Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss))) =\n    Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)))", "have \"map (\\<lambda>t . lift t (Suc i)) (map (\\<lambda>t. lift t 0) ss) = map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>t. lift t (Suc i)) (map (\\<lambda>t. lift t 0) ss) =\n    map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)", "using lift_lift"], ["proof (prove)\nusing this:\n  ?i < ?k + 1 \\<Longrightarrow>\n  lift (lift ?t ?i) (Suc ?k) = lift (lift ?t ?k) ?i\n\ngoal (1 subgoal):\n 1. map (\\<lambda>t. lift t (Suc i)) (map (\\<lambda>t. lift t 0) ss) =\n    map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>t. lift t (Suc i)) (map (\\<lambda>t. lift t 0) ss) =\n  map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)\n\ngoal (1 subgoal):\n 1. Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss))) =\n    Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>t. lift t (Suc i)) (map (\\<lambda>t. lift t 0) ss) =\n  map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)\n\ngoal (1 subgoal):\n 1. Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss))) =\n    Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)))", "unfolding lift_def"], ["proof (prove)\nusing this:\n  map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss) =\n  map (incr_bv 1 0) (map (incr_bv 1 i) ss)\n\ngoal (1 subgoal):\n 1. Abs T\n     (subst_bvs1' (incr_bv 1 (Suc i + length (map (incr_bv 1 0) ss)) t)\n       (Suc j) (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss))) =\n    Abs T\n     (subst_bvs1' (incr_bv 1 (Suc i + length (map (incr_bv 1 0) ss)) t)\n       (Suc j) (map (incr_bv 1 0) (map (incr_bv 1 i) ss)))", "by argo"], ["proof (state)\nthis:\n  Abs T\n   (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n     (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss))) =\n  Abs T\n   (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n     (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Abs T\n   (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n     (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss))) =\n  Abs T\n   (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n     (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "also"], ["proof (state)\nthis:\n  Abs T\n   (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n     (map (incr_bv 1 (Suc i)) (map (incr_bv 1 0) ss))) =\n  Abs T\n   (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n     (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss)))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "have \"\\<dots> = subst_bvs1' (Abs T (lift t (Suc i + length (map (incr_bv 1 0) ss)))) j\n       (map (\\<lambda>t. lift t i) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs T\n     (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n       (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss))) =\n    subst_bvs1' (Abs T (lift t (Suc i + length (map (incr_bv 1 0) ss)))) j\n     (map (\\<lambda>t. lift t i) ss)", "by auto"], ["proof (state)\nthis:\n  Abs T\n   (subst_bvs1' (lift t (Suc i + length (map (incr_bv 1 0) ss))) (Suc j)\n     (map (\\<lambda>t. lift t 0) (map (\\<lambda>t. lift t i) ss))) =\n  subst_bvs1' (Abs T (lift t (Suc i + length (map (incr_bv 1 0) ss)))) j\n   (map (\\<lambda>t. lift t i) ss)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "finally"], ["proof (chain)\npicking this:\n  lift (subst_bvs1' (Abs T t) j ss) i =\n  subst_bvs1' (Abs T (lift t (Suc i + length (map (incr_bv 1 0) ss)))) j\n   (map (\\<lambda>t. lift t i) ss)", "show ?case"], ["proof (prove)\nusing this:\n  lift (subst_bvs1' (Abs T t) j ss) i =\n  subst_bvs1' (Abs T (lift t (Suc i + length (map (incr_bv 1 0) ss)))) j\n   (map (\\<lambda>t. lift t i) ss)\n\ngoal (1 subgoal):\n 1. lift (subst_bvs1' (Abs T t) j ss) i =\n    subst_bvs1' (lift (Abs T t) (i + length ss)) j\n     (map (\\<lambda>s. lift s i) ss)", "by simp"], ["proof (state)\nthis:\n  lift (subst_bvs1' (Abs T t) j ss) i =\n  subst_bvs1' (lift (Abs T t) (i + length ss)) j\n   (map (\\<lambda>s. lift s i) ss)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       j < i + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) (i + length ss)) j\n        (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   j < i + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 (i + length ss)) j\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           j < i + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 (i + length ss)) j\n            (map (\\<lambda>s. lift s i) ss);\n        j < i + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) (i + length ss)) j\n                          (map (\\<lambda>s. lift s i) ss)", "qed (auto simp add: diff_Suc lift_lift split: nat.split)"], ["", "lemma lift_subst_bvs1'_lt:\n    \"i < j + 1 \\<Longrightarrow> lift (subst_bvs1' t j ss) i \n  = subst_bvs1' (lift t i) (j + 1) (map (\\<lambda>s . lift s i) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j + 1 \\<Longrightarrow>\n    lift (subst_bvs1' t j ss) i =\n    subst_bvs1' (lift t i) (j + 1) (map (\\<lambda>s. lift s i) ss)", "proof (induct t arbitrary: i j ss)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       i < j + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) i) (j + 1)\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       i < j + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) i) (j + 1)\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       i < j + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) i) (j + 1) (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   i < j + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t i) (j + 1)\n                    (map (\\<lambda>s. lift s i) ss);\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) i) (j + 1)\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   i < j + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 i) (j + 1)\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           i < j + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 i) (j + 1) (map (\\<lambda>s. lift s i) ss);\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) i) (j + 1)\n                          (map (\\<lambda>s. lift s i) ss)", "case (Abs T t)"], ["proof (state)\nthis:\n  ?i < ?j + 1 \\<Longrightarrow>\n  lift (subst_bvs1' t ?j ?ss) ?i =\n  subst_bvs1' (lift t ?i) (?j + 1) (map (\\<lambda>s. lift s ?i) ?ss)\n  i < j + 1\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       i < j + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) i) (j + 1)\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       i < j + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) i) (j + 1)\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       i < j + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) i) (j + 1) (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>x1 t i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   i < j + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t j ss) i =\n                   subst_bvs1' (lift t i) (j + 1)\n                    (map (\\<lambda>s. lift s i) ss);\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (Abs x1 t) j ss) i =\n                         subst_bvs1' (lift (Abs x1 t) i) (j + 1)\n                          (map (\\<lambda>s. lift s i) ss)\n 5. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   i < j + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 i) (j + 1)\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           i < j + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 i) (j + 1) (map (\\<lambda>s. lift s i) ss);\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) i) (j + 1)\n                          (map (\\<lambda>s. lift s i) ss)", "then"], ["proof (chain)\npicking this:\n  ?i < ?j + 1 \\<Longrightarrow>\n  lift (subst_bvs1' t ?j ?ss) ?i =\n  subst_bvs1' (lift t ?i) (?j + 1) (map (\\<lambda>s. lift s ?i) ?ss)\n  i < j + 1", "show ?case"], ["proof (prove)\nusing this:\n  ?i < ?j + 1 \\<Longrightarrow>\n  lift (subst_bvs1' t ?j ?ss) ?i =\n  subst_bvs1' (lift t ?i) (?j + 1) (map (\\<lambda>s. lift s ?i) ?ss)\n  i < j + 1\n\ngoal (1 subgoal):\n 1. lift (subst_bvs1' (Abs T t) j ss) i =\n    subst_bvs1' (lift (Abs T t) i) (j + 1) (map (\\<lambda>s. lift s i) ss)", "using lift_lift"], ["proof (prove)\nusing this:\n  ?i < ?j + 1 \\<Longrightarrow>\n  lift (subst_bvs1' t ?j ?ss) ?i =\n  subst_bvs1' (lift t ?i) (?j + 1) (map (\\<lambda>s. lift s ?i) ?ss)\n  i < j + 1\n  ?i < ?k + 1 \\<Longrightarrow>\n  lift (lift ?t ?i) (Suc ?k) = lift (lift ?t ?k) ?i\n\ngoal (1 subgoal):\n 1. lift (subst_bvs1' (Abs T t) j ss) i =\n    subst_bvs1' (lift (Abs T t) i) (j + 1) (map (\\<lambda>s. lift s i) ss)", "by simp (smt comp_apply map_eq_conv zero_less_Suc)"], ["proof (state)\nthis:\n  lift (subst_bvs1' (Abs T t) j ss) i =\n  subst_bvs1' (lift (Abs T t) i) (j + 1) (map (\\<lambda>s. lift s i) ss)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 i j ss.\n       i < j + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Ct x1 x2) j ss) i =\n       subst_bvs1' (lift (Ct x1 x2) i) (j + 1)\n        (map (\\<lambda>s. lift s i) ss)\n 2. \\<And>x1 x2 i j ss.\n       i < j + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Fv x1 x2) j ss) i =\n       subst_bvs1' (lift (Fv x1 x2) i) (j + 1)\n        (map (\\<lambda>s. lift s i) ss)\n 3. \\<And>x i j ss.\n       i < j + 1 \\<Longrightarrow>\n       lift (subst_bvs1' (Bv x) j ss) i =\n       subst_bvs1' (lift (Bv x) i) (j + 1) (map (\\<lambda>s. lift s i) ss)\n 4. \\<And>t1 t2 i j ss.\n       \\<lbrakk>\\<And>i j ss.\n                   i < j + 1 \\<Longrightarrow>\n                   lift (subst_bvs1' t1 j ss) i =\n                   subst_bvs1' (lift t1 i) (j + 1)\n                    (map (\\<lambda>s. lift s i) ss);\n        \\<And>i j ss.\n           i < j + 1 \\<Longrightarrow>\n           lift (subst_bvs1' t2 j ss) i =\n           subst_bvs1' (lift t2 i) (j + 1) (map (\\<lambda>s. lift s i) ss);\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> lift (subst_bvs1' (t1 $ t2) j ss) i =\n                         subst_bvs1' (lift (t1 $ t2) i) (j + 1)\n                          (map (\\<lambda>s. lift s i) ss)", "qed auto"], ["", "lemma subst_bvs1'_subst_bv2:\n  \"i < j + 1 \\<Longrightarrow> \n    subst_bv2(subst_bvs1' t (Suc j) (map (\\<lambda>v. lift v i) vs)) i (subst_bvs1' u j vs) \n    = subst_bvs1' (subst_bv2 t i u) j vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j + 1 \\<Longrightarrow>\n    subst_bv2 (subst_bvs1' t (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n     (subst_bvs1' u j vs) =\n    subst_bvs1' (subst_bv2 t i u) j vs", "proof(induction t arbitrary: i j u vs)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j u vs.\n       i < j + 1 \\<Longrightarrow>\n       subst_bv2\n        (subst_bvs1' (Ct x1 x2) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n        (subst_bvs1' u j vs) =\n       subst_bvs1' (subst_bv2 (Ct x1 x2) i u) j vs\n 2. \\<And>x1 x2 i j u vs.\n       i < j + 1 \\<Longrightarrow>\n       subst_bv2\n        (subst_bvs1' (Fv x1 x2) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n        (subst_bvs1' u j vs) =\n       subst_bvs1' (subst_bv2 (Fv x1 x2) i u) j vs\n 3. \\<And>x i j u vs.\n       i < j + 1 \\<Longrightarrow>\n       subst_bv2\n        (subst_bvs1' (Bv x) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n        (subst_bvs1' u j vs) =\n       subst_bvs1' (subst_bv2 (Bv x) i u) j vs\n 4. \\<And>x1 t i j u vs.\n       \\<lbrakk>\\<And>i j u vs.\n                   i < j + 1 \\<Longrightarrow>\n                   subst_bv2\n                    (subst_bvs1' t (Suc j) (map (\\<lambda>v. lift v i) vs))\n                    i (subst_bvs1' u j vs) =\n                   subst_bvs1' (subst_bv2 t i u) j vs;\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> subst_bv2\n                          (subst_bvs1' (Abs x1 t) (Suc j)\n                            (map (\\<lambda>v. lift v i) vs))\n                          i (subst_bvs1' u j vs) =\n                         subst_bvs1' (subst_bv2 (Abs x1 t) i u) j vs\n 5. \\<And>t1 t2 i j u vs.\n       \\<lbrakk>\\<And>i j u vs.\n                   i < j + 1 \\<Longrightarrow>\n                   subst_bv2\n                    (subst_bvs1' t1 (Suc j) (map (\\<lambda>v. lift v i) vs))\n                    i (subst_bvs1' u j vs) =\n                   subst_bvs1' (subst_bv2 t1 i u) j vs;\n        \\<And>i j u vs.\n           i < j + 1 \\<Longrightarrow>\n           subst_bv2\n            (subst_bvs1' t2 (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n            (subst_bvs1' u j vs) =\n           subst_bvs1' (subst_bv2 t2 i u) j vs;\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> subst_bv2\n                          (subst_bvs1' (t1 $ t2) (Suc j)\n                            (map (\\<lambda>v. lift v i) vs))\n                          i (subst_bvs1' u j vs) =\n                         subst_bvs1' (subst_bv2 (t1 $ t2) i u) j vs", "case (Abs T t)"], ["proof (state)\nthis:\n  ?i < ?j + 1 \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' t (Suc ?j) (map (\\<lambda>v. lift v ?i) ?vs)) ?i\n   (subst_bvs1' ?u ?j ?vs) =\n  subst_bvs1' (subst_bv2 t ?i ?u) ?j ?vs\n  i < j + 1\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i j u vs.\n       i < j + 1 \\<Longrightarrow>\n       subst_bv2\n        (subst_bvs1' (Ct x1 x2) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n        (subst_bvs1' u j vs) =\n       subst_bvs1' (subst_bv2 (Ct x1 x2) i u) j vs\n 2. \\<And>x1 x2 i j u vs.\n       i < j + 1 \\<Longrightarrow>\n       subst_bv2\n        (subst_bvs1' (Fv x1 x2) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n        (subst_bvs1' u j vs) =\n       subst_bvs1' (subst_bv2 (Fv x1 x2) i u) j vs\n 3. \\<And>x i j u vs.\n       i < j + 1 \\<Longrightarrow>\n       subst_bv2\n        (subst_bvs1' (Bv x) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n        (subst_bvs1' u j vs) =\n       subst_bvs1' (subst_bv2 (Bv x) i u) j vs\n 4. \\<And>x1 t i j u vs.\n       \\<lbrakk>\\<And>i j u vs.\n                   i < j + 1 \\<Longrightarrow>\n                   subst_bv2\n                    (subst_bvs1' t (Suc j) (map (\\<lambda>v. lift v i) vs))\n                    i (subst_bvs1' u j vs) =\n                   subst_bvs1' (subst_bv2 t i u) j vs;\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> subst_bv2\n                          (subst_bvs1' (Abs x1 t) (Suc j)\n                            (map (\\<lambda>v. lift v i) vs))\n                          i (subst_bvs1' u j vs) =\n                         subst_bvs1' (subst_bv2 (Abs x1 t) i u) j vs\n 5. \\<And>t1 t2 i j u vs.\n       \\<lbrakk>\\<And>i j u vs.\n                   i < j + 1 \\<Longrightarrow>\n                   subst_bv2\n                    (subst_bvs1' t1 (Suc j) (map (\\<lambda>v. lift v i) vs))\n                    i (subst_bvs1' u j vs) =\n                   subst_bvs1' (subst_bv2 t1 i u) j vs;\n        \\<And>i j u vs.\n           i < j + 1 \\<Longrightarrow>\n           subst_bv2\n            (subst_bvs1' t2 (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n            (subst_bvs1' u j vs) =\n           subst_bvs1' (subst_bv2 t2 i u) j vs;\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> subst_bv2\n                          (subst_bvs1' (t1 $ t2) (Suc j)\n                            (map (\\<lambda>v. lift v i) vs))\n                          i (subst_bvs1' u j vs) =\n                         subst_bvs1' (subst_bv2 (t1 $ t2) i u) j vs", "then"], ["proof (chain)\npicking this:\n  ?i < ?j + 1 \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' t (Suc ?j) (map (\\<lambda>v. lift v ?i) ?vs)) ?i\n   (subst_bvs1' ?u ?j ?vs) =\n  subst_bvs1' (subst_bv2 t ?i ?u) ?j ?vs\n  i < j + 1", "show ?case"], ["proof (prove)\nusing this:\n  ?i < ?j + 1 \\<Longrightarrow>\n  subst_bv2 (subst_bvs1' t (Suc ?j) (map (\\<lambda>v. lift v ?i) ?vs)) ?i\n   (subst_bvs1' ?u ?j ?vs) =\n  subst_bvs1' (subst_bv2 t ?i ?u) ?j ?vs\n  i < j + 1\n\ngoal (1 subgoal):\n 1. subst_bv2\n     (subst_bvs1' (Abs T t) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n     (subst_bvs1' u j vs) =\n    subst_bvs1' (subst_bv2 (Abs T t) i u) j vs", "by simp (smt One_nat_def Suc_eq_plus1 Suc_less_eq comp_apply lift_lift lift_def\n        lift_subst_bvs1'_lt map_eq_conv map_map zero_less_Suc)"], ["proof (state)\nthis:\n  subst_bv2 (subst_bvs1' (Abs T t) (Suc j) (map (\\<lambda>v. lift v i) vs))\n   i (subst_bvs1' u j vs) =\n  subst_bvs1' (subst_bv2 (Abs T t) i u) j vs\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 i j u vs.\n       i < j + 1 \\<Longrightarrow>\n       subst_bv2\n        (subst_bvs1' (Ct x1 x2) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n        (subst_bvs1' u j vs) =\n       subst_bvs1' (subst_bv2 (Ct x1 x2) i u) j vs\n 2. \\<And>x1 x2 i j u vs.\n       i < j + 1 \\<Longrightarrow>\n       subst_bv2\n        (subst_bvs1' (Fv x1 x2) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n        (subst_bvs1' u j vs) =\n       subst_bvs1' (subst_bv2 (Fv x1 x2) i u) j vs\n 3. \\<And>x i j u vs.\n       i < j + 1 \\<Longrightarrow>\n       subst_bv2\n        (subst_bvs1' (Bv x) (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n        (subst_bvs1' u j vs) =\n       subst_bvs1' (subst_bv2 (Bv x) i u) j vs\n 4. \\<And>t1 t2 i j u vs.\n       \\<lbrakk>\\<And>i j u vs.\n                   i < j + 1 \\<Longrightarrow>\n                   subst_bv2\n                    (subst_bvs1' t1 (Suc j) (map (\\<lambda>v. lift v i) vs))\n                    i (subst_bvs1' u j vs) =\n                   subst_bvs1' (subst_bv2 t1 i u) j vs;\n        \\<And>i j u vs.\n           i < j + 1 \\<Longrightarrow>\n           subst_bv2\n            (subst_bvs1' t2 (Suc j) (map (\\<lambda>v. lift v i) vs)) i\n            (subst_bvs1' u j vs) =\n           subst_bvs1' (subst_bv2 t2 i u) j vs;\n        i < j + 1\\<rbrakk>\n       \\<Longrightarrow> subst_bv2\n                          (subst_bvs1' (t1 $ t2) (Suc j)\n                            (map (\\<lambda>v. lift v i) vs))\n                          i (subst_bvs1' u j vs) =\n                         subst_bvs1' (subst_bv2 (t1 $ t2) i u) j vs", "qed (use subst_bv2_lift in auto)"], ["", "lemma fv_subst_bv2_upper_bound: \"fv (subst_bv2 t lev u) \\<subseteq> fv t \\<union> fv u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (subst_bv2 t lev u) \\<subseteq> fv t \\<union> fv u", "by (induction t lev u rule: subst_bv2.induct) auto"], ["", "lemma beta_fv: \"s \\<rightarrow>\\<^sub>\\<beta> t \\<Longrightarrow> fv t \\<subseteq> fv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<rightarrow>\\<^sub>\\<beta> t \\<Longrightarrow> fv t \\<subseteq> fv s", "by (induction rule: beta.induct) (use fv_subst_bv2_upper_bound in auto)"], ["", "lemma loose_bvar1_subst_bvs1'_closeds: \"\\<not> loose_bvar1 t lev \\<Longrightarrow> lev < k \\<Longrightarrow> \\<forall>x\\<in>set us . is_closed x\n  \\<Longrightarrow> \\<not> loose_bvar1 (subst_bvs1' t k us) lev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> loose_bvar1 t lev; lev < k;\n     \\<forall>x\\<in>set us. is_closed x\\<rbrakk>\n    \\<Longrightarrow> \\<not> loose_bvar1 (subst_bvs1' t k us) lev", "by (induction t k us arbitrary: lev rule: subst_bvs1'.induct)\n    (use is_open_def loose_bvar_iff_exist_loose_bvar1 in \\<open>auto simp add: is_open_def\\<close>)"], ["", "lemma is_closed_subst_bvs1'_closeds: \"\\<not> is_dependent t \\<Longrightarrow> \\<forall>x\\<in>set us . is_closed x\n  \\<Longrightarrow> \\<not> is_dependent (subst_bvs1' t (Suc k) us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_dependent t;\n     \\<forall>x\\<in>set us. is_closed x\\<rbrakk>\n    \\<Longrightarrow> \\<not> is_dependent (subst_bvs1' t (Suc k) us)", "by (simp add: is_dependent_def loose_bvar1_subst_bvs1'_closeds)"], ["", "end"]]}