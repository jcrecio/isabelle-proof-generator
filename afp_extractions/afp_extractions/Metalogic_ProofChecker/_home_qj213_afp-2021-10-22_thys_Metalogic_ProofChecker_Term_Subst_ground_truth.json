{"file_name": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker/Term_Subst.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker", "problem_names": ["lemma subst_typ_nil[simp]: \"subst_typ [] T = T\"", "lemma subst_typ_irrelevant_order:\n  assumes \"distinct (map fst pairs)\" and \"distinct (map fst pairs')\" and \"set pairs = set pairs'\"\nshows \"subst_typ pairs T = subst_typ pairs' T\"", "lemma subst_typ_simulates_tsubstT_gen': \"distinct l \\<Longrightarrow> tvsT T \\<subseteq> set l \n  \\<Longrightarrow> tsubstT T \\<rho> = subst_typ (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) l) T\"", "lemma subst_typ_simulates_tsubstT_gen: \"tsubstT T \\<rho> \n  = subst_typ (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) (SOME l . distinct l \\<and> tvsT T \\<subseteq> set l)) T\"", "lemma tsubstT_simulates_subst_typ: \"subst_typ insts T\n  = tsubstT T (\\<lambda>idn S . the_default (Tv idn S) (lookup (\\<lambda>x. x=(idn, S)) insts))\"", "lemma subst_typ_comp: \n  \"subst_typ inst1 (subst_typ inst2 T) = subst_typ (map (apsnd (subst_typ inst1)) inst2 @ inst1) T\"", "lemma subst_typ_AList_clearjunk: \"subst_typ insts T = subst_typ (AList.clearjunk insts) T\"", "lemma subst_type_term_empty_no_change[simp]: \"subst_type_term [] [] t = t\"", "lemma subst_type_term_irrelevant_order:\n  assumes instT_assms: \"distinct (map fst instT)\" \"distinct (map fst instT')\" \"set instT = set instT'\"\n  assumes insts_assms: \"distinct (map fst insts)\" \"distinct (map fst insts')\" \"set insts = set insts'\"\nshows \"subst_type_term instT insts t = subst_type_term instT' insts' t\"", "lemma subst_type_term_simulates_subst_tsubst_gen':\n  assumes lty_assms: \"distinct lty\" \"tvs t \\<subseteq> set lty\"\n  assumes lt_assms: \"distinct lt\" \"fv (tsubst t \\<rho>ty) \\<subseteq> set lt\"\n  shows \"subst (tsubst t \\<rho>ty) \\<rho>t \n    = subst_type_term (map (\\<lambda>(x,y).((x,y), \\<rho>ty x y)) lty) (map (\\<lambda>(x,y).((x,y), \\<rho>t x y)) lt) t\"", "lemma subst_typ'_nil[simp]: \"subst_typ' [] A = A\"", "lemma subst_typ'_simulates_tsubst_gen': \"distinct pairs \\<Longrightarrow> tvs t \\<subseteq> set pairs\n  \\<Longrightarrow> tsubst t \\<rho> = subst_typ' (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) pairs) t\"", "lemma subst_typ'_simulates_tsubst_gen: \"tsubst t \\<rho> \n  = subst_typ' (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) (SOME l . distinct l \\<and> tvs t \\<subseteq> set l)) t\"", "lemma tsubst_simulates_subst_typ': \"subst_typ' insts T\n  = tsubst T (\\<lambda>idn S . the_default (Tv idn S) (lookup (\\<lambda>x. x=(idn, S)) insts))\"", "lemma subst_type_add_degenerate_instance: \n  \"(idx,s) \\<notin> set (map fst insts) \\<Longrightarrow> subst_typ insts T = subst_typ (((idx,s), Tv idx s)#insts) T\"", "lemma subst_typ'_add_degenerate_instance: \n  \"(idx,s) \\<notin> set (map fst insts) \\<Longrightarrow> subst_typ' insts t = subst_typ' (((idx,s), Tv idx s)#insts) t\"", "lemma subst_typ'_comp: \n  \"subst_typ' inst1 (subst_typ' inst2 t) = subst_typ' (map (apsnd (subst_typ inst1)) inst2 @ inst1) t\"", "lemma subst_typ'_AList_clearjunk: \"subst_typ' insts t = subst_typ' (AList.clearjunk insts) t\"", "lemma subst_term_empty_no_change[simp]: \"subst_term [] t = t\"", "lemma subst_type_term_without_type_insts_eq_subst_term[simp]: \n  \"subst_type_term [] insts t = subst_term insts t\"", "lemma subst_type_term_split_levels: \n  \"subst_type_term instT insts t = subst_term insts (subst_typ' instT t)\"", "lemma subst_typ_stepwise:\n  assumes \"distinct (map fst instT)\"\n  assumes \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` set instT . tvsT t) \\<Longrightarrow> x \\<notin> fst ` set instT\"\n  shows \"subst_typ instT T = fold (\\<lambda>single acc . subst_typ [single] acc) instT T\"", "lemma subst_typ'_stepwise:\n  assumes \"distinct (map fst instT)\"\n  assumes \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` (set instT) . tvsT t) \\<Longrightarrow> x \\<notin> fst ` (set instT)\"\n  shows \"subst_typ' instT t = fold (\\<lambda>single acc . subst_typ' [single] acc) instT t\"", "lemma subst_term_stepwise:\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` (set insts) . fv t) \\<Longrightarrow> x \\<notin> fst ` (set insts)\"\n  shows \"subst_term insts t = fold (\\<lambda>single acc . subst_term [single] acc) insts t\"", "lemma distinct_fst_imp_distinct: \"distinct (map fst l) \\<Longrightarrow> distinct l\"", "lemma distinct_kv_list: \"distinct l \\<Longrightarrow> distinct (map (\\<lambda>x. (x, f x)) l)\"", "lemma subst_subst_term: \n  assumes \"distinct l\" and \"fv t \\<subseteq> set l\"\n  shows \"subst t \\<rho> = subst_term (map (\\<lambda>x.(x, case_prod \\<rho> x)) l) t\"", "lemma subst_term_subst:\n  assumes \"distinct (map fst l)\"\n  shows \"subst_term l t = subst t (fold (\\<lambda>((idn, T), t) f x y. if x=idn \\<and>y=T then t else f x y) l Fv)\"", "lemma subst_typ_combine_single:\n  assumes \"fresh_idn \\<notin> fst ` tvsT \\<tau>\"\n  shows \"subst_typ [((fresh_idn, S), \\<tau>2)] (subst_typ [((idn, S), Tv fresh_idn S)] \\<tau>)\n    = subst_typ [((idn, S), \\<tau>2)] \\<tau>\"", "lemma subst_typ_combine:\n  assumes \"length fresh_idns = length insts\"\n  assumes \"distinct fresh_idns\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<forall>idn \\<in> set fresh_idns . idn \\<notin> fst ` (tvsT \\<tau> \\<union> (\\<Union>ty\\<in>snd ` set insts . (tvsT ty)) \n    \\<union> (fst ` set insts))\"\n  shows \"subst_typ insts \\<tau> \n    = subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (subst_typ (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>)\"", "lemma subst_typ_combine':\n  assumes \"length fresh_idns = length insts\"\n  assumes \"distinct fresh_idns\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<forall>idn \\<in> set fresh_idns . idn \\<notin> fst ` (tvsT \\<tau> \\<union> (\\<Union>ty\\<in>snd ` set insts . (tvsT ty)) \n    \\<union> (fst ` set insts))\"\n  shows \"subst_typ insts \\<tau> \n    = fold (\\<lambda>single acc . subst_typ [single] acc) (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (fold (\\<lambda>single acc . subst_typ [single] acc) (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>)\"", "lemma subst_typ'_combine:\n  assumes \"length fresh_idns = length insts\"\n  assumes \"distinct fresh_idns\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<forall>idn \\<in> set fresh_idns . idn \\<notin> fst ` (tvs t \\<union> (\\<Union>ty\\<in>snd ` set insts . (tvsT ty)) \n    \\<union> (fst ` set insts))\"\n  shows \"subst_typ' insts t\n    = subst_typ' (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (subst_typ' (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t)\"", "lemma subst_term_combine:\n  assumes \"length fresh_idns = length insts\"\n  assumes \"distinct fresh_idns\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<forall>idn \\<in> set fresh_idns . idn \\<notin> fst ` (fv t \\<union> (\\<Union>t\\<in>snd ` set insts . (fv t)) \n    \\<union> (fst ` set insts))\"\n  shows \"subst_term insts t\n    = subst_term (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (subst_term (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\"", "lemma subst_term_not_loose_bvar:\n  assumes \"\\<not> loose_bvar t n\" \"is_closed b\" \n  shows \"\\<not> loose_bvar (subst_term [((idn,T),b)] t) n\"", "lemma bind_fv2_subst_bv1_eq_subst_term: \n  assumes \"\\<not>loose_bvar t n\" \"is_closed b\"\n  shows \"subst_term [((idn,T),b)] t = subst_bv1 (bind_fv2 (idn, T) n t) n b\"", "lemma instantiate_vars_same_typ:\n  assumes typs: \"list_all (\\<lambda>((idx, ty), t) . typ_of t = Some ty) insts\"\n  assumes closed_B: \"\\<not> loose_bvar B lev\"\n  shows \"fold (\\<lambda>((idx, ty), t) B . subst_bv1 (bind_fv2 (idx, ty) lev B) lev t) insts B\n    = fold (\\<lambda>single . subst_term [single]) insts B\""], "translations": [["", "lemma subst_typ_nil[simp]: \"subst_typ [] T = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [] T = T", "by (induction T) (auto simp add: map_idI)"], ["", "lemma subst_typ_irrelevant_order:\n  assumes \"distinct (map fst pairs)\" and \"distinct (map fst pairs')\" and \"set pairs = set pairs'\"\nshows \"subst_typ pairs T = subst_typ pairs' T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ pairs T = subst_typ pairs' T", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst pairs)\n  distinct (map fst pairs')\n  set pairs = set pairs'\n\ngoal (1 subgoal):\n 1. subst_typ pairs T = subst_typ pairs' T", "proof(induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; distinct (map fst pairs);\n                    distinct (map fst pairs');\n                    set pairs = set pairs'\\<rbrakk>\n                   \\<Longrightarrow> subst_typ pairs x2a =\n                                     subst_typ pairs' x2a;\n        distinct (map fst pairs); distinct (map fst pairs');\n        set pairs = set pairs'\\<rbrakk>\n       \\<Longrightarrow> subst_typ pairs (Ty x1 x2) =\n                         subst_typ pairs' (Ty x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst pairs); distinct (map fst pairs');\n        set pairs = set pairs'\\<rbrakk>\n       \\<Longrightarrow> subst_typ pairs (Tv x1 x2) =\n                         subst_typ pairs' (Tv x1 x2)", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; distinct (map fst pairs);\n   distinct (map fst pairs'); set pairs = set pairs'\\<rbrakk>\n  \\<Longrightarrow> subst_typ pairs ?x2a = subst_typ pairs' ?x2a\n  distinct (map fst pairs)\n  distinct (map fst pairs')\n  set pairs = set pairs'\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; distinct (map fst pairs);\n                    distinct (map fst pairs');\n                    set pairs = set pairs'\\<rbrakk>\n                   \\<Longrightarrow> subst_typ pairs x2a =\n                                     subst_typ pairs' x2a;\n        distinct (map fst pairs); distinct (map fst pairs');\n        set pairs = set pairs'\\<rbrakk>\n       \\<Longrightarrow> subst_typ pairs (Ty x1 x2) =\n                         subst_typ pairs' (Ty x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst pairs); distinct (map fst pairs');\n        set pairs = set pairs'\\<rbrakk>\n       \\<Longrightarrow> subst_typ pairs (Tv x1 x2) =\n                         subst_typ pairs' (Tv x1 x2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts; distinct (map fst pairs);\n   distinct (map fst pairs'); set pairs = set pairs'\\<rbrakk>\n  \\<Longrightarrow> subst_typ pairs ?x2a = subst_typ pairs' ?x2a\n  distinct (map fst pairs)\n  distinct (map fst pairs')\n  set pairs = set pairs'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts; distinct (map fst pairs);\n   distinct (map fst pairs'); set pairs = set pairs'\\<rbrakk>\n  \\<Longrightarrow> subst_typ pairs ?x2a = subst_typ pairs' ?x2a\n  distinct (map fst pairs)\n  distinct (map fst pairs')\n  set pairs = set pairs'\n\ngoal (1 subgoal):\n 1. subst_typ pairs (Ty n Ts) = subst_typ pairs' (Ty n Ts)", "by (induction Ts) auto"], ["proof (state)\nthis:\n  subst_typ pairs (Ty n Ts) = subst_typ pairs' (Ty n Ts)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst pairs); distinct (map fst pairs');\n        set pairs = set pairs'\\<rbrakk>\n       \\<Longrightarrow> subst_typ pairs (Tv x1 x2) =\n                         subst_typ pairs' (Tv x1 x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst pairs); distinct (map fst pairs');\n        set pairs = set pairs'\\<rbrakk>\n       \\<Longrightarrow> subst_typ pairs (Tv x1 x2) =\n                         subst_typ pairs' (Tv x1 x2)", "case (Tv idn S)"], ["proof (state)\nthis:\n  distinct (map fst pairs)\n  distinct (map fst pairs')\n  set pairs = set pairs'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst pairs); distinct (map fst pairs');\n        set pairs = set pairs'\\<rbrakk>\n       \\<Longrightarrow> subst_typ pairs (Tv x1 x2) =\n                         subst_typ pairs' (Tv x1 x2)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst pairs)\n  distinct (map fst pairs')\n  set pairs = set pairs'", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst pairs)\n  distinct (map fst pairs')\n  set pairs = set pairs'\n\ngoal (1 subgoal):\n 1. subst_typ pairs (Tv idn S) = subst_typ pairs' (Tv idn S)", "using lookup_eq_order_irrelevant"], ["proof (prove)\nusing this:\n  distinct (map fst pairs)\n  distinct (map fst pairs')\n  set pairs = set pairs'\n  \\<lbrakk>distinct (map fst ?pairs); distinct (map fst ?pairs');\n   set ?pairs = set ?pairs'\\<rbrakk>\n  \\<Longrightarrow> lookup (\\<lambda>x. x = ?k) ?pairs =\n                    lookup (\\<lambda>x. x = ?k) ?pairs'\n\ngoal (1 subgoal):\n 1. subst_typ pairs (Tv idn S) = subst_typ pairs' (Tv idn S)", "by (metis subst_typ.simps(2))"], ["proof (state)\nthis:\n  subst_typ pairs (Tv idn S) = subst_typ pairs' (Tv idn S)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Core lemma, Isabelle/Pure's instantiateT_same function can simulate abstract type subtitutions \n  in types *)"], ["", "lemma subst_typ_simulates_tsubstT_gen': \"distinct l \\<Longrightarrow> tvsT T \\<subseteq> set l \n  \\<Longrightarrow> tsubstT T \\<rho> = subst_typ (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) l) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct l; tvsT T \\<subseteq> set l\\<rbrakk>\n    \\<Longrightarrow> tsubstT T \\<rho> =\n                      subst_typ\n                       (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l) T", "proof(induction T arbitrary: l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>\\<And>x2a l.\n                   \\<lbrakk>x2a \\<in> set x2; distinct l;\n                    tvsT x2a \\<subseteq> set l\\<rbrakk>\n                   \\<Longrightarrow> tsubstT x2a \\<rho> =\n                                     subst_typ\n(map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l) x2a;\n        distinct l; tvsT (Ty x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Ty x1 x2) \\<rho> =\n                         subst_typ\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l)\n                          (Ty x1 x2)\n 2. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; tvsT (Tv x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Tv x1 x2) \\<rho> =\n                         subst_typ\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l)\n                          (Tv x1 x2)", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; distinct ?l;\n   tvsT ?x2a \\<subseteq> set ?l\\<rbrakk>\n  \\<Longrightarrow> tsubstT ?x2a \\<rho> =\n                    subst_typ\n                     (map (\\<lambda>a.\n                              case a of\n                              (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n                       ?l)\n                     ?x2a\n  distinct l\n  tvsT (Ty n Ts) \\<subseteq> set l\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>\\<And>x2a l.\n                   \\<lbrakk>x2a \\<in> set x2; distinct l;\n                    tvsT x2a \\<subseteq> set l\\<rbrakk>\n                   \\<Longrightarrow> tsubstT x2a \\<rho> =\n                                     subst_typ\n(map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l) x2a;\n        distinct l; tvsT (Ty x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Ty x1 x2) \\<rho> =\n                         subst_typ\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l)\n                          (Ty x1 x2)\n 2. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; tvsT (Tv x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Tv x1 x2) \\<rho> =\n                         subst_typ\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l)\n                          (Tv x1 x2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts; distinct ?l;\n   tvsT ?x2a \\<subseteq> set ?l\\<rbrakk>\n  \\<Longrightarrow> tsubstT ?x2a \\<rho> =\n                    subst_typ\n                     (map (\\<lambda>a.\n                              case a of\n                              (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n                       ?l)\n                     ?x2a\n  distinct l\n  tvsT (Ty n Ts) \\<subseteq> set l", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts; distinct ?l;\n   tvsT ?x2a \\<subseteq> set ?l\\<rbrakk>\n  \\<Longrightarrow> tsubstT ?x2a \\<rho> =\n                    subst_typ\n                     (map (\\<lambda>a.\n                              case a of\n                              (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n                       ?l)\n                     ?x2a\n  distinct l\n  tvsT (Ty n Ts) \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. tsubstT (Ty n Ts) \\<rho> =\n    subst_typ\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n       l)\n     (Ty n Ts)", "by (induction Ts) auto"], ["proof (state)\nthis:\n  tsubstT (Ty n Ts) \\<rho> =\n  subst_typ\n   (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y)) l)\n   (Ty n Ts)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; tvsT (Tv x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Tv x1 x2) \\<rho> =\n                         subst_typ\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l)\n                          (Tv x1 x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; tvsT (Tv x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Tv x1 x2) \\<rho> =\n                         subst_typ\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l)\n                          (Tv x1 x2)", "case (Tv idn S)"], ["proof (state)\nthis:\n  distinct l\n  tvsT (Tv idn S) \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; tvsT (Tv x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Tv x1 x2) \\<rho> =\n                         subst_typ\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l)\n                          (Tv x1 x2)", "hence d: \"distinct (map fst (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) l))\""], ["proof (prove)\nusing this:\n  distinct l\n  tvsT (Tv idn S) \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l))", "by (simp add: case_prod_beta map_idI)"], ["proof (state)\nthis:\n  distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; tvsT (Tv x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Tv x1 x2) \\<rho> =\n                         subst_typ\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l)\n                          (Tv x1 x2)", "hence el: \"((idn,S), \\<rho> idn S) \\<in> set (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y)) l)\""], ["proof (prove)\nusing this:\n  distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l))\n\ngoal (1 subgoal):\n 1. ((idn, S), \\<rho> idn S)\n    \\<in> set (map (\\<lambda>a.\n                       case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n                l)", "using Tv"], ["proof (prove)\nusing this:\n  distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l))\n  distinct l\n  tvsT (Tv idn S) \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. ((idn, S), \\<rho> idn S)\n    \\<in> set (map (\\<lambda>a.\n                       case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n                l)", "by auto"], ["proof (state)\nthis:\n  ((idn, S), \\<rho> idn S)\n  \\<in> set (map (\\<lambda>a.\n                     case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n              l)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; tvsT (Tv x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Tv x1 x2) \\<rho> =\n                         subst_typ\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l)\n                          (Tv x1 x2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. tsubstT (Tv idn S) \\<rho> =\n    subst_typ\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n       l)\n     (Tv idn S)", "using iffD1[OF lookup_present_eq_key, OF _ el]  Tv.prems d"], ["proof (prove)\nusing this:\n  distinct\n   (map fst\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n       l)) \\<Longrightarrow>\n  lookup (\\<lambda>x. x = (idn, S))\n   (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n     l) =\n  Some (\\<rho> idn S)\n  distinct l\n  tvsT (Tv idn S) \\<subseteq> set l\n  distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) l))\n\ngoal (1 subgoal):\n 1. tsubstT (Tv idn S) \\<rho> =\n    subst_typ\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n       l)\n     (Tv idn S)", "by auto"], ["proof (state)\nthis:\n  tsubstT (Tv idn S) \\<rho> =\n  subst_typ\n   (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y)) l)\n   (Tv idn S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_typ_simulates_tsubstT_gen: \"tsubstT T \\<rho> \n  = subst_typ (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) (SOME l . distinct l \\<and> tvsT T \\<subseteq> set l)) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tsubstT T \\<rho> =\n    subst_typ\n     (map (\\<lambda>(x, y). ((x, y), \\<rho> x y))\n       (SOME l. distinct l \\<and> tvsT T \\<subseteq> set l))\n     T", "proof(rule someI2_ex)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a. distinct a \\<and> tvsT T \\<subseteq> set a\n 2. \\<And>x.\n       distinct x \\<and> tvsT T \\<subseteq> set x \\<Longrightarrow>\n       tsubstT T \\<rho> =\n       subst_typ\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        T", "show \"\\<exists>a. distinct a \\<and> tvsT T \\<subseteq> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. distinct a \\<and> tvsT T \\<subseteq> set a", "using finite_tvsT finite_distinct_list"], ["proof (prove)\nusing this:\n  finite (tvsT ?T)\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>a. distinct a \\<and> tvsT T \\<subseteq> set a", "by (metis order_refl)"], ["proof (state)\nthis:\n  \\<exists>a. distinct a \\<and> tvsT T \\<subseteq> set a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> tvsT T \\<subseteq> set x \\<Longrightarrow>\n       tsubstT T \\<rho> =\n       subst_typ\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> tvsT T \\<subseteq> set x \\<Longrightarrow>\n       tsubstT T \\<rho> =\n       subst_typ\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        T", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> tvsT T \\<subseteq> set x \\<Longrightarrow>\n       tsubstT T \\<rho> =\n       subst_typ\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        T", "assume l: \"distinct l \\<and> tvsT T \\<subseteq> set l\""], ["proof (state)\nthis:\n  distinct l \\<and> tvsT T \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> tvsT T \\<subseteq> set x \\<Longrightarrow>\n       tsubstT T \\<rho> =\n       subst_typ\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        T", "then"], ["proof (chain)\npicking this:\n  distinct l \\<and> tvsT T \\<subseteq> set l", "show \"tsubstT T \\<rho> = subst_typ (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y)) l) T\""], ["proof (prove)\nusing this:\n  distinct l \\<and> tvsT T \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. tsubstT T \\<rho> =\n    subst_typ\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n       l)\n     T", "using subst_typ_simulates_tsubstT_gen'"], ["proof (prove)\nusing this:\n  distinct l \\<and> tvsT T \\<subseteq> set l\n  \\<lbrakk>distinct ?l; tvsT ?T \\<subseteq> set ?l\\<rbrakk>\n  \\<Longrightarrow> tsubstT ?T ?\\<rho> =\n                    subst_typ\n                     (map (\\<lambda>(x, y). ((x, y), ?\\<rho> x y)) ?l) ?T\n\ngoal (1 subgoal):\n 1. tsubstT T \\<rho> =\n    subst_typ\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n       l)\n     T", "by blast"], ["proof (state)\nthis:\n  tsubstT T \\<rho> =\n  subst_typ\n   (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y)) l)\n   T\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_typ_simulates_tsubstT: \"tsubstT T \\<rho> \n  = subst_typ (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) (SOME l . distinct l \\<and> set l = tvsT T)) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tsubstT T \\<rho> =\n    subst_typ\n     (map (\\<lambda>(x, y). ((x, y), \\<rho> x y))\n       (SOME l. distinct l \\<and> set l = tvsT T))\n     T", "apply (rule someI2_ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>a. distinct a \\<and> set a = tvsT T\n 2. \\<And>x.\n       distinct x \\<and> set x = tvsT T \\<Longrightarrow>\n       tsubstT T \\<rho> =\n       subst_typ\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        T", "using finite_tvsT finite_distinct_list"], ["proof (prove)\nusing this:\n  finite (tvsT ?T)\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n\ngoal (2 subgoals):\n 1. \\<exists>a. distinct a \\<and> set a = tvsT T\n 2. \\<And>x.\n       distinct x \\<and> set x = tvsT T \\<Longrightarrow>\n       tsubstT T \\<rho> =\n       subst_typ\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        T", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> set x = tvsT T \\<Longrightarrow>\n       tsubstT T \\<rho> =\n       subst_typ\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        T", "using subst_typ_simulates_tsubstT_gen'"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?l; tvsT ?T \\<subseteq> set ?l\\<rbrakk>\n  \\<Longrightarrow> tsubstT ?T ?\\<rho> =\n                    subst_typ\n                     (map (\\<lambda>(x, y). ((x, y), ?\\<rho> x y)) ?l) ?T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> set x = tvsT T \\<Longrightarrow>\n       tsubstT T \\<rho> =\n       subst_typ\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        T", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Other direction, can construct a abstract substitution for one performed by instantiateT_same *)"], ["", "lemma tsubstT_simulates_subst_typ: \"subst_typ insts T\n  = tsubstT T (\\<lambda>idn S . the_default (Tv idn S) (lookup (\\<lambda>x. x=(idn, S)) insts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ insts T =\n    tsubstT T\n     (\\<lambda>idn S.\n         the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))", "by (induction T) auto"], ["", "(* Somewhat janky version of \"composition\" for subst_typ *)"], ["", "lemma subst_typ_comp: \n  \"subst_typ inst1 (subst_typ inst2 T) = subst_typ (map (apsnd (subst_typ inst1)) inst2 @ inst1) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ inst1 (subst_typ inst2 T) =\n    subst_typ (map (apsnd (subst_typ inst1)) inst2 @ inst1) T", "proof (induction inst2 T arbitrary: inst1 rule: subst_typ.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>insts a Ts inst1.\n       (\\<And>x inst1.\n           x \\<in> set Ts \\<Longrightarrow>\n           subst_typ inst1 (subst_typ insts x) =\n           subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1)\n            x) \\<Longrightarrow>\n       subst_typ inst1 (subst_typ insts (Ty a Ts)) =\n       subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Ty a Ts)\n 2. \\<And>insts idn S inst1.\n       subst_typ inst1 (subst_typ insts (Tv idn S)) =\n       subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Tv idn S)", "case (1 insts a Ts)"], ["proof (state)\nthis:\n  ?x \\<in> set Ts \\<Longrightarrow>\n  subst_typ ?inst1.0 (subst_typ insts ?x) =\n  subst_typ (map (apsnd (subst_typ ?inst1.0)) insts @ ?inst1.0) ?x\n\ngoal (2 subgoals):\n 1. \\<And>insts a Ts inst1.\n       (\\<And>x inst1.\n           x \\<in> set Ts \\<Longrightarrow>\n           subst_typ inst1 (subst_typ insts x) =\n           subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1)\n            x) \\<Longrightarrow>\n       subst_typ inst1 (subst_typ insts (Ty a Ts)) =\n       subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Ty a Ts)\n 2. \\<And>insts idn S inst1.\n       subst_typ inst1 (subst_typ insts (Tv idn S)) =\n       subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Tv idn S)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> set Ts \\<Longrightarrow>\n  subst_typ ?inst1.0 (subst_typ insts ?x) =\n  subst_typ (map (apsnd (subst_typ ?inst1.0)) insts @ ?inst1.0) ?x", "show ?case"], ["proof (prove)\nusing this:\n  ?x \\<in> set Ts \\<Longrightarrow>\n  subst_typ ?inst1.0 (subst_typ insts ?x) =\n  subst_typ (map (apsnd (subst_typ ?inst1.0)) insts @ ?inst1.0) ?x\n\ngoal (1 subgoal):\n 1. subst_typ inst1 (subst_typ insts (Ty a Ts)) =\n    subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Ty a Ts)", "by auto"], ["proof (state)\nthis:\n  subst_typ inst1 (subst_typ insts (Ty a Ts)) =\n  subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Ty a Ts)\n\ngoal (1 subgoal):\n 1. \\<And>insts idn S inst1.\n       subst_typ inst1 (subst_typ insts (Tv idn S)) =\n       subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Tv idn S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>insts idn S inst1.\n       subst_typ inst1 (subst_typ insts (Tv idn S)) =\n       subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Tv idn S)", "case (2 insts idn S)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>insts idn S inst1.\n       subst_typ inst1 (subst_typ insts (Tv idn S)) =\n       subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Tv idn S)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ inst1 (subst_typ insts (Tv idn S)) =\n    subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Tv idn S)", "by (induction insts) auto"], ["proof (state)\nthis:\n  subst_typ inst1 (subst_typ insts (Tv idn S)) =\n  subst_typ (map (apsnd (subst_typ inst1)) insts @ inst1) (Tv idn S)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* To make insts distinct again *)"], ["", "lemma subst_typ_AList_clearjunk: \"subst_typ insts T = subst_typ (AList.clearjunk insts) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ insts T = subst_typ (AList.clearjunk insts) T", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           subst_typ insts x2a =\n           subst_typ (AList.clearjunk insts) x2a) \\<Longrightarrow>\n       subst_typ insts (Ty x1 x2) =\n       subst_typ (AList.clearjunk insts) (Ty x1 x2)\n 2. \\<And>x1 x2.\n       subst_typ insts (Tv x1 x2) =\n       subst_typ (AList.clearjunk insts) (Tv x1 x2)", "case (Ty n Ts)"], ["proof (state)\nthis:\n  ?x2a \\<in> set Ts \\<Longrightarrow>\n  subst_typ insts ?x2a = subst_typ (AList.clearjunk insts) ?x2a\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           subst_typ insts x2a =\n           subst_typ (AList.clearjunk insts) x2a) \\<Longrightarrow>\n       subst_typ insts (Ty x1 x2) =\n       subst_typ (AList.clearjunk insts) (Ty x1 x2)\n 2. \\<And>x1 x2.\n       subst_typ insts (Tv x1 x2) =\n       subst_typ (AList.clearjunk insts) (Tv x1 x2)", "then"], ["proof (chain)\npicking this:\n  ?x2a \\<in> set Ts \\<Longrightarrow>\n  subst_typ insts ?x2a = subst_typ (AList.clearjunk insts) ?x2a", "show ?case"], ["proof (prove)\nusing this:\n  ?x2a \\<in> set Ts \\<Longrightarrow>\n  subst_typ insts ?x2a = subst_typ (AList.clearjunk insts) ?x2a\n\ngoal (1 subgoal):\n 1. subst_typ insts (Ty n Ts) = subst_typ (AList.clearjunk insts) (Ty n Ts)", "by auto"], ["proof (state)\nthis:\n  subst_typ insts (Ty n Ts) = subst_typ (AList.clearjunk insts) (Ty n Ts)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       subst_typ insts (Tv x1 x2) =\n       subst_typ (AList.clearjunk insts) (Tv x1 x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       subst_typ insts (Tv x1 x2) =\n       subst_typ (AList.clearjunk insts) (Tv x1 x2)", "case (Tv n S)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       subst_typ insts (Tv x1 x2) =\n       subst_typ (AList.clearjunk insts) (Tv x1 x2)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ insts (Tv n S) = subst_typ (AList.clearjunk insts) (Tv n S)", "proof(induction insts)"], ["proof (state)\ngoal (2 subgoals):\n 1. subst_typ [] (Tv n S) = subst_typ (AList.clearjunk []) (Tv n S)\n 2. \\<And>a insts.\n       subst_typ insts (Tv n S) =\n       subst_typ (AList.clearjunk insts) (Tv n S) \\<Longrightarrow>\n       subst_typ (a # insts) (Tv n S) =\n       subst_typ (AList.clearjunk (a # insts)) (Tv n S)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. subst_typ [] (Tv n S) = subst_typ (AList.clearjunk []) (Tv n S)\n 2. \\<And>a insts.\n       subst_typ insts (Tv n S) =\n       subst_typ (AList.clearjunk insts) (Tv n S) \\<Longrightarrow>\n       subst_typ (a # insts) (Tv n S) =\n       subst_typ (AList.clearjunk (a # insts)) (Tv n S)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [] (Tv n S) = subst_typ (AList.clearjunk []) (Tv n S)", "by auto"], ["proof (state)\nthis:\n  subst_typ [] (Tv n S) = subst_typ (AList.clearjunk []) (Tv n S)\n\ngoal (1 subgoal):\n 1. \\<And>a insts.\n       subst_typ insts (Tv n S) =\n       subst_typ (AList.clearjunk insts) (Tv n S) \\<Longrightarrow>\n       subst_typ (a # insts) (Tv n S) =\n       subst_typ (AList.clearjunk (a # insts)) (Tv n S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a insts.\n       subst_typ insts (Tv n S) =\n       subst_typ (AList.clearjunk insts) (Tv n S) \\<Longrightarrow>\n       subst_typ (a # insts) (Tv n S) =\n       subst_typ (AList.clearjunk (a # insts)) (Tv n S)", "case (Cons inst insts)"], ["proof (state)\nthis:\n  subst_typ insts (Tv n S) = subst_typ (AList.clearjunk insts) (Tv n S)\n\ngoal (1 subgoal):\n 1. \\<And>a insts.\n       subst_typ insts (Tv n S) =\n       subst_typ (AList.clearjunk insts) (Tv n S) \\<Longrightarrow>\n       subst_typ (a # insts) (Tv n S) =\n       subst_typ (AList.clearjunk (a # insts)) (Tv n S)", "then"], ["proof (chain)\npicking this:\n  subst_typ insts (Tv n S) = subst_typ (AList.clearjunk insts) (Tv n S)", "show ?case"], ["proof (prove)\nusing this:\n  subst_typ insts (Tv n S) = subst_typ (AList.clearjunk insts) (Tv n S)\n\ngoal (1 subgoal):\n 1. subst_typ (inst # insts) (Tv n S) =\n    subst_typ (AList.clearjunk (inst # insts)) (Tv n S)", "by simp (metis clearjunk.simps(2) lookup_AList_clearjunk)"], ["proof (state)\nthis:\n  subst_typ (inst # insts) (Tv n S) =\n  subst_typ (AList.clearjunk (inst # insts)) (Tv n S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_typ insts (Tv n S) = subst_typ (AList.clearjunk insts) (Tv n S)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun subst_type_term :: \"((variable \\<times> sort) \\<times> typ) list \\<Rightarrow> \n    ((variable \\<times> typ) \\<times> term) list \\<Rightarrow> term \\<Rightarrow> term\" where\n  \"subst_type_term instT insts (Ct c T) = Ct c (subst_typ instT T)\"\n| \"subst_type_term instT insts (Fv idn T) = (let T' = subst_typ instT T in\n    the_default (Fv idn T') (lookup (\\<lambda>x. x = (idn, T')) insts))\"\n| \"subst_type_term _ _ (Bv n) = Bv n\"\n| \"subst_type_term instT insts (Abs T t) = Abs (subst_typ instT T) (subst_type_term instT insts t)\"\n| \"subst_type_term instT insts (t $ u) = subst_type_term instT insts t $ subst_type_term instT insts u\""], ["", "lemma subst_type_term_empty_no_change[simp]: \"subst_type_term [] [] t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_type_term [] [] t = t", "by (induction t) (simp_all add:)"], ["", "lemma subst_type_term_irrelevant_order:\n  assumes instT_assms: \"distinct (map fst instT)\" \"distinct (map fst instT')\" \"set instT = set instT'\"\n  assumes insts_assms: \"distinct (map fst insts)\" \"distinct (map fst insts')\" \"set insts = set insts'\"\nshows \"subst_type_term instT insts t = subst_type_term instT' insts' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_type_term instT insts t = subst_type_term instT' insts' t", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst instT)\n  distinct (map fst instT')\n  set instT = set instT'\n  distinct (map fst insts)\n  distinct (map fst insts')\n  set insts = set insts'\n\ngoal (1 subgoal):\n 1. subst_type_term instT insts t = subst_type_term instT' insts' t", "proof(induction t)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Ct x1 x2) =\n                         subst_type_term instT' insts' (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Fv x1 x2) =\n                         subst_type_term instT' insts' (Fv x1 x2)\n 3. \\<And>x.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Bv x) =\n                         subst_type_term instT' insts' (Bv x)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t =\n                                  subst_type_term instT' insts' t;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Abs x1 t) =\n                         subst_type_term instT' insts' (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t1 =\n                                  subst_type_term instT' insts' t1;\n        \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n         set instT = set instT'; distinct (map fst insts);\n         distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n        \\<Longrightarrow> subst_type_term instT insts t2 =\n                          subst_type_term instT' insts' t2;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (t1 $ t2) =\n                         subst_type_term instT' insts' (t1 $ t2)", "case (Fv idn T)"], ["proof (state)\nthis:\n  distinct (map fst instT)\n  distinct (map fst instT')\n  set instT = set instT'\n  distinct (map fst insts)\n  distinct (map fst insts')\n  set insts = set insts'\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Ct x1 x2) =\n                         subst_type_term instT' insts' (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Fv x1 x2) =\n                         subst_type_term instT' insts' (Fv x1 x2)\n 3. \\<And>x.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Bv x) =\n                         subst_type_term instT' insts' (Bv x)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t =\n                                  subst_type_term instT' insts' t;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Abs x1 t) =\n                         subst_type_term instT' insts' (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t1 =\n                                  subst_type_term instT' insts' t1;\n        \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n         set instT = set instT'; distinct (map fst insts);\n         distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n        \\<Longrightarrow> subst_type_term instT insts t2 =\n                          subst_type_term instT' insts' t2;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (t1 $ t2) =\n                         subst_type_term instT' insts' (t1 $ t2)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst instT)\n  distinct (map fst instT')\n  set instT = set instT'\n  distinct (map fst insts)\n  distinct (map fst insts')\n  set insts = set insts'", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst instT)\n  distinct (map fst instT')\n  set instT = set instT'\n  distinct (map fst insts)\n  distinct (map fst insts')\n  set insts = set insts'\n\ngoal (1 subgoal):\n 1. subst_type_term instT insts (Fv idn T) =\n    subst_type_term instT' insts' (Fv idn T)", "apply (simp add: Let_def subst_typ_irrelevant_order[OF Fv.prems(1-3)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n     set instT = set instT'; distinct (map fst insts);\n     distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n    \\<Longrightarrow> the_default (Fv idn (subst_typ instT' T))\n                       (lookup (\\<lambda>x. x = (idn, subst_typ instT' T))\n                         insts) =\n                      the_default (Fv idn (subst_typ instT' T))\n                       (lookup (\\<lambda>x. x = (idn, subst_typ instT' T))\n                         insts')", "using lookup_eq_order_irrelevant"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst ?pairs); distinct (map fst ?pairs');\n   set ?pairs = set ?pairs'\\<rbrakk>\n  \\<Longrightarrow> lookup (\\<lambda>x. x = ?k) ?pairs =\n                    lookup (\\<lambda>x. x = ?k) ?pairs'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n     set instT = set instT'; distinct (map fst insts);\n     distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n    \\<Longrightarrow> the_default (Fv idn (subst_typ instT' T))\n                       (lookup (\\<lambda>x. x = (idn, subst_typ instT' T))\n                         insts) =\n                      the_default (Fv idn (subst_typ instT' T))\n                       (lookup (\\<lambda>x. x = (idn, subst_typ instT' T))\n                         insts')", "by (metis Fv.prems(4) Fv.prems(5) insts_assms)"], ["proof (state)\nthis:\n  subst_type_term instT insts (Fv idn T) =\n  subst_type_term instT' insts' (Fv idn T)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Ct x1 x2) =\n                         subst_type_term instT' insts' (Ct x1 x2)\n 2. \\<And>x.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Bv x) =\n                         subst_type_term instT' insts' (Bv x)\n 3. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t =\n                                  subst_type_term instT' insts' t;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Abs x1 t) =\n                         subst_type_term instT' insts' (Abs x1 t)\n 4. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t1 =\n                                  subst_type_term instT' insts' t1;\n        \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n         set instT = set instT'; distinct (map fst insts);\n         distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n        \\<Longrightarrow> subst_type_term instT insts t2 =\n                          subst_type_term instT' insts' t2;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (t1 $ t2) =\n                         subst_type_term instT' insts' (t1 $ t2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Ct x1 x2) =\n                         subst_type_term instT' insts' (Ct x1 x2)\n 2. \\<And>x.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Bv x) =\n                         subst_type_term instT' insts' (Bv x)\n 3. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t =\n                                  subst_type_term instT' insts' t;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Abs x1 t) =\n                         subst_type_term instT' insts' (Abs x1 t)\n 4. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t1 =\n                                  subst_type_term instT' insts' t1;\n        \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n         set instT = set instT'; distinct (map fst insts);\n         distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n        \\<Longrightarrow> subst_type_term instT insts t2 =\n                          subst_type_term instT' insts' t2;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (t1 $ t2) =\n                         subst_type_term instT' insts' (t1 $ t2)", "case (Abs T t)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n   set instT = set instT'; distinct (map fst insts);\n   distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n  \\<Longrightarrow> subst_type_term instT insts t =\n                    subst_type_term instT' insts' t\n  distinct (map fst instT)\n  distinct (map fst instT')\n  set instT = set instT'\n  distinct (map fst insts)\n  distinct (map fst insts')\n  set insts = set insts'\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Ct x1 x2) =\n                         subst_type_term instT' insts' (Ct x1 x2)\n 2. \\<And>x.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Bv x) =\n                         subst_type_term instT' insts' (Bv x)\n 3. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t =\n                                  subst_type_term instT' insts' t;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Abs x1 t) =\n                         subst_type_term instT' insts' (Abs x1 t)\n 4. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t1 =\n                                  subst_type_term instT' insts' t1;\n        \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n         set instT = set instT'; distinct (map fst insts);\n         distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n        \\<Longrightarrow> subst_type_term instT insts t2 =\n                          subst_type_term instT' insts' t2;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (t1 $ t2) =\n                         subst_type_term instT' insts' (t1 $ t2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n   set instT = set instT'; distinct (map fst insts);\n   distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n  \\<Longrightarrow> subst_type_term instT insts t =\n                    subst_type_term instT' insts' t\n  distinct (map fst instT)\n  distinct (map fst instT')\n  set instT = set instT'\n  distinct (map fst insts)\n  distinct (map fst insts')\n  set insts = set insts'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n   set instT = set instT'; distinct (map fst insts);\n   distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n  \\<Longrightarrow> subst_type_term instT insts t =\n                    subst_type_term instT' insts' t\n  distinct (map fst instT)\n  distinct (map fst instT')\n  set instT = set instT'\n  distinct (map fst insts)\n  distinct (map fst insts')\n  set insts = set insts'\n\ngoal (1 subgoal):\n 1. subst_type_term instT insts (Abs T t) =\n    subst_type_term instT' insts' (Abs T t)", "using subst_typ_irrelevant_order[OF instT_assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n   set instT = set instT'; distinct (map fst insts);\n   distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n  \\<Longrightarrow> subst_type_term instT insts t =\n                    subst_type_term instT' insts' t\n  distinct (map fst instT)\n  distinct (map fst instT')\n  set instT = set instT'\n  distinct (map fst insts)\n  distinct (map fst insts')\n  set insts = set insts'\n  subst_typ instT ?T = subst_typ instT' ?T\n\ngoal (1 subgoal):\n 1. subst_type_term instT insts (Abs T t) =\n    subst_type_term instT' insts' (Abs T t)", "by simp"], ["proof (state)\nthis:\n  subst_type_term instT insts (Abs T t) =\n  subst_type_term instT' insts' (Abs T t)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Ct x1 x2) =\n                         subst_type_term instT' insts' (Ct x1 x2)\n 2. \\<And>x.\n       \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (Bv x) =\n                         subst_type_term instT' insts' (Bv x)\n 3. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>distinct (map fst instT);\n                 distinct (map fst instT'); set instT = set instT';\n                 distinct (map fst insts); distinct (map fst insts');\n                 set insts = set insts'\\<rbrakk>\n                \\<Longrightarrow> subst_type_term instT insts t1 =\n                                  subst_type_term instT' insts' t1;\n        \\<lbrakk>distinct (map fst instT); distinct (map fst instT');\n         set instT = set instT'; distinct (map fst insts);\n         distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n        \\<Longrightarrow> subst_type_term instT insts t2 =\n                          subst_type_term instT' insts' t2;\n        distinct (map fst instT); distinct (map fst instT');\n        set instT = set instT'; distinct (map fst insts);\n        distinct (map fst insts'); set insts = set insts'\\<rbrakk>\n       \\<Longrightarrow> subst_type_term instT insts (t1 $ t2) =\n                         subst_type_term instT' insts' (t1 $ t2)", "qed (simp_all add: subst_typ_irrelevant_order[OF instT_assms])"], ["", "(* Core lemma, Isabelle/Pure's instantiate_same function can simulate abstract \n  term/type subtitutions in terms \n\n  The tsubst should be no problem, can be rewritten to subst_type using previous simulation lemma\n*)"], ["", "lemma subst_type_term_simulates_subst_tsubst_gen':\n  assumes lty_assms: \"distinct lty\" \"tvs t \\<subseteq> set lty\"\n  assumes lt_assms: \"distinct lt\" \"fv (tsubst t \\<rho>ty) \\<subseteq> set lt\"\n  shows \"subst (tsubst t \\<rho>ty) \\<rho>t \n    = subst_type_term (map (\\<lambda>(x,y).((x,y), \\<rho>ty x y)) lty) (map (\\<lambda>(x,y).((x,y), \\<rho>t x y)) lt) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (tsubst t \\<rho>ty) \\<rho>t =\n    subst_type_term (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst (tsubst t \\<rho>ty) \\<rho>t =\n    subst_type_term (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t", "let ?lty = \"map (\\<lambda>(x,y).((x,y), \\<rho>ty x y)) lty\""], ["proof (state)\ngoal (1 subgoal):\n 1. subst (tsubst t \\<rho>ty) \\<rho>t =\n    subst_type_term (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t", "have p1ty: \"distinct (map fst ?lty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty))", "using lty_assms"], ["proof (prove)\nusing this:\n  distinct lty\n  tvs t \\<subseteq> set lty\n\ngoal (1 subgoal):\n 1. distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty))", "by (simp add: case_prod_beta map_idI)"], ["proof (state)\nthis:\n  distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty))\n\ngoal (1 subgoal):\n 1. subst (tsubst t \\<rho>ty) \\<rho>t =\n    subst_type_term (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t", "let ?lt = \"map (\\<lambda>(x,y).((x,y), \\<rho>t x y)) lt\""], ["proof (state)\ngoal (1 subgoal):\n 1. subst (tsubst t \\<rho>ty) \\<rho>t =\n    subst_type_term (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t", "have p1t: \"distinct (map fst ?lt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt))", "using lt_assms"], ["proof (prove)\nusing this:\n  distinct lt\n  fv (tsubst t \\<rho>ty) \\<subseteq> set lt\n\ngoal (1 subgoal):\n 1. distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt))", "by (simp add: case_prod_beta map_idI)"], ["proof (state)\nthis:\n  distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt))\n\ngoal (1 subgoal):\n 1. subst (tsubst t \\<rho>ty) \\<rho>t =\n    subst_type_term (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (tsubst t \\<rho>ty) \\<rho>t =\n    subst_type_term (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t", "using assms"], ["proof (prove)\nusing this:\n  distinct lty\n  tvs t \\<subseteq> set lty\n  distinct lt\n  fv (tsubst t \\<rho>ty) \\<subseteq> set lt\n\ngoal (1 subgoal):\n 1. subst (tsubst t \\<rho>ty) \\<rho>t =\n    subst_type_term (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t", "proof(induction t arbitrary: lty lt)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Ct x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Ct x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Ct x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Ct x1 x2)\n 2. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Fv x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Fv x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Fv x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Fv x1 x2)\n 3. \\<And>x lty lt.\n       \\<lbrakk>distinct lty; tvs (Bv x) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Bv x) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Bv x) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Bv x)\n 4. \\<And>x1 t lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t;\n        distinct lty; tvs (Abs x1 t) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Abs x1 t) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Abs x1 t) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Abs x1 t)\n 5. \\<And>t1 t2 lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t1 \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t1 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t1 \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t1;\n        \\<And>lty lt.\n           \\<lbrakk>distinct lty; tvs t2 \\<subseteq> set lty; distinct lt;\n            fv (tsubst t2 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n           \\<Longrightarrow> subst (tsubst t2 \\<rho>ty) \\<rho>t =\n                             subst_type_term\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                                lty)\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y))\n                                lt)\n                              t2;\n        distinct lty; tvs (t1 $ t2) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (t1 $ t2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (t1 $ t2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (t1 $ t2)", "case (Fv idn T)"], ["proof (state)\nthis:\n  distinct lty\n  tvs (Fv idn T) \\<subseteq> set lty\n  distinct lt\n  fv (tsubst (Fv idn T) \\<rho>ty) \\<subseteq> set lt\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Ct x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Ct x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Ct x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Ct x1 x2)\n 2. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Fv x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Fv x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Fv x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Fv x1 x2)\n 3. \\<And>x lty lt.\n       \\<lbrakk>distinct lty; tvs (Bv x) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Bv x) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Bv x) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Bv x)\n 4. \\<And>x1 t lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t;\n        distinct lty; tvs (Abs x1 t) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Abs x1 t) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Abs x1 t) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Abs x1 t)\n 5. \\<And>t1 t2 lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t1 \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t1 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t1 \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t1;\n        \\<And>lty lt.\n           \\<lbrakk>distinct lty; tvs t2 \\<subseteq> set lty; distinct lt;\n            fv (tsubst t2 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n           \\<Longrightarrow> subst (tsubst t2 \\<rho>ty) \\<rho>t =\n                             subst_type_term\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                                lty)\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y))\n                                lt)\n                              t2;\n        distinct lty; tvs (t1 $ t2) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (t1 $ t2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (t1 $ t2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (t1 $ t2)", "let ?T = \"tsubstT T \\<rho>ty\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Ct x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Ct x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Ct x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Ct x1 x2)\n 2. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Fv x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Fv x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Fv x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Fv x1 x2)\n 3. \\<And>x lty lt.\n       \\<lbrakk>distinct lty; tvs (Bv x) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Bv x) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Bv x) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Bv x)\n 4. \\<And>x1 t lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t;\n        distinct lty; tvs (Abs x1 t) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Abs x1 t) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Abs x1 t) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Abs x1 t)\n 5. \\<And>t1 t2 lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t1 \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t1 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t1 \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t1;\n        \\<And>lty lt.\n           \\<lbrakk>distinct lty; tvs t2 \\<subseteq> set lty; distinct lt;\n            fv (tsubst t2 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n           \\<Longrightarrow> subst (tsubst t2 \\<rho>ty) \\<rho>t =\n                             subst_type_term\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                                lty)\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y))\n                                lt)\n                              t2;\n        distinct lty; tvs (t1 $ t2) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (t1 $ t2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (t1 $ t2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (t1 $ t2)", "have el: \"((idn, ?T), \\<rho>t idn ?T) \\<in> set (map (\\<lambda>(x,y).((x,y), \\<rho>t x y)) lt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((idn, tsubstT T \\<rho>ty), \\<rho>t idn (tsubstT T \\<rho>ty))\n    \\<in> set (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)", "using Fv"], ["proof (prove)\nusing this:\n  distinct lty\n  tvs (Fv idn T) \\<subseteq> set lty\n  distinct lt\n  fv (tsubst (Fv idn T) \\<rho>ty) \\<subseteq> set lt\n\ngoal (1 subgoal):\n 1. ((idn, tsubstT T \\<rho>ty), \\<rho>t idn (tsubstT T \\<rho>ty))\n    \\<in> set (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)", "by auto"], ["proof (state)\nthis:\n  ((idn, tsubstT T \\<rho>ty), \\<rho>t idn (tsubstT T \\<rho>ty))\n  \\<in> set (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Ct x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Ct x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Ct x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Ct x1 x2)\n 2. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Fv x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Fv x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Fv x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Fv x1 x2)\n 3. \\<And>x lty lt.\n       \\<lbrakk>distinct lty; tvs (Bv x) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Bv x) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Bv x) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Bv x)\n 4. \\<And>x1 t lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t;\n        distinct lty; tvs (Abs x1 t) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Abs x1 t) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Abs x1 t) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Abs x1 t)\n 5. \\<And>t1 t2 lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t1 \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t1 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t1 \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t1;\n        \\<And>lty lt.\n           \\<lbrakk>distinct lty; tvs t2 \\<subseteq> set lty; distinct lt;\n            fv (tsubst t2 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n           \\<Longrightarrow> subst (tsubst t2 \\<rho>ty) \\<rho>t =\n                             subst_type_term\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                                lty)\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y))\n                                lt)\n                              t2;\n        distinct lty; tvs (t1 $ t2) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (t1 $ t2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (t1 $ t2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (t1 $ t2)", "have d: \"distinct (map fst (map (\\<lambda>(x,y).((x,y), \\<rho>t x y)) lt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt))", "using Fv"], ["proof (prove)\nusing this:\n  distinct lty\n  tvs (Fv idn T) \\<subseteq> set lty\n  distinct lt\n  fv (tsubst (Fv idn T) \\<rho>ty) \\<subseteq> set lt\n\ngoal (1 subgoal):\n 1. distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt))", "by (simp add: case_prod_beta map_idI)"], ["proof (state)\nthis:\n  distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Ct x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Ct x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Ct x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Ct x1 x2)\n 2. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Fv x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Fv x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Fv x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Fv x1 x2)\n 3. \\<And>x lty lt.\n       \\<lbrakk>distinct lty; tvs (Bv x) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Bv x) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Bv x) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Bv x)\n 4. \\<And>x1 t lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t;\n        distinct lty; tvs (Abs x1 t) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Abs x1 t) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Abs x1 t) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Abs x1 t)\n 5. \\<And>t1 t2 lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t1 \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t1 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t1 \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t1;\n        \\<And>lty lt.\n           \\<lbrakk>distinct lty; tvs t2 \\<subseteq> set lty; distinct lt;\n            fv (tsubst t2 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n           \\<Longrightarrow> subst (tsubst t2 \\<rho>ty) \\<rho>t =\n                             subst_type_term\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                                lty)\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y))\n                                lt)\n                              t2;\n        distinct lty; tvs (t1 $ t2) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (t1 $ t2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (t1 $ t2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (t1 $ t2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (tsubst (Fv idn T) \\<rho>ty) \\<rho>t =\n    subst_type_term\n     (map (\\<lambda>a.\n              case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>ty x y))\n       lty)\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>t x y))\n       lt)\n     (Fv idn T)", "using  Fv.prems d"], ["proof (prove)\nusing this:\n  distinct lty\n  tvs (Fv idn T) \\<subseteq> set lty\n  distinct lt\n  fv (tsubst (Fv idn T) \\<rho>ty) \\<subseteq> set lt\n  distinct (map fst (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt))\n\ngoal (1 subgoal):\n 1. subst (tsubst (Fv idn T) \\<rho>ty) \\<rho>t =\n    subst_type_term\n     (map (\\<lambda>a.\n              case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>ty x y))\n       lty)\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>t x y))\n       lt)\n     (Fv idn T)", "by (auto simp add: iffD1[OF lookup_present_eq_key, OF d el] \n          subst_typ_simulates_tsubstT_gen'[symmetric] Let_def)"], ["proof (state)\nthis:\n  subst (tsubst (Fv idn T) \\<rho>ty) \\<rho>t =\n  subst_type_term\n   (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>ty x y))\n     lty)\n   (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>t x y))\n     lt)\n   (Fv idn T)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 lty lt.\n       \\<lbrakk>distinct lty; tvs (Ct x1 x2) \\<subseteq> set lty;\n        distinct lt;\n        fv (tsubst (Ct x1 x2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Ct x1 x2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Ct x1 x2)\n 2. \\<And>x lty lt.\n       \\<lbrakk>distinct lty; tvs (Bv x) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Bv x) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Bv x) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Bv x)\n 3. \\<And>x1 t lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t;\n        distinct lty; tvs (Abs x1 t) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (Abs x1 t) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (Abs x1 t) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (Abs x1 t)\n 4. \\<And>t1 t2 lty lt.\n       \\<lbrakk>\\<And>lty lt.\n                   \\<lbrakk>distinct lty; tvs t1 \\<subseteq> set lty;\n                    distinct lt;\n                    fv (tsubst t1 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n                   \\<Longrightarrow> subst (tsubst t1 \\<rho>ty) \\<rho>t =\n                                     subst_type_term\n(map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n(map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t1;\n        \\<And>lty lt.\n           \\<lbrakk>distinct lty; tvs t2 \\<subseteq> set lty; distinct lt;\n            fv (tsubst t2 \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n           \\<Longrightarrow> subst (tsubst t2 \\<rho>ty) \\<rho>t =\n                             subst_type_term\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                                lty)\n                              (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y))\n                                lt)\n                              t2;\n        distinct lty; tvs (t1 $ t2) \\<subseteq> set lty; distinct lt;\n        fv (tsubst (t1 $ t2) \\<rho>ty) \\<subseteq> set lt\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst (t1 $ t2) \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n                            lty)\n                          (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt)\n                          (t1 $ t2)", "qed (simp_all add: subst_typ_simulates_tsubstT_gen')"], ["proof (state)\nthis:\n  subst (tsubst t \\<rho>ty) \\<rho>t =\n  subst_type_term (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y)) lty)\n   (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y)) lt) t\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_type_term_simulates_subst_tsubst: \"subst (tsubst t \\<rho>ty) \\<rho>t \n    = subst_type_term (map (\\<lambda>(x,y).((x,y), \\<rho>ty x y)) (SOME lty . distinct lty \\<and> tvs t = set lty)) \n      (map (\\<lambda>(x,y).((x,y), \\<rho>t x y)) (SOME lt . distinct lt \\<and> fv (tsubst t \\<rho>ty) = set lt)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (tsubst t \\<rho>ty) \\<rho>t =\n    subst_type_term\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>ty x y))\n       (SOME lty. distinct lty \\<and> tvs t = set lty))\n     (map (\\<lambda>(x, y). ((x, y), \\<rho>t x y))\n       (SOME lt. distinct lt \\<and> fv (tsubst t \\<rho>ty) = set lt))\n     t", "apply (rule someI2_ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>a. distinct a \\<and> fv (tsubst t \\<rho>ty) = set a\n 2. \\<And>x.\n       distinct x \\<and> fv (tsubst t \\<rho>ty) = set x \\<Longrightarrow>\n       subst (tsubst t \\<rho>ty) \\<rho>t =\n       subst_type_term\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>ty x y))\n          (SOME lty. distinct lty \\<and> tvs t = set lty))\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>t x y))\n          x)\n        t", "using finite_fv finite_distinct_list"], ["proof (prove)\nusing this:\n  finite (fv ?t)\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n\ngoal (2 subgoals):\n 1. \\<exists>a. distinct a \\<and> fv (tsubst t \\<rho>ty) = set a\n 2. \\<And>x.\n       distinct x \\<and> fv (tsubst t \\<rho>ty) = set x \\<Longrightarrow>\n       subst (tsubst t \\<rho>ty) \\<rho>t =\n       subst_type_term\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>ty x y))\n          (SOME lty. distinct lty \\<and> tvs t = set lty))\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>t x y))\n          x)\n        t", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> fv (tsubst t \\<rho>ty) = set x \\<Longrightarrow>\n       subst (tsubst t \\<rho>ty) \\<rho>t =\n       subst_type_term\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>ty x y))\n          (SOME lty. distinct lty \\<and> tvs t = set lty))\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho>t x y))\n          x)\n        t", "apply (rule someI2_ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       distinct x \\<and> fv (tsubst t \\<rho>ty) = set x \\<Longrightarrow>\n       \\<exists>a. distinct a \\<and> tvs t = set a\n 2. \\<And>x xa.\n       \\<lbrakk>distinct x \\<and> fv (tsubst t \\<rho>ty) = set x;\n        distinct xa \\<and> tvs t = set xa\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (x, y) \\<Rightarrow>\n                                     ((x, y), \\<rho>ty x y))\n                            xa)\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (x, y) \\<Rightarrow>\n                                     ((x, y), \\<rho>t x y))\n                            x)\n                          t", "using finite_tvs finite_distinct_list"], ["proof (prove)\nusing this:\n  finite (tvs ?t)\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       distinct x \\<and> fv (tsubst t \\<rho>ty) = set x \\<Longrightarrow>\n       \\<exists>a. distinct a \\<and> tvs t = set a\n 2. \\<And>x xa.\n       \\<lbrakk>distinct x \\<and> fv (tsubst t \\<rho>ty) = set x;\n        distinct xa \\<and> tvs t = set xa\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (x, y) \\<Rightarrow>\n                                     ((x, y), \\<rho>ty x y))\n                            xa)\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (x, y) \\<Rightarrow>\n                                     ((x, y), \\<rho>t x y))\n                            x)\n                          t", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>distinct x \\<and> fv (tsubst t \\<rho>ty) = set x;\n        distinct xa \\<and> tvs t = set xa\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (x, y) \\<Rightarrow>\n                                     ((x, y), \\<rho>ty x y))\n                            xa)\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (x, y) \\<Rightarrow>\n                                     ((x, y), \\<rho>t x y))\n                            x)\n                          t", "using subst_type_term_simulates_subst_tsubst_gen'"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?lty; tvs ?t \\<subseteq> set ?lty; distinct ?lt;\n   fv (tsubst ?t ?\\<rho>ty) \\<subseteq> set ?lt\\<rbrakk>\n  \\<Longrightarrow> subst (tsubst ?t ?\\<rho>ty) ?\\<rho>t =\n                    subst_type_term\n                     (map (\\<lambda>(x, y). ((x, y), ?\\<rho>ty x y)) ?lty)\n                     (map (\\<lambda>(x, y). ((x, y), ?\\<rho>t x y)) ?lt) ?t\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>distinct x \\<and> fv (tsubst t \\<rho>ty) = set x;\n        distinct xa \\<and> tvs t = set xa\\<rbrakk>\n       \\<Longrightarrow> subst (tsubst t \\<rho>ty) \\<rho>t =\n                         subst_type_term\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (x, y) \\<Rightarrow>\n                                     ((x, y), \\<rho>ty x y))\n                            xa)\n                          (map (\\<lambda>a.\n                                   case a of\n                                   (x, y) \\<Rightarrow>\n                                     ((x, y), \\<rho>t x y))\n                            x)\n                          t", "by simp"], ["", "abbreviation \"subst_typ' pairs t \\<equiv> map_types (subst_typ pairs) t\""], ["", "lemma subst_typ'_nil[simp]: \"subst_typ' [] A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' [] A = A", "by (induction A) (auto simp add:)"], ["", "lemma subst_typ'_simulates_tsubst_gen': \"distinct pairs \\<Longrightarrow> tvs t \\<subseteq> set pairs\n  \\<Longrightarrow> tsubst t \\<rho> = subst_typ' (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) pairs) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct pairs; tvs t \\<subseteq> set pairs\\<rbrakk>\n    \\<Longrightarrow> tsubst t \\<rho> =\n                      subst_typ'\n                       (map (\\<lambda>(x, y). ((x, y), \\<rho> x y)) pairs) t", "by (induction t arbitrary: pairs \\<rho>) \n    (auto simp add: subst_typ_simulates_tsubstT_gen')"], ["", "lemma subst_typ'_simulates_tsubst_gen: \"tsubst t \\<rho> \n  = subst_typ' (map (\\<lambda>(x,y).((x,y), \\<rho> x y)) (SOME l . distinct l \\<and> tvs t \\<subseteq> set l)) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tsubst t \\<rho> =\n    subst_typ'\n     (map (\\<lambda>(x, y). ((x, y), \\<rho> x y))\n       (SOME l. distinct l \\<and> tvs t \\<subseteq> set l))\n     t", "proof(rule someI2_ex)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a. distinct a \\<and> tvs t \\<subseteq> set a\n 2. \\<And>x.\n       distinct x \\<and> tvs t \\<subseteq> set x \\<Longrightarrow>\n       tsubst t \\<rho> =\n       subst_typ'\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        t", "show \"\\<exists>a. distinct a \\<and> tvs t \\<subseteq> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. distinct a \\<and> tvs t \\<subseteq> set a", "using finite_tvs finite_distinct_list"], ["proof (prove)\nusing this:\n  finite (tvs ?t)\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>a. distinct a \\<and> tvs t \\<subseteq> set a", "by (metis order_refl)"], ["proof (state)\nthis:\n  \\<exists>a. distinct a \\<and> tvs t \\<subseteq> set a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> tvs t \\<subseteq> set x \\<Longrightarrow>\n       tsubst t \\<rho> =\n       subst_typ'\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> tvs t \\<subseteq> set x \\<Longrightarrow>\n       tsubst t \\<rho> =\n       subst_typ'\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        t", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> tvs t \\<subseteq> set x \\<Longrightarrow>\n       tsubst t \\<rho> =\n       subst_typ'\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        t", "assume l: \"distinct l \\<and> tvs t \\<subseteq> set l\""], ["proof (state)\nthis:\n  distinct l \\<and> tvs t \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       distinct x \\<and> tvs t \\<subseteq> set x \\<Longrightarrow>\n       tsubst t \\<rho> =\n       subst_typ'\n        (map (\\<lambda>a.\n                 case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n          x)\n        t", "then"], ["proof (chain)\npicking this:\n  distinct l \\<and> tvs t \\<subseteq> set l", "show \"tsubst t \\<rho> = subst_typ' (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y)) l) t\""], ["proof (prove)\nusing this:\n  distinct l \\<and> tvs t \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. tsubst t \\<rho> =\n    subst_typ'\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n       l)\n     t", "using subst_typ'_simulates_tsubst_gen'"], ["proof (prove)\nusing this:\n  distinct l \\<and> tvs t \\<subseteq> set l\n  \\<lbrakk>distinct ?pairs; tvs ?t \\<subseteq> set ?pairs\\<rbrakk>\n  \\<Longrightarrow> tsubst ?t ?\\<rho> =\n                    subst_typ'\n                     (map (\\<lambda>(x, y). ((x, y), ?\\<rho> x y)) ?pairs)\n                     ?t\n\ngoal (1 subgoal):\n 1. tsubst t \\<rho> =\n    subst_typ'\n     (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y))\n       l)\n     t", "by blast"], ["proof (state)\nthis:\n  tsubst t \\<rho> =\n  subst_typ'\n   (map (\\<lambda>a. case a of (x, y) \\<Rightarrow> ((x, y), \\<rho> x y)) l)\n   t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tsubst_simulates_subst_typ': \"subst_typ' insts T\n  = tsubst T (\\<lambda>idn S . the_default (Tv idn S) (lookup (\\<lambda>x. x=(idn, S)) insts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' insts T =\n    tsubst T\n     (\\<lambda>idn S.\n         the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))", "by (induction T) (auto simp add: tsubstT_simulates_subst_typ)"], ["", "(* \n  Naming! \n*)"], ["", "lemma subst_type_add_degenerate_instance: \n  \"(idx,s) \\<notin> set (map fst insts) \\<Longrightarrow> subst_typ insts T = subst_typ (((idx,s), Tv idx s)#insts) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (idx, s) \\<notin> set (map fst insts) \\<Longrightarrow>\n    subst_typ insts T = subst_typ (((idx, s), Tv idx s) # insts) T", "by (induction T) (auto simp add: lookup_eq_key_not_present)"], ["", "lemma subst_typ'_add_degenerate_instance: \n  \"(idx,s) \\<notin> set (map fst insts) \\<Longrightarrow> subst_typ' insts t = subst_typ' (((idx,s), Tv idx s)#insts) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (idx, s) \\<notin> set (map fst insts) \\<Longrightarrow>\n    subst_typ' insts t = subst_typ' (((idx, s), Tv idx s) # insts) t", "by (induction t) (auto simp add: subst_type_add_degenerate_instance)"], ["", "(* Again, janky composition *)"], ["", "lemma subst_typ'_comp: \n  \"subst_typ' inst1 (subst_typ' inst2 t) = subst_typ' (map (apsnd (subst_typ inst1)) inst2 @ inst1) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' inst1 (subst_typ' inst2 t) =\n    subst_typ' (map (apsnd (subst_typ inst1)) inst2 @ inst1) t", "by (induction t) (use subst_typ_comp in auto)"], ["", "(* To make insts distinct again *)"], ["", "lemma subst_typ'_AList_clearjunk: \"subst_typ' insts t = subst_typ' (AList.clearjunk insts) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' insts t = subst_typ' (AList.clearjunk insts) t", "by (induction t) (use subst_typ_AList_clearjunk in auto)"], ["", "fun subst_term :: \"((variable * typ) * term) list \\<Rightarrow> term \\<Rightarrow> term\" where\n  \"subst_term insts (Ct c T) = Ct c T\"\n| \"subst_term insts (Fv idn T) = the_default (Fv idn T) (lookup (\\<lambda>x. x=(idn, T)) insts)\"\n| \"subst_term _ (Bv n) = Bv n\"\n| \"subst_term insts (Abs T t) = Abs T (subst_term insts t)\"\n| \"subst_term insts (t $ u) = subst_term  insts t $ subst_term insts u\""], ["", "lemma subst_term_empty_no_change[simp]: \"subst_term [] t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term [] t = t", "by (induction t) auto"], ["", "lemma subst_type_term_without_type_insts_eq_subst_term[simp]: \n  \"subst_type_term [] insts t = subst_term insts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_type_term [] insts t = subst_term insts t", "by (induction insts t rule: subst_term.induct) simp_all"], ["", "lemma subst_type_term_split_levels: \n  \"subst_type_term instT insts t = subst_term insts (subst_typ' instT t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_type_term instT insts t = subst_term insts (subst_typ' instT t)", "by (induction t) (auto simp add: Let_def)"], ["", "(* Express parallel substitution as a series of single substitutions. *)\n\n(* Deleted assms in the induction once, recheck proofs, maybe some get easier. *)"], ["", "lemma subst_typ_stepwise:\n  assumes \"distinct (map fst instT)\"\n  assumes \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` set instT . tvsT t) \\<Longrightarrow> x \\<notin> fst ` set instT\"\n  shows \"subst_typ instT T = fold (\\<lambda>single acc . subst_typ [single] acc) instT T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ instT T = fold (\\<lambda>single. subst_typ [single]) instT T", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst instT)\n  ?x \\<in> tvsT_Set (snd ` set instT) \\<Longrightarrow>\n  ?x \\<notin> fst ` set instT\n\ngoal (1 subgoal):\n 1. subst_typ instT T = fold (\\<lambda>single. subst_typ [single]) instT T", "proof (induction instT T rule: subst_typ.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>insts a Ts.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ts; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> subst_typ insts x =\n                                     fold\n(\\<lambda>single. subst_typ [single]) insts x;\n        distinct (map fst insts);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set insts) \\<Longrightarrow>\n           x \\<notin> fst ` set insts\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Ty a Ts) =\n                         fold (\\<lambda>single. subst_typ [single]) insts\n                          (Ty a Ts)\n 2. \\<And>insts idn S.\n       \\<lbrakk>distinct (map fst insts);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set insts) \\<Longrightarrow>\n           x \\<notin> fst ` set insts\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) insts\n                          (Tv idn S)", "case (1 inst a Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set Ts; distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (2 subgoals):\n 1. \\<And>insts a Ts.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ts; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> subst_typ insts x =\n                                     fold\n(\\<lambda>single. subst_typ [single]) insts x;\n        distinct (map fst insts);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set insts) \\<Longrightarrow>\n           x \\<notin> fst ` set insts\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Ty a Ts) =\n                         fold (\\<lambda>single. subst_typ [single]) insts\n                          (Ty a Ts)\n 2. \\<And>insts idn S.\n       \\<lbrakk>distinct (map fst insts);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set insts) \\<Longrightarrow>\n           x \\<notin> fst ` set insts\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) insts\n                          (Tv idn S)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set Ts; distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set Ts; distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. subst_typ inst (Ty a Ts) =\n    fold (\\<lambda>single. subst_typ [single]) inst (Ty a Ts)", "proof (induction Ts arbitrary: inst)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>inst.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set []; distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst x =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (constT a) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (constT a)\n 2. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set []; distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (2 subgoals):\n 1. \\<And>inst.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set []; distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst x =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (constT a) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (constT a)\n 2. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set []; distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set []; distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. subst_typ inst (constT a) =\n    fold (\\<lambda>single. subst_typ [single]) inst (constT a)", "by (induction inst) auto"], ["proof (state)\nthis:\n  subst_typ inst (constT a) =\n  fold (\\<lambda>single. subst_typ [single]) inst (constT a)\n\ngoal (1 subgoal):\n 1. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "case (Cons T Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>x \\<in> set Ts; distinct (map fst ?inst);\n               \\<And>x.\n                  x \\<in> tvsT_Set (snd ` set ?inst) \\<Longrightarrow>\n                  x \\<notin> fst ` set ?inst\\<rbrakk>\n              \\<Longrightarrow> subst_typ ?inst x =\n                                fold (\\<lambda>single. subst_typ [single])\n                                 ?inst x;\n   distinct (map fst ?inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set ?inst) \\<Longrightarrow>\n      x \\<notin> fst ` set ?inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ ?inst (Ty a Ts) =\n                    fold (\\<lambda>single. subst_typ [single]) ?inst\n                     (Ty a Ts)\n  \\<lbrakk>?x \\<in> set (T # Ts); distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "hence \"subst_typ inst (Ty a Ts) = fold (\\<lambda>single. subst_typ [single]) inst (Ty a Ts)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>x \\<in> set Ts; distinct (map fst ?inst);\n               \\<And>x.\n                  x \\<in> tvsT_Set (snd ` set ?inst) \\<Longrightarrow>\n                  x \\<notin> fst ` set ?inst\\<rbrakk>\n              \\<Longrightarrow> subst_typ ?inst x =\n                                fold (\\<lambda>single. subst_typ [single])\n                                 ?inst x;\n   distinct (map fst ?inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set ?inst) \\<Longrightarrow>\n      x \\<notin> fst ` set ?inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ ?inst (Ty a Ts) =\n                    fold (\\<lambda>single. subst_typ [single]) ?inst\n                     (Ty a Ts)\n  \\<lbrakk>?x \\<in> set (T # Ts); distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. subst_typ inst (Ty a Ts) =\n    fold (\\<lambda>single. subst_typ [single]) inst (Ty a Ts)", "by simp"], ["proof (state)\nthis:\n  subst_typ inst (Ty a Ts) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a Ts)\n\ngoal (1 subgoal):\n 1. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "moreover"], ["proof (state)\nthis:\n  subst_typ inst (Ty a Ts) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a Ts)\n\ngoal (1 subgoal):\n 1. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "have \"subst_typ inst T = fold (\\<lambda>single. subst_typ [single]) inst T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ inst T = fold (\\<lambda>single. subst_typ [single]) inst T", "using Cons 1"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>x \\<in> set Ts; distinct (map fst ?inst);\n               \\<And>x.\n                  x \\<in> tvsT_Set (snd ` set ?inst) \\<Longrightarrow>\n                  x \\<notin> fst ` set ?inst\\<rbrakk>\n              \\<Longrightarrow> subst_typ ?inst x =\n                                fold (\\<lambda>single. subst_typ [single])\n                                 ?inst x;\n   distinct (map fst ?inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set ?inst) \\<Longrightarrow>\n      x \\<notin> fst ` set ?inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ ?inst (Ty a Ts) =\n                    fold (\\<lambda>single. subst_typ [single]) ?inst\n                     (Ty a Ts)\n  \\<lbrakk>?x \\<in> set (T # Ts); distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n  \\<lbrakk>?x \\<in> set Ts__; distinct (map fst inst__);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst__) \\<Longrightarrow>\n      x \\<notin> fst ` set inst__\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst__ ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst__ ?x\n  distinct (map fst inst__)\n  ?x \\<in> tvsT_Set (snd ` set inst__) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst__\n\ngoal (1 subgoal):\n 1. subst_typ inst T = fold (\\<lambda>single. subst_typ [single]) inst T", "by simp"], ["proof (state)\nthis:\n  subst_typ inst T = fold (\\<lambda>single. subst_typ [single]) inst T\n\ngoal (1 subgoal):\n 1. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "moreover"], ["proof (state)\nthis:\n  subst_typ inst T = fold (\\<lambda>single. subst_typ [single]) inst T\n\ngoal (1 subgoal):\n 1. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "have \"fold (\\<lambda>single. subst_typ [single]) inst (Ty a (T#Ts)) \n      = (Ty a (map (fold (\\<lambda>single. subst_typ [single]) inst) (T#Ts)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) inst (Ty a (T # Ts)) =\n    Ty a (map (fold (\\<lambda>single. subst_typ [single]) inst) (T # Ts))", "proof (induction inst rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. fold (\\<lambda>single. subst_typ [single]) [] (Ty a (T # Ts)) =\n    Ty a (map (fold (\\<lambda>single. subst_typ [single]) []) (T # Ts))\n 2. \\<And>x xs.\n       fold (\\<lambda>single. subst_typ [single]) xs (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) xs)\n          (T # Ts)) \\<Longrightarrow>\n       fold (\\<lambda>single. subst_typ [single]) (xs @ [x])\n        (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) (xs @ [x]))\n          (T # Ts))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. fold (\\<lambda>single. subst_typ [single]) [] (Ty a (T # Ts)) =\n    Ty a (map (fold (\\<lambda>single. subst_typ [single]) []) (T # Ts))\n 2. \\<And>x xs.\n       fold (\\<lambda>single. subst_typ [single]) xs (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) xs)\n          (T # Ts)) \\<Longrightarrow>\n       fold (\\<lambda>single. subst_typ [single]) (xs @ [x])\n        (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) (xs @ [x]))\n          (T # Ts))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) [] (Ty a (T # Ts)) =\n    Ty a (map (fold (\\<lambda>single. subst_typ [single]) []) (T # Ts))", "by simp"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) [] (Ty a (T # Ts)) =\n  Ty a (map (fold (\\<lambda>single. subst_typ [single]) []) (T # Ts))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       fold (\\<lambda>single. subst_typ [single]) xs (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) xs)\n          (T # Ts)) \\<Longrightarrow>\n       fold (\\<lambda>single. subst_typ [single]) (xs @ [x])\n        (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) (xs @ [x]))\n          (T # Ts))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       fold (\\<lambda>single. subst_typ [single]) xs (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) xs)\n          (T # Ts)) \\<Longrightarrow>\n       fold (\\<lambda>single. subst_typ [single]) (xs @ [x])\n        (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) (xs @ [x]))\n          (T # Ts))", "case (snoc x xs)"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) xs (Ty a (T # Ts)) =\n  Ty a (map (fold (\\<lambda>single. subst_typ [single]) xs) (T # Ts))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       fold (\\<lambda>single. subst_typ [single]) xs (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) xs)\n          (T # Ts)) \\<Longrightarrow>\n       fold (\\<lambda>single. subst_typ [single]) (xs @ [x])\n        (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) (xs @ [x]))\n          (T # Ts))", "hence \"fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) (Ty a (T # Ts)) =\n        Ty a (map (subst_typ [x]) (map (fold (\\<lambda>single. subst_typ [single]) xs) (T # Ts)))\""], ["proof (prove)\nusing this:\n  fold (\\<lambda>single. subst_typ [single]) xs (Ty a (T # Ts)) =\n  Ty a (map (fold (\\<lambda>single. subst_typ [single]) xs) (T # Ts))\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) (Ty a (T # Ts)) =\n    Ty a\n     (map (subst_typ [x])\n       (map (fold (\\<lambda>single. subst_typ [single]) xs) (T # Ts)))", "by simp"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) (Ty a (T # Ts)) =\n  Ty a\n   (map (subst_typ [x])\n     (map (fold (\\<lambda>single. subst_typ [single]) xs) (T # Ts)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       fold (\\<lambda>single. subst_typ [single]) xs (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) xs)\n          (T # Ts)) \\<Longrightarrow>\n       fold (\\<lambda>single. subst_typ [single]) (xs @ [x])\n        (Ty a (T # Ts)) =\n       Ty a\n        (map (fold (\\<lambda>single. subst_typ [single]) (xs @ [x]))\n          (T # Ts))", "then"], ["proof (chain)\npicking this:\n  fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) (Ty a (T # Ts)) =\n  Ty a\n   (map (subst_typ [x])\n     (map (fold (\\<lambda>single. subst_typ [single]) xs) (T # Ts)))", "show ?case"], ["proof (prove)\nusing this:\n  fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) (Ty a (T # Ts)) =\n  Ty a\n   (map (subst_typ [x])\n     (map (fold (\\<lambda>single. subst_typ [single]) xs) (T # Ts)))\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) (Ty a (T # Ts)) =\n    Ty a\n     (map (fold (\\<lambda>single. subst_typ [single]) (xs @ [x])) (T # Ts))", "by simp"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) (Ty a (T # Ts)) =\n  Ty a\n   (map (fold (\\<lambda>single. subst_typ [single]) (xs @ [x])) (T # Ts))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a (T # Ts)) =\n  Ty a (map (fold (\\<lambda>single. subst_typ [single]) inst) (T # Ts))\n\ngoal (1 subgoal):\n 1. \\<And>aa Ts inst.\n       \\<lbrakk>\\<And>inst.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>x \\<in> set Ts;\n                                distinct (map fst inst);\n                                \\<And>x.\n                                   x \\<in> tvsT_Set\n      (snd ` set inst) \\<Longrightarrow>\n                                   x \\<notin> fst ` set inst\\<rbrakk>\n                               \\<Longrightarrow> subst_typ inst x =\n           fold (\\<lambda>single. subst_typ [single]) inst x;\n                    distinct (map fst inst);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n                       x \\<notin> fst ` set inst\\<rbrakk>\n                   \\<Longrightarrow> subst_typ inst (Ty a Ts) =\n                                     fold\n(\\<lambda>single. subst_typ [single]) inst (Ty a Ts);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (aa # Ts); distinct (map fst inst);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n               x \\<notin> fst ` set inst\\<rbrakk>\n           \\<Longrightarrow> subst_typ inst x =\n                             fold (\\<lambda>single. subst_typ [single]) inst\n                              x;\n        distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Ty a (aa # Ts)) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Ty a (aa # Ts))", "ultimately"], ["proof (chain)\npicking this:\n  subst_typ inst (Ty a Ts) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a Ts)\n  subst_typ inst T = fold (\\<lambda>single. subst_typ [single]) inst T\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a (T # Ts)) =\n  Ty a (map (fold (\\<lambda>single. subst_typ [single]) inst) (T # Ts))", "show ?case"], ["proof (prove)\nusing this:\n  subst_typ inst (Ty a Ts) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a Ts)\n  subst_typ inst T = fold (\\<lambda>single. subst_typ [single]) inst T\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a (T # Ts)) =\n  Ty a (map (fold (\\<lambda>single. subst_typ [single]) inst) (T # Ts))\n\ngoal (1 subgoal):\n 1. subst_typ inst (Ty a (T # Ts)) =\n    fold (\\<lambda>single. subst_typ [single]) inst (Ty a (T # Ts))", "using Cons.prems(1) Cons.prems(2) local.Cons(4)"], ["proof (prove)\nusing this:\n  subst_typ inst (Ty a Ts) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a Ts)\n  subst_typ inst T = fold (\\<lambda>single. subst_typ [single]) inst T\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a (T # Ts)) =\n  Ty a (map (fold (\\<lambda>single. subst_typ [single]) inst) (T # Ts))\n  \\<lbrakk>?x \\<in> set (T # Ts); distinct (map fst inst);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n      x \\<notin> fst ` set inst\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    fold (\\<lambda>single. subst_typ [single]) inst ?x\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. subst_typ inst (Ty a (T # Ts)) =\n    fold (\\<lambda>single. subst_typ [single]) inst (Ty a (T # Ts))", "by auto"], ["proof (state)\nthis:\n  subst_typ inst (Ty a (T # Ts)) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a (T # Ts))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_typ inst (Ty a Ts) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Ty a Ts)\n\ngoal (1 subgoal):\n 1. \\<And>insts idn S.\n       \\<lbrakk>distinct (map fst insts);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set insts) \\<Longrightarrow>\n           x \\<notin> fst ` set insts\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) insts\n                          (Tv idn S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>insts idn S.\n       \\<lbrakk>distinct (map fst insts);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set insts) \\<Longrightarrow>\n           x \\<notin> fst ` set insts\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) insts\n                          (Tv idn S)", "case (2 inst idn S)"], ["proof (state)\nthis:\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. \\<And>insts idn S.\n       \\<lbrakk>distinct (map fst insts);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set insts) \\<Longrightarrow>\n           x \\<notin> fst ` set insts\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) insts\n                          (Tv idn S)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. subst_typ inst (Tv idn S) =\n    fold (\\<lambda>single. subst_typ [single]) inst (Tv idn S)", "proof (cases \"lookup (\\<lambda>x . x = (idn, S)) (inst)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst inst);\n     \\<And>x.\n        x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n        x \\<notin> fst ` set inst;\n     lookup (\\<lambda>x. x = (idn, S)) inst = None\\<rbrakk>\n    \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                      fold (\\<lambda>single. subst_typ [single]) inst\n                       (Tv idn S)\n 2. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "case None"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S)) inst = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst inst);\n     \\<And>x.\n        x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n        x \\<notin> fst ` set inst;\n     lookup (\\<lambda>x. x = (idn, S)) inst = None\\<rbrakk>\n    \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                      fold (\\<lambda>single. subst_typ [single]) inst\n                       (Tv idn S)\n 2. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "hence \"fst p \\<noteq> (idn, S)\" if \"p\\<in>set inst\" for p"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S)) inst = None\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, S)", "using that"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S)) inst = None\n  p \\<in> set inst\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, S)", "by (auto simp add: lookup_None_iff)"], ["proof (state)\nthis:\n  ?p \\<in> set inst \\<Longrightarrow> fst ?p \\<noteq> (idn, S)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst inst);\n     \\<And>x.\n        x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n        x \\<notin> fst ` set inst;\n     lookup (\\<lambda>x. x = (idn, S)) inst = None\\<rbrakk>\n    \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                      fold (\\<lambda>single. subst_typ [single]) inst\n                       (Tv idn S)\n 2. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "hence \"subst_typ [p] (Tv idn S) = Tv idn S\" if \"p\\<in>set inst\" for p"], ["proof (prove)\nusing this:\n  ?p \\<in> set inst \\<Longrightarrow> fst ?p \\<noteq> (idn, S)\n\ngoal (1 subgoal):\n 1. subst_typ [p] (Tv idn S) = Tv idn S", "using that"], ["proof (prove)\nusing this:\n  ?p \\<in> set inst \\<Longrightarrow> fst ?p \\<noteq> (idn, S)\n  p \\<in> set inst\n\ngoal (1 subgoal):\n 1. subst_typ [p] (Tv idn S) = Tv idn S", "by (cases p) fastforce"], ["proof (state)\nthis:\n  ?p \\<in> set inst \\<Longrightarrow> subst_typ [?p] (Tv idn S) = Tv idn S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst inst);\n     \\<And>x.\n        x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n        x \\<notin> fst ` set inst;\n     lookup (\\<lambda>x. x = (idn, S)) inst = None\\<rbrakk>\n    \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                      fold (\\<lambda>single. subst_typ [single]) inst\n                       (Tv idn S)\n 2. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "from this None"], ["proof (chain)\npicking this:\n  ?p \\<in> set inst \\<Longrightarrow> subst_typ [?p] (Tv idn S) = Tv idn S\n  lookup (\\<lambda>x. x = (idn, S)) inst = None", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p \\<in> set inst \\<Longrightarrow> subst_typ [?p] (Tv idn S) = Tv idn S\n  lookup (\\<lambda>x. x = (idn, S)) inst = None\n\ngoal (1 subgoal):\n 1. subst_typ inst (Tv idn S) =\n    fold (\\<lambda>single. subst_typ [single]) inst (Tv idn S)", "by (induction inst) (auto split: if_splits)"], ["proof (state)\nthis:\n  subst_typ inst (Tv idn S) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Tv idn S)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "case (Some a)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "have elem: \"((idn, S), a) \\<in> set inst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((idn, S), a) \\<in> set inst", "using Some lookup_present_eq_key'' 2"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some a\n  distinct (map fst ?al) \\<Longrightarrow>\n  (lookup (\\<lambda>x. x = ?k) ?al = Some ?v) = ((?k, ?v) \\<in> set ?al)\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. ((idn, S), a) \\<in> set inst", "by fastforce"], ["proof (state)\nthis:\n  ((idn, S), a) \\<in> set inst\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "from this"], ["proof (chain)\npicking this:\n  ((idn, S), a) \\<in> set inst", "obtain fs bs where split: \"inst = fs @ ((idn, S), a) # bs\""], ["proof (prove)\nusing this:\n  ((idn, S), a) \\<in> set inst\n\ngoal (1 subgoal):\n 1. (\\<And>fs bs.\n        inst = fs @ ((idn, S), a) # bs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  inst = fs @ ((idn, S), a) # bs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "hence \"(idn, S) \\<notin> set (map fst fs)\" and \"(idn, S) \\<notin> set (map fst bs)\""], ["proof (prove)\nusing this:\n  inst = fs @ ((idn, S), a) # bs\n\ngoal (1 subgoal):\n 1. (idn, S) \\<notin> set (map fst fs) &&&\n    (idn, S) \\<notin> set (map fst bs)", "using 2"], ["proof (prove)\nusing this:\n  inst = fs @ ((idn, S), a) # bs\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. (idn, S) \\<notin> set (map fst fs) &&&\n    (idn, S) \\<notin> set (map fst bs)", "by simp_all"], ["proof (state)\nthis:\n  (idn, S) \\<notin> set (map fst fs)\n  (idn, S) \\<notin> set (map fst bs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "hence \"fst p \\<noteq> (idn, S)\" if \"p\\<in>set fs\" for p"], ["proof (prove)\nusing this:\n  (idn, S) \\<notin> set (map fst fs)\n  (idn, S) \\<notin> set (map fst bs)\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, S)", "using that"], ["proof (prove)\nusing this:\n  (idn, S) \\<notin> set (map fst fs)\n  (idn, S) \\<notin> set (map fst bs)\n  p \\<in> set fs\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, S)", "by force"], ["proof (state)\nthis:\n  ?p \\<in> set fs \\<Longrightarrow> fst ?p \\<noteq> (idn, S)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "hence id_subst_fs: \"subst_typ [p] (Tv idn S) = Tv idn S\" if \"p\\<in>set fs\" for p"], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> fst ?p \\<noteq> (idn, S)\n\ngoal (1 subgoal):\n 1. subst_typ [p] (Tv idn S) = Tv idn S", "using that"], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> fst ?p \\<noteq> (idn, S)\n  p \\<in> set fs\n\ngoal (1 subgoal):\n 1. subst_typ [p] (Tv idn S) = Tv idn S", "by (cases p) fastforce"], ["proof (state)\nthis:\n  ?p \\<in> set fs \\<Longrightarrow> subst_typ [?p] (Tv idn S) = Tv idn S\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "hence fs_step: \"fold (\\<lambda>single. subst_typ [single]) fs (Tv idn S) = Tv idn S\""], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> subst_typ [?p] (Tv idn S) = Tv idn S\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) fs (Tv idn S) = Tv idn S", "by (induction fs) (auto split: if_splits)"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) fs (Tv idn S) = Tv idn S\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "have change_step: \"subst_typ [((idn, S), a)] (Tv idn S) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [((idn, S), a)] (Tv idn S) = a", "by simp"], ["proof (state)\nthis:\n  subst_typ [((idn, S), a)] (Tv idn S) = a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "have bs_sub: \"set bs \\<subseteq> set inst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set bs \\<subseteq> set inst", "using split"], ["proof (prove)\nusing this:\n  inst = fs @ ((idn, S), a) # bs\n\ngoal (1 subgoal):\n 1. set bs \\<subseteq> set inst", "by auto"], ["proof (state)\nthis:\n  set bs \\<subseteq> set inst\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "hence \"x \\<notin> fst ` set bs\" \n      if \"x\\<in> \\<Union> (tvsT ` snd ` set bs)\" for x"], ["proof (prove)\nusing this:\n  set bs \\<subseteq> set inst\n\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set bs", "using 2 that split"], ["proof (prove)\nusing this:\n  set bs \\<subseteq> set inst\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n  x \\<in> tvsT_Set (snd ` set bs)\n  inst = fs @ ((idn, S), a) # bs\n\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set bs", "by (auto simp add: image_iff)"], ["proof (state)\nthis:\n  ?x \\<in> tvsT_Set (snd ` set bs) \\<Longrightarrow>\n  ?x \\<notin> fst ` set bs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "have \"v \\<notin> fst ` set bs\" if \"v \\<in> tvsT a\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> fst ` set bs", "using that 2 elem bs_sub"], ["proof (prove)\nusing this:\n  v \\<in> tvsT a\n  distinct (map fst inst)\n  ?x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n  ?x \\<notin> fst ` set inst\n  ((idn, S), a) \\<in> set inst\n  set bs \\<subseteq> set inst\n\ngoal (1 subgoal):\n 1. v \\<notin> fst ` set bs", "by (fastforce simp add: image_iff)"], ["proof (state)\nthis:\n  ?v \\<in> tvsT a \\<Longrightarrow> ?v \\<notin> fst ` set bs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "hence id_subst_bs: \"subst_typ [p] a = a\" if \"p \\<in> set bs\" for p"], ["proof (prove)\nusing this:\n  ?v \\<in> tvsT a \\<Longrightarrow> ?v \\<notin> fst ` set bs\n\ngoal (1 subgoal):\n 1. subst_typ [p] a = a", "using that"], ["proof (prove)\nusing this:\n  ?v \\<in> tvsT a \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n\ngoal (1 subgoal):\n 1. subst_typ [p] a = a", "proof(cases p, induction a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 a b.\n       \\<lbrakk>\\<And>x2a a b.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    \\<And>v.\n                       v \\<in> tvsT x2a \\<Longrightarrow>\n                       v \\<notin> fst ` set bs;\n                    p \\<in> set bs; p = (a, b);\n                    \\<And>v.\n                       v \\<in> tvsT x2a \\<Longrightarrow>\n                       v \\<notin> fst ` set bs;\n                    p \\<in> set bs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ [p] x2a = x2a;\n        \\<And>v.\n           v \\<in> tvsT (Ty x1 x2) \\<Longrightarrow>\n           v \\<notin> fst ` set bs;\n        p \\<in> set bs; p = (a, b);\n        \\<And>v.\n           v \\<in> tvsT (Ty x1 x2) \\<Longrightarrow>\n           v \\<notin> fst ` set bs;\n        p \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> subst_typ [p] (Ty x1 x2) = Ty x1 x2\n 2. \\<And>x1 x2 a b.\n       \\<lbrakk>\\<And>v.\n                   v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n                   v \\<notin> fst ` set bs;\n        p \\<in> set bs; p = (a, b);\n        \\<And>v.\n           v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n           v \\<notin> fst ` set bs;\n        p \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> subst_typ [p] (Tv x1 x2) = Tv x1 x2", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   \\<And>v. v \\<in> tvsT ?x2a \\<Longrightarrow> v \\<notin> fst ` set bs;\n   p \\<in> set bs; p = (?a, ?b);\n   \\<And>v. v \\<in> tvsT ?x2a \\<Longrightarrow> v \\<notin> fst ` set bs;\n   p \\<in> set bs\\<rbrakk>\n  \\<Longrightarrow> subst_typ [p] ?x2a = ?x2a\n  ?v \\<in> tvsT (Ty n Ts) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n  p = (a, b)\n  ?v \\<in> tvsT (Ty n Ts) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 a b.\n       \\<lbrakk>\\<And>x2a a b.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    \\<And>v.\n                       v \\<in> tvsT x2a \\<Longrightarrow>\n                       v \\<notin> fst ` set bs;\n                    p \\<in> set bs; p = (a, b);\n                    \\<And>v.\n                       v \\<in> tvsT x2a \\<Longrightarrow>\n                       v \\<notin> fst ` set bs;\n                    p \\<in> set bs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ [p] x2a = x2a;\n        \\<And>v.\n           v \\<in> tvsT (Ty x1 x2) \\<Longrightarrow>\n           v \\<notin> fst ` set bs;\n        p \\<in> set bs; p = (a, b);\n        \\<And>v.\n           v \\<in> tvsT (Ty x1 x2) \\<Longrightarrow>\n           v \\<notin> fst ` set bs;\n        p \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> subst_typ [p] (Ty x1 x2) = Ty x1 x2\n 2. \\<And>x1 x2 a b.\n       \\<lbrakk>\\<And>v.\n                   v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n                   v \\<notin> fst ` set bs;\n        p \\<in> set bs; p = (a, b);\n        \\<And>v.\n           v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n           v \\<notin> fst ` set bs;\n        p \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> subst_typ [p] (Tv x1 x2) = Tv x1 x2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   \\<And>v. v \\<in> tvsT ?x2a \\<Longrightarrow> v \\<notin> fst ` set bs;\n   p \\<in> set bs; p = (?a, ?b);\n   \\<And>v. v \\<in> tvsT ?x2a \\<Longrightarrow> v \\<notin> fst ` set bs;\n   p \\<in> set bs\\<rbrakk>\n  \\<Longrightarrow> subst_typ [p] ?x2a = ?x2a\n  ?v \\<in> tvsT (Ty n Ts) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n  p = (a, b)\n  ?v \\<in> tvsT (Ty n Ts) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   \\<And>v. v \\<in> tvsT ?x2a \\<Longrightarrow> v \\<notin> fst ` set bs;\n   p \\<in> set bs; p = (?a, ?b);\n   \\<And>v. v \\<in> tvsT ?x2a \\<Longrightarrow> v \\<notin> fst ` set bs;\n   p \\<in> set bs\\<rbrakk>\n  \\<Longrightarrow> subst_typ [p] ?x2a = ?x2a\n  ?v \\<in> tvsT (Ty n Ts) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n  p = (a, b)\n  ?v \\<in> tvsT (Ty n Ts) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n\ngoal (1 subgoal):\n 1. subst_typ [p] (Ty n Ts) = Ty n Ts", "by (induction Ts) auto"], ["proof (state)\nthis:\n  subst_typ [p] (Ty n Ts) = Ty n Ts\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 a b.\n       \\<lbrakk>\\<And>v.\n                   v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n                   v \\<notin> fst ` set bs;\n        p \\<in> set bs; p = (a, b);\n        \\<And>v.\n           v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n           v \\<notin> fst ` set bs;\n        p \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> subst_typ [p] (Tv x1 x2) = Tv x1 x2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 a b.\n       \\<lbrakk>\\<And>v.\n                   v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n                   v \\<notin> fst ` set bs;\n        p \\<in> set bs; p = (a, b);\n        \\<And>v.\n           v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n           v \\<notin> fst ` set bs;\n        p \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> subst_typ [p] (Tv x1 x2) = Tv x1 x2", "case (Tv n S)"], ["proof (state)\nthis:\n  ?v \\<in> tvsT (Tv n S) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n  p = (a, b)\n  ?v \\<in> tvsT (Tv n S) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 a b.\n       \\<lbrakk>\\<And>v.\n                   v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n                   v \\<notin> fst ` set bs;\n        p \\<in> set bs; p = (a, b);\n        \\<And>v.\n           v \\<in> tvsT (Tv x1 x2) \\<Longrightarrow>\n           v \\<notin> fst ` set bs;\n        p \\<in> set bs\\<rbrakk>\n       \\<Longrightarrow> subst_typ [p] (Tv x1 x2) = Tv x1 x2", "then"], ["proof (chain)\npicking this:\n  ?v \\<in> tvsT (Tv n S) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n  p = (a, b)\n  ?v \\<in> tvsT (Tv n S) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs", "show ?case"], ["proof (prove)\nusing this:\n  ?v \\<in> tvsT (Tv n S) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n  p = (a, b)\n  ?v \\<in> tvsT (Tv n S) \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n\ngoal (1 subgoal):\n 1. subst_typ [p] (Tv n S) = Tv n S", "by force"], ["proof (state)\nthis:\n  subst_typ [p] (Tv n S) = Tv n S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p \\<in> set bs \\<Longrightarrow> subst_typ [?p] a = a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "hence bs_step: \"fold (\\<lambda>single. subst_typ [single]) bs a = a\""], ["proof (prove)\nusing this:\n  ?p \\<in> set bs \\<Longrightarrow> subst_typ [?p] a = a\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) bs a = a", "by (induction bs) auto"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) bs a = a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst inst);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set inst) \\<Longrightarrow>\n           x \\<notin> fst ` set inst;\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_typ inst (Tv idn S) =\n                         fold (\\<lambda>single. subst_typ [single]) inst\n                          (Tv idn S)", "from fs_step change_step bs_step split Some"], ["proof (chain)\npicking this:\n  fold (\\<lambda>single. subst_typ [single]) fs (Tv idn S) = Tv idn S\n  subst_typ [((idn, S), a)] (Tv idn S) = a\n  fold (\\<lambda>single. subst_typ [single]) bs a = a\n  inst = fs @ ((idn, S), a) # bs\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  fold (\\<lambda>single. subst_typ [single]) fs (Tv idn S) = Tv idn S\n  subst_typ [((idn, S), a)] (Tv idn S) = a\n  fold (\\<lambda>single. subst_typ [single]) bs a = a\n  inst = fs @ ((idn, S), a) # bs\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some a\n\ngoal (1 subgoal):\n 1. subst_typ inst (Tv idn S) =\n    fold (\\<lambda>single. subst_typ [single]) inst (Tv idn S)", "by simp"], ["proof (state)\nthis:\n  subst_typ inst (Tv idn S) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Tv idn S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_typ inst (Tv idn S) =\n  fold (\\<lambda>single. subst_typ [single]) inst (Tv idn S)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_typ_split_first:\n  assumes \"distinct (map fst (x#xs))\"\n  assumes \"\\<And>y . y \\<in> (\\<Union>t \\<in> snd ` set (x#xs) . tvsT t) \\<Longrightarrow> y \\<notin> fst ` (set (x#xs))\"\n  shows \"subst_typ (x#xs) T = subst_typ xs (subst_typ [x] T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)", "have \"subst_typ (x#xs) T = fold (\\<lambda>single . subst_typ [single]) (x#xs) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T =\n    fold (\\<lambda>single. subst_typ [single]) (x # xs) T", "using assms subst_typ_stepwise"], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n  ?y \\<in> tvsT_Set (snd ` set (x # xs)) \\<Longrightarrow>\n  ?y \\<notin> fst ` set (x # xs)\n  \\<lbrakk>distinct (map fst ?instT);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set ?instT) \\<Longrightarrow>\n      x \\<notin> fst ` set ?instT\\<rbrakk>\n  \\<Longrightarrow> subst_typ ?instT ?T =\n                    fold (\\<lambda>single. subst_typ [single]) ?instT ?T\n\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T =\n    fold (\\<lambda>single. subst_typ [single]) (x # xs) T", "by blast"], ["proof (state)\nthis:\n  subst_typ (x # xs) T =\n  fold (\\<lambda>single. subst_typ [single]) (x # xs) T\n\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)", "also"], ["proof (state)\nthis:\n  subst_typ (x # xs) T =\n  fold (\\<lambda>single. subst_typ [single]) (x # xs) T\n\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)", "have \"\\<dots> = fold (\\<lambda>single . subst_typ [single]) xs (subst_typ [x] T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) (x # xs) T =\n    fold (\\<lambda>single. subst_typ [single]) xs (subst_typ [x] T)", "by simp"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) (x # xs) T =\n  fold (\\<lambda>single. subst_typ [single]) xs (subst_typ [x] T)\n\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)", "also"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) (x # xs) T =\n  fold (\\<lambda>single. subst_typ [single]) xs (subst_typ [x] T)\n\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)", "have \"\\<dots> = subst_typ xs (subst_typ [x] T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) xs (subst_typ [x] T) =\n    subst_typ xs (subst_typ [x] T)", "using assms subst_typ_stepwise"], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n  ?y \\<in> tvsT_Set (snd ` set (x # xs)) \\<Longrightarrow>\n  ?y \\<notin> fst ` set (x # xs)\n  \\<lbrakk>distinct (map fst ?instT);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set ?instT) \\<Longrightarrow>\n      x \\<notin> fst ` set ?instT\\<rbrakk>\n  \\<Longrightarrow> subst_typ ?instT ?T =\n                    fold (\\<lambda>single. subst_typ [single]) ?instT ?T\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) xs (subst_typ [x] T) =\n    subst_typ xs (subst_typ [x] T)", "by simp"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) xs (subst_typ [x] T) =\n  subst_typ xs (subst_typ [x] T)\n\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)", "finally"], ["proof (chain)\npicking this:\n  subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)\n\ngoal (1 subgoal):\n 1. subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)", "."], ["proof (state)\nthis:\n  subst_typ (x # xs) T = subst_typ xs (subst_typ [x] T)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_typ_split_last:\n  assumes \"distinct (map fst (xs @ [x]))\"\n  assumes \"\\<And>y . y \\<in> (\\<Union>t \\<in> snd ` (set (xs @ [x])) . tvsT t) \\<Longrightarrow> y \\<notin> fst ` (set (xs @ [x]))\"\n  shows \"subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)", "have \"subst_typ (xs @ [x]) T = fold (\\<lambda>single . subst_typ [single]) (xs@[x]) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T =\n    fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) T", "using assms subst_typ_stepwise"], ["proof (prove)\nusing this:\n  distinct (map fst (xs @ [x]))\n  ?y \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?y \\<notin> fst ` set (xs @ [x])\n  \\<lbrakk>distinct (map fst ?instT);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set ?instT) \\<Longrightarrow>\n      x \\<notin> fst ` set ?instT\\<rbrakk>\n  \\<Longrightarrow> subst_typ ?instT ?T =\n                    fold (\\<lambda>single. subst_typ [single]) ?instT ?T\n\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T =\n    fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) T", "by blast"], ["proof (state)\nthis:\n  subst_typ (xs @ [x]) T =\n  fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) T\n\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)", "also"], ["proof (state)\nthis:\n  subst_typ (xs @ [x]) T =\n  fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) T\n\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)", "have \"\\<dots> = subst_typ [x] (fold (\\<lambda>single . subst_typ [single]) xs T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) T =\n    subst_typ [x] (fold (\\<lambda>single. subst_typ [single]) xs T)", "by simp"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) T =\n  subst_typ [x] (fold (\\<lambda>single. subst_typ [single]) xs T)\n\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)", "also"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_typ [single]) (xs @ [x]) T =\n  subst_typ [x] (fold (\\<lambda>single. subst_typ [single]) xs T)\n\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)", "have \"\\<dots> = subst_typ [x] (subst_typ xs T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [x] (fold (\\<lambda>single. subst_typ [single]) xs T) =\n    subst_typ [x] (subst_typ xs T)", "using assms subst_typ_stepwise"], ["proof (prove)\nusing this:\n  distinct (map fst (xs @ [x]))\n  ?y \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?y \\<notin> fst ` set (xs @ [x])\n  \\<lbrakk>distinct (map fst ?instT);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set ?instT) \\<Longrightarrow>\n      x \\<notin> fst ` set ?instT\\<rbrakk>\n  \\<Longrightarrow> subst_typ ?instT ?T =\n                    fold (\\<lambda>single. subst_typ [single]) ?instT ?T\n\ngoal (1 subgoal):\n 1. subst_typ [x] (fold (\\<lambda>single. subst_typ [single]) xs T) =\n    subst_typ [x] (subst_typ xs T)", "by simp"], ["proof (state)\nthis:\n  subst_typ [x] (fold (\\<lambda>single. subst_typ [single]) xs T) =\n  subst_typ [x] (subst_typ xs T)\n\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)", "finally"], ["proof (chain)\npicking this:\n  subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)\n\ngoal (1 subgoal):\n 1. subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)", "."], ["proof (state)\nthis:\n  subst_typ (xs @ [x]) T = subst_typ [x] (subst_typ xs T)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_typ'_stepwise:\n  assumes \"distinct (map fst instT)\"\n  assumes \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` (set instT) . tvsT t) \\<Longrightarrow> x \\<notin> fst ` (set instT)\"\n  shows \"subst_typ' instT t = fold (\\<lambda>single acc . subst_typ' [single] acc) instT t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' instT t = fold (\\<lambda>single. subst_typ' [single]) instT t", "(* I switched the order of inductions and 99% of the proof vanished *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' instT t = fold (\\<lambda>single. subst_typ' [single]) instT t", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst instT)\n  ?x \\<in> tvsT_Set (snd ` set instT) \\<Longrightarrow>\n  ?x \\<notin> fst ` set instT\n\ngoal (1 subgoal):\n 1. subst_typ' instT t = fold (\\<lambda>single. subst_typ' [single]) instT t", "proof (induction instT arbitrary: t rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>distinct (map fst []);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set []) \\<Longrightarrow>\n           x \\<notin> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [] t =\n                         fold (\\<lambda>single. subst_typ' [single]) [] t\n 2. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) t", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n  ?x \\<in> tvsT_Set (snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>distinct (map fst []);\n        \\<And>x.\n           x \\<in> tvsT_Set (snd ` set []) \\<Longrightarrow>\n           x \\<notin> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [] t =\n                         fold (\\<lambda>single. subst_typ' [single]) [] t\n 2. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) t", "then"], ["proof (chain)\npicking this:\n  distinct (map fst [])\n  ?x \\<in> tvsT_Set (snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n  ?x \\<in> tvsT_Set (snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []\n\ngoal (1 subgoal):\n 1. subst_typ' [] t = fold (\\<lambda>single. subst_typ' [single]) [] t", "by simp"], ["proof (state)\nthis:\n  subst_typ' [] t = fold (\\<lambda>single. subst_typ' [single]) [] t\n\ngoal (1 subgoal):\n 1. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) t", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_typ' xs ?t =\n                    fold (\\<lambda>single. subst_typ' [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_typ' xs ?t =\n                    fold (\\<lambda>single. subst_typ' [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_typ' xs ?t =\n                    fold (\\<lambda>single. subst_typ' [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])\n\ngoal (1 subgoal):\n 1. subst_typ' (xs @ [x]) t =\n    fold (\\<lambda>single. subst_typ' [single]) (xs @ [x]) t", "apply (induction t)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (Ct x1 x2) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (Fv x1 x2) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (Fv x1 x2)\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (Bv xa) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (Bv xa)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> tvsT_Set\n   (snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_typ' xs t =\n        fold (\\<lambda>single. subst_typ' [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> tvsT_Set\n                              (snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_typ' (xs @ [x]) t =\n                                  fold\n                                   (\\<lambda>single. subst_typ' [single])\n                                   (xs @ [x]) t;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_typ' xs t =\n                             fold (\\<lambda>single. subst_typ' [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (Abs x1 t) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> tvsT_Set\n   (snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_typ' xs t =\n        fold (\\<lambda>single. subst_typ' [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> tvsT_Set\n                              (snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_typ' (xs @ [x]) t1 =\n                                  fold\n                                   (\\<lambda>single. subst_typ' [single])\n                                   (xs @ [x]) t1;\n        \\<lbrakk>\\<And>t.\n                    \\<lbrakk>distinct (map fst xs);\n                     \\<And>x.\n                        x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                        x \\<notin> fst ` set xs\\<rbrakk>\n                    \\<Longrightarrow> subst_typ' xs t =\nfold (\\<lambda>single. subst_typ' [single]) xs t;\n         distinct (map fst (xs @ [x]));\n         \\<And>xa.\n            xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n            xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n        \\<Longrightarrow> subst_typ' (xs @ [x]) t2 =\n                          fold (\\<lambda>single. subst_typ' [single])\n                           (xs @ [x]) t2;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_typ' xs t =\n                             fold (\\<lambda>single. subst_typ' [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (t1 $ t2) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (t1 $ t2)", "using subst_typ_split_last"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst (?xs @ [?x]));\n   \\<And>y.\n      y \\<in> tvsT_Set (snd ` set (?xs @ [?x])) \\<Longrightarrow>\n      y \\<notin> fst ` set (?xs @ [?x])\\<rbrakk>\n  \\<Longrightarrow> subst_typ (?xs @ [?x]) ?T =\n                    subst_typ [?x] (subst_typ ?xs ?T)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (Ct x1 x2) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (Fv x1 x2) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (Fv x1 x2)\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' xs t =\n                                     fold\n(\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (Bv xa) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (Bv xa)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> tvsT_Set\n   (snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_typ' xs t =\n        fold (\\<lambda>single. subst_typ' [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> tvsT_Set\n                              (snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_typ' (xs @ [x]) t =\n                                  fold\n                                   (\\<lambda>single. subst_typ' [single])\n                                   (xs @ [x]) t;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_typ' xs t =\n                             fold (\\<lambda>single. subst_typ' [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (Abs x1 t) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> tvsT_Set\n   (snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_typ' xs t =\n        fold (\\<lambda>single. subst_typ' [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> tvsT_Set\n                              (snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_typ' (xs @ [x]) t1 =\n                                  fold\n                                   (\\<lambda>single. subst_typ' [single])\n                                   (xs @ [x]) t1;\n        \\<lbrakk>\\<And>t.\n                    \\<lbrakk>distinct (map fst xs);\n                     \\<And>x.\n                        x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n                        x \\<notin> fst ` set xs\\<rbrakk>\n                    \\<Longrightarrow> subst_typ' xs t =\nfold (\\<lambda>single. subst_typ' [single]) xs t;\n         distinct (map fst (xs @ [x]));\n         \\<And>xa.\n            xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n            xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n        \\<Longrightarrow> subst_typ' (xs @ [x]) t2 =\n                          fold (\\<lambda>single. subst_typ' [single])\n                           (xs @ [x]) t2;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_typ' xs t =\n                             fold (\\<lambda>single. subst_typ' [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> tvsT_Set (snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_typ' (xs @ [x]) (t1 $ t2) =\n                         fold (\\<lambda>single. subst_typ' [single])\n                          (xs @ [x]) (t1 $ t2)", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   subst_typ' xs t =\n                   fold (\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst xs) \\<and> fst x \\<notin> fst ` set xs;\n        \\<And>xa.\n           xa \\<in> tvsT (snd x) \\<or>\n           (\\<exists>x\\<in>set xs. xa \\<in> tvsT (snd x)) \\<Longrightarrow>\n           xa \\<noteq> fst x \\<and> xa \\<notin> fst ` set xs;\n        \\<And>xs x T.\n           \\<lbrakk>distinct (map fst xs) \\<and>\n                    fst x \\<notin> fst ` set xs;\n            \\<And>y.\n               y \\<in> tvsT (snd x) \\<or>\n               (\\<exists>x\\<in>set xs.\n                   y \\<in> tvsT (snd x)) \\<Longrightarrow>\n               y \\<noteq> fst x \\<and> y \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_typ (xs @ [x]) T =\n                             subst_typ [x] (subst_typ xs T)\\<rbrakk>\n       \\<Longrightarrow> Ct x1 (subst_typ [x] (subst_typ xs x2)) =\n                         subst_typ' [x]\n                          (fold (\\<lambda>single. subst_typ' [single]) xs\n                            (Ct x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   subst_typ' xs t =\n                   fold (\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst xs) \\<and> fst x \\<notin> fst ` set xs;\n        \\<And>xa.\n           xa \\<in> tvsT (snd x) \\<or>\n           (\\<exists>x\\<in>set xs. xa \\<in> tvsT (snd x)) \\<Longrightarrow>\n           xa \\<noteq> fst x \\<and> xa \\<notin> fst ` set xs;\n        \\<And>xs x T.\n           \\<lbrakk>distinct (map fst xs) \\<and>\n                    fst x \\<notin> fst ` set xs;\n            \\<And>y.\n               y \\<in> tvsT (snd x) \\<or>\n               (\\<exists>x\\<in>set xs.\n                   y \\<in> tvsT (snd x)) \\<Longrightarrow>\n               y \\<noteq> fst x \\<and> y \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_typ (xs @ [x]) T =\n                             subst_typ [x] (subst_typ xs T)\\<rbrakk>\n       \\<Longrightarrow> Fv x1 (subst_typ [x] (subst_typ xs x2)) =\n                         subst_typ' [x]\n                          (fold (\\<lambda>single. subst_typ' [single]) xs\n                            (Fv x1 x2))\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   subst_typ' xs t =\n                   fold (\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst xs) \\<and> fst x \\<notin> fst ` set xs;\n        \\<And>xa.\n           xa \\<in> tvsT (snd x) \\<or>\n           (\\<exists>x\\<in>set xs. xa \\<in> tvsT (snd x)) \\<Longrightarrow>\n           xa \\<noteq> fst x \\<and> xa \\<notin> fst ` set xs;\n        \\<And>xs x T.\n           \\<lbrakk>distinct (map fst xs) \\<and>\n                    fst x \\<notin> fst ` set xs;\n            \\<And>y.\n               y \\<in> tvsT (snd x) \\<or>\n               (\\<exists>x\\<in>set xs.\n                   y \\<in> tvsT (snd x)) \\<Longrightarrow>\n               y \\<noteq> fst x \\<and> y \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_typ (xs @ [x]) T =\n                             subst_typ [x] (subst_typ xs T)\\<rbrakk>\n       \\<Longrightarrow> Bv xa =\n                         subst_typ' [x]\n                          (fold (\\<lambda>single. subst_typ' [single]) xs\n                            (Bv xa))\n 4. \\<And>x1 t.\n       \\<lbrakk>subst_typ' (xs @ [x]) t =\n                subst_typ' [x]\n                 (fold (\\<lambda>single. subst_typ' [single]) xs t);\n        \\<And>t.\n           subst_typ' xs t =\n           fold (\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst xs) \\<and> fst x \\<notin> fst ` set xs;\n        \\<And>xa.\n           xa \\<in> tvsT (snd x) \\<or>\n           (\\<exists>x\\<in>set xs. xa \\<in> tvsT (snd x)) \\<Longrightarrow>\n           xa \\<noteq> fst x \\<and> xa \\<notin> fst ` set xs;\n        \\<And>xs x T.\n           \\<lbrakk>distinct (map fst xs) \\<and>\n                    fst x \\<notin> fst ` set xs;\n            \\<And>y.\n               y \\<in> tvsT (snd x) \\<or>\n               (\\<exists>x\\<in>set xs.\n                   y \\<in> tvsT (snd x)) \\<Longrightarrow>\n               y \\<noteq> fst x \\<and> y \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_typ (xs @ [x]) T =\n                             subst_typ [x] (subst_typ xs T)\\<rbrakk>\n       \\<Longrightarrow> Abs (subst_typ [x] (subst_typ xs x1))\n                          (subst_typ' [x]\n                            (fold (\\<lambda>single. subst_typ' [single]) xs\n                              t)) =\n                         subst_typ' [x]\n                          (fold (\\<lambda>single. subst_typ' [single]) xs\n                            (Abs x1 t))\n 5. \\<And>t1 t2.\n       \\<lbrakk>subst_typ' (xs @ [x]) t1 =\n                subst_typ' [x]\n                 (fold (\\<lambda>single. subst_typ' [single]) xs t1);\n        subst_typ' (xs @ [x]) t2 =\n        subst_typ' [x] (fold (\\<lambda>single. subst_typ' [single]) xs t2);\n        \\<And>t.\n           subst_typ' xs t =\n           fold (\\<lambda>single. subst_typ' [single]) xs t;\n        distinct (map fst xs) \\<and> fst x \\<notin> fst ` set xs;\n        \\<And>xa.\n           xa \\<in> tvsT (snd x) \\<or>\n           (\\<exists>x\\<in>set xs. xa \\<in> tvsT (snd x)) \\<Longrightarrow>\n           xa \\<noteq> fst x \\<and> xa \\<notin> fst ` set xs;\n        \\<And>xs x T.\n           \\<lbrakk>distinct (map fst xs) \\<and>\n                    fst x \\<notin> fst ` set xs;\n            \\<And>y.\n               y \\<in> tvsT (snd x) \\<or>\n               (\\<exists>x\\<in>set xs.\n                   y \\<in> tvsT (snd x)) \\<Longrightarrow>\n               y \\<noteq> fst x \\<and> y \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_typ (xs @ [x]) T =\n                             subst_typ [x] (subst_typ xs T)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [x]\n                          (fold (\\<lambda>single. subst_typ' [single]) xs\n                            t1) $\n                         subst_typ' [x]\n                          (fold (\\<lambda>single. subst_typ' [single]) xs\n                            t2) =\n                         subst_typ' [x]\n                          (fold (\\<lambda>single. subst_typ' [single]) xs\n                            (t1 $ t2))", "apply (metis map_types.simps)+"], ["proof (prove)\ngoal:\nNo subgoals!", "(* ... *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst_typ' (xs @ [x]) t =\n  fold (\\<lambda>single. subst_typ' [single]) (xs @ [x]) t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_term_stepwise:\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` (set insts) . fv t) \\<Longrightarrow> x \\<notin> fst ` (set insts)\"\n  shows \"subst_term insts t = fold (\\<lambda>single acc . subst_term [single] acc) insts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term insts t = fold (\\<lambda>single. subst_term [single]) insts t", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst insts)\n  ?x \\<in> \\<Union> (fv ` snd ` set insts) \\<Longrightarrow>\n  ?x \\<notin> fst ` set insts\n\ngoal (1 subgoal):\n 1. subst_term insts t = fold (\\<lambda>single. subst_term [single]) insts t", "proof (induction insts arbitrary: t rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>distinct (map fst []);\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n           x \\<notin> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> subst_term [] t =\n                         fold (\\<lambda>single. subst_term [single]) [] t\n 2. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) t", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n  ?x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>distinct (map fst []);\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n           x \\<notin> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> subst_term [] t =\n                         fold (\\<lambda>single. subst_term [single]) [] t\n 2. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) t", "then"], ["proof (chain)\npicking this:\n  distinct (map fst [])\n  ?x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n  ?x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []\n\ngoal (1 subgoal):\n 1. subst_term [] t = fold (\\<lambda>single. subst_term [single]) [] t", "by simp"], ["proof (state)\nthis:\n  subst_term [] t = fold (\\<lambda>single. subst_term [single]) [] t\n\ngoal (1 subgoal):\n 1. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) t", "case (snoc x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) t =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t =\n    fold (\\<lambda>single. subst_term [single]) (xs @ [x]) t", "proof (induction t)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Ct x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv x1 x2)\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Bv xa) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Bv xa)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Abs x1 t) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t1 =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t1;\n        \\<lbrakk>\\<And>t.\n                    \\<lbrakk>distinct (map fst xs);\n                     \\<And>x.\n                        x \\<in> \\<Union>\n                                 (fv ` snd ` set xs) \\<Longrightarrow>\n                        x \\<notin> fst ` set xs\\<rbrakk>\n                    \\<Longrightarrow> subst_term xs t =\nfold (\\<lambda>single. subst_term [single]) xs t;\n         distinct (map fst (xs @ [x]));\n         \\<And>xa.\n            xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n            xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n        \\<Longrightarrow> subst_term (xs @ [x]) t2 =\n                          fold (\\<lambda>single. subst_term [single])\n                           (xs @ [x]) t2;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (t1 $ t2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (t1 $ t2)", "case (Fv idn T)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Ct x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv x1 x2)\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Bv xa) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Bv xa)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Abs x1 t) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t1 =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t1;\n        \\<lbrakk>\\<And>t.\n                    \\<lbrakk>distinct (map fst xs);\n                     \\<And>x.\n                        x \\<in> \\<Union>\n                                 (fv ` snd ` set xs) \\<Longrightarrow>\n                        x \\<notin> fst ` set xs\\<rbrakk>\n                    \\<Longrightarrow> subst_term xs t =\nfold (\\<lambda>single. subst_term [single]) xs t;\n         distinct (map fst (xs @ [x]));\n         \\<And>xa.\n            xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n            xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n        \\<Longrightarrow> subst_term (xs @ [x]) t2 =\n                          fold (\\<lambda>single. subst_term [single])\n                           (xs @ [x]) t2;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (t1 $ t2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (t1 $ t2)", "(* Allows more direct copy paste, hide structure of list, do proof properly later *)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Ct x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv x1 x2)\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Bv xa) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Bv xa)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Abs x1 t) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t1 =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t1;\n        \\<lbrakk>\\<And>t.\n                    \\<lbrakk>distinct (map fst xs);\n                     \\<And>x.\n                        x \\<in> \\<Union>\n                                 (fv ` snd ` set xs) \\<Longrightarrow>\n                        x \\<notin> fst ` set xs\\<rbrakk>\n                    \\<Longrightarrow> subst_term xs t =\nfold (\\<lambda>single. subst_term [single]) xs t;\n         distinct (map fst (xs @ [x]));\n         \\<And>xa.\n            xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n            xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n        \\<Longrightarrow> subst_term (xs @ [x]) t2 =\n                          fold (\\<lambda>single. subst_term [single])\n                           (xs @ [x]) t2;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (t1 $ t2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (t1 $ t2)", "define insts where insts_def: \"insts = xs @ [x]\""], ["proof (state)\nthis:\n  insts = xs @ [x]\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Ct x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv x1 x2)\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Bv xa) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Bv xa)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Abs x1 t) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t1 =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t1;\n        \\<lbrakk>\\<And>t.\n                    \\<lbrakk>distinct (map fst xs);\n                     \\<And>x.\n                        x \\<in> \\<Union>\n                                 (fv ` snd ` set xs) \\<Longrightarrow>\n                        x \\<notin> fst ` set xs\\<rbrakk>\n                    \\<Longrightarrow> subst_term xs t =\nfold (\\<lambda>single. subst_term [single]) xs t;\n         distinct (map fst (xs @ [x]));\n         \\<And>xa.\n            xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n            xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n        \\<Longrightarrow> subst_term (xs @ [x]) t2 =\n                          fold (\\<lambda>single. subst_term [single])\n                           (xs @ [x]) t2;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (t1 $ t2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (t1 $ t2)", "have insts_thm1: \"distinct (map fst insts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst insts)", "using insts_def snoc"], ["proof (prove)\nusing this:\n  insts = xs @ [x]\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])\n\ngoal (1 subgoal):\n 1. distinct (map fst insts)", "by simp"], ["proof (state)\nthis:\n  distinct (map fst insts)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Ct x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv x1 x2)\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Bv xa) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Bv xa)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Abs x1 t) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t1 =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t1;\n        \\<lbrakk>\\<And>t.\n                    \\<lbrakk>distinct (map fst xs);\n                     \\<And>x.\n                        x \\<in> \\<Union>\n                                 (fv ` snd ` set xs) \\<Longrightarrow>\n                        x \\<notin> fst ` set xs\\<rbrakk>\n                    \\<Longrightarrow> subst_term xs t =\nfold (\\<lambda>single. subst_term [single]) xs t;\n         distinct (map fst (xs @ [x]));\n         \\<And>xa.\n            xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n            xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n        \\<Longrightarrow> subst_term (xs @ [x]) t2 =\n                          fold (\\<lambda>single. subst_term [single])\n                           (xs @ [x]) t2;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (t1 $ t2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (t1 $ t2)", "have insts_thm2: \"x \\<notin> fst ` set insts\" if \"x \\<in> \\<Union> (fv ` snd ` set insts)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set insts", "using insts_def snoc that"], ["proof (prove)\nusing this:\n  insts = xs @ [x__]\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x__]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x__])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x__])\n  x \\<in> \\<Union> (fv ` snd ` set insts)\n\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set insts", "by blast"], ["proof (state)\nthis:\n  ?x \\<in> \\<Union> (fv ` snd ` set insts) \\<Longrightarrow>\n  ?x \\<notin> fst ` set insts\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Ct x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Ct x1 x2)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv x1 x2)\n 3. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Bv xa) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Bv xa)\n 4. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Abs x1 t) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Abs x1 t)\n 5. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t1 =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t1;\n        \\<lbrakk>\\<And>t.\n                    \\<lbrakk>distinct (map fst xs);\n                     \\<And>x.\n                        x \\<in> \\<Union>\n                                 (fv ` snd ` set xs) \\<Longrightarrow>\n                        x \\<notin> fst ` set xs\\<rbrakk>\n                    \\<Longrightarrow> subst_term xs t =\nfold (\\<lambda>single. subst_term [single]) xs t;\n         distinct (map fst (xs @ [x]));\n         \\<And>xa.\n            xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n            xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n        \\<Longrightarrow> subst_term (xs @ [x]) t2 =\n                          fold (\\<lambda>single. subst_term [single])\n                           (xs @ [x]) t2;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (t1 $ t2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (t1 $ t2)", "from Fv"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) (Fv idn T) =\n    fold (\\<lambda>single. subst_term [single]) (xs @ [x]) (Fv idn T)", "(* Proof copied from subst_typ *)"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> subst_term xs ?t =\n                    fold (\\<lambda>single. subst_term [single]) xs ?t\n  distinct (map fst (xs @ [x]))\n  ?x \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (xs @ [x])\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) (Fv idn T) =\n    fold (\\<lambda>single. subst_term [single]) (xs @ [x]) (Fv idn T)", "proof (cases \"lookup (\\<lambda>x . x = (idn, T)) insts\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (map fst xs);\n                 \\<And>x.\n                    x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n                    x \\<notin> fst ` set xs\\<rbrakk>\n                \\<Longrightarrow> subst_term xs t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single]) xs\n                                   t;\n     distinct (map fst (xs @ [x]));\n     \\<And>xa.\n        xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n        xa \\<notin> fst ` set (xs @ [x]);\n     lookup (\\<lambda>x. x = (idn, T)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                      fold (\\<lambda>single. subst_term [single]) (xs @ [x])\n                       (Fv idn T)\n 2. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "case None"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, T)) insts = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (map fst xs);\n                 \\<And>x.\n                    x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n                    x \\<notin> fst ` set xs\\<rbrakk>\n                \\<Longrightarrow> subst_term xs t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single]) xs\n                                   t;\n     distinct (map fst (xs @ [x]));\n     \\<And>xa.\n        xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n        xa \\<notin> fst ` set (xs @ [x]);\n     lookup (\\<lambda>x. x = (idn, T)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                      fold (\\<lambda>single. subst_term [single]) (xs @ [x])\n                       (Fv idn T)\n 2. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "hence \"fst p \\<noteq> (idn, T)\" if \"p\\<in>set insts\" for p"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, T)) insts = None\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, T)", "using that"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, T)) insts = None\n  p \\<in> set insts\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, T)", "by (auto simp add: lookup_None_iff)"], ["proof (state)\nthis:\n  ?p \\<in> set insts \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (map fst xs);\n                 \\<And>x.\n                    x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n                    x \\<notin> fst ` set xs\\<rbrakk>\n                \\<Longrightarrow> subst_term xs t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single]) xs\n                                   t;\n     distinct (map fst (xs @ [x]));\n     \\<And>xa.\n        xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n        xa \\<notin> fst ` set (xs @ [x]);\n     lookup (\\<lambda>x. x = (idn, T)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                      fold (\\<lambda>single. subst_term [single]) (xs @ [x])\n                       (Fv idn T)\n 2. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "hence \"subst_term [p] (Fv idn T) = Fv idn T\" if \"p\\<in>set insts\" for p"], ["proof (prove)\nusing this:\n  ?p \\<in> set insts \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n\ngoal (1 subgoal):\n 1. subst_term [p] (Fv idn T) = Fv idn T", "using that"], ["proof (prove)\nusing this:\n  ?p \\<in> set insts \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n  p \\<in> set insts\n\ngoal (1 subgoal):\n 1. subst_term [p] (Fv idn T) = Fv idn T", "by (cases p) fastforce"], ["proof (state)\nthis:\n  ?p \\<in> set insts \\<Longrightarrow> subst_term [?p] (Fv idn T) = Fv idn T\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>distinct (map fst xs);\n                 \\<And>x.\n                    x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n                    x \\<notin> fst ` set xs\\<rbrakk>\n                \\<Longrightarrow> subst_term xs t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single]) xs\n                                   t;\n     distinct (map fst (xs @ [x]));\n     \\<And>xa.\n        xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n        xa \\<notin> fst ` set (xs @ [x]);\n     lookup (\\<lambda>x. x = (idn, T)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                      fold (\\<lambda>single. subst_term [single]) (xs @ [x])\n                       (Fv idn T)\n 2. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "from this None"], ["proof (chain)\npicking this:\n  ?p \\<in> set insts \\<Longrightarrow> subst_term [?p] (Fv idn T) = Fv idn T\n  lookup (\\<lambda>x. x = (idn, T)) insts = None", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p \\<in> set insts \\<Longrightarrow> subst_term [?p] (Fv idn T) = Fv idn T\n  lookup (\\<lambda>x. x = (idn, T)) insts = None\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) (Fv idn T) =\n    fold (\\<lambda>single. subst_term [single]) (xs @ [x]) (Fv idn T)", "unfolding insts_def[symmetric]"], ["proof (prove)\nusing this:\n  ?p \\<in> set insts \\<Longrightarrow> subst_term [?p] (Fv idn T) = Fv idn T\n  lookup (\\<lambda>x. x = (idn, T)) insts = None\n\ngoal (1 subgoal):\n 1. subst_term insts (Fv idn T) =\n    fold (\\<lambda>single. subst_term [single]) insts (Fv idn T)", "by (induction insts) (auto split: if_splits)"], ["proof (state)\nthis:\n  subst_term (xs @ [x]) (Fv idn T) =\n  fold (\\<lambda>single. subst_term [single]) (xs @ [x]) (Fv idn T)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "case (Some a)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, T)) insts = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "have elem: \"((idn, T), a) \\<in> set insts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((idn, T), a) \\<in> set insts", "using Some lookup_present_eq_key'' insts_thm1"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, T)) insts = Some a\n  distinct (map fst ?al) \\<Longrightarrow>\n  (lookup (\\<lambda>x. x = ?k) ?al = Some ?v) = ((?k, ?v) \\<in> set ?al)\n  distinct (map fst insts)\n\ngoal (1 subgoal):\n 1. ((idn, T), a) \\<in> set insts", "by fastforce"], ["proof (state)\nthis:\n  ((idn, T), a) \\<in> set insts\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "from this"], ["proof (chain)\npicking this:\n  ((idn, T), a) \\<in> set insts", "obtain fs bs where split: \"insts = fs @ ((idn, T), a) # bs\""], ["proof (prove)\nusing this:\n  ((idn, T), a) \\<in> set insts\n\ngoal (1 subgoal):\n 1. (\\<And>fs bs.\n        insts = fs @ ((idn, T), a) # bs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  insts = fs @ ((idn, T), a) # bs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "hence \"(idn, T) \\<notin> set (map fst fs)\" and \"(idn, T) \\<notin> set (map fst bs)\""], ["proof (prove)\nusing this:\n  insts = fs @ ((idn, T), a) # bs\n\ngoal (1 subgoal):\n 1. (idn, T) \\<notin> set (map fst fs) &&&\n    (idn, T) \\<notin> set (map fst bs)", "using insts_thm1"], ["proof (prove)\nusing this:\n  insts = fs @ ((idn, T), a) # bs\n  distinct (map fst insts)\n\ngoal (1 subgoal):\n 1. (idn, T) \\<notin> set (map fst fs) &&&\n    (idn, T) \\<notin> set (map fst bs)", "by simp_all"], ["proof (state)\nthis:\n  (idn, T) \\<notin> set (map fst fs)\n  (idn, T) \\<notin> set (map fst bs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "hence \"fst p ~= (idn, T)\" if \"p\\<in>set fs\" for p"], ["proof (prove)\nusing this:\n  (idn, T) \\<notin> set (map fst fs)\n  (idn, T) \\<notin> set (map fst bs)\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, T)", "using that"], ["proof (prove)\nusing this:\n  (idn, T) \\<notin> set (map fst fs)\n  (idn, T) \\<notin> set (map fst bs)\n  p \\<in> set fs\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, T)", "by force"], ["proof (state)\nthis:\n  ?p \\<in> set fs \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "hence id_subst_fs: \"subst_term [p] (Fv idn T) = Fv idn T\" if \"p\\<in>set fs\" for p"], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n\ngoal (1 subgoal):\n 1. subst_term [p] (Fv idn T) = Fv idn T", "using that"], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n  p \\<in> set fs\n\ngoal (1 subgoal):\n 1. subst_term [p] (Fv idn T) = Fv idn T", "by (cases p) fastforce"], ["proof (state)\nthis:\n  ?p \\<in> set fs \\<Longrightarrow> subst_term [?p] (Fv idn T) = Fv idn T\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "hence fs_step: \"fold (\\<lambda>single. subst_term [single]) fs (Fv idn T) = Fv idn T\""], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> subst_term [?p] (Fv idn T) = Fv idn T\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_term [single]) fs (Fv idn T) = Fv idn T", "by (induction fs) (auto split: if_splits)"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_term [single]) fs (Fv idn T) = Fv idn T\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "have change_step: \"subst_term [((idn, T), a)] (Fv idn T) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term [((idn, T), a)] (Fv idn T) = a", "by simp"], ["proof (state)\nthis:\n  subst_term [((idn, T), a)] (Fv idn T) = a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "have bs_sub: \"set bs \\<subseteq> set insts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set bs \\<subseteq> set insts", "using split"], ["proof (prove)\nusing this:\n  insts = fs @ ((idn, T), a) # bs\n\ngoal (1 subgoal):\n 1. set bs \\<subseteq> set insts", "by auto"], ["proof (state)\nthis:\n  set bs \\<subseteq> set insts\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "hence \"x \\<notin> fst ` set bs\" \n        if \"x\\<in> \\<Union> (fv ` snd ` set bs)\" for x"], ["proof (prove)\nusing this:\n  set bs \\<subseteq> set insts\n\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set bs", "using insts_thm2 that split"], ["proof (prove)\nusing this:\n  set bs \\<subseteq> set insts\n  ?x \\<in> \\<Union> (fv ` snd ` set insts) \\<Longrightarrow>\n  ?x \\<notin> fst ` set insts\n  x \\<in> \\<Union> (fv ` snd ` set bs)\n  insts = fs @ ((idn, T), a) # bs\n\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set bs", "by (auto simp add: image_iff)"], ["proof (state)\nthis:\n  ?x \\<in> \\<Union> (fv ` snd ` set bs) \\<Longrightarrow>\n  ?x \\<notin> fst ` set bs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "have \"v \\<notin> fst ` set bs\" if \"v \\<in> fv a\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> fst ` set bs", "using that insts_thm2 elem bs_sub"], ["proof (prove)\nusing this:\n  v \\<in> fv a\n  ?x \\<in> \\<Union> (fv ` snd ` set insts) \\<Longrightarrow>\n  ?x \\<notin> fst ` set insts\n  ((idn, T), a) \\<in> set insts\n  set bs \\<subseteq> set insts\n\ngoal (1 subgoal):\n 1. v \\<notin> fst ` set bs", "by (fastforce simp add: image_iff)"], ["proof (state)\nthis:\n  ?v \\<in> fv a \\<Longrightarrow> ?v \\<notin> fst ` set bs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "hence id_subst_bs: \"subst_term [p] a = a\" if \"p\\<in>set bs\" for p"], ["proof (prove)\nusing this:\n  ?v \\<in> fv a \\<Longrightarrow> ?v \\<notin> fst ` set bs\n\ngoal (1 subgoal):\n 1. subst_term [p] a = a", "using that"], ["proof (prove)\nusing this:\n  ?v \\<in> fv a \\<Longrightarrow> ?v \\<notin> fst ` set bs\n  p \\<in> set bs\n\ngoal (1 subgoal):\n 1. subst_term [p] a = a", "by (cases p, induction a) force+"], ["proof (state)\nthis:\n  ?p \\<in> set bs \\<Longrightarrow> subst_term [?p] a = a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "hence bs_step: \"fold (\\<lambda>single. subst_term [single]) bs a = a\""], ["proof (prove)\nusing this:\n  ?p \\<in> set bs \\<Longrightarrow> subst_term [?p] a = a\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_term [single]) bs a = a", "by (induction bs) auto"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_term [single]) bs a = a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x]);\n        lookup (\\<lambda>x. x = (idn, T)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Fv idn T) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Fv idn T)", "from fs_step change_step bs_step split Some"], ["proof (chain)\npicking this:\n  fold (\\<lambda>single. subst_term [single]) fs (Fv idn T) = Fv idn T\n  subst_term [((idn, T), a)] (Fv idn T) = a\n  fold (\\<lambda>single. subst_term [single]) bs a = a\n  insts = fs @ ((idn, T), a) # bs\n  lookup (\\<lambda>x. x = (idn, T)) insts = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  fold (\\<lambda>single. subst_term [single]) fs (Fv idn T) = Fv idn T\n  subst_term [((idn, T), a)] (Fv idn T) = a\n  fold (\\<lambda>single. subst_term [single]) bs a = a\n  insts = fs @ ((idn, T), a) # bs\n  lookup (\\<lambda>x. x = (idn, T)) insts = Some a\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) (Fv idn T) =\n    fold (\\<lambda>single. subst_term [single]) (xs @ [x]) (Fv idn T)", "by (simp add: insts_def)"], ["proof (state)\nthis:\n  subst_term (xs @ [x]) (Fv idn T) =\n  fold (\\<lambda>single. subst_term [single]) (xs @ [x]) (Fv idn T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_term (xs @ [x]) (Fv idn T) =\n  fold (\\<lambda>single. subst_term [single]) (xs @ [x]) (Fv idn T)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Ct x1 x2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Ct x1 x2)\n 2. \\<And>xa.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>distinct (map fst xs);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set xs) \\<Longrightarrow>\n                       x \\<notin> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> subst_term xs t =\n                                     fold\n(\\<lambda>single. subst_term [single]) xs t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Bv xa) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Bv xa)\n 3. \\<And>x1 t.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (Abs x1 t) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (Abs x1 t)\n 4. \\<And>t1 t2.\n       \\<lbrakk>\\<lbrakk>\\<And>t.\n                            \\<lbrakk>distinct (map fst xs);\n                             \\<And>x.\n                                x \\<in> \\<Union>\n   (fv ` snd ` set xs) \\<Longrightarrow>\n                                x \\<notin> fst ` set xs\\<rbrakk>\n                            \\<Longrightarrow> subst_term xs t =\n        fold (\\<lambda>single. subst_term [single]) xs t;\n                 distinct (map fst (xs @ [x]));\n                 \\<And>xa.\n                    xa \\<in> \\<Union>\n                              (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n                    xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n                \\<Longrightarrow> subst_term (xs @ [x]) t1 =\n                                  fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (xs @ [x]) t1;\n        \\<lbrakk>\\<And>t.\n                    \\<lbrakk>distinct (map fst xs);\n                     \\<And>x.\n                        x \\<in> \\<Union>\n                                 (fv ` snd ` set xs) \\<Longrightarrow>\n                        x \\<notin> fst ` set xs\\<rbrakk>\n                    \\<Longrightarrow> subst_term xs t =\nfold (\\<lambda>single. subst_term [single]) xs t;\n         distinct (map fst (xs @ [x]));\n         \\<And>xa.\n            xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n            xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n        \\<Longrightarrow> subst_term (xs @ [x]) t2 =\n                          fold (\\<lambda>single. subst_term [single])\n                           (xs @ [x]) t2;\n        \\<And>t.\n           \\<lbrakk>distinct (map fst xs);\n            \\<And>x.\n               x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n               x \\<notin> fst ` set xs\\<rbrakk>\n           \\<Longrightarrow> subst_term xs t =\n                             fold (\\<lambda>single. subst_term [single]) xs\n                              t;\n        distinct (map fst (xs @ [x]));\n        \\<And>xa.\n           xa \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n           xa \\<notin> fst ` set (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> subst_term (xs @ [x]) (t1 $ t2) =\n                         fold (\\<lambda>single. subst_term [single])\n                          (xs @ [x]) (t1 $ t2)", "qed (simp, metis subst_term.simps)+"], ["proof (state)\nthis:\n  subst_term (xs @ [x]) t =\n  fold (\\<lambda>single. subst_term [single]) (xs @ [x]) t\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_term_split_last:\n  assumes \"distinct (map fst (xs @ [x]))\"\n  assumes \"\\<And>y . y \\<in> (\\<Union>t \\<in> snd ` (set (xs @ [x])) . fv t) \\<Longrightarrow> y \\<notin> fst ` (set (xs @ [x]))\"\n  shows \"subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)", "have \"subst_term (xs @ [x]) t = fold (\\<lambda>single . subst_term [single]) (xs@[x]) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t =\n    fold (\\<lambda>single. subst_term [single]) (xs @ [x]) t", "using assms subst_term_stepwise"], ["proof (prove)\nusing this:\n  distinct (map fst (xs @ [x]))\n  ?y \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?y \\<notin> fst ` set (xs @ [x])\n  \\<lbrakk>distinct (map fst ?insts);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set ?insts) \\<Longrightarrow>\n      x \\<notin> fst ` set ?insts\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts ?t =\n                    fold (\\<lambda>single. subst_term [single]) ?insts ?t\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t =\n    fold (\\<lambda>single. subst_term [single]) (xs @ [x]) t", "by blast"], ["proof (state)\nthis:\n  subst_term (xs @ [x]) t =\n  fold (\\<lambda>single. subst_term [single]) (xs @ [x]) t\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)", "also"], ["proof (state)\nthis:\n  subst_term (xs @ [x]) t =\n  fold (\\<lambda>single. subst_term [single]) (xs @ [x]) t\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)", "have \"\\<dots> = subst_term [x] (fold (\\<lambda>single . subst_term [single]) xs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_term [single]) (xs @ [x]) t =\n    subst_term [x] (fold (\\<lambda>single. subst_term [single]) xs t)", "by simp"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_term [single]) (xs @ [x]) t =\n  subst_term [x] (fold (\\<lambda>single. subst_term [single]) xs t)\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)", "also"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_term [single]) (xs @ [x]) t =\n  subst_term [x] (fold (\\<lambda>single. subst_term [single]) xs t)\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)", "have \"\\<dots> = subst_term [x] (subst_term xs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term [x] (fold (\\<lambda>single. subst_term [single]) xs t) =\n    subst_term [x] (subst_term xs t)", "using assms subst_term_stepwise"], ["proof (prove)\nusing this:\n  distinct (map fst (xs @ [x]))\n  ?y \\<in> \\<Union> (fv ` snd ` set (xs @ [x])) \\<Longrightarrow>\n  ?y \\<notin> fst ` set (xs @ [x])\n  \\<lbrakk>distinct (map fst ?insts);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set ?insts) \\<Longrightarrow>\n      x \\<notin> fst ` set ?insts\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts ?t =\n                    fold (\\<lambda>single. subst_term [single]) ?insts ?t\n\ngoal (1 subgoal):\n 1. subst_term [x] (fold (\\<lambda>single. subst_term [single]) xs t) =\n    subst_term [x] (subst_term xs t)", "by simp"], ["proof (state)\nthis:\n  subst_term [x] (fold (\\<lambda>single. subst_term [single]) xs t) =\n  subst_term [x] (subst_term xs t)\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)", "finally"], ["proof (chain)\npicking this:\n  subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)\n\ngoal (1 subgoal):\n 1. subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)", "."], ["proof (state)\nthis:\n  subst_term (xs @ [x]) t = subst_term [x] (subst_term xs t)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary subst_type_term_stepwise:\n  assumes \"distinct (map fst instT)\"\n  assumes \"\\<And>x . x \\<in> (\\<Union>T \\<in> snd ` (set instT) . tvsT T) \\<Longrightarrow> x \\<notin> fst ` (set instT)\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` (set insts) . fv t) \\<Longrightarrow> x \\<notin> fst ` (set insts)\"\n  shows \"subst_type_term instT insts t \n    = fold (\\<lambda>single . subst_term [single]) insts (fold (\\<lambda>single . subst_typ' [single]) instT t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_type_term instT insts t =\n    fold (\\<lambda>single. subst_term [single]) insts\n     (fold (\\<lambda>single. subst_typ' [single]) instT t)", "using assms subst_typ'_stepwise subst_term_stepwise subst_type_term_split_levels"], ["proof (prove)\nusing this:\n  distinct (map fst instT)\n  ?x \\<in> tvsT_Set (snd ` set instT) \\<Longrightarrow>\n  ?x \\<notin> fst ` set instT\n  distinct (map fst insts)\n  ?x \\<in> \\<Union> (fv ` snd ` set insts) \\<Longrightarrow>\n  ?x \\<notin> fst ` set insts\n  \\<lbrakk>distinct (map fst ?instT);\n   \\<And>x.\n      x \\<in> tvsT_Set (snd ` set ?instT) \\<Longrightarrow>\n      x \\<notin> fst ` set ?instT\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?instT ?t =\n                    fold (\\<lambda>single. subst_typ' [single]) ?instT ?t\n  \\<lbrakk>distinct (map fst ?insts);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set ?insts) \\<Longrightarrow>\n      x \\<notin> fst ` set ?insts\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts ?t =\n                    fold (\\<lambda>single. subst_term [single]) ?insts ?t\n  subst_type_term ?instT ?insts ?t =\n  subst_term ?insts (subst_typ' ?instT ?t)\n\ngoal (1 subgoal):\n 1. subst_type_term instT insts t =\n    fold (\\<lambda>single. subst_term [single]) insts\n     (fold (\\<lambda>single. subst_typ' [single]) instT t)", "by auto"], ["", "(* MOVE *)"], ["", "lemma distinct_fst_imp_distinct: \"distinct (map fst l) \\<Longrightarrow> distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow> distinct l", "by (induction l) auto"], ["", "lemma distinct_kv_list: \"distinct l \\<Longrightarrow> distinct (map (\\<lambda>x. (x, f x)) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l \\<Longrightarrow> distinct (map (\\<lambda>x. (x, f x)) l)", "by (induction l) auto"], ["", "lemma subst_subst_term: \n  assumes \"distinct l\" and \"fv t \\<subseteq> set l\"\n  shows \"subst t \\<rho> = subst_term (map (\\<lambda>x.(x, case_prod \\<rho> x)) l) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst t \\<rho> =\n    subst_term\n     (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l)\n     t", "using assms"], ["proof (prove)\nusing this:\n  distinct l\n  fv t \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. subst t \\<rho> =\n    subst_term\n     (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l)\n     t", "proof (induction t arbitrary: l)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; fv (Ct x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Ct x1 x2) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Ct x1 x2)\n 2. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; fv (Fv x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Fv x1 x2) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Fv x1 x2)\n 3. \\<And>x l.\n       \\<lbrakk>distinct l; fv (Bv x) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Bv x) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Bv x)\n 4. \\<And>x1 t l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>distinct l; fv t \\<subseteq> set l\\<rbrakk>\n                   \\<Longrightarrow> subst t \\<rho> =\n                                     subst_term\n(map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l) t;\n        distinct l; fv (Abs x1 t) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Abs x1 t) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Abs x1 t)\n 5. \\<And>t1 t2 l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>distinct l; fv t1 \\<subseteq> set l\\<rbrakk>\n                   \\<Longrightarrow> subst t1 \\<rho> =\n                                     subst_term\n(map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l) t1;\n        \\<And>l.\n           \\<lbrakk>distinct l; fv t2 \\<subseteq> set l\\<rbrakk>\n           \\<Longrightarrow> subst t2 \\<rho> =\n                             subst_term\n                              (map (\\<lambda>x.\n (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n                                l)\n                              t2;\n        distinct l; fv (t1 $ t2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (t1 $ t2) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (t1 $ t2)", "case (Fv idn T)"], ["proof (state)\nthis:\n  distinct l\n  fv (Fv idn T) \\<subseteq> set l\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; fv (Ct x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Ct x1 x2) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Ct x1 x2)\n 2. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; fv (Fv x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Fv x1 x2) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Fv x1 x2)\n 3. \\<And>x l.\n       \\<lbrakk>distinct l; fv (Bv x) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Bv x) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Bv x)\n 4. \\<And>x1 t l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>distinct l; fv t \\<subseteq> set l\\<rbrakk>\n                   \\<Longrightarrow> subst t \\<rho> =\n                                     subst_term\n(map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l) t;\n        distinct l; fv (Abs x1 t) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Abs x1 t) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Abs x1 t)\n 5. \\<And>t1 t2 l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>distinct l; fv t1 \\<subseteq> set l\\<rbrakk>\n                   \\<Longrightarrow> subst t1 \\<rho> =\n                                     subst_term\n(map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l) t1;\n        \\<And>l.\n           \\<lbrakk>distinct l; fv t2 \\<subseteq> set l\\<rbrakk>\n           \\<Longrightarrow> subst t2 \\<rho> =\n                             subst_term\n                              (map (\\<lambda>x.\n (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n                                l)\n                              t2;\n        distinct l; fv (t1 $ t2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (t1 $ t2) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (t1 $ t2)", "then"], ["proof (chain)\npicking this:\n  distinct l\n  fv (Fv idn T) \\<subseteq> set l", "show ?case"], ["proof (prove)\nusing this:\n  distinct l\n  fv (Fv idn T) \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. subst (Fv idn T) \\<rho> =\n    subst_term\n     (map (\\<lambda>x. (x, case x of (a, b) \\<Rightarrow> \\<rho> a b)) l)\n     (Fv idn T)", "proof (cases \"(idn, T) \\<in> set l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)\n 2. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)", "case True"], ["proof (state)\nthis:\n  (idn, T) \\<in> set l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)\n 2. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)", "hence \"((idn, T), \\<rho> idn T) \\<in> set (map (\\<lambda>x.(x, case_prod \\<rho> x)) l)\""], ["proof (prove)\nusing this:\n  (idn, T) \\<in> set l\n\ngoal (1 subgoal):\n 1. ((idn, T), \\<rho> idn T)\n    \\<in> set (map (\\<lambda>x.\n                       (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n                l)", "by auto"], ["proof (state)\nthis:\n  ((idn, T), \\<rho> idn T)\n  \\<in> set (map (\\<lambda>x.\n                     (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n              l)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)\n 2. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)", "moreover"], ["proof (state)\nthis:\n  ((idn, T), \\<rho> idn T)\n  \\<in> set (map (\\<lambda>x.\n                     (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n              l)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)\n 2. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)", "have \"distinct (map fst (map (\\<lambda>x.(x, case_prod \\<rho> x)) l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n         l))", "using Fv(1)"], ["proof (prove)\nusing this:\n  distinct l\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n         l))", "by (induction l) auto"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)\n 2. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)", "ultimately"], ["proof (chain)\npicking this:\n  ((idn, T), \\<rho> idn T)\n  \\<in> set (map (\\<lambda>x.\n                     (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n              l)\n  distinct\n   (map fst\n     (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l))", "have \"(lookup (\\<lambda>x. x = (idn, T)) (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l))\n      = Some (\\<rho> idn T)\""], ["proof (prove)\nusing this:\n  ((idn, T), \\<rho> idn T)\n  \\<in> set (map (\\<lambda>x.\n                     (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n              l)\n  distinct\n   (map fst\n     (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l))\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, T))\n     (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n       l) =\n    Some (\\<rho> idn T)", "using lookup_present_eq_key"], ["proof (prove)\nusing this:\n  ((idn, T), \\<rho> idn T)\n  \\<in> set (map (\\<lambda>x.\n                     (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n              l)\n  distinct\n   (map fst\n     (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l))\n  distinct (map fst ?al) \\<Longrightarrow>\n  ((?k, ?v) \\<in> set ?al) = (lookup (\\<lambda>x. x = ?k) ?al = Some ?v)\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, T))\n     (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n       l) =\n    Some (\\<rho> idn T)", "by fast"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, T))\n   (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l) =\n  Some (\\<rho> idn T)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<in> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)\n 2. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (idn, T))\n   (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l) =\n  Some (\\<rho> idn T)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, T))\n   (map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l) =\n  Some (\\<rho> idn T)\n\ngoal (1 subgoal):\n 1. subst (Fv idn T) \\<rho> =\n    subst_term\n     (map (\\<lambda>x. (x, case x of (a, b) \\<Rightarrow> \\<rho> a b)) l)\n     (Fv idn T)", "by simp"], ["proof (state)\nthis:\n  subst (Fv idn T) \\<rho> =\n  subst_term\n   (map (\\<lambda>x. (x, case x of (a, b) \\<Rightarrow> \\<rho> a b)) l)\n   (Fv idn T)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)", "case False"], ["proof (state)\nthis:\n  (idn, T) \\<notin> set l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct l; fv (Fv idn T) \\<subseteq> set l;\n     (idn, T) \\<notin> set l\\<rbrakk>\n    \\<Longrightarrow> subst (Fv idn T) \\<rho> =\n                      subst_term\n                       (map (\\<lambda>x.\n                                (x, case x of\n                                    (a, b) \\<Rightarrow> \\<rho> a b))\n                         l)\n                       (Fv idn T)", "then"], ["proof (chain)\npicking this:\n  (idn, T) \\<notin> set l", "show ?thesis"], ["proof (prove)\nusing this:\n  (idn, T) \\<notin> set l\n\ngoal (1 subgoal):\n 1. subst (Fv idn T) \\<rho> =\n    subst_term\n     (map (\\<lambda>x. (x, case x of (a, b) \\<Rightarrow> \\<rho> a b)) l)\n     (Fv idn T)", "using Fv"], ["proof (prove)\nusing this:\n  (idn, T) \\<notin> set l\n  distinct l\n  fv (Fv idn T) \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. subst (Fv idn T) \\<rho> =\n    subst_term\n     (map (\\<lambda>x. (x, case x of (a, b) \\<Rightarrow> \\<rho> a b)) l)\n     (Fv idn T)", "by simp"], ["proof (state)\nthis:\n  subst (Fv idn T) \\<rho> =\n  subst_term\n   (map (\\<lambda>x. (x, case x of (a, b) \\<Rightarrow> \\<rho> a b)) l)\n   (Fv idn T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst (Fv idn T) \\<rho> =\n  subst_term\n   (map (\\<lambda>x. (x, case x of (a, b) \\<Rightarrow> \\<rho> a b)) l)\n   (Fv idn T)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 l.\n       \\<lbrakk>distinct l; fv (Ct x1 x2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Ct x1 x2) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Ct x1 x2)\n 2. \\<And>x l.\n       \\<lbrakk>distinct l; fv (Bv x) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Bv x) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Bv x)\n 3. \\<And>x1 t l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>distinct l; fv t \\<subseteq> set l\\<rbrakk>\n                   \\<Longrightarrow> subst t \\<rho> =\n                                     subst_term\n(map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l) t;\n        distinct l; fv (Abs x1 t) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (Abs x1 t) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (Abs x1 t)\n 4. \\<And>t1 t2 l.\n       \\<lbrakk>\\<And>l.\n                   \\<lbrakk>distinct l; fv t1 \\<subseteq> set l\\<rbrakk>\n                   \\<Longrightarrow> subst t1 \\<rho> =\n                                     subst_term\n(map (\\<lambda>x. (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa)) l) t1;\n        \\<And>l.\n           \\<lbrakk>distinct l; fv t2 \\<subseteq> set l\\<rbrakk>\n           \\<Longrightarrow> subst t2 \\<rho> =\n                             subst_term\n                              (map (\\<lambda>x.\n (x, case x of (x, xa) \\<Rightarrow> \\<rho> x xa))\n                                l)\n                              t2;\n        distinct l; fv (t1 $ t2) \\<subseteq> set l\\<rbrakk>\n       \\<Longrightarrow> subst (t1 $ t2) \\<rho> =\n                         subst_term\n                          (map (\\<lambda>x.\n                                   (x, case x of\n (x, xa) \\<Rightarrow> \\<rho> x xa))\n                            l)\n                          (t1 $ t2)", "qed auto"], ["", "lemma subst_term_subst:\n  assumes \"distinct (map fst l)\"\n  shows \"subst_term l t = subst t (fold (\\<lambda>((idn, T), t) f x y. if x=idn \\<and>y=T then t else f x y) l Fv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term l t =\n    subst t\n     (fold\n       (\\<lambda>((idn, T), t) f x y.\n           if x = idn \\<and> y = T then t else f x y)\n       l Fv)", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst l)\n\ngoal (1 subgoal):\n 1. subst_term l t =\n    subst t\n     (fold\n       (\\<lambda>((idn, T), t) f x y.\n           if x = idn \\<and> y = T then t else f x y)\n       l Fv)", "proof (induction t)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       distinct (map fst l) \\<Longrightarrow>\n       subst_term l (Ct x1 x2) =\n       subst (Ct x1 x2)\n        (fold\n          (\\<lambda>((idn, T), t) f x y.\n              if x = idn \\<and> y = T then t else f x y)\n          l Fv)\n 2. \\<And>x1 x2.\n       distinct (map fst l) \\<Longrightarrow>\n       subst_term l (Fv x1 x2) =\n       subst (Fv x1 x2)\n        (fold\n          (\\<lambda>((idn, T), t) f x y.\n              if x = idn \\<and> y = T then t else f x y)\n          l Fv)\n 3. \\<And>x.\n       distinct (map fst l) \\<Longrightarrow>\n       subst_term l (Bv x) =\n       subst (Bv x)\n        (fold\n          (\\<lambda>((idn, T), t) f x y.\n              if x = idn \\<and> y = T then t else f x y)\n          l Fv)\n 4. \\<And>x1 t.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                subst_term l t =\n                subst t\n                 (fold\n                   (\\<lambda>((idn, T), t) f x y.\n                       if x = idn \\<and> y = T then t else f x y)\n                   l Fv);\n        distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Abs x1 t) =\n                         subst (Abs x1 t)\n                          (fold\n                            (\\<lambda>((idn, T), t) f x y.\n                                if x = idn \\<and> y = T then t else f x y)\n                            l Fv)\n 5. \\<And>t1 t2.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                subst_term l t1 =\n                subst t1\n                 (fold\n                   (\\<lambda>((idn, T), t) f x y.\n                       if x = idn \\<and> y = T then t else f x y)\n                   l Fv);\n        distinct (map fst l) \\<Longrightarrow>\n        subst_term l t2 =\n        subst t2\n         (fold\n           (\\<lambda>((idn, T), t) f x y.\n               if x = idn \\<and> y = T then t else f x y)\n           l Fv);\n        distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> subst_term l (t1 $ t2) =\n                         subst (t1 $ t2)\n                          (fold\n                            (\\<lambda>((idn, T), t) f x y.\n                                if x = idn \\<and> y = T then t else f x y)\n                            l Fv)", "case (Fv idn T)"], ["proof (state)\nthis:\n  distinct (map fst l)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       distinct (map fst l) \\<Longrightarrow>\n       subst_term l (Ct x1 x2) =\n       subst (Ct x1 x2)\n        (fold\n          (\\<lambda>((idn, T), t) f x y.\n              if x = idn \\<and> y = T then t else f x y)\n          l Fv)\n 2. \\<And>x1 x2.\n       distinct (map fst l) \\<Longrightarrow>\n       subst_term l (Fv x1 x2) =\n       subst (Fv x1 x2)\n        (fold\n          (\\<lambda>((idn, T), t) f x y.\n              if x = idn \\<and> y = T then t else f x y)\n          l Fv)\n 3. \\<And>x.\n       distinct (map fst l) \\<Longrightarrow>\n       subst_term l (Bv x) =\n       subst (Bv x)\n        (fold\n          (\\<lambda>((idn, T), t) f x y.\n              if x = idn \\<and> y = T then t else f x y)\n          l Fv)\n 4. \\<And>x1 t.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                subst_term l t =\n                subst t\n                 (fold\n                   (\\<lambda>((idn, T), t) f x y.\n                       if x = idn \\<and> y = T then t else f x y)\n                   l Fv);\n        distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Abs x1 t) =\n                         subst (Abs x1 t)\n                          (fold\n                            (\\<lambda>((idn, T), t) f x y.\n                                if x = idn \\<and> y = T then t else f x y)\n                            l Fv)\n 5. \\<And>t1 t2.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                subst_term l t1 =\n                subst t1\n                 (fold\n                   (\\<lambda>((idn, T), t) f x y.\n                       if x = idn \\<and> y = T then t else f x y)\n                   l Fv);\n        distinct (map fst l) \\<Longrightarrow>\n        subst_term l t2 =\n        subst t2\n         (fold\n           (\\<lambda>((idn, T), t) f x y.\n               if x = idn \\<and> y = T then t else f x y)\n           l Fv);\n        distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> subst_term l (t1 $ t2) =\n                         subst (t1 $ t2)\n                          (fold\n                            (\\<lambda>((idn, T), t) f x y.\n                                if x = idn \\<and> y = T then t else f x y)\n                            l Fv)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst l)", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst l)\n\ngoal (1 subgoal):\n 1. subst_term l (Fv idn T) =\n    subst (Fv idn T)\n     (fold\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (idn, T) \\<Rightarrow>\n                \\<lambda>t f x y. if x = idn \\<and> y = T then t else f x y)\n              b)\n       l Fv)", "proof (cases \"lookup (\\<lambda>x. x = (idn, T)) l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst l);\n     lookup (\\<lambda>x. x = (idn, T)) l = None\\<rbrakk>\n    \\<Longrightarrow> subst_term l (Fv idn T) =\n                      subst (Fv idn T)\n                       (fold\n                         (\\<lambda>a.\n                             case a of\n                             (a, b) \\<Rightarrow>\n                               (case a of\n                                (idn, T) \\<Rightarrow>\n                                  \\<lambda>t f x y.\n                                     if x = idn \\<and> y = T then t\n                                     else f x y)\n                                b)\n                         l Fv)\n 2. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "case None"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, T)) l = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst l);\n     lookup (\\<lambda>x. x = (idn, T)) l = None\\<rbrakk>\n    \\<Longrightarrow> subst_term l (Fv idn T) =\n                      subst (Fv idn T)\n                       (fold\n                         (\\<lambda>a.\n                             case a of\n                             (a, b) \\<Rightarrow>\n                               (case a of\n                                (idn, T) \\<Rightarrow>\n                                  \\<lambda>t f x y.\n                                     if x = idn \\<and> y = T then t\n                                     else f x y)\n                                b)\n                         l Fv)\n 2. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "hence \"(idn, T) \\<notin> set (map fst l)\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, T)) l = None\n\ngoal (1 subgoal):\n 1. (idn, T) \\<notin> set (map fst l)", "by (metis (full_types) lookup_None_iff)"], ["proof (state)\nthis:\n  (idn, T) \\<notin> set (map fst l)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst l);\n     lookup (\\<lambda>x. x = (idn, T)) l = None\\<rbrakk>\n    \\<Longrightarrow> subst_term l (Fv idn T) =\n                      subst (Fv idn T)\n                       (fold\n                         (\\<lambda>a.\n                             case a of\n                             (a, b) \\<Rightarrow>\n                               (case a of\n                                (idn, T) \\<Rightarrow>\n                                  \\<lambda>t f x y.\n                                     if x = idn \\<and> y = T then t\n                                     else f x y)\n                                b)\n                         l Fv)\n 2. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "hence \"(fold (\\<lambda>((idn, T), t) f x y. if x=idn \\<and>y=T then t else f x y) l Fv) idn T = Fv idn T\""], ["proof (prove)\nusing this:\n  (idn, T) \\<notin> set (map fst l)\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idn, T), t) f x y.\n         if x = idn \\<and> y = T then t else f x y)\n     l Fv idn T =\n    Fv idn T", "by (induction l rule: rev_induct) (auto split: if_splits prod.splits)"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>((idn, T), t) f x y. if x = idn \\<and> y = T then t else f x y)\n   l Fv idn T =\n  Fv idn T\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst l);\n     lookup (\\<lambda>x. x = (idn, T)) l = None\\<rbrakk>\n    \\<Longrightarrow> subst_term l (Fv idn T) =\n                      subst (Fv idn T)\n                       (fold\n                         (\\<lambda>a.\n                             case a of\n                             (a, b) \\<Rightarrow>\n                               (case a of\n                                (idn, T) \\<Rightarrow>\n                                  \\<lambda>t f x y.\n                                     if x = idn \\<and> y = T then t\n                                     else f x y)\n                                b)\n                         l Fv)\n 2. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "then"], ["proof (chain)\npicking this:\n  fold\n   (\\<lambda>((idn, T), t) f x y. if x = idn \\<and> y = T then t else f x y)\n   l Fv idn T =\n  Fv idn T", "show ?thesis"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>((idn, T), t) f x y. if x = idn \\<and> y = T then t else f x y)\n   l Fv idn T =\n  Fv idn T\n\ngoal (1 subgoal):\n 1. subst_term l (Fv idn T) =\n    subst (Fv idn T)\n     (fold\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (idn, T) \\<Rightarrow>\n                \\<lambda>t f x y. if x = idn \\<and> y = T then t else f x y)\n              b)\n       l Fv)", "by (simp add: None)"], ["proof (state)\nthis:\n  subst_term l (Fv idn T) =\n  subst (Fv idn T)\n   (fold\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (idn, T) \\<Rightarrow>\n              \\<lambda>t f x y. if x = idn \\<and> y = T then t else f x y)\n            b)\n     l Fv)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "case (Some a)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, T)) l = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "have elem: \"((idn, T), a) \\<in> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((idn, T), a) \\<in> set l", "using Some lookup_present_eq_key'' Fv"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, T)) l = Some a\n  distinct (map fst ?al) \\<Longrightarrow>\n  (lookup (\\<lambda>x. x = ?k) ?al = Some ?v) = ((?k, ?v) \\<in> set ?al)\n  distinct (map fst l)\n\ngoal (1 subgoal):\n 1. ((idn, T), a) \\<in> set l", "by fastforce"], ["proof (state)\nthis:\n  ((idn, T), a) \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "from this"], ["proof (chain)\npicking this:\n  ((idn, T), a) \\<in> set l", "obtain fs bs where split: \"l = fs @ ((idn, T), a) # bs\""], ["proof (prove)\nusing this:\n  ((idn, T), a) \\<in> set l\n\ngoal (1 subgoal):\n 1. (\\<And>fs bs.\n        l = fs @ ((idn, T), a) # bs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  l = fs @ ((idn, T), a) # bs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "hence \"(idn, T) \\<notin> set (map fst fs)\" and not_in_bs: \"(idn, T) \\<notin> set (map fst bs)\""], ["proof (prove)\nusing this:\n  l = fs @ ((idn, T), a) # bs\n\ngoal (1 subgoal):\n 1. (idn, T) \\<notin> set (map fst fs) &&&\n    (idn, T) \\<notin> set (map fst bs)", "using Fv"], ["proof (prove)\nusing this:\n  l = fs @ ((idn, T), a) # bs\n  distinct (map fst l)\n\ngoal (1 subgoal):\n 1. (idn, T) \\<notin> set (map fst fs) &&&\n    (idn, T) \\<notin> set (map fst bs)", "by simp_all"], ["proof (state)\nthis:\n  (idn, T) \\<notin> set (map fst fs)\n  (idn, T) \\<notin> set (map fst bs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "hence \"fst p ~= (idn, T)\" if \"p\\<in>set fs\" for p"], ["proof (prove)\nusing this:\n  (idn, T) \\<notin> set (map fst fs)\n  (idn, T) \\<notin> set (map fst bs)\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, T)", "using that"], ["proof (prove)\nusing this:\n  (idn, T) \\<notin> set (map fst fs)\n  (idn, T) \\<notin> set (map fst bs)\n  p \\<in> set fs\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, T)", "by force"], ["proof (state)\nthis:\n  ?p \\<in> set fs \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "hence fs_step: \"(fold (\\<lambda>((idn, T), t) f x y. if x=idn \\<and>y=T then t else f x y) fs Fv) idn T = Fv idn T\""], ["proof (prove)\nusing this:\n  ?p \\<in> set fs \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idn, T), t) f x y.\n         if x = idn \\<and> y = T then t else f x y)\n     fs Fv idn T =\n    Fv idn T", "by (induction fs rule: rev_induct) (fastforce split: if_splits prod.splits)+"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>((idn, T), t) f x y. if x = idn \\<and> y = T then t else f x y)\n   fs Fv idn T =\n  Fv idn T\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "have bs_sub: \"set bs \\<subseteq> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set bs \\<subseteq> set l", "using split"], ["proof (prove)\nusing this:\n  l = fs @ ((idn, T), a) # bs\n\ngoal (1 subgoal):\n 1. set bs \\<subseteq> set l", "by auto"], ["proof (state)\nthis:\n  set bs \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "have \"fst p ~= (idn, T)\" if \"p\\<in>set bs\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, T)", "using that not_in_bs"], ["proof (prove)\nusing this:\n  p \\<in> set bs\n  (idn, T) \\<notin> set (map fst bs)\n\ngoal (1 subgoal):\n 1. fst p \\<noteq> (idn, T)", "by force"], ["proof (state)\nthis:\n  ?p \\<in> set bs \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "hence bs_step: \"(fold (\\<lambda>((idn, T), t) f x y. if x=idn \\<and>y=T then t else f x y) bs f) idn T = f idn T\"\n      for f"], ["proof (prove)\nusing this:\n  ?p \\<in> set bs \\<Longrightarrow> fst ?p \\<noteq> (idn, T)\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idn, T), t) f x y.\n         if x = idn \\<and> y = T then t else f x y)\n     bs f idn T =\n    f idn T", "by (induction bs rule: rev_induct) (fastforce split: if_splits prod.splits)+"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>((idn, T), t) f x y. if x = idn \\<and> y = T then t else f x y)\n   bs ?f idn T =\n  ?f idn T\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>distinct (map fst l);\n        lookup (\\<lambda>x. x = (idn, T)) l = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Fv idn T) =\n                         subst (Fv idn T)\n                          (fold\n                            (\\<lambda>a.\n                                case a of\n                                (a, b) \\<Rightarrow>\n                                  (case a of\n                                   (idn, T) \\<Rightarrow>\n                                     \\<lambda>t f x y.\n  if x = idn \\<and> y = T then t else f x y)\n                                   b)\n                            l Fv)", "from fs_step bs_step split Some"], ["proof (chain)\npicking this:\n  fold\n   (\\<lambda>((idn, T), t) f x y. if x = idn \\<and> y = T then t else f x y)\n   fs Fv idn T =\n  Fv idn T\n  fold\n   (\\<lambda>((idn, T), t) f x y. if x = idn \\<and> y = T then t else f x y)\n   bs ?f idn T =\n  ?f idn T\n  l = fs @ ((idn, T), a) # bs\n  lookup (\\<lambda>x. x = (idn, T)) l = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>((idn, T), t) f x y. if x = idn \\<and> y = T then t else f x y)\n   fs Fv idn T =\n  Fv idn T\n  fold\n   (\\<lambda>((idn, T), t) f x y. if x = idn \\<and> y = T then t else f x y)\n   bs ?f idn T =\n  ?f idn T\n  l = fs @ ((idn, T), a) # bs\n  lookup (\\<lambda>x. x = (idn, T)) l = Some a\n\ngoal (1 subgoal):\n 1. subst_term l (Fv idn T) =\n    subst (Fv idn T)\n     (fold\n       (\\<lambda>a.\n           case a of\n           (a, b) \\<Rightarrow>\n             (case a of\n              (idn, T) \\<Rightarrow>\n                \\<lambda>t f x y. if x = idn \\<and> y = T then t else f x y)\n              b)\n       l Fv)", "by simp"], ["proof (state)\nthis:\n  subst_term l (Fv idn T) =\n  subst (Fv idn T)\n   (fold\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (idn, T) \\<Rightarrow>\n              \\<lambda>t f x y. if x = idn \\<and> y = T then t else f x y)\n            b)\n     l Fv)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_term l (Fv idn T) =\n  subst (Fv idn T)\n   (fold\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (idn, T) \\<Rightarrow>\n              \\<lambda>t f x y. if x = idn \\<and> y = T then t else f x y)\n            b)\n     l Fv)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       distinct (map fst l) \\<Longrightarrow>\n       subst_term l (Ct x1 x2) =\n       subst (Ct x1 x2)\n        (fold\n          (\\<lambda>((idn, T), t) f x y.\n              if x = idn \\<and> y = T then t else f x y)\n          l Fv)\n 2. \\<And>x.\n       distinct (map fst l) \\<Longrightarrow>\n       subst_term l (Bv x) =\n       subst (Bv x)\n        (fold\n          (\\<lambda>((idn, T), t) f x y.\n              if x = idn \\<and> y = T then t else f x y)\n          l Fv)\n 3. \\<And>x1 t.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                subst_term l t =\n                subst t\n                 (fold\n                   (\\<lambda>((idn, T), t) f x y.\n                       if x = idn \\<and> y = T then t else f x y)\n                   l Fv);\n        distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> subst_term l (Abs x1 t) =\n                         subst (Abs x1 t)\n                          (fold\n                            (\\<lambda>((idn, T), t) f x y.\n                                if x = idn \\<and> y = T then t else f x y)\n                            l Fv)\n 4. \\<And>t1 t2.\n       \\<lbrakk>distinct (map fst l) \\<Longrightarrow>\n                subst_term l t1 =\n                subst t1\n                 (fold\n                   (\\<lambda>((idn, T), t) f x y.\n                       if x = idn \\<and> y = T then t else f x y)\n                   l Fv);\n        distinct (map fst l) \\<Longrightarrow>\n        subst_term l t2 =\n        subst t2\n         (fold\n           (\\<lambda>((idn, T), t) f x y.\n               if x = idn \\<and> y = T then t else f x y)\n           l Fv);\n        distinct (map fst l)\\<rbrakk>\n       \\<Longrightarrow> subst_term l (t1 $ t2) =\n                         subst (t1 $ t2)\n                          (fold\n                            (\\<lambda>((idn, T), t) f x y.\n                                if x = idn \\<and> y = T then t else f x y)\n                            l Fv)", "qed auto"], ["", "lemma subst_typ_combine_single:\n  assumes \"fresh_idn \\<notin> fst ` tvsT \\<tau>\"\n  shows \"subst_typ [((fresh_idn, S), \\<tau>2)] (subst_typ [((idn, S), Tv fresh_idn S)] \\<tau>)\n    = subst_typ [((idn, S), \\<tau>2)] \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [((fresh_idn, S), \\<tau>2)]\n     (subst_typ [((idn, S), Tv fresh_idn S)] \\<tau>) =\n    subst_typ [((idn, S), \\<tau>2)] \\<tau>", "using assms"], ["proof (prove)\nusing this:\n  fresh_idn \\<notin> fst ` tvsT \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ [((fresh_idn, S), \\<tau>2)]\n     (subst_typ [((idn, S), Tv fresh_idn S)] \\<tau>) =\n    subst_typ [((idn, S), \\<tau>2)] \\<tau>", "by (induction \\<tau>) auto"], ["", "lemma subst_typ_combine:\n  assumes \"length fresh_idns = length insts\"\n  assumes \"distinct fresh_idns\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<forall>idn \\<in> set fresh_idns . idn \\<notin> fst ` (tvsT \\<tau> \\<union> (\\<Union>ty\\<in>snd ` set insts . (tvsT ty)) \n    \\<union> (fst ` set insts))\"\n  shows \"subst_typ insts \\<tau> \n    = subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (subst_typ (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    subst_typ\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "using assms"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT \\<tau> \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    subst_typ\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "proof (induction insts \\<tau> arbitrary: fresh_idns rule: subst_typ.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>insts a Ts fresh_idns.\n       \\<lbrakk>\\<And>x fresh_idns.\n                   \\<lbrakk>x \\<in> set Ts;\n                    length fresh_idns = length insts; distinct fresh_idns;\n                    distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvsT x \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ insts x =\n                                     subst_typ\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) x);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvsT (Ty a Ts) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Ty a Ts) =\n                         subst_typ\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ty a Ts))\n 2. \\<And>insts idn S fresh_idns.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (tvsT (Tv idn S) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         subst_typ\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Tv idn S))", "case (1 inst a Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set Ts; length ?fresh_idns = length inst;\n   distinct ?fresh_idns; distinct (map fst inst);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvsT ?x \\<union> tvsT_Set (snd ` set inst) \\<union>\n                fst ` set inst)\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    subst_typ\n                     (zip (zip ?fresh_idns (map snd (map fst inst)))\n                       (map snd inst))\n                     (subst_typ\n                       (zip (map fst inst)\n                         (map2 Tv ?fresh_idns (map snd (map fst inst))))\n                       ?x)\n  length fresh_idns = length inst\n  distinct fresh_idns\n  distinct (map fst inst)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT (Ty a Ts) \\<union> tvsT_Set (snd ` set inst) \\<union>\n               fst ` set inst)\n\ngoal (2 subgoals):\n 1. \\<And>insts a Ts fresh_idns.\n       \\<lbrakk>\\<And>x fresh_idns.\n                   \\<lbrakk>x \\<in> set Ts;\n                    length fresh_idns = length insts; distinct fresh_idns;\n                    distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvsT x \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ insts x =\n                                     subst_typ\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) x);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvsT (Ty a Ts) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Ty a Ts) =\n                         subst_typ\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ty a Ts))\n 2. \\<And>insts idn S fresh_idns.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (tvsT (Tv idn S) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         subst_typ\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Tv idn S))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set Ts; length ?fresh_idns = length inst;\n   distinct ?fresh_idns; distinct (map fst inst);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvsT ?x \\<union> tvsT_Set (snd ` set inst) \\<union>\n                fst ` set inst)\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    subst_typ\n                     (zip (zip ?fresh_idns (map snd (map fst inst)))\n                       (map snd inst))\n                     (subst_typ\n                       (zip (map fst inst)\n                         (map2 Tv ?fresh_idns (map snd (map fst inst))))\n                       ?x)\n  length fresh_idns = length inst\n  distinct fresh_idns\n  distinct (map fst inst)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT (Ty a Ts) \\<union> tvsT_Set (snd ` set inst) \\<union>\n               fst ` set inst)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set Ts; length ?fresh_idns = length inst;\n   distinct ?fresh_idns; distinct (map fst inst);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvsT ?x \\<union> tvsT_Set (snd ` set inst) \\<union>\n                fst ` set inst)\\<rbrakk>\n  \\<Longrightarrow> subst_typ inst ?x =\n                    subst_typ\n                     (zip (zip ?fresh_idns (map snd (map fst inst)))\n                       (map snd inst))\n                     (subst_typ\n                       (zip (map fst inst)\n                         (map2 Tv ?fresh_idns (map snd (map fst inst))))\n                       ?x)\n  length fresh_idns = length inst\n  distinct fresh_idns\n  distinct (map fst inst)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT (Ty a Ts) \\<union> tvsT_Set (snd ` set inst) \\<union>\n               fst ` set inst)\n\ngoal (1 subgoal):\n 1. subst_typ inst (Ty a Ts) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Ty a Ts))", "by fastforce"], ["proof (state)\nthis:\n  subst_typ inst (Ty a Ts) =\n  subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n   (subst_typ\n     (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n     (Ty a Ts))\n\ngoal (1 subgoal):\n 1. \\<And>insts idn S fresh_idns.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (tvsT (Tv idn S) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         subst_typ\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Tv idn S))", "(* LOL, I wanted to do another induction *)"], ["proof (state)\nthis:\n  subst_typ inst (Ty a Ts) =\n  subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n   (subst_typ\n     (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n     (Ty a Ts))\n\ngoal (1 subgoal):\n 1. \\<And>insts idn S fresh_idns.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (tvsT (Tv idn S) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         subst_typ\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Tv idn S))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>insts idn S fresh_idns.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (tvsT (Tv idn S) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         subst_typ\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Tv idn S))", "case (2 inst idn S)"], ["proof (state)\nthis:\n  length fresh_idns = length inst\n  distinct fresh_idns\n  distinct (map fst inst)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (tvsT (Tv idn S) \\<union> tvsT_Set (snd ` set inst) \\<union>\n               fst ` set inst)\n\ngoal (1 subgoal):\n 1. \\<And>insts idn S fresh_idns.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (tvsT (Tv idn S) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Tv idn S) =\n                         subst_typ\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Tv idn S))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))", "proof (cases \"lookup (\\<lambda>x. x = (idn, S)) inst\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S)) inst = None \\<Longrightarrow>\n    subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "case None"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S)) inst = None\n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S)) inst = None \\<Longrightarrow>\n    subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "hence \"((idn, S)) \\<notin> fst ` set inst\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S)) inst = None\n\ngoal (1 subgoal):\n 1. (idn, S) \\<notin> fst ` set inst", "by (metis (mono_tags, lifting) list.set_map lookup_None_iff)"], ["proof (state)\nthis:\n  (idn, S) \\<notin> fst ` set inst\n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S)) inst = None \\<Longrightarrow>\n    subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "hence 1: \"(lookup (\\<lambda>x. x = (idn, S)) \n      (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)))) = None\""], ["proof (prove)\nusing this:\n  (idn, S) \\<notin> fst ` set inst\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, S))\n     (zip (map fst inst)\n       (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n    None", "using 2"], ["proof (prove)\nusing this:\n  (idn, S) \\<notin> fst ` set inst\n  length fresh_idns = length inst\n  distinct fresh_idns\n  distinct (map fst inst)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (tvsT (Tv idn S) \\<union> tvsT_Set (snd ` set inst) \\<union>\n               fst ` set inst)\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, S))\n     (zip (map fst inst)\n       (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n    None", "by (simp add: lookup_eq_key_not_present)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n  None\n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S)) inst = None \\<Longrightarrow>\n    subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "have \"(idn, S) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) inst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (idn, S) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) inst))", "using 2 set_zip_leftD"], ["proof (prove)\nusing this:\n  length fresh_idns = length inst\n  distinct fresh_idns\n  distinct (map fst inst)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (tvsT (Tv idn S) \\<union> tvsT_Set (snd ` set inst) \\<union>\n               fst ` set inst)\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow> ?x \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. (idn, S) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) inst))", "by fastforce"], ["proof (state)\nthis:\n  (idn, S) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) inst))\n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S)) inst = None \\<Longrightarrow>\n    subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "hence \"(lookup (\\<lambda>x. x = (idn, S)) \n      (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst))) = None\""], ["proof (prove)\nusing this:\n  (idn, S) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) inst))\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, S))\n     (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n    None", "using 2"], ["proof (prove)\nusing this:\n  (idn, S) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) inst))\n  length fresh_idns = length inst\n  distinct fresh_idns\n  distinct (map fst inst)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (tvsT (Tv idn S) \\<union> tvsT_Set (snd ` set inst) \\<union>\n               fst ` set inst)\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, S))\n     (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n    None", "by (simp add: lookup_eq_key_not_present)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n  None\n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S)) inst = None \\<Longrightarrow>\n    subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n  None", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n  None\n\ngoal (1 subgoal):\n 1. subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))", "using None 1"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n  None\n  lookup (\\<lambda>x. x = (idn, S)) inst = None\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n  None\n\ngoal (1 subgoal):\n 1. subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))", "by simp"], ["proof (state)\nthis:\n  subst_typ inst (Tv idn S) =\n  subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n   (subst_typ\n     (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n     (Tv idn S))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "case (Some ty)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "from this"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some ty", "obtain idx where idx: \"inst ! idx = ((idn, S), ty)\" \"idx < length inst\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\n\ngoal (1 subgoal):\n 1. (\\<And>idx.\n        \\<lbrakk>inst ! idx = ((idn, S), ty); idx < length inst\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction inst)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>idx.\n                \\<lbrakk>[] ! idx = ((idn, S), ty); idx < length []\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lookup (\\<lambda>x. x = (idn, S)) [] = Some ty\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a inst.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>inst ! idx = ((idn, S), ty);\n                             idx < length inst\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # inst) ! idx = ((idn, S), ty);\n            idx < length (a # inst)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, S)) (a # inst) = Some ty\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>[] ! ?idx = ((idn, S), ty); ?idx < length []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lookup (\\<lambda>x. x = (idn, S)) [] = Some ty\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>idx.\n                \\<lbrakk>[] ! idx = ((idn, S), ty); idx < length []\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lookup (\\<lambda>x. x = (idn, S)) [] = Some ty\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a inst.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>inst ! idx = ((idn, S), ty);\n                             idx < length inst\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # inst) ! idx = ((idn, S), ty);\n            idx < length (a # inst)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, S)) (a # inst) = Some ty\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>[] ! ?idx = ((idn, S), ty); ?idx < length []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lookup (\\<lambda>x. x = (idn, S)) [] = Some ty", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>[] ! ?idx = ((idn, S), ty); ?idx < length []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lookup (\\<lambda>x. x = (idn, S)) [] = Some ty\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a inst.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>inst ! idx = ((idn, S), ty);\n                             idx < length inst\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # inst) ! idx = ((idn, S), ty);\n            idx < length (a # inst)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, S)) (a # inst) = Some ty\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a inst.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>inst ! idx = ((idn, S), ty);\n                             idx < length inst\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # inst) ! idx = ((idn, S), ty);\n            idx < length (a # inst)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, S)) (a # inst) = Some ty\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>idx.\n              \\<lbrakk>as ! idx = ((idn, S), ty); idx < length as\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   lookup (\\<lambda>x. x = (idn, S)) as = Some ty\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>(a # as) ! ?idx = ((idn, S), ty); ?idx < length (a # as)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lookup (\\<lambda>x. x = (idn, S)) (a # as) = Some ty\n\ngoal (1 subgoal):\n 1. \\<And>a inst.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>inst ! idx = ((idn, S), ty);\n                             idx < length inst\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # inst) ! idx = ((idn, S), ty);\n            idx < length (a # inst)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, S)) (a # inst) = Some ty\\<rbrakk>\n       \\<Longrightarrow> thesis", "thm Cons.IH"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>idx.\n              \\<lbrakk>as ! idx = ((idn, S), ty); idx < length as\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   lookup (\\<lambda>x. x = (idn, S)) as = Some ty\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>(a # as) ! ?idx = ((idn, S), ty); ?idx < length (a # as)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lookup (\\<lambda>x. x = (idn, S)) (a # as) = Some ty\n\ngoal (1 subgoal):\n 1. \\<And>a inst.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>inst ! idx = ((idn, S), ty);\n                             idx < length inst\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # inst) ! idx = ((idn, S), ty);\n            idx < length (a # inst)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, S)) (a # inst) = Some ty\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"(\\<And>idx. as ! idx = ((idn, S), ty) \\<Longrightarrow> idx < length as \\<Longrightarrow> thesis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>idx.\n       \\<lbrakk>as ! idx = ((idn, S), ty); idx < length as\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (metis Cons.prems(1) in_set_conv_nth list.set_intros(2))"], ["proof (state)\nthis:\n  \\<lbrakk>as ! ?idx = ((idn, S), ty); ?idx < length as\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>a inst.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>inst ! idx = ((idn, S), ty);\n                             idx < length inst\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # inst) ! idx = ((idn, S), ty);\n            idx < length (a # inst)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, S)) (a # inst) = Some ty\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>as ! ?idx = ((idn, S), ty); ?idx < length as\\<rbrakk>\n  \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>as ! ?idx = ((idn, S), ty); ?idx < length as\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (meson Cons.prems(1) Cons.prems(2) in_set_conv_nth lookup_present_eq_key')"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inst ! idx = ((idn, S), ty)\n  idx < length inst\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "from this"], ["proof (chain)\npicking this:\n  inst ! idx = ((idn, S), ty)\n  idx < length inst", "obtain fresh_idn where fresh_idn: \"fresh_idns ! idx = fresh_idn\""], ["proof (prove)\nusing this:\n  inst ! idx = ((idn, S), ty)\n  idx < length inst\n\ngoal (1 subgoal):\n 1. (\\<And>fresh_idn.\n        fresh_idns ! idx = fresh_idn \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  fresh_idns ! idx = fresh_idn\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "from 2(1) idx fresh_idn"], ["proof (chain)\npicking this:\n  length fresh_idns = length inst\n  inst ! idx = ((idn, S), ty)\n  idx < length inst\n  fresh_idns ! idx = fresh_idn", "have ren:\n      \"(zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) ! idx \n      = ((idn, S), Tv fresh_idn S) \""], ["proof (prove)\nusing this:\n  length fresh_idns = length inst\n  inst ! idx = ((idn, S), ty)\n  idx < length inst\n  fresh_idns ! idx = fresh_idn\n\ngoal (1 subgoal):\n 1. zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)) !\n    idx =\n    ((idn, S), Tv fresh_idn S)", "by auto"], ["proof (state)\nthis:\n  zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)) !\n  idx =\n  ((idn, S), Tv fresh_idn S)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "from this idx(2)"], ["proof (chain)\npicking this:\n  zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)) !\n  idx =\n  ((idn, S), Tv fresh_idn S)\n  idx < length inst", "have \"((idn, S), Tv fresh_idn S) \\<in> set\n      (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)))\""], ["proof (prove)\nusing this:\n  zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)) !\n  idx =\n  ((idn, S), Tv fresh_idn S)\n  idx < length inst\n\ngoal (1 subgoal):\n 1. ((idn, S), Tv fresh_idn S)\n    \\<in> set (zip (map fst inst)\n                (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)))", "by (metis (no_types, hide_lams) \"2.prems\"(1) length_map map_fst_zip map_map map_snd_zip nth_mem)"], ["proof (state)\nthis:\n  ((idn, S), Tv fresh_idn S)\n  \\<in> set (zip (map fst inst)\n              (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "from this"], ["proof (chain)\npicking this:\n  ((idn, S), Tv fresh_idn S)\n  \\<in> set (zip (map fst inst)\n              (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)))", "have 1: \"(lookup (\\<lambda>x. x = (idn, S)) \n      (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)))) = Some (Tv fresh_idn S)\""], ["proof (prove)\nusing this:\n  ((idn, S), Tv fresh_idn S)\n  \\<in> set (zip (map fst inst)\n              (map2 Tv fresh_idns (map (snd \\<circ> fst) inst)))\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, S))\n     (zip (map fst inst)\n       (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n    Some (Tv fresh_idn S)", "by (simp add: \"2.prems\"(1) \"2.prems\"(3) lookup_present_eq_key'')"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n  Some (Tv fresh_idn S)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "from 2(1) idx fresh_idn 1"], ["proof (chain)\npicking this:\n  length fresh_idns = length inst\n  inst ! idx = ((idn, S), ty)\n  idx < length inst\n  fresh_idns ! idx = fresh_idn\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n  Some (Tv fresh_idn S)", "have \"((fresh_idn, S), ty) \n      \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst))\""], ["proof (prove)\nusing this:\n  length fresh_idns = length inst\n  inst ! idx = ((idn, S), ty)\n  idx < length inst\n  fresh_idns ! idx = fresh_idn\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n  Some (Tv fresh_idn S)\n\ngoal (1 subgoal):\n 1. ((fresh_idn, S), ty)\n    \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) inst))\n                (map snd inst))", "using in_set_conv_nth"], ["proof (prove)\nusing this:\n  length fresh_idns = length inst\n  inst ! idx = ((idn, S), ty)\n  idx < length inst\n  fresh_idns ! idx = fresh_idn\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n  Some (Tv fresh_idn S)\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n\ngoal (1 subgoal):\n 1. ((fresh_idn, S), ty)\n    \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) inst))\n                (map snd inst))", "by fastforce"], ["proof (state)\nthis:\n  ((fresh_idn, S), ty)\n  \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) inst))\n              (map snd inst))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "hence 2: \"(lookup (\\<lambda>x. x = (fresh_idn, S)) \n      (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst))) = Some ty\""], ["proof (prove)\nusing this:\n  ((fresh_idn, S), ty)\n  \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) inst))\n              (map snd inst))\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (fresh_idn, S))\n     (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n    Some ty", "by (simp add: \"2.prems\"(1) \"2.prems\"(2) distinct_zipI1 lookup_present_eq_key'')"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (fresh_idn, S))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n  Some ty\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) inst = Some a \\<Longrightarrow>\n       subst_typ inst (Tv idn S) =\n       subst_typ\n        (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n        (subst_typ\n          (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n          (Tv idn S))", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (fresh_idn, S))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n  Some ty", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (fresh_idn, S))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n  Some ty\n\ngoal (1 subgoal):\n 1. subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))", "using Some 1 2"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (fresh_idn, S))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n  Some ty\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some ty\n  lookup (\\<lambda>x. x = (idn, S))\n   (zip (map fst inst) (map2 Tv fresh_idns (map (snd \\<circ> fst) inst))) =\n  Some (Tv fresh_idn S)\n  lookup (\\<lambda>x. x = (fresh_idn, S))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) inst)) (map snd inst)) =\n  Some ty\n\ngoal (1 subgoal):\n 1. subst_typ inst (Tv idn S) =\n    subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n     (subst_typ\n       (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n       (Tv idn S))", "by simp"], ["proof (state)\nthis:\n  subst_typ inst (Tv idn S) =\n  subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n   (subst_typ\n     (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n     (Tv idn S))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_typ inst (Tv idn S) =\n  subst_typ (zip (zip fresh_idns (map snd (map fst inst))) (map snd inst))\n   (subst_typ\n     (zip (map fst inst) (map2 Tv fresh_idns (map snd (map fst inst))))\n     (Tv idn S))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_typ_combine':\n  assumes \"length fresh_idns = length insts\"\n  assumes \"distinct fresh_idns\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<forall>idn \\<in> set fresh_idns . idn \\<notin> fst ` (tvsT \\<tau> \\<union> (\\<Union>ty\\<in>snd ` set insts . (tvsT ty)) \n    \\<union> (fst ` set insts))\"\n  shows \"subst_typ insts \\<tau> \n    = fold (\\<lambda>single acc . subst_typ [single] acc) (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (fold (\\<lambda>single acc . subst_typ [single] acc) (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "have s1: \"fst ` set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n    = fst ` set insts \""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "have \"fst ` set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n      = set (map fst (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    set (map fst\n          (zip (map fst insts)\n            (map2 Tv fresh_idns (map snd (map fst insts)))))", "by auto"], ["proof (state)\nthis:\n  fst `\n  set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) =\n  set (map fst\n        (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))))\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "also"], ["proof (state)\nthis:\n  fst `\n  set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) =\n  set (map fst\n        (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))))\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "have \"\\<dots> = set (map fst insts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst\n          (zip (map fst insts)\n            (map2 Tv fresh_idns (map snd (map fst insts))))) =\n    set (map fst insts)", "using map_fst_zip assms(1)"], ["proof (prove)\nusing this:\n  length ?xs = length ?ys \\<Longrightarrow> map fst (zip ?xs ?ys) = ?xs\n  length fresh_idns = length insts\n\ngoal (1 subgoal):\n 1. set (map fst\n          (zip (map fst insts)\n            (map2 Tv fresh_idns (map snd (map fst insts))))) =\n    set (map fst insts)", "by auto"], ["proof (state)\nthis:\n  set (map fst\n        (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts))))) =\n  set (map fst insts)\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "also"], ["proof (state)\nthis:\n  set (map fst\n        (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts))))) =\n  set (map fst insts)\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "have \"\\<dots> = fst ` set insts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst insts) = fst ` set insts", "by simp"], ["proof (state)\nthis:\n  set (map fst insts) = fst ` set insts\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "finally"], ["proof (chain)\npicking this:\n  fst `\n  set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) =\n  fst ` set insts", "show ?thesis"], ["proof (prove)\nusing this:\n  fst `\n  set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) =\n  fst ` set insts\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "."], ["proof (state)\nthis:\n  fst `\n  set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) =\n  fst ` set insts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst `\n  set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) =\n  fst ` set insts\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "have \"snd ` set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n    = set (map2 Tv fresh_idns (map snd (map fst insts)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    set (map2 Tv fresh_idns (map snd (map fst insts)))", "using map_snd_zip assms(1)"], ["proof (prove)\nusing this:\n  length ?xs = length ?ys \\<Longrightarrow> map snd (zip ?xs ?ys) = ?ys\n  length fresh_idns = length insts\n\ngoal (1 subgoal):\n 1. snd `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts)))) =\n    set (map2 Tv fresh_idns (map snd (map fst insts)))", "by (metis (no_types, lifting) image_set length_map)"], ["proof (state)\nthis:\n  snd `\n  set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) =\n  set (map2 Tv fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "hence \"(\\<Union> (tvsT ` snd ` set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))))\n    = (\\<Union> (tvsT ` set (map2 Tv fresh_idns (map snd (map fst insts)))))\""], ["proof (prove)\nusing this:\n  snd `\n  set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) =\n  set (map2 Tv fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. tvsT_Set\n     (snd `\n      set (zip (map fst insts)\n            (map2 Tv fresh_idns (map snd (map fst insts))))) =\n    tvsT_Set (set (map2 Tv fresh_idns (map snd (map fst insts))))", "by simp"], ["proof (state)\nthis:\n  tvsT_Set\n   (snd `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts))))) =\n  tvsT_Set (set (map2 Tv fresh_idns (map snd (map fst insts))))\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "from assms(1) this"], ["proof (chain)\npicking this:\n  length fresh_idns = length insts\n  tvsT_Set\n   (snd `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts))))) =\n  tvsT_Set (set (map2 Tv fresh_idns (map snd (map fst insts))))", "have s2:\n    \"(\\<Union> (tvsT ` snd ` set (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))))\n    = (set (zip fresh_idns (map snd (map fst insts))))\""], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  tvsT_Set\n   (snd `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts))))) =\n  tvsT_Set (set (map2 Tv fresh_idns (map snd (map fst insts))))\n\ngoal (1 subgoal):\n 1. tvsT_Set\n     (snd `\n      set (zip (map fst insts)\n            (map2 Tv fresh_idns (map snd (map fst insts))))) =\n    set (zip fresh_idns (map snd (map fst insts)))", "using assms(1)"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  tvsT_Set\n   (snd `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts))))) =\n  tvsT_Set (set (map2 Tv fresh_idns (map snd (map fst insts))))\n  length fresh_idns = length insts\n\ngoal (1 subgoal):\n 1. tvsT_Set\n     (snd `\n      set (zip (map fst insts)\n            (map2 Tv fresh_idns (map snd (map fst insts))))) =\n    set (zip fresh_idns (map snd (map fst insts)))", "by (induction fresh_idns insts rule: list_induct2) auto"], ["proof (state)\nthis:\n  tvsT_Set\n   (snd `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts))))) =\n  set (zip fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "hence s3: \"\\<Union> (tvsT ` snd ` set (zip (map fst insts)\n                   (map2 Tv fresh_idns (map (snd \\<circ> fst) insts))))\n    = set (zip fresh_idns (map snd (map fst insts)))\""], ["proof (prove)\nusing this:\n  tvsT_Set\n   (snd `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map snd (map fst insts))))) =\n  set (zip fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. tvsT_Set\n     (snd `\n      set (zip (map fst insts)\n            (map2 Tv fresh_idns (map (snd \\<circ> fst) insts)))) =\n    set (zip fresh_idns (map snd (map fst insts)))", "by simp"], ["proof (state)\nthis:\n  tvsT_Set\n   (snd `\n    set (zip (map fst insts)\n          (map2 Tv fresh_idns (map (snd \\<circ> fst) insts)))) =\n  set (zip fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "have \"idn \\<notin> fst ` fst ` set insts\" if \"idn \\<in> set fresh_idns\" for idn"], ["proof (prove)\ngoal (1 subgoal):\n 1. idn \\<notin> fst ` fst ` set insts", "using that assms"], ["proof (prove)\nusing this:\n  idn \\<in> set fresh_idns\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT \\<tau> \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. idn \\<notin> fst ` fst ` set insts", "by auto"], ["proof (state)\nthis:\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  ?idn \\<notin> fst ` fst ` set insts\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "hence I: \"(idn, S) \\<notin> fst ` set insts\" if \"idn \\<in> set fresh_idns\" for idn S"], ["proof (prove)\nusing this:\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  ?idn \\<notin> fst ` fst ` set insts\n\ngoal (1 subgoal):\n 1. (idn, S) \\<notin> fst ` set insts", "using that assms"], ["proof (prove)\nusing this:\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  ?idn \\<notin> fst ` fst ` set insts\n  idn \\<in> set fresh_idns\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT \\<tau> \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. (idn, S) \\<notin> fst ` set insts", "by (metis fst_conv image_eqI)"], ["proof (state)\nthis:\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  (?idn, ?S) \\<notin> fst ` set insts\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "have u1: \"(subst_typ (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>)\n    = fold (\\<lambda>single acc . subst_typ [single] acc) (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>", "apply (rule subst_typ_stepwise)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (map fst\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))))\n 2. \\<And>x.\n       x \\<in> tvsT_Set\n                (snd `\n                 set (zip (map fst insts)\n                       (map2 Tv fresh_idns\n                         (map snd (map fst insts))))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (map fst insts)\n                        (map2 Tv fresh_idns (map snd (map fst insts))))", "using assms"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT \\<tau> \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (2 subgoals):\n 1. distinct\n     (map fst\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))))\n 2. \\<And>x.\n       x \\<in> tvsT_Set\n                (snd `\n                 set (zip (map fst insts)\n                       (map2 Tv fresh_idns\n                         (map snd (map fst insts))))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (map fst insts)\n                        (map2 Tv fresh_idns (map snd (map fst insts))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tvsT_Set\n                (snd `\n                 set (zip (map fst insts)\n                       (map2 Tv fresh_idns\n                         (map snd (map fst insts))))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (map fst insts)\n                        (map2 Tv fresh_idns (map snd (map fst insts))))", "apply (simp only: s1 s2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (zip fresh_idns\n                     (map snd (map fst insts))) \\<Longrightarrow>\n       x \\<notin> fst ` set insts", "using assms I"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT \\<tau> \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  (?idn, ?S) \\<notin> fst ` set insts\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (zip fresh_idns\n                     (map snd (map fst insts))) \\<Longrightarrow>\n       x \\<notin> fst ` set insts", "by (metis prod.collapse set_zip_leftD)"], ["proof (state)\nthis:\n  subst_typ\n   (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n   \\<tau> =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n   \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "moreover"], ["proof (state)\nthis:\n  subst_typ\n   (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n   \\<tau> =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n   \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "have u2: \"subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n    (subst_typ (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>)\n  = fold (\\<lambda>single acc . subst_typ [single] acc) (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n    (subst_typ (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>) =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "apply (rule subst_typ_stepwise)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (map fst\n       (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)))\n 2. \\<And>x.\n       x \\<in> tvsT_Set\n                (snd `\n                 set (zip (zip fresh_idns (map snd (map fst insts)))\n                       (map snd insts))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (zip fresh_idns (map snd (map fst insts)))\n                        (map snd insts))", "using assms"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT \\<tau> \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (2 subgoals):\n 1. distinct\n     (map fst\n       (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)))\n 2. \\<And>x.\n       x \\<in> tvsT_Set\n                (snd `\n                 set (zip (zip fresh_idns (map snd (map fst insts)))\n                       (map snd insts))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (zip fresh_idns (map snd (map fst insts)))\n                        (map snd insts))", "apply (simp add: distinct_zipI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tvsT_Set\n                (snd `\n                 set (zip (zip fresh_idns (map snd (map fst insts)))\n                       (map snd insts))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (zip fresh_idns (map snd (map fst insts)))\n                        (map snd insts))", "using assms"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT \\<tau> \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tvsT_Set\n                (snd `\n                 set (zip (zip fresh_idns (map snd (map fst insts)))\n                       (map snd insts))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (zip fresh_idns (map snd (map fst insts)))\n                        (map snd insts))", "by (smt UnCI imageE image_eqI length_map map_snd_zip prod.collapse set_map set_zip_leftD)"], ["proof (state)\nthis:\n  subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>) =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>)\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "ultimately"], ["proof (chain)\npicking this:\n  subst_typ\n   (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n   \\<tau> =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n   \\<tau>\n  subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>) =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>)", "have unfold: \"subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n    (subst_typ (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>)\n   = fold (\\<lambda>single acc . subst_typ [single] acc) (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n        (fold (\\<lambda>single acc . subst_typ [single] acc) (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) \\<tau>)\""], ["proof (prove)\nusing this:\n  subst_typ\n   (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n   \\<tau> =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n   \\<tau>\n  subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>) =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>)\n\ngoal (1 subgoal):\n 1. subst_typ\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>) =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "by simp"], ["proof (state)\nthis:\n  subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>) =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_typ [single])\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>)\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "using assms subst_typ_combine unfold"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvsT \\<tau> \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvsT ?\\<tau> \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ ?insts ?\\<tau> =\n                    subst_typ\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       ?\\<tau>)\n  subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>) =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_typ [single])\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>)\n\ngoal (1 subgoal):\n 1. subst_typ insts \\<tau> =\n    fold (\\<lambda>single. subst_typ [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_typ [single])\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       \\<tau>)", "by auto"], ["proof (state)\nthis:\n  subst_typ insts \\<tau> =\n  fold (\\<lambda>single. subst_typ [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_typ [single])\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     \\<tau>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_typ'_combine:\n  assumes \"length fresh_idns = length insts\"\n  assumes \"distinct fresh_idns\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<forall>idn \\<in> set fresh_idns . idn \\<notin> fst ` (tvs t \\<union> (\\<Union>ty\\<in>snd ` set insts . (tvsT ty)) \n    \\<union> (fst ` set insts))\"\n  shows \"subst_typ' insts t\n    = subst_typ' (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (subst_typ' (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' insts t =\n    subst_typ'\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ'\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       t)", "using assms"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs t \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. subst_typ' insts t =\n    subst_typ'\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ'\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       t)", "proof (induction t arbitrary: fresh_idns insts)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Abs x1 t) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Abs x1 t) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 5. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "case (Abs T t)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs (Abs T t) \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Abs x1 t) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Abs x1 t) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 5. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs (Abs T t) \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Abs x1 t) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Abs x1 t) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 5. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "have \"tvs t \\<subseteq> tvs (Abs T t) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs t \\<subseteq> tvs (Abs T t)", "by simp"], ["proof (state)\nthis:\n  tvs t \\<subseteq> tvs (Abs T t)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Abs x1 t) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Abs x1 t) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 5. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs (Abs T t) \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n  tvs t \\<subseteq> tvs (Abs T t)", "have \"subst_typ' insts t =\n    subst_typ' (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ' (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs (Abs T t) \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n  tvs t \\<subseteq> tvs (Abs T t)\n\ngoal (1 subgoal):\n 1. subst_typ' insts t =\n    subst_typ'\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ'\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       t)", "by blast"], ["proof (state)\nthis:\n  subst_typ' insts t =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Abs x1 t) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Abs x1 t) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 5. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "moreover"], ["proof (state)\nthis:\n  subst_typ' insts t =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Abs x1 t) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Abs x1 t) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 5. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "have \"subst_typ insts T =\n    subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ insts T =\n    subst_typ\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       T)", "using subst_typ_combine Abs.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvsT ?\\<tau> \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ ?insts ?\\<tau> =\n                    subst_typ\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       ?\\<tau>)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs (Abs T t) \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. subst_typ insts T =\n    subst_typ\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       T)", "by fastforce"], ["proof (state)\nthis:\n  subst_typ insts T =\n  subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) T)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Abs x1 t) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Abs x1 t) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 5. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "ultimately"], ["proof (chain)\npicking this:\n  subst_typ' insts t =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t)\n  subst_typ insts T =\n  subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) T)", "show ?case"], ["proof (prove)\nusing this:\n  subst_typ' insts t =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t)\n  subst_typ insts T =\n  subst_typ (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) T)\n\ngoal (1 subgoal):\n 1. subst_typ' insts (Abs T t) =\n    subst_typ'\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ'\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       (Abs T t))", "by simp"], ["proof (state)\nthis:\n  subst_typ' insts (Abs T t) =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     (Abs T t))\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "case (App t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t1 \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t1 =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t1)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t2 \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t2 =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t2)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs (t1 $ t2) \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t1 \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t1 =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t1)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t2 \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t2 =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t2)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs (t1 $ t2) \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "have \"tvs t1 \\<subseteq> tvs (t1 $ t2)\" \"tvs t2 \\<subseteq> tvs (t1 $ t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs t1 \\<subseteq> tvs (t1 $ t2) &&& tvs t2 \\<subseteq> tvs (t1 $ t2)", "by auto"], ["proof (state)\nthis:\n  tvs t1 \\<subseteq> tvs (t1 $ t2)\n  tvs t2 \\<subseteq> tvs (t1 $ t2)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t1 \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t1 =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t1)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t2 \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t2 =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t2)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs (t1 $ t2) \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n  tvs t1 \\<subseteq> tvs (t1 $ t2)\n  tvs t2 \\<subseteq> tvs (t1 $ t2)", "have \"subst_typ' insts t1 =\n    subst_typ' (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ' (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1)\" \n  and \"subst_typ' insts t2 =\n    subst_typ' (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ' (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t1 \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t1 =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t1)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (tvs t2 \\<union> tvsT_Set (snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_typ' ?insts t2 =\n                    subst_typ'\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_typ'\n                       (zip (map fst ?insts)\n                         (map2 Tv ?fresh_idns (map snd (map fst ?insts))))\n                       t2)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (tvs (t1 $ t2) \\<union> tvsT_Set (snd ` set insts) \\<union>\n               fst ` set insts)\n  tvs t1 \\<subseteq> tvs (t1 $ t2)\n  tvs t2 \\<subseteq> tvs (t1 $ t2)\n\ngoal (1 subgoal):\n 1. subst_typ' insts t1 =\n    subst_typ'\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ'\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       t1) &&&\n    subst_typ' insts t2 =\n    subst_typ'\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ'\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       t2)", "by blast+"], ["proof (state)\nthis:\n  subst_typ' insts t1 =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     t1)\n  subst_typ' insts t2 =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     t2)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (tvs t1 \\<union>\n                                 tvsT_Set (snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' insts t1 =\n                                     subst_typ'\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_typ'\n  (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (tvs t2 \\<union> tvsT_Set (snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_typ' insts t2 =\n                             subst_typ'\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_typ'\n                                (zip (map fst insts)\n                                  (map2 Tv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (t1 $ t2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (t1 $ t2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "then"], ["proof (chain)\npicking this:\n  subst_typ' insts t1 =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     t1)\n  subst_typ' insts t2 =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     t2)", "show ?case"], ["proof (prove)\nusing this:\n  subst_typ' insts t1 =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     t1)\n  subst_typ' insts t2 =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     t2)\n\ngoal (1 subgoal):\n 1. subst_typ' insts (t1 $ t2) =\n    subst_typ'\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_typ'\n       (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n       (t1 $ t2))", "by simp"], ["proof (state)\nthis:\n  subst_typ' insts (t1 $ t2) =\n  subst_typ'\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_typ'\n     (zip (map fst insts) (map2 Tv fresh_idns (map snd (map fst insts))))\n     (t1 $ t2))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Ct x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Ct x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Fv x1 x2) \\<union>\n                     tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Fv x1 x2) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (tvs (Bv x) \\<union> tvsT_Set (snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_typ' insts (Bv x) =\n                         subst_typ'\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_typ'\n                            (zip (map fst insts)\n                              (map2 Tv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))", "qed (use subst_typ_combine in auto)"], ["", "(* Only interesting case is Fv, and that one is copied directly from subst_typ *)"], ["", "lemma subst_term_combine:\n  assumes \"length fresh_idns = length insts\"\n  assumes \"distinct fresh_idns\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<forall>idn \\<in> set fresh_idns . idn \\<notin> fst ` (fv t \\<union> (\\<Union>t\\<in>snd ` set insts . (fv t)) \n    \\<union> (fst ` set insts))\"\n  shows \"subst_term insts t\n    = subst_term (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (subst_term (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term insts t =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "using assms"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv t \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "proof (induction t arbitrary: fresh_idns insts)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Ct x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Ct x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Fv x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Bv x) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Bv x) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Abs x1 t) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Abs x1 t) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 5. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t1 \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t1 =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (fv t2 \\<union>\n                         \\<Union> (fv ` snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_term insts t2 =\n                             subst_term\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_term\n                                (zip (map fst insts)\n                                  (map2 Fv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (t1 $ t2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (t1 $ t2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "case (Fv idn ty)"], ["proof (state)\nthis:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (fv (Fv idn ty) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Ct x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Ct x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Fv x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv x1 x2))\n 3. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Bv x) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Bv x) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 4. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Abs x1 t) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Abs x1 t) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 5. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t1 \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t1 =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (fv t2 \\<union>\n                         \\<Union> (fv ` snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_term insts t2 =\n                             subst_term\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_term\n                                (zip (map fst insts)\n                                  (map2 Fv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (t1 $ t2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (t1 $ t2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "then"], ["proof (chain)\npicking this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (fv (Fv idn ty) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)", "show ?case"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (fv (Fv idn ty) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. subst_term insts (Fv idn ty) =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       (Fv idn ty))", "proof (cases \"lookup (\\<lambda>x. x = (idn, ty)) insts\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n     distinct (map fst insts);\n     \\<forall>idna\\<in>set fresh_idns.\n        idna\n        \\<notin> fst `\n                 (fv (Fv idn ty) \\<union>\n                  \\<Union> (fv ` snd ` set insts) \\<union>\n                  fst ` set insts);\n     lookup (\\<lambda>x. x = (idn, ty)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                      subst_term\n                       (zip (zip fresh_idns (map snd (map fst insts)))\n                         (map snd insts))\n                       (subst_term\n                         (zip (map fst insts)\n                           (map2 Fv fresh_idns (map snd (map fst insts))))\n                         (Fv idn ty))\n 2. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "case None"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, ty)) insts = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n     distinct (map fst insts);\n     \\<forall>idna\\<in>set fresh_idns.\n        idna\n        \\<notin> fst `\n                 (fv (Fv idn ty) \\<union>\n                  \\<Union> (fv ` snd ` set insts) \\<union>\n                  fst ` set insts);\n     lookup (\\<lambda>x. x = (idn, ty)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                      subst_term\n                       (zip (zip fresh_idns (map snd (map fst insts)))\n                         (map snd insts))\n                       (subst_term\n                         (zip (map fst insts)\n                           (map2 Fv fresh_idns (map snd (map fst insts))))\n                         (Fv idn ty))\n 2. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "hence \"((idn, ty)) \\<notin> fst ` set insts\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, ty)) insts = None\n\ngoal (1 subgoal):\n 1. (idn, ty) \\<notin> fst ` set insts", "by (metis (mono_tags, lifting) list.set_map lookup_None_iff)"], ["proof (state)\nthis:\n  (idn, ty) \\<notin> fst ` set insts\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n     distinct (map fst insts);\n     \\<forall>idna\\<in>set fresh_idns.\n        idna\n        \\<notin> fst `\n                 (fv (Fv idn ty) \\<union>\n                  \\<Union> (fv ` snd ` set insts) \\<union>\n                  fst ` set insts);\n     lookup (\\<lambda>x. x = (idn, ty)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                      subst_term\n                       (zip (zip fresh_idns (map snd (map fst insts)))\n                         (map snd insts))\n                       (subst_term\n                         (zip (map fst insts)\n                           (map2 Fv fresh_idns (map snd (map fst insts))))\n                         (Fv idn ty))\n 2. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "hence 1: \"(lookup (\\<lambda>x. x = (idn, ty)) \n      (zip (map fst insts) (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)))) = None\""], ["proof (prove)\nusing this:\n  (idn, ty) \\<notin> fst ` set insts\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, ty))\n     (zip (map fst insts)\n       (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n    None", "using Fv"], ["proof (prove)\nusing this:\n  (idn, ty) \\<notin> fst ` set insts\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (fv (Fv idn ty) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, ty))\n     (zip (map fst insts)\n       (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n    None", "by (simp add: lookup_eq_key_not_present)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (map fst insts)\n     (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n  None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n     distinct (map fst insts);\n     \\<forall>idna\\<in>set fresh_idns.\n        idna\n        \\<notin> fst `\n                 (fv (Fv idn ty) \\<union>\n                  \\<Union> (fv ` snd ` set insts) \\<union>\n                  fst ` set insts);\n     lookup (\\<lambda>x. x = (idn, ty)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                      subst_term\n                       (zip (zip fresh_idns (map snd (map fst insts)))\n                         (map snd insts))\n                       (subst_term\n                         (zip (map fst insts)\n                           (map2 Fv fresh_idns (map snd (map fst insts))))\n                         (Fv idn ty))\n 2. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "have \"(idn, ty) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) insts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (idn, ty) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) insts))", "using Fv set_zip_leftD"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (fv (Fv idn ty) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n  (?x, ?y) \\<in> set (zip ?xs ?ys) \\<Longrightarrow> ?x \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. (idn, ty) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) insts))", "by fastforce"], ["proof (state)\nthis:\n  (idn, ty) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) insts))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n     distinct (map fst insts);\n     \\<forall>idna\\<in>set fresh_idns.\n        idna\n        \\<notin> fst `\n                 (fv (Fv idn ty) \\<union>\n                  \\<Union> (fv ` snd ` set insts) \\<union>\n                  fst ` set insts);\n     lookup (\\<lambda>x. x = (idn, ty)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                      subst_term\n                       (zip (zip fresh_idns (map snd (map fst insts)))\n                         (map snd insts))\n                       (subst_term\n                         (zip (map fst insts)\n                           (map2 Fv fresh_idns (map snd (map fst insts))))\n                         (Fv idn ty))\n 2. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "hence \"(lookup (\\<lambda>x. x = (idn, ty)) \n      (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts))) = None\""], ["proof (prove)\nusing this:\n  (idn, ty) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) insts))\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, ty))\n     (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n    None", "using Fv"], ["proof (prove)\nusing this:\n  (idn, ty) \\<notin> set (zip fresh_idns (map (snd \\<circ> fst) insts))\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idna\\<in>set fresh_idns.\n     idna\n     \\<notin> fst `\n              (fv (Fv idn ty) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, ty))\n     (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n    None", "by (simp add: lookup_eq_key_not_present)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n  None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n     distinct (map fst insts);\n     \\<forall>idna\\<in>set fresh_idns.\n        idna\n        \\<notin> fst `\n                 (fv (Fv idn ty) \\<union>\n                  \\<Union> (fv ` snd ` set insts) \\<union>\n                  fst ` set insts);\n     lookup (\\<lambda>x. x = (idn, ty)) insts = None\\<rbrakk>\n    \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                      subst_term\n                       (zip (zip fresh_idns (map snd (map fst insts)))\n                         (map snd insts))\n                       (subst_term\n                         (zip (map fst insts)\n                           (map2 Fv fresh_idns (map snd (map fst insts))))\n                         (Fv idn ty))\n 2. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n  None", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n  None\n\ngoal (1 subgoal):\n 1. subst_term insts (Fv idn ty) =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       (Fv idn ty))", "using None 1"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n  None\n  lookup (\\<lambda>x. x = (idn, ty)) insts = None\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (map fst insts)\n     (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n  None\n\ngoal (1 subgoal):\n 1. subst_term insts (Fv idn ty) =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       (Fv idn ty))", "by simp"], ["proof (state)\nthis:\n  subst_term insts (Fv idn ty) =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     (Fv idn ty))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "case (Some u)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, ty)) insts = Some u\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "from this"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (idn, ty)) insts = Some u", "obtain idx where idx: \"insts ! idx = ((idn, ty), u)\" \"idx < length insts\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, ty)) insts = Some u\n\ngoal (1 subgoal):\n 1. (\\<And>idx.\n        \\<lbrakk>insts ! idx = ((idn, ty), u); idx < length insts\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (induction insts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>idx.\n                \\<lbrakk>[] ! idx = ((idn, ty), u); idx < length []\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lookup (\\<lambda>x. x = (idn, ty)) [] = Some u\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a insts.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>insts ! idx = ((idn, ty), u);\n                             idx < length insts\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, ty)) insts = Some u\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # insts) ! idx = ((idn, ty), u);\n            idx < length (a # insts)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, ty)) (a # insts) = Some u\\<rbrakk>\n       \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  \\<lbrakk>[] ! ?idx = ((idn, ty), u); ?idx < length []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lookup (\\<lambda>x. x = (idn, ty)) [] = Some u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>idx.\n                \\<lbrakk>[] ! idx = ((idn, ty), u); idx < length []\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     lookup (\\<lambda>x. x = (idn, ty)) [] = Some u\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a insts.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>insts ! idx = ((idn, ty), u);\n                             idx < length insts\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, ty)) insts = Some u\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # insts) ! idx = ((idn, ty), u);\n            idx < length (a # insts)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, ty)) (a # insts) = Some u\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>[] ! ?idx = ((idn, ty), u); ?idx < length []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lookup (\\<lambda>x. x = (idn, ty)) [] = Some u", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>[] ! ?idx = ((idn, ty), u); ?idx < length []\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lookup (\\<lambda>x. x = (idn, ty)) [] = Some u\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a insts.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>insts ! idx = ((idn, ty), u);\n                             idx < length insts\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, ty)) insts = Some u\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # insts) ! idx = ((idn, ty), u);\n            idx < length (a # insts)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, ty)) (a # insts) = Some u\\<rbrakk>\n       \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a insts.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>insts ! idx = ((idn, ty), u);\n                             idx < length insts\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, ty)) insts = Some u\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # insts) ! idx = ((idn, ty), u);\n            idx < length (a # insts)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, ty)) (a # insts) = Some u\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>idx.\n              \\<lbrakk>as ! idx = ((idn, ty), u); idx < length as\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   lookup (\\<lambda>x. x = (idn, ty)) as = Some u\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>(a # as) ! ?idx = ((idn, ty), u); ?idx < length (a # as)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  lookup (\\<lambda>x. x = (idn, ty)) (a # as) = Some u\n\ngoal (1 subgoal):\n 1. \\<And>a insts.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>insts ! idx = ((idn, ty), u);\n                             idx < length insts\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, ty)) insts = Some u\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # insts) ! idx = ((idn, ty), u);\n            idx < length (a # insts)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, ty)) (a # insts) = Some u\\<rbrakk>\n       \\<Longrightarrow> thesis", "have \"(\\<And>idx. as ! idx = ((idn, ty), u) \\<Longrightarrow> idx < length as \\<Longrightarrow> thesis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>idx.\n       \\<lbrakk>as ! idx = ((idn, ty), u); idx < length as\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (metis Cons.prems(1) in_set_conv_nth insert_iff list.set(2))"], ["proof (state)\nthis:\n  \\<lbrakk>as ! ?idx = ((idn, ty), u); ?idx < length as\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<And>a insts.\n       \\<lbrakk>\\<lbrakk>\\<And>idx.\n                            \\<lbrakk>insts ! idx = ((idn, ty), u);\n                             idx < length insts\\<rbrakk>\n                            \\<Longrightarrow> thesis;\n                 lookup (\\<lambda>x. x = (idn, ty)) insts = Some u\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        \\<And>idx.\n           \\<lbrakk>(a # insts) ! idx = ((idn, ty), u);\n            idx < length (a # insts)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        lookup (\\<lambda>x. x = (idn, ty)) (a # insts) = Some u\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>as ! ?idx = ((idn, ty), u); ?idx < length as\\<rbrakk>\n  \\<Longrightarrow> thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>as ! ?idx = ((idn, ty), u); ?idx < length as\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by (meson Cons.prems(1) Cons.prems(2) in_set_conv_nth lookup_present_eq_key')"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insts ! idx = ((idn, ty), u)\n  idx < length insts\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "from this"], ["proof (chain)\npicking this:\n  insts ! idx = ((idn, ty), u)\n  idx < length insts", "obtain fresh_idn where fresh_idn: \"fresh_idns ! idx = fresh_idn\""], ["proof (prove)\nusing this:\n  insts ! idx = ((idn, ty), u)\n  idx < length insts\n\ngoal (1 subgoal):\n 1. (\\<And>fresh_idn.\n        fresh_idns ! idx = fresh_idn \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  fresh_idns ! idx = fresh_idn\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "from Fv(1) idx fresh_idn"], ["proof (chain)\npicking this:\n  length fresh_idns = length insts\n  insts ! idx = ((idn, ty), u)\n  idx < length insts\n  fresh_idns ! idx = fresh_idn", "have ren:\n      \"(zip (map fst insts) (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) ! idx \n      = ((idn, ty), Fv fresh_idn ty)\""], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  insts ! idx = ((idn, ty), u)\n  idx < length insts\n  fresh_idns ! idx = fresh_idn\n\ngoal (1 subgoal):\n 1. zip (map fst insts) (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)) !\n    idx =\n    ((idn, ty), Fv fresh_idn ty)", "by auto"], ["proof (state)\nthis:\n  zip (map fst insts) (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)) !\n  idx =\n  ((idn, ty), Fv fresh_idn ty)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "from this idx(2)"], ["proof (chain)\npicking this:\n  zip (map fst insts) (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)) !\n  idx =\n  ((idn, ty), Fv fresh_idn ty)\n  idx < length insts", "have \"((idn, ty), Fv fresh_idn ty) \\<in> set\n      (zip (map fst insts) (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)))\""], ["proof (prove)\nusing this:\n  zip (map fst insts) (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)) !\n  idx =\n  ((idn, ty), Fv fresh_idn ty)\n  idx < length insts\n\ngoal (1 subgoal):\n 1. ((idn, ty), Fv fresh_idn ty)\n    \\<in> set (zip (map fst insts)\n                (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)))", "by (metis (no_types, hide_lams) \"Fv.prems\"(1) length_map map_fst_zip map_map map_snd_zip nth_mem)"], ["proof (state)\nthis:\n  ((idn, ty), Fv fresh_idn ty)\n  \\<in> set (zip (map fst insts)\n              (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "from this"], ["proof (chain)\npicking this:\n  ((idn, ty), Fv fresh_idn ty)\n  \\<in> set (zip (map fst insts)\n              (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)))", "have 1: \"(lookup (\\<lambda>x. x = (idn, ty)) \n      (zip (map fst insts) (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)))) = Some (Fv fresh_idn ty)\""], ["proof (prove)\nusing this:\n  ((idn, ty), Fv fresh_idn ty)\n  \\<in> set (zip (map fst insts)\n              (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)))\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, ty))\n     (zip (map fst insts)\n       (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n    Some (Fv fresh_idn ty)", "by (simp add: \"Fv.prems\"(1) \"Fv.prems\"(3) lookup_present_eq_key'')"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (map fst insts)\n     (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n  Some (Fv fresh_idn ty)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "(* Feels doable with better simp setup *)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (map fst insts)\n     (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n  Some (Fv fresh_idn ty)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "from Fv(1) idx fresh_idn 1"], ["proof (chain)\npicking this:\n  length fresh_idns = length insts\n  insts ! idx = ((idn, ty), u)\n  idx < length insts\n  fresh_idns ! idx = fresh_idn\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (map fst insts)\n     (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n  Some (Fv fresh_idn ty)", "have \"((fresh_idn, ty), u) \n      \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts))\""], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  insts ! idx = ((idn, ty), u)\n  idx < length insts\n  fresh_idns ! idx = fresh_idn\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (map fst insts)\n     (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n  Some (Fv fresh_idn ty)\n\ngoal (1 subgoal):\n 1. ((fresh_idn, ty), u)\n    \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) insts))\n                (map snd insts))", "using in_set_conv_nth"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  insts ! idx = ((idn, ty), u)\n  idx < length insts\n  fresh_idns ! idx = fresh_idn\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (map fst insts)\n     (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n  Some (Fv fresh_idn ty)\n  (?x \\<in> set ?xs) = (\\<exists>i<length ?xs. ?xs ! i = ?x)\n\ngoal (1 subgoal):\n 1. ((fresh_idn, ty), u)\n    \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) insts))\n                (map snd insts))", "by fastforce"], ["proof (state)\nthis:\n  ((fresh_idn, ty), u)\n  \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) insts))\n              (map snd insts))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "hence 2: \"(lookup (\\<lambda>x. x = (fresh_idn, ty)) \n      (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts))) = Some u\""], ["proof (prove)\nusing this:\n  ((fresh_idn, ty), u)\n  \\<in> set (zip (zip fresh_idns (map (snd \\<circ> fst) insts))\n              (map snd insts))\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (fresh_idn, ty))\n     (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n    Some u", "by (simp add: \"Fv.prems\"(1) \"Fv.prems\"(2) distinct_zipI1 lookup_present_eq_key'')"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (fresh_idn, ty))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n  Some u\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idna\\<in>set fresh_idns.\n           idna\n           \\<notin> fst `\n                    (fv (Fv idn ty) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts);\n        lookup (\\<lambda>x. x = (idn, ty)) insts = Some a\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Fv idn ty) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Fv idn ty))", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (fresh_idn, ty))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n  Some u", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (fresh_idn, ty))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n  Some u\n\ngoal (1 subgoal):\n 1. subst_term insts (Fv idn ty) =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       (Fv idn ty))", "using Some 1 2"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (fresh_idn, ty))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n  Some u\n  lookup (\\<lambda>x. x = (idn, ty)) insts = Some u\n  lookup (\\<lambda>x. x = (idn, ty))\n   (zip (map fst insts)\n     (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))) =\n  Some (Fv fresh_idn ty)\n  lookup (\\<lambda>x. x = (fresh_idn, ty))\n   (zip (zip fresh_idns (map (snd \\<circ> fst) insts)) (map snd insts)) =\n  Some u\n\ngoal (1 subgoal):\n 1. subst_term insts (Fv idn ty) =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       (Fv idn ty))", "by simp"], ["proof (state)\nthis:\n  subst_term insts (Fv idn ty) =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     (Fv idn ty))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_term insts (Fv idn ty) =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     (Fv idn ty))\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Ct x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Ct x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Bv x) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Bv x) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 3. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Abs x1 t) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Abs x1 t) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t1 \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t1 =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (fv t2 \\<union>\n                         \\<Union> (fv ` snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_term insts t2 =\n                             subst_term\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_term\n                                (zip (map fst insts)\n                                  (map2 Fv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (t1 $ t2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (t1 $ t2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Ct x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Ct x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Bv x) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Bv x) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 3. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Abs x1 t) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Abs x1 t) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t1 \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t1 =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (fv t2 \\<union>\n                         \\<Union> (fv ` snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_term insts t2 =\n                             subst_term\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_term\n                                (zip (map fst insts)\n                                  (map2 Fv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (t1 $ t2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (t1 $ t2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "case (App t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv t1 \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts t1 =\n                    subst_term\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_term\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       t1)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv t2 \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts t2 =\n                    subst_term\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_term\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       t2)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv (t1 $ t2) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Ct x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Ct x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Bv x) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Bv x) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 3. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Abs x1 t) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Abs x1 t) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t1 \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t1 =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (fv t2 \\<union>\n                         \\<Union> (fv ` snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_term insts t2 =\n                             subst_term\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_term\n                                (zip (map fst insts)\n                                  (map2 Fv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (t1 $ t2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (t1 $ t2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv t1 \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts t1 =\n                    subst_term\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_term\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       t1)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv t2 \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts t2 =\n                    subst_term\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_term\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       t2)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv (t1 $ t2) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Ct x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Ct x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Bv x) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Bv x) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 3. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Abs x1 t) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Abs x1 t) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t1 \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t1 =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (fv t2 \\<union>\n                         \\<Union> (fv ` snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_term insts t2 =\n                             subst_term\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_term\n                                (zip (map fst insts)\n                                  (map2 Fv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (t1 $ t2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (t1 $ t2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "have \"fv t1 \\<subseteq> fv (t1 $ t2)\" \"fv t2 \\<subseteq> fv (t1 $ t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv t1 \\<subseteq> fv (t1 $ t2) &&& fv t2 \\<subseteq> fv (t1 $ t2)", "by simp_all"], ["proof (state)\nthis:\n  fv t1 \\<subseteq> fv (t1 $ t2)\n  fv t2 \\<subseteq> fv (t1 $ t2)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Ct x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Ct x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Bv x) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Bv x) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 3. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Abs x1 t) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Abs x1 t) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t1 \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t1 =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (fv t2 \\<union>\n                         \\<Union> (fv ` snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_term insts t2 =\n                             subst_term\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_term\n                                (zip (map fst insts)\n                                  (map2 Fv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (t1 $ t2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (t1 $ t2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv t1 \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts t1 =\n                    subst_term\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_term\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       t1)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv t2 \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts t2 =\n                    subst_term\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_term\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       t2)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv (t1 $ t2) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n  fv t1 \\<subseteq> fv (t1 $ t2)\n  fv t2 \\<subseteq> fv (t1 $ t2)", "have \"subst_term insts t1 =\n    subst_term (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t1)\" \n  and \"subst_term insts t2 =\n    subst_term (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv t1 \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts t1 =\n                    subst_term\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_term\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       t1)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv t2 \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts t2 =\n                    subst_term\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_term\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       t2)\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv (t1 $ t2) \\<union>\n               \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n  fv t1 \\<subseteq> fv (t1 $ t2)\n  fv t2 \\<subseteq> fv (t1 $ t2)\n\ngoal (1 subgoal):\n 1. subst_term insts t1 =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t1) &&&\n    subst_term insts t2 =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t2)", "by blast+"], ["proof (state)\nthis:\n  subst_term insts t1 =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t1)\n  subst_term insts t2 =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t2)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Ct x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Ct x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Bv x) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Bv x) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 3. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Abs x1 t) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Abs x1 t) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))\n 4. \\<And>t1 t2 fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t1 \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t1 =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t1);\n        \\<And>fresh_idns insts.\n           \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n            distinct (map fst insts);\n            \\<forall>idn\\<in>set fresh_idns.\n               idn\n               \\<notin> fst `\n                        (fv t2 \\<union>\n                         \\<Union> (fv ` snd ` set insts) \\<union>\n                         fst ` set insts)\\<rbrakk>\n           \\<Longrightarrow> subst_term insts t2 =\n                             subst_term\n                              (zip (zip fresh_idns\n                                     (map snd (map fst insts)))\n                                (map snd insts))\n                              (subst_term\n                                (zip (map fst insts)\n                                  (map2 Fv fresh_idns\n                                    (map snd (map fst insts))))\n                                t2);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (t1 $ t2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (t1 $ t2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (t1 $ t2))", "then"], ["proof (chain)\npicking this:\n  subst_term insts t1 =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t1)\n  subst_term insts t2 =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t2)", "show ?case"], ["proof (prove)\nusing this:\n  subst_term insts t1 =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t1)\n  subst_term insts t2 =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t2)\n\ngoal (1 subgoal):\n 1. subst_term insts (t1 $ t2) =\n    subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       (t1 $ t2))", "by simp"], ["proof (state)\nthis:\n  subst_term insts (t1 $ t2) =\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     (t1 $ t2))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Ct x1 x2) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Ct x1 x2) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Ct x1 x2))\n 2. \\<And>x fresh_idns insts.\n       \\<lbrakk>length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Bv x) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Bv x) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Bv x))\n 3. \\<And>x1 t fresh_idns insts.\n       \\<lbrakk>\\<And>fresh_idns insts.\n                   \\<lbrakk>length fresh_idns = length insts;\n                    distinct fresh_idns; distinct (map fst insts);\n                    \\<forall>idn\\<in>set fresh_idns.\n                       idn\n                       \\<notin> fst `\n                                (fv t \\<union>\n                                 \\<Union> (fv ` snd ` set insts) \\<union>\n                                 fst ` set insts)\\<rbrakk>\n                   \\<Longrightarrow> subst_term insts t =\n                                     subst_term\n(zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n(subst_term\n  (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t);\n        length fresh_idns = length insts; distinct fresh_idns;\n        distinct (map fst insts);\n        \\<forall>idn\\<in>set fresh_idns.\n           idn\n           \\<notin> fst `\n                    (fv (Abs x1 t) \\<union>\n                     \\<Union> (fv ` snd ` set insts) \\<union>\n                     fst ` set insts)\\<rbrakk>\n       \\<Longrightarrow> subst_term insts (Abs x1 t) =\n                         subst_term\n                          (zip (zip fresh_idns (map snd (map fst insts)))\n                            (map snd insts))\n                          (subst_term\n                            (zip (map fst insts)\n                              (map2 Fv fresh_idns\n                                (map snd (map fst insts))))\n                            (Abs x1 t))", "qed auto"], ["", "corollary subst_term_combine':\n  assumes \"length fresh_idns = length insts\"\n  assumes \"distinct fresh_idns\"\n  assumes \"distinct (map fst insts)\"\n  assumes \"\\<forall>idn \\<in> set fresh_idns . idn \\<notin> fst ` (fv t \\<union> (\\<Union>t\\<in>snd ` set insts . (fv t)) \n    \\<union> (fst ` set insts))\"\n  shows \"subst_term insts t\n    = fold (\\<lambda>single acc . subst_term [single] acc) (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (fold (\\<lambda>single acc . subst_term [single] acc) (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "have s1: \"fst ` set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n    = fst ` set insts \""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "have \"fst ` set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n      = set (map fst (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    set (map fst\n          (zip (map fst insts)\n            (map2 Fv fresh_idns (map snd (map fst insts)))))", "by auto"], ["proof (state)\nthis:\n  fst `\n  set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) =\n  set (map fst\n        (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))))\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "also"], ["proof (state)\nthis:\n  fst `\n  set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) =\n  set (map fst\n        (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))))\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "have \"\\<dots> = set (map fst insts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst\n          (zip (map fst insts)\n            (map2 Fv fresh_idns (map snd (map fst insts))))) =\n    set (map fst insts)", "using map_fst_zip assms(1)"], ["proof (prove)\nusing this:\n  length ?xs = length ?ys \\<Longrightarrow> map fst (zip ?xs ?ys) = ?xs\n  length fresh_idns = length insts\n\ngoal (1 subgoal):\n 1. set (map fst\n          (zip (map fst insts)\n            (map2 Fv fresh_idns (map snd (map fst insts))))) =\n    set (map fst insts)", "by auto"], ["proof (state)\nthis:\n  set (map fst\n        (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts))))) =\n  set (map fst insts)\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "also"], ["proof (state)\nthis:\n  set (map fst\n        (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts))))) =\n  set (map fst insts)\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "have \"\\<dots> = fst ` set insts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map fst insts) = fst ` set insts", "by simp"], ["proof (state)\nthis:\n  set (map fst insts) = fst ` set insts\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "finally"], ["proof (chain)\npicking this:\n  fst `\n  set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) =\n  fst ` set insts", "show ?thesis"], ["proof (prove)\nusing this:\n  fst `\n  set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) =\n  fst ` set insts\n\ngoal (1 subgoal):\n 1. fst `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    fst ` set insts", "."], ["proof (state)\nthis:\n  fst `\n  set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) =\n  fst ` set insts\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst `\n  set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) =\n  fst ` set insts\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "have \"snd ` set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n    = set (map2 Fv fresh_idns (map snd (map fst insts)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    set (map2 Fv fresh_idns (map snd (map fst insts)))", "using map_snd_zip assms(1)"], ["proof (prove)\nusing this:\n  length ?xs = length ?ys \\<Longrightarrow> map snd (zip ?xs ?ys) = ?ys\n  length fresh_idns = length insts\n\ngoal (1 subgoal):\n 1. snd `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts)))) =\n    set (map2 Fv fresh_idns (map snd (map fst insts)))", "by (metis (no_types, lifting) image_set length_map)"], ["proof (state)\nthis:\n  snd `\n  set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) =\n  set (map2 Fv fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "hence \"(\\<Union> (fv ` snd ` set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))))\n    = (\\<Union> (fv ` set (map2 Fv fresh_idns (map snd (map fst insts)))))\""], ["proof (prove)\nusing this:\n  snd `\n  set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) =\n  set (map2 Fv fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (fv `\n      snd `\n      set (zip (map fst insts)\n            (map2 Fv fresh_idns (map snd (map fst insts))))) =\n    \\<Union> (fv ` set (map2 Fv fresh_idns (map snd (map fst insts))))", "by simp"], ["proof (state)\nthis:\n  \\<Union>\n   (fv `\n    snd `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts))))) =\n  \\<Union> (fv ` set (map2 Fv fresh_idns (map snd (map fst insts))))\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "from assms(1) this"], ["proof (chain)\npicking this:\n  length fresh_idns = length insts\n  \\<Union>\n   (fv `\n    snd `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts))))) =\n  \\<Union> (fv ` set (map2 Fv fresh_idns (map snd (map fst insts))))", "have s2:\n    \"(\\<Union> (fv ` snd ` set (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))))\n    = (set (zip fresh_idns (map snd (map fst insts))))\""], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  \\<Union>\n   (fv `\n    snd `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts))))) =\n  \\<Union> (fv ` set (map2 Fv fresh_idns (map snd (map fst insts))))\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (fv `\n      snd `\n      set (zip (map fst insts)\n            (map2 Fv fresh_idns (map snd (map fst insts))))) =\n    set (zip fresh_idns (map snd (map fst insts)))", "using assms(1)"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  \\<Union>\n   (fv `\n    snd `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts))))) =\n  \\<Union> (fv ` set (map2 Fv fresh_idns (map snd (map fst insts))))\n  length fresh_idns = length insts\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (fv `\n      snd `\n      set (zip (map fst insts)\n            (map2 Fv fresh_idns (map snd (map fst insts))))) =\n    set (zip fresh_idns (map snd (map fst insts)))", "by (induction fresh_idns insts rule: list_induct2) auto"], ["proof (state)\nthis:\n  \\<Union>\n   (fv `\n    snd `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts))))) =\n  set (zip fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "hence s3: \"\\<Union> (fv ` snd ` set (zip (map fst insts)\n                   (map2 Fv fresh_idns (map (snd \\<circ> fst) insts))))\n    = set (zip fresh_idns (map snd (map fst insts)))\""], ["proof (prove)\nusing this:\n  \\<Union>\n   (fv `\n    snd `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map snd (map fst insts))))) =\n  set (zip fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. \\<Union>\n     (fv `\n      snd `\n      set (zip (map fst insts)\n            (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)))) =\n    set (zip fresh_idns (map snd (map fst insts)))", "by simp"], ["proof (state)\nthis:\n  \\<Union>\n   (fv `\n    snd `\n    set (zip (map fst insts)\n          (map2 Fv fresh_idns (map (snd \\<circ> fst) insts)))) =\n  set (zip fresh_idns (map snd (map fst insts)))\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "have \"idn \\<notin> fst ` fst ` set insts\" if \"idn \\<in> set fresh_idns\" for idn"], ["proof (prove)\ngoal (1 subgoal):\n 1. idn \\<notin> fst ` fst ` set insts", "using that assms"], ["proof (prove)\nusing this:\n  idn \\<in> set fresh_idns\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv t \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. idn \\<notin> fst ` fst ` set insts", "by auto"], ["proof (state)\nthis:\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  ?idn \\<notin> fst ` fst ` set insts\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "hence I: \"(idn, T) \\<notin> fst ` set insts\" if \"idn \\<in> set fresh_idns\" for idn T"], ["proof (prove)\nusing this:\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  ?idn \\<notin> fst ` fst ` set insts\n\ngoal (1 subgoal):\n 1. (idn, T) \\<notin> fst ` set insts", "using that assms"], ["proof (prove)\nusing this:\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  ?idn \\<notin> fst ` fst ` set insts\n  idn \\<in> set fresh_idns\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv t \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. (idn, T) \\<notin> fst ` set insts", "by (metis fst_conv image_eqI)"], ["proof (state)\nthis:\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  (?idn, ?T) \\<notin> fst ` set insts\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "have u1: \"(subst_term (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\n    = fold (\\<lambda>single acc . subst_term [single] acc) (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t", "apply (rule subst_term_stepwise)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (map fst\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))))\n 2. \\<And>x.\n       x \\<in> \\<Union>\n                (fv `\n                 snd `\n                 set (zip (map fst insts)\n                       (map2 Fv fresh_idns\n                         (map snd (map fst insts))))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (map fst insts)\n                        (map2 Fv fresh_idns (map snd (map fst insts))))", "using assms"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv t \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (2 subgoals):\n 1. distinct\n     (map fst\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))))\n 2. \\<And>x.\n       x \\<in> \\<Union>\n                (fv `\n                 snd `\n                 set (zip (map fst insts)\n                       (map2 Fv fresh_idns\n                         (map snd (map fst insts))))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (map fst insts)\n                        (map2 Fv fresh_idns (map snd (map fst insts))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (fv `\n                 snd `\n                 set (zip (map fst insts)\n                       (map2 Fv fresh_idns\n                         (map snd (map fst insts))))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (map fst insts)\n                        (map2 Fv fresh_idns (map snd (map fst insts))))", "apply (simp only: s1 s2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (zip fresh_idns\n                     (map snd (map fst insts))) \\<Longrightarrow>\n       x \\<notin> fst ` set insts", "using assms I"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv t \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n  ?idn \\<in> set fresh_idns \\<Longrightarrow>\n  (?idn, ?T) \\<notin> fst ` set insts\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (zip fresh_idns\n                     (map snd (map fst insts))) \\<Longrightarrow>\n       x \\<notin> fst ` set insts", "by (metis prod.collapse set_zip_leftD)"], ["proof (state)\nthis:\n  subst_term\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "moreover"], ["proof (state)\nthis:\n  subst_term\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "have u2: \"subst_term (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n    (subst_term (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\n  = fold (\\<lambda>single acc . subst_term [single] acc) (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n    (subst_term (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t) =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "apply (rule subst_term_stepwise)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct\n     (map fst\n       (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)))\n 2. \\<And>x.\n       x \\<in> \\<Union>\n                (fv `\n                 snd `\n                 set (zip (zip fresh_idns (map snd (map fst insts)))\n                       (map snd insts))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (zip fresh_idns (map snd (map fst insts)))\n                        (map snd insts))", "using assms"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv t \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (2 subgoals):\n 1. distinct\n     (map fst\n       (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)))\n 2. \\<And>x.\n       x \\<in> \\<Union>\n                (fv `\n                 snd `\n                 set (zip (zip fresh_idns (map snd (map fst insts)))\n                       (map snd insts))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (zip fresh_idns (map snd (map fst insts)))\n                        (map snd insts))", "apply (simp add: distinct_zipI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (fv `\n                 snd `\n                 set (zip (zip fresh_idns (map snd (map fst insts)))\n                       (map snd insts))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (zip fresh_idns (map snd (map fst insts)))\n                        (map snd insts))", "using assms"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv t \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union>\n                (fv `\n                 snd `\n                 set (zip (zip fresh_idns (map snd (map fst insts)))\n                       (map snd insts))) \\<Longrightarrow>\n       x \\<notin> fst `\n                  set (zip (zip fresh_idns (map snd (map fst insts)))\n                        (map snd insts))", "by (smt UnCI imageE image_eqI length_map map_snd_zip prod.collapse set_map set_zip_leftD)"], ["proof (state)\nthis:\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t) =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "ultimately"], ["proof (chain)\npicking this:\n  subst_term\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t) =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)", "have unfold: \"subst_term (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n    (subst_term (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\n   = fold (\\<lambda>single acc . subst_term [single] acc) (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n        (fold (\\<lambda>single acc . subst_term [single] acc) (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\""], ["proof (prove)\nusing this:\n  subst_term\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t) =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\n\ngoal (1 subgoal):\n 1. subst_term\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (subst_term\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t) =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "by simp"], ["proof (state)\nthis:\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t) =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "using assms subst_term_combine unfold"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv t \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv ?t \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts ?t =\n                    subst_term\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (subst_term\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       ?t)\n  subst_term\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (subst_term\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n     t) =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\n\ngoal (1 subgoal):\n 1. subst_term insts t =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       t)", "by auto"], ["proof (state)\nthis:\n  subst_term insts t =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_term_not_loose_bvar:\n  assumes \"\\<not> loose_bvar t n\" \"is_closed b\" \n  shows \"\\<not> loose_bvar (subst_term [((idn,T),b)] t) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> loose_bvar (subst_term [((idn, T), b)] t) n", "using assms"], ["proof (prove)\nusing this:\n  \\<not> loose_bvar t n\n  is_closed b\n\ngoal (1 subgoal):\n 1. \\<not> loose_bvar (subst_term [((idn, T), b)] t) n", "by (induction t arbitrary: n idn T b) (auto simp add: is_open_def loose_bvar_leq)"], ["", "(* This seems a bit to weak, second premise probably needs to be more general *)"], ["", "lemma bind_fv2_subst_bv1_eq_subst_term: \n  assumes \"\\<not>loose_bvar t n\" \"is_closed b\"\n  shows \"subst_term [((idn,T),b)] t = subst_bv1 (bind_fv2 (idn, T) n t) n b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term [((idn, T), b)] t = subst_bv1 (bind_fv2 (idn, T) n t) n b", "using assms"], ["proof (prove)\nusing this:\n  \\<not> loose_bvar t n\n  is_closed b\n\ngoal (1 subgoal):\n 1. subst_term [((idn, T), b)] t = subst_bv1 (bind_fv2 (idn, T) n t) n b", "by (induction t arbitrary: n idn T b) (auto simp add: is_open_def incr_boundvars_def)"], ["", "corollary\n  assumes \"is_closed t\" \"is_closed b\" \n  shows \"subst_bv b (bind_fv (idn, T) t) = (subst_term [((idn, T),b)] t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bv b (bind_fv (idn, T) t) = subst_term [((idn, T), b)] t", "using assms bind_fv2_subst_bv1_eq_subst_term"], ["proof (prove)\nusing this:\n  is_closed t\n  is_closed b\n  \\<lbrakk>\\<not> loose_bvar ?t ?n; is_closed ?b\\<rbrakk>\n  \\<Longrightarrow> subst_term [((?idn, ?T), ?b)] ?t =\n                    subst_bv1 (bind_fv2 (?idn, ?T) ?n ?t) ?n ?b\n\ngoal (1 subgoal):\n 1. subst_bv b (bind_fv (idn, T) t) = subst_term [((idn, T), b)] t", "by (simp add: bind_fv_def subst_bv_def is_open_def)"], ["", "corollary instantiate_var_same_typ:\n  assumes typ_a: \"typ_of a = Some \\<tau>\"\n  assumes closed_B: \"\\<not> loose_bvar B lev\"\n  shows \"subst_bv1 (bind_fv2 (x, \\<tau>) lev B) lev a = subst_term [((x, \\<tau>), a)] B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bv1 (bind_fv2 (x, \\<tau>) lev B) lev a =\n    subst_term [((x, \\<tau>), a)] B", "using bind_fv2_subst_bv1_eq_subst_term assms typ_of_imp_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> loose_bvar ?t ?n; is_closed ?b\\<rbrakk>\n  \\<Longrightarrow> subst_term [((?idn, ?T), ?b)] ?t =\n                    subst_bv1 (bind_fv2 (?idn, ?T) ?n ?t) ?n ?b\n  typ_of a = Some \\<tau>\n  \\<not> loose_bvar B lev\n  typ_of ?t = Some ?ty \\<Longrightarrow> is_closed ?t\n\ngoal (1 subgoal):\n 1. subst_bv1 (bind_fv2 (x, \\<tau>) lev B) lev a =\n    subst_term [((x, \\<tau>), a)] B", "by metis"], ["", "corollary instantiate_var_same_typ':\n  assumes typ_a: \"typ_of a = Some \\<tau>\"\n  assumes closed_B: \"is_closed B\"\n  shows \"subst_bv a (bind_fv (x, \\<tau>) B) = subst_term [((x, \\<tau>), a)] B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_bv a (bind_fv (x, \\<tau>) B) = subst_term [((x, \\<tau>), a)] B", "using instantiate_var_same_typ bind_fv_def subst_bv_def is_open_def assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>typ_of ?a = Some ?\\<tau>; \\<not> loose_bvar ?B ?lev\\<rbrakk>\n  \\<Longrightarrow> subst_bv1 (bind_fv2 (?x, ?\\<tau>) ?lev ?B) ?lev ?a =\n                    subst_term [((?x, ?\\<tau>), ?a)] ?B\n  bind_fv ?vT ?t = bind_fv2 ?vT 0 ?t\n  subst_bv ?u ?t \\<equiv> subst_bv1 ?t 0 ?u\n  is_open ?t \\<equiv> loose_bvar ?t 0\n  typ_of a = Some \\<tau>\n  is_closed B\n\ngoal (1 subgoal):\n 1. subst_bv a (bind_fv (x, \\<tau>) B) = subst_term [((x, \\<tau>), a)] B", "by auto"], ["", "corollary instantiate_var_same_type'':\n  assumes typ_a: \"typ_of a = Some \\<tau>\"\n  assumes closed_B: \"is_closed B\"\n  shows \"Abs \\<tau> (bind_fv (x, \\<tau>) B) \\<bullet> a = subst_term [((x, \\<tau>), a)] B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_fv x \\<tau> B \\<bullet> a = subst_term [((x, \\<tau>), a)] B", "using assms instantiate_var_same_typ'"], ["proof (prove)\nusing this:\n  typ_of a = Some \\<tau>\n  is_closed B\n  \\<lbrakk>typ_of ?a = Some ?\\<tau>; is_closed ?B\\<rbrakk>\n  \\<Longrightarrow> subst_bv ?a (bind_fv (?x, ?\\<tau>) ?B) =\n                    subst_term [((?x, ?\\<tau>), ?a)] ?B\n\ngoal (1 subgoal):\n 1. Abs_fv x \\<tau> B \\<bullet> a = subst_term [((x, \\<tau>), a)] B", "by simp"], ["", "lemma instantiate_vars_same_typ:\n  assumes typs: \"list_all (\\<lambda>((idx, ty), t) . typ_of t = Some ty) insts\"\n  assumes closed_B: \"\\<not> loose_bvar B lev\"\n  shows \"fold (\\<lambda>((idx, ty), t) B . subst_bv1 (bind_fv2 (idx, ty) lev B) lev t) insts B\n    = fold (\\<lambda>single . subst_term [single]) insts B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     insts B =\n    fold (\\<lambda>single. subst_term [single]) insts B", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) insts\n  \\<not> loose_bvar B lev\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     insts B =\n    fold (\\<lambda>single. subst_term [single]) insts B", "proof (induction insts arbitrary: B lev)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B lev.\n       \\<lbrakk>list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) [];\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          [] B =\n                         fold (\\<lambda>single. subst_term [single]) [] B\n 2. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "case Nil"], ["proof (state)\nthis:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   []\n  \\<not> loose_bvar B lev\n\ngoal (2 subgoals):\n 1. \\<And>B lev.\n       \\<lbrakk>list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) [];\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          [] B =\n                         fold (\\<lambda>single. subst_term [single]) [] B\n 2. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "then"], ["proof (chain)\npicking this:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   []\n  \\<not> loose_bvar B lev", "show ?case"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   []\n  \\<not> loose_bvar B lev\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (idx, ty) \\<Rightarrow>\n              \\<lambda>t B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n            b)\n     [] B =\n    fold (\\<lambda>single. subst_term [single]) [] B", "by simp"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n          b)\n   [] B =\n  fold (\\<lambda>single. subst_term [single]) [] B\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>list_all\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n                   b)\n            xs;\n   \\<not> loose_bvar ?B ?lev\\<rbrakk>\n  \\<Longrightarrow> fold\n                     (\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow>\n                           (case a of\n                            (idx, ty) \\<Rightarrow>\n                              \\<lambda>t B.\n                                 subst_bv1 (bind_fv2 (idx, ty) ?lev B) ?lev\n                                  t)\n                            b)\n                     xs ?B =\n                    fold (\\<lambda>single. subst_term [single]) xs ?B\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  \\<not> loose_bvar B lev\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>list_all\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n                   b)\n            xs;\n   \\<not> loose_bvar ?B ?lev\\<rbrakk>\n  \\<Longrightarrow> fold\n                     (\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow>\n                           (case a of\n                            (idx, ty) \\<Rightarrow>\n                              \\<lambda>t B.\n                                 subst_bv1 (bind_fv2 (idx, ty) ?lev B) ?lev\n                                  t)\n                            b)\n                     xs ?B =\n                    fold (\\<lambda>single. subst_term [single]) xs ?B\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  \\<not> loose_bvar B lev", "obtain idn ty t where x: \"x = ((idn, ty), t)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all\n            (\\<lambda>a.\n                case a of\n                (a, b) \\<Rightarrow>\n                  (case a of\n                   (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n                   b)\n            xs;\n   \\<not> loose_bvar ?B ?lev\\<rbrakk>\n  \\<Longrightarrow> fold\n                     (\\<lambda>a.\n                         case a of\n                         (a, b) \\<Rightarrow>\n                           (case a of\n                            (idx, ty) \\<Rightarrow>\n                              \\<lambda>t B.\n                                 subst_bv1 (bind_fv2 (idx, ty) ?lev B) ?lev\n                                  t)\n                            b)\n                     xs ?B =\n                    fold (\\<lambda>single. subst_term [single]) xs ?B\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  \\<not> loose_bvar B lev\n\ngoal (1 subgoal):\n 1. (\\<And>idn ty t.\n        x = ((idn, ty), t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  x = ((idn, ty), t)\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "hence typ_a: \"typ_of t = Some ty\""], ["proof (prove)\nusing this:\n  x = ((idn, ty), t)\n\ngoal (1 subgoal):\n 1. typ_of t = Some ty", "using Cons.prems"], ["proof (prove)\nusing this:\n  x = ((idn, ty), t)\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  \\<not> loose_bvar B lev\n\ngoal (1 subgoal):\n 1. typ_of t = Some ty", "by simp"], ["proof (state)\nthis:\n  typ_of t = Some ty\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "have typs: \"list_all (\\<lambda>((idx, ty), t) . typ_of t = Some ty) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) xs", "using Cons.prems"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  \\<not> loose_bvar B lev\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) xs", "by simp"], ["proof (state)\nthis:\n  list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) xs\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "have not_loose: \"\\<not> loose_bvar (subst_term [((idn, ty), t)] B) lev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> loose_bvar (subst_term [((idn, ty), t)] B) lev", "using Cons.prems subst_term_not_loose_bvar typ_a typ_of_imp_closed"], ["proof (prove)\nusing this:\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  \\<not> loose_bvar B lev\n  \\<lbrakk>\\<not> loose_bvar ?t ?n; is_closed ?b\\<rbrakk>\n  \\<Longrightarrow> \\<not> loose_bvar (subst_term [((?idn, ?T), ?b)] ?t) ?n\n  typ_of t = Some ty\n  typ_of ?t = Some ?ty \\<Longrightarrow> is_closed ?t\n\ngoal (1 subgoal):\n 1. \\<not> loose_bvar (subst_term [((idn, ty), t)] B) lev", "by simp"], ["proof (state)\nthis:\n  \\<not> loose_bvar (subst_term [((idn, ty), t)] B) lev\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "note single = instantiate_var_same_typ[OF typ_a Cons.prems(2), of idn]"], ["proof (state)\nthis:\n  subst_bv1 (bind_fv2 (idn, ty) lev B) lev t = subst_term [((idn, ty), t)] B\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "have \"fold (\\<lambda>((idx, ty), t) B . subst_bv1 (bind_fv2 (idx, ty) lev B) lev t) (x # xs) B\n    = fold (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t) xs \n        (subst_bv1 (bind_fv2 (idn, ty) lev B) lev t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     (x # xs) B =\n    fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     xs (subst_bv1 (bind_fv2 (idn, ty) lev B) lev t)", "by (simp add: x)"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   (x # xs) B =\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   xs (subst_bv1 (bind_fv2 (idn, ty) lev B) lev t)\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "also"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   (x # xs) B =\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   xs (subst_bv1 (bind_fv2 (idn, ty) lev B) lev t)\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "have \"\\<dots> = fold (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t) xs\n    (subst_term [((idn, ty), t)] B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     xs (subst_bv1 (bind_fv2 (idn, ty) lev B) lev t) =\n    fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     xs (subst_term [((idn, ty), t)] B)", "using single"], ["proof (prove)\nusing this:\n  subst_bv1 (bind_fv2 (idn, ty) lev B) lev t = subst_term [((idn, ty), t)] B\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     xs (subst_bv1 (bind_fv2 (idn, ty) lev B) lev t) =\n    fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     xs (subst_term [((idn, ty), t)] B)", "by simp"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   xs (subst_bv1 (bind_fv2 (idn, ty) lev B) lev t) =\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   xs (subst_term [((idn, ty), t)] B)\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "also"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   xs (subst_bv1 (bind_fv2 (idn, ty) lev B) lev t) =\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   xs (subst_term [((idn, ty), t)] B)\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "have \"\\<dots> = fold (\\<lambda>single. subst_term [single]) xs (subst_term [((idn, ty), t)] B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     xs (subst_term [((idn, ty), t)] B) =\n    fold (\\<lambda>single. subst_term [single]) xs\n     (subst_term [((idn, ty), t)] B)", "using Cons.IH[where B = \"subst_term [((idn, ty), t)] B\", OF typs not_loose] Cons.prems"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n          b)\n   xs (subst_term [((idn, ty), t)] B) =\n  fold (\\<lambda>single. subst_term [single]) xs\n   (subst_term [((idn, ty), t)] B)\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  \\<not> loose_bvar B lev\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     xs (subst_term [((idn, ty), t)] B) =\n    fold (\\<lambda>single. subst_term [single]) xs\n     (subst_term [((idn, ty), t)] B)", "by blast"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   xs (subst_term [((idn, ty), t)] B) =\n  fold (\\<lambda>single. subst_term [single]) xs\n   (subst_term [((idn, ty), t)] B)\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "also"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   xs (subst_term [((idn, ty), t)] B) =\n  fold (\\<lambda>single. subst_term [single]) xs\n   (subst_term [((idn, ty), t)] B)\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "have \"\\<dots> = fold (\\<lambda>single. subst_term [single]) (x # xs) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_term [single]) xs\n     (subst_term [((idn, ty), t)] B) =\n    fold (\\<lambda>single. subst_term [single]) (x # xs) B", "by (simp add: x)"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_term [single]) xs\n   (subst_term [((idn, ty), t)] B) =\n  fold (\\<lambda>single. subst_term [single]) (x # xs) B\n\ngoal (1 subgoal):\n 1. \\<And>a insts B lev.\n       \\<lbrakk>\\<And>B lev.\n                   \\<lbrakk>list_all\n                             (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                             insts;\n                    \\<not> loose_bvar B lev\\<rbrakk>\n                   \\<Longrightarrow> fold\n(\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\ninsts B =\n                                     fold\n(\\<lambda>single. subst_term [single]) insts B;\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (a # insts);\n        \\<not> loose_bvar B lev\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>((idx, ty), t) B.\n                              subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n                          (a # insts) B =\n                         fold (\\<lambda>single. subst_term [single])\n                          (a # insts) B", "finally"], ["proof (chain)\npicking this:\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   (x # xs) B =\n  fold (\\<lambda>single. subst_term [single]) (x # xs) B", "show ?case"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n   (x # xs) B =\n  fold (\\<lambda>single. subst_term [single]) (x # xs) B\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>a.\n         case a of\n         (a, b) \\<Rightarrow>\n           (case a of\n            (idx, ty) \\<Rightarrow>\n              \\<lambda>t B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n            b)\n     (x # xs) B =\n    fold (\\<lambda>single. subst_term [single]) (x # xs) B", "."], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n          b)\n   (x # xs) B =\n  fold (\\<lambda>single. subst_term [single]) (x # xs) B\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary instantiate_vars_same_typ':\n  assumes typs: \"list_all (\\<lambda>((idx, ty), t) . typ_of t = Some ty) insts\"\n  assumes closed_B: \"\\<not> loose_bvar B lev\"\n  assumes distinct: \"distinct (map fst insts)\"\n  assumes no_overlap: \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` (set insts) . fv t) \\<Longrightarrow> x \\<notin> fst ` (set insts)\"\n  shows \"fold (\\<lambda>((idx, ty), t) B . subst_bv1 (bind_fv2 (idx, ty) lev B) lev t) insts B\n    = subst_term insts B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     insts B =\n    subst_term insts B", "using instantiate_vars_same_typ subst_term_stepwise[symmetric] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) ?insts;\n   \\<not> loose_bvar ?B ?lev\\<rbrakk>\n  \\<Longrightarrow> fold\n                     (\\<lambda>((idx, ty), t) B.\n                         subst_bv1 (bind_fv2 (idx, ty) ?lev B) ?lev t)\n                     ?insts ?B =\n                    fold (\\<lambda>single. subst_term [single]) ?insts ?B\n  \\<lbrakk>distinct (map fst ?insts);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set ?insts) \\<Longrightarrow>\n      x \\<notin> fst ` set ?insts\\<rbrakk>\n  \\<Longrightarrow> fold (\\<lambda>single. subst_term [single]) ?insts ?t =\n                    subst_term ?insts ?t\n  list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) insts\n  \\<not> loose_bvar B lev\n  distinct (map fst insts)\n  ?x \\<in> \\<Union> (fv ` snd ` set insts) \\<Longrightarrow>\n  ?x \\<notin> fst ` set insts\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>((idx, ty), t) B. subst_bv1 (bind_fv2 (idx, ty) lev B) lev t)\n     insts B =\n    subst_term insts B", "by simp"], ["", "end"]]}