{"file_name": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker/CheckerExe.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker", "problem_names": ["lemma typ_ok_code: \n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"typ_ok (translate_theory \\<Theta>) ty = exetyp_ok \\<Theta> ty\"", "lemma execlass_leq_code: \"class_leq (set cs) c1 c2 = execlass_leq cs c1 c2\"", "lemma exesort_les_code: \"sort_leq (set cs) c1 c2 = exesort_leq cs c1 c2\"", "lemma exehas_sort_imp_has_sort: \n  assumes \"exe_osig_conds (sub, tcs)\"\n  shows \"exehas_sort (sub, tcs) T S \\<Longrightarrow> has_sort (translate_osig (sub, tcs)) T S\"", "lemma has_sort_imp_exehas_sort: \n  assumes \"exe_osig_conds (sub, tcs)\"\n  shows \"has_sort (translate_osig (sub, tcs)) T S \\<Longrightarrow> exehas_sort (sub, tcs) T S\"", "lemma has_sort_code:\n  assumes \"exe_osig_conds oss\"\n  shows \"has_sort (translate_osig oss) T S = exehas_sort oss T S\"", "lemma has_sort_code':\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"has_sort (osig (sig (translate_theory \\<Theta>))) T S \n    = exehas_sort (exesorts (exesig \\<Theta>)) T S\"", "lemma inst_ok_code1:\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"list_all (exetyp_ok \\<Theta>) (map snd insts) = list_all (typ_ok (translate_theory \\<Theta>)) (map snd insts)\"", "lemma inst_ok_code2:\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"list_all (\\<lambda>((idn, S), T) . has_sort (osig (sig (translate_theory \\<Theta>))) T S) insts\n    = list_all (\\<lambda>((idn, S), T) . exehas_sort (exesorts (exesig \\<Theta>)) T S) insts\"", "lemma inst_ok_code:\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"inst_ok (translate_theory \\<Theta>) insts = exeinst_ok \\<Theta> insts\"", "lemma term_ok_code:\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"term_ok (translate_theory \\<Theta>) t = exeterm_ok \\<Theta> t\"", "lemma of_class_code1: \n  assumes \"exe_wf_theory' thy\"\n  shows \"(has_sort (osig (sig (translate_theory thy))) ty {c} \\<and> typ_ok (translate_theory thy) ty)\n    = (exehas_sort (exesorts (exesig thy)) ty {c} \\<and> exetyp_ok thy ty)\"", "lemma of_class_code2: \n  assumes \"exe_wf_theory' thy\"\n  shows \"const_type (sig (translate_theory thy)) (const_of_class c) \n    = lookup (\\<lambda>k. k=const_of_class c) (execonst_type_of (exesig thy))\"", "lemma replay'_code:\n  assumes \"exe_wf_theory' thy\"\n  shows \"replay' (translate_theory thy) vs ns Hs P = exereplay' thy vs ns Hs P\"", "lemma replay''_code:\n  assumes \"exe_wf_theory' thy\"\n  shows \"replay'' (translate_theory thy) vs ns Hs P = exereplay'' thy vs ns Hs P\"", "lemma replay_code:\n  assumes \"exe_wf_theory' thy\"\n  shows \"replay (translate_theory thy) P = exereplay thy P\"", "lemma exe_check_proof_iff_check_proof: \n  \"exe_check_proof e P res \\<longleftrightarrow> check_proof (translate_theory e) P res\"", "lemma check_proof_sound:\n  shows \"exe_check_proof e P res \\<Longrightarrow> translate_theory e, set (hyps P) \\<turnstile> res\"", "lemma check_proof_really_sound:\n  shows \"exe_check_proof e P res \\<Longrightarrow> translate_theory e, set (hyps P) \\<tturnstile> res\""], "translations": [["", "lemma typ_ok_code: \n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"typ_ok (translate_theory \\<Theta>) ty = exetyp_ok \\<Theta> ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok (translate_theory \\<Theta>) ty = exetyp_ok \\<Theta> ty", "using assms typ_ok_sig_code"], ["proof (prove)\nusing this:\n  exe_wf_theory' \\<Theta>\n  exe_osig_conds (exesorts ?\\<Sigma>) \\<Longrightarrow>\n  typ_ok_sig (translate_signature ?\\<Sigma>) ?ty =\n  exetyp_ok_sig ?\\<Sigma> ?ty\n\ngoal (1 subgoal):\n 1. typ_ok (translate_theory \\<Theta>) ty = exetyp_ok \\<Theta> ty", "by (metis exe_sig_conds_def exe_wf_theory.simps exe_wf_theory_code exesignature.exhaust\n      exetheory.sel(1) sig.simps translate_theory.elims typ_ok_def wf_type_iff_typ_ok_sig)"], ["", "definition [simp]: \"execlass_leq cs c1 c2 = List.member cs (c1,c2)\""], ["", "lemma execlass_leq_code: \"class_leq (set cs) c1 c2 = execlass_leq cs c1 c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class_leq (set cs) c1 c2 = execlass_leq cs c1 c2", "by (simp add: class_leq_def class_les_def member_def)"], ["", "definition \"exesort_leq sub s1 s2 = (\\<forall>c\\<^sub>2 \\<in> s2 . \\<exists>c\\<^sub>1 \\<in> s1. execlass_leq sub c\\<^sub>1 c\\<^sub>2)\""], ["", "lemma exesort_les_code: \"sort_leq (set cs) c1 c2 = exesort_leq cs c1 c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_leq (set cs) c1 c2 = exesort_leq cs c1 c2", "by (simp add: execlass_leq_code exesort_leq_def sort_leq_def)"], ["", "fun exehas_sort :: \"exeosig \\<Rightarrow> typ \\<Rightarrow> sort \\<Rightarrow> bool\" where\n\"exehas_sort oss (Tv _ S) S' = exesort_leq (execlasses oss) S S'\" |\n\"exehas_sort oss (Ty a Ts) S =\n  (case lookup (\\<lambda>k. k=a) (exetcsigs oss) of\n  None \\<Rightarrow> False |\n  Some mgd \\<Rightarrow> (\\<forall>C \\<in> S.\n    case lookup (\\<lambda>k. k=C) mgd of\n        None \\<Rightarrow> False\n      | Some Ss \\<Rightarrow> list_all2 (exehas_sort oss) Ts Ss))\""], ["", "(* cleanup *)"], ["", "lemma exehas_sort_imp_has_sort: \n  assumes \"exe_osig_conds (sub, tcs)\"\n  shows \"exehas_sort (sub, tcs) T S \\<Longrightarrow> has_sort (translate_osig (sub, tcs)) T S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exehas_sort (sub, tcs) T S \\<Longrightarrow>\n    has_sort (translate_osig (sub, tcs)) T S", "proof (induction T arbitrary: S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    exehas_sort (sub, tcs) x2a S\\<rbrakk>\n                   \\<Longrightarrow> has_sort (translate_osig (sub, tcs))\nx2a S;\n        exehas_sort (sub, tcs) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       exehas_sort (sub, tcs) (Tv x1 x2) S \\<Longrightarrow>\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; exehas_sort (sub, tcs) ?x2a ?S\\<rbrakk>\n  \\<Longrightarrow> has_sort (translate_osig (sub, tcs)) ?x2a ?S\n  exehas_sort (sub, tcs) (Ty n Ts) S\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    exehas_sort (sub, tcs) x2a S\\<rbrakk>\n                   \\<Longrightarrow> has_sort (translate_osig (sub, tcs))\nx2a S;\n        exehas_sort (sub, tcs) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       exehas_sort (sub, tcs) (Tv x1 x2) S \\<Longrightarrow>\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S", "obtain sub' tcs' where sub'_tcs': \"translate_osig (sub, tcs) = (sub', tcs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sub' tcs'.\n        translate_osig (sub, tcs) = (sub', tcs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  translate_osig (sub, tcs) = (sub', tcs')\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    exehas_sort (sub, tcs) x2a S\\<rbrakk>\n                   \\<Longrightarrow> has_sort (translate_osig (sub, tcs))\nx2a S;\n        exehas_sort (sub, tcs) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       exehas_sort (sub, tcs) (Tv x1 x2) S \\<Longrightarrow>\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S", "obtain mgd where mgd: \"tcs' n = Some mgd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mgd.\n        tcs' n = Some mgd \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Ty.prems sub'_tcs'"], ["proof (prove)\nusing this:\n  exehas_sort (sub, tcs) (Ty n Ts) S\n  translate_osig (sub, tcs) = (sub', tcs')\n\ngoal (1 subgoal):\n 1. (\\<And>mgd.\n        tcs' n = Some mgd \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (simp split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>\\<forall>C\\<in>S.\n                   (\\<exists>y.\n                       lookup (\\<lambda>k. k = C) x2 = Some y) \\<and>\n                   (\\<forall>x2a.\n                       lookup (\\<lambda>k. k = C) x2 =\n                       Some x2a \\<longrightarrow>\n                       list_all2 (exehas_sort (sub, tcs)) Ts x2a);\n        (if exe_osig_conds (sub, tcs) then (set sub, translate_ars tcs)\n         else ({},\n               [STR ''A'' \\<mapsto>\n                [STR ''A'' \\<mapsto> [insert STR ''A'' full_sort]]])) =\n        (sub', tcs');\n        \\<And>mgd. tcs' n = Some mgd \\<Longrightarrow> thesis;\n        lookup (\\<lambda>k. k = n) tcs = Some x2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (metis assms exe_ars_conds_def exe_osig_conds_def in_alist_imp_in_map_of lookup_eq_map_of_ap \n        map_of_SomeD snd_conv)"], ["proof (state)\nthis:\n  tcs' n = Some mgd\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    exehas_sort (sub, tcs) x2a S\\<rbrakk>\n                   \\<Longrightarrow> has_sort (translate_osig (sub, tcs))\nx2a S;\n        exehas_sort (sub, tcs) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       exehas_sort (sub, tcs) (Tv x1 x2) S \\<Longrightarrow>\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (translate_osig (sub, tcs)) (Ty n Ts) S", "proof (subst sub'_tcs', rule has_sort_Ty[of tcs', OF mgd], rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "assume asm: \"c\\<in>S\""], ["proof (state)\nthis:\n  c \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "have l: \"lookup (\\<lambda>k. k=n) (map (apsnd map_of) tcs) = Some mgd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>k. k = n) (map (apsnd map_of) tcs) = Some mgd", "by (metis assms lookup_eq_map_of_ap mgd snd_conv sub'_tcs' translate_ars.simps translate_osig.simps)"], ["proof (state)\nthis:\n  lookup (\\<lambda>k. k = n) (map (apsnd map_of) tcs) = Some mgd\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "hence \"\\<exists>x. (lookup (\\<lambda>k. k=n) tcs) = Some x\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>k. k = n) (map (apsnd map_of) tcs) = Some mgd\n\ngoal (1 subgoal):\n 1. \\<exists>x. lookup (\\<lambda>k. k = n) tcs = Some x", "by (induction tcs) auto"], ["proof (state)\nthis:\n  \\<exists>x. lookup (\\<lambda>k. k = n) tcs = Some x\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "from this"], ["proof (chain)\npicking this:\n  \\<exists>x. lookup (\\<lambda>k. k = n) tcs = Some x", "obtain pre_mgd where pre_mgd: \"(lookup (\\<lambda>k. k=n) tcs) = Some pre_mgd\""], ["proof (prove)\nusing this:\n  \\<exists>x. lookup (\\<lambda>k. k = n) tcs = Some x\n\ngoal (1 subgoal):\n 1. (\\<And>pre_mgd.\n        lookup (\\<lambda>k. k = n) tcs = Some pre_mgd \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lookup (\\<lambda>k. k = n) tcs = Some pre_mgd\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "have pre_mgd_mgd: \"map_of pre_mgd = mgd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of pre_mgd = mgd", "by (metis l assms exe_ars_conds_def\n          exe_osig_conds_def in_alist_imp_in_map_of lookup_eq_map_of_ap map_of_SomeD \n          option.sel pre_mgd snd_conv translate_ars.simps)"], ["proof (state)\nthis:\n  map_of pre_mgd = mgd\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "obtain Ss where Ss: \"lookup (\\<lambda>k. k=c) pre_mgd = Some Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ss.\n        lookup (\\<lambda>k. k = c) pre_mgd = Some Ss \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Ty.prems asm"], ["proof (prove)\nusing this:\n  exehas_sort (sub, tcs) (Ty n Ts) S\n  c \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>Ss.\n        lookup (\\<lambda>k. k = c) pre_mgd = Some Ss \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: pre_mgd split: option.splits)"], ["proof (state)\nthis:\n  lookup (\\<lambda>k. k = c) pre_mgd = Some Ss\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "hence cond: \"list_all2 (exehas_sort (sub,tcs)) Ts Ss\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>k. k = c) pre_mgd = Some Ss\n\ngoal (1 subgoal):\n 1. list_all2 (exehas_sort (sub, tcs)) Ts Ss", "using \\<open>exehas_sort (sub, tcs) (Ty n Ts) S\\<close>asm pre_mgd"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>k. k = c) pre_mgd = Some Ss\n  exehas_sort (sub, tcs) (Ty n Ts) S\n  c \\<in> S\n  lookup (\\<lambda>k. k = n) tcs = Some pre_mgd\n\ngoal (1 subgoal):\n 1. list_all2 (exehas_sort (sub, tcs)) Ts Ss", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  list_all2 (exehas_sort (sub, tcs)) Ts Ss\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "from Ss"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>k. k = c) pre_mgd = Some Ss", "have \"mgd c = Some Ss\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>k. k = c) pre_mgd = Some Ss\n\ngoal (1 subgoal):\n 1. mgd c = Some Ss", "by (simp add: lookup_eq_map_of_ap pre_mgd_mgd)"], ["proof (state)\nthis:\n  mgd c = Some Ss\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "then"], ["proof (chain)\npicking this:\n  mgd c = Some Ss", "show \"\\<exists>Ss. mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss\""], ["proof (prove)\nusing this:\n  mgd c = Some Ss\n\ngoal (1 subgoal):\n 1. \\<exists>Ss.\n       mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "using cond Ty.IH list.rel_mono_strong sub'_tcs'"], ["proof (prove)\nusing this:\n  mgd c = Some Ss\n  list_all2 (exehas_sort (sub, tcs)) Ts Ss\n  \\<lbrakk>?x2a \\<in> set Ts; exehas_sort (sub, tcs) ?x2a ?S\\<rbrakk>\n  \\<Longrightarrow> has_sort (translate_osig (sub, tcs)) ?x2a ?S\n  \\<lbrakk>list_all2 ?R ?x ?y;\n   \\<And>z yb.\n      \\<lbrakk>z \\<in> set ?x; yb \\<in> set ?y; ?R z yb\\<rbrakk>\n      \\<Longrightarrow> ?Ra z yb\\<rbrakk>\n  \\<Longrightarrow> list_all2 ?Ra ?x ?y\n  translate_osig (sub, tcs) = (sub', tcs')\n\ngoal (1 subgoal):\n 1. \\<exists>Ss.\n       mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "by force"], ["proof (state)\nthis:\n  \\<exists>Ss.\n     mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_sort (translate_osig (sub, tcs)) (Ty n Ts) S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S.\n       exehas_sort (sub, tcs) (Tv x1 x2) S \\<Longrightarrow>\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S.\n       exehas_sort (sub, tcs) (Tv x1 x2) S \\<Longrightarrow>\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S", "case (Tv n S)"], ["proof (state)\nthis:\n  exehas_sort (sub, tcs) (Tv n Sa__) S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S.\n       exehas_sort (sub, tcs) (Tv x1 x2) S \\<Longrightarrow>\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S", "then"], ["proof (chain)\npicking this:\n  exehas_sort (sub, tcs) (Tv n Sa__) S", "show ?case"], ["proof (prove)\nusing this:\n  exehas_sort (sub, tcs) (Tv n Sa__) S\n\ngoal (1 subgoal):\n 1. has_sort (translate_osig (sub, tcs)) (Tv n Sa__) S", "by (metis assms exehas_sort.simps(1) exesort_les_code has_sort_Tv prod.collapse translate_osig.simps)"], ["proof (state)\nthis:\n  has_sort (translate_osig (sub, tcs)) (Tv n Sa__) S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sort_imp_exehas_sort: \n  assumes \"exe_osig_conds (sub, tcs)\"\n  shows \"has_sort (translate_osig (sub, tcs)) T S \\<Longrightarrow> exehas_sort (sub, tcs) T S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (translate_osig (sub, tcs)) T S \\<Longrightarrow>\n    exehas_sort (sub, tcs) T S", "proof (induction T arbitrary: S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   has_sort (translate_osig (sub, tcs)) ?x2a ?S\\<rbrakk>\n  \\<Longrightarrow> exehas_sort (sub, tcs) ?x2a ?S\n  has_sort (translate_osig (sub, tcs)) (Ty n Ts) S\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "obtain sub' tcs' where sub'_tcs': \"translate_osig (sub, tcs) = (sub', tcs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sub' tcs'.\n        translate_osig (sub, tcs) = (sub', tcs') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  translate_osig (sub, tcs) = (sub', tcs')\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "obtain mgd where mgd: \"tcs' n = Some mgd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mgd.\n        tcs' n = Some mgd \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Ty.prems sub'_tcs' has_sort.simps"], ["proof (prove)\nusing this:\n  has_sort (translate_osig (sub, tcs)) (Ty n Ts) S\n  translate_osig (sub, tcs) = (sub', tcs')\n  has_sort ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>sub S S' tcs a.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Tv a S \\<and> ?a3.0 = S' \\<and> sort_leq sub S S') \\<or>\n   (\\<exists>tcs \\<kappa> dm S sub Ts.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Ty \\<kappa> Ts \\<and>\n       ?a3.0 = S \\<and>\n       tcs \\<kappa> = Some dm \\<and>\n       (\\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss)))\n\ngoal (1 subgoal):\n 1. (\\<And>mgd.\n        tcs' n = Some mgd \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  tcs' n = Some mgd\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "hence \"lookup (\\<lambda>k. k=n) (map (apsnd map_of) tcs) = Some mgd\""], ["proof (prove)\nusing this:\n  tcs' n = Some mgd\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>k. k = n) (map (apsnd map_of) tcs) = Some mgd", "by (metis assms lookup_eq_map_of_ap prod.inject sub'_tcs' translate_ars.simps translate_osig.simps)"], ["proof (state)\nthis:\n  lookup (\\<lambda>k. k = n) (map (apsnd map_of) tcs) = Some mgd\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "have l: \"lookup (\\<lambda>k. k=n) (map (apsnd map_of) tcs) = Some mgd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>k. k = n) (map (apsnd map_of) tcs) = Some mgd", "by (metis assms lookup_eq_map_of_ap mgd snd_conv sub'_tcs' \n        translate_ars.simps translate_osig.simps)"], ["proof (state)\nthis:\n  lookup (\\<lambda>k. k = n) (map (apsnd map_of) tcs) = Some mgd\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "hence \"\\<exists>x. (lookup (\\<lambda>k. k=n) tcs) = Some x\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>k. k = n) (map (apsnd map_of) tcs) = Some mgd\n\ngoal (1 subgoal):\n 1. \\<exists>x. lookup (\\<lambda>k. k = n) tcs = Some x", "by (induction tcs) auto"], ["proof (state)\nthis:\n  \\<exists>x. lookup (\\<lambda>k. k = n) tcs = Some x\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "from this"], ["proof (chain)\npicking this:\n  \\<exists>x. lookup (\\<lambda>k. k = n) tcs = Some x", "obtain pre_mgd where pre_mgd: \"(lookup (\\<lambda>k. k=n) tcs) = Some pre_mgd\""], ["proof (prove)\nusing this:\n  \\<exists>x. lookup (\\<lambda>k. k = n) tcs = Some x\n\ngoal (1 subgoal):\n 1. (\\<And>pre_mgd.\n        lookup (\\<lambda>k. k = n) tcs = Some pre_mgd \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lookup (\\<lambda>k. k = n) tcs = Some pre_mgd\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "have pre_mgd_mgd: \"map_of pre_mgd = mgd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of pre_mgd = mgd", "by (metis l assms exe_ars_conds_def\n        exe_osig_conds_def in_alist_imp_in_map_of lookup_eq_map_of_ap map_of_SomeD option.sel\n        pre_mgd snd_conv translate_ars.simps)"], ["proof (state)\nthis:\n  map_of pre_mgd = mgd\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "{"], ["proof (state)\nthis:\n  map_of pre_mgd = mgd\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "assume asm: \"c\\<in>S\""], ["proof (state)\nthis:\n  c \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "obtain Ss where Ss: \"lookup (\\<lambda>k. k=c) pre_mgd = Some Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ss.\n        lookup (\\<lambda>k. k = c) pre_mgd = Some Ss \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>c \\<in> S\\<close> \\<open>map_of pre_mgd = mgd\\<close> sub'_tcs' mgd assms Ty.prems has_sort.simps"], ["proof (prove)\nusing this:\n  c \\<in> S\n  map_of pre_mgd = mgd\n  translate_osig (sub, tcs) = (sub', tcs')\n  tcs' n = Some mgd\n  exe_osig_conds (sub, tcs)\n  has_sort (translate_osig (sub, tcs)) (Ty n Ts) S\n  has_sort ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>sub S S' tcs a.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Tv a S \\<and> ?a3.0 = S' \\<and> sort_leq sub S S') \\<or>\n   (\\<exists>tcs \\<kappa> dm S sub Ts.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Ty \\<kappa> Ts \\<and>\n       ?a3.0 = S \\<and>\n       tcs \\<kappa> = Some dm \\<and>\n       (\\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss)))\n\ngoal (1 subgoal):\n 1. (\\<And>Ss.\n        lookup (\\<lambda>k. k = c) pre_mgd = Some Ss \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: dom_map_of_conv_image_fst domIff eq_fst_iff exe_ars_conds_def \n          map_of_eq_None_iff classes_translate lookup_eq_map_of_ap split: typ.splits\n          dest!: domD intro!: domI)"], ["proof (state)\nthis:\n  lookup (\\<lambda>k. k = c) pre_mgd = Some Ss\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "have l: \"length Ts = length Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Ts = length Ss", "using asm mgd pre_mgd Ty.prems assms sub'_tcs' Ss list_all2_lengthD pre_mgd_mgd"], ["proof (prove)\nusing this:\n  c \\<in> S\n  tcs' n = Some mgd\n  lookup (\\<lambda>k. k = n) tcs = Some pre_mgd\n  has_sort (translate_osig (sub, tcs)) (Ty n Ts) S\n  exe_osig_conds (sub, tcs)\n  translate_osig (sub, tcs) = (sub', tcs')\n  lookup (\\<lambda>k. k = c) pre_mgd = Some Ss\n  list_all2 ?P ?xs ?ys \\<Longrightarrow> length ?xs = length ?ys\n  map_of pre_mgd = mgd\n\ngoal (1 subgoal):\n 1. length Ts = length Ss", "by (fastforce simp add: has_sort.simps lookup_eq_map_of_ap)"], ["proof (state)\nthis:\n  length Ts = length Ss\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "have 1: \"\\<forall>c \\<in> S. \\<exists>Ss . mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>S.\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "using mgd Ty.prems has_sort.simps sub'_tcs'"], ["proof (prove)\nusing this:\n  tcs' n = Some mgd\n  has_sort (translate_osig (sub, tcs)) (Ty n Ts) S\n  has_sort ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>sub S S' tcs a.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Tv a S \\<and> ?a3.0 = S' \\<and> sort_leq sub S S') \\<or>\n   (\\<exists>tcs \\<kappa> dm S sub Ts.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Ty \\<kappa> Ts \\<and>\n       ?a3.0 = S \\<and>\n       tcs \\<kappa> = Some dm \\<and>\n       (\\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss)))\n  translate_osig (sub, tcs) = (sub', tcs')\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>S.\n       \\<exists>Ss.\n          mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss", "by auto"], ["proof (state)\nthis:\n  \\<forall>c\\<in>S.\n     \\<exists>Ss.\n        mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "have cond: \"list_all2 (exehas_sort (sub,tcs)) Ts Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (exehas_sort (sub, tcs)) Ts Ss", "apply (rule list_all2_all_nthI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length Ts = length Ss\n 2. \\<And>n.\n       n < length Ts \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Ts ! n) (Ss ! n)", "using l"], ["proof (prove)\nusing this:\n  length Ts = length Ss\n\ngoal (2 subgoals):\n 1. length Ts = length Ss\n 2. \\<And>n.\n       n < length Ts \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Ts ! n) (Ss ! n)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length Ts \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Ts ! n) (Ss ! n)", "subgoal premises p for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. exehas_sort (sub, tcs) (Ts ! m) (Ss ! m)", "apply (rule Ty.IH)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Ts ! m \\<in> set Ts\n 2. has_sort (translate_osig (sub, tcs)) (Ts ! m) (Ss ! m)", "using p"], ["proof (prove)\nusing this:\n  m < length Ts\n\ngoal (2 subgoals):\n 1. Ts ! m \\<in> set Ts\n 2. has_sort (translate_osig (sub, tcs)) (Ts ! m) (Ss ! m)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (translate_osig (sub, tcs)) (Ts ! m) (Ss ! m)", "using p Ty.prems assms 1"], ["proof (prove)\nusing this:\n  m < length Ts\n  has_sort (translate_osig (sub, tcs)) (Ty n Ts) S\n  exe_osig_conds (sub, tcs)\n  \\<forall>c\\<in>S.\n     \\<exists>Ss.\n        mgd c = Some Ss \\<and> list_all2 (has_sort (sub', tcs')) Ts Ss\n\ngoal (1 subgoal):\n 1. has_sort (translate_osig (sub, tcs)) (Ts ! m) (Ss ! m)", "by (metis Ss asm list_all2_conv_all_nth lookup_eq_map_of_ap option.sel pre_mgd_mgd sub'_tcs')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all2 (exehas_sort (sub, tcs)) Ts Ss\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "have \"(\\<forall>C \\<in> S.\n    case lookup (\\<lambda>k. k=C) pre_mgd of\n        None \\<Rightarrow> False\n      | Some Ss \\<Rightarrow> list_all2 (exehas_sort (sub,tcs)) Ts Ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S.\n       case lookup (\\<lambda>k. k = C) pre_mgd of None \\<Rightarrow> False\n       | Some Ss \\<Rightarrow> list_all2 (exehas_sort (sub, tcs)) Ts Ss", "by (metis \"1\" Ty.IH list_all2_conv_all_nth lookup_eq_map_of_ap nth_mem option.simps(5) \n        pre_mgd_mgd sub'_tcs')"], ["proof (state)\nthis:\n  \\<forall>C\\<in>S.\n     case lookup (\\<lambda>k. k = C) pre_mgd of None \\<Rightarrow> False\n     | Some Ss \\<Rightarrow> list_all2 (exehas_sort (sub, tcs)) Ts Ss\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "}"], ["proof (state)\nthis:\n  ?c2 \\<in> S \\<Longrightarrow>\n  \\<forall>C\\<in>S.\n     case lookup (\\<lambda>k. k = C) pre_mgd of None \\<Rightarrow> False\n     | Some Ss \\<Rightarrow> list_all2 (exehas_sort (sub, tcs)) Ts Ss\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    has_sort (translate_osig (sub, tcs)) x2a S\\<rbrakk>\n                   \\<Longrightarrow> exehas_sort (sub, tcs) x2a S;\n        has_sort (translate_osig (sub, tcs)) (Ty x1 x2) S\\<rbrakk>\n       \\<Longrightarrow> exehas_sort (sub, tcs) (Ty x1 x2) S\n 2. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "then"], ["proof (chain)\npicking this:\n  ?c2 \\<in> S \\<Longrightarrow>\n  \\<forall>C\\<in>S.\n     case lookup (\\<lambda>k. k = C) pre_mgd of None \\<Rightarrow> False\n     | Some Ss \\<Rightarrow> list_all2 (exehas_sort (sub, tcs)) Ts Ss", "show ?case"], ["proof (prove)\nusing this:\n  ?c2 \\<in> S \\<Longrightarrow>\n  \\<forall>C\\<in>S.\n     case lookup (\\<lambda>k. k = C) pre_mgd of None \\<Rightarrow> False\n     | Some Ss \\<Rightarrow> list_all2 (exehas_sort (sub, tcs)) Ts Ss\n\ngoal (1 subgoal):\n 1. exehas_sort (sub, tcs) (Ty n Ts) S", "using pre_mgd"], ["proof (prove)\nusing this:\n  ?c2 \\<in> S \\<Longrightarrow>\n  \\<forall>C\\<in>S.\n     case lookup (\\<lambda>k. k = C) pre_mgd of None \\<Rightarrow> False\n     | Some Ss \\<Rightarrow> list_all2 (exehas_sort (sub, tcs)) Ts Ss\n  lookup (\\<lambda>k. k = n) tcs = Some pre_mgd\n\ngoal (1 subgoal):\n 1. exehas_sort (sub, tcs) (Ty n Ts) S", "by simp"], ["proof (state)\nthis:\n  exehas_sort (sub, tcs) (Ty n Ts) S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "case (Tv n S)"], ["proof (state)\nthis:\n  has_sort (translate_osig (sub, tcs)) (Tv n Sa__) S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S.\n       has_sort (translate_osig (sub, tcs)) (Tv x1 x2) S \\<Longrightarrow>\n       exehas_sort (sub, tcs) (Tv x1 x2) S", "then"], ["proof (chain)\npicking this:\n  has_sort (translate_osig (sub, tcs)) (Tv n Sa__) S", "show ?case"], ["proof (prove)\nusing this:\n  has_sort (translate_osig (sub, tcs)) (Tv n Sa__) S\n\ngoal (1 subgoal):\n 1. exehas_sort (sub, tcs) (Tv n Sa__) S", "using assms exesort_les_code has_sort_Tv_imp_sort_leq"], ["proof (prove)\nusing this:\n  has_sort (translate_osig (sub, tcs)) (Tv n Sa__) S\n  exe_osig_conds (sub, tcs)\n  sort_leq (set ?cs) ?c1.0 ?c2.0 = exesort_leq ?cs ?c1.0 ?c2.0\n  has_sort ?oss (Tv ?idn ?S) ?S' \\<Longrightarrow>\n  sort_leq (subclass ?oss) ?S ?S'\n\ngoal (1 subgoal):\n 1. exehas_sort (sub, tcs) (Tv n Sa__) S", "by fastforce"], ["proof (state)\nthis:\n  exehas_sort (sub, tcs) (Tv n Sa__) S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sort_code:\n  assumes \"exe_osig_conds oss\"\n  shows \"has_sort (translate_osig oss) T S = exehas_sort oss T S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (translate_osig oss) T S = exehas_sort oss T S", "by (metis assms exehas_sort_imp_has_sort has_sort_imp_exehas_sort prod.collapse)"], ["", "lemma has_sort_code':\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"has_sort (osig (sig (translate_theory \\<Theta>))) T S \n    = exehas_sort (exesorts (exesig \\<Theta>)) T S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (osig (sig (translate_theory \\<Theta>))) T S =\n    exehas_sort (exesorts (exesig \\<Theta>)) T S", "apply (cases \\<Theta> rule: exetheory_full_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>const_type typ_arity sorts axioms.\n       \\<Theta> =\n       ExeTheory (ExeSignature const_type typ_arity sorts)\n        axioms \\<Longrightarrow>\n       has_sort (osig (sig (translate_theory \\<Theta>))) T S =\n       exehas_sort (exesorts (exesig \\<Theta>)) T S", "using assms has_sort_code"], ["proof (prove)\nusing this:\n  exe_wf_theory' \\<Theta>\n  exe_osig_conds ?oss \\<Longrightarrow>\n  has_sort (translate_osig ?oss) ?T ?S = exehas_sort ?oss ?T ?S\n\ngoal (1 subgoal):\n 1. \\<And>const_type typ_arity sorts axioms.\n       \\<Theta> =\n       ExeTheory (ExeSignature const_type typ_arity sorts)\n        axioms \\<Longrightarrow>\n       has_sort (osig (sig (translate_theory \\<Theta>))) T S =\n       exehas_sort (exesorts (exesig \\<Theta>)) T S", "by auto"], ["", "abbreviation \"exeinst_ok \\<Theta> insts \\<equiv> \n    distinct (map fst insts)\n  \\<and> list_all (exetyp_ok \\<Theta>) (map snd insts)\n  \\<and> list_all (\\<lambda>((idn, S), T) . exehas_sort (exesorts (exesig \\<Theta>)) T S) insts\""], ["", "lemma inst_ok_code1:\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"list_all (exetyp_ok \\<Theta>) (map snd insts) = list_all (typ_ok (translate_theory \\<Theta>)) (map snd insts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (exetyp_ok \\<Theta>) (map snd insts) =\n    list_all (typ_ok (translate_theory \\<Theta>)) (map snd insts)", "using assms typ_ok_code"], ["proof (prove)\nusing this:\n  exe_wf_theory' \\<Theta>\n  exe_wf_theory' ?\\<Theta> \\<Longrightarrow>\n  typ_ok (translate_theory ?\\<Theta>) ?ty = exetyp_ok ?\\<Theta> ?ty\n\ngoal (1 subgoal):\n 1. list_all (exetyp_ok \\<Theta>) (map snd insts) =\n    list_all (typ_ok (translate_theory \\<Theta>)) (map snd insts)", "by (auto simp add: list_all_iff)"], ["", "lemma inst_ok_code2:\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"list_all (\\<lambda>((idn, S), T) . has_sort (osig (sig (translate_theory \\<Theta>))) T S) insts\n    = list_all (\\<lambda>((idn, S), T) . exehas_sort (exesorts (exesig \\<Theta>)) T S) insts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>((idn, S), T).\n         has_sort (osig (sig (translate_theory \\<Theta>))) T S)\n     insts =\n    list_all\n     (\\<lambda>((idn, S), T). exehas_sort (exesorts (exesig \\<Theta>)) T S)\n     insts", "using has_sort_code' assms"], ["proof (prove)\nusing this:\n  exe_wf_theory' ?\\<Theta> \\<Longrightarrow>\n  has_sort (osig (sig (translate_theory ?\\<Theta>))) ?T ?S =\n  exehas_sort (exesorts (exesig ?\\<Theta>)) ?T ?S\n  exe_wf_theory' \\<Theta>\n\ngoal (1 subgoal):\n 1. list_all\n     (\\<lambda>((idn, S), T).\n         has_sort (osig (sig (translate_theory \\<Theta>))) T S)\n     insts =\n    list_all\n     (\\<lambda>((idn, S), T). exehas_sort (exesorts (exesig \\<Theta>)) T S)\n     insts", "by auto"], ["", "lemma inst_ok_code:\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"inst_ok (translate_theory \\<Theta>) insts = exeinst_ok \\<Theta> insts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst_ok (translate_theory \\<Theta>) insts = exeinst_ok \\<Theta> insts", "using inst_ok_code1 inst_ok_code2 assms"], ["proof (prove)\nusing this:\n  exe_wf_theory' ?\\<Theta> \\<Longrightarrow>\n  list_all (exetyp_ok ?\\<Theta>) (map snd ?insts) =\n  list_all (typ_ok (translate_theory ?\\<Theta>)) (map snd ?insts)\n  exe_wf_theory' ?\\<Theta> \\<Longrightarrow>\n  list_all\n   (\\<lambda>((idn, S), T).\n       has_sort (osig (sig (translate_theory ?\\<Theta>))) T S)\n   ?insts =\n  list_all\n   (\\<lambda>((idn, S), T). exehas_sort (exesorts (exesig ?\\<Theta>)) T S)\n   ?insts\n  exe_wf_theory' \\<Theta>\n\ngoal (1 subgoal):\n 1. inst_ok (translate_theory \\<Theta>) insts = exeinst_ok \\<Theta> insts", "by auto"], ["", "definition [simp]: \"exeterm_ok \\<Theta> t \\<equiv> exeterm_ok' (exesig \\<Theta>) t \\<and> typ_of t \\<noteq> None\""], ["", "lemma term_ok_code:\n  assumes \"exe_wf_theory' \\<Theta>\"\n  shows \"term_ok (translate_theory \\<Theta>) t = exeterm_ok \\<Theta> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok (translate_theory \\<Theta>) t = exeterm_ok \\<Theta> t", "using assms"], ["proof (prove)\nusing this:\n  exe_wf_theory' \\<Theta>\n\ngoal (1 subgoal):\n 1. term_ok (translate_theory \\<Theta>) t = exeterm_ok \\<Theta> t", "apply (cases \\<Theta> rule: exetheory_full_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>const_type typ_arity sorts axioms.\n       \\<lbrakk>exe_wf_theory' \\<Theta>;\n        \\<Theta> =\n        ExeTheory (ExeSignature const_type typ_arity sorts) axioms\\<rbrakk>\n       \\<Longrightarrow> term_ok (translate_theory \\<Theta>) t =\n                         exeterm_ok \\<Theta> t", "by (metis exe_sig_conds_def exe_wf_theory'.simps exeterm_ok_def exetheory.sel(1) \n      sig.simps term_okD1 term_okD2 term_okI wt_term_code translate_theory.simps)"], ["", "fun exereplay' :: \"exetheory \\<Rightarrow> (variable \\<times> typ) list \\<Rightarrow> variable set\n  \\<Rightarrow> term list \\<Rightarrow> proofterm \\<Rightarrow> term option\" where\n  \"exereplay' thy _ _ Hs (PAxm t Tis) = (if exeinst_ok thy Tis \\<and> exeterm_ok thy t\n    then if t \\<in> set (exeaxioms_of thy)\n      then Some (forall_intro_vars (subst_typ' Tis t) []) \n    else None else None)\"\n| \"exereplay' thy _ _ Hs (PBound n) = partial_nth Hs n\" \n| \"exereplay' thy vs ns Hs (Abst T p) = (if exetyp_ok thy T \n    then (let (s',ns') = variant_variable (Free STR ''default'') ns in \n      map_option (mk_all s' T) (exereplay' thy ((s', T) # vs) ns' Hs p))\n    else None)\"\n| \"exereplay' thy vs ns Hs (Appt p t) = \n    (let rep = exereplay' thy vs ns Hs p in\n    let t' = subst_bvs (map (\\<lambda>(x,y) . Fv x y) vs) t in\n      case (rep, typ_of t') of\n        (Some (Ct s (Ty fun1 [Ty fun2 [\\<tau>, Ty propT1 Nil], Ty propT2 Nil]) $ b), Some \\<tau>') \\<Rightarrow> \n          if s = STR ''Pure.all'' \\<and> fun1 = STR ''fun'' \\<and> fun2 = STR ''fun'' \n            \\<and> propT1 = STR ''prop'' \\<and> propT2 = STR ''prop''\n             \\<and> \\<tau>=\\<tau>' \\<and> exeterm_ok thy t'\n            then Some (b \\<bullet> t') else None\n      | _ \\<Rightarrow> None)\" \n| \"exereplay' thy vs ns Hs (AbsP t p) =\n    (let t' = subst_bvs (map (\\<lambda>(x,y) . Fv x y) vs) t in\n    let rep = exereplay' thy vs ns (t'#Hs) p in\n      (if typ_of t' = Some propT \\<and> exeterm_ok thy t' then map_option (mk_imp t') rep else None))\"\n| \"exereplay' thy vs ns Hs (AppP p1 p2) = \n    (let rep1 = Option.bind (exereplay' thy vs ns Hs p1) beta_eta_norm in\n    let rep2 = Option.bind (exereplay' thy vs ns Hs p2) beta_eta_norm in\n      (case (rep1, rep2) of (\n        Some (Ct imp (Ty fn1 [Ty prp1 [], Ty fn2 [Ty prp2 [], Ty prp3 []]]) $ A $ B),\n        Some A') \\<Rightarrow> \n          if imp = STR ''Pure.imp'' \\<and> fn1 = STR ''fun'' \\<and> fn2 = STR ''fun''\n            \\<and> prp1 = STR ''prop'' \\<and> prp2 = STR ''prop'' \\<and> prp3 = STR ''prop'' \\<and> A=A' \n          then Some B else None\n        | _ \\<Rightarrow> None))\"\n| \"exereplay' thy vs ns Hs (OfClass ty c) = (if exehas_sort (exesorts (exesig thy)) ty {c} \n    \\<and> exetyp_ok thy ty\n    then (case lookup (\\<lambda>k. k=const_of_class c) (execonst_type_of (exesig thy)) of \n      Some (Ty fun [Ty it [ity], Ty prop []]) \\<Rightarrow> \n        if ity = tvariable STR '''a'' \\<and> fun = STR ''fun'' \\<and> prop = STR ''prop'' \\<and> it = STR ''itself''\n          then Some (mk_of_class ty c) else None | _ \\<Rightarrow> None) else None)\"\n| \"exereplay' thy vs ns Hs (Hyp t) = (if t\\<in>set Hs then Some t else None)\""], ["", "lemma of_class_code1: \n  assumes \"exe_wf_theory' thy\"\n  shows \"(has_sort (osig (sig (translate_theory thy))) ty {c} \\<and> typ_ok (translate_theory thy) ty)\n    = (exehas_sort (exesorts (exesig thy)) ty {c} \\<and> exetyp_ok thy ty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (has_sort (osig (sig (translate_theory thy))) ty\n      (insert c full_sort) \\<and>\n     typ_ok (translate_theory thy) ty) =\n    (exehas_sort (exesorts (exesig thy)) ty (insert c full_sort) \\<and>\n     exetyp_ok thy ty)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (has_sort (osig (sig (translate_theory thy))) ty\n      (insert c full_sort) \\<and>\n     typ_ok (translate_theory thy) ty) =\n    (exehas_sort (exesorts (exesig thy)) ty (insert c full_sort) \\<and>\n     exetyp_ok thy ty)", "have \"has_sort (osig (sig (translate_theory thy))) ty {c}\n    = exehas_sort (exesorts (exesig thy)) ty {c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (osig (sig (translate_theory thy))) ty (insert c full_sort) =\n    exehas_sort (exesorts (exesig thy)) ty (insert c full_sort)", "using has_sort_code' assms"], ["proof (prove)\nusing this:\n  exe_wf_theory' ?\\<Theta> \\<Longrightarrow>\n  has_sort (osig (sig (translate_theory ?\\<Theta>))) ?T ?S =\n  exehas_sort (exesorts (exesig ?\\<Theta>)) ?T ?S\n  exe_wf_theory' thy\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig (translate_theory thy))) ty (insert c full_sort) =\n    exehas_sort (exesorts (exesig thy)) ty (insert c full_sort)", "by simp"], ["proof (state)\nthis:\n  has_sort (osig (sig (translate_theory thy))) ty (insert c full_sort) =\n  exehas_sort (exesorts (exesig thy)) ty (insert c full_sort)\n\ngoal (1 subgoal):\n 1. (has_sort (osig (sig (translate_theory thy))) ty\n      (insert c full_sort) \\<and>\n     typ_ok (translate_theory thy) ty) =\n    (exehas_sort (exesorts (exesig thy)) ty (insert c full_sort) \\<and>\n     exetyp_ok thy ty)", "moreover"], ["proof (state)\nthis:\n  has_sort (osig (sig (translate_theory thy))) ty (insert c full_sort) =\n  exehas_sort (exesorts (exesig thy)) ty (insert c full_sort)\n\ngoal (1 subgoal):\n 1. (has_sort (osig (sig (translate_theory thy))) ty\n      (insert c full_sort) \\<and>\n     typ_ok (translate_theory thy) ty) =\n    (exehas_sort (exesorts (exesig thy)) ty (insert c full_sort) \\<and>\n     exetyp_ok thy ty)", "have \"typ_ok (translate_theory thy) ty = exetyp_ok thy ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok (translate_theory thy) ty = exetyp_ok thy ty", "using typ_ok_code assms"], ["proof (prove)\nusing this:\n  exe_wf_theory' ?\\<Theta> \\<Longrightarrow>\n  typ_ok (translate_theory ?\\<Theta>) ?ty = exetyp_ok ?\\<Theta> ?ty\n  exe_wf_theory' thy\n\ngoal (1 subgoal):\n 1. typ_ok (translate_theory thy) ty = exetyp_ok thy ty", "by simp"], ["proof (state)\nthis:\n  typ_ok (translate_theory thy) ty = exetyp_ok thy ty\n\ngoal (1 subgoal):\n 1. (has_sort (osig (sig (translate_theory thy))) ty\n      (insert c full_sort) \\<and>\n     typ_ok (translate_theory thy) ty) =\n    (exehas_sort (exesorts (exesig thy)) ty (insert c full_sort) \\<and>\n     exetyp_ok thy ty)", "ultimately"], ["proof (chain)\npicking this:\n  has_sort (osig (sig (translate_theory thy))) ty (insert c full_sort) =\n  exehas_sort (exesorts (exesig thy)) ty (insert c full_sort)\n  typ_ok (translate_theory thy) ty = exetyp_ok thy ty", "show ?thesis"], ["proof (prove)\nusing this:\n  has_sort (osig (sig (translate_theory thy))) ty (insert c full_sort) =\n  exehas_sort (exesorts (exesig thy)) ty (insert c full_sort)\n  typ_ok (translate_theory thy) ty = exetyp_ok thy ty\n\ngoal (1 subgoal):\n 1. (has_sort (osig (sig (translate_theory thy))) ty\n      (insert c full_sort) \\<and>\n     typ_ok (translate_theory thy) ty) =\n    (exehas_sort (exesorts (exesig thy)) ty (insert c full_sort) \\<and>\n     exetyp_ok thy ty)", "by auto"], ["proof (state)\nthis:\n  (has_sort (osig (sig (translate_theory thy))) ty\n    (insert c full_sort) \\<and>\n   typ_ok (translate_theory thy) ty) =\n  (exehas_sort (exesorts (exesig thy)) ty (insert c full_sort) \\<and>\n   exetyp_ok thy ty)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma of_class_code2: \n  assumes \"exe_wf_theory' thy\"\n  shows \"const_type (sig (translate_theory thy)) (const_of_class c) \n    = lookup (\\<lambda>k. k=const_of_class c) (execonst_type_of (exesig thy))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const_type (sig (translate_theory thy)) (const_of_class c) =\n    lookup (\\<lambda>k. k = const_of_class c)\n     (execonst_type_of (exesig thy))", "by (metis assms const_type_of_lookup_code exe_wf_theory_code \n      exe_wf_theory_translate_imp_wf_theory exetheory.sel(1) illformed_theory_not_wf_theory \n      sig.simps translate_theory.elims)"], ["", "lemma replay'_code:\n  assumes \"exe_wf_theory' thy\"\n  shows \"replay' (translate_theory thy) vs ns Hs P = exereplay' thy vs ns Hs P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replay' (translate_theory thy) vs ns Hs P = exereplay' thy vs ns Hs P", "proof (induction P arbitrary: vs ns Hs)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PAxm x1 x2a) =\n       exereplay' thy vs ns Hs (PAxm x1 x2a)\n 2. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 4. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 5. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 6. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 7. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 8. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "case (PAxm ax tys)"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PAxm x1 x2a) =\n       exereplay' thy vs ns Hs (PAxm x1 x2a)\n 2. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 4. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 5. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 6. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 7. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 8. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "have wf: \"wf_theory (translate_theory thy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_theory (translate_theory thy)", "by (simp add: assms exe_wf_theory_code exe_wf_theory_translate_imp_wf_theory)"], ["proof (state)\nthis:\n  wf_theory (translate_theory thy)\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PAxm x1 x2a) =\n       exereplay' thy vs ns Hs (PAxm x1 x2a)\n 2. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 4. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 5. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 6. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 7. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 8. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "moreover"], ["proof (state)\nthis:\n  wf_theory (translate_theory thy)\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PAxm x1 x2a) =\n       exereplay' thy vs ns Hs (PAxm x1 x2a)\n 2. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 4. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 5. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 6. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 7. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 8. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "have inst: \"inst_ok (translate_theory thy) tys \\<longleftrightarrow> exeinst_ok thy tys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst_ok (translate_theory thy) tys = exeinst_ok thy tys", "by (simp add: assms inst_ok_code1 inst_ok_code2)"], ["proof (state)\nthis:\n  inst_ok (translate_theory thy) tys = exeinst_ok thy tys\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PAxm x1 x2a) =\n       exereplay' thy vs ns Hs (PAxm x1 x2a)\n 2. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 4. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 5. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 6. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 7. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 8. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "moreover"], ["proof (state)\nthis:\n  inst_ok (translate_theory thy) tys = exeinst_ok thy tys\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PAxm x1 x2a) =\n       exereplay' thy vs ns Hs (PAxm x1 x2a)\n 2. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 4. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 5. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 6. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 7. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 8. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "have tok: \"term_ok (translate_theory thy) ax \\<longleftrightarrow> exeterm_ok thy ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok (translate_theory thy) ax = exeterm_ok thy ax", "using assms term_ok_code"], ["proof (prove)\nusing this:\n  exe_wf_theory' thy\n  exe_wf_theory' ?\\<Theta> \\<Longrightarrow>\n  term_ok (translate_theory ?\\<Theta>) ?t = exeterm_ok ?\\<Theta> ?t\n\ngoal (1 subgoal):\n 1. term_ok (translate_theory thy) ax = exeterm_ok thy ax", "by blast"], ["proof (state)\nthis:\n  term_ok (translate_theory thy) ax = exeterm_ok thy ax\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PAxm x1 x2a) =\n       exereplay' thy vs ns Hs (PAxm x1 x2a)\n 2. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 4. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 5. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 6. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 7. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 8. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "moreover"], ["proof (state)\nthis:\n  term_ok (translate_theory thy) ax = exeterm_ok thy ax\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PAxm x1 x2a) =\n       exereplay' thy vs ns Hs (PAxm x1 x2a)\n 2. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 4. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 5. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 6. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 7. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 8. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "have ax: \"ax \\<in> axioms (translate_theory thy) \\<longleftrightarrow> ax \\<in> set (exeaxioms_of thy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ax \\<in> axioms (translate_theory thy)) =\n    (ax \\<in> set (exeaxioms_of thy))", "by (metis axioms.simps wf exetheory.sel(2) illformed_theory_not_wf_theory translate_theory.elims)"], ["proof (state)\nthis:\n  (ax \\<in> axioms (translate_theory thy)) =\n  (ax \\<in> set (exeaxioms_of thy))\n\ngoal (8 subgoals):\n 1. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PAxm x1 x2a) =\n       exereplay' thy vs ns Hs (PAxm x1 x2a)\n 2. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 4. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 5. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 6. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 7. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 8. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "ultimately"], ["proof (chain)\npicking this:\n  wf_theory (translate_theory thy)\n  inst_ok (translate_theory thy) tys = exeinst_ok thy tys\n  term_ok (translate_theory thy) ax = exeterm_ok thy ax\n  (ax \\<in> axioms (translate_theory thy)) =\n  (ax \\<in> set (exeaxioms_of thy))", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory (translate_theory thy)\n  inst_ok (translate_theory thy) tys = exeinst_ok thy tys\n  term_ok (translate_theory thy) ax = exeterm_ok thy ax\n  (ax \\<in> axioms (translate_theory thy)) =\n  (ax \\<in> set (exeaxioms_of thy))\n\ngoal (1 subgoal):\n 1. replay' (translate_theory thy) vs ns Hs (PAxm ax tys) =\n    exereplay' thy vs ns Hs (PAxm ax tys)", "by simp"], ["proof (state)\nthis:\n  replay' (translate_theory thy) vs ns Hs (PAxm ax tys) =\n  exereplay' thy vs ns Hs (PAxm ax tys)\n\ngoal (7 subgoals):\n 1. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (PBound x) =\n       exereplay' thy vs ns Hs (PBound x)\n 2. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Abst x1 P) =\n       exereplay' thy vs ns Hs (Abst x1 P)\n 3. \\<And>x1 P vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (AbsP x1 P) =\n       exereplay' thy vs ns Hs (AbsP x1 P)\n 4. \\<And>P x2a vs ns Hs.\n       (\\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P =\n           exereplay' thy vs ns Hs P) \\<Longrightarrow>\n       replay' (translate_theory thy) vs ns Hs (Appt P x2a) =\n       exereplay' thy vs ns Hs (Appt P x2a)\n 5. \\<And>P1 P2 vs ns Hs.\n       \\<lbrakk>\\<And>vs ns Hs.\n                   replay' (translate_theory thy) vs ns Hs P1 =\n                   exereplay' thy vs ns Hs P1;\n        \\<And>vs ns Hs.\n           replay' (translate_theory thy) vs ns Hs P2 =\n           exereplay' thy vs ns Hs P2\\<rbrakk>\n       \\<Longrightarrow> replay' (translate_theory thy) vs ns Hs\n                          (AppP P1 P2) =\n                         exereplay' thy vs ns Hs (AppP P1 P2)\n 6. \\<And>x1 x2a vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (OfClass x1 x2a) =\n       exereplay' thy vs ns Hs (OfClass x1 x2a)\n 7. \\<And>x vs ns Hs.\n       replay' (translate_theory thy) vs ns Hs (Hyp x) =\n       exereplay' thy vs ns Hs (Hyp x)", "qed (use assms term_ok_code typ_ok_code of_class_code1 of_class_code2 \n      in \\<open>auto simp only: replay'.simps exereplay'.simps split: if_splits\\<close>)"], ["", "abbreviation \"exereplay'' thy vs ns Hs P \\<equiv> Option.bind (exereplay' thy vs ns Hs P) beta_eta_norm\""], ["", "lemma replay''_code:\n  assumes \"exe_wf_theory' thy\"\n  shows \"replay'' (translate_theory thy) vs ns Hs P = exereplay'' thy vs ns Hs P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replay'' (translate_theory thy) vs ns Hs P = exereplay'' thy vs ns Hs P", "by (simp add: assms replay'_code)"], ["", "definition [simp]: \"exereplay thy P \\<equiv> \n  (if \\<forall>x\\<in>set (hyps P) . exeterm_ok thy x \\<and> typ_of x = Some propT then\n  exereplay'' thy [] (fst ` (fv_Proof P \\<union> FV (set (hyps P)))) (hyps P) P else None)\""], ["", "lemma replay_code:\n  assumes \"exe_wf_theory' thy\"\n  shows \"replay (translate_theory thy) P = exereplay thy P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replay (translate_theory thy) P = exereplay thy P", "using assms replay''_code term_ok_code"], ["proof (prove)\nusing this:\n  exe_wf_theory' thy\n  exe_wf_theory' ?thy \\<Longrightarrow>\n  replay'' (translate_theory ?thy) ?vs ?ns ?Hs ?P =\n  exereplay'' ?thy ?vs ?ns ?Hs ?P\n  exe_wf_theory' ?\\<Theta> \\<Longrightarrow>\n  term_ok (translate_theory ?\\<Theta>) ?t = exeterm_ok ?\\<Theta> ?t\n\ngoal (1 subgoal):\n 1. replay (translate_theory thy) P = exereplay thy P", "by auto"], ["", "definition \"exe_replay' e P = exereplay'' e [] (fst ` fv_Proof P) [] P\""], ["", "definition \"exe_check_proof e P res \\<equiv> \n  exe_wf_theory' e \\<and> exereplay e P = Some res\""], ["", "lemma exe_check_proof_iff_check_proof: \n  \"exe_check_proof e P res \\<longleftrightarrow> check_proof (translate_theory e) P res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exe_check_proof e P res = check_proof (translate_theory e) P res", "using check_proof_def exe_check_proof_def wf_theory_translate_iff_exe_wf_theory"], ["proof (prove)\nusing this:\n  check_proof ?thy ?P ?res \\<equiv>\n  wf_theory ?thy \\<and> replay ?thy ?P = Some ?res\n  exe_check_proof ?e ?P ?res \\<equiv>\n  exe_wf_theory' ?e \\<and> exereplay ?e ?P = Some ?res\n  wf_theory (translate_theory ?a) = exe_wf_theory ?a\n\ngoal (1 subgoal):\n 1. exe_check_proof e P res = check_proof (translate_theory e) P res", "by (metis exe_wf_theory_code replay_code)"], ["", "lemma check_proof_sound:\n  shows \"exe_check_proof e P res \\<Longrightarrow> translate_theory e, set (hyps P) \\<turnstile> res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exe_check_proof e P res \\<Longrightarrow>\n    translate_theory e,set (hyps P) \\<turnstile> res", "by (simp add: check_proof_sound exe_check_proof_iff_check_proof)"], ["", "lemma check_proof_really_sound:\n  shows \"exe_check_proof e P res \\<Longrightarrow> translate_theory e, set (hyps P) \\<tturnstile> res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exe_check_proof e P res \\<Longrightarrow>\n    translate_theory e,set (hyps P) \\<tturnstile> res", "by (simp add: check_proof_really_sound exe_check_proof_iff_check_proof)"], ["", "end"]]}