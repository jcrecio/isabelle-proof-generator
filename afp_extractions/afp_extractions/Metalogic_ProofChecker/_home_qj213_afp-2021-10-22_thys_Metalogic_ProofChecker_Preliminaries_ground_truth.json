{"file_name": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker/Preliminaries.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker", "problem_names": ["lemma Or_Some: \"(e1 OR e2) = Some x \\<longleftrightarrow> e1 = Some x \\<or> (e1 = None \\<and> e2 = Some x)\"", "lemma Or_None: \"(e1 OR e2) = None \\<longleftrightarrow> e1 = None \\<and> e2 = None\"", "lemma lift2_option_not_None: \"lift2_option f x y \\<noteq> None \\<longleftrightarrow> (x \\<noteq> None \\<and> y \\<noteq> None)\"", "lemma lift2_option_None: \"lift2_option f x y = None \\<longleftrightarrow> (x = None \\<or> y = None)\"", "lemma findD:\n  \"find f xs = Some p \\<Longrightarrow> \\<exists>x \\<in> set xs. f x = Some p\"", "lemma find_None:\n  \"find f xs = None \\<longleftrightarrow> (\\<forall>x \\<in> set xs. f x = None)\"", "lemma find_ListFind: \"find f l = Option.bind (List.find (\\<lambda>x. case f x of None \\<Rightarrow> False | _ \\<Rightarrow> True) l) f\"", "lemma \"List.find P l = Some p \\<Longrightarrow> \\<exists>p \\<in> set l . P p\"", "lemma find_the_pair:\n  assumes \"distinct (map fst pairs)\" \n    and \"\\<And>x y. x\\<in>set (map fst pairs) \\<Longrightarrow> y\\<in>set (map fst pairs) \\<Longrightarrow> P x \\<Longrightarrow> P y \\<Longrightarrow> x = y\"\n    and \"(x,y) \\<in> set pairs\" and \"P x\" \n  shows \"List.find (\\<lambda>(x,_) . P x) pairs = Some (x,y)\"", "lemma \"remdups_on (=) xs = remdups xs\"", "lemma remdups_on_antimono:\n  \"(\\<And>x y . f x y \\<Longrightarrow> g x y) \\<Longrightarrow> set (remdups_on g xs) \\<subseteq> set (remdups_on f xs)\"", "lemma remdups_on_subset_input: \"set (remdups_on f xs) \\<subseteq> set xs\"", "lemma distinct_on_remdups_on: \"distinct_on f (remdups_on f xs)\"", "lemma distinct_on_no_compare: \"(\\<And>x y . f x y \\<Longrightarrow> f y x)\\<Longrightarrow> \n  distinct_on f xs \\<Longrightarrow> x\\<in>set xs \\<Longrightarrow> y\\<in>set xs \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow> \\<not> f x y\"", "lemma lookup_present_eq_key: \"distinct (map fst al) \\<Longrightarrow> (k, v) \\<in> set al \\<longleftrightarrow> lookup (\\<lambda>x. x=k) al = Some v\"", "lemma lookup_None_iff: \"lookup P xs = None \\<longleftrightarrow> \\<not> (\\<exists>x. x \\<in> set (map fst xs) \\<and> P x)\"", "lemma find_Some: \"List.find P l = Some p \\<Longrightarrow> p\\<in>set l \\<and> P p\"", "lemma find_Some_imp_lookup_Some: \n  \"List.find (\\<lambda>(k,_). P k) xs = Some (k,v) \\<Longrightarrow> lookup P xs = Some v\"", "lemma lookup_Some_imp_find_Some: \n  \"lookup P xs = Some v \\<Longrightarrow> \\<exists>x. List.find (\\<lambda>(k,_). P k) xs = Some (x,v)\"", "lemma lookup_None_iff_find_None: \"lookup P xs = None \\<longleftrightarrow> List.find (\\<lambda>(k,_). P k) xs = None\"", "lemma lookup_eq_order_irrelevant:\n  assumes \"distinct (map fst pairs)\" and \"distinct (map fst pairs')\" and \"set pairs = set pairs'\"\n  shows \"lookup (\\<lambda>x. x=k) pairs = lookup (\\<lambda>x. x=k) pairs'\"", "lemma lookup_Some_append_back:\n  \"lookup (\\<lambda>x. x=k) insts = Some v \\<Longrightarrow> lookup (\\<lambda>x. x=k) (insts@[(k,v')]) = Some v\"", "lemma lookup_eq_key_not_present: \"key \\<notin> set (map fst inst) \\<Longrightarrow> lookup (\\<lambda>x. x = key) inst = None\"", "lemma lookup_in_empty[simp]: \"lookup f [] = None\"", "lemma lookup_in_single[simp]: \"lookup f [(k, v)] = (if f k then Some v else None)\"", "lemma lookup_present_eq_key': \"lookup (\\<lambda>x. x=k) al = Some v \\<Longrightarrow> (k, v) \\<in> set al \"", "lemma lookup_present_eq_key'': \"distinct (map fst al) \\<Longrightarrow> lookup (\\<lambda>x. x=k) al = Some v \\<longleftrightarrow> (k, v) \\<in> set al \"", "lemma key_present_imp_eq_lookup_finds_value: \"k \\<in> fst ` set al \\<Longrightarrow> \\<exists>v . lookup (\\<lambda>x. x=k) al = Some v\"", "lemma list_allI: \"(\\<And>x. x\\<in>set l \\<Longrightarrow> P x) \\<Longrightarrow> list_all P l\"", "lemma map2_sym: \"(\\<And>x y . f x y = f y x) \\<Longrightarrow> map2 f xs ys = map2 f ys xs\"", "lemma idem_map2: assumes \"(\\<And>x. f x x = x)\" shows \"map2 f l l = l\"", "lemma rev_induct2[consumes 1, case_names Nil snoc]:\n  assumes \"length xs = length ys\"\n  assumes \"P [] []\"\n  assumes \"(\\<And>x xs y ys. length xs = length ys \\<Longrightarrow> P xs ys \\<Longrightarrow> P (xs @ [x]) (ys @ [y]))\"\n  shows \"P xs ys\"", "lemma alist_map_corr: \"distinct (map fst al) \\<Longrightarrow> (k,v) \\<in> set al \\<longleftrightarrow> map_of al k = Some v\"", "lemma distinct_fst_imp_distinct: \"distinct (map fst l) \\<Longrightarrow> distinct l\"", "lemma length_alist:\n  assumes \"distinct (map fst al)\" and \"distinct (map fst al')\" and \"set al = set al'\"\n  shows \"length al = length al'\"", "lemma same_map_of_imp_same_length: \n  \"distinct (map fst ars1) \\<Longrightarrow> distinct (map fst ars2) \\<Longrightarrow> map_of ars1 = map_of ars2\n  \\<Longrightarrow> length ars1 = length ars2\"", "lemma in_range_if_ex_key: \"v \\<in> ran m \\<longleftrightarrow> (\\<exists>k. m k = Some v)\"", "lemma set_AList_delete_bound: \"set (AList.delete a l) \\<subseteq> set l\"", "lemma list_all_clearjunk_cons: \n  \"list_all P (x#(AList.clearjunk l)) \\<Longrightarrow> list_all P (AList.clearjunk (x#l))\"", "lemma lookup_AList_delete: \"k'\\<noteq>k \\<Longrightarrow> lookup (\\<lambda>x. x = k) al = lookup (\\<lambda>x. x = k) (AList.delete k' al)\"", "lemma lookup_AList_clearjunk: \"lookup (\\<lambda>x. x = k) al = lookup (\\<lambda>x. x = k) (AList.clearjunk al)\"", "lemma diff_list_set[simp]: \"set (diff_list xs ys) = set xs - set ys\"", "lemma diff_list_set_from_Nil[simp]: \"diff_list [] ys = []\"", "lemma diff_list_set_remove_Nil[simp]: \"diff_list xs [] = xs\"", "lemma diff_list_rec: \"diff_list (x # xs) ys = (if x\\<in>set ys then diff_list xs ys else x#diff_list xs ys)\"", "lemma diff_list_order_irr: \"set ys = set ys' \\<Longrightarrow> diff_list xs ys = diff_list xs ys'\"", "lemma fold_Option_bind_eq_Some_start_not_None:\n  \"fold (\\<lambda>new option . Option.bind option (f new)) list start = Some res\n  \\<Longrightarrow> start \\<noteq> None\"", "lemma fold_Option_bind_eq_Some_at_point_not_None:\n  \"fold (\\<lambda>new option . Option.bind option (f new)) (l1@l2) start = Some res\n  \\<Longrightarrow> fold (\\<lambda>new option . Option.bind option (f new)) (l1) start \\<noteq> None\"", "lemma fold_Option_bind_eq_Some_start_not_None':\n  \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) list start = Some res\n  \\<Longrightarrow> start \\<noteq> None\"", "lemma fold_Option_bind_eq_None_start_None:\n  \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) list None = None\"", "lemma fold_Option_bind_at_some_point_None_eq_None:\n  \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) l1 start = None \\<Longrightarrow>\n  fold (\\<lambda>(x,y) option . Option.bind option (f x y)) (l1@l2) start = None\"", "lemma fold_Option_bind_eq_Some_at_each_point_Some:\n  \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) (l1@l2) start = Some res\n  \\<Longrightarrow> (\\<exists>point . fold (\\<lambda>(x,y) option . Option.bind option (f x y)) l1 start = Some point\n    \\<and> fold (\\<lambda>(x,y) option . Option.bind option (f x y)) l2 (Some point) = Some res)\"", "lemma fold_Option_bind_eq_Some_at_each_point_Some':\n  assumes \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) (xs@ys) start = Some res\"\n  obtains point where \n    \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) xs start = Some point\" and\n    \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) ys (Some point) = Some res\"", "lemma fold_matches_first_step_not_None:\n  assumes\n    \"fold (\\<lambda>(T, U) subs . Option.bind subs (f T U)) (zip (x#xs) (y#ys)) (Some subs) = Some subs'\" \n  obtains point where\n    \"f x y subs = Some point\"\n    \"fold (\\<lambda>(T, U) subs . Option.bind subs (f T U)) (zip (xs) (ys)) (Some point) = Some subs'\"", "lemma fold_matches_last_step_not_None:\n  assumes\n    \"length xs = length ys\"\n    \"fold (\\<lambda>(T, U) subs . Option.bind subs (f T U)) (zip (xs@[x]) (ys@[y])) (Some subs) = Some subs'\" \n  obtains point where\n    \"fold (\\<lambda>(T, U) subs . Option.bind subs (f T U)) (zip (xs) (ys)) (Some subs) = Some point\"\n    \"f x y point = Some subs'\""], "translations": [["", "lemma Or_Some: \"(e1 OR e2) = Some x \\<longleftrightarrow> e1 = Some x \\<or> (e1 = None \\<and> e2 = Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e1 OR e2 = Some x) = (e1 = Some x \\<or> e1 = None \\<and> e2 = Some x)", "by(auto split: option.split)"], ["", "lemma Or_None: \"(e1 OR e2) = None \\<longleftrightarrow> e1 = None \\<and> e2 = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e1 OR e2 = None) = (e1 = None \\<and> e2 = None)", "by(auto split: option.split)"], ["", "fun lift2_option :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> 'a option \\<Rightarrow> 'b option \\<Rightarrow> 'c option\" where\n  \"lift2_option _ None _ = None\" |\n  \"lift2_option _ _ None = None\" |\n  \"lift2_option f (Some x) (Some y) = Some (f x y)\""], ["", "lemma lift2_option_not_None: \"lift2_option f x y \\<noteq> None \\<longleftrightarrow> (x \\<noteq> None \\<and> y \\<noteq> None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift2_option f x y \\<noteq> None) =\n    (x \\<noteq> None \\<and> y \\<noteq> None)", "using lift2_option.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>lift2_option ?x ?xa ?xb = ?y;\n   \\<And>uu_ uv_.\n      \\<lbrakk>?x = uu_; ?xa = None; ?xb = uv_; ?y = None\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>uw_ v.\n      \\<lbrakk>?x = uw_; ?xa = Some v; ?xb = None; ?y = None\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>f x y.\n      \\<lbrakk>?x = f; ?xa = Some x; ?xb = Some y;\n       ?y = Some (f x y)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (lift2_option f x y \\<noteq> None) =\n    (x \\<noteq> None \\<and> y \\<noteq> None)", "by blast"], ["", "lemma lift2_option_None: \"lift2_option f x y = None \\<longleftrightarrow> (x = None \\<or> y = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift2_option f x y = None) = (x = None \\<or> y = None)", "using lift2_option.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>lift2_option ?x ?xa ?xb = ?y;\n   \\<And>uu_ uv_.\n      \\<lbrakk>?x = uu_; ?xa = None; ?xb = uv_; ?y = None\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>uw_ v.\n      \\<lbrakk>?x = uw_; ?xa = Some v; ?xb = None; ?y = None\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>f x y.\n      \\<lbrakk>?x = f; ?xa = Some x; ?xb = Some y;\n       ?y = Some (f x y)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (lift2_option f x y = None) = (x = None \\<or> y = None)", "by blast"], ["", "text \\<open>Lookup functions for assoc lists\\<close>"], ["", "fun find :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> 'a list \\<Rightarrow> 'b option\" where\n\"find f [] = None\" |\n\"find f (x#xs) = f x OR find f xs\""], ["", "lemma findD:\n  \"find f xs = Some p \\<Longrightarrow> \\<exists>x \\<in> set xs. f x = Some p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Preliminaries.find f xs = Some p \\<Longrightarrow>\n    \\<exists>x\\<in>set xs. f x = Some p", "by(induction xs arbitrary: p) (auto split: option.splits)"], ["", "lemma find_None:\n  \"find f xs = None \\<longleftrightarrow> (\\<forall>x \\<in> set xs. f x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Preliminaries.find f xs = None) = (\\<forall>x\\<in>set xs. f x = None)", "by(induction xs) (auto split: option.splits)"], ["", "lemma find_ListFind: \"find f l = Option.bind (List.find (\\<lambda>x. case f x of None \\<Rightarrow> False | _ \\<Rightarrow> True) l) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Preliminaries.find f l =\n    Option.bind\n     (List.find\n       (\\<lambda>x.\n           case f x of None \\<Rightarrow> False | Some a \\<Rightarrow> True)\n       l)\n     f", "by (induction l) (auto split: option.split)"], ["", "lemma \"List.find P l = Some p \\<Longrightarrow> \\<exists>p \\<in> set l . P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.find P l = Some p \\<Longrightarrow> \\<exists>p\\<in>set l. P p", "by (induction l) (auto split: if_splits)"], ["", "lemma find_the_pair:\n  assumes \"distinct (map fst pairs)\" \n    and \"\\<And>x y. x\\<in>set (map fst pairs) \\<Longrightarrow> y\\<in>set (map fst pairs) \\<Longrightarrow> P x \\<Longrightarrow> P y \\<Longrightarrow> x = y\"\n    and \"(x,y) \\<in> set pairs\" and \"P x\" \n  shows \"List.find (\\<lambda>(x,_) . P x) pairs = Some (x,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.find (\\<lambda>(x, uu_). P x) pairs = Some (x, y)", "using assms(1-3)"], ["proof (prove)\nusing this:\n  distinct (map fst pairs)\n  \\<lbrakk>?x \\<in> set (map fst pairs); ?y \\<in> set (map fst pairs); P ?x;\n   P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (x, y) \\<in> set pairs\n\ngoal (1 subgoal):\n 1. List.find (\\<lambda>(x, uu_). P x) pairs = Some (x, y)", "proof (induction pairs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst []);\n     \\<And>x y.\n        \\<lbrakk>x \\<in> set (map fst []); y \\<in> set (map fst []); P x;\n         P y\\<rbrakk>\n        \\<Longrightarrow> x = y;\n     (x, y) \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) [] = Some (x, y)\n 2. \\<And>a pairs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst pairs);\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set (map fst pairs);\n                     y \\<in> set (map fst pairs); P x; P y\\<rbrakk>\n                    \\<Longrightarrow> x = y;\n                 (x, y) \\<in> set pairs\\<rbrakk>\n                \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) pairs =\n                                  Some (x, y);\n        distinct (map fst (a # pairs));\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (map fst (a # pairs));\n            y \\<in> set (map fst (a # pairs)); P x; P y\\<rbrakk>\n           \\<Longrightarrow> x = y;\n        (x, y) \\<in> set (a # pairs)\\<rbrakk>\n       \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) (a # pairs) =\n                         Some (x, y)", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n  \\<lbrakk>?x \\<in> set (map fst []); ?y \\<in> set (map fst []); P ?x;\n   P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (x, y) \\<in> set []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct (map fst []);\n     \\<And>x y.\n        \\<lbrakk>x \\<in> set (map fst []); y \\<in> set (map fst []); P x;\n         P y\\<rbrakk>\n        \\<Longrightarrow> x = y;\n     (x, y) \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) [] = Some (x, y)\n 2. \\<And>a pairs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst pairs);\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set (map fst pairs);\n                     y \\<in> set (map fst pairs); P x; P y\\<rbrakk>\n                    \\<Longrightarrow> x = y;\n                 (x, y) \\<in> set pairs\\<rbrakk>\n                \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) pairs =\n                                  Some (x, y);\n        distinct (map fst (a # pairs));\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (map fst (a # pairs));\n            y \\<in> set (map fst (a # pairs)); P x; P y\\<rbrakk>\n           \\<Longrightarrow> x = y;\n        (x, y) \\<in> set (a # pairs)\\<rbrakk>\n       \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) (a # pairs) =\n                         Some (x, y)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst [])\n  \\<lbrakk>?x \\<in> set (map fst []); ?y \\<in> set (map fst []); P ?x;\n   P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (x, y) \\<in> set []", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n  \\<lbrakk>?x \\<in> set (map fst []); ?y \\<in> set (map fst []); P ?x;\n   P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (x, y) \\<in> set []\n\ngoal (1 subgoal):\n 1. List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x) [] =\n    Some (x, y)", "by simp"], ["proof (state)\nthis:\n  List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x) [] =\n  Some (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>a pairs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst pairs);\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set (map fst pairs);\n                     y \\<in> set (map fst pairs); P x; P y\\<rbrakk>\n                    \\<Longrightarrow> x = y;\n                 (x, y) \\<in> set pairs\\<rbrakk>\n                \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) pairs =\n                                  Some (x, y);\n        distinct (map fst (a # pairs));\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (map fst (a # pairs));\n            y \\<in> set (map fst (a # pairs)); P x; P y\\<rbrakk>\n           \\<Longrightarrow> x = y;\n        (x, y) \\<in> set (a # pairs)\\<rbrakk>\n       \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) (a # pairs) =\n                         Some (x, y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a pairs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst pairs);\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set (map fst pairs);\n                     y \\<in> set (map fst pairs); P x; P y\\<rbrakk>\n                    \\<Longrightarrow> x = y;\n                 (x, y) \\<in> set pairs\\<rbrakk>\n                \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) pairs =\n                                  Some (x, y);\n        distinct (map fst (a # pairs));\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (map fst (a # pairs));\n            y \\<in> set (map fst (a # pairs)); P x; P y\\<rbrakk>\n           \\<Longrightarrow> x = y;\n        (x, y) \\<in> set (a # pairs)\\<rbrakk>\n       \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) (a # pairs) =\n                         Some (x, y)", "case (Cons pair pairs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst pairs);\n   \\<And>x y.\n      \\<lbrakk>x \\<in> set (map fst pairs); y \\<in> set (map fst pairs);\n       P x; P y\\<rbrakk>\n      \\<Longrightarrow> x = y;\n   (x, y) \\<in> set pairs\\<rbrakk>\n  \\<Longrightarrow> List.find\n                     (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n                     pairs =\n                    Some (x, y)\n  distinct (map fst (pair # pairs))\n  \\<lbrakk>?x \\<in> set (map fst (pair # pairs));\n   ?y \\<in> set (map fst (pair # pairs)); P ?x; P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (x, y) \\<in> set (pair # pairs)\n\ngoal (1 subgoal):\n 1. \\<And>a pairs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst pairs);\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set (map fst pairs);\n                     y \\<in> set (map fst pairs); P x; P y\\<rbrakk>\n                    \\<Longrightarrow> x = y;\n                 (x, y) \\<in> set pairs\\<rbrakk>\n                \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) pairs =\n                                  Some (x, y);\n        distinct (map fst (a # pairs));\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (map fst (a # pairs));\n            y \\<in> set (map fst (a # pairs)); P x; P y\\<rbrakk>\n           \\<Longrightarrow> x = y;\n        (x, y) \\<in> set (a # pairs)\\<rbrakk>\n       \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) (a # pairs) =\n                         Some (x, y)", "thm Cons.prems"], ["proof (state)\nthis:\n  \\<lbrakk>distinct (map fst pairs);\n   \\<And>x y.\n      \\<lbrakk>x \\<in> set (map fst pairs); y \\<in> set (map fst pairs);\n       P x; P y\\<rbrakk>\n      \\<Longrightarrow> x = y;\n   (x, y) \\<in> set pairs\\<rbrakk>\n  \\<Longrightarrow> List.find\n                     (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n                     pairs =\n                    Some (x, y)\n  distinct (map fst (pair # pairs))\n  \\<lbrakk>?x \\<in> set (map fst (pair # pairs));\n   ?y \\<in> set (map fst (pair # pairs)); P ?x; P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (x, y) \\<in> set (pair # pairs)\n\ngoal (1 subgoal):\n 1. \\<And>a pairs.\n       \\<lbrakk>\\<lbrakk>distinct (map fst pairs);\n                 \\<And>x y.\n                    \\<lbrakk>x \\<in> set (map fst pairs);\n                     y \\<in> set (map fst pairs); P x; P y\\<rbrakk>\n                    \\<Longrightarrow> x = y;\n                 (x, y) \\<in> set pairs\\<rbrakk>\n                \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) pairs =\n                                  Some (x, y);\n        distinct (map fst (a # pairs));\n        \\<And>x y.\n           \\<lbrakk>x \\<in> set (map fst (a # pairs));\n            y \\<in> set (map fst (a # pairs)); P x; P y\\<rbrakk>\n           \\<Longrightarrow> x = y;\n        (x, y) \\<in> set (a # pairs)\\<rbrakk>\n       \\<Longrightarrow> List.find (\\<lambda>(x, uu_). P x) (a # pairs) =\n                         Some (x, y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "proof(cases \"fst pair = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst pair = x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)\n 2. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "case True"], ["proof (state)\nthis:\n  fst pair = x\n\ngoal (2 subgoals):\n 1. fst pair = x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)\n 2. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "then"], ["proof (chain)\npicking this:\n  fst pair = x", "show ?thesis"], ["proof (prove)\nusing this:\n  fst pair = x\n\ngoal (1 subgoal):\n 1. List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "using eq_key_imp_eq_value[OF Cons.prems(1,3)] assms(4)"], ["proof (prove)\nusing this:\n  fst pair = x\n  (x, ?v2.0) \\<in> set (pair # pairs) \\<Longrightarrow> y = ?v2.0\n  P x\n\ngoal (1 subgoal):\n 1. List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "by force"], ["proof (state)\nthis:\n  List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n   (pair # pairs) =\n  Some (x, y)\n\ngoal (1 subgoal):\n 1. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "case False"], ["proof (state)\nthis:\n  fst pair \\<noteq> x\n\ngoal (1 subgoal):\n 1. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "hence \"(x,y) \\<in> set pairs\""], ["proof (prove)\nusing this:\n  fst pair \\<noteq> x\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> set pairs", "using Cons.prems(3)"], ["proof (prove)\nusing this:\n  fst pair \\<noteq> x\n  (x, y) \\<in> set (pair # pairs)\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> set pairs", "by fastforce"], ["proof (state)\nthis:\n  (x, y) \\<in> set pairs\n\ngoal (1 subgoal):\n 1. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "moreover"], ["proof (state)\nthis:\n  (x, y) \\<in> set pairs\n\ngoal (1 subgoal):\n 1. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "have \"\\<And>x y. x \\<in> set (map fst pairs) \\<Longrightarrow> y \\<in> set (map fst pairs) \\<Longrightarrow> P x \\<Longrightarrow> P y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map fst pairs); y \\<in> set (map fst pairs);\n        P x; P y\\<rbrakk>\n       \\<Longrightarrow> x = y", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (map fst (pair # pairs));\n   ?y \\<in> set (map fst (pair # pairs)); P ?x; P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (map fst pairs); y \\<in> set (map fst pairs);\n        P x; P y\\<rbrakk>\n       \\<Longrightarrow> x = y", "by (metis list.set_intros(2) list.simps(9))"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (map fst pairs); ?y \\<in> set (map fst pairs); P ?x;\n   P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "ultimately"], ["proof (chain)\npicking this:\n  (x, y) \\<in> set pairs\n  \\<lbrakk>?x \\<in> set (map fst pairs); ?y \\<in> set (map fst pairs); P ?x;\n   P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y", "have I: \"List.find (\\<lambda>(x,_) . P x) pairs = Some (x,y)\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> set pairs\n  \\<lbrakk>?x \\<in> set (map fst pairs); ?y \\<in> set (map fst pairs); P ?x;\n   P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. List.find (\\<lambda>(x, uu_). P x) pairs = Some (x, y)", "using Cons.prems(1,3)"], ["proof (prove)\nusing this:\n  (x, y) \\<in> set pairs\n  \\<lbrakk>?x \\<in> set (map fst pairs); ?y \\<in> set (map fst pairs); P ?x;\n   P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  distinct (map fst (pair # pairs))\n  (x, y) \\<in> set (pair # pairs)\n\ngoal (1 subgoal):\n 1. List.find (\\<lambda>(x, uu_). P x) pairs = Some (x, y)", "by (auto intro!: Cons.IH)"], ["proof (state)\nthis:\n  List.find (\\<lambda>(x, uu_). P x) pairs = Some (x, y)\n\ngoal (1 subgoal):\n 1. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "moreover"], ["proof (state)\nthis:\n  List.find (\\<lambda>(x, uu_). P x) pairs = Some (x, y)\n\ngoal (1 subgoal):\n 1. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "have \"\\<And>y. y \\<in> set (map fst (pair # pairs)) \\<Longrightarrow> P y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> set (map fst (pair # pairs)); P y\\<rbrakk>\n       \\<Longrightarrow> x = y", "using Cons.prems(2,3) assms(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (map fst (pair # pairs));\n   ?y \\<in> set (map fst (pair # pairs)); P ?x; P ?y\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (x, y) \\<in> set (pair # pairs)\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<in> set (map fst (pair # pairs)); P y\\<rbrakk>\n       \\<Longrightarrow> x = y", "by (metis set_zip_leftD zip_map_fst_snd)"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<in> set (map fst (pair # pairs)); P ?y\\<rbrakk>\n  \\<Longrightarrow> x = ?y\n\ngoal (1 subgoal):\n 1. fst pair \\<noteq> x \\<Longrightarrow>\n    List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "ultimately"], ["proof (chain)\npicking this:\n  List.find (\\<lambda>(x, uu_). P x) pairs = Some (x, y)\n  \\<lbrakk>?y \\<in> set (map fst (pair # pairs)); P ?y\\<rbrakk>\n  \\<Longrightarrow> x = ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  List.find (\\<lambda>(x, uu_). P x) pairs = Some (x, y)\n  \\<lbrakk>?y \\<in> set (map fst (pair # pairs)); P ?y\\<rbrakk>\n  \\<Longrightarrow> x = ?y\n\ngoal (1 subgoal):\n 1. List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "using False"], ["proof (prove)\nusing this:\n  List.find (\\<lambda>(x, uu_). P x) pairs = Some (x, y)\n  \\<lbrakk>?y \\<in> set (map fst (pair # pairs)); P ?y\\<rbrakk>\n  \\<Longrightarrow> x = ?y\n  fst pair \\<noteq> x\n\ngoal (1 subgoal):\n 1. List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n     (pair # pairs) =\n    Some (x, y)", "by fastforce"], ["proof (state)\nthis:\n  List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n   (pair # pairs) =\n  Some (x, y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  List.find (\\<lambda>a. case a of (x, uu_) \\<Rightarrow> P x)\n   (pair # pairs) =\n  Some (x, y)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun remdups_on :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"remdups_on  _ [] = []\" \n| \"remdups_on cmp (x # xs) = \n    (if \\<exists>x' \\<in> set xs . cmp x x' then remdups_on cmp xs else x # remdups_on cmp xs)\""], ["", "fun distinct_on :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> bool\" where\n  \"distinct_on _ [] \\<longleftrightarrow> True\"\n| \"distinct_on cmp (x # xs) \\<longleftrightarrow> \\<not>(\\<exists>x' \\<in> set xs . cmp x x') \\<and> distinct_on cmp xs\""], ["", "lemma \"remdups_on (=) xs = remdups xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups_on (=) xs = remdups xs", "by (induction xs) auto"], ["", "lemma remdups_on_antimono:\n  \"(\\<And>x y . f x y \\<Longrightarrow> g x y) \\<Longrightarrow> set (remdups_on g xs) \\<subseteq> set (remdups_on f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. f x y \\<Longrightarrow> g x y) \\<Longrightarrow>\n    set (remdups_on g xs) \\<subseteq> set (remdups_on f xs)", "by (induction xs) auto"], ["", "lemma remdups_on_subset_input: \"set (remdups_on f xs) \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (remdups_on f xs) \\<subseteq> set xs", "by (induction xs) auto"], ["", "lemma distinct_on_remdups_on: \"distinct_on f (remdups_on f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_on f (remdups_on f xs)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct_on f (remdups_on f [])\n 2. \\<And>a xs.\n       distinct_on f (remdups_on f xs) \\<Longrightarrow>\n       distinct_on f (remdups_on f (a # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. distinct_on f (remdups_on f [])\n 2. \\<And>a xs.\n       distinct_on f (remdups_on f xs) \\<Longrightarrow>\n       distinct_on f (remdups_on f (a # xs))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_on f (remdups_on f [])", "by simp"], ["proof (state)\nthis:\n  distinct_on f (remdups_on f [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       distinct_on f (remdups_on f xs) \\<Longrightarrow>\n       distinct_on f (remdups_on f (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       distinct_on f (remdups_on f xs) \\<Longrightarrow>\n       distinct_on f (remdups_on f (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  distinct_on f (remdups_on f xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       distinct_on f (remdups_on f xs) \\<Longrightarrow>\n       distinct_on f (remdups_on f (a # xs))", "then"], ["proof (chain)\npicking this:\n  distinct_on f (remdups_on f xs)", "show ?case"], ["proof (prove)\nusing this:\n  distinct_on f (remdups_on f xs)\n\ngoal (1 subgoal):\n 1. distinct_on f (remdups_on f (x # xs))", "using remdups_on_subset_input"], ["proof (prove)\nusing this:\n  distinct_on f (remdups_on f xs)\n  set (remdups_on ?f ?xs) \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. distinct_on f (remdups_on f (x # xs))", "by fastforce"], ["proof (state)\nthis:\n  distinct_on f (remdups_on f (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_on_no_compare: \"(\\<And>x y . f x y \\<Longrightarrow> f y x)\\<Longrightarrow> \n  distinct_on f xs \\<Longrightarrow> x\\<in>set xs \\<Longrightarrow> y\\<in>set xs \\<Longrightarrow> x\\<noteq>y \\<Longrightarrow> \\<not> f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y. f x y \\<Longrightarrow> f y x; distinct_on f xs;\n     x \\<in> set xs; y \\<in> set xs; x \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> \\<not> f x y", "by (induction xs) auto"], ["", "fun lookup :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<times> 'b) list \\<Rightarrow> 'b option\" where\n  \"lookup _ [] = None\"\n| \"lookup f ((x,y)#xs) = (if f x then Some y else lookup f xs)\""], ["", "lemma lookup_present_eq_key: \"distinct (map fst al) \\<Longrightarrow> (k, v) \\<in> set al \\<longleftrightarrow> lookup (\\<lambda>x. x=k) al = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst al) \\<Longrightarrow>\n    ((k, v) \\<in> set al) = (lookup (\\<lambda>x. x = k) al = Some v)", "by (induction al) (auto simp add: rev_image_eqI split: if_splits)"], ["", "lemma lookup_None_iff: \"lookup P xs = None \\<longleftrightarrow> \\<not> (\\<exists>x. x \\<in> set (map fst xs) \\<and> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup P xs = None) =\n    (\\<nexists>x. x \\<in> set (map fst xs) \\<and> P x)", "by (induction xs) (auto split: if_splits)"], ["", "lemma find_Some: \"List.find P l = Some p \\<Longrightarrow> p\\<in>set l \\<and> P p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.find P l = Some p \\<Longrightarrow> p \\<in> set l \\<and> P p", "by (induction l) (auto split: if_splits)"], ["", "(* This means lookup seems somewhat superflouus *)"], ["", "lemma find_Some_imp_lookup_Some: \n  \"List.find (\\<lambda>(k,_). P k) xs = Some (k,v) \\<Longrightarrow> lookup P xs = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.find (\\<lambda>(k, uu_). P k) xs = Some (k, v) \\<Longrightarrow>\n    lookup P xs = Some v", "by (induction xs) auto"], ["", "lemma lookup_Some_imp_find_Some: \n  \"lookup P xs = Some v \\<Longrightarrow> \\<exists>x. List.find (\\<lambda>(k,_). P k) xs = Some (x,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup P xs = Some v \\<Longrightarrow>\n    \\<exists>x. List.find (\\<lambda>(k, uu_). P k) xs = Some (x, v)", "by (induction xs) auto"], ["", "lemma lookup_None_iff_find_None: \"lookup P xs = None \\<longleftrightarrow> List.find (\\<lambda>(k,_). P k) xs = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lookup P xs = None) = (List.find (\\<lambda>(k, uu_). P k) xs = None)", "by (induction xs) auto"], ["", "lemma lookup_eq_order_irrelevant:\n  assumes \"distinct (map fst pairs)\" and \"distinct (map fst pairs')\" and \"set pairs = set pairs'\"\n  shows \"lookup (\\<lambda>x. x=k) pairs = lookup (\\<lambda>x. x=k) pairs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "proof (cases \"lookup (\\<lambda>x. x=k) pairs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = k) pairs = None \\<Longrightarrow>\n    lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = k) pairs = Some a \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "case None"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) pairs = None\n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = k) pairs = None \\<Longrightarrow>\n    lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = k) pairs = Some a \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = k) pairs = None", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = k) pairs = None\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "using lookup_None_iff"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = k) pairs = None\n  (lookup ?P ?xs = None) =\n  (\\<nexists>x. x \\<in> set (map fst ?xs) \\<and> ?P x)\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "by (metis assms(3) set_map)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = k) pairs = Some a \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = k) pairs = Some a \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "case (Some v)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) pairs = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = k) pairs = Some a \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "hence \"(k,v)\\<in>set pairs\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = k) pairs = Some v\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set pairs", "using assms(1)"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = k) pairs = Some v\n  distinct (map fst pairs)\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set pairs", "by (simp add: lookup_present_eq_key)"], ["proof (state)\nthis:\n  (k, v) \\<in> set pairs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = k) pairs = Some a \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "hence el: \"(k,v)\\<in>set pairs'\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set pairs\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set pairs'", "using assms(3)"], ["proof (prove)\nusing this:\n  (k, v) \\<in> set pairs\n  set pairs = set pairs'\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set pairs'", "by blast"], ["proof (state)\nthis:\n  (k, v) \\<in> set pairs'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = k) pairs = Some a \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "using lookup_present_eq_key[OF assms(2)] el Some"], ["proof (prove)\nusing this:\n  ((?k, ?v) \\<in> set pairs') =\n  (lookup (\\<lambda>x. x = ?k) pairs' = Some ?v)\n  (k, v) \\<in> set pairs'\n  lookup (\\<lambda>x. x = k) pairs = Some v\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'", "by simp"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) pairs = lookup (\\<lambda>x. x = k) pairs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_Some_append_back:\n  \"lookup (\\<lambda>x. x=k) insts = Some v \\<Longrightarrow> lookup (\\<lambda>x. x=k) (insts@[(k,v')]) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) insts = Some v \\<Longrightarrow>\n    lookup (\\<lambda>x. x = k) (insts @ [(k, v')]) = Some v", "by (induction insts arbitrary: ) auto"], ["", "lemma lookup_eq_key_not_present: \"key \\<notin> set (map fst inst) \\<Longrightarrow> lookup (\\<lambda>x. x = key) inst = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key \\<notin> set (map fst inst) \\<Longrightarrow>\n    lookup (\\<lambda>x. x = key) inst = None", "by (induction inst) auto"], ["", "lemma lookup_in_empty[simp]: \"lookup f [] = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup f [] = None", "by simp"], ["", "lemma lookup_in_single[simp]: \"lookup f [(k, v)] = (if f k then Some v else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup f [(k, v)] = (if f k then Some v else None)", "by simp"], ["", "lemma lookup_present_eq_key': \"lookup (\\<lambda>x. x=k) al = Some v \\<Longrightarrow> (k, v) \\<in> set al \""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) al = Some v \\<Longrightarrow>\n    (k, v) \\<in> set al", "by (induction al) (auto simp add: rev_image_eqI split: if_splits)"], ["", "lemma lookup_present_eq_key'': \"distinct (map fst al) \\<Longrightarrow> lookup (\\<lambda>x. x=k) al = Some v \\<longleftrightarrow> (k, v) \\<in> set al \""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst al) \\<Longrightarrow>\n    (lookup (\\<lambda>x. x = k) al = Some v) = ((k, v) \\<in> set al)", "by (induction al) (auto simp add: rev_image_eqI split: if_splits)"], ["", "lemma key_present_imp_eq_lookup_finds_value: \"k \\<in> fst ` set al \\<Longrightarrow> \\<exists>v . lookup (\\<lambda>x. x=k) al = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set al \\<Longrightarrow>\n    \\<exists>v. lookup (\\<lambda>x. x = k) al = Some v", "by (induction al) (auto simp add: rev_image_eqI)"], ["", "lemma list_allI: \"(\\<And>x. x\\<in>set l \\<Longrightarrow> P x) \\<Longrightarrow> list_all P l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set l \\<Longrightarrow> P x) \\<Longrightarrow>\n    list_all P l", "by (induction l) auto"], ["", "lemma map2_sym: \"(\\<And>x y . f x y = f y x) \\<Longrightarrow> map2 f xs ys = map2 f ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. f x y = f y x) \\<Longrightarrow> map2 f xs ys = map2 f ys xs", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (\\<And>x y. f x y = f y x) \\<Longrightarrow>\n       map2 f [] ys = map2 f ys []\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   (\\<And>x y. f x y = f y x) \\<Longrightarrow>\n                   map2 f xs ys = map2 f ys xs;\n        \\<And>x y. f x y = f y x\\<rbrakk>\n       \\<Longrightarrow> map2 f (a # xs) ys = map2 f ys (a # xs)", "case Nil"], ["proof (state)\nthis:\n  f ?x ?y = f ?y ?x\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (\\<And>x y. f x y = f y x) \\<Longrightarrow>\n       map2 f [] ys = map2 f ys []\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   (\\<And>x y. f x y = f y x) \\<Longrightarrow>\n                   map2 f xs ys = map2 f ys xs;\n        \\<And>x y. f x y = f y x\\<rbrakk>\n       \\<Longrightarrow> map2 f (a # xs) ys = map2 f ys (a # xs)", "then"], ["proof (chain)\npicking this:\n  f ?x ?y = f ?y ?x", "show ?case"], ["proof (prove)\nusing this:\n  f ?x ?y = f ?y ?x\n\ngoal (1 subgoal):\n 1. map2 f [] ys = map2 f ys []", "by simp"], ["proof (state)\nthis:\n  map2 f [] ys = map2 f ys []\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   (\\<And>x y. f x y = f y x) \\<Longrightarrow>\n                   map2 f xs ys = map2 f ys xs;\n        \\<And>x y. f x y = f y x\\<rbrakk>\n       \\<Longrightarrow> map2 f (a # xs) ys = map2 f ys (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   (\\<And>x y. f x y = f y x) \\<Longrightarrow>\n                   map2 f xs ys = map2 f ys xs;\n        \\<And>x y. f x y = f y x\\<rbrakk>\n       \\<Longrightarrow> map2 f (a # xs) ys = map2 f ys (a # xs)", "case (Cons a xs)"], ["proof (state)\nthis:\n  (\\<And>x y. f x y = f y x) \\<Longrightarrow> map2 f xs ?ys = map2 f ?ys xs\n  f ?x ?y = f ?y ?x\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   (\\<And>x y. f x y = f y x) \\<Longrightarrow>\n                   map2 f xs ys = map2 f ys xs;\n        \\<And>x y. f x y = f y x\\<rbrakk>\n       \\<Longrightarrow> map2 f (a # xs) ys = map2 f ys (a # xs)", "then"], ["proof (chain)\npicking this:\n  (\\<And>x y. f x y = f y x) \\<Longrightarrow> map2 f xs ?ys = map2 f ?ys xs\n  f ?x ?y = f ?y ?x", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y. f x y = f y x) \\<Longrightarrow> map2 f xs ?ys = map2 f ?ys xs\n  f ?x ?y = f ?y ?x\n\ngoal (1 subgoal):\n 1. map2 f (a # xs) ys = map2 f ys (a # xs)", "by (induction ys) auto"], ["proof (state)\nthis:\n  map2 f (a # xs) ys = map2 f ys (a # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma idem_map2: assumes \"(\\<And>x. f x x = x)\" shows \"map2 f l l = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 f l l = l", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map2 f l l = l", "have \"length l = length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length l = length l", "by simp"], ["proof (state)\nthis:\n  length l = length l\n\ngoal (1 subgoal):\n 1. map2 f l l = l", "then"], ["proof (chain)\npicking this:\n  length l = length l", "show \"map2 f l l = l\""], ["proof (prove)\nusing this:\n  length l = length l\n\ngoal (1 subgoal):\n 1. map2 f l l = l", "by (induction l l rule: list_induct2) (use assms in auto)"], ["proof (state)\nthis:\n  map2 f l l = l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rev_induct2[consumes 1, case_names Nil snoc]:\n  assumes \"length xs = length ys\"\n  assumes \"P [] []\"\n  assumes \"(\\<And>x xs y ys. length xs = length ys \\<Longrightarrow> P xs ys \\<Longrightarrow> P (xs @ [x]) (ys @ [y]))\"\n  shows \"P xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs ys", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P xs ys", "have \"length (rev xs) = length (rev ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rev xs) = length (rev ys)", "using assms(1)"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. length (rev xs) = length (rev ys)", "by simp"], ["proof (state)\nthis:\n  length (rev xs) = length (rev ys)\n\ngoal (1 subgoal):\n 1. P xs ys", "hence \"P (rev (rev xs)) (rev (rev ys))\""], ["proof (prove)\nusing this:\n  length (rev xs) = length (rev ys)\n\ngoal (1 subgoal):\n 1. P (rev (rev xs)) (rev (rev ys))", "using assms(2-3)"], ["proof (prove)\nusing this:\n  length (rev xs) = length (rev ys)\n  P [] []\n  \\<lbrakk>length ?xs = length ?ys; P ?xs ?ys\\<rbrakk>\n  \\<Longrightarrow> P (?xs @ [?x]) (?ys @ [?y])\n\ngoal (1 subgoal):\n 1. P (rev (rev xs)) (rev (rev ys))", "by (induction rule: list_induct2[of \"rev xs\" \"rev ys\"]) simp_all"], ["proof (state)\nthis:\n  P (rev (rev xs)) (rev (rev ys))\n\ngoal (1 subgoal):\n 1. P xs ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  P (rev (rev xs)) (rev (rev ys))\n\ngoal (1 subgoal):\n 1. P xs ys", "by simp"], ["proof (state)\nthis:\n  P xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alist_map_corr: \"distinct (map fst al) \\<Longrightarrow> (k,v) \\<in> set al \\<longleftrightarrow> map_of al k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst al) \\<Longrightarrow>\n    ((k, v) \\<in> set al) = (map_of al k = Some v)", "by simp"], ["", "lemma distinct_fst_imp_distinct: \"distinct (map fst l) \\<Longrightarrow> distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow> distinct l", "by (induction l) auto"], ["", "lemma length_alist:\n  assumes \"distinct (map fst al)\" and \"distinct (map fst al')\" and \"set al = set al'\"\n  shows \"length al = length al'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length al = length al'", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst al)\n  distinct (map fst al')\n  set al = set al'\n\ngoal (1 subgoal):\n 1. length al = length al'", "by (metis distinct_card length_map set_map)"], ["", "lemma same_map_of_imp_same_length: \n  \"distinct (map fst ars1) \\<Longrightarrow> distinct (map fst ars2) \\<Longrightarrow> map_of ars1 = map_of ars2\n  \\<Longrightarrow> length ars1 = length ars2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst ars1); distinct (map fst ars2);\n     map_of ars1 = map_of ars2\\<rbrakk>\n    \\<Longrightarrow> length ars1 = length ars2", "(* Name is a bit to specific*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst ars1); distinct (map fst ars2);\n     map_of ars1 = map_of ars2\\<rbrakk>\n    \\<Longrightarrow> length ars1 = length ars2", "using length_alist map_of_inject_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst ?al); distinct (map fst ?al');\n   set ?al = set ?al'\\<rbrakk>\n  \\<Longrightarrow> length ?al = length ?al'\n  \\<lbrakk>distinct (map fst ?xs); distinct (map fst ?ys)\\<rbrakk>\n  \\<Longrightarrow> (map_of ?xs = map_of ?ys) = (set ?xs = set ?ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst ars1); distinct (map fst ars2);\n     map_of ars1 = map_of ars2\\<rbrakk>\n    \\<Longrightarrow> length ars1 = length ars2", "by blast"], ["", "lemma in_range_if_ex_key: \"v \\<in> ran m \\<longleftrightarrow> (\\<exists>k. m k = Some v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<in> ran m) = (\\<exists>k. m k = Some v)", "by (auto simp add: ranI ran_def)"], ["", "lemma set_AList_delete_bound: \"set (AList.delete a l) \\<subseteq> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (AList.delete a l) \\<subseteq> set l", "by (induction l) auto"], ["", "lemma list_all_clearjunk_cons: \n  \"list_all P (x#(AList.clearjunk l)) \\<Longrightarrow> list_all P (AList.clearjunk (x#l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P (x # AList.clearjunk l) \\<Longrightarrow>\n    list_all P (AList.clearjunk (x # l))", "by (induction l rule: AList.clearjunk.induct) (auto simp add: delete_twist)"], ["", "lemma lookup_AList_delete: \"k'\\<noteq>k \\<Longrightarrow> lookup (\\<lambda>x. x = k) al = lookup (\\<lambda>x. x = k) (AList.delete k' al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' \\<noteq> k \\<Longrightarrow>\n    lookup (\\<lambda>x. x = k) al =\n    lookup (\\<lambda>x. x = k) (AList.delete k' al)", "by (induction al) auto"], ["", "lemma lookup_AList_clearjunk: \"lookup (\\<lambda>x. x = k) al = lookup (\\<lambda>x. x = k) (AList.clearjunk al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) al =\n    lookup (\\<lambda>x. x = k) (AList.clearjunk al)", "proof (induction al)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = k) [] =\n    lookup (\\<lambda>x. x = k) (AList.clearjunk [])\n 2. \\<And>a al.\n       lookup (\\<lambda>x. x = k) al =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk al) \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) (a # al) =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = k) [] =\n    lookup (\\<lambda>x. x = k) (AList.clearjunk [])\n 2. \\<And>a al.\n       lookup (\\<lambda>x. x = k) al =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk al) \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) (a # al) =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) [] =\n    lookup (\\<lambda>x. x = k) (AList.clearjunk [])", "by simp"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) [] =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk [])\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       lookup (\\<lambda>x. x = k) al =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk al) \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) (a # al) =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a al.\n       lookup (\\<lambda>x. x = k) al =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk al) \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) (a # al) =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "case (Cons a al)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) al =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk al)\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       lookup (\\<lambda>x. x = k) al =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk al) \\<Longrightarrow>\n       lookup (\\<lambda>x. x = k) (a # al) =\n       lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = k) al =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk al)", "show ?case"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = k) al =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk al)\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) (a # al) =\n    lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "proof(cases \"fst a=k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a = k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))\n 2. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "case True"], ["proof (state)\nthis:\n  fst a = k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a = k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))\n 2. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "then"], ["proof (chain)\npicking this:\n  fst a = k", "show ?thesis"], ["proof (prove)\nusing this:\n  fst a = k\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) (a # al) =\n    lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "by (metis (full_types) clearjunk.simps(2) lookup.simps(2) prod.collapse)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) (a # al) =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "case False"], ["proof (state)\nthis:\n  fst a \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "have \"lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al)) \n      = lookup (\\<lambda>x. x = k) (a # AList.clearjunk (AList.delete (fst a) al))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al)) =\n    lookup (\\<lambda>x. x = k)\n     (a # AList.clearjunk (AList.delete (fst a) al))", "by simp"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al)) =\n  lookup (\\<lambda>x. x = k) (a # AList.clearjunk (AList.delete (fst a) al))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "also"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al)) =\n  lookup (\\<lambda>x. x = k) (a # AList.clearjunk (AList.delete (fst a) al))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "have \"\\<dots> = lookup (\\<lambda>x. x = k) (AList.clearjunk (AList.delete (fst a) al))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k)\n     (a # AList.clearjunk (AList.delete (fst a) al)) =\n    lookup (\\<lambda>x. x = k) (AList.clearjunk (AList.delete (fst a) al))", "by (metis (full_types) False lookup.simps(2) surjective_pairing)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k)\n   (a # AList.clearjunk (AList.delete (fst a) al)) =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (AList.delete (fst a) al))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "also"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k)\n   (a # AList.clearjunk (AList.delete (fst a) al)) =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (AList.delete (fst a) al))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "have \"\\<dots> = lookup (\\<lambda>x. x = k) (AList.clearjunk al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) (AList.clearjunk (AList.delete (fst a) al)) =\n    lookup (\\<lambda>x. x = k) (AList.clearjunk al)", "by (metis False clearjunk_delete lookup_AList_delete)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (AList.delete (fst a) al)) =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk al)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "also"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (AList.delete (fst a) al)) =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk al)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "have \"\\<dots> = lookup (\\<lambda>x. x = k) al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) (AList.clearjunk al) =\n    lookup (\\<lambda>x. x = k) al", "using Cons.IH"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = k) al =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk al)\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) (AList.clearjunk al) =\n    lookup (\\<lambda>x. x = k) al", "by auto"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) (AList.clearjunk al) =\n  lookup (\\<lambda>x. x = k) al\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "also"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) (AList.clearjunk al) =\n  lookup (\\<lambda>x. x = k) al\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "have \"\\<dots> = lookup (\\<lambda>x. x = k) (a # al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) al = lookup (\\<lambda>x. x = k) (a # al)", "by (metis (full_types) False lookup.simps(2) surjective_pairing)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) al = lookup (\\<lambda>x. x = k) (a # al)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = k) al =\n             lookup (\\<lambda>x. x = k) (AList.clearjunk al);\n     fst a \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> lookup (\\<lambda>x. x = k) (a # al) =\n                      lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "finally"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al)) =\n  lookup (\\<lambda>x. x = k) (a # al)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al)) =\n  lookup (\\<lambda>x. x = k) (a # al)\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = k) (a # al) =\n    lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))", "by simp"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) (a # al) =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = k) (a # al) =\n  lookup (\\<lambda>x. x = k) (AList.clearjunk (a # al))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"diff_list xs ys \\<equiv> fold removeAll ys xs\""], ["", "lemma diff_list_set[simp]: \"set (diff_list xs ys) = set xs - set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (diff_list xs ys) = set xs - set ys", "unfolding diff_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold removeAll ys xs) = set xs - set ys", "by (induction ys arbitrary: xs) auto"], ["", "lemma diff_list_set_from_Nil[simp]: \"diff_list [] ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_list [] ys = []", "using last_in_set"], ["proof (prove)\nusing this:\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. diff_list [] ys = []", "by fastforce"], ["", "lemma diff_list_set_remove_Nil[simp]: \"diff_list xs [] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_list xs [] = xs", "unfolding diff_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold removeAll [] xs = xs", "by (induction xs) auto"], ["", "lemma diff_list_rec: \"diff_list (x # xs) ys = (if x\\<in>set ys then diff_list xs ys else x#diff_list xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diff_list (x # xs) ys =\n    (if x \\<in> set ys then diff_list xs ys else x # diff_list xs ys)", "unfolding diff_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold removeAll ys (x # xs) =\n    (if x \\<in> set ys then fold removeAll ys xs\n     else x # fold removeAll ys xs)", "by (induction ys arbitrary: x xs) auto"], ["", "lemma diff_list_order_irr: \"set ys = set ys' \\<Longrightarrow> diff_list xs ys = diff_list xs ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys = set ys' \\<Longrightarrow> diff_list xs ys = diff_list xs ys'", "proof (induction ys arbitrary: ys' xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys' xs.\n       set [] = set ys' \\<Longrightarrow> diff_list xs [] = diff_list xs ys'\n 2. \\<And>a ys ys' xs.\n       \\<lbrakk>\\<And>ys' xs.\n                   set ys = set ys' \\<Longrightarrow>\n                   diff_list xs ys = diff_list xs ys';\n        set (a # ys) = set ys'\\<rbrakk>\n       \\<Longrightarrow> diff_list xs (a # ys) = diff_list xs ys'", "case Nil"], ["proof (state)\nthis:\n  set [] = set ys'\n\ngoal (2 subgoals):\n 1. \\<And>ys' xs.\n       set [] = set ys' \\<Longrightarrow> diff_list xs [] = diff_list xs ys'\n 2. \\<And>a ys ys' xs.\n       \\<lbrakk>\\<And>ys' xs.\n                   set ys = set ys' \\<Longrightarrow>\n                   diff_list xs ys = diff_list xs ys';\n        set (a # ys) = set ys'\\<rbrakk>\n       \\<Longrightarrow> diff_list xs (a # ys) = diff_list xs ys'", "then"], ["proof (chain)\npicking this:\n  set [] = set ys'", "show ?case"], ["proof (prove)\nusing this:\n  set [] = set ys'\n\ngoal (1 subgoal):\n 1. diff_list xs [] = diff_list xs ys'", "by simp"], ["proof (state)\nthis:\n  diff_list xs [] = diff_list xs ys'\n\ngoal (1 subgoal):\n 1. \\<And>a ys ys' xs.\n       \\<lbrakk>\\<And>ys' xs.\n                   set ys = set ys' \\<Longrightarrow>\n                   diff_list xs ys = diff_list xs ys';\n        set (a # ys) = set ys'\\<rbrakk>\n       \\<Longrightarrow> diff_list xs (a # ys) = diff_list xs ys'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ys ys' xs.\n       \\<lbrakk>\\<And>ys' xs.\n                   set ys = set ys' \\<Longrightarrow>\n                   diff_list xs ys = diff_list xs ys';\n        set (a # ys) = set ys'\\<rbrakk>\n       \\<Longrightarrow> diff_list xs (a # ys) = diff_list xs ys'", "case (Cons y ys)"], ["proof (state)\nthis:\n  set ys = set ?ys' \\<Longrightarrow> diff_list ?xs ys = diff_list ?xs ?ys'\n  set (y # ys) = set ys'\n\ngoal (1 subgoal):\n 1. \\<And>a ys ys' xs.\n       \\<lbrakk>\\<And>ys' xs.\n                   set ys = set ys' \\<Longrightarrow>\n                   diff_list xs ys = diff_list xs ys';\n        set (a # ys) = set ys'\\<rbrakk>\n       \\<Longrightarrow> diff_list xs (a # ys) = diff_list xs ys'", "then"], ["proof (chain)\npicking this:\n  set ys = set ?ys' \\<Longrightarrow> diff_list ?xs ys = diff_list ?xs ?ys'\n  set (y # ys) = set ys'", "show ?case"], ["proof (prove)\nusing this:\n  set ys = set ?ys' \\<Longrightarrow> diff_list ?xs ys = diff_list ?xs ?ys'\n  set (y # ys) = set ys'\n\ngoal (1 subgoal):\n 1. diff_list xs (y # ys) = diff_list xs ys'", "by (induction xs arbitrary: y ys ys') (simp_all add: diff_list_rec)"], ["proof (state)\nthis:\n  diff_list xs (y # ys) = diff_list xs ys'\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Folding lists with option return typs. probably no longer relevant, was for implementing sorts by lists *)"], ["", "lemma fold_Option_bind_eq_Some_start_not_None:\n  \"fold (\\<lambda>new option . Option.bind option (f new)) list start = Some res\n  \\<Longrightarrow> start \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>new option. Option.bind option (f new)) list start =\n    Some res \\<Longrightarrow>\n    start \\<noteq> None", "by (induction list arbitrary: start res)\n    (fastforce split: option.splits if_splits simp add: bind_eq_Some_conv)+"], ["", "lemma fold_Option_bind_eq_Some_at_point_not_None:\n  \"fold (\\<lambda>new option . Option.bind option (f new)) (l1@l2) start = Some res\n  \\<Longrightarrow> fold (\\<lambda>new option . Option.bind option (f new)) (l1) start \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>new option. Option.bind option (f new)) (l1 @ l2) start =\n    Some res \\<Longrightarrow>\n    fold (\\<lambda>new option. Option.bind option (f new)) l1 start \\<noteq>\n    None", "by (induction l1 arbitrary: start res l2) (use fold_Option_bind_eq_Some_start_not_None in \n      \\<open>fastforce split: option.splits if_splits simp add: bind_eq_Some_conv\\<close>)+"], ["", "lemma fold_Option_bind_eq_Some_start_not_None':\n  \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) list start = Some res\n  \\<Longrightarrow> start \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y) option. Option.bind option (f x y)) list start =\n    Some res \\<Longrightarrow>\n    start \\<noteq> None", "proof (induction list arbitrary: start res)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>start res.\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) [] start =\n       Some res \\<Longrightarrow>\n       start \\<noteq> None\n 2. \\<And>a list start res.\n       \\<lbrakk>\\<And>start res.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    list start =\n                   Some res \\<Longrightarrow>\n                   start \\<noteq> None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # list)\n         start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> start \\<noteq> None", "case Nil"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   [] start =\n  Some res\n\ngoal (2 subgoals):\n 1. \\<And>start res.\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) [] start =\n       Some res \\<Longrightarrow>\n       start \\<noteq> None\n 2. \\<And>a list start res.\n       \\<lbrakk>\\<And>start res.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    list start =\n                   Some res \\<Longrightarrow>\n                   start \\<noteq> None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # list)\n         start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> start \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   [] start =\n  Some res", "show ?case"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   [] start =\n  Some res\n\ngoal (1 subgoal):\n 1. start \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  start \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>a list start res.\n       \\<lbrakk>\\<And>start res.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    list start =\n                   Some res \\<Longrightarrow>\n                   start \\<noteq> None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # list)\n         start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> start \\<noteq> None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list start res.\n       \\<lbrakk>\\<And>start res.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    list start =\n                   Some res \\<Longrightarrow>\n                   start \\<noteq> None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # list)\n         start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> start \\<noteq> None", "case (Cons a list)"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   list ?start =\n  Some ?res \\<Longrightarrow>\n  ?start \\<noteq> None\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (a # list) start =\n  Some res\n\ngoal (1 subgoal):\n 1. \\<And>a list start res.\n       \\<lbrakk>\\<And>start res.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    list start =\n                   Some res \\<Longrightarrow>\n                   start \\<noteq> None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # list)\n         start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> start \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   list ?start =\n  Some ?res \\<Longrightarrow>\n  ?start \\<noteq> None\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (a # list) start =\n  Some res", "show ?case"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   list ?start =\n  Some ?res \\<Longrightarrow>\n  ?start \\<noteq> None\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (a # list) start =\n  Some res\n\ngoal (1 subgoal):\n 1. start \\<noteq> None", "by (fastforce split: option.splits if_splits prod.splits simp add: bind_eq_Some_conv)"], ["proof (state)\nthis:\n  start \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_Option_bind_eq_None_start_None:\n  \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) list None = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y) option. Option.bind option (f x y)) list None =\n    None", "by (induction list) (auto split: option.splits if_splits prod.splits)"], ["", "lemma fold_Option_bind_at_some_point_None_eq_None:\n  \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) l1 start = None \\<Longrightarrow>\n  fold (\\<lambda>(x,y) option . Option.bind option (f x y)) (l1@l2) start = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y) option. Option.bind option (f x y)) l1 start =\n    None \\<Longrightarrow>\n    fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (l1 @ l2)\n     start =\n    None", "proof (induction l1 arbitrary: start  l2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>start l2.\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) [] start =\n       None \\<Longrightarrow>\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) ([] @ l2)\n        start =\n       None\n 2. \\<And>a l1 start l2.\n       \\<lbrakk>\\<And>start l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    l1 start =\n                   None \\<Longrightarrow>\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # l1)\n         start =\n        None\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>(x, y) option.\n                              Option.bind option (f x y))\n                          ((a # l1) @ l2) start =\n                         None", "case Nil"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   [] start =\n  None\n\ngoal (2 subgoals):\n 1. \\<And>start l2.\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) [] start =\n       None \\<Longrightarrow>\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) ([] @ l2)\n        start =\n       None\n 2. \\<And>a l1 start l2.\n       \\<lbrakk>\\<And>start l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    l1 start =\n                   None \\<Longrightarrow>\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # l1)\n         start =\n        None\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>(x, y) option.\n                              Option.bind option (f x y))\n                          ((a # l1) @ l2) start =\n                         None", "then"], ["proof (chain)\npicking this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   [] start =\n  None", "show ?case"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   [] start =\n  None\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>a.\n         case a of\n         (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n     ([] @ l2) start =\n    None", "using fold_Option_bind_eq_Some_start_not_None'"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   [] start =\n  None\n  fold (\\<lambda>(x, y) option. Option.bind option (?f x y)) ?list ?start =\n  Some ?res \\<Longrightarrow>\n  ?start \\<noteq> None\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>a.\n         case a of\n         (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n     ([] @ l2) start =\n    None", "by fastforce"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   ([] @ l2) start =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>a l1 start l2.\n       \\<lbrakk>\\<And>start l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    l1 start =\n                   None \\<Longrightarrow>\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # l1)\n         start =\n        None\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>(x, y) option.\n                              Option.bind option (f x y))\n                          ((a # l1) @ l2) start =\n                         None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l1 start l2.\n       \\<lbrakk>\\<And>start l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    l1 start =\n                   None \\<Longrightarrow>\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # l1)\n         start =\n        None\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>(x, y) option.\n                              Option.bind option (f x y))\n                          ((a # l1) @ l2) start =\n                         None", "case (Cons a l1)"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   l1 ?start =\n  None \\<Longrightarrow>\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (l1 @ ?l2.0) ?start =\n  None\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (a # l1) start =\n  None\n\ngoal (1 subgoal):\n 1. \\<And>a l1 start l2.\n       \\<lbrakk>\\<And>start l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    l1 start =\n                   None \\<Longrightarrow>\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   None;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (a # l1)\n         start =\n        None\\<rbrakk>\n       \\<Longrightarrow> fold\n                          (\\<lambda>(x, y) option.\n                              Option.bind option (f x y))\n                          ((a # l1) @ l2) start =\n                         None", "then"], ["proof (chain)\npicking this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   l1 ?start =\n  None \\<Longrightarrow>\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (l1 @ ?l2.0) ?start =\n  None\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (a # l1) start =\n  None", "show ?case"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   l1 ?start =\n  None \\<Longrightarrow>\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (l1 @ ?l2.0) ?start =\n  None\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (a # l1) start =\n  None\n\ngoal (1 subgoal):\n 1. fold\n     (\\<lambda>a.\n         case a of\n         (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n     ((a # l1) @ l2) start =\n    None", "by simp"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   ((a # l1) @ l2) start =\n  None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_Option_bind_eq_Some_at_each_point_Some:\n  \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) (l1@l2) start = Some res\n  \\<Longrightarrow> (\\<exists>point . fold (\\<lambda>(x,y) option . Option.bind option (f x y)) l1 start = Some point\n    \\<and> fold (\\<lambda>(x,y) option . Option.bind option (f x y)) l2 (Some point) = Some res)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (l1 @ l2)\n     start =\n    Some res \\<Longrightarrow>\n    \\<exists>point.\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) l1 start =\n       Some point \\<and>\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) l2\n        (Some point) =\n       Some res", "proof (induction l1 arbitrary: start res l2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>start res l2.\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) ([] @ l2)\n        start =\n       Some res \\<Longrightarrow>\n       \\<exists>point.\n          fold (\\<lambda>(x, y) option. Option.bind option (f x y)) []\n           start =\n          Some point \\<and>\n          fold (\\<lambda>(x, y) option. Option.bind option (f x y)) l2\n           (Some point) =\n          Some res\n 2. \\<And>a l1 start res l2.\n       \\<lbrakk>\\<And>start res l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   Some res \\<Longrightarrow>\n                   \\<exists>point.\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l1 start =\n                      Some point \\<and>\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l2 (Some point) =\n                      Some res;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n         ((a # l1) @ l2) start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>point.\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             (a # l1) start =\n                            Some point \\<and>\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             l2 (Some point) =\n                            Some res", "case Nil"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   ([] @ l2) start =\n  Some res\n\ngoal (2 subgoals):\n 1. \\<And>start res l2.\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) ([] @ l2)\n        start =\n       Some res \\<Longrightarrow>\n       \\<exists>point.\n          fold (\\<lambda>(x, y) option. Option.bind option (f x y)) []\n           start =\n          Some point \\<and>\n          fold (\\<lambda>(x, y) option. Option.bind option (f x y)) l2\n           (Some point) =\n          Some res\n 2. \\<And>a l1 start res l2.\n       \\<lbrakk>\\<And>start res l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   Some res \\<Longrightarrow>\n                   \\<exists>point.\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l1 start =\n                      Some point \\<and>\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l2 (Some point) =\n                      Some res;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n         ((a # l1) @ l2) start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>point.\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             (a # l1) start =\n                            Some point \\<and>\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             l2 (Some point) =\n                            Some res", "then"], ["proof (chain)\npicking this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   ([] @ l2) start =\n  Some res", "show ?case"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   ([] @ l2) start =\n  Some res\n\ngoal (1 subgoal):\n 1. \\<exists>point.\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              \\<lambda>option. Option.bind option (f x y))\n        [] start =\n       Some point \\<and>\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              \\<lambda>option. Option.bind option (f x y))\n        l2 (Some point) =\n       Some res", "using fold_Option_bind_eq_Some_start_not_None'"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   ([] @ l2) start =\n  Some res\n  fold (\\<lambda>(x, y) option. Option.bind option (?f x y)) ?list ?start =\n  Some ?res \\<Longrightarrow>\n  ?start \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>point.\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              \\<lambda>option. Option.bind option (f x y))\n        [] start =\n       Some point \\<and>\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              \\<lambda>option. Option.bind option (f x y))\n        l2 (Some point) =\n       Some res", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>point.\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      [] start =\n     Some point \\<and>\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      l2 (Some point) =\n     Some res\n\ngoal (1 subgoal):\n 1. \\<And>a l1 start res l2.\n       \\<lbrakk>\\<And>start res l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   Some res \\<Longrightarrow>\n                   \\<exists>point.\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l1 start =\n                      Some point \\<and>\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l2 (Some point) =\n                      Some res;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n         ((a # l1) @ l2) start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>point.\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             (a # l1) start =\n                            Some point \\<and>\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             l2 (Some point) =\n                            Some res", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l1 start res l2.\n       \\<lbrakk>\\<And>start res l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   Some res \\<Longrightarrow>\n                   \\<exists>point.\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l1 start =\n                      Some point \\<and>\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l2 (Some point) =\n                      Some res;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n         ((a # l1) @ l2) start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>point.\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             (a # l1) start =\n                            Some point \\<and>\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             l2 (Some point) =\n                            Some res", "case (Cons a l1)"], ["proof (state)\nthis:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (l1 @ ?l2.0) ?start =\n  Some ?res \\<Longrightarrow>\n  \\<exists>point.\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      l1 ?start =\n     Some point \\<and>\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      ?l2.0 (Some point) =\n     Some ?res\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   ((a # l1) @ l2) start =\n  Some res\n\ngoal (1 subgoal):\n 1. \\<And>a l1 start res l2.\n       \\<lbrakk>\\<And>start res l2.\n                   fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                    (l1 @ l2) start =\n                   Some res \\<Longrightarrow>\n                   \\<exists>point.\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l1 start =\n                      Some point \\<and>\n                      fold\n                       (\\<lambda>(x, y) option. Option.bind option (f x y))\n                       l2 (Some point) =\n                      Some res;\n        fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n         ((a # l1) @ l2) start =\n        Some res\\<rbrakk>\n       \\<Longrightarrow> \\<exists>point.\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             (a # l1) start =\n                            Some point \\<and>\n                            fold\n                             (\\<lambda>(x, y) option.\n                                 Option.bind option (f x y))\n                             l2 (Some point) =\n                            Some res", "then"], ["proof (chain)\npicking this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (l1 @ ?l2.0) ?start =\n  Some ?res \\<Longrightarrow>\n  \\<exists>point.\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      l1 ?start =\n     Some point \\<and>\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      ?l2.0 (Some point) =\n     Some ?res\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   ((a # l1) @ l2) start =\n  Some res", "show ?case"], ["proof (prove)\nusing this:\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   (l1 @ ?l2.0) ?start =\n  Some ?res \\<Longrightarrow>\n  \\<exists>point.\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      l1 ?start =\n     Some point \\<and>\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      ?l2.0 (Some point) =\n     Some ?res\n  fold\n   (\\<lambda>a.\n       case a of\n       (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n   ((a # l1) @ l2) start =\n  Some res\n\ngoal (1 subgoal):\n 1. \\<exists>point.\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              \\<lambda>option. Option.bind option (f x y))\n        (a # l1) start =\n       Some point \\<and>\n       fold\n        (\\<lambda>a.\n            case a of\n            (x, y) \\<Rightarrow>\n              \\<lambda>option. Option.bind option (f x y))\n        l2 (Some point) =\n       Some res", "by simp"], ["proof (state)\nthis:\n  \\<exists>point.\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      (a # l1) start =\n     Some point \\<and>\n     fold\n      (\\<lambda>a.\n          case a of\n          (x, y) \\<Rightarrow> \\<lambda>option. Option.bind option (f x y))\n      l2 (Some point) =\n     Some res\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_Option_bind_eq_Some_at_each_point_Some':\n  assumes \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) (xs@ys) start = Some res\"\n  obtains point where \n    \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) xs start = Some point\" and\n    \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) ys (Some point) = Some res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>point.\n        \\<lbrakk>fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                  xs start =\n                 Some point;\n         fold (\\<lambda>(x, y) option. Option.bind option (f x y)) ys\n          (Some point) =\n         Some res\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms fold_Option_bind_eq_Some_at_each_point_Some"], ["proof (prove)\nusing this:\n  fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (xs @ ys)\n   start =\n  Some res\n  fold (\\<lambda>(x, y) option. Option.bind option (?f x y)) (?l1.0 @ ?l2.0)\n   ?start =\n  Some ?res \\<Longrightarrow>\n  \\<exists>point.\n     fold (\\<lambda>(x, y) option. Option.bind option (?f x y)) ?l1.0\n      ?start =\n     Some point \\<and>\n     fold (\\<lambda>(x, y) option. Option.bind option (?f x y)) ?l2.0\n      (Some point) =\n     Some ?res\n\ngoal (1 subgoal):\n 1. (\\<And>point.\n        \\<lbrakk>fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                  xs start =\n                 Some point;\n         fold (\\<lambda>(x, y) option. Option.bind option (f x y)) ys\n          (Some point) =\n         Some res\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["", "(* Legacy *)"], ["", "corollary fold_Option_bind_eq_Some_at_point_not_None':\n  \"fold (\\<lambda>(x,y) option . Option.bind option (f x y)) (l1@l2) start = Some res\n  \\<Longrightarrow> fold (\\<lambda>(x,y) option . Option.bind option (f x y)) (l1) start \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (l1 @ l2)\n     start =\n    Some res \\<Longrightarrow>\n    fold (\\<lambda>(x, y) option. Option.bind option (f x y)) l1\n     start \\<noteq>\n    None", "using fold_Option_bind_eq_Some_at_each_point_Some"], ["proof (prove)\nusing this:\n  fold (\\<lambda>(x, y) option. Option.bind option (?f x y)) (?l1.0 @ ?l2.0)\n   ?start =\n  Some ?res \\<Longrightarrow>\n  \\<exists>point.\n     fold (\\<lambda>(x, y) option. Option.bind option (?f x y)) ?l1.0\n      ?start =\n     Some point \\<and>\n     fold (\\<lambda>(x, y) option. Option.bind option (?f x y)) ?l2.0\n      (Some point) =\n     Some ?res\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>(x, y) option. Option.bind option (f x y)) (l1 @ l2)\n     start =\n    Some res \\<Longrightarrow>\n    fold (\\<lambda>(x, y) option. Option.bind option (f x y)) l1\n     start \\<noteq>\n    None", "by fast"], ["", "(* Interestingly no longer need helper... *)"], ["", "lemma fold_matches_first_step_not_None:\n  assumes\n    \"fold (\\<lambda>(T, U) subs . Option.bind subs (f T U)) (zip (x#xs) (y#ys)) (Some subs) = Some subs'\" \n  obtains point where\n    \"f x y subs = Some point\"\n    \"fold (\\<lambda>(T, U) subs . Option.bind subs (f T U)) (zip (xs) (ys)) (Some point) = Some subs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>point.\n        \\<lbrakk>f x y subs = Some point;\n         fold (\\<lambda>(T, U) subs. Option.bind subs (f T U)) (zip xs ys)\n          (Some point) =\n         Some subs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms fold_Option_bind_eq_Some_start_not_None' not_None_eq"], ["proof (prove)\nusing this:\n  fold (\\<lambda>(T, U) subs. Option.bind subs (f T U))\n   (zip (x # xs) (y # ys)) (Some subs) =\n  Some subs'\n  fold (\\<lambda>(x, y) option. Option.bind option (?f x y)) ?list ?start =\n  Some ?res \\<Longrightarrow>\n  ?start \\<noteq> None\n  (?x \\<noteq> None) = (\\<exists>y. ?x = Some y)\n\ngoal (1 subgoal):\n 1. (\\<And>point.\n        \\<lbrakk>f x y subs = Some point;\n         fold (\\<lambda>(T, U) subs. Option.bind subs (f T U)) (zip xs ys)\n          (Some point) =\n         Some subs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["", "lemma fold_matches_last_step_not_None:\n  assumes\n    \"length xs = length ys\"\n    \"fold (\\<lambda>(T, U) subs . Option.bind subs (f T U)) (zip (xs@[x]) (ys@[y])) (Some subs) = Some subs'\" \n  obtains point where\n    \"fold (\\<lambda>(T, U) subs . Option.bind subs (f T U)) (zip (xs) (ys)) (Some subs) = Some point\"\n    \"f x y point = Some subs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>point.\n        \\<lbrakk>fold (\\<lambda>(T, U) subs. Option.bind subs (f T U))\n                  (zip xs ys) (Some subs) =\n                 Some point;\n         f x y point = Some subs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms fold_Option_bind_eq_Some_at_each_point_Some'[where xs=\"zip xs ys\" and ys=\"[(x,y)]\" \n      and start=\"Some subs\" and res=\"subs'\" and f=\"f\"]"], ["proof (prove)\nusing this:\n  length xs = length ys\n  fold (\\<lambda>(T, U) subs. Option.bind subs (f T U))\n   (zip (xs @ [x]) (ys @ [y])) (Some subs) =\n  Some subs'\n  \\<lbrakk>fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n            (zip xs ys @ [(x, y)]) (Some subs) =\n           Some subs';\n   \\<And>point.\n      \\<lbrakk>fold (\\<lambda>(x, y) option. Option.bind option (f x y))\n                (zip xs ys) (Some subs) =\n               Some point;\n       fold (\\<lambda>(x, y) option. Option.bind option (f x y)) [(x, y)]\n        (Some point) =\n       Some subs'\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>point.\n        \\<lbrakk>fold (\\<lambda>(T, U) subs. Option.bind subs (f T U))\n                  (zip xs ys) (Some subs) =\n                 Some point;\n         f x y point = Some subs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "end"]]}