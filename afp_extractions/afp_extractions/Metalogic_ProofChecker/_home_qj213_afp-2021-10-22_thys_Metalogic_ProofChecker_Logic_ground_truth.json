{"file_name": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker/Logic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Metalogic_ProofChecker", "problem_names": ["lemma inst_ok_imp_wf_inst: \n    \"inst_ok \\<Theta> insts \\<Longrightarrow> wf_inst \\<Theta> (\\<lambda>idn S .the_default (Tv idn S) (lookup (\\<lambda>x. x=(idn, S)) insts))\"", "lemma term_ok'_eta_norm: \"term_ok' \\<Sigma> t \\<Longrightarrow> term_ok' \\<Sigma> (eta_norm t)\"", "lemma \"beta_eta_norm t = Some t' \\<Longrightarrow> \\<not> eta_reducible t'\"", "lemma term_ok_beta_eta_norm: \"term_ok thy t \\<Longrightarrow> beta_eta_norm t = Some t' \\<Longrightarrow> term_ok thy t'\"", "lemma typ_of_beta_eta_norm:\n  \"typ_of t = Some T \\<Longrightarrow> beta_eta_norm t = Some t' \\<Longrightarrow> typ_of t' = Some T\"", "lemma inst_ok_nil[simp]: \"inst_ok \\<Theta> []\"", "lemma axiom_subst_typ': \n  assumes \"wf_theory \\<Theta>\" \"A\\<in>axioms \\<Theta>\" \"inst_ok \\<Theta> insts\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_typ' insts A\"", "lemma has_sort_Tv_refl: \"wf_osig oss \\<Longrightarrow> sort_ex (subclass oss) S \\<Longrightarrow> has_sort oss (Tv v S) S\"", "lemma has_sort_Tv_refl': \n  \"wf_theory \\<Theta> \\<Longrightarrow> typ_ok \\<Theta> (Tv v S) \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) (Tv v S) S\"", "lemma wf_inst_imp_inst_ok:\n    \"wf_theory \\<Theta> \\<Longrightarrow> distinct l \\<Longrightarrow> \\<forall>(v, S) \\<in> set l . typ_ok \\<Theta> (Tv v S) \\<Longrightarrow> wf_inst \\<Theta> \\<rho> \n  \\<Longrightarrow> inst_ok \\<Theta> (map (\\<lambda>(v, S) . ((v, S), \\<rho> v S)) l)\"", "lemma typs_of_fv_subset_Types: \"snd ` fv t \\<subseteq> Types t\"", "lemma osig_tvsT_subset_SortsT: \"snd ` tvsT T \\<subseteq> SortsT T\"", "lemma osig_tvs_subset_Sorts: \"snd ` tvs t \\<subseteq> Sorts t\"", "lemma term_ok_Types_imp_typ_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> \\<tau> \\<in> Types t \\<Longrightarrow> typ_ok_sig \\<Sigma> \\<tau>\"", "lemma term_ok_Types_typ_ok: \"wf_theory \\<Theta> \\<Longrightarrow> term_ok \\<Theta> t \\<Longrightarrow> \\<tau> \\<in> Types t \\<Longrightarrow> typ_ok \\<Theta> \\<tau>\"", "lemma term_ok_fv_imp_typ_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> (x,\\<tau>) \\<in> fv t \\<Longrightarrow> typ_ok_sig \\<Sigma> \\<tau>\"", "lemma term_ok_vars_typ_ok: \"wf_theory \\<Theta> \\<Longrightarrow> term_ok \\<Theta> t \\<Longrightarrow> (x, \\<tau>) \\<in> fv t \\<Longrightarrow> typ_ok \\<Theta> \\<tau>\"", "lemma typ_ok_TFreesT_imp_sort_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> typ_ok_sig \\<Sigma> T \\<Longrightarrow> (x, S) \\<in> tvsT T \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\"", "lemma term_ok_TFrees_imp_sort_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> (x, S) \\<in> tvs t \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\"", "lemma typ_ok_tvsT_imp_sort_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> typ_ok_sig \\<Sigma> T \\<Longrightarrow> (x,S) \\<in> tvsT T \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\"", "lemma term_ok_tvars_sort_ok:\n  assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> t\" \"(x, S) \\<in> tvs t\"\n  shows \"wf_sort (subclass (osig (sig \\<Theta>))) S\"", "lemma term_ok'_bind_fv2:\n  assumes \"term_ok' \\<Sigma> t\"\n  shows \"term_ok' \\<Sigma> (bind_fv2 (v,T) lev t)\"", "lemma term_ok'_bind_fv:\n  assumes \"term_ok' \\<Sigma> t\"\n  shows \"term_ok' \\<Sigma> (bind_fv (v,\\<tau>) t)\"", "lemma term_ok'_Abs_fv:\n  assumes \"term_ok' \\<Sigma> t\" \"typ_ok_sig \\<Sigma> \\<tau>\"\n  shows \"term_ok' \\<Sigma> (Abs \\<tau> (bind_fv (v,\\<tau>) t))\"", "lemma term_ok'_mk_all:\n  assumes \"wf_theory \\<Theta>\" and \"term_ok' (sig \\<Theta>) B\" and \"typ_of B = Some propT\" \n    and \"typ_ok \\<Theta> \\<tau>\"\n  shows \"term_ok' (sig \\<Theta>) (mk_all x \\<tau> B)\"", "lemma term_ok_mk_all:\n  assumes \"wf_theory \\<Theta>\" and \"term_ok' (sig \\<Theta>) B\" and \"typ_of B = Some propT\" and \"typ_ok \\<Theta> \\<tau>\"\n  shows \"term_ok \\<Theta> (mk_all x \\<tau> B)\"", "lemma term_ok'_incr_boundvars: \n  \"term_ok' (sig \\<Theta>) t \\<Longrightarrow> term_ok' (sig \\<Theta>) (incr_boundvars lev t)\"", "lemma term_ok'_subst_bv1:\n  assumes \"term_ok' (sig \\<Theta>) f\" and \"term_ok' (sig \\<Theta>) u\"\n  shows \"term_ok' (sig \\<Theta>) (subst_bv1 f lev u)\"", "lemma term_ok'_subst_bv:\n  assumes \"term_ok' (sig \\<Theta>) f\" and \"term_ok' (sig \\<Theta>) u\"\n  shows \"term_ok' (sig \\<Theta>) (subst_bv f u)\"", "lemma term_ok'_betapply:\n  assumes \"term_ok' (sig \\<Theta>) f\" \"term_ok' (sig \\<Theta>) u\"\n  shows \"term_ok' (sig \\<Theta>) (f \\<bullet> u)\"", "lemma term_ok_betapply:\n  assumes \"term_ok \\<Theta> f\" \"term_ok \\<Theta> u\" \n  assumes \"typ_of f = Some (uty \\<rightarrow> tty)\" \"typ_of u = Some uty\"\n  shows \"term_ok \\<Theta> (f \\<bullet> u)\"", "lemma typ_ok_sig_subst_typ:\n  assumes \"is_std_sig \\<Sigma>\" and \"typ_ok_sig \\<Sigma> ty\" and \"distinct (map fst insts)\" \n    and \"list_all (typ_ok_sig \\<Sigma>) (map snd insts)\"\n  shows \"typ_ok_sig \\<Sigma> (subst_typ insts ty)\"", "lemma tsubstT_trans: \"tsubstT ty \\<rho>1 = ty1 \\<Longrightarrow> tsubstT ty1 \\<rho>2 = ty2 \n  \\<Longrightarrow> tsubstT ty (\\<lambda>idx s . case \\<rho>1 idx s of Tv idx' s' \\<Rightarrow> \\<rho>2 idx' s' \n  | Ty s Ts \\<Rightarrow> Ty s (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)) = ty2\"", "lemma term_ok'_subst_typ':\n  assumes \"is_std_sig \\<Sigma>\" and \"term_ok' \\<Sigma> t\" and \"distinct (map fst insts)\" \n    and \"list_all (typ_ok_sig \\<Sigma>) (map snd insts)\"\n  shows \"term_ok' \\<Sigma> (subst_typ' insts t)\"", "lemma \n  term_ok'_occs:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> occs u t \\<Longrightarrow> term_ok' \\<Sigma> u\"", "lemma typ_of1_tsubst:\n  \"typ_of1 Ts t = Some ty \\<Longrightarrow> typ_of1 (map (\\<lambda>T . tsubstT T \\<rho>) Ts) (tsubst t \\<rho>) = Some (tsubstT ty \\<rho>)\"", "lemma tsubstT_no_change[simp]: \"tsubstT T Tv = T\"", "lemma term_ok_mk_eq_same_typ:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"term_ok \\<Theta> (mk_eq s t)\"\n  shows \"typ_of s = typ_of t\"", "lemma typ_of_eta_expand: \"typ_of f = Some (\\<tau> \\<rightarrow> \\<tau>') \\<Longrightarrow> typ_of (Abs \\<tau> (f $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\"", "lemma term_okI: \"term_ok' (sig \\<Theta>) t \\<Longrightarrow> typ_of t \\<noteq> None \\<Longrightarrow> term_ok \\<Theta> t\"", "lemma term_okD1: \"term_ok \\<Theta> t \\<Longrightarrow> term_ok' (sig \\<Theta>) t\"", "lemma term_okD2: \"term_ok \\<Theta> t \\<Longrightarrow> typ_of t \\<noteq> None\"", "lemma term_ok_imp_typ_ok': assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> t\" shows \"typ_ok \\<Theta> (the (typ_of t))\"", "lemma term_ok_mk_eqI:\n  assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> s\" \"term_ok \\<Theta> t\" \"typ_of s = typ_of t\" \n  shows\"term_ok \\<Theta> (mk_eq s t)\"", "lemma typ_of1_decr': \"\\<not> loose_bvar1 t 0 \\<Longrightarrow> typ_of1 (T#Ts) t = Some \\<tau> \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some \\<tau>\"", "lemma typ_of1_eta_red_step_pre: \"\\<not> loose_bvar1 t 0 \\<Longrightarrow> \n  typ_of1 Ts (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>') \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\"", "lemma typ_of1_eta_red_step: \"\\<not> is_dependent t \\<Longrightarrow> \n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>') \\<Longrightarrow> typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\"", "lemma distinct_add_vars': \"distinct acc \\<Longrightarrow> distinct (add_vars' t acc)\"", "lemma distinct_add_tvarsT': \"distinct acc \\<Longrightarrow> distinct (add_tvarsT' T acc)\"", "lemma distinct_add_tvars': \"distinct acc \\<Longrightarrow> distinct (add_tvars' t acc)\"", "lemma proved_terms_well_formed_pre: \"\\<Theta>, \\<Gamma> \\<turnstile> p \\<Longrightarrow> typ_of p = Some propT \\<and> term_ok \\<Theta> p\"", "lemma forall_intros: \n  \"wf_theory \\<Theta> \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> B \\<Longrightarrow> \\<forall>(x, \\<tau>)\\<in>set frees . (x,\\<tau>) \\<notin> FV \\<Gamma> \\<and> typ_ok \\<Theta> \\<tau> \n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> mk_all_list frees B\"", "lemma term_ok_var[simp]: \"term_ok \\<Theta> (Fv idn \\<tau>) = typ_ok \\<Theta> \\<tau>\"", "lemma typ_of_var[simp]: \"typ_of (Fv idn \\<tau>) = Some \\<tau>\"", "lemma is_closed_Fv[simp]: \"is_closed (Fv idn \\<tau>)\"", "lemma not_loose_bvar_bind_fv2: \n  \"\\<not> loose_bvar t lev \\<Longrightarrow> \\<not> loose_bvar (bind_fv2 v lev t) (Suc lev)\"", "lemma not_loose_bvar_bind_fv2_: \n  \"\\<not> loose_bvar (bind_fv2 v lev t) lev \\<Longrightarrow> \\<not> loose_bvar t lev\"", "lemma fold_add_vars'_FV_pre: \"set (fold add_vars' Hs acc) = set acc \\<union> FV (set Hs)\"", "lemma forall_intro_vars:\n  assumes \"wf_theory \\<Theta>\" \"\\<Theta>, set Hs \\<turnstile> B\" \n  shows \"\\<Theta>, set Hs \\<turnstile> forall_intro_vars B Hs\"", "lemma mk_all_list'_preserves_term_ok_typ_of:\n  assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> B\" \"typ_of B = Some propT\" \"\\<forall>(idn,ty)\\<in>set vs . typ_ok \\<Theta> ty\"\n  shows \"term_ok \\<Theta> (mk_all_list vs B) \\<and> typ_of (mk_all_list vs B) = Some propT\"", "lemma bind_fv_remove_var_from_fv: \"fv (bind_fv (idn, \\<tau>) t) = fv t - {(idn, \\<tau>)}\"", "lemma forall_intro_vars_remove_fv[simp]: \"fv (forall_intro_vars t []) = {}\"", "lemma term_ok_mk_all_list:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"term_ok \\<Theta> B\" \n  assumes \"typ_of B = Some propT\"\n  assumes \"\\<forall>(idn, \\<tau>) \\<in> set l . typ_ok \\<Theta> \\<tau>\"\n  shows \"term_ok \\<Theta> (mk_all_list l B) \\<and> typ_of (mk_all_list l B) = Some propT\"", "lemma tvs_bind_fv2: \"tvs (bind_fv2 (v, T) lev t) \\<union> tvsT T = tvs t \\<union> tvsT T\"", "lemma tvs_bind_fv: \"tvs (bind_fv (v,T) t) \\<union> tvsT T = tvs t \\<union> tvsT T\"", "lemma tvs_mk_all': \"tvs (mk_all idn ty B) = tvs B \\<union> tvsT ty\"", "lemma tvs_mk_all_list: \n  \"tvs (mk_all_list vs B) = tvs B \\<union> tvsT_Set (snd ` set vs)\"", "lemma tvs_occs: \"occs v t \\<Longrightarrow> tvs v \\<subseteq> tvs t\"", "lemma tvs_forall_intro_vars: \"tvs (forall_intro_vars B Hs) = tvs B\"", "lemma \"strip_all_single_var B = Some \\<tau> \\<Longrightarrow> strip_all_single_body B \\<noteq> B\"", "lemma strip_all_body_unchanged_iff_strip_all_single_body_unchanged: \n  \"strip_all_body B = B \\<longleftrightarrow> strip_all_single_body B = B\"", "lemma strip_all_body_unchanged_imp_strip_all_vars_no: \n  assumes \"strip_all_body B = B\"\n  shows \"strip_all_vars B = []\"", "lemma strip_all_body_unchanged_imp_strip_all_single_body_unchanged: \n  \"strip_all_body B = B \\<Longrightarrow> strip_all_single_body B = B\"", "lemma strip_all_single_body_unchanged_imp_strip_all_body_unchanged: \n  \"strip_all_single_body B = B \\<Longrightarrow> strip_all_body B = B\"", "lemma strip_all_single_var_np_imp_strip_all_body_single_unchanged: \n  \"strip_all_single_var B = None \\<Longrightarrow> strip_all_single_body B = B\"", "lemma strip_all_single_form: \"strip_all_single_var B = Some \\<tau>\n  \\<Longrightarrow> Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $ Abs \\<tau> (strip_all_single_body B) = B\"", "lemma proves_strip_all_single:\n  assumes \"\\<Theta>, \\<Gamma> \\<turnstile> B\" \"strip_all_single_var B = Some \\<tau>\"\n    \"typ_of t = Some \\<tau>\" \"term_ok \\<Theta> t\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_bv t (strip_all_single_body B)\"", "lemma strip_all_vars_no_strip_all_body_unchanged[simp]: \n  \"strip_all_vars B = [] \\<Longrightarrow> strip_all_body B = B\"", "lemma \"strip_all_vars B = (\\<tau>s@[\\<tau>]) \\<Longrightarrow> strip_all_body B \n  = strip_all_single_body (Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $ Abs \\<tau> (strip_all_body B))\"", "lemma strip_all_vars_incr_bv: \"strip_all_vars (incr_bv inc lev t) = strip_all_vars t\"", "lemma strip_all_vars_incr_boundvars: \"strip_all_vars (incr_boundvars inc t) = strip_all_vars t\"", "lemma strip_all_vars_subst_bv1_Fv:\n  \"strip_all_vars (subst_bv1 B lev (Fv x \\<tau>)) = strip_all_vars B\"", "lemma strip_all_vars_subst_bv_Fv:\n  \"strip_all_vars (subst_bv (Fv x \\<tau>) B) = strip_all_vars B\"", "lemma \"strip_all_single_var B = Some \\<tau>\n  \\<Longrightarrow> strip_all_vars (subst_bv (Fv x \\<tau>) (strip_all_single_body B)) = tl (strip_all_vars B)\"", "lemma trivial_pre_depr: \"term_ok \\<Theta> c \\<Longrightarrow> typ_of c = Some propT \\<Longrightarrow> \\<Theta>, {c} \\<turnstile> c\"", "lemma trivial_pre:\n  assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> c\" \"typ_of c = Some propT\"\n  shows \"\\<Theta>, {} \\<turnstile> c \\<longmapsto> c\"", "lemma inst_var: \n  assumes wf_theory: \"wf_theory \\<Theta>\"\n  assumes B: \"\\<Theta>, \\<Gamma> \\<turnstile> B\"\n  assumes a_ok: \"term_ok \\<Theta> a\" \n  assumes typ_a: \"typ_of a = Some \\<tau>\"\n  assumes free: \"(x,\\<tau>) \\<notin> FV \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B\"", "lemma subst_term_single_no_change[simp]:\n  assumes nvar: \"(x,\\<tau>)\\<notin>fv B\"\n  shows \"subst_term [((x,\\<tau>), t)] B = B\"", "lemma fv_subst_term_single:\n  assumes var: \"(x,\\<tau>)\\<in>fv B\"\n  assumes \"\\<And>p . p \\<in> fv t \\<Longrightarrow> p ~= (x,\\<tau>)\"\n  shows \"fv (subst_term [((x,\\<tau>), t)] B) = fv B - {(x,\\<tau>)} \\<union> fv t\"", "lemma inst_vars_pre: \n  assumes wf_theory: \"wf_theory \\<Theta>\"\n  assumes B: \"\\<Theta>, \\<Gamma> \\<turnstile> B\"\n  (*assumes vars: \"set (map fst insts) \\<subseteq> fv B\"*)\n  assumes vars_ok: \"list_all (term_ok \\<Theta>) (map snd insts)\"\n  assumes typs_ok: \"list_all (\\<lambda>((idx, ty), t) . typ_of t = Some ty) insts\"\n  assumes free: \"list_all (\\<lambda>((idx, ty), t) . (idx, ty) \\<notin> FV \\<Gamma>) insts\"\n  assumes typ_a: \"typ_of a = Some \\<tau>\"\n  assumes distinct: \"distinct (map fst insts)\"\n  assumes no_overlap: \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` (set insts) . fv t) \\<Longrightarrow> x \\<notin> fst ` (set insts)\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single]) insts B\"", "lemma subterm_term_ok': \n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> is_closed st \\<Longrightarrow> occs st t \\<Longrightarrow> term_ok' \\<Sigma> st\"", "lemma infinite_fv_UNIV: \"infinite (UNIV :: (indexname \\<times> typ) set)\"", "lemma implies_intro'_pre:\n  assumes \"wf_theory \\<Theta>\" \"\\<Theta>, \\<Gamma> \\<turnstile> B\" \"term_ok \\<Theta> A\" \"typ_of A = Some propT\" \"A \\<notin> \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> A \\<longmapsto> B\"", "lemma implies_intro'_pre2:\n  assumes \"wf_theory \\<Theta>\" \"\\<Theta>, \\<Gamma> \\<turnstile> B\" \"term_ok \\<Theta> A\" \"typ_of A = Some propT\" \"A \\<in> \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> A \\<longmapsto> B\"", "lemma subst_term_preserves_typ_of1[simp]: \n  \"typ_of1 Ts (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) = typ_of1 Ts t\"", "lemma subst_term_preserves_typ_of[simp]:\n  \"typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) = typ_of t\"", "lemma subst_term_preserves_term_ok'[simp]: \n  \"term_ok' \\<Sigma> (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) \\<longleftrightarrow> term_ok' \\<Sigma> t\"", "lemma subst_term_preserves_term_ok[simp]:\n  \"term_ok \\<Theta> (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) \\<longleftrightarrow> term_ok \\<Theta> A\"", "lemma not_in_FV_in_fv_not_in: \"(x,\\<tau>) \\<notin> FV \\<Gamma> \\<Longrightarrow> (x,\\<tau>) \\<in> fv t \\<Longrightarrow> t \\<notin> \\<Gamma>\"", "lemma subst_term_fv: \"fv (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) \n  = (if (x,\\<tau>) \\<in> fv t then insert (y,\\<tau>) else id) (fv t - {(x,\\<tau>)})\"", "lemma rename_free: \n  assumes wf_theory: \"wf_theory \\<Theta>\"\n  assumes B: \"\\<Theta>, \\<Gamma> \\<turnstile> B\"\n  assumes free: \"(x,\\<tau>)\\<notin> FV \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), Fv y \\<tau>)] B\"", "lemma tvs_subst_term_single[simp]: \"tvs (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = tvs A\"", "lemma weaken_proves': \"\\<Theta>, \\<Gamma> \\<turnstile> B \\<Longrightarrow> term_ok \\<Theta> A \\<Longrightarrow> typ_of A = Some propT \\<Longrightarrow> A \\<notin> \\<Gamma>\n  \\<Longrightarrow> finite \\<Gamma> \n  \\<Longrightarrow> \\<Theta>, insert A \\<Gamma> \\<turnstile> B\"", "lemma weaken_proves_set: \"finite \\<Gamma>2 \\<Longrightarrow> \\<Theta>, \\<Gamma> \\<turnstile> B \\<Longrightarrow> \\<forall>A\\<in>\\<Gamma>2 . term_ok \\<Theta> A \\<Longrightarrow> \\<forall>A\\<in>\\<Gamma>2 . typ_of A = Some propT\n  \\<Longrightarrow> finite \\<Gamma>\n  \\<Longrightarrow> \\<Theta>, \\<Gamma> \\<union> \\<Gamma>2 \\<turnstile> B\"", "lemma no_tvsT_imp_subst_typ_unchanged: \"tvsT T = empty \\<Longrightarrow> subst_typ insts T = T\"", "lemma subst_typ_fv:\n  shows \"apsnd (subst_typ insts) ` fv B = fv (subst_typ' insts B)\"", "lemma subst_typ_fv_point:\n  assumes \"(x, \\<tau>) \\<in> fv B\" \n  shows \"(x, subst_typ insts \\<tau>) \\<in> fv (subst_typ' insts B)\"", "lemma subst_typ_typ_ok:\n  assumes \"typ_ok_sig \\<Sigma> \\<tau>\"\n  assumes \"list_all (typ_ok_sig \\<Sigma>) (map snd insts)\"\n  shows \"typ_ok_sig \\<Sigma> (subst_typ insts \\<tau>)\"", "lemma subst_typ_comp_single_left: \"subst_typ [single] (subst_typ insts T) \n  = subst_typ (map (apsnd (subst_typ [single])) insts@[single]) T\"", "lemma subst_typ_comp_single_left_stronger: \"subst_typ [single] (subst_typ insts T) \n  = subst_typ (map (apsnd (subst_typ [single])) insts\n  @ (if fst single \\<in> set (map fst insts) then [] else [single])) T\"", "lemma subst_typ'_comp_single_left: \"subst_typ' [single] (subst_typ' insts t)\n  = subst_typ' (map (apsnd (subst_typ [single])) insts@[single]) t\"", "lemma subst_typ'_comp_single_left_stronger: \"subst_typ' [single] (subst_typ' insts t)\n  = subst_typ' (map (apsnd (subst_typ [single])) insts\n  @ (if fst single \\<in> set (map fst insts) then [] else [single])) t\"", "lemma subst_typ_preserves_typ_ok:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"typ_ok \\<Theta> T\"\n  assumes \"list_all (typ_ok \\<Theta>) (map snd insts)\"\n  shows \"typ_ok \\<Theta> (subst_typ insts T)\"", "lemma typ_ok_Ty[simp]: \"typ_ok \\<Theta> (Ty n Ts) \\<Longrightarrow> list_all (typ_ok \\<Theta>) Ts\"", "lemma typ_ok_sig_Ty[simp]: \"typ_ok_sig \\<Sigma> (Ty n Ts) \\<Longrightarrow> list_all (typ_ok_sig \\<Sigma>) Ts\"", "lemma wf_theory_imp_wf_osig: \"wf_theory \\<Theta> \\<Longrightarrow> wf_osig (osig (sig \\<Theta>))\"", "lemma the_lift2_option_Somes[simp]: \"the (lift2_option f (Some a) (Some b)) = f a b\"", "lemma class_les_mgd:\n  assumes \"wf_osig oss\" \n  assumes \"tcsigs oss type = Some mgd\"\n  assumes \"mgd C' = Some Ss'\"\n  assumes \"class_les (subclass oss) C' C\"\n  shows \"mgd C \\<noteq> None\"", "lemma has_sort_sort_leq_osig:\n  assumes \"wf_osig (sub, tcs)\" \"has_sort (sub,tcs) T S\" \"sort_leq sub S S'\"\n  shows \"has_sort (sub,tcs) T S'\"", "lemma has_sort_sort_leq: \"wf_theory \\<Theta> \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) T S \n  \\<Longrightarrow> sort_leq (subclass (osig (sig \\<Theta>))) S S'\n  \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) T S'\"", "lemma subst_typ_preserves_has_sort:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"has_sort (osig (sig \\<Theta>)) T S\"\n  assumes \"list_all (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S) insts\"\n  shows \"has_sort (osig (sig \\<Theta>)) (subst_typ insts T) S\"", "lemma subst_typ_preserves_Some_typ_of1:\n  assumes \"typ_of1 Ts t = Some T\"\n  shows \"typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) \n      = Some (subst_typ insts T)\"", "lemma subst_typ'_incr_bv: \n  \"subst_typ' insts (incr_bv inc lev t) = incr_bv inc lev (subst_typ' insts t)\"", "lemma subst_typ'_incr_boundvars:\n  \"subst_typ' insts (incr_boundvars lev t) = incr_boundvars lev (subst_typ' insts t)\"", "lemma subst_typ'_subst_bv1: \"subst_typ' insts (subst_bv1 t n u) \n  = subst_bv1 (subst_typ' insts t) n (subst_typ' insts u)\"", "lemma subst_typ'_subst_bv: \"subst_typ' insts (subst_bv t u) \n  = subst_bv (subst_typ' insts t) (subst_typ' insts u)\"", "lemma subst_typ_no_tvsT_unchanged:\n  \"\\<forall>(f, s) \\<in> set insts . f \\<notin> tvsT T \\<Longrightarrow> subst_typ insts T = T\"", "lemma subst_typ'_no_tvs_unchanged:\n  \"\\<forall>(f, s) \\<in> set insts . f \\<notin> tvs t \\<Longrightarrow> subst_typ' insts t = t\"", "lemma subst_typ'_preserves_term_ok':\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"inst_ok \\<Theta> insts\"\n  assumes \"term_ok' (sig \\<Theta>) t\"\n  shows \"term_ok' (sig \\<Theta>) (subst_typ' insts t)\"", "lemma subst_typ'_preserves_term_ok:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"inst_ok \\<Theta> insts\"\n  assumes \"term_ok \\<Theta> t\"\n  shows \"term_ok \\<Theta> (subst_typ' insts t)\"", "lemma subst_typ_rename_vars_cancel:\n  assumes \"y \\<notin> fst ` tvsT T\" \n  shows \"subst_typ [((y,S), Tv x S)] (subst_typ [((x,S), Tv y S)] T) = T\"", "lemma subst_typ'_rename_tvars_cancel:\n  assumes \"y \\<notin> fst ` tvs t\" assumes \"y \\<notin> fst ` tvsT \\<tau>\" \n  shows \"subst_typ' [((y,S), Tv x S)] ((bind_fv2 (x, subst_typ [((x,S), Tv y S)] \\<tau>)) \n    lev (subst_typ' [((x,S), Tv y S)] t))\n  = bind_fv2 (x, \\<tau>) lev t\"", "lemma bind_fv2_renamed_var:\n  assumes \"y \\<notin> fst ` fv t\" \n  shows \"bind_fv2 (y, \\<tau>) i (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) \n    = bind_fv2 (x, \\<tau>) i t\"", "lemma bind_fv_renamed_var:\n  assumes \"y \\<notin> fst ` fv t\" \n  shows \"bind_fv (y, \\<tau>) (subst_term [((x, \\<tau>), Fv y \\<tau>)] t)\n    = bind_fv (x, \\<tau>) t\"", "lemma subst_typ'_rename_tvar_bind_fv2:\n  assumes \"y \\<notin> fst ` fv t\" \n  assumes \"(b, S) \\<notin> tvs t\"\n  assumes \"(b, S) \\<notin> tvsT \\<tau>\"\n  shows \"bind_fv2 (y, subst_typ [((a, S), Tv b S)] \\<tau>) i \n  (subst_typ' [((a,S), Tv b S)] (subst_term [((x, \\<tau>), Fv y \\<tau>)] t))\n    = subst_typ' [((a,S), Tv b S)] (bind_fv2 (x, \\<tau>) i t)\"", "lemma subst_typ'_rename_tvar_bind_fv:\n  assumes \"y \\<notin> fst ` fv t\" \n  assumes \"(b, S) \\<notin> tvs t\"\n  assumes \"(b, S) \\<notin> tvsT \\<tau>\"\n  shows \"bind_fv (y, subst_typ [((a,S), Tv b S)] \\<tau>) \n  (subst_typ' [((a,S), Tv b S)] (subst_term [((x, \\<tau>), Fv y \\<tau>)] t))\n    = subst_typ' [((a,S), Tv b S)] (bind_fv (x, \\<tau>) t)\"", "lemma tvar_in_fv_in_tvs: \"(a, \\<tau>) \\<in> fv B \\<Longrightarrow> (x, S) \\<in> tvsT \\<tau> \\<Longrightarrow> (x, S) \\<in> tvs B\"", "lemma tvs_bind_fv2_subset: \"tvs (bind_fv2 (a, \\<tau>) i B) \\<subseteq> tvs B\"", "lemma tvs_bind_fv_subset: \"tvs (bind_fv (a, \\<tau>) B) \\<subseteq> tvs B\"", "lemma subst_typ_rename_tvar_preserves_eq:\n  \"(y, S) \\<notin> tvsT T \\<Longrightarrow> (y, S) \\<notin> tvsT \\<tau> \\<Longrightarrow>\n    subst_typ [((x, S), Tv y S)] T = subst_typ [((x, S), Tv y S)] \\<tau> \\<Longrightarrow> T=\\<tau>\"", "lemma subst_typ'_subst_term_rename_var_swap:\n  assumes \"b \\<notin> fst ` fv B\"\n  assumes \"(y, S) \\<notin> tvs B\"\n  assumes \"(y, S) \\<notin> tvsT \\<tau>\"\n  shows \"subst_typ' [((x, S), Tv y S)] (subst_term [((a, \\<tau>), Fv b \\<tau>)] B)\n    = subst_term [((a, (subst_typ [((x, S), Tv y S)] \\<tau>)), Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))] \n      (subst_typ' [((x, S), Tv y S)] B)\"", "lemma tvar_not_in_term_imp_free_not_in_term:\n  \"(y, S) \\<in> tvsT \\<tau> \\<Longrightarrow> (y,S) \\<notin> tvs t \\<Longrightarrow> (a, \\<tau>) \\<notin> fv t\"", "lemma tvar_not_in_term_imp_free_not_in_term_set:\n  \"finite \\<Gamma> \\<Longrightarrow> (y, S) \\<in> tvsT \\<tau> \\<Longrightarrow> (y,S) \\<notin> tvs_Set \\<Gamma> \\<Longrightarrow> (a, \\<tau>) \\<notin> FV \\<Gamma>\"", "lemma inst_var_multiple: \n  assumes wf_theory: \"wf_theory \\<Theta>\"\n  assumes B: \"\\<Theta>, \\<Gamma> \\<turnstile> B\"\n  assumes vars: \"\\<forall>(x,\\<tau>)\\<in>fst ` set insts . term_ok \\<Theta> (Fv x \\<tau>)\"\n  assumes a_ok: \"\\<forall>a\\<in>snd ` set insts . term_ok \\<Theta> a\" \n  assumes typ_a: \"\\<forall>((_,\\<tau>), a)\\<in>set insts . typ_of a = Some \\<tau>\"\n  assumes free: \"\\<forall>(v, _)\\<in>set insts . v \\<notin> FV \\<Gamma>\"\n  assumes distinct: \"distinct (map fst insts)\"\n  assumes finite: \"finite \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_term insts B\"", "lemma term_ok_eta_red_step: \n  \"\\<not> is_dependent t \\<Longrightarrow> term_ok \\<Theta> (Abs T (t $ Bv 0)) \\<Longrightarrow> term_ok \\<Theta> (decr 0 t)\""], "translations": [["", "lemma inst_ok_imp_wf_inst: \n    \"inst_ok \\<Theta> insts \\<Longrightarrow> wf_inst \\<Theta> (\\<lambda>idn S .the_default (Tv idn S) (lookup (\\<lambda>x. x=(idn, S)) insts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst_ok \\<Theta> insts \\<Longrightarrow>\n    wf_inst \\<Theta>\n     (\\<lambda>idn S.\n         the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))", "by (induction insts) (auto split: if_splits prod.splits)"], ["", "lemma term_ok'_eta_norm: \"term_ok' \\<Sigma> t \\<Longrightarrow> term_ok' \\<Sigma> (eta_norm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> t \\<Longrightarrow> term_ok' \\<Sigma> (eta_norm t)", "by (induction t rule: eta_norm.induct)\n    (auto split: term.splits nat.splits simp add: term_ok'_decr is_dependent_def)"], ["", "corollary term_ok_eta_norm: \"term_ok thy t \\<Longrightarrow> term_ok thy (eta_norm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok thy t \\<Longrightarrow> term_ok thy (eta_norm t)", "using wt_term_def typ_of_eta_norm term_ok'_eta_norm"], ["proof (prove)\nusing this:\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  typ_of ?t = Some ?ty \\<Longrightarrow> typ_of (eta_norm ?t) = Some ?ty\n  term_ok' ?\\<Sigma> ?t \\<Longrightarrow> term_ok' ?\\<Sigma> (eta_norm ?t)\n\ngoal (1 subgoal):\n 1. term_ok thy t \\<Longrightarrow> term_ok thy (eta_norm t)", "by auto"], ["", "abbreviation \"beta_eta_norm t \\<equiv> map_option eta_norm (beta_norm t)\""], ["", "lemma \"beta_eta_norm t = Some t' \\<Longrightarrow> \\<not> eta_reducible t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beta_eta_norm t = Some t' \\<Longrightarrow> \\<not> eta_reducible t'", "using not_eta_reducible_eta_norm"], ["proof (prove)\nusing this:\n  \\<not> eta_reducible (eta_norm ?t)\n\ngoal (1 subgoal):\n 1. beta_eta_norm t = Some t' \\<Longrightarrow> \\<not> eta_reducible t'", "by auto"], ["", "lemma term_ok_beta_eta_norm: \"term_ok thy t \\<Longrightarrow> beta_eta_norm t = Some t' \\<Longrightarrow> term_ok thy t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>term_ok thy t; beta_eta_norm t = Some t'\\<rbrakk>\n    \\<Longrightarrow> term_ok thy t'", "using term_ok_eta_norm term_ok_beta_norm"], ["proof (prove)\nusing this:\n  term_ok ?thy ?t \\<Longrightarrow> term_ok ?thy (eta_norm ?t)\n  \\<lbrakk>term_ok ?thy ?t; beta_norm ?t = Some ?t'\\<rbrakk>\n  \\<Longrightarrow> term_ok ?thy ?t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>term_ok thy t; beta_eta_norm t = Some t'\\<rbrakk>\n    \\<Longrightarrow> term_ok thy t'", "by blast"], ["", "lemma typ_of_beta_eta_norm:\n  \"typ_of t = Some T \\<Longrightarrow> beta_eta_norm t = Some t' \\<Longrightarrow> typ_of t' = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typ_of t = Some T; beta_eta_norm t = Some t'\\<rbrakk>\n    \\<Longrightarrow> typ_of t' = Some T", "using beta_norm_imp_beta_reds beta_star_preserves_typ_of1 typ_of1_eta_norm typ_of_def"], ["proof (prove)\nusing this:\n  beta_norm ?t = Some ?t' \\<Longrightarrow>\n  ?t \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?t'\n  \\<lbrakk>?r \\<rightarrow>\\<^sub>\\<beta>\\<^sup>* ?s;\n   typ_of1 ?Ts ?r = Some ?T\\<rbrakk>\n  \\<Longrightarrow> typ_of1 ?Ts ?s = Some ?T\n  typ_of1 ?Ts ?t = Some ?ty \\<Longrightarrow>\n  typ_of1 ?Ts (eta_norm ?t) = Some ?ty\n  typ_of ?t \\<equiv> typ_of1 [] ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>typ_of t = Some T; beta_eta_norm t = Some t'\\<rbrakk>\n    \\<Longrightarrow> typ_of t' = Some T", "by fastforce"], ["", "lemma inst_ok_nil[simp]: \"inst_ok \\<Theta> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst_ok \\<Theta> []", "by simp"], ["", "lemma axiom_subst_typ': \n  assumes \"wf_theory \\<Theta>\" \"A\\<in>axioms \\<Theta>\" \"inst_ok \\<Theta> insts\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_typ' insts A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' insts A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' insts A", "have \"wf_inst \\<Theta> (\\<lambda>idn S . the_default (Tv idn S) (lookup (\\<lambda>x. x=(idn, S)) insts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_inst \\<Theta>\n     (\\<lambda>idn S.\n         the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))", "using inst_ok_imp_wf_inst assms(3)"], ["proof (prove)\nusing this:\n  inst_ok ?\\<Theta> ?insts \\<Longrightarrow>\n  wf_inst ?\\<Theta>\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) ?insts))\n  inst_ok \\<Theta> insts\n\ngoal (1 subgoal):\n 1. wf_inst \\<Theta>\n     (\\<lambda>idn S.\n         the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))", "by blast"], ["proof (state)\nthis:\n  wf_inst \\<Theta>\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' insts A", "moreover"], ["proof (state)\nthis:\n  wf_inst \\<Theta>\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' insts A", "have \"subst_typ' insts A\n    = tsubst A (\\<lambda>idn S . the_default (Tv idn S) (lookup (\\<lambda>x. x=(idn, S)) insts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' insts A =\n    tsubst A\n     (\\<lambda>idn S.\n         the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))", "by (simp add: tsubst_simulates_subst_typ')"], ["proof (state)\nthis:\n  subst_typ' insts A =\n  tsubst A\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' insts A", "ultimately"], ["proof (chain)\npicking this:\n  wf_inst \\<Theta>\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))\n  subst_typ' insts A =\n  tsubst A\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_inst \\<Theta>\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))\n  subst_typ' insts A =\n  tsubst A\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' insts A", "using assms axiom"], ["proof (prove)\nusing this:\n  wf_inst \\<Theta>\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))\n  subst_typ' insts A =\n  tsubst A\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) insts))\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  inst_ok \\<Theta> insts\n  \\<lbrakk>wf_theory ?\\<Theta>; ?A \\<in> axioms ?\\<Theta>;\n   wf_inst ?\\<Theta> ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> tsubst ?A ?\\<rho>\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' insts A", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' insts A\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary axiom': \"wf_theory \\<Theta> \\<Longrightarrow> A \\<in> axioms \\<Theta> \\<Longrightarrow> \\<Theta>, \\<Gamma> \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> A", "apply (subst subst_typ'_nil[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' [] A", "using axiom_subst_typ' inst_ok_nil"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_theory ?\\<Theta>; ?A \\<in> axioms ?\\<Theta>;\n   inst_ok ?\\<Theta> ?insts\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_typ' ?insts ?A\n  inst_ok ?\\<Theta> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> subst_typ' [] A", "by metis"], ["", "lemma has_sort_Tv_refl: \"wf_osig oss \\<Longrightarrow> sort_ex (subclass oss) S \\<Longrightarrow> has_sort oss (Tv v S) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_osig oss; sort_ex (subclass oss) S\\<rbrakk>\n    \\<Longrightarrow> has_sort oss (Tv v S) S", "by (cases oss) (simp add: osig_subclass_loc wf_subclass_loc.intro has_sort_Tv wf_subclass_loc.sort_leq_refl)"], ["", "lemma has_sort_Tv_refl': \n  \"wf_theory \\<Theta> \\<Longrightarrow> typ_ok \\<Theta> (Tv v S) \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) (Tv v S) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv v S)\\<rbrakk>\n    \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) (Tv v S) S", "using has_sort_Tv_refl"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_osig ?oss; sort_ex (subclass ?oss) ?S\\<rbrakk>\n  \\<Longrightarrow> has_sort ?oss (Tv ?v ?S) ?S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv v S)\\<rbrakk>\n    \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) (Tv v S) S", "by (metis wf_sig.simps osig.elims wf_theory_imp_wf_sig typ_ok_def\n      wf_type_imp_typ_ok_sig typ_ok_sig.simps(2) wf_sort_def)"], ["", "lemma wf_inst_imp_inst_ok:\n    \"wf_theory \\<Theta> \\<Longrightarrow> distinct l \\<Longrightarrow> \\<forall>(v, S) \\<in> set l . typ_ok \\<Theta> (Tv v S) \\<Longrightarrow> wf_inst \\<Theta> \\<rho> \n  \\<Longrightarrow> inst_ok \\<Theta> (map (\\<lambda>(v, S) . ((v, S), \\<rho> v S)) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; distinct l;\n     \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n     wf_inst \\<Theta> \\<rho>\\<rbrakk>\n    \\<Longrightarrow> inst_ok \\<Theta>\n                       (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)", "proof (induction l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; distinct [];\n     \\<forall>(v, S)\\<in>set []. typ_ok \\<Theta> (Tv v S);\n     wf_inst \\<Theta> \\<rho>\\<rbrakk>\n    \\<Longrightarrow> inst_ok \\<Theta>\n                       (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "case Nil"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  distinct []\n  \\<forall>a\\<in>set [].\n     case a of (v, S) \\<Rightarrow> typ_ok \\<Theta> (Tv v S)\n  wf_inst \\<Theta> \\<rho>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; distinct [];\n     \\<forall>(v, S)\\<in>set []. typ_ok \\<Theta> (Tv v S);\n     wf_inst \\<Theta> \\<rho>\\<rbrakk>\n    \\<Longrightarrow> inst_ok \\<Theta>\n                       (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  distinct []\n  \\<forall>a\\<in>set [].\n     case a of (v, S) \\<Rightarrow> typ_ok \\<Theta> (Tv v S)\n  wf_inst \\<Theta> \\<rho>", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  distinct []\n  \\<forall>a\\<in>set [].\n     case a of (v, S) \\<Rightarrow> typ_ok \\<Theta> (Tv v S)\n  wf_inst \\<Theta> \\<rho>\n\ngoal (1 subgoal):\n 1. inst_ok \\<Theta>\n     (map (\\<lambda>a. case a of (v, S) \\<Rightarrow> ((v, S), \\<rho> v S))\n       [])", "by simp"], ["proof (state)\nthis:\n  inst_ok \\<Theta>\n   (map (\\<lambda>a. case a of (v, S) \\<Rightarrow> ((v, S), \\<rho> v S))\n     [])\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "case (Cons a l)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_theory \\<Theta>; distinct l;\n   \\<forall>a\\<in>set l.\n      case a of (v, S) \\<Rightarrow> typ_ok \\<Theta> (Tv v S);\n   wf_inst \\<Theta> \\<rho>\\<rbrakk>\n  \\<Longrightarrow> inst_ok \\<Theta>\n                     (map (\\<lambda>a.\n                              case a of\n                              (v, S) \\<Rightarrow> ((v, S), \\<rho> v S))\n                       l)\n  wf_theory \\<Theta>\n  distinct (a # l)\n  \\<forall>a\\<in>set (a # l).\n     case a of (v, S) \\<Rightarrow> typ_ok \\<Theta> (Tv v S)\n  wf_inst \\<Theta> \\<rho>\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "have I: \"inst_ok \\<Theta> (map (\\<lambda>(v,S) . ((v, S), \\<rho> v S)) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inst_ok \\<Theta> (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)", "using Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_theory \\<Theta>; distinct l;\n   \\<forall>a\\<in>set l.\n      case a of (v, S) \\<Rightarrow> typ_ok \\<Theta> (Tv v S);\n   wf_inst \\<Theta> \\<rho>\\<rbrakk>\n  \\<Longrightarrow> inst_ok \\<Theta>\n                     (map (\\<lambda>a.\n                              case a of\n                              (v, S) \\<Rightarrow> ((v, S), \\<rho> v S))\n                       l)\n  wf_theory \\<Theta>\n  distinct (a # l)\n  \\<forall>a\\<in>set (a # l).\n     case a of (v, S) \\<Rightarrow> typ_ok \\<Theta> (Tv v S)\n  wf_inst \\<Theta> \\<rho>\n\ngoal (1 subgoal):\n 1. inst_ok \\<Theta> (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)", "by fastforce"], ["proof (state)\nthis:\n  inst_ok \\<Theta> (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "have \"a \\<notin> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<notin> set l", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  distinct (a # l)\n\ngoal (1 subgoal):\n 1. a \\<notin> set l", "by auto"], ["proof (state)\nthis:\n  a \\<notin> set l\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "hence \"(a, case_prod \\<rho> a) \\<notin> set (map (\\<lambda>(v,S) . ((v, S), \\<rho> v S)) l)\""], ["proof (prove)\nusing this:\n  a \\<notin> set l\n\ngoal (1 subgoal):\n 1. (a, case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n    \\<notin> set (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)", "by (simp add: image_iff prod.case_eq_if)"], ["proof (state)\nthis:\n  (a, case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  \\<notin> set (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "moreover"], ["proof (state)\nthis:\n  (a, case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  \\<notin> set (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "have \"distinct (map (\\<lambda>(v,S) . ((v, S), \\<rho> v S)) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)", "using I distinct_kv_list distinct_map"], ["proof (prove)\nusing this:\n  inst_ok \\<Theta> (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)\n  distinct ?l \\<Longrightarrow> distinct (map (\\<lambda>x. (x, ?f x)) ?l)\n  distinct (map ?f ?xs) = (distinct ?xs \\<and> inj_on ?f (set ?xs))\n\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)", "by fast"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "ultimately"], ["proof (chain)\npicking this:\n  (a, case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  \\<notin> set (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)\n  distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)", "have \"distinct (map (\\<lambda>(v,S) . ((v, S), \\<rho> v S)) (a#l))\""], ["proof (prove)\nusing this:\n  (a, case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  \\<notin> set (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)\n  distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)\n\ngoal (1 subgoal):\n 1. distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (a # l))", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (a # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "moreover"], ["proof (state)\nthis:\n  distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (a # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "have \"wf_type (sig \\<Theta>) (case_prod \\<rho> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_type (sig \\<Theta>) (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)", "using Cons.prems(3-4)"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (a # l).\n     case a of (v, S) \\<Rightarrow> typ_ok \\<Theta> (Tv v S)\n  wf_inst \\<Theta> \\<rho>\n\ngoal (1 subgoal):\n 1. wf_type (sig \\<Theta>) (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)", "by auto (metis typ_ok_Tv wf_type_imp_typ_ok_sig)"], ["proof (state)\nthis:\n  wf_type (sig \\<Theta>) (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "moreover"], ["proof (state)\nthis:\n  wf_type (sig \\<Theta>) (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "hence \"typ_ok \\<Theta> (case_prod \\<rho> a)\""], ["proof (prove)\nusing this:\n  wf_type (sig \\<Theta>) (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)", "by simp"], ["proof (state)\nthis:\n  typ_ok \\<Theta> (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "moreover"], ["proof (state)\nthis:\n  typ_ok \\<Theta> (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "hence \"has_sort (osig (sig \\<Theta>)) (case_prod \\<rho> a) (snd a)\""], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>))\n     (case a of (x, xa) \\<Rightarrow> \\<rho> x xa) (snd a)", "using Cons.prems"], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  wf_theory \\<Theta>\n  distinct (a # l)\n  \\<forall>a\\<in>set (a # l).\n     case a of (v, S) \\<Rightarrow> typ_ok \\<Theta> (Tv v S)\n  wf_inst \\<Theta> \\<rho>\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>))\n     (case a of (x, xa) \\<Rightarrow> \\<rho> x xa) (snd a)", "by (metis (full_types) has_sort_Tv_refl' prod.case_eq_if wf_inst_def)"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>))\n   (case a of (x, xa) \\<Rightarrow> \\<rho> x xa) (snd a)\n\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; distinct l;\n                 \\<forall>(v, S)\\<in>set l. typ_ok \\<Theta> (Tv v S);\n                 wf_inst \\<Theta> \\<rho>\\<rbrakk>\n                \\<Longrightarrow> inst_ok \\<Theta>\n                                   (map (\\<lambda>(v, S).\n      ((v, S), \\<rho> v S))\n                                     l);\n        wf_theory \\<Theta>; distinct (a # l);\n        \\<forall>(v, S)\\<in>set (a # l). typ_ok \\<Theta> (Tv v S);\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> inst_ok \\<Theta>\n                          (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                            (a # l))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (a # l))\n  wf_type (sig \\<Theta>) (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  typ_ok \\<Theta> (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  has_sort (osig (sig \\<Theta>))\n   (case a of (x, xa) \\<Rightarrow> \\<rho> x xa) (snd a)", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (a # l))\n  wf_type (sig \\<Theta>) (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  typ_ok \\<Theta> (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  has_sort (osig (sig \\<Theta>))\n   (case a of (x, xa) \\<Rightarrow> \\<rho> x xa) (snd a)\n\ngoal (1 subgoal):\n 1. inst_ok \\<Theta>\n     (map (\\<lambda>a. case a of (v, S) \\<Rightarrow> ((v, S), \\<rho> v S))\n       (a # l))", "using I"], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (a # l))\n  wf_type (sig \\<Theta>) (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  typ_ok \\<Theta> (case a of (x, xa) \\<Rightarrow> \\<rho> x xa)\n  has_sort (osig (sig \\<Theta>))\n   (case a of (x, xa) \\<Rightarrow> \\<rho> x xa) (snd a)\n  inst_ok \\<Theta> (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) l)\n\ngoal (1 subgoal):\n 1. inst_ok \\<Theta>\n     (map (\\<lambda>a. case a of (v, S) \\<Rightarrow> ((v, S), \\<rho> v S))\n       (a # l))", "by (auto simp del: typ_ok_def split: prod.splits)"], ["proof (state)\nthis:\n  inst_ok \\<Theta>\n   (map (\\<lambda>a. case a of (v, S) \\<Rightarrow> ((v, S), \\<rho> v S))\n     (a # l))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* MOVE to term, also use for transfering proofs *)"], ["", "lemma typs_of_fv_subset_Types: \"snd ` fv t \\<subseteq> Types t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` fv t \\<subseteq> Types t", "by (induction t) auto"], ["", "lemma osig_tvsT_subset_SortsT: \"snd ` tvsT T \\<subseteq> SortsT T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` tvsT T \\<subseteq> SortsT T", "by (induction T) auto"], ["", "lemma osig_tvs_subset_Sorts: \"snd ` tvs t \\<subseteq> Sorts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` tvs t \\<subseteq> Sorts t", "by (induction t) (use osig_tvsT_subset_SortsT in \\<open>auto simp add: image_subset_iff\\<close>)"], ["", "lemma term_ok_Types_imp_typ_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> \\<tau> \\<in> Types t \\<Longrightarrow> typ_ok_sig \\<Sigma> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n     \\<tau> \\<in> Types t\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> \\<tau>", "by (induction t arbitrary: \\<tau>) (auto split: option.splits)"], ["", "lemma term_ok_Types_typ_ok: \"wf_theory \\<Theta> \\<Longrightarrow> term_ok \\<Theta> t \\<Longrightarrow> \\<tau> \\<in> Types t \\<Longrightarrow> typ_ok \\<Theta> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> t;\n     \\<tau> \\<in> Types t\\<rbrakk>\n    \\<Longrightarrow> typ_ok \\<Theta> \\<tau>", "by (cases \\<Theta> rule: theory_full_exhaust) (fastforce simp add: wt_term_def \n      intro: term_ok_Types_imp_typ_ok_pre)"], ["", "lemma term_ok_fv_imp_typ_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> (x,\\<tau>) \\<in> fv t \\<Longrightarrow> typ_ok_sig \\<Sigma> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n     (x, \\<tau>) \\<in> fv t\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> \\<tau>", "using typs_of_fv_subset_Types term_ok_Types_imp_typ_ok_pre"], ["proof (prove)\nusing this:\n  snd ` fv ?t \\<subseteq> Types ?t\n  \\<lbrakk>is_std_sig ?\\<Sigma>; term_ok' ?\\<Sigma> ?t;\n   ?\\<tau> \\<in> Types ?t\\<rbrakk>\n  \\<Longrightarrow> typ_ok_sig ?\\<Sigma> ?\\<tau>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n     (x, \\<tau>) \\<in> fv t\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> \\<tau>", "by (metis image_subset_iff snd_conv)"], ["", "lemma term_ok_vars_typ_ok: \"wf_theory \\<Theta> \\<Longrightarrow> term_ok \\<Theta> t \\<Longrightarrow> (x, \\<tau>) \\<in> fv t \\<Longrightarrow> typ_ok \\<Theta> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> t;\n     (x, \\<tau>) \\<in> fv t\\<rbrakk>\n    \\<Longrightarrow> typ_ok \\<Theta> \\<tau>", "using term_ok_Types_typ_ok typs_of_fv_subset_Types"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok ?\\<Theta> ?t;\n   ?\\<tau> \\<in> Types ?t\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?\\<Theta> ?\\<tau>\n  snd ` fv ?t \\<subseteq> Types ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> t;\n     (x, \\<tau>) \\<in> fv t\\<rbrakk>\n    \\<Longrightarrow> typ_ok \\<Theta> \\<tau>", "by (metis image_subset_iff snd_conv)"], ["", "lemma typ_ok_TFreesT_imp_sort_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> typ_ok_sig \\<Sigma> T \\<Longrightarrow> (x, S) \\<in> tvsT T \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> T;\n     (x, S) \\<in> tvsT T\\<rbrakk>\n    \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x2a; (x, S) \\<in> tvsT x2a\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty x1 x2);\n        (x, S) \\<in> tvsT (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>x1 x2.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv x1 x2);\n        (x, S) \\<in> tvsT (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> ?x2a;\n   (x, S) \\<in> tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Ty n Ts)\n  (x, S) \\<in> tvsT (Ty n Ts)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x2a; (x, S) \\<in> tvsT x2a\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty x1 x2);\n        (x, S) \\<in> tvsT (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>x1 x2.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv x1 x2);\n        (x, S) \\<in> tvsT (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts; is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> ?x2a;\n   (x, S) \\<in> tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Ty n Ts)\n  (x, S) \\<in> tvsT (Ty n Ts)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts; is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> ?x2a;\n   (x, S) \\<in> tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Ty n Ts)\n  (x, S) \\<in> tvsT (Ty n Ts)\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig \\<Sigma>)) S", "by (induction Ts) (fastforce dest: split_list split: option.split_asm)+"], ["proof (state)\nthis:\n  wf_sort (subclass (osig \\<Sigma>)) S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv x1 x2);\n        (x, S) \\<in> tvsT (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "qed (auto simp add: wf_sort_def)"], ["", "lemma term_ok_TFrees_imp_sort_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> (x, S) \\<in> tvs t \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n     (x, S) \\<in> tvs t\\<rbrakk>\n    \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "proof (induction t arbitrary: S)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Ct x1 x2);\n        (x, S) \\<in> tvs (Ct x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        (x, S) \\<in> tvs (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 3. \\<And>xa S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv xa);\n        (x, S) \\<in> tvs (Bv xa)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 4. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 5. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "case (Ct n T)"], ["proof (state)\nthis:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Ct n T)\n  (x, S) \\<in> tvs (Ct n T)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Ct x1 x2);\n        (x, S) \\<in> tvs (Ct x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        (x, S) \\<in> tvs (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 3. \\<And>xa S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv xa);\n        (x, S) \\<in> tvs (Bv xa)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 4. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 5. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "then"], ["proof (chain)\npicking this:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Ct n T)\n  (x, S) \\<in> tvs (Ct n T)", "show ?case"], ["proof (prove)\nusing this:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Ct n T)\n  (x, S) \\<in> tvs (Ct n T)\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig \\<Sigma>)) S", "apply (clarsimp split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>(x, S) \\<in> tvsT T; is_std_sig \\<Sigma>;\n        const_type \\<Sigma> n = Some x2; typ_ok_sig \\<Sigma> T;\n        tinstT T x2\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "by (use typ_ok_TFreesT_imp_sort_ok_pre wf_sort_def in auto)"], ["proof (state)\nthis:\n  wf_sort (subclass (osig \\<Sigma>)) S\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        (x, S) \\<in> tvs (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>xa S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv xa);\n        (x, S) \\<in> tvs (Bv xa)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 3. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 4. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        (x, S) \\<in> tvs (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>xa S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv xa);\n        (x, S) \\<in> tvs (Bv xa)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 3. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 4. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "case (Fv n T)"], ["proof (state)\nthis:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Fv n T)\n  (x, S) \\<in> tvs (Fv n T)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        (x, S) \\<in> tvs (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>xa S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv xa);\n        (x, S) \\<in> tvs (Bv xa)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 3. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 4. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "then"], ["proof (chain)\npicking this:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Fv n T)\n  (x, S) \\<in> tvs (Fv n T)", "show ?case"], ["proof (prove)\nusing this:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Fv n T)\n  (x, S) \\<in> tvs (Fv n T)\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig \\<Sigma>)) S", "apply (clarsimp split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> T;\n     (x, S) \\<in> tvsT T\\<rbrakk>\n    \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "by (use typ_ok_TFreesT_imp_sort_ok_pre wf_sort_def in auto)"], ["proof (state)\nthis:\n  wf_sort (subclass (osig \\<Sigma>)) S\n\ngoal (3 subgoals):\n 1. \\<And>xa S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv xa);\n        (x, S) \\<in> tvs (Bv xa)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 3. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv xa);\n        (x, S) \\<in> tvs (Bv xa)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 3. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "case (Bv n)"], ["proof (state)\nthis:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Bv n)\n  (x, S) \\<in> tvs (Bv n)\n\ngoal (3 subgoals):\n 1. \\<And>xa S.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv xa);\n        (x, S) \\<in> tvs (Bv xa)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 3. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "then"], ["proof (chain)\npicking this:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Bv n)\n  (x, S) \\<in> tvs (Bv n)", "show ?case"], ["proof (prove)\nusing this:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Bv n)\n  (x, S) \\<in> tvs (Bv n)\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig \\<Sigma>)) S", "by (clarsimp split: option.splits)"], ["proof (state)\nthis:\n  wf_sort (subclass (osig \\<Sigma>)) S\n\ngoal (2 subgoals):\n 1. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "case (Abs T t)"], ["proof (state)\nthis:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n   (x, ?S) \\<in> tvs t\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) ?S\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Abs T t)\n  (x, S) \\<in> tvs (Abs T t)\n\ngoal (2 subgoals):\n 1. \\<And>x1 t S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    (x, S) \\<in> tvs t\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t);\n        (x, S) \\<in> tvs (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n   (x, ?S) \\<in> tvs t\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) ?S\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Abs T t)\n  (x, S) \\<in> tvs (Abs T t)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n   (x, ?S) \\<in> tvs t\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) ?S\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Abs T t)\n  (x, S) \\<in> tvs (Abs T t)\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig \\<Sigma>)) S", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>S.\n                (x, S) \\<in> tvs t \\<Longrightarrow>\n                wf_sort (subclass (osig \\<Sigma>)) S;\n     is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> T \\<and> term_ok' \\<Sigma> t;\n     (x, S) \\<in> tvsT T \\<or> (x, S) \\<in> tvs t\\<rbrakk>\n    \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "using typ_ok_TFreesT_imp_sort_ok_pre wf_sort_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_std_sig ?\\<Sigma>; typ_ok_sig ?\\<Sigma> ?T;\n   (?x, ?S) \\<in> tvsT ?T\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig ?\\<Sigma>)) ?S\n  wf_sort ?sub ?S = (normalized_sort ?sub ?S \\<and> sort_ex ?sub ?S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>S.\n                (x, S) \\<in> tvs t \\<Longrightarrow>\n                wf_sort (subclass (osig \\<Sigma>)) S;\n     is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> T \\<and> term_ok' \\<Sigma> t;\n     (x, S) \\<in> tvsT T \\<or> (x, S) \\<in> tvs t\\<rbrakk>\n    \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "by meson"], ["proof (state)\nthis:\n  wf_sort (subclass (osig \\<Sigma>)) S\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "case (App t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n   (x, ?S) \\<in> tvs t1\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) ?S\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n   (x, ?S) \\<in> tvs t2\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) ?S\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (t1 $ t2)\n  (x, S) \\<in> tvs (t1 $ t2)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2 S.\n       \\<lbrakk>\\<And>S.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    (x, S) \\<in> tvs t1\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        \\<And>S.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n            (x, S) \\<in> tvs t2\\<rbrakk>\n           \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2);\n        (x, S) \\<in> tvs (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n   (x, ?S) \\<in> tvs t1\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) ?S\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n   (x, ?S) \\<in> tvs t2\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) ?S\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (t1 $ t2)\n  (x, S) \\<in> tvs (t1 $ t2)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n   (x, ?S) \\<in> tvs t1\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) ?S\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2;\n   (x, ?S) \\<in> tvs t2\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) ?S\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (t1 $ t2)\n  (x, S) \\<in> tvs (t1 $ t2)\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig \\<Sigma>)) S", "by auto"], ["proof (state)\nthis:\n  wf_sort (subclass (osig \\<Sigma>)) S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typ_ok_tvsT_imp_sort_ok_pre:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> typ_ok_sig \\<Sigma> T \\<Longrightarrow> (x,S) \\<in> tvsT T \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> T;\n     (x, S) \\<in> tvsT T\\<rbrakk>\n    \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x2a; (x, S) \\<in> tvsT x2a\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty x1 x2);\n        (x, S) \\<in> tvsT (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>x1 x2.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv x1 x2);\n        (x, S) \\<in> tvsT (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> ?x2a;\n   (x, S) \\<in> tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Ty n Ts)\n  (x, S) \\<in> tvsT (Ty n Ts)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x2a; (x, S) \\<in> tvsT x2a\\<rbrakk>\n                   \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S;\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty x1 x2);\n        (x, S) \\<in> tvsT (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n 2. \\<And>x1 x2.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv x1 x2);\n        (x, S) \\<in> tvsT (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts; is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> ?x2a;\n   (x, S) \\<in> tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Ty n Ts)\n  (x, S) \\<in> tvsT (Ty n Ts)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts; is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> ?x2a;\n   (x, S) \\<in> tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Ty n Ts)\n  (x, S) \\<in> tvsT (Ty n Ts)\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig \\<Sigma>)) S", "by (induction Ts) (fastforce dest: split_list split: option.split_asm)+"], ["proof (state)\nthis:\n  wf_sort (subclass (osig \\<Sigma>)) S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv x1 x2);\n        (x, S) \\<in> tvsT (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> wf_sort (subclass (osig \\<Sigma>)) S", "qed (auto simp add: wf_sort_def)"], ["", "lemma term_ok_tvars_sort_ok:\n  assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> t\" \"(x, S) \\<in> tvs t\"\n  shows \"wf_sort (subclass (osig (sig \\<Theta>))) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig (sig \\<Theta>))) S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig (sig \\<Theta>))) S", "have \"term_ok' (sig \\<Theta>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) t", "using assms(2)"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> t\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) t", "by (simp add: wt_term_def)"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) t\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig (sig \\<Theta>))) S", "moreover"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) t\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig (sig \\<Theta>))) S", "have \"is_std_sig (sig \\<Theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_std_sig (sig \\<Theta>)", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> t\n  (x, S) \\<in> tvs t\n\ngoal (1 subgoal):\n 1. is_std_sig (sig \\<Theta>)", "by (cases \\<Theta> rule: theory_full_exhaust) simp"], ["proof (state)\nthis:\n  is_std_sig (sig \\<Theta>)\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig (sig \\<Theta>))) S", "ultimately"], ["proof (chain)\npicking this:\n  term_ok' (sig \\<Theta>) t\n  is_std_sig (sig \\<Theta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) t\n  is_std_sig (sig \\<Theta>)\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig (sig \\<Theta>))) S", "using assms(3) term_ok_TFrees_imp_sort_ok_pre"], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) t\n  is_std_sig (sig \\<Theta>)\n  (x, S) \\<in> tvs t\n  \\<lbrakk>is_std_sig ?\\<Sigma>; term_ok' ?\\<Sigma> ?t;\n   (?x, ?S) \\<in> tvs ?t\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig ?\\<Sigma>)) ?S\n\ngoal (1 subgoal):\n 1. wf_sort (subclass (osig (sig \\<Theta>))) S", "by simp"], ["proof (state)\nthis:\n  wf_sort (subclass (osig (sig \\<Theta>))) S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma term_ok'_bind_fv2:\n  assumes \"term_ok' \\<Sigma> t\"\n  shows \"term_ok' \\<Sigma> (bind_fv2 (v,T) lev t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> (bind_fv2 (v, T) lev t)", "using assms"], ["proof (prove)\nusing this:\n  term_ok' \\<Sigma> t\n\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> (bind_fv2 (v, T) lev t)", "by (induction \"(v,T)\" lev t rule: bind_fv2.induct) auto"], ["", "lemma term_ok'_bind_fv:\n  assumes \"term_ok' \\<Sigma> t\"\n  shows \"term_ok' \\<Sigma> (bind_fv (v,\\<tau>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> (bind_fv (v, \\<tau>) t)", "using term_ok'_bind_fv2 bind_fv_def assms"], ["proof (prove)\nusing this:\n  term_ok' ?\\<Sigma> ?t \\<Longrightarrow>\n  term_ok' ?\\<Sigma> (bind_fv2 (?v, ?T) ?lev ?t)\n  bind_fv ?vT ?t = bind_fv2 ?vT 0 ?t\n  term_ok' \\<Sigma> t\n\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> (bind_fv (v, \\<tau>) t)", "by metis"], ["", "lemma term_ok'_Abs_fv:\n  assumes \"term_ok' \\<Sigma> t\" \"typ_ok_sig \\<Sigma> \\<tau>\"\n  shows \"term_ok' \\<Sigma> (Abs \\<tau> (bind_fv (v,\\<tau>) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> (Abs_fv v \\<tau> t)", "using term_ok'_bind_fv assms"], ["proof (prove)\nusing this:\n  term_ok' ?\\<Sigma> ?t \\<Longrightarrow>\n  term_ok' ?\\<Sigma> (bind_fv (?v, ?\\<tau>) ?t)\n  term_ok' \\<Sigma> t\n  typ_ok_sig \\<Sigma> \\<tau>\n\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> (Abs_fv v \\<tau> t)", "by simp"], ["", "lemma term_ok'_mk_all:\n  assumes \"wf_theory \\<Theta>\" and \"term_ok' (sig \\<Theta>) B\" and \"typ_of B = Some propT\" \n    and \"typ_ok \\<Theta> \\<tau>\"\n  shows \"term_ok' (sig \\<Theta>) (mk_all x \\<tau> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_all x \\<tau> B)", "using assms term_ok'_bind_fv"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok' (sig \\<Theta>) B\n  typ_of B = Some propT\n  typ_ok \\<Theta> \\<tau>\n  term_ok' ?\\<Sigma> ?t \\<Longrightarrow>\n  term_ok' ?\\<Sigma> (bind_fv (?v, ?\\<tau>) ?t)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_all x \\<tau> B)", "by (cases \\<Theta> rule: wf_theory.cases) (auto simp add: typ_of_def tinstT_def)"], ["", "lemma term_ok_mk_all:\n  assumes \"wf_theory \\<Theta>\" and \"term_ok' (sig \\<Theta>) B\" and \"typ_of B = Some propT\" and \"typ_ok \\<Theta> \\<tau>\"\n  shows \"term_ok \\<Theta> (mk_all x \\<tau> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all x \\<tau> B)", "using typ_of_mk_all term_ok'_mk_all assms"], ["proof (prove)\nusing this:\n  typ_of ?A = Some propT \\<Longrightarrow>\n  typ_of (mk_all ?x ?ty ?A) = Some propT\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok' (sig ?\\<Theta>) ?B;\n   typ_of ?B = Some propT; typ_ok ?\\<Theta> ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> term_ok' (sig ?\\<Theta>) (mk_all ?x ?\\<tau> ?B)\n  wf_theory \\<Theta>\n  term_ok' (sig \\<Theta>) B\n  typ_of B = Some propT\n  typ_ok \\<Theta> \\<tau>\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all x \\<tau> B)", "by (auto simp add: wt_term_def)"], ["", "lemma term_ok'_incr_boundvars: \n  \"term_ok' (sig \\<Theta>) t \\<Longrightarrow> term_ok' (sig \\<Theta>) (incr_boundvars lev t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) t \\<Longrightarrow>\n    term_ok' (sig \\<Theta>) (incr_boundvars lev t)", "using term_ok'_incr_bv incr_boundvars_def"], ["proof (prove)\nusing this:\n  term_ok' ?\\<Sigma> ?t \\<Longrightarrow>\n  term_ok' ?\\<Sigma> (incr_bv ?inc ?lev ?t)\n  incr_boundvars ?inc ?t = incr_bv ?inc 0 ?t\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) t \\<Longrightarrow>\n    term_ok' (sig \\<Theta>) (incr_boundvars lev t)", "by simp"], ["", "lemma term_ok'_subst_bv1:\n  assumes \"term_ok' (sig \\<Theta>) f\" and \"term_ok' (sig \\<Theta>) u\"\n  shows \"term_ok' (sig \\<Theta>) (subst_bv1 f lev u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (subst_bv1 f lev u)", "using assms"], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) f\n  term_ok' (sig \\<Theta>) u\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (subst_bv1 f lev u)", "by (induction f lev u rule: subst_bv1.induct) (use term_ok'_incr_boundvars in auto)"], ["", "lemma term_ok'_subst_bv:\n  assumes \"term_ok' (sig \\<Theta>) f\" and \"term_ok' (sig \\<Theta>) u\"\n  shows \"term_ok' (sig \\<Theta>) (subst_bv f u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (subst_bv f u)", "using assms term_ok'_subst_bv1 subst_bv_def"], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) f\n  term_ok' (sig \\<Theta>) u\n  \\<lbrakk>term_ok' (sig ?\\<Theta>) ?f; term_ok' (sig ?\\<Theta>) ?u\\<rbrakk>\n  \\<Longrightarrow> term_ok' (sig ?\\<Theta>) (subst_bv1 ?f ?lev ?u)\n  subst_bv ?u ?t \\<equiv> subst_bv1 ?t 0 ?u\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (subst_bv f u)", "by simp"], ["", "lemma term_ok'_betapply:\n  assumes \"term_ok' (sig \\<Theta>) f\" \"term_ok' (sig \\<Theta>) u\"\n  shows \"term_ok' (sig \\<Theta>) (f \\<bullet> u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (f \\<bullet> u)", "proof(cases \"f\")"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       f = Ct x11 x12 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 2. \\<And>x21 x22.\n       f = Fv x21 x22 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 3. \\<And>x3.\n       f = Bv x3 \\<Longrightarrow> term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 4. \\<And>x41 x42.\n       f = Abs x41 x42 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 5. \\<And>x51 x52.\n       f = x51 $ x52 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)", "case (Abs T t)"], ["proof (state)\nthis:\n  f = Abs T t\n\ngoal (5 subgoals):\n 1. \\<And>x11 x12.\n       f = Ct x11 x12 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 2. \\<And>x21 x22.\n       f = Fv x21 x22 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 3. \\<And>x3.\n       f = Bv x3 \\<Longrightarrow> term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 4. \\<And>x41 x42.\n       f = Abs x41 x42 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 5. \\<And>x51 x52.\n       f = x51 $ x52 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)", "then"], ["proof (chain)\npicking this:\n  f = Abs T t", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Abs T t\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (f \\<bullet> u)", "using assms term_ok'_subst_bv1"], ["proof (prove)\nusing this:\n  f = Abs T t\n  term_ok' (sig \\<Theta>) f\n  term_ok' (sig \\<Theta>) u\n  \\<lbrakk>term_ok' (sig ?\\<Theta>) ?f; term_ok' (sig ?\\<Theta>) ?u\\<rbrakk>\n  \\<Longrightarrow> term_ok' (sig ?\\<Theta>) (subst_bv1 ?f ?lev ?u)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (f \\<bullet> u)", "by (simp add: subst_bv_def)"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) (f \\<bullet> u)\n\ngoal (4 subgoals):\n 1. \\<And>x11 x12.\n       f = Ct x11 x12 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 2. \\<And>x21 x22.\n       f = Fv x21 x22 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 3. \\<And>x3.\n       f = Bv x3 \\<Longrightarrow> term_ok' (sig \\<Theta>) (f \\<bullet> u)\n 4. \\<And>x51 x52.\n       f = x51 $ x52 \\<Longrightarrow>\n       term_ok' (sig \\<Theta>) (f \\<bullet> u)", "qed (use assms in auto)"], ["", "lemma term_ok_betapply:\n  assumes \"term_ok \\<Theta> f\" \"term_ok \\<Theta> u\" \n  assumes \"typ_of f = Some (uty \\<rightarrow> tty)\" \"typ_of u = Some uty\"\n  shows \"term_ok \\<Theta> (f \\<bullet> u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (f \\<bullet> u)", "using assms term_ok'_betapply wt_term_def typ_of_betaply assms"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> f\n  term_ok \\<Theta> u\n  typ_of f = Some (uty \\<rightarrow> tty)\n  typ_of u = Some uty\n  \\<lbrakk>term_ok' (sig ?\\<Theta>) ?f; term_ok' (sig ?\\<Theta>) ?u\\<rbrakk>\n  \\<Longrightarrow> term_ok' (sig ?\\<Theta>) (?f \\<bullet> ?u)\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  \\<lbrakk>typ_of ?t = Some (?uty \\<rightarrow> ?tty);\n   typ_of ?u = Some ?uty\\<rbrakk>\n  \\<Longrightarrow> typ_of (?t \\<bullet> ?u) = Some ?tty\n  term_ok \\<Theta> f\n  term_ok \\<Theta> u\n  typ_of f = Some (uty \\<rightarrow> tty)\n  typ_of u = Some uty\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (f \\<bullet> u)", "by auto"], ["", "lemma typ_ok_sig_subst_typ:\n  assumes \"is_std_sig \\<Sigma>\" and \"typ_ok_sig \\<Sigma> ty\" and \"distinct (map fst insts)\" \n    and \"list_all (typ_ok_sig \\<Sigma>) (map snd insts)\"\n  shows \"typ_ok_sig \\<Sigma> (subst_typ insts ty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ insts ty)", "using assms"], ["proof (prove)\nusing this:\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> ty\n  distinct (map fst insts)\n  list_all (typ_ok_sig \\<Sigma>) (map snd insts)\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ insts ty)", "proof (induction insts ty rule: subst_typ.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>insts a Ts.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ts; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x; distinct (map fst insts);\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x);\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty a Ts);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty a Ts))\n 2. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "case (1 inst a Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set Ts; is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> ?x;\n   distinct (map fst inst);\n   list_all (typ_ok_sig \\<Sigma>) (map snd inst)\\<rbrakk>\n  \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst ?x)\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Ty a Ts)\n  distinct (map fst inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)\n\ngoal (2 subgoals):\n 1. \\<And>insts a Ts.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ts; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x; distinct (map fst insts);\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x);\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty a Ts);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty a Ts))\n 2. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "have \"typ_ok_sig \\<Sigma> (subst_typ inst ty)\" if \"ty \\<in> set Ts\" for ty"], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ inst ty)", "using that 1"], ["proof (prove)\nusing this:\n  ty \\<in> set Ts\n  \\<lbrakk>?x \\<in> set Ts; is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> ?x;\n   distinct (map fst inst);\n   list_all (typ_ok_sig \\<Sigma>) (map snd inst)\\<rbrakk>\n  \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst ?x)\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Ty a Ts)\n  distinct (map fst inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ inst ty)", "by (auto simp add: list_all_iff split: option.splits)"], ["proof (state)\nthis:\n  ?ty \\<in> set Ts \\<Longrightarrow>\n  typ_ok_sig \\<Sigma> (subst_typ inst ?ty)\n\ngoal (2 subgoals):\n 1. \\<And>insts a Ts.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ts; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x; distinct (map fst insts);\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x);\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty a Ts);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty a Ts))\n 2. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "hence \"\\<forall>ty \\<in> set (map (subst_typ inst) Ts) . typ_ok_sig \\<Sigma> ty\""], ["proof (prove)\nusing this:\n  ?ty \\<in> set Ts \\<Longrightarrow>\n  typ_ok_sig \\<Sigma> (subst_typ inst ?ty)\n\ngoal (1 subgoal):\n 1. \\<forall>ty\\<in>set (map (subst_typ inst) Ts). typ_ok_sig \\<Sigma> ty", "by simp"], ["proof (state)\nthis:\n  \\<forall>ty\\<in>set (map (subst_typ inst) Ts). typ_ok_sig \\<Sigma> ty\n\ngoal (2 subgoals):\n 1. \\<And>insts a Ts.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ts; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x; distinct (map fst insts);\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x);\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty a Ts);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty a Ts))\n 2. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "hence \"list_all (typ_ok_sig \\<Sigma>) (map (subst_typ inst) Ts)\""], ["proof (prove)\nusing this:\n  \\<forall>ty\\<in>set (map (subst_typ inst) Ts). typ_ok_sig \\<Sigma> ty\n\ngoal (1 subgoal):\n 1. list_all (typ_ok_sig \\<Sigma>) (map (subst_typ inst) Ts)", "using list_all_iff"], ["proof (prove)\nusing this:\n  \\<forall>ty\\<in>set (map (subst_typ inst) Ts). typ_ok_sig \\<Sigma> ty\n  list_all ?P ?x = Ball (set ?x) ?P\n\ngoal (1 subgoal):\n 1. list_all (typ_ok_sig \\<Sigma>) (map (subst_typ inst) Ts)", "by blast"], ["proof (state)\nthis:\n  list_all (typ_ok_sig \\<Sigma>) (map (subst_typ inst) Ts)\n\ngoal (2 subgoals):\n 1. \\<And>insts a Ts.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ts; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x; distinct (map fst insts);\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x);\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty a Ts);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty a Ts))\n 2. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "moreover"], ["proof (state)\nthis:\n  list_all (typ_ok_sig \\<Sigma>) (map (subst_typ inst) Ts)\n\ngoal (2 subgoals):\n 1. \\<And>insts a Ts.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ts; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x; distinct (map fst insts);\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x);\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty a Ts);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty a Ts))\n 2. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "have \"length (map (subst_typ inst) Ts) = length Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (subst_typ inst) Ts) = length Ts", "by simp"], ["proof (state)\nthis:\n  length (map (subst_typ inst) Ts) = length Ts\n\ngoal (2 subgoals):\n 1. \\<And>insts a Ts.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set Ts; is_std_sig \\<Sigma>;\n                    typ_ok_sig \\<Sigma> x; distinct (map fst insts);\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x);\n        is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Ty a Ts);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty a Ts))\n 2. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "ultimately"], ["proof (chain)\npicking this:\n  list_all (typ_ok_sig \\<Sigma>) (map (subst_typ inst) Ts)\n  length (map (subst_typ inst) Ts) = length Ts", "show ?case"], ["proof (prove)\nusing this:\n  list_all (typ_ok_sig \\<Sigma>) (map (subst_typ inst) Ts)\n  length (map (subst_typ inst) Ts) = length Ts\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ inst (Ty a Ts))", "using \"1.prems\""], ["proof (prove)\nusing this:\n  list_all (typ_ok_sig \\<Sigma>) (map (subst_typ inst) Ts)\n  length (map (subst_typ inst) Ts) = length Ts\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Ty a Ts)\n  distinct (map fst inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ inst (Ty a Ts))", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  typ_ok_sig \\<Sigma> (subst_typ inst (Ty a Ts))\n\ngoal (1 subgoal):\n 1. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "case (2 inst idn S)"], ["proof (state)\nthis:\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Tv idn S)\n  distinct (map fst inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)\n\ngoal (1 subgoal):\n 1. \\<And>insts idn S.\n       \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n        distinct (map fst insts);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn S))", "then"], ["proof (chain)\npicking this:\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Tv idn S)\n  distinct (map fst inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)", "show ?case"], ["proof (prove)\nusing this:\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Tv idn S)\n  distinct (map fst inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "proof(cases \"lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))\n 2. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "case True"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))\n 2. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "from this 2"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Tv idn S)\n  distinct (map fst inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)", "obtain res where res: \"lookup (\\<lambda>x. x = (idn, S)) inst = Some res\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Tv idn S)\n  distinct (map fst inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)\n\ngoal (1 subgoal):\n 1. (\\<And>res.\n        lookup (\\<lambda>x. x = (idn, S)) inst = Some res \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some res\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))\n 2. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "have \"res \\<in> set (map snd inst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res \\<in> set (map snd inst)", "using 2 res"], ["proof (prove)\nusing this:\n  is_std_sig \\<Sigma>\n  typ_ok_sig \\<Sigma> (Tv idn S)\n  distinct (map fst inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some res\n\ngoal (1 subgoal):\n 1. res \\<in> set (map snd inst)", "by (induction inst) (auto split: if_splits)"], ["proof (state)\nthis:\n  res \\<in> set (map snd inst)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))\n 2. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "hence \"typ_ok_sig \\<Sigma> res\""], ["proof (prove)\nusing this:\n  res \\<in> set (map snd inst)\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> res", "using 2(4) res"], ["proof (prove)\nusing this:\n  res \\<in> set (map snd inst)\n  list_all (typ_ok_sig \\<Sigma>) (map snd inst)\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some res\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> res", "by (induction inst) (auto split: if_splits simp add: rev_image_eqI)"], ["proof (state)\nthis:\n  typ_ok_sig \\<Sigma> res\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))\n 2. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "then"], ["proof (chain)\npicking this:\n  typ_ok_sig \\<Sigma> res", "show ?thesis"], ["proof (prove)\nusing this:\n  typ_ok_sig \\<Sigma> res\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "using res"], ["proof (prove)\nusing this:\n  typ_ok_sig \\<Sigma> res\n  lookup (\\<lambda>x. x = (idn, S)) inst = Some res\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "by simp"], ["proof (state)\nthis:\n  typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "case False"], ["proof (state)\nthis:\n  \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "hence rewr: \"subst_typ inst (Tv idn S) = Tv idn S\""], ["proof (prove)\nusing this:\n  \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\n\ngoal (1 subgoal):\n 1. subst_typ inst (Tv idn S) = Tv idn S", "by auto"], ["proof (state)\nthis:\n  subst_typ inst (Tv idn S) = Tv idn S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; typ_ok_sig \\<Sigma> (Tv idn S);\n     distinct (map fst inst); list_all (typ_ok_sig \\<Sigma>) (map snd inst);\n     \\<not> lookup (\\<lambda>x. x = (idn, S)) inst \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "then"], ["proof (chain)\npicking this:\n  subst_typ inst (Tv idn S) = Tv idn S", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_typ inst (Tv idn S) = Tv idn S\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "using \"2.prems\"(2)"], ["proof (prove)\nusing this:\n  subst_typ inst (Tv idn S) = Tv idn S\n  typ_ok_sig \\<Sigma> (Tv idn S)\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))", "by simp"], ["proof (state)\nthis:\n  typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  typ_ok_sig \\<Sigma> (subst_typ inst (Tv idn S))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* MOVE *)"], ["", "corollary subst_typ_tinstT: \"tinstT (subst_typ insts ty) ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinstT (subst_typ insts ty) ty", "unfolding tinstT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<rho>. tsubstT ty \\<rho> = subst_typ insts ty", "using tsubstT_simulates_subst_typ"], ["proof (prove)\nusing this:\n  subst_typ ?insts ?T =\n  tsubstT ?T\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) ?insts))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<rho>. tsubstT ty \\<rho> = subst_typ insts ty", "by fastforce"], ["", "lemma tsubstT_trans: \"tsubstT ty \\<rho>1 = ty1 \\<Longrightarrow> tsubstT ty1 \\<rho>2 = ty2 \n  \\<Longrightarrow> tsubstT ty (\\<lambda>idx s . case \\<rho>1 idx s of Tv idx' s' \\<Rightarrow> \\<rho>2 idx' s' \n  | Ty s Ts \\<Rightarrow> Ty s (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)) = ty2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tsubstT ty \\<rho>1 = ty1; tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n    \\<Longrightarrow> tsubstT ty\n                       (\\<lambda>idx s.\n                           case \\<rho>1 idx s of\n                           Ty s Ts \\<Rightarrow>\n                             Ty s (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n                           | Tv idx' s' \\<Rightarrow> \\<rho>2 idx' s') =\n                      ty2", "unfolding tinstT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tsubstT ty \\<rho>1 = ty1; tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n    \\<Longrightarrow> tsubstT ty\n                       (\\<lambda>idx s.\n                           case \\<rho>1 idx s of\n                           Ty s Ts \\<Rightarrow>\n                             Ty s (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n                           | Tv idx' s' \\<Rightarrow> \\<rho>2 idx' s') =\n                      ty2", "proof (induction ty arbitrary: ty1 ty2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 ty1 ty2.\n       \\<lbrakk>\\<And>x2a ty1 ty2.\n                   \\<lbrakk>x2a \\<in> set x2; tsubstT x2a \\<rho>1 = ty1;\n                    tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n                   \\<Longrightarrow> tsubstT x2a\n(\\<lambda>idx s.\n    case \\<rho>1 idx s of\n    Ty s Ts \\<Rightarrow> Ty s (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n    | Tv x xa \\<Rightarrow> \\<rho>2 x xa) =\n                                     ty2;\n        tsubstT (Ty x1 x2) \\<rho>1 = ty1; tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Ty x1 x2)\n                          (\\<lambda>idx s.\n                              case \\<rho>1 idx s of\n                              Ty s Ts \\<Rightarrow>\n                                Ty s\n                                 (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n                              | Tv x xa \\<Rightarrow> \\<rho>2 x xa) =\n                         ty2\n 2. \\<And>x1 x2 ty1 ty2.\n       \\<lbrakk>tsubstT (Tv x1 x2) \\<rho>1 = ty1;\n        tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Tv x1 x2)\n                          (\\<lambda>idx s.\n                              case \\<rho>1 idx s of\n                              Ty s Ts \\<Rightarrow>\n                                Ty s\n                                 (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n                              | Tv x xa \\<Rightarrow> \\<rho>2 x xa) =\n                         ty2", "case (Tv idx s)"], ["proof (state)\nthis:\n  tsubstT (Tv idx s) \\<rho>1 = ty1\n  tsubstT ty1 \\<rho>2 = ty2\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 ty1 ty2.\n       \\<lbrakk>\\<And>x2a ty1 ty2.\n                   \\<lbrakk>x2a \\<in> set x2; tsubstT x2a \\<rho>1 = ty1;\n                    tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n                   \\<Longrightarrow> tsubstT x2a\n(\\<lambda>idx s.\n    case \\<rho>1 idx s of\n    Ty s Ts \\<Rightarrow> Ty s (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n    | Tv x xa \\<Rightarrow> \\<rho>2 x xa) =\n                                     ty2;\n        tsubstT (Ty x1 x2) \\<rho>1 = ty1; tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Ty x1 x2)\n                          (\\<lambda>idx s.\n                              case \\<rho>1 idx s of\n                              Ty s Ts \\<Rightarrow>\n                                Ty s\n                                 (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n                              | Tv x xa \\<Rightarrow> \\<rho>2 x xa) =\n                         ty2\n 2. \\<And>x1 x2 ty1 ty2.\n       \\<lbrakk>tsubstT (Tv x1 x2) \\<rho>1 = ty1;\n        tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Tv x1 x2)\n                          (\\<lambda>idx s.\n                              case \\<rho>1 idx s of\n                              Ty s Ts \\<Rightarrow>\n                                Ty s\n                                 (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n                              | Tv x xa \\<Rightarrow> \\<rho>2 x xa) =\n                         ty2", "then"], ["proof (chain)\npicking this:\n  tsubstT (Tv idx s) \\<rho>1 = ty1\n  tsubstT ty1 \\<rho>2 = ty2", "show ?case"], ["proof (prove)\nusing this:\n  tsubstT (Tv idx s) \\<rho>1 = ty1\n  tsubstT ty1 \\<rho>2 = ty2\n\ngoal (1 subgoal):\n 1. tsubstT (Tv idx s)\n     (\\<lambda>idx s.\n         case \\<rho>1 idx s of\n         Ty s Ts \\<Rightarrow> Ty s (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n         | Tv a b \\<Rightarrow> \\<rho>2 a b) =\n    ty2", "by (cases \"\\<rho>1 idx s\") auto"], ["proof (state)\nthis:\n  tsubstT (Tv idx s)\n   (\\<lambda>idx s.\n       case \\<rho>1 idx s of\n       Ty s Ts \\<Rightarrow> Ty s (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n       | Tv a b \\<Rightarrow> \\<rho>2 a b) =\n  ty2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 ty1 ty2.\n       \\<lbrakk>\\<And>x2a ty1 ty2.\n                   \\<lbrakk>x2a \\<in> set x2; tsubstT x2a \\<rho>1 = ty1;\n                    tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n                   \\<Longrightarrow> tsubstT x2a\n(\\<lambda>idx s.\n    case \\<rho>1 idx s of\n    Ty s Ts \\<Rightarrow> Ty s (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n    | Tv x xa \\<Rightarrow> \\<rho>2 x xa) =\n                                     ty2;\n        tsubstT (Ty x1 x2) \\<rho>1 = ty1; tsubstT ty1 \\<rho>2 = ty2\\<rbrakk>\n       \\<Longrightarrow> tsubstT (Ty x1 x2)\n                          (\\<lambda>idx s.\n                              case \\<rho>1 idx s of\n                              Ty s Ts \\<Rightarrow>\n                                Ty s\n                                 (map (\\<lambda>T. tsubstT T \\<rho>2) Ts)\n                              | Tv x xa \\<Rightarrow> \\<rho>2 x xa) =\n                         ty2", "qed auto"], ["", "corollary tinstT_trans: \"tinstT ty1 ty \\<Longrightarrow> tinstT ty2 ty1 \\<Longrightarrow> tinstT ty2 ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tinstT ty1 ty; tinstT ty2 ty1\\<rbrakk>\n    \\<Longrightarrow> tinstT ty2 ty", "unfolding tinstT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>\\<rho>. tsubstT ty \\<rho> = ty1;\n     \\<exists>\\<rho>. tsubstT ty1 \\<rho> = ty2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<rho>. tsubstT ty \\<rho> = ty2", "using tsubstT_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>tsubstT ?ty ?\\<rho>1.0 = ?ty1.0;\n   tsubstT ?ty1.0 ?\\<rho>2.0 = ?ty2.0\\<rbrakk>\n  \\<Longrightarrow> tsubstT ?ty\n                     (\\<lambda>idx s.\n                         case ?\\<rho>1.0 idx s of\n                         Ty s Ts \\<Rightarrow>\n                           Ty s (map (\\<lambda>T. tsubstT T ?\\<rho>2.0) Ts)\n                         | Tv idx' s' \\<Rightarrow> ?\\<rho>2.0 idx' s') =\n                    ?ty2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>\\<rho>. tsubstT ty \\<rho> = ty1;\n     \\<exists>\\<rho>. tsubstT ty1 \\<rho> = ty2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<rho>. tsubstT ty \\<rho> = ty2", "by blast"], ["", "lemma term_ok'_subst_typ':\n  assumes \"is_std_sig \\<Sigma>\" and \"term_ok' \\<Sigma> t\" and \"distinct (map fst insts)\" \n    and \"list_all (typ_ok_sig \\<Sigma>) (map snd insts)\"\n  shows \"term_ok' \\<Sigma> (subst_typ' insts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> (subst_typ' insts t)", "using assms"], ["proof (prove)\nusing this:\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> t\n  distinct (map fst insts)\n  list_all (typ_ok_sig \\<Sigma>) (map snd insts)\n\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> (subst_typ' insts t)", "by (induction t) \n    (use typ_ok_sig_subst_typ subst_typ_tinstT tinstT_trans in \\<open>auto split: option.splits\\<close>)"], ["", "(* This is a bit suspect, as I am disregarding abstractions... *)"], ["", "lemma \n  term_ok'_occs:\n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> occs u t \\<Longrightarrow> term_ok' \\<Sigma> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t; occs u t\\<rbrakk>\n    \\<Longrightarrow> term_ok' \\<Sigma> u", "by (induction t) auto"], ["", "lemma typ_of1_tsubst:\n  \"typ_of1 Ts t = Some ty \\<Longrightarrow> typ_of1 (map (\\<lambda>T . tsubstT T \\<rho>) Ts) (tsubst t \\<rho>) = Some (tsubstT ty \\<rho>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of1 Ts t = Some ty \\<Longrightarrow>\n    typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst t \\<rho>) =\n    Some (tsubstT ty \\<rho>)", "proof (induction Ts t arbitrary: ty rule: typ_of1.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>Ts i ty.\n       typ_of1 Ts (Bv i) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n        (tsubst (Bv i) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 4. \\<And>Ts T body ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 (T # Ts) body = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) (T # Ts))\n                    (tsubst body \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (Abs T body) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (Abs T body) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)\n 5. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "case (2 Ts i)"], ["proof (state)\nthis:\n  typ_of1 Ts (Bv i) = Some ty\n\ngoal (5 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>Ts i ty.\n       typ_of1 Ts (Bv i) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n        (tsubst (Bv i) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 4. \\<And>Ts T body ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 (T # Ts) body = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) (T # Ts))\n                    (tsubst body \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (Abs T body) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (Abs T body) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)\n 5. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "then"], ["proof (chain)\npicking this:\n  typ_of1 Ts (Bv i) = Some ty", "show ?case"], ["proof (prove)\nusing this:\n  typ_of1 Ts (Bv i) = Some ty\n\ngoal (1 subgoal):\n 1. typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst (Bv i) \\<rho>) =\n    Some (tsubstT ty \\<rho>)", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst (Bv i) \\<rho>) =\n  Some (tsubstT ty \\<rho>)\n\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts T body ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 (T # Ts) body = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) (T # Ts))\n                    (tsubst body \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (Abs T body) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (Abs T body) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)\n 4. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts T body ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 (T # Ts) body = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) (T # Ts))\n                    (tsubst body \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (Abs T body) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (Abs T body) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)\n 4. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "case (4 Ts T body)"], ["proof (state)\nthis:\n  typ_of1 (T # Ts) body = Some ?ty \\<Longrightarrow>\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) (T # Ts))\n   (tsubst body \\<rho>) =\n  Some (tsubstT ?ty \\<rho>)\n  typ_of1 Ts (Abs T body) = Some ty\n\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts T body ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 (T # Ts) body = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) (T # Ts))\n                    (tsubst body \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (Abs T body) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (Abs T body) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)\n 4. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "then"], ["proof (chain)\npicking this:\n  typ_of1 (T # Ts) body = Some ?ty \\<Longrightarrow>\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) (T # Ts))\n   (tsubst body \\<rho>) =\n  Some (tsubstT ?ty \\<rho>)\n  typ_of1 Ts (Abs T body) = Some ty", "show ?case"], ["proof (prove)\nusing this:\n  typ_of1 (T # Ts) body = Some ?ty \\<Longrightarrow>\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) (T # Ts))\n   (tsubst body \\<rho>) =\n  Some (tsubstT ?ty \\<rho>)\n  typ_of1 Ts (Abs T body) = Some ty\n\ngoal (1 subgoal):\n 1. typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n     (tsubst (Abs T body) \\<rho>) =\n    Some (tsubstT ty \\<rho>)", "by (auto simp add: bind_eq_Some_conv)"], ["proof (state)\nthis:\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n   (tsubst (Abs T body) \\<rho>) =\n  Some (tsubstT ty \\<rho>)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "case (5 Ts f u)"], ["proof (state)\nthis:\n  typ_of1 Ts u = Some ?ty \\<Longrightarrow>\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst u \\<rho>) =\n  Some (tsubstT ?ty \\<rho>)\n  \\<lbrakk>typ_of1 Ts u = Some ?a; typ_of1 Ts f = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                     (tsubst f \\<rho>) =\n                    Some (tsubstT ?ty \\<rho>)\n  typ_of1 Ts (f $ u) = Some ty\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "from \"5.prems\""], ["proof (chain)\npicking this:\n  typ_of1 Ts (f $ u) = Some ty", "obtain u_ty where u_ty: \"typ_of1 Ts u = Some u_ty\""], ["proof (prove)\nusing this:\n  typ_of1 Ts (f $ u) = Some ty\n\ngoal (1 subgoal):\n 1. (\\<And>u_ty.\n        typ_of1 Ts u = Some u_ty \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: bind_eq_Some_conv)"], ["proof (state)\nthis:\n  typ_of1 Ts u = Some u_ty\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "from this \"5.prems\""], ["proof (chain)\npicking this:\n  typ_of1 Ts u = Some u_ty\n  typ_of1 Ts (f $ u) = Some ty", "have f_ty: \"typ_of1 Ts f = Some (u_ty \\<rightarrow> ty)\""], ["proof (prove)\nusing this:\n  typ_of1 Ts u = Some u_ty\n  typ_of1 Ts (f $ u) = Some ty\n\ngoal (1 subgoal):\n 1. typ_of1 Ts f = Some (u_ty \\<rightarrow> ty)", "by (auto simp add: bind_eq_Some_conv typ_of1_arg_typ[OF \"5.prems\"(1)] \n        split: if_splits typ.splits option.splits)"], ["proof (state)\nthis:\n  typ_of1 Ts f = Some (u_ty \\<rightarrow> ty)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "from u_ty \"5.IH\"(1)"], ["proof (chain)\npicking this:\n  typ_of1 Ts u = Some u_ty\n  typ_of1 Ts u = Some ?ty \\<Longrightarrow>\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst u \\<rho>) =\n  Some (tsubstT ?ty \\<rho>)", "have \"typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst u \\<rho>) = Some (tsubstT u_ty \\<rho>)\""], ["proof (prove)\nusing this:\n  typ_of1 Ts u = Some u_ty\n  typ_of1 Ts u = Some ?ty \\<Longrightarrow>\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst u \\<rho>) =\n  Some (tsubstT ?ty \\<rho>)\n\ngoal (1 subgoal):\n 1. typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst u \\<rho>) =\n    Some (tsubstT u_ty \\<rho>)", "by simp"], ["proof (state)\nthis:\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst u \\<rho>) =\n  Some (tsubstT u_ty \\<rho>)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "moreover"], ["proof (state)\nthis:\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst u \\<rho>) =\n  Some (tsubstT u_ty \\<rho>)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "from u_ty f_ty \"5.IH\"(2)"], ["proof (chain)\npicking this:\n  typ_of1 Ts u = Some u_ty\n  typ_of1 Ts f = Some (u_ty \\<rightarrow> ty)\n  \\<lbrakk>typ_of1 Ts u = Some ?a; typ_of1 Ts f = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                     (tsubst f \\<rho>) =\n                    Some (tsubstT ?ty \\<rho>)", "have \"typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst f \\<rho>) \n    = Some (tsubstT (u_ty \\<rightarrow> ty) \\<rho>)\""], ["proof (prove)\nusing this:\n  typ_of1 Ts u = Some u_ty\n  typ_of1 Ts f = Some (u_ty \\<rightarrow> ty)\n  \\<lbrakk>typ_of1 Ts u = Some ?a; typ_of1 Ts f = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                     (tsubst f \\<rho>) =\n                    Some (tsubstT ?ty \\<rho>)\n\ngoal (1 subgoal):\n 1. typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst f \\<rho>) =\n    Some (tsubstT (u_ty \\<rightarrow> ty) \\<rho>)", "by simp"], ["proof (state)\nthis:\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst f \\<rho>) =\n  Some (tsubstT (u_ty \\<rightarrow> ty) \\<rho>)\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 3. \\<And>Ts t u ty.\n       \\<lbrakk>\\<And>ty.\n                   typ_of1 Ts u = Some ty \\<Longrightarrow>\n                   typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                    (tsubst u \\<rho>) =\n                   Some (tsubstT ty \\<rho>);\n        \\<And>a ty.\n           \\<lbrakk>typ_of1 Ts u = Some a; typ_of1 Ts t = Some ty\\<rbrakk>\n           \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                              (tsubst t \\<rho>) =\n                             Some (tsubstT ty \\<rho>);\n        typ_of1 Ts (t $ u) = Some ty\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n                          (tsubst (t $ u) \\<rho>) =\n                         Some (tsubstT ty \\<rho>)", "ultimately"], ["proof (chain)\npicking this:\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst u \\<rho>) =\n  Some (tsubstT u_ty \\<rho>)\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst f \\<rho>) =\n  Some (tsubstT (u_ty \\<rightarrow> ty) \\<rho>)", "show ?case"], ["proof (prove)\nusing this:\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst u \\<rho>) =\n  Some (tsubstT u_ty \\<rho>)\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst f \\<rho>) =\n  Some (tsubstT (u_ty \\<rightarrow> ty) \\<rho>)\n\ngoal (1 subgoal):\n 1. typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts)\n     (tsubst (f $ u) \\<rho>) =\n    Some (tsubstT ty \\<rho>)", "by simp"], ["proof (state)\nthis:\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst (f $ u) \\<rho>) =\n  Some (tsubstT ty \\<rho>)\n\ngoal (2 subgoals):\n 1. \\<And>uu_ uv_ T ty.\n       typ_of1 uu_ (Ct uv_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uu_)\n        (tsubst (Ct uv_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)\n 2. \\<And>uw_ ux_ T ty.\n       typ_of1 uw_ (Fv ux_ T) = Some ty \\<Longrightarrow>\n       typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) uw_)\n        (tsubst (Fv ux_ T) \\<rho>) =\n       Some (tsubstT ty \\<rho>)", "qed auto"], ["", "corollary typ_of1_tsubst_weak:\n  assumes \"typ_of1 Ts t = Some ty\"\n  assumes \"typ_of1 (map (\\<lambda>T . tsubstT T \\<rho>) Ts) (tsubst t \\<rho>) = Some ty'\"\n  shows \"tsubstT ty \\<rho> = ty'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tsubstT ty \\<rho> = ty'", "using assms typ_of1_tsubst"], ["proof (prove)\nusing this:\n  typ_of1 Ts t = Some ty\n  typ_of1 (map (\\<lambda>T. tsubstT T \\<rho>) Ts) (tsubst t \\<rho>) =\n  Some ty'\n  typ_of1 ?Ts ?t = Some ?ty \\<Longrightarrow>\n  typ_of1 (map (\\<lambda>T. tsubstT T ?\\<rho>) ?Ts) (tsubst ?t ?\\<rho>) =\n  Some (tsubstT ?ty ?\\<rho>)\n\ngoal (1 subgoal):\n 1. tsubstT ty \\<rho> = ty'", "by auto"], ["", "lemma tsubstT_no_change[simp]: \"tsubstT T Tv = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tsubstT T Tv = T", "by (induction T) (auto simp add: map_idI)"], ["", "lemma term_ok_mk_eq_same_typ:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"term_ok \\<Theta> (mk_eq s t)\"\n  shows \"typ_of s = typ_of t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of s = typ_of t", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> (mk_eq s t)\n\ngoal (1 subgoal):\n 1. typ_of s = typ_of t", "by (cases \\<Theta> rule: theory_full_exhaust)\n   (fastforce simp add: wt_term_def typ_of_def bind_eq_Some_conv tinstT_def)"], ["", "lemma typ_of_eta_expand: \"typ_of f = Some (\\<tau> \\<rightarrow> \\<tau>') \\<Longrightarrow> typ_of (Abs \\<tau> (f $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of f = Some (\\<tau> \\<rightarrow> \\<tau>') \\<Longrightarrow>\n    typ_of (Abs \\<tau> (f $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')", "using typ_of1_weaken"], ["proof (prove)\nusing this:\n  typ_of1 ?Ts ?t = Some ?T \\<Longrightarrow>\n  typ_of1 (?Ts @ ?Ts') ?t = Some ?T\n\ngoal (1 subgoal):\n 1. typ_of f = Some (\\<tau> \\<rightarrow> \\<tau>') \\<Longrightarrow>\n    typ_of (Abs \\<tau> (f $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')", "by (fastforce simp add: bind_eq_Some_conv typ_of_def)"], ["", "lemma term_okI: \"term_ok' (sig \\<Theta>) t \\<Longrightarrow> typ_of t \\<noteq> None \\<Longrightarrow> term_ok \\<Theta> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>term_ok' (sig \\<Theta>) t; typ_of t \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> term_ok \\<Theta> t", "by (simp add: wt_term_def)"], ["", "lemma term_okD1: \"term_ok \\<Theta> t \\<Longrightarrow> term_ok' (sig \\<Theta>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> t \\<Longrightarrow> term_ok' (sig \\<Theta>) t", "by (simp add: wt_term_def)"], ["", "lemma term_okD2: \"term_ok \\<Theta> t \\<Longrightarrow> typ_of t \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> t \\<Longrightarrow> typ_of t \\<noteq> None", "by (simp add: wt_term_def)"], ["", "lemma term_ok_imp_typ_ok': assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> t\" shows \"typ_ok \\<Theta> (the (typ_of t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (the (typ_of t))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (the (typ_of t))", "obtain ty where ty: \"typ_of t = Some ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ty.\n        typ_of t = Some ty \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson assms option.exhaust term_okD2)"], ["proof (state)\nthis:\n  typ_of t = Some ty\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (the (typ_of t))", "hence \"typ_ok \\<Theta> ty\""], ["proof (prove)\nusing this:\n  typ_of t = Some ty\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> ty", "using term_ok_imp_typ_ok assms"], ["proof (prove)\nusing this:\n  typ_of t = Some ty\n  \\<lbrakk>wf_theory ?thy; term_ok ?thy ?t; typ_of ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?thy ?ty\n  wf_theory \\<Theta>\n  term_ok \\<Theta> t\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> ty", "by blast"], ["proof (state)\nthis:\n  typ_ok \\<Theta> ty\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (the (typ_of t))", "thus ?thesis"], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> ty\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (the (typ_of t))", "using ty"], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> ty\n  typ_of t = Some ty\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (the (typ_of t))", "by simp"], ["proof (state)\nthis:\n  typ_ok \\<Theta> (the (typ_of t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma term_ok_mk_eqI:\n  assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> s\" \"term_ok \\<Theta> t\" \"typ_of s = typ_of t\" \n  shows\"term_ok \\<Theta> (mk_eq s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq s t)", "proof (rule term_okI)"], ["proof (state)\ngoal (2 subgoals):\n 1. term_ok' (sig \\<Theta>) (mk_eq s t)\n 2. typ_of (mk_eq s t) \\<noteq> None", "have \"typ_ok \\<Theta> (the (typ_of t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (the (typ_of t))", "using assms(1) assms(3) term_ok_imp_typ_ok'"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> t\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok ?\\<Theta> ?t\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?\\<Theta> (the (typ_of ?t))\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (the (typ_of t))", "by blast"], ["proof (state)\nthis:\n  typ_ok \\<Theta> (the (typ_of t))\n\ngoal (2 subgoals):\n 1. term_ok' (sig \\<Theta>) (mk_eq s t)\n 2. typ_of (mk_eq s t) \\<noteq> None", "hence \"typ_ok_sig (sig \\<Theta>) (the (typ_of t))\""], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> (the (typ_of t))\n\ngoal (1 subgoal):\n 1. typ_ok_sig (sig \\<Theta>) (the (typ_of t))", "by simp"], ["proof (state)\nthis:\n  typ_ok_sig (sig \\<Theta>) (the (typ_of t))\n\ngoal (2 subgoals):\n 1. term_ok' (sig \\<Theta>) (mk_eq s t)\n 2. typ_of (mk_eq s t) \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  typ_ok_sig (sig \\<Theta>) (the (typ_of t))", "show \"term_ok' (sig \\<Theta>) (mk_eq s t)\""], ["proof (prove)\nusing this:\n  typ_ok_sig (sig \\<Theta>) (the (typ_of t))\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq s t)", "using assms"], ["proof (prove)\nusing this:\n  typ_ok_sig (sig \\<Theta>) (the (typ_of t))\n  wf_theory \\<Theta>\n  term_ok \\<Theta> s\n  term_ok \\<Theta> t\n  typ_of s = typ_of t\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq s t)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typ_ok_sig (sig \\<Theta>) (the (typ_of t)); wf_theory \\<Theta>;\n     term_ok \\<Theta> s; term_ok \\<Theta> t; typ_of s = typ_of t\\<rbrakk>\n    \\<Longrightarrow> term_ok' (sig \\<Theta>) (mk_eq s t)", "apply (drule term_okD1)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>typ_ok_sig (sig \\<Theta>) (the (typ_of t)); wf_theory \\<Theta>;\n     typ_of s = typ_of t; term_ok' (sig \\<Theta>) s;\n     term_ok' (sig \\<Theta>) t\\<rbrakk>\n    \\<Longrightarrow> term_ok' (sig \\<Theta>) (mk_eq s t)", "apply (cases \\<Theta> rule: theory_full_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cto tao sorts axioms.\n       \\<lbrakk>typ_ok_sig (sig \\<Theta>) (the (typ_of t));\n        wf_theory \\<Theta>; typ_of s = typ_of t; term_ok' (sig \\<Theta>) s;\n        term_ok' (sig \\<Theta>) t;\n        \\<Theta> = ((cto, tao, sorts), axioms)\\<rbrakk>\n       \\<Longrightarrow> term_ok' (sig \\<Theta>) (mk_eq s t)", "by (auto split: option.splits simp add: tinstT_def)"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) (mk_eq s t)\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq s t) \\<noteq> None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. typ_of (mk_eq s t) \\<noteq> None", "show \"typ_of (mk_eq s t) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of (mk_eq s t) \\<noteq> None", "using assms typ_of_def"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> s\n  term_ok \\<Theta> t\n  typ_of s = typ_of t\n  typ_of ?t \\<equiv> typ_of1 [] ?t\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq s t) \\<noteq> None", "by (auto dest: term_okD2 simp add: wt_term_def)"], ["proof (state)\nthis:\n  typ_of (mk_eq s t) \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typ_of1_decr': \"\\<not> loose_bvar1 t 0 \\<Longrightarrow> typ_of1 (T#Ts) t = Some \\<tau> \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> loose_bvar1 t 0;\n     typ_of1 (T # Ts) t = Some \\<tau>\\<rbrakk>\n    \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some \\<tau>", "proof (induction Ts t arbitrary: T \\<tau> rule: typ_of1.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>uu_ uv_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Ct uv_ T) 0;\n        typ_of1 (Ta # uu_) (Ct uv_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ (decr 0 (Ct uv_ T)) = Some \\<tau>\n 2. \\<And>Ts i T \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Bv i) 0;\n        typ_of1 (T # Ts) (Bv i) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (Bv i)) = Some \\<tau>\n 3. \\<And>uw_ ux_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Fv ux_ T) 0;\n        typ_of1 (Ta # uw_) (Fv ux_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ (decr 0 (Fv ux_ T)) = Some \\<tau>\n 4. \\<And>Ts T body Ta \\<tau>.\n       \\<lbrakk>\\<And>Ta \\<tau>.\n                   \\<lbrakk>\\<not> loose_bvar1 body 0;\n                    typ_of1 (Ta # T # Ts) body = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 (T # Ts) (decr 0 body) =\n                                     Some \\<tau>;\n        \\<not> loose_bvar1 (Abs T body) 0;\n        typ_of1 (Ta # Ts) (Abs T body) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (Abs T body)) = Some \\<tau>\n 5. \\<And>Ts t u T \\<tau>.\n       \\<lbrakk>\\<And>T \\<tau>.\n                   \\<lbrakk>\\<not> loose_bvar1 u 0;\n                    typ_of1 (T # Ts) u = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts (decr 0 u) = Some \\<tau>;\n        \\<And>a T \\<tau>.\n           \\<lbrakk>typ_of1 Ts u = Some a; \\<not> loose_bvar1 t 0;\n            typ_of1 (T # Ts) t = Some \\<tau>\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some \\<tau>;\n        \\<not> loose_bvar1 (t $ u) 0;\n        typ_of1 (T # Ts) (t $ u) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (t $ u)) = Some \\<tau>", "case (4 Ts B body)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> loose_bvar1 body 0;\n   typ_of1 (?T # B # Ts) body = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (B # Ts) (decr 0 body) = Some ?\\<tau>\n  \\<not> loose_bvar1 (Abs B body) 0\n  typ_of1 (T # Ts) (Abs B body) = Some \\<tau>\n\ngoal (5 subgoals):\n 1. \\<And>uu_ uv_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Ct uv_ T) 0;\n        typ_of1 (Ta # uu_) (Ct uv_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ (decr 0 (Ct uv_ T)) = Some \\<tau>\n 2. \\<And>Ts i T \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Bv i) 0;\n        typ_of1 (T # Ts) (Bv i) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (Bv i)) = Some \\<tau>\n 3. \\<And>uw_ ux_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Fv ux_ T) 0;\n        typ_of1 (Ta # uw_) (Fv ux_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ (decr 0 (Fv ux_ T)) = Some \\<tau>\n 4. \\<And>Ts T body Ta \\<tau>.\n       \\<lbrakk>\\<And>Ta \\<tau>.\n                   \\<lbrakk>\\<not> loose_bvar1 body 0;\n                    typ_of1 (Ta # T # Ts) body = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 (T # Ts) (decr 0 body) =\n                                     Some \\<tau>;\n        \\<not> loose_bvar1 (Abs T body) 0;\n        typ_of1 (Ta # Ts) (Abs T body) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (Abs T body)) = Some \\<tau>\n 5. \\<And>Ts t u T \\<tau>.\n       \\<lbrakk>\\<And>T \\<tau>.\n                   \\<lbrakk>\\<not> loose_bvar1 u 0;\n                    typ_of1 (T # Ts) u = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts (decr 0 u) = Some \\<tau>;\n        \\<And>a T \\<tau>.\n           \\<lbrakk>typ_of1 Ts u = Some a; \\<not> loose_bvar1 t 0;\n            typ_of1 (T # Ts) t = Some \\<tau>\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some \\<tau>;\n        \\<not> loose_bvar1 (t $ u) 0;\n        typ_of1 (T # Ts) (t $ u) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (t $ u)) = Some \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> loose_bvar1 body 0;\n   typ_of1 (?T # B # Ts) body = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (B # Ts) (decr 0 body) = Some ?\\<tau>\n  \\<not> loose_bvar1 (Abs B body) 0\n  typ_of1 (T # Ts) (Abs B body) = Some \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> loose_bvar1 body 0;\n   typ_of1 (?T # B # Ts) body = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (B # Ts) (decr 0 body) = Some ?\\<tau>\n  \\<not> loose_bvar1 (Abs B body) 0\n  typ_of1 (T # Ts) (Abs B body) = Some \\<tau>\n\ngoal (1 subgoal):\n 1. typ_of1 Ts (decr 0 (Abs B body)) = Some \\<tau>", "using typ_of1_decr_gen"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> loose_bvar1 body 0;\n   typ_of1 (?T # B # Ts) body = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (B # Ts) (decr 0 body) = Some ?\\<tau>\n  \\<not> loose_bvar1 (Abs B body) 0\n  typ_of1 (T # Ts) (Abs B body) = Some \\<tau>\n  \\<lbrakk>typ_of1 (?Ts @ [?T] @ ?Ts') ?t = ?tyo;\n   \\<not> loose_bvar1 ?t (length ?Ts)\\<rbrakk>\n  \\<Longrightarrow> typ_of1 (?Ts @ ?Ts') (decr (length ?Ts) ?t) = ?tyo\n\ngoal (1 subgoal):\n 1. typ_of1 Ts (decr 0 (Abs B body)) = Some \\<tau>", "apply (simp add: bind_eq_Some_conv split: if_splits option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>T \\<tau>.\n                \\<lbrakk>\\<not> loose_bvar1 body 0;\n                 typ_of1 (T # B # Ts) body = Some \\<tau>\\<rbrakk>\n                \\<Longrightarrow> typ_of1 (B # Ts) (decr 0 body) =\n                                  Some \\<tau>;\n     \\<not> loose_bvar1 body (Suc 0);\n     \\<exists>y.\n        typ_of1 (B # T # Ts) body = Some y \\<and>\n        B \\<rightarrow> y = \\<tau>;\n     \\<And>Ts T Ts' t.\n        \\<not> loose_bvar1 t (length Ts) \\<Longrightarrow>\n        typ_of1 (Ts @ Ts') (decr (length Ts) t) =\n        typ_of1 (Ts @ T # Ts') t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         typ_of1 (B # Ts) (decr (Suc 0) body) =\n                         Some y \\<and>\n                         B \\<rightarrow> y = \\<tau>", "by (metis append_Cons append_Nil length_Cons list.size(3) typ_of1_decr_gen)"], ["proof (state)\nthis:\n  typ_of1 Ts (decr 0 (Abs B body)) = Some \\<tau>\n\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Ct uv_ T) 0;\n        typ_of1 (Ta # uu_) (Ct uv_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ (decr 0 (Ct uv_ T)) = Some \\<tau>\n 2. \\<And>Ts i T \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Bv i) 0;\n        typ_of1 (T # Ts) (Bv i) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (Bv i)) = Some \\<tau>\n 3. \\<And>uw_ ux_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Fv ux_ T) 0;\n        typ_of1 (Ta # uw_) (Fv ux_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ (decr 0 (Fv ux_ T)) = Some \\<tau>\n 4. \\<And>Ts t u T \\<tau>.\n       \\<lbrakk>\\<And>T \\<tau>.\n                   \\<lbrakk>\\<not> loose_bvar1 u 0;\n                    typ_of1 (T # Ts) u = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts (decr 0 u) = Some \\<tau>;\n        \\<And>a T \\<tau>.\n           \\<lbrakk>typ_of1 Ts u = Some a; \\<not> loose_bvar1 t 0;\n            typ_of1 (T # Ts) t = Some \\<tau>\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some \\<tau>;\n        \\<not> loose_bvar1 (t $ u) 0;\n        typ_of1 (T # Ts) (t $ u) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (t $ u)) = Some \\<tau>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Ct uv_ T) 0;\n        typ_of1 (Ta # uu_) (Ct uv_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ (decr 0 (Ct uv_ T)) = Some \\<tau>\n 2. \\<And>Ts i T \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Bv i) 0;\n        typ_of1 (T # Ts) (Bv i) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (Bv i)) = Some \\<tau>\n 3. \\<And>uw_ ux_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Fv ux_ T) 0;\n        typ_of1 (Ta # uw_) (Fv ux_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ (decr 0 (Fv ux_ T)) = Some \\<tau>\n 4. \\<And>Ts t u T \\<tau>.\n       \\<lbrakk>\\<And>T \\<tau>.\n                   \\<lbrakk>\\<not> loose_bvar1 u 0;\n                    typ_of1 (T # Ts) u = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts (decr 0 u) = Some \\<tau>;\n        \\<And>a T \\<tau>.\n           \\<lbrakk>typ_of1 Ts u = Some a; \\<not> loose_bvar1 t 0;\n            typ_of1 (T # Ts) t = Some \\<tau>\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some \\<tau>;\n        \\<not> loose_bvar1 (t $ u) 0;\n        typ_of1 (T # Ts) (t $ u) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (t $ u)) = Some \\<tau>", "case (5 Ts f u)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> loose_bvar1 u 0;\n   typ_of1 (?T # Ts) u = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts (decr 0 u) = Some ?\\<tau>\n  \\<lbrakk>typ_of1 Ts u = Some ?a; \\<not> loose_bvar1 f 0;\n   typ_of1 (?T # Ts) f = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts (decr 0 f) = Some ?\\<tau>\n  \\<not> loose_bvar1 (f $ u) 0\n  typ_of1 (T # Ts) (f $ u) = Some \\<tau>\n\ngoal (4 subgoals):\n 1. \\<And>uu_ uv_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Ct uv_ T) 0;\n        typ_of1 (Ta # uu_) (Ct uv_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ (decr 0 (Ct uv_ T)) = Some \\<tau>\n 2. \\<And>Ts i T \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Bv i) 0;\n        typ_of1 (T # Ts) (Bv i) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (Bv i)) = Some \\<tau>\n 3. \\<And>uw_ ux_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Fv ux_ T) 0;\n        typ_of1 (Ta # uw_) (Fv ux_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ (decr 0 (Fv ux_ T)) = Some \\<tau>\n 4. \\<And>Ts t u T \\<tau>.\n       \\<lbrakk>\\<And>T \\<tau>.\n                   \\<lbrakk>\\<not> loose_bvar1 u 0;\n                    typ_of1 (T # Ts) u = Some \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> typ_of1 Ts (decr 0 u) = Some \\<tau>;\n        \\<And>a T \\<tau>.\n           \\<lbrakk>typ_of1 Ts u = Some a; \\<not> loose_bvar1 t 0;\n            typ_of1 (T # Ts) t = Some \\<tau>\\<rbrakk>\n           \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some \\<tau>;\n        \\<not> loose_bvar1 (t $ u) 0;\n        typ_of1 (T # Ts) (t $ u) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (t $ u)) = Some \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> loose_bvar1 u 0;\n   typ_of1 (?T # Ts) u = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts (decr 0 u) = Some ?\\<tau>\n  \\<lbrakk>typ_of1 Ts u = Some ?a; \\<not> loose_bvar1 f 0;\n   typ_of1 (?T # Ts) f = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts (decr 0 f) = Some ?\\<tau>\n  \\<not> loose_bvar1 (f $ u) 0\n  typ_of1 (T # Ts) (f $ u) = Some \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> loose_bvar1 u 0;\n   typ_of1 (?T # Ts) u = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts (decr 0 u) = Some ?\\<tau>\n  \\<lbrakk>typ_of1 Ts u = Some ?a; \\<not> loose_bvar1 f 0;\n   typ_of1 (?T # Ts) f = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 Ts (decr 0 f) = Some ?\\<tau>\n  \\<not> loose_bvar1 (f $ u) 0\n  typ_of1 (T # Ts) (f $ u) = Some \\<tau>\n\ngoal (1 subgoal):\n 1. typ_of1 Ts (decr 0 (f $ u)) = Some \\<tau>", "apply (simp add: bind_eq_Some_conv split: if_splits option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>T \\<tau>.\n                typ_of1 (T # Ts) u = Some \\<tau> \\<Longrightarrow>\n                typ_of1 Ts (decr 0 u) = Some \\<tau>;\n     \\<And>a T \\<tau>.\n        \\<lbrakk>typ_of1 Ts u = Some a;\n         typ_of1 (T # Ts) f = Some \\<tau>\\<rbrakk>\n        \\<Longrightarrow> typ_of1 Ts (decr 0 f) = Some \\<tau>;\n     \\<not> loose_bvar1 f 0 \\<and> \\<not> loose_bvar1 u 0;\n     \\<exists>y.\n        typ_of1 (T # Ts) u = Some y \\<and>\n        (\\<exists>ya.\n            typ_of1 (T # Ts) f = Some ya \\<and>\n            (case ya of Ty fun [] \\<Rightarrow> None\n             | Ty fun [T1] \\<Rightarrow> None\n             | Ty fun [T1, T2] \\<Rightarrow>\n                 if fun = STR ''fun'' then if T1 = y then Some T2 else None\n                 else None\n             | Ty fun (T1 # T2 # ab # xa) \\<Rightarrow> Map.empty xa\n             | Tv variable x \\<Rightarrow> Map.empty x) =\n            Some \\<tau>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y.\n                         typ_of1 Ts (decr 0 u) = Some y \\<and>\n                         (\\<exists>ya.\n                             typ_of1 Ts (decr 0 f) = Some ya \\<and>\n                             (case ya of Ty fun [] \\<Rightarrow> None\n                              | Ty fun [T1] \\<Rightarrow> None\n                              | Ty fun [T1, T2] \\<Rightarrow>\n                                  if fun = STR ''fun''\n                                  then if T1 = y then Some T2 else None\n                                  else None\n                              | Ty fun (T1 # T2 # ab # xa) \\<Rightarrow>\n                                  Map.empty xa\n                              | Tv variable x \\<Rightarrow> Map.empty x) =\n                             Some \\<tau>)", "by (smt no_loose_bvar1_subst_bv2_decr subst_bv_def substn_subst_0' typ_of1.simps(3) typ_of1_subst_bv_gen')"], ["proof (state)\nthis:\n  typ_of1 Ts (decr 0 (f $ u)) = Some \\<tau>\n\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Ct uv_ T) 0;\n        typ_of1 (Ta # uu_) (Ct uv_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uu_ (decr 0 (Ct uv_ T)) = Some \\<tau>\n 2. \\<And>Ts i T \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Bv i) 0;\n        typ_of1 (T # Ts) (Bv i) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 Ts (decr 0 (Bv i)) = Some \\<tau>\n 3. \\<And>uw_ ux_ T Ta \\<tau>.\n       \\<lbrakk>\\<not> loose_bvar1 (Fv ux_ T) 0;\n        typ_of1 (Ta # uw_) (Fv ux_ T) = Some \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of1 uw_ (decr 0 (Fv ux_ T)) = Some \\<tau>", "qed (auto simp add: bind_eq_Some_conv split: if_splits option.splits)"], ["", "lemma typ_of1_eta_red_step_pre: \"\\<not> loose_bvar1 t 0 \\<Longrightarrow> \n  typ_of1 Ts (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>') \\<Longrightarrow> typ_of1 Ts (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> loose_bvar1 t 0;\n     typ_of1 Ts (Abs \\<tau> (t $ Bv 0)) =\n     Some (\\<tau> \\<rightarrow> \\<tau>')\\<rbrakk>\n    \\<Longrightarrow> typ_of1 Ts (decr 0 t) =\n                      Some (\\<tau> \\<rightarrow> \\<tau>')", "using typ_of1_decr'"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> loose_bvar1 ?t 0;\n   typ_of1 (?T # ?Ts) ?t = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of1 ?Ts (decr 0 ?t) = Some ?\\<tau>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> loose_bvar1 t 0;\n     typ_of1 Ts (Abs \\<tau> (t $ Bv 0)) =\n     Some (\\<tau> \\<rightarrow> \\<tau>')\\<rbrakk>\n    \\<Longrightarrow> typ_of1 Ts (decr 0 t) =\n                      Some (\\<tau> \\<rightarrow> \\<tau>')", "by (smt length_Cons nth_Cons_0 typ_of1.simps(2) typ_of1_arg_typ typ_of_Abs_body_typ' zero_less_Suc)"], ["", "lemma typ_of1_eta_red_step: \"\\<not> is_dependent t \\<Longrightarrow> \n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>') \\<Longrightarrow> typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_dependent t;\n     typ_of (Abs \\<tau> (t $ Bv 0)) =\n     Some (\\<tau> \\<rightarrow> \\<tau>')\\<rbrakk>\n    \\<Longrightarrow> typ_of (decr 0 t) =\n                      Some (\\<tau> \\<rightarrow> \\<tau>')", "using typ_of_def is_dependent_def typ_of1_eta_red_step_pre"], ["proof (prove)\nusing this:\n  typ_of ?t \\<equiv> typ_of1 [] ?t\n  is_dependent ?t \\<equiv> loose_bvar1 ?t 0\n  \\<lbrakk>\\<not> loose_bvar1 ?t 0;\n   typ_of1 ?Ts (Abs ?\\<tau> (?t $ Bv 0)) =\n   Some (?\\<tau> \\<rightarrow> ?\\<tau>')\\<rbrakk>\n  \\<Longrightarrow> typ_of1 ?Ts (decr 0 ?t) =\n                    Some (?\\<tau> \\<rightarrow> ?\\<tau>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_dependent t;\n     typ_of (Abs \\<tau> (t $ Bv 0)) =\n     Some (\\<tau> \\<rightarrow> \\<tau>')\\<rbrakk>\n    \\<Longrightarrow> typ_of (decr 0 t) =\n                      Some (\\<tau> \\<rightarrow> \\<tau>')", "by simp"], ["", "(* MOVE *)"], ["", "lemma distinct_add_vars': \"distinct acc \\<Longrightarrow> distinct (add_vars' t acc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct acc \\<Longrightarrow> distinct (add_vars' t acc)", "unfolding add_vars'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct acc \\<Longrightarrow>\n    distinct\n     (fold_aterms\n       (\\<lambda>x l.\n           case x of Fv idn s \\<Rightarrow> List.insert (idn, s) l\n           | _ \\<Rightarrow> l)\n       t acc)", "by (induction t arbitrary: acc) auto"], ["", "lemma distinct_add_tvarsT': \"distinct acc \\<Longrightarrow> distinct (add_tvarsT' T acc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct acc \\<Longrightarrow> distinct (add_tvarsT' T acc)", "proof (induction T arbitrary: acc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 acc.\n       \\<lbrakk>\\<And>x2a acc.\n                   \\<lbrakk>x2a \\<in> set x2; distinct acc\\<rbrakk>\n                   \\<Longrightarrow> distinct (add_tvarsT' x2a acc);\n        distinct acc\\<rbrakk>\n       \\<Longrightarrow> distinct (add_tvarsT' (Ty x1 x2) acc)\n 2. \\<And>x1 x2 acc.\n       distinct acc \\<Longrightarrow> distinct (add_tvarsT' (Tv x1 x2) acc)", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; distinct ?acc\\<rbrakk>\n  \\<Longrightarrow> distinct (add_tvarsT' ?x2a ?acc)\n  distinct acc\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 acc.\n       \\<lbrakk>\\<And>x2a acc.\n                   \\<lbrakk>x2a \\<in> set x2; distinct acc\\<rbrakk>\n                   \\<Longrightarrow> distinct (add_tvarsT' x2a acc);\n        distinct acc\\<rbrakk>\n       \\<Longrightarrow> distinct (add_tvarsT' (Ty x1 x2) acc)\n 2. \\<And>x1 x2 acc.\n       distinct acc \\<Longrightarrow> distinct (add_tvarsT' (Tv x1 x2) acc)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts; distinct ?acc\\<rbrakk>\n  \\<Longrightarrow> distinct (add_tvarsT' ?x2a ?acc)\n  distinct acc", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts; distinct ?acc\\<rbrakk>\n  \\<Longrightarrow> distinct (add_tvarsT' ?x2a ?acc)\n  distinct acc\n\ngoal (1 subgoal):\n 1. distinct (add_tvarsT' (Ty n Ts) acc)", "by (induction Ts rule: rev_induct) (auto simp add: add_tvarsT'_def)"], ["proof (state)\nthis:\n  distinct (add_tvarsT' (Ty n Ts) acc)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 acc.\n       distinct acc \\<Longrightarrow> distinct (add_tvarsT' (Tv x1 x2) acc)", "qed (simp add: add_tvarsT'_def)"], ["", "lemma distinct_add_tvars': \"distinct acc \\<Longrightarrow> distinct (add_tvars' t acc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct acc \\<Longrightarrow> distinct (add_tvars' t acc)", "by (induction t arbitrary: acc) (simp_all add: add_tvars'_def fold_types_def distinct_add_tvarsT')"], ["", "(* Figure out better syntax for goal *)"], ["", "lemma proved_terms_well_formed_pre: \"\\<Theta>, \\<Gamma> \\<turnstile> p \\<Longrightarrow> typ_of p = Some propT \\<and> term_ok \\<Theta> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> p \\<Longrightarrow>\n    typ_of p = Some propT \\<and> term_ok \\<Theta> p", "proof (induction \\<Gamma> p rule: proves.induct)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "case (axiom A \\<rho>)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> \\<rho>\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "from axiom"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> \\<rho>", "have ty: \"typ_of1 [] A = Some propT\""], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> \\<rho>\n\ngoal (1 subgoal):\n 1. typ_of1 [] A = Some propT", "by (cases \\<Theta> rule: theory_full_exhaust) (simp add: wt_term_def typ_of_def)"], ["proof (state)\nthis:\n  typ_of1 [] A = Some propT\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "let ?l = \"add_tvars' A []\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "let ?l' = \"map (\\<lambda>(v, S) . ((v, S), \\<rho> v S)) ?l\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "have dist: \"distinct ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (add_tvars' A [])", "using distinct_add_tvars'"], ["proof (prove)\nusing this:\n  distinct ?acc \\<Longrightarrow> distinct (add_tvars' ?t ?acc)\n\ngoal (1 subgoal):\n 1. distinct (add_tvars' A [])", "by simp"], ["proof (state)\nthis:\n  distinct (add_tvars' A [])\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "moreover"], ["proof (state)\nthis:\n  distinct (add_tvars' A [])\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "have \"\\<forall>(v, S) \\<in> set ?l . typ_ok \\<Theta> (Tv v S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)", "have \"typ_ok \\<Theta> (Tv v T)\" if \"(v, T) \\<in> tvs A\" for v T"], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (Tv v T)", "using axiom.hyps(1) axiom.hyps(2) axioms_terms_ok\n        term_ok_tvars_sort_ok that typ_ok_def typ_ok_Tv"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  \\<lbrakk>wf_theory ?thy; ?A \\<in> axioms ?thy\\<rbrakk>\n  \\<Longrightarrow> term_ok ?thy ?A\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok ?\\<Theta> ?t;\n   (?x, ?S) \\<in> tvs ?t\\<rbrakk>\n  \\<Longrightarrow> wf_sort (subclass (osig (sig ?\\<Theta>))) ?S\n  (v, T) \\<in> tvs A\n  typ_ok ?\\<Theta> ?T \\<equiv> wf_type (sig ?\\<Theta>) ?T\n  wf_sort (subclass (osig ?\\<Sigma>)) ?S \\<Longrightarrow>\n  wf_type ?\\<Sigma> (Tv ?a ?S)\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (Tv v T)", "by (meson wf_sort_def)"], ["proof (state)\nthis:\n  (?v, ?T) \\<in> tvs A \\<Longrightarrow> typ_ok \\<Theta> (Tv ?v ?T)\n\ngoal (1 subgoal):\n 1. \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)", "moreover"], ["proof (state)\nthis:\n  (?v, ?T) \\<in> tvs A \\<Longrightarrow> typ_ok \\<Theta> (Tv ?v ?T)\n\ngoal (1 subgoal):\n 1. \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)", "have \"set ?l = tvs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (add_tvars' A []) = tvs A", "by auto"], ["proof (state)\nthis:\n  set (add_tvars' A []) = tvs A\n\ngoal (1 subgoal):\n 1. \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)", "ultimately"], ["proof (chain)\npicking this:\n  (?v, ?T) \\<in> tvs A \\<Longrightarrow> typ_ok \\<Theta> (Tv ?v ?T)\n  set (add_tvars' A []) = tvs A", "show ?thesis"], ["proof (prove)\nusing this:\n  (?v, ?T) \\<in> tvs A \\<Longrightarrow> typ_ok \\<Theta> (Tv ?v ?T)\n  set (add_tvars' A []) = tvs A\n\ngoal (1 subgoal):\n 1. \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)", "by auto"], ["proof (state)\nthis:\n  \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "moreover"], ["proof (state)\nthis:\n  \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "hence \"\\<forall>(v, S) \\<in> set ?l . has_sort (osig (sig \\<Theta>)) (Tv v S) S\""], ["proof (prove)\nusing this:\n  \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)\n\ngoal (1 subgoal):\n 1. \\<forall>(v, S)\\<in>set (add_tvars' A []).\n       has_sort (osig (sig \\<Theta>)) (Tv v S) S", "using axiom.hyps(1) has_sort_Tv_refl'"], ["proof (prove)\nusing this:\n  \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)\n  wf_theory \\<Theta>\n  \\<lbrakk>wf_theory ?\\<Theta>; typ_ok ?\\<Theta> (Tv ?v ?S)\\<rbrakk>\n  \\<Longrightarrow> has_sort (osig (sig ?\\<Theta>)) (Tv ?v ?S) ?S\n\ngoal (1 subgoal):\n 1. \\<forall>(v, S)\\<in>set (add_tvars' A []).\n       has_sort (osig (sig \\<Theta>)) (Tv v S) S", "by blast"], ["proof (state)\nthis:\n  \\<forall>(v, S)\\<in>set (add_tvars' A []).\n     has_sort (osig (sig \\<Theta>)) (Tv v S) S\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "ultimately"], ["proof (chain)\npicking this:\n  distinct (add_tvars' A [])\n  \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)\n  \\<forall>(v, S)\\<in>set (add_tvars' A []).\n     has_sort (osig (sig \\<Theta>)) (Tv v S) S", "have \"inst_ok \\<Theta> ?l'\""], ["proof (prove)\nusing this:\n  distinct (add_tvars' A [])\n  \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S)\n  \\<forall>(v, S)\\<in>set (add_tvars' A []).\n     has_sort (osig (sig \\<Theta>)) (Tv v S) S\n\ngoal (1 subgoal):\n 1. inst_ok \\<Theta>\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A []))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (add_tvars' A []);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []).\n        has_sort (osig (sig \\<Theta>)) (Tv v S) S\\<rbrakk>\n    \\<Longrightarrow> inst_ok \\<Theta>\n                       (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                         (add_tvars' A []))", "apply (rule wf_inst_imp_inst_ok)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>distinct (add_tvars' A []);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []).\n        has_sort (osig (sig \\<Theta>)) (Tv v S) S\\<rbrakk>\n    \\<Longrightarrow> wf_theory \\<Theta>\n 2. \\<lbrakk>distinct (add_tvars' A []);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []).\n        has_sort (osig (sig \\<Theta>)) (Tv v S) S\\<rbrakk>\n    \\<Longrightarrow> distinct (add_tvars' A [])\n 3. \\<lbrakk>distinct (add_tvars' A []);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []).\n        has_sort (osig (sig \\<Theta>)) (Tv v S) S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(v, S)\\<in>set (add_tvars' A []).\n                         typ_ok \\<Theta> (Tv v S)\n 4. \\<lbrakk>distinct (add_tvars' A []);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []).\n        has_sort (osig (sig \\<Theta>)) (Tv v S) S\\<rbrakk>\n    \\<Longrightarrow> wf_inst \\<Theta> \\<rho>", "using axiom.hyps(1) axiom.hyps(3)"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wf_inst \\<Theta> \\<rho>\n\ngoal (4 subgoals):\n 1. \\<lbrakk>distinct (add_tvars' A []);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []).\n        has_sort (osig (sig \\<Theta>)) (Tv v S) S\\<rbrakk>\n    \\<Longrightarrow> wf_theory \\<Theta>\n 2. \\<lbrakk>distinct (add_tvars' A []);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []).\n        has_sort (osig (sig \\<Theta>)) (Tv v S) S\\<rbrakk>\n    \\<Longrightarrow> distinct (add_tvars' A [])\n 3. \\<lbrakk>distinct (add_tvars' A []);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []).\n        has_sort (osig (sig \\<Theta>)) (Tv v S) S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>(v, S)\\<in>set (add_tvars' A []).\n                         typ_ok \\<Theta> (Tv v S)\n 4. \\<lbrakk>distinct (add_tvars' A []);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []). typ_ok \\<Theta> (Tv v S);\n     \\<forall>(v, S)\\<in>set (add_tvars' A []).\n        has_sort (osig (sig \\<Theta>)) (Tv v S) S\\<rbrakk>\n    \\<Longrightarrow> wf_inst \\<Theta> \\<rho>", "by blast+"], ["proof (state)\nthis:\n  inst_ok \\<Theta>\n   (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A []))\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "have simp: \"tsubst A \\<rho> = subst_typ' ?l' A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tsubst A \\<rho> =\n    subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A", "using dist subst_typ'_simulates_tsubst_gen'"], ["proof (prove)\nusing this:\n  distinct (add_tvars' A [])\n  \\<lbrakk>distinct ?pairs; tvs ?t \\<subseteq> set ?pairs\\<rbrakk>\n  \\<Longrightarrow> tsubst ?t ?\\<rho> =\n                    subst_typ'\n                     (map (\\<lambda>(x, y). ((x, y), ?\\<rho> x y)) ?pairs)\n                     ?t\n\ngoal (1 subgoal):\n 1. tsubst A \\<rho> =\n    subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A", "by auto"], ["proof (state)\nthis:\n  tsubst A \\<rho> =\n  subst_typ' (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A []))\n   A\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "have \"typ_of1 [] (tsubst A \\<rho>) = Some propT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of1 [] (tsubst A \\<rho>) = Some propT", "using tsubst_simulates_subst_typ' axioms_typ_of_propT typ_of1_tsubst ty"], ["proof (prove)\nusing this:\n  subst_typ' ?insts ?T =\n  tsubst ?T\n   (\\<lambda>idn S.\n       the_default (Tv idn S) (lookup (\\<lambda>x. x = (idn, S)) ?insts))\n  \\<lbrakk>wf_theory ?thy; ?A \\<in> axioms ?thy\\<rbrakk>\n  \\<Longrightarrow> typ_of ?A = Some propT\n  typ_of1 ?Ts ?t = Some ?ty \\<Longrightarrow>\n  typ_of1 (map (\\<lambda>T. tsubstT T ?\\<rho>) ?Ts) (tsubst ?t ?\\<rho>) =\n  Some (tsubstT ?ty ?\\<rho>)\n  typ_of1 [] A = Some propT\n\ngoal (1 subgoal):\n 1. typ_of1 [] (tsubst A \\<rho>) = Some propT", "by fastforce"], ["proof (state)\nthis:\n  typ_of1 [] (tsubst A \\<rho>) = Some propT\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "hence 1: \"typ_of1 [] (subst_typ' ?l' A) = Some propT\""], ["proof (prove)\nusing this:\n  typ_of1 [] (tsubst A \\<rho>) = Some propT\n\ngoal (1 subgoal):\n 1. typ_of1 []\n     (subst_typ'\n       (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A) =\n    Some propT", "using simp"], ["proof (prove)\nusing this:\n  typ_of1 [] (tsubst A \\<rho>) = Some propT\n  tsubst A \\<rho> =\n  subst_typ' (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A []))\n   A\n\ngoal (1 subgoal):\n 1. typ_of1 []\n     (subst_typ'\n       (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A) =\n    Some propT", "by simp"], ["proof (state)\nthis:\n  typ_of1 []\n   (subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A) =\n  Some propT\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "from axiom"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> \\<rho>", "have \"term_ok' (sig \\<Theta>) A\""], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> \\<rho>\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) A", "by (cases \\<Theta> rule: theory_full_exhaust) (simp add: wt_term_def)"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) A\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "hence 2: \"term_ok' (sig \\<Theta>) (subst_typ' ?l' A)\""], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) A\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>)\n     (subst_typ'\n       (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A)", "using axiom term_ok'_subst_typ'"], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) A\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> \\<rho>\n  \\<lbrakk>is_std_sig ?\\<Sigma>; term_ok' ?\\<Sigma> ?t;\n   distinct (map fst ?insts);\n   list_all (typ_ok_sig ?\\<Sigma>) (map snd ?insts)\\<rbrakk>\n  \\<Longrightarrow> term_ok' ?\\<Sigma> (subst_typ' ?insts ?t)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>)\n     (subst_typ'\n       (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A)", "apply (cases \\<Theta> rule: theory_full_exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cto tao sorts axiomsa.\n       \\<lbrakk>term_ok' (sig \\<Theta>) A; wf_theory \\<Theta>;\n        A \\<in> axioms \\<Theta>; wf_inst \\<Theta> \\<rho>;\n        \\<And>\\<Sigma> t insts.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n            distinct (map fst insts);\n            list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n           \\<Longrightarrow> term_ok' \\<Sigma> (subst_typ' insts t);\n        \\<Theta> = ((cto, tao, sorts), axiomsa)\\<rbrakk>\n       \\<Longrightarrow> term_ok' (sig \\<Theta>)\n                          (subst_typ'\n                            (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                              (add_tvars' A []))\n                            A)", "apply (simp add: list_all_iff wt_term_def typ_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cto tao sorts axioms.\n       \\<lbrakk>(\\<forall>p\\<in>axioms.\n                    term_ok' (cto, tao, sorts) p \\<and>\n                    (\\<exists>T. typ_of1 [] p = Some T) \\<and>\n                    typ_of1 [] p = Some propT) \\<and>\n                tao STR ''fun'' = Some 2 \\<and>\n                tao STR ''prop'' = Some 0 \\<and>\n                tao STR ''itself'' = Some (Suc 0) \\<and>\n                cto STR ''Pure.eq'' =\n                Some\n                 (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT) \\<and>\n                cto STR ''Pure.all'' =\n                Some\n                 ((Core.aT \\<rightarrow> propT) \\<rightarrow> propT) \\<and>\n                cto STR ''Pure.imp'' =\n                Some (propT \\<rightarrow> propT \\<rightarrow> propT) \\<and>\n                cto STR ''Pure.type'' = Some (itselfT Core.aT) \\<and>\n                wf_osig sorts \\<and>\n                dom (tcsigs sorts) = dom tao \\<and>\n                (\\<forall>type\\<in>dom (tcsigs sorts).\n                    \\<forall>ars\\<in>ran (the (tcsigs sorts type)).\n                       the (tao type) = length ars) \\<and>\n                (\\<forall>x\\<in>ran cto.\n                    typ_ok_sig (cto, tao, sorts) x) \\<and>\n                eq_reflexive_ax \\<in> axioms \\<and>\n                eq_symmetric_ax \\<in> axioms \\<and>\n                eq_transitive_ax \\<in> axioms \\<and>\n                eq_intr_ax \\<in> axioms \\<and>\n                eq_elim_ax \\<in> axioms \\<and>\n                eq_combination_ax \\<in> axioms \\<and>\n                eq_abstract_rule_ax \\<in> axioms;\n        A \\<in> axioms;\n        \\<forall>v S.\n           \\<rho> v S \\<noteq> Tv v S \\<longrightarrow>\n           has_sort sorts (\\<rho> v S) S \\<and>\n           typ_ok_sig (cto, tao, sorts) (\\<rho> v S);\n        \\<And>\\<Sigma> t insts.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n            distinct (map fst insts);\n            \\<forall>x\\<in>set insts. typ_ok_sig \\<Sigma> (snd x)\\<rbrakk>\n           \\<Longrightarrow> term_ok' \\<Sigma> (subst_typ' insts t);\n        \\<Theta> = ((cto, tao, sorts), axioms)\\<rbrakk>\n       \\<Longrightarrow> term_ok' (cto, tao, sorts)\n                          (subst_typ'\n                            (map (\\<lambda>(v, S). ((v, S), \\<rho> v S))\n                              (add_tvars' A []))\n                            A)", "by (metis (no_types, lifting) \\<open>inst_ok \\<Theta> (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A []))\\<close> \n        axiom.hyps(1) list.pred_mono_strong sig.simps term_ok'_subst_typ' wf_theory.simps\n        typ_ok_def wf_type_imp_typ_ok_sig)"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>)\n   (subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A)\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>\\<rbrakk>\n       \\<Longrightarrow> typ_of (tsubst A \\<rho>) = Some propT \\<and>\n                         term_ok \\<Theta> (tsubst A \\<rho>)\n 2. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 3. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 4. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 5. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 7. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 8. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "from 1 2"], ["proof (chain)\npicking this:\n  typ_of1 []\n   (subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A) =\n  Some propT\n  term_ok' (sig \\<Theta>)\n   (subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A)", "show ?case"], ["proof (prove)\nusing this:\n  typ_of1 []\n   (subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A) =\n  Some propT\n  term_ok' (sig \\<Theta>)\n   (subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A)\n\ngoal (1 subgoal):\n 1. typ_of (tsubst A \\<rho>) = Some propT \\<and>\n    term_ok \\<Theta> (tsubst A \\<rho>)", "using simp"], ["proof (prove)\nusing this:\n  typ_of1 []\n   (subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A) =\n  Some propT\n  term_ok' (sig \\<Theta>)\n   (subst_typ'\n     (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A [])) A)\n  tsubst A \\<rho> =\n  subst_typ' (map (\\<lambda>(v, S). ((v, S), \\<rho> v S)) (add_tvars' A []))\n   A\n\ngoal (1 subgoal):\n 1. typ_of (tsubst A \\<rho>) = Some propT \\<and>\n    term_ok \\<Theta> (tsubst A \\<rho>)", "by (simp add: wt_term_def typ_of_def)"], ["proof (state)\nthis:\n  typ_of (tsubst A \\<rho>) = Some propT \\<and>\n  term_ok \\<Theta> (tsubst A \\<rho>)\n\ngoal (8 subgoals):\n 1. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 2. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 3. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 4. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 5. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 6. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 7. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 8. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 2. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 3. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 4. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 5. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 6. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 7. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 8. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "case (\"assume\" A)"], ["proof (state)\nthis:\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  A \\<in> \\<Gamma>_\n\ngoal (8 subgoals):\n 1. \\<And>A \\<Gamma>.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> typ_of A = Some propT \\<and> term_ok \\<Theta> A\n 2. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 3. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 4. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 5. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 6. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 7. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 8. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "then"], ["proof (chain)\npicking this:\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  A \\<in> \\<Gamma>_", "show ?case"], ["proof (prove)\nusing this:\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  A \\<in> \\<Gamma>_\n\ngoal (1 subgoal):\n 1. typ_of A = Some propT \\<and> term_ok \\<Theta> A", "by (simp add: wt_term_def)"], ["proof (state)\nthis:\n  typ_of A = Some propT \\<and> term_ok \\<Theta> A\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 2. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 3. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 5. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 6. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 2. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 3. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 5. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 6. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "(*Same as case above*)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 2. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 3. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 5. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 6. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "case (forall_intro \\<Gamma> B x \\<tau>)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  (x, \\<tau>) \\<notin> FV \\<Gamma>\n  wf_type (sig \\<Theta>) \\<tau>\n  typ_of B = Some propT \\<and> term_ok \\<Theta> B\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 2. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 3. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 5. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 6. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "hence \"term_ok' (sig \\<Theta>) B\" and \"typ_of B = Some propT\""], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  (x, \\<tau>) \\<notin> FV \\<Gamma>\n  wf_type (sig \\<Theta>) \\<tau>\n  typ_of B = Some propT \\<and> term_ok \\<Theta> B\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) B &&& typ_of B = Some propT", "by (simp_all add: wt_term_def)"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) B\n  typ_of B = Some propT\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau>.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>;\n        wf_type (sig \\<Theta>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_all x \\<tau> B)\n 2. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 3. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 5. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 6. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n    term_ok \\<Theta> (mk_all x \\<tau> B)", "using typ_of_mk_all forall_intro\n      term_ok_mk_all[OF \\<open>wf_theory \\<Theta>\\<close> \\<open>term_ok' (sig \\<Theta>) B\\<close> \n        \\<open>typ_of B = Some propT\\<close> _, of _ x] \\<open>wf_type (sig \\<Theta>) \\<tau>\\<close>"], ["proof (prove)\nusing this:\n  typ_of ?A = Some propT \\<Longrightarrow>\n  typ_of (mk_all ?x ?ty ?A) = Some propT\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  (x, \\<tau>) \\<notin> FV \\<Gamma>\n  wf_type (sig \\<Theta>) \\<tau>\n  typ_of B = Some propT \\<and> term_ok \\<Theta> B\n  typ_ok \\<Theta> ?\\<tau> \\<Longrightarrow>\n  term_ok \\<Theta> (mk_all x ?\\<tau> B)\n  wf_type (sig \\<Theta>) \\<tau>\n\ngoal (1 subgoal):\n 1. typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n    term_ok \\<Theta> (mk_all x \\<tau> B)", "by auto"], ["proof (state)\nthis:\n  typ_of (mk_all x \\<tau> B) = Some propT \\<and>\n  term_ok \\<Theta> (mk_all x \\<tau> B)\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 2. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 3. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 4. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 5. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 6. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 2. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 3. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 4. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 5. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 6. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "case (forall_elim \\<Gamma> \\<tau> B a)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                                  ((\\<tau> \\<rightarrow>\n                                    propT) \\<rightarrow>\n                                   propT) $\n                                 Abs \\<tau> B\n  \\<turnstile>\\<^sub>\\<tau> a : \\<tau>\n  wf_term (sig \\<Theta>) a\n  typ_of\n   (Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> B) =\n  Some propT \\<and>\n  term_ok \\<Theta>\n   (Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> B)\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> B a.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        typ_of\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B) =\n        Some propT \\<and>\n        term_ok \\<Theta>\n         (Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B);\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n        wf_term (sig \\<Theta>) a\\<rbrakk>\n       \\<Longrightarrow> typ_of (subst_bv a B) = Some propT \\<and>\n                         term_ok \\<Theta> (subst_bv a B)\n 2. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 3. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 4. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 5. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 6. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                                  ((\\<tau> \\<rightarrow>\n                                    propT) \\<rightarrow>\n                                   propT) $\n                                 Abs \\<tau> B\n  \\<turnstile>\\<^sub>\\<tau> a : \\<tau>\n  wf_term (sig \\<Theta>) a\n  typ_of\n   (Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> B) =\n  Some propT \\<and>\n  term_ok \\<Theta>\n   (Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> B)\n\ngoal (1 subgoal):\n 1. typ_of (subst_bv a B) = Some propT \\<and>\n    term_ok \\<Theta> (subst_bv a B)", "using term_ok'_subst_bv1"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                                  ((\\<tau> \\<rightarrow>\n                                    propT) \\<rightarrow>\n                                   propT) $\n                                 Abs \\<tau> B\n  \\<turnstile>\\<^sub>\\<tau> a : \\<tau>\n  wf_term (sig \\<Theta>) a\n  typ_of\n   (Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> B) =\n  Some propT \\<and>\n  term_ok \\<Theta>\n   (Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> B)\n  \\<lbrakk>term_ok' (sig ?\\<Theta>) ?f; term_ok' (sig ?\\<Theta>) ?u\\<rbrakk>\n  \\<Longrightarrow> term_ok' (sig ?\\<Theta>) (subst_bv1 ?f ?lev ?u)\n\ngoal (1 subgoal):\n 1. typ_of (subst_bv a B) = Some propT \\<and>\n    term_ok \\<Theta> (subst_bv a B)", "by (auto simp add: typ_of_def term_ok'_subst_bv tinstT_def \n        wt_term_def bind_eq_Some_conv subst_bv_def typ_of1_subst_bv_gen' \n        split: if_splits option.splits)"], ["proof (state)\nthis:\n  typ_of (subst_bv a B) = Some propT \\<and> term_ok \\<Theta> (subst_bv a B)\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 2. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 3. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 4. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 5. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 2. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 3. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 4. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 5. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "case (implies_intro \\<Gamma> B A)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  typ_of B = Some propT \\<and> term_ok \\<Theta> B\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> B A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        typ_of B = Some propT \\<and> term_ok \\<Theta> B;\n        wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT\\<rbrakk>\n       \\<Longrightarrow> typ_of (A \\<longmapsto> B) = Some propT \\<and>\n                         term_ok \\<Theta> (A \\<longmapsto> B)\n 2. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 3. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 4. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 5. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  typ_of B = Some propT \\<and> term_ok \\<Theta> B", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  typ_of B = Some propT \\<and> term_ok \\<Theta> B\n\ngoal (1 subgoal):\n 1. typ_of (A \\<longmapsto> B) = Some propT \\<and>\n    term_ok \\<Theta> (A \\<longmapsto> B)", "by (cases \\<Theta> rule: wf_theory.cases) (auto simp add: typ_of_def wt_term_def tinstT_def)"], ["proof (state)\nthis:\n  typ_of (A \\<longmapsto> B) = Some propT \\<and>\n  term_ok \\<Theta> (A \\<longmapsto> B)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 2. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 3. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 4. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 2. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 3. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 4. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "case (implies_elim \\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B\n  \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A\n  typ_of (A \\<longmapsto> B) = Some propT \\<and>\n  term_ok \\<Theta> (A \\<longmapsto> B)\n  typ_of A = Some propT \\<and> term_ok \\<Theta> A\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        typ_of (A \\<longmapsto> B) = Some propT \\<and>\n        term_ok \\<Theta> (A \\<longmapsto> B);\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        typ_of A = Some propT \\<and> term_ok \\<Theta> A\\<rbrakk>\n       \\<Longrightarrow> typ_of B = Some propT \\<and> term_ok \\<Theta> B\n 2. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 3. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 4. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "then"], ["proof (chain)\npicking this:\n  \\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B\n  \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A\n  typ_of (A \\<longmapsto> B) = Some propT \\<and>\n  term_ok \\<Theta> (A \\<longmapsto> B)\n  typ_of A = Some propT \\<and> term_ok \\<Theta> A", "show ?case"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B\n  \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A\n  typ_of (A \\<longmapsto> B) = Some propT \\<and>\n  term_ok \\<Theta> (A \\<longmapsto> B)\n  typ_of A = Some propT \\<and> term_ok \\<Theta> A\n\ngoal (1 subgoal):\n 1. typ_of B = Some propT \\<and> term_ok \\<Theta> B", "by (auto simp add: bind_eq_Some_conv typ_of_def wt_term_def tinstT_def \n        split: option.splits if_splits)"], ["proof (state)\nthis:\n  typ_of B = Some propT \\<and> term_ok \\<Theta> B\n\ngoal (3 subgoals):\n 1. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 2. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 3. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 2. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 3. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "case (of_class c iT T)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  const_type (sig \\<Theta>) (const_of_class c) =\n  Some (itselfT Core.aT \\<rightarrow> propT)\n  wf_type (sig \\<Theta>) iT\n  has_sort (osig (sig \\<Theta>)) iT (insert c full_sort)\n\ngoal (3 subgoals):\n 1. \\<And>c T \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort)\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_of_class T c) = Some propT \\<and>\n                         term_ok \\<Theta> (mk_of_class T c)\n 2. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 3. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  const_type (sig \\<Theta>) (const_of_class c) =\n  Some (itselfT Core.aT \\<rightarrow> propT)\n  wf_type (sig \\<Theta>) iT\n  has_sort (osig (sig \\<Theta>)) iT (insert c full_sort)", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  const_type (sig \\<Theta>) (const_of_class c) =\n  Some (itselfT Core.aT \\<rightarrow> propT)\n  wf_type (sig \\<Theta>) iT\n  has_sort (osig (sig \\<Theta>)) iT (insert c full_sort)\n\ngoal (1 subgoal):\n 1. typ_of (mk_of_class iT c) = Some propT \\<and>\n    term_ok \\<Theta> (mk_of_class iT c)", "by (cases \\<Theta> rule: theory_full_exhaust)  \n      (auto simp add: bind_eq_Some_conv typ_of_def wt_term_def \n        tinstT_def mk_of_class_def mk_type_def)"], ["proof (state)\nthis:\n  typ_of (mk_of_class iT c) = Some propT \\<and>\n  term_ok \\<Theta> (mk_of_class iT c)\n\ngoal (2 subgoals):\n 1. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 2. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 2. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "case (\\<beta>_conversion T t x)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  wt_term (sig \\<Theta>) (Abs T t)\n  wf_term (sig \\<Theta>) x\n  \\<turnstile>\\<^sub>\\<tau> x : T\n\ngoal (2 subgoals):\n 1. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 2. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "hence 1: \"typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) = Some propT\""], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wt_term (sig \\<Theta>) (Abs T t)\n  wf_term (sig \\<Theta>) x\n  \\<turnstile>\\<^sub>\\<tau> x : T\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) = Some propT", "by (auto simp add: typ_of_def wt_term_def subst_bv_def bind_eq_Some_conv \n        typ_of1_subst_bv_gen')"], ["proof (state)\nthis:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) = Some propT\n\ngoal (2 subgoals):\n 1. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 2. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "moreover"], ["proof (state)\nthis:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) = Some propT\n\ngoal (2 subgoals):\n 1. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 2. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "have \"term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "have \"typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) \\<noteq> None", "using 1"], ["proof (prove)\nusing this:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) = Some propT\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) \\<noteq> None\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "(* This needs to be moved out *)"], ["proof (state)\nthis:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) \\<noteq> None\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "moreover"], ["proof (state)\nthis:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) \\<noteq> None\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "have \"term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "have \"term_ok' (sig \\<Theta>) (Abs T t $ x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (Abs T t $ x)", "using \\<beta>_conversion.hyps(2) \\<beta>_conversion.hyps(3) term_ok'.simps(4) wt_term_def term_ok_def"], ["proof (prove)\nusing this:\n  wt_term (sig \\<Theta>) (Abs T t)\n  wf_term (sig \\<Theta>) x\n  term_ok' ?\\<Sigma> (?t $ ?u) =\n  (term_ok' ?\\<Sigma> ?t \\<and> term_ok' ?\\<Sigma> ?u)\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  term_ok ?\\<Theta> ?t \\<equiv> wt_term (sig ?\\<Theta>) ?t\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (Abs T t $ x)", "by blast"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) (Abs T t $ x)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "moreover"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) (Abs T t $ x)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "hence \"term_ok' (sig \\<Theta>) (subst_bv x t)\""], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) (Abs T t $ x)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (subst_bv x t)", "using subst_bv_def term_ok'_subst_bv1"], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) (Abs T t $ x)\n  subst_bv ?u ?t \\<equiv> subst_bv1 ?t 0 ?u\n  \\<lbrakk>term_ok' (sig ?\\<Theta>) ?f; term_ok' (sig ?\\<Theta>) ?u\\<rbrakk>\n  \\<Longrightarrow> term_ok' (sig ?\\<Theta>) (subst_bv1 ?f ?lev ?u)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (subst_bv x t)", "by auto"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) (subst_bv x t)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "moreover"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) (subst_bv x t)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "have \"const_type (sig \\<Theta>) STR ''Pure.eq''\n        = Some ((Tv (Var (STR '''a'', 0)) full_sort) \\<rightarrow> ((Tv (Var (STR '''a'', 0)) full_sort) \\<rightarrow> propT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const_type (sig \\<Theta>) STR ''Pure.eq'' =\n    Some (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)", "using \\<beta>_conversion.hyps(1)"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n\ngoal (1 subgoal):\n 1. const_type (sig \\<Theta>) STR ''Pure.eq'' =\n    Some (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)", "by (cases \\<Theta>) fastforce"], ["proof (state)\nthis:\n  const_type (sig \\<Theta>) STR ''Pure.eq'' =\n  Some (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "moreover"], ["proof (state)\nthis:\n  const_type (sig \\<Theta>) STR ''Pure.eq'' =\n  Some (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "obtain t' where \"typ_of (Abs T t $ x) = Some t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        typ_of (Abs T t $ x) = Some t' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (smt \"1\" typ_of1_split_App typ_of_def)"], ["proof (state)\nthis:\n  typ_of (Abs T t $ x) = Some t'\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "moreover"], ["proof (state)\nthis:\n  typ_of (Abs T t $ x) = Some t'\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "hence \"typ_of (subst_bv x t) = Some t'\""], ["proof (prove)\nusing this:\n  typ_of (Abs T t $ x) = Some t'\n\ngoal (1 subgoal):\n 1. typ_of (subst_bv x t) = Some t'", "by (smt list.simps(1) subst_bv_def typ.simps(1) typ_of1_split_App typ_of1_subst_bv_gen' typ_of_Abs_body_typ' typ_of_def)"], ["proof (state)\nthis:\n  typ_of (subst_bv x t) = Some t'\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "moreover"], ["proof (state)\nthis:\n  typ_of (subst_bv x t) = Some t'\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "have \"typ_ok_sig (sig \\<Theta>) t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok_sig (sig \\<Theta>) t'", "using \\<beta>_conversion.hyps(1) calculation(2) calculation(5) wt_term_def term_ok_imp_typ_ok typ_ok_def"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok' (sig \\<Theta>) (subst_bv x t)\n  typ_of (subst_bv x t) = Some t'\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  \\<lbrakk>wf_theory ?thy; term_ok ?thy ?t; typ_of ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?thy ?ty\n  typ_ok ?\\<Theta> ?T \\<equiv> wf_type (sig ?\\<Theta>) ?T\n\ngoal (1 subgoal):\n 1. typ_ok_sig (sig \\<Theta>) t'", "by auto"], ["proof (state)\nthis:\n  typ_ok_sig (sig \\<Theta>) t'\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "moreover"], ["proof (state)\nthis:\n  typ_ok_sig (sig \\<Theta>) t'\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "hence \"typ_ok_sig (sig \\<Theta>) (t' \\<rightarrow> propT) \""], ["proof (prove)\nusing this:\n  typ_ok_sig (sig \\<Theta>) t'\n\ngoal (1 subgoal):\n 1. typ_ok_sig (sig \\<Theta>) (t' \\<rightarrow> propT)", "using \\<open>wf_theory \\<Theta>\\<close>"], ["proof (prove)\nusing this:\n  typ_ok_sig (sig \\<Theta>) t'\n  wf_theory \\<Theta>\n\ngoal (1 subgoal):\n 1. typ_ok_sig (sig \\<Theta>) (t' \\<rightarrow> propT)", "by (cases \\<Theta> rule: theory_full_exhaust) auto"], ["proof (state)\nthis:\n  typ_ok_sig (sig \\<Theta>) (t' \\<rightarrow> propT)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "moreover"], ["proof (state)\nthis:\n  typ_ok_sig (sig \\<Theta>) (t' \\<rightarrow> propT)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "have \"tinstT (T \\<rightarrow> (T \\<rightarrow> propT)) ((Tv (Var (STR '''a'', 0)) full_sort) \\<rightarrow> ((Tv (Var (STR '''a'', 0)) full_sort) \\<rightarrow> propT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinstT (T \\<rightarrow> T \\<rightarrow> propT)\n     (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)", "unfolding tinstT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<rho>.\n       tsubstT (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT) \\<rho> =\n       T \\<rightarrow> T \\<rightarrow> propT", "by auto"], ["proof (state)\nthis:\n  tinstT (T \\<rightarrow> T \\<rightarrow> propT)\n   (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "moreover"], ["proof (state)\nthis:\n  tinstT (T \\<rightarrow> T \\<rightarrow> propT)\n   (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "have \"tinstT (t' \\<rightarrow> (t' \\<rightarrow> propT)) ((Tv (Var (STR '''a'', 0)) full_sort) \\<rightarrow> ((Tv (Var (STR '''a'', 0)) full_sort) \\<rightarrow> propT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tinstT (t' \\<rightarrow> t' \\<rightarrow> propT)\n     (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)", "unfolding tinstT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<rho>.\n       tsubstT (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT) \\<rho> =\n       t' \\<rightarrow> t' \\<rightarrow> propT", "by auto"], ["proof (state)\nthis:\n  tinstT (t' \\<rightarrow> t' \\<rightarrow> propT)\n   (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "ultimately"], ["proof (chain)\npicking this:\n  term_ok' (sig \\<Theta>) (Abs T t $ x)\n  term_ok' (sig \\<Theta>) (subst_bv x t)\n  const_type (sig \\<Theta>) STR ''Pure.eq'' =\n  Some (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n  typ_of (Abs T t $ x) = Some t'\n  typ_of (subst_bv x t) = Some t'\n  typ_ok_sig (sig \\<Theta>) t'\n  typ_ok_sig (sig \\<Theta>) (t' \\<rightarrow> propT)\n  tinstT (T \\<rightarrow> T \\<rightarrow> propT)\n   (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n  tinstT (t' \\<rightarrow> t' \\<rightarrow> propT)\n   (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)", "show ?thesis"], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) (Abs T t $ x)\n  term_ok' (sig \\<Theta>) (subst_bv x t)\n  const_type (sig \\<Theta>) STR ''Pure.eq'' =\n  Some (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n  typ_of (Abs T t $ x) = Some t'\n  typ_of (subst_bv x t) = Some t'\n  typ_ok_sig (sig \\<Theta>) t'\n  typ_ok_sig (sig \\<Theta>) (t' \\<rightarrow> propT)\n  tinstT (T \\<rightarrow> T \\<rightarrow> propT)\n   (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n  tinstT (t' \\<rightarrow> t' \\<rightarrow> propT)\n   (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "using \\<open>wf_theory \\<Theta>\\<close>"], ["proof (prove)\nusing this:\n  term_ok' (sig \\<Theta>) (Abs T t $ x)\n  term_ok' (sig \\<Theta>) (subst_bv x t)\n  const_type (sig \\<Theta>) STR ''Pure.eq'' =\n  Some (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n  typ_of (Abs T t $ x) = Some t'\n  typ_of (subst_bv x t) = Some t'\n  typ_ok_sig (sig \\<Theta>) t'\n  typ_ok_sig (sig \\<Theta>) (t' \\<rightarrow> propT)\n  tinstT (T \\<rightarrow> T \\<rightarrow> propT)\n   (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n  tinstT (t' \\<rightarrow> t' \\<rightarrow> propT)\n   (Core.aT \\<rightarrow> Core.aT \\<rightarrow> propT)\n  wf_theory \\<Theta>\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "by (cases \\<Theta> rule: theory_full_exhaust) auto"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "ultimately"], ["proof (chain)\npicking this:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) \\<noteq> None\n  term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))", "show ?thesis"], ["proof (prove)\nusing this:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) \\<noteq> None\n  term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "using wt_term_def"], ["proof (prove)\nusing this:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) \\<noteq> None\n  term_ok' (sig \\<Theta>) (mk_eq (Abs T t $ x) (subst_bv x t))\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "by simp"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))\n\ngoal (2 subgoals):\n 1. \\<And>T t u \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs T t $ u) (subst_bv u t)) =\n                         Some propT \\<and>\n                         term_ok \\<Theta>\n                          (mk_eq (Abs T t $ u) (subst_bv u t))\n 2. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "ultimately"], ["proof (chain)\npicking this:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) = Some propT\n  term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "show ?case"], ["proof (prove)\nusing this:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) = Some propT\n  term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) = Some propT \\<and>\n    term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))", "by simp"], ["proof (state)\nthis:\n  typ_of (mk_eq (Abs T t $ x) (subst_bv x t)) = Some propT \\<and>\n  term_ok \\<Theta> (mk_eq (Abs T t $ x) (subst_bv x t))\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "case (eta t \\<tau> \\<tau>')"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "hence tyeta: \"typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\""], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n\ngoal (1 subgoal):\n 1. typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')", "using typ_of_eta_expand"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  typ_of ?f = Some (?\\<tau> \\<rightarrow> ?\\<tau>') \\<Longrightarrow>\n  typ_of (Abs ?\\<tau> (?f $ Bv 0)) = Some (?\\<tau> \\<rightarrow> ?\\<tau>')\n\ngoal (1 subgoal):\n 1. typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')", "by auto"], ["proof (state)\nthis:\n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "moreover"], ["proof (state)\nthis:\n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "have \"\\<not> is_dependent t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_dependent t", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_dependent t", "have \"is_closed t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_closed t", "using eta.hyps(3) typ_of_imp_closed"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  typ_of ?t = Some ?ty \\<Longrightarrow> is_closed ?t\n\ngoal (1 subgoal):\n 1. is_closed t", "by blast"], ["proof (state)\nthis:\n  is_closed t\n\ngoal (1 subgoal):\n 1. \\<not> is_dependent t", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_closed t\n\ngoal (1 subgoal):\n 1. \\<not> is_dependent t", "using is_dependent_def is_open_def loose_bvar1_imp_loose_bvar"], ["proof (prove)\nusing this:\n  is_closed t\n  is_dependent ?t \\<equiv> loose_bvar1 ?t 0\n  is_open ?t \\<equiv> loose_bvar ?t 0\n  loose_bvar1 ?t ?n \\<Longrightarrow> loose_bvar ?t ?n\n\ngoal (1 subgoal):\n 1. \\<not> is_dependent t", "by blast"], ["proof (state)\nthis:\n  \\<not> is_dependent t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_dependent t\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "ultimately"], ["proof (chain)\npicking this:\n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\n  \\<not> is_dependent t", "have ty_decr: \"typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\""], ["proof (prove)\nusing this:\n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\n  \\<not> is_dependent t\n\ngoal (1 subgoal):\n 1. typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')", "using typ_of1_eta_red_step"], ["proof (prove)\nusing this:\n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\n  \\<not> is_dependent t\n  \\<lbrakk>\\<not> is_dependent ?t;\n   typ_of (Abs ?\\<tau> (?t $ Bv 0)) =\n   Some (?\\<tau> \\<rightarrow> ?\\<tau>')\\<rbrakk>\n  \\<Longrightarrow> typ_of (decr 0 ?t) =\n                    Some (?\\<tau> \\<rightarrow> ?\\<tau>')\n\ngoal (1 subgoal):\n 1. typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')", "by blast"], ["proof (state)\nthis:\n  typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "hence 1: \"typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t)) = Some propT\""], ["proof (prove)\nusing this:\n  typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t)) = Some propT", "using eta tyeta"], ["proof (prove)\nusing this:\n  typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t)) = Some propT", "by (auto simp add: typ_of_def)"], ["proof (state)\nthis:\n  typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t)) = Some propT\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "have \"typ_ok \\<Theta> (\\<tau> \\<rightarrow> \\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (\\<tau> \\<rightarrow> \\<tau>')", "using eta term_ok_imp_typ_ok"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  \\<lbrakk>wf_theory ?thy; term_ok ?thy ?t; typ_of ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?thy ?ty\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (\\<tau> \\<rightarrow> \\<tau>')", "by (simp add: wt_term_def del: typ_ok_def)"], ["proof (state)\nthis:\n  typ_ok \\<Theta> (\\<tau> \\<rightarrow> \\<tau>')\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "hence tyok: \"typ_ok \\<Theta> \\<tau>\" \"typ_ok \\<Theta> \\<tau>'\""], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> (\\<tau> \\<rightarrow> \\<tau>')\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> \\<tau> &&& typ_ok \\<Theta> \\<tau>'", "unfolding typ_ok_def"], ["proof (prove)\nusing this:\n  wf_type (sig \\<Theta>) (\\<tau> \\<rightarrow> \\<tau>')\n\ngoal (1 subgoal):\n 1. wf_type (sig \\<Theta>) \\<tau> &&& wf_type (sig \\<Theta>) \\<tau>'", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  typ_ok \\<Theta> \\<tau>\n  typ_ok \\<Theta> \\<tau>'\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "hence \"term_ok \\<Theta> (Abs \\<tau> (t $ Bv 0))\""], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> \\<tau>\n  typ_ok \\<Theta> \\<tau>'\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Abs \\<tau> (t $ Bv 0))", "using eta(2) tyeta"], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> \\<tau>\n  typ_ok \\<Theta> \\<tau>'\n  wf_term (sig \\<Theta>) t\n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Abs \\<tau> (t $ Bv 0))", "by (simp add: wt_term_def)"], ["proof (state)\nthis:\n  term_ok \\<Theta> (Abs \\<tau> (t $ Bv 0))\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "moreover"], ["proof (state)\nthis:\n  term_ok \\<Theta> (Abs \\<tau> (t $ Bv 0))\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "have \"term_ok \\<Theta> (decr 0 t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (decr 0 t)", "using eta term_ok'_decr tyeta ty_decr wt_term_def typ_ok_def tyok"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  term_ok' ?\\<Sigma> ?t \\<Longrightarrow> term_ok' ?\\<Sigma> (decr ?i ?t)\n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\n  typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  typ_ok ?\\<Theta> ?T \\<equiv> wf_type (sig ?\\<Theta>) ?T\n  typ_ok \\<Theta> \\<tau>\n  typ_ok \\<Theta> \\<tau>'\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (decr 0 t)", "by (cases \\<Theta> rule: theory_full_exhaust) (auto split: option.splits simp add: tinstT_def)"], ["proof (state)\nthis:\n  term_ok \\<Theta> (decr 0 t)\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "ultimately"], ["proof (chain)\npicking this:\n  term_ok \\<Theta> (Abs \\<tau> (t $ Bv 0))\n  term_ok \\<Theta> (decr 0 t)", "have \"term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t))\""], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (Abs \\<tau> (t $ Bv 0))\n  term_ok \\<Theta> (decr 0 t)\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t))", "using eta.hyps ty_decr tyeta tyok 1 term_ok_mk_eqI"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (Abs \\<tau> (t $ Bv 0))\n  term_ok \\<Theta> (decr 0 t)\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  typ_of (decr 0 t) = Some (\\<tau> \\<rightarrow> \\<tau>')\n  typ_of (Abs \\<tau> (t $ Bv 0)) = Some (\\<tau> \\<rightarrow> \\<tau>')\n  typ_ok \\<Theta> \\<tau>\n  typ_ok \\<Theta> \\<tau>'\n  typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t)) = Some propT\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok ?\\<Theta> ?s; term_ok ?\\<Theta> ?t;\n   typ_of ?s = typ_of ?t\\<rbrakk>\n  \\<Longrightarrow> term_ok ?\\<Theta> (mk_eq ?s ?t)\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t))", "by metis"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t))\n\ngoal (1 subgoal):\n 1. \\<And>t \\<tau> \\<tau>' \\<Gamma>.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) =\n                         Some propT \\<and>\n                         term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "then"], ["proof (chain)\npicking this:\n  term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t))", "show ?case"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t))\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) = Some propT \\<and>\n    term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "using 1"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t))\n  typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t)) = Some propT\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) = Some propT \\<and>\n    term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "using eta.hyps(2) eta.hyps(3) has_typ_imp_closed term_ok_subst_bv_no_change\n      closed_subst_bv_no_change"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t))\n  typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) (decr 0 t)) = Some propT\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  \\<turnstile>\\<^sub>\\<tau> ?t : ?ty \\<Longrightarrow> is_closed ?t\n  term_ok ?\\<Theta> ?t \\<Longrightarrow> subst_bv ?u ?t = ?t\n  is_closed ?t \\<Longrightarrow> subst_bv ?u ?t = ?t\n\ngoal (1 subgoal):\n 1. typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) = Some propT \\<and>\n    term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)", "by auto"], ["proof (state)\nthis:\n  typ_of (mk_eq (Abs \\<tau> (t $ Bv 0)) t) = Some propT \\<and>\n  term_ok \\<Theta> (mk_eq (Abs \\<tau> (t $ Bv 0)) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary proved_terms_well_formed: \n  assumes \"\\<Theta>, \\<Gamma> \\<turnstile> p\"\n  shows \"typ_of p = Some propT\" \"term_ok \\<Theta> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of p = Some propT &&& term_ok \\<Theta> p", "using assms proved_terms_well_formed_pre"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> p\n  ?\\<Theta>,?\\<Gamma> \\<turnstile> ?p \\<Longrightarrow>\n  typ_of ?p = Some propT \\<and> term_ok ?\\<Theta> ?p\n\ngoal (1 subgoal):\n 1. typ_of p = Some propT &&& term_ok \\<Theta> p", "by auto"], ["", "lemma forall_intros: \n  \"wf_theory \\<Theta> \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> B \\<Longrightarrow> \\<forall>(x, \\<tau>)\\<in>set frees . (x,\\<tau>) \\<notin> FV \\<Gamma> \\<and> typ_ok \\<Theta> \\<tau> \n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> mk_all_list frees B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     \\<forall>(x, \\<tau>)\\<in>set frees.\n        (x, \\<tau>) \\<notin> FV \\<Gamma> \\<and>\n        typ_ok \\<Theta> \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> mk_all_list frees B", "by (induction frees arbitrary: B)\n   (auto intro: proves.forall_intro simp add: mk_all_list_def simp del: FV_def split: prod.splits)"], ["", "(* MOVE *)"], ["", "lemma term_ok_var[simp]: \"term_ok \\<Theta> (Fv idn \\<tau>) = typ_ok \\<Theta> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv idn \\<tau>) = typ_ok \\<Theta> \\<tau>", "by (simp add: wt_term_def typ_of_def)"], ["", "lemma typ_of_var[simp]: \"typ_of (Fv idn \\<tau>) = Some \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of (Fv idn \\<tau>) = Some \\<tau>", "by (simp add: typ_of_def)"], ["", "(* Is this a simp rule? *)"], ["", "lemma is_closed_Fv[simp]: \"is_closed (Fv idn \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_closed (Fv idn \\<tau>)", "by (simp add: is_open_def)"], ["", "corollary proved_terms_closed: \"\\<Theta>, \\<Gamma> \\<turnstile> B \\<Longrightarrow> is_closed B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> B \\<Longrightarrow> is_closed B", "by (simp add: proved_terms_well_formed(1) typ_of_imp_closed)"], ["", "lemma not_loose_bvar_bind_fv2: \n  \"\\<not> loose_bvar t lev \\<Longrightarrow> \\<not> loose_bvar (bind_fv2 v lev t) (Suc lev)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> loose_bvar t lev \\<Longrightarrow>\n    \\<not> loose_bvar (bind_fv2 v lev t) (Suc lev)", "by (induction t arbitrary: lev) auto"], ["", "lemma not_loose_bvar_bind_fv2_: \n  \"\\<not> loose_bvar (bind_fv2 v lev t) lev \\<Longrightarrow> \\<not> loose_bvar t lev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> loose_bvar (bind_fv2 v lev t) lev \\<Longrightarrow>\n    \\<not> loose_bvar t lev", "by (induction t arbitrary: lev) (auto split: if_splits)"], ["", "lemma fold_add_vars'_FV_pre: \"set (fold add_vars' Hs acc) = set acc \\<union> FV (set Hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold add_vars' Hs acc) = set acc \\<union> FV (set Hs)", "by (induction Hs arbitrary: acc) (auto simp add: add_vars'_fv_pre)"], ["", "corollary fold_add_vars'_FV[simp]: \"set (fold (add_vars') Hs []) = FV (set Hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fold add_vars' Hs []) = FV (set Hs)", "using fold_add_vars'_FV_pre"], ["proof (prove)\nusing this:\n  set (fold add_vars' ?Hs ?acc) = set ?acc \\<union> FV (set ?Hs)\n\ngoal (1 subgoal):\n 1. set (fold add_vars' Hs []) = FV (set Hs)", "by simp"], ["", "lemma forall_intro_vars:\n  assumes \"wf_theory \\<Theta>\" \"\\<Theta>, set Hs \\<turnstile> B\" \n  shows \"\\<Theta>, set Hs \\<turnstile> forall_intro_vars B Hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,set Hs \\<turnstile> forall_intro_vars B Hs", "apply (rule forall_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,set Hs \\<turnstile> B\n 3. \\<forall>(x, \\<tau>)\n             \\<in>set (diff_list (add_vars' B []) (fold add_vars' Hs [])).\n       (x, \\<tau>) \\<notin> FV (set Hs) \\<and> typ_ok \\<Theta> \\<tau>", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,set Hs \\<turnstile> B\n\ngoal (3 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,set Hs \\<turnstile> B\n 3. \\<forall>(x, \\<tau>)\n             \\<in>set (diff_list (add_vars' B []) (fold add_vars' Hs [])).\n       (x, \\<tau>) \\<notin> FV (set Hs) \\<and> typ_ok \\<Theta> \\<tau>", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,set Hs \\<turnstile> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (add_vars' B []) -\n                                     \\<Union> (fv ` set Hs).\n                         case x of\n                         (x, \\<tau>) \\<Rightarrow>\n                           (\\<forall>xa\\<in>set Hs.\n                               (x, \\<tau>) \\<notin> fv xa) \\<and>\n                           typ_ok_sig (sig \\<Theta>) \\<tau>", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,set Hs \\<turnstile> B;\n        (a, b) \\<in> set (add_vars' B []);\n        \\<forall>x\\<in>set Hs. (a, b) \\<notin> fv x\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig (sig \\<Theta>) b", "using add_vars'_fv proved_terms_well_formed_pre term_ok_vars_typ_ok"], ["proof (prove)\nusing this:\n  set (add_vars' ?t []) = fv ?t\n  ?\\<Theta>,?\\<Gamma> \\<turnstile> ?p \\<Longrightarrow>\n  typ_of ?p = Some propT \\<and> term_ok ?\\<Theta> ?p\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok ?\\<Theta> ?t;\n   (?x, ?\\<tau>) \\<in> fv ?t\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?\\<Theta> ?\\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,set Hs \\<turnstile> B;\n        (a, b) \\<in> set (add_vars' B []);\n        \\<forall>x\\<in>set Hs. (a, b) \\<notin> fv x\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig (sig \\<Theta>) b", "by (metis term_ok_vars_typ_ok typ_ok_def wf_type_imp_typ_ok_sig)"], ["", "(* MOVE *)"], ["", "lemma mk_all_list'_preserves_term_ok_typ_of:\n  assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> B\" \"typ_of B = Some propT\" \"\\<forall>(idn,ty)\\<in>set vs . typ_ok \\<Theta> ty\"\n  shows \"term_ok \\<Theta> (mk_all_list vs B) \\<and> typ_of (mk_all_list vs B) = Some propT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list vs B) \\<and>\n    typ_of (mk_all_list vs B) = Some propT", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>(idn, ty)\\<in>set vs. typ_ok \\<Theta> ty\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list vs B) \\<and>\n    typ_of (mk_all_list vs B) = Some propT", "proof (induction vs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n     \\<forall>(idn, y)\\<in>set []. typ_ok \\<Theta> y\\<rbrakk>\n    \\<Longrightarrow> term_ok \\<Theta> (mk_all_list [] B) \\<and>\n                      typ_of (mk_all_list [] B) = Some propT\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "case Nil"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set []. case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n     \\<forall>(idn, y)\\<in>set []. typ_ok \\<Theta> y\\<rbrakk>\n    \\<Longrightarrow> term_ok \\<Theta> (mk_all_list [] B) \\<and>\n                      typ_of (mk_all_list [] B) = Some propT\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set []. case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set []. case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list [] B) \\<and>\n    typ_of (mk_all_list [] B) = Some propT", "by simp"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_all_list [] B) \\<and>\n  typ_of (mk_all_list [] B) = Some propT\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "case (snoc v vs)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n   \\<forall>a\\<in>set vs.\n      case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\\<rbrakk>\n  \\<Longrightarrow> term_ok \\<Theta> (mk_all_list vs B) \\<and>\n                    typ_of (mk_all_list vs B) = Some propT\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set (vs @ [v]).\n     case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "hence I: \"term_ok \\<Theta> (mk_all_list vs B)\" \"typ_of (mk_all_list vs B) = Some propT\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n   \\<forall>a\\<in>set vs.\n      case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\\<rbrakk>\n  \\<Longrightarrow> term_ok \\<Theta> (mk_all_list vs B) \\<and>\n                    typ_of (mk_all_list vs B) = Some propT\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set (vs @ [v]).\n     case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list vs B) &&&\n    typ_of (mk_all_list vs B) = Some propT", "by simp_all"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_all_list vs B)\n  typ_of (mk_all_list vs B) = Some propT\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "obtain idn ty where v: \"v=(idn,ty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>idn ty. v = (idn, ty) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v = (idn, ty)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "hence s: \"(mk_all_list (vs @ [v]) B) = mk_all idn ty (mk_all_list (vs) B)\""], ["proof (prove)\nusing this:\n  v = (idn, ty)\n\ngoal (1 subgoal):\n 1. mk_all_list (vs @ [v]) B = mk_all idn ty (mk_all_list vs B)", "by (simp add: mk_all_list_def)"], ["proof (state)\nthis:\n  mk_all_list (vs @ [v]) B = mk_all idn ty (mk_all_list vs B)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "have \"typ_ok \\<Theta> ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> ty", "using v snoc.prems"], ["proof (prove)\nusing this:\n  v = (idn, ty)\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set (vs @ [v]).\n     case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> ty", "by simp"], ["proof (state)\nthis:\n  typ_ok \\<Theta> ty\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "then"], ["proof (chain)\npicking this:\n  typ_ok \\<Theta> ty", "show ?case"], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> ty\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list (vs @ [v]) B) \\<and>\n    typ_of (mk_all_list (vs @ [v]) B) = Some propT", "using I s term_ok_mk_all snoc.prems(1) wt_term_def typ_of_mk_all"], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> ty\n  term_ok \\<Theta> (mk_all_list vs B)\n  typ_of (mk_all_list vs B) = Some propT\n  mk_all_list (vs @ [v]) B = mk_all idn ty (mk_all_list vs B)\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok' (sig ?\\<Theta>) ?B;\n   typ_of ?B = Some propT; typ_ok ?\\<Theta> ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> term_ok ?\\<Theta> (mk_all ?x ?\\<tau> ?B)\n  wf_theory \\<Theta>\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  typ_of ?A = Some propT \\<Longrightarrow>\n  typ_of (mk_all ?x ?ty ?A) = Some propT\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list (vs @ [v]) B) \\<and>\n    typ_of (mk_all_list (vs @ [v]) B) = Some propT", "by auto"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_all_list (vs @ [v]) B) \\<and>\n  typ_of (mk_all_list (vs @ [v]) B) = Some propT\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary forall_intro_vars_preserves_term_ok_typ_of:\n  assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> B\" \"typ_of B = Some propT\" \n  shows \"term_ok \\<Theta> (forall_intro_vars B Hs) \\<and> typ_of (forall_intro_vars B Hs) = Some propT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (forall_intro_vars B Hs) \\<and>\n    typ_of (forall_intro_vars B Hs) = Some propT", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (forall_intro_vars B Hs) \\<and>\n    typ_of (forall_intro_vars B Hs) = Some propT", "have 1: \"\\<forall>(idn,ty)\\<in>set (add_vars' B []) . typ_ok \\<Theta> ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(idn, ty)\\<in>set (add_vars' B []). typ_ok \\<Theta> ty", "using add_vars'_fv assms(1) assms(2) term_ok_vars_typ_ok"], ["proof (prove)\nusing this:\n  set (add_vars' ?t []) = fv ?t\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok ?\\<Theta> ?t;\n   (?x, ?\\<tau>) \\<in> fv ?t\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?\\<Theta> ?\\<tau>\n\ngoal (1 subgoal):\n 1. \\<forall>(idn, ty)\\<in>set (add_vars' B []). typ_ok \\<Theta> ty", "by blast"], ["proof (state)\nthis:\n  \\<forall>(idn, ty)\\<in>set (add_vars' B []). typ_ok \\<Theta> ty\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (forall_intro_vars B Hs) \\<and>\n    typ_of (forall_intro_vars B Hs) = Some propT", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(idn, ty)\\<in>set (add_vars' B []). typ_ok \\<Theta> ty\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (forall_intro_vars B Hs) \\<and>\n    typ_of (forall_intro_vars B Hs) = Some propT", "using assms mk_all_list'_preserves_term_ok_typ_of"], ["proof (prove)\nusing this:\n  \\<forall>(idn, ty)\\<in>set (add_vars' B []). typ_ok \\<Theta> ty\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok ?\\<Theta> ?B;\n   typ_of ?B = Some propT;\n   \\<forall>(idn, ty)\\<in>set ?vs. typ_ok ?\\<Theta> ty\\<rbrakk>\n  \\<Longrightarrow> term_ok ?\\<Theta> (mk_all_list ?vs ?B) \\<and>\n                    typ_of (mk_all_list ?vs ?B) = Some propT\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (forall_intro_vars B Hs) \\<and>\n    typ_of (forall_intro_vars B Hs) = Some propT", "by simp"], ["proof (state)\nthis:\n  term_ok \\<Theta> (forall_intro_vars B Hs) \\<and>\n  typ_of (forall_intro_vars B Hs) = Some propT\n\ngoal:\nNo subgoals!", "qed"], ["", "(* MOVE and rename *)"], ["", "lemma bind_fv_remove_var_from_fv: \"fv (bind_fv (idn, \\<tau>) t) = fv t - {(idn, \\<tau>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (bind_fv (idn, \\<tau>) t) = fv t - {(idn, \\<tau>)}", "using bind_fv2_Fv_fv bind_fv_def"], ["proof (prove)\nusing this:\n  fv (bind_fv2 (?x, ?\\<tau>) ?lev ?t) = fv ?t - {(?x, ?\\<tau>)}\n  bind_fv ?vT ?t = bind_fv2 ?vT 0 ?t\n\ngoal (1 subgoal):\n 1. fv (bind_fv (idn, \\<tau>) t) = fv t - {(idn, \\<tau>)}", "by simp"], ["", "lemma forall_intro_vars_remove_fv[simp]: \"fv (forall_intro_vars t []) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (forall_intro_vars t []) = {}", "using mk_all_list_fv_unchanged add_vars'_fv"], ["proof (prove)\nusing this:\n  fv (mk_all_list ?l ?B) = fv ?B - set ?l\n  set (add_vars' ?t []) = fv ?t\n\ngoal (1 subgoal):\n 1. fv (forall_intro_vars t []) = {}", "by simp"], ["", "lemma term_ok_mk_all_list:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"term_ok \\<Theta> B\" \n  assumes \"typ_of B = Some propT\"\n  assumes \"\\<forall>(idn, \\<tau>) \\<in> set l . typ_ok \\<Theta> \\<tau>\"\n  shows \"term_ok \\<Theta> (mk_all_list l B) \\<and> typ_of (mk_all_list l B) = Some propT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list l B) \\<and>\n    typ_of (mk_all_list l B) = Some propT", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>(idn, \\<tau>)\\<in>set l. typ_ok \\<Theta> \\<tau>\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list l B) \\<and>\n    typ_of (mk_all_list l B) = Some propT", "proof(induction l rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n     \\<forall>(idn, y)\\<in>set []. typ_ok \\<Theta> y\\<rbrakk>\n    \\<Longrightarrow> term_ok \\<Theta> (mk_all_list [] B) \\<and>\n                      typ_of (mk_all_list [] B) = Some propT\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "case Nil"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set []. case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n     \\<forall>(idn, y)\\<in>set []. typ_ok \\<Theta> y\\<rbrakk>\n    \\<Longrightarrow> term_ok \\<Theta> (mk_all_list [] B) \\<and>\n                      typ_of (mk_all_list [] B) = Some propT\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set []. case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set []. case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list [] B) \\<and>\n    typ_of (mk_all_list [] B) = Some propT", "by simp"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_all_list [] B) \\<and>\n  typ_of (mk_all_list [] B) = Some propT\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "case (snoc v vs)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n   \\<forall>a\\<in>set vs.\n      case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\\<rbrakk>\n  \\<Longrightarrow> term_ok \\<Theta> (mk_all_list vs B) \\<and>\n                    typ_of (mk_all_list vs B) = Some propT\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set (vs @ [v]).\n     case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "obtain idn \\<tau> where v: \"v = (idn, \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>idn \\<tau>.\n        v = (idn, \\<tau>) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v = (idn, \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "hence simp: \"mk_all_list (vs@[v]) B = mk_all idn \\<tau> (mk_all_list vs B)\""], ["proof (prove)\nusing this:\n  v = (idn, \\<tau>)\n\ngoal (1 subgoal):\n 1. mk_all_list (vs @ [v]) B = mk_all idn \\<tau> (mk_all_list vs B)", "by (auto simp add: mk_all_list_def)"], ["proof (state)\nthis:\n  mk_all_list (vs @ [v]) B = mk_all idn \\<tau> (mk_all_list vs B)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "have I: \"term_ok \\<Theta> (mk_all_list vs B)\" \"typ_of (mk_all_list vs B) = Some propT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list vs B) &&&\n    typ_of (mk_all_list vs B) = Some propT", "using snoc"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n   \\<forall>a\\<in>set vs.\n      case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\\<rbrakk>\n  \\<Longrightarrow> term_ok \\<Theta> (mk_all_list vs B) \\<and>\n                    typ_of (mk_all_list vs B) = Some propT\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set (vs @ [v]).\n     case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list vs B) &&&\n    typ_of (mk_all_list vs B) = Some propT", "by auto"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_all_list vs B)\n  typ_of (mk_all_list vs B) = Some propT\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "have \"term_ok \\<Theta> (mk_all idn \\<tau> (mk_all_list vs B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all idn \\<tau> (mk_all_list vs B))", "using term_ok_mk_all snoc.prems I v"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_theory ?\\<Theta>; term_ok' (sig ?\\<Theta>) ?B;\n   typ_of ?B = Some propT; typ_ok ?\\<Theta> ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> term_ok ?\\<Theta> (mk_all ?x ?\\<tau> ?B)\n  wf_theory \\<Theta>\n  term_ok \\<Theta> B\n  typ_of B = Some propT\n  \\<forall>a\\<in>set (vs @ [v]).\n     case a of (idn, a) \\<Rightarrow> typ_ok \\<Theta> a\n  term_ok \\<Theta> (mk_all_list vs B)\n  typ_of (mk_all_list vs B) = Some propT\n  v = (idn, \\<tau>)\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all idn \\<tau> (mk_all_list vs B))", "by (auto simp add: wt_term_def)"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_all idn \\<tau> (mk_all_list vs B))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "moreover"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_all idn \\<tau> (mk_all_list vs B))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "have \"typ_of (mk_all idn \\<tau> (mk_all_list vs B)) = Some propT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of (mk_all idn \\<tau> (mk_all_list vs B)) = Some propT", "using I(2) v typ_of_mk_all"], ["proof (prove)\nusing this:\n  typ_of (mk_all_list vs B) = Some propT\n  v = (idn, \\<tau>)\n  typ_of ?A = Some propT \\<Longrightarrow>\n  typ_of (mk_all ?x ?ty ?A) = Some propT\n\ngoal (1 subgoal):\n 1. typ_of (mk_all idn \\<tau> (mk_all_list vs B)) = Some propT", "by simp"], ["proof (state)\nthis:\n  typ_of (mk_all idn \\<tau> (mk_all_list vs B)) = Some propT\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lbrakk>wf_theory \\<Theta>; term_ok \\<Theta> B;\n                 typ_of B = Some propT;\n                 \\<forall>(idn, y)\\<in>set xs. typ_ok \\<Theta> y\\<rbrakk>\n                \\<Longrightarrow> term_ok \\<Theta> (mk_all_list xs B) \\<and>\n                                  typ_of (mk_all_list xs B) = Some propT;\n        wf_theory \\<Theta>; term_ok \\<Theta> B; typ_of B = Some propT;\n        \\<forall>(idn, y)\\<in>set (xs @ [x]). typ_ok \\<Theta> y\\<rbrakk>\n       \\<Longrightarrow> term_ok \\<Theta> (mk_all_list (xs @ [x]) B) \\<and>\n                         typ_of (mk_all_list (xs @ [x]) B) = Some propT", "ultimately"], ["proof (chain)\npicking this:\n  term_ok \\<Theta> (mk_all idn \\<tau> (mk_all_list vs B))\n  typ_of (mk_all idn \\<tau> (mk_all_list vs B)) = Some propT", "show ?case"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (mk_all idn \\<tau> (mk_all_list vs B))\n  typ_of (mk_all idn \\<tau> (mk_all_list vs B)) = Some propT\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (mk_all_list (vs @ [v]) B) \\<and>\n    typ_of (mk_all_list (vs @ [v]) B) = Some propT", "by (simp add: simp)"], ["proof (state)\nthis:\n  term_ok \\<Theta> (mk_all_list (vs @ [v]) B) \\<and>\n  typ_of (mk_all_list (vs @ [v]) B) = Some propT\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Move, also see if these are not subsumed *)"], ["", "lemma tvs_bind_fv2: \"tvs (bind_fv2 (v, T) lev t) \\<union> tvsT T = tvs t \\<union> tvsT T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (bind_fv2 (v, T) lev t) \\<union> tvsT T = tvs t \\<union> tvsT T", "by (induction \"(v, T)\" lev t rule: bind_fv2.induct) auto"], ["", "lemma tvs_bind_fv: \"tvs (bind_fv (v,T) t) \\<union> tvsT T = tvs t \\<union> tvsT T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (bind_fv (v, T) t) \\<union> tvsT T = tvs t \\<union> tvsT T", "using tvs_bind_fv2 bind_fv_def"], ["proof (prove)\nusing this:\n  tvs (bind_fv2 (?v, ?T) ?lev ?t) \\<union> tvsT ?T = tvs ?t \\<union> tvsT ?T\n  bind_fv ?vT ?t = bind_fv2 ?vT 0 ?t\n\ngoal (1 subgoal):\n 1. tvs (bind_fv (v, T) t) \\<union> tvsT T = tvs t \\<union> tvsT T", "by simp"], ["", "lemma tvs_mk_all': \"tvs (mk_all idn ty B) = tvs B \\<union> tvsT ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (mk_all idn ty B) = tvs B \\<union> tvsT ty", "using tvs_bind_fv typ_of_def is_variable.simps(2)"], ["proof (prove)\nusing this:\n  tvs (bind_fv (?v, ?T) ?t) \\<union> tvsT ?T = tvs ?t \\<union> tvsT ?T\n  typ_of ?t \\<equiv> typ_of1 [] ?t\n  is_variable (Ct ?v ?va) = False\n\ngoal (1 subgoal):\n 1. tvs (mk_all idn ty B) = tvs B \\<union> tvsT ty", "by fastforce"], ["", "lemma tvs_mk_all_list: \n  \"tvs (mk_all_list vs B) = tvs B \\<union> tvsT_Set (snd ` set vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (mk_all_list vs B) = tvs B \\<union> tvsT_Set (snd ` set vs)", "proof(induction vs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. tvs (mk_all_list [] B) = tvs B \\<union> tvsT_Set (snd ` set [])\n 2. \\<And>x xs.\n       tvs (mk_all_list xs B) =\n       tvs B \\<union> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n       tvs (mk_all_list (xs @ [x]) B) =\n       tvs B \\<union> tvsT_Set (snd ` set (xs @ [x]))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. tvs (mk_all_list [] B) = tvs B \\<union> tvsT_Set (snd ` set [])\n 2. \\<And>x xs.\n       tvs (mk_all_list xs B) =\n       tvs B \\<union> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n       tvs (mk_all_list (xs @ [x]) B) =\n       tvs B \\<union> tvsT_Set (snd ` set (xs @ [x]))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (mk_all_list [] B) = tvs B \\<union> tvsT_Set (snd ` set [])", "by simp"], ["proof (state)\nthis:\n  tvs (mk_all_list [] B) = tvs B \\<union> tvsT_Set (snd ` set [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       tvs (mk_all_list xs B) =\n       tvs B \\<union> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n       tvs (mk_all_list (xs @ [x]) B) =\n       tvs B \\<union> tvsT_Set (snd ` set (xs @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       tvs (mk_all_list xs B) =\n       tvs B \\<union> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n       tvs (mk_all_list (xs @ [x]) B) =\n       tvs B \\<union> tvsT_Set (snd ` set (xs @ [x]))", "case (snoc v vs)"], ["proof (state)\nthis:\n  tvs (mk_all_list vs B) = tvs B \\<union> tvsT_Set (snd ` set vs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       tvs (mk_all_list xs B) =\n       tvs B \\<union> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n       tvs (mk_all_list (xs @ [x]) B) =\n       tvs B \\<union> tvsT_Set (snd ` set (xs @ [x]))", "obtain idn \\<tau> where v: \"v = (idn, \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>idn \\<tau>.\n        v = (idn, \\<tau>) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  v = (idn, \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       tvs (mk_all_list xs B) =\n       tvs B \\<union> tvsT_Set (snd ` set xs) \\<Longrightarrow>\n       tvs (mk_all_list (xs @ [x]) B) =\n       tvs B \\<union> tvsT_Set (snd ` set (xs @ [x]))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (mk_all_list (vs @ [v]) B) =\n    tvs B \\<union> tvsT_Set (snd ` set (vs @ [v]))", "using snoc v tvs_mk_all'"], ["proof (prove)\nusing this:\n  tvs (mk_all_list vs B) = tvs B \\<union> tvsT_Set (snd ` set vs)\n  v = (idn, \\<tau>)\n  tvs (mk_all ?idn ?ty ?B) = tvs ?B \\<union> tvsT ?ty\n\ngoal (1 subgoal):\n 1. tvs (mk_all_list (vs @ [v]) B) =\n    tvs B \\<union> tvsT_Set (snd ` set (vs @ [v]))", "by (auto simp add: mk_all_list_def)"], ["proof (state)\nthis:\n  tvs (mk_all_list (vs @ [v]) B) =\n  tvs B \\<union> tvsT_Set (snd ` set (vs @ [v]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tvs_occs: \"occs v t \\<Longrightarrow> tvs v \\<subseteq> tvs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. occs v t \\<Longrightarrow> tvs v \\<subseteq> tvs t", "by (induction t) auto"], ["", "lemma tvs_forall_intro_vars: \"tvs (forall_intro_vars B Hs) = tvs B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (forall_intro_vars B Hs) = tvs B", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. tvs (forall_intro_vars B Hs) = tvs B", "have \"\\<forall>(idn, ty)\\<in>fv B . occs (Fv idn ty) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(idn, ty)\\<in>fv B. occs (Fv idn ty) B", "using fv_occs"], ["proof (prove)\nusing this:\n  (?x, ?\\<tau>) \\<in> fv ?t \\<Longrightarrow> occs (Fv ?x ?\\<tau>) ?t\n\ngoal (1 subgoal):\n 1. \\<forall>(idn, ty)\\<in>fv B. occs (Fv idn ty) B", "by blast"], ["proof (state)\nthis:\n  \\<forall>(idn, ty)\\<in>fv B. occs (Fv idn ty) B\n\ngoal (1 subgoal):\n 1. tvs (forall_intro_vars B Hs) = tvs B", "hence \"\\<forall>(idn, ty)\\<in>fv B . tvs (Fv idn ty) \\<subseteq> tvs B\""], ["proof (prove)\nusing this:\n  \\<forall>(idn, ty)\\<in>fv B. occs (Fv idn ty) B\n\ngoal (1 subgoal):\n 1. \\<forall>(idn, ty)\\<in>fv B. tvs (Fv idn ty) \\<subseteq> tvs B", "using tvs_occs"], ["proof (prove)\nusing this:\n  \\<forall>(idn, ty)\\<in>fv B. occs (Fv idn ty) B\n  occs ?v ?t \\<Longrightarrow> tvs ?v \\<subseteq> tvs ?t\n\ngoal (1 subgoal):\n 1. \\<forall>(idn, ty)\\<in>fv B. tvs (Fv idn ty) \\<subseteq> tvs B", "by blast"], ["proof (state)\nthis:\n  \\<forall>(idn, ty)\\<in>fv B. tvs (Fv idn ty) \\<subseteq> tvs B\n\ngoal (1 subgoal):\n 1. tvs (forall_intro_vars B Hs) = tvs B", "hence \"\\<forall>(idn, ty)\\<in>fv B . tvsT ty \\<subseteq> tvs B\""], ["proof (prove)\nusing this:\n  \\<forall>(idn, ty)\\<in>fv B. tvs (Fv idn ty) \\<subseteq> tvs B\n\ngoal (1 subgoal):\n 1. \\<forall>(idn, ty)\\<in>fv B. tvsT ty \\<subseteq> tvs B", "by simp"], ["proof (state)\nthis:\n  \\<forall>(idn, ty)\\<in>fv B. tvsT ty \\<subseteq> tvs B\n\ngoal (1 subgoal):\n 1. tvs (forall_intro_vars B Hs) = tvs B", "hence \"tvsT_Set (snd ` fv B) \\<subseteq> tvs B\""], ["proof (prove)\nusing this:\n  \\<forall>(idn, ty)\\<in>fv B. tvsT ty \\<subseteq> tvs B\n\ngoal (1 subgoal):\n 1. tvsT_Set (snd ` fv B) \\<subseteq> tvs B", "by fastforce"], ["proof (state)\nthis:\n  tvsT_Set (snd ` fv B) \\<subseteq> tvs B\n\ngoal (1 subgoal):\n 1. tvs (forall_intro_vars B Hs) = tvs B", "hence \"tvsT_Set (snd ` set (add_vars' B [])) \\<subseteq> tvs B\""], ["proof (prove)\nusing this:\n  tvsT_Set (snd ` fv B) \\<subseteq> tvs B\n\ngoal (1 subgoal):\n 1. tvsT_Set (snd ` set (add_vars' B [])) \\<subseteq> tvs B", "by (simp add: add_vars'_fv)"], ["proof (state)\nthis:\n  tvsT_Set (snd ` set (add_vars' B [])) \\<subseteq> tvs B\n\ngoal (1 subgoal):\n 1. tvs (forall_intro_vars B Hs) = tvs B", "thus ?thesis"], ["proof (prove)\nusing this:\n  tvsT_Set (snd ` set (add_vars' B [])) \\<subseteq> tvs B\n\ngoal (1 subgoal):\n 1. tvs (forall_intro_vars B Hs) = tvs B", "using tvs_mk_all_list"], ["proof (prove)\nusing this:\n  tvsT_Set (snd ` set (add_vars' B [])) \\<subseteq> tvs B\n  tvs (mk_all_list ?vs ?B) = tvs ?B \\<union> tvsT_Set (snd ` set ?vs)\n\ngoal (1 subgoal):\n 1. tvs (forall_intro_vars B Hs) = tvs B", "by auto"], ["proof (state)\nthis:\n  tvs (forall_intro_vars B Hs) = tvs B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"strip_all_single_var B = Some \\<tau> \\<Longrightarrow> strip_all_single_body B \\<noteq> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_single_var B = Some \\<tau> \\<Longrightarrow>\n    strip_all_single_body B \\<noteq> B", "using strip_all_vars_step"], ["proof (prove)\nusing this:\n  strip_all_single_var ?t = Some ?T \\<Longrightarrow>\n  ?T # strip_all_vars (strip_all_single_body ?t) = strip_all_vars ?t\n\ngoal (1 subgoal):\n 1. strip_all_single_var B = Some \\<tau> \\<Longrightarrow>\n    strip_all_single_body B \\<noteq> B", "by fastforce"], ["", "lemma strip_all_body_unchanged_iff_strip_all_single_body_unchanged: \n  \"strip_all_body B = B \\<longleftrightarrow> strip_all_single_body B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (strip_all_body B = B) = (strip_all_single_body B = B)", "by (metis not_Cons_self2 not_None_eq not_is_all_imp_strip_all_body_unchanged \n      strip_all_body_single_simp' strip_all_single_var_is_all strip_all_vars_step)"], ["", "lemma strip_all_body_unchanged_imp_strip_all_vars_no: \n  assumes \"strip_all_body B = B\"\n  shows \"strip_all_vars B = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_vars B = []", "by (smt assms not_Cons_self2 strip_all_body_single_simp' strip_all_single_body.simps(1) strip_all_vars.elims)"], ["", "lemma strip_all_body_unchanged_imp_strip_all_single_body_unchanged: \n  \"strip_all_body B = B \\<Longrightarrow> strip_all_single_body B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_body B = B \\<Longrightarrow> strip_all_single_body B = B", "by (smt (z3) not_Cons_self2 strip_all_body_single_simp' strip_all_single_body.simps(1) strip_all_vars.simps(1))"], ["", "lemma strip_all_single_body_unchanged_imp_strip_all_body_unchanged: \n  \"strip_all_single_body B = B \\<Longrightarrow> strip_all_body B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_single_body B = B \\<Longrightarrow> strip_all_body B = B", "by (auto elim!: strip_all_single_body.elims)"], ["", "lemma strip_all_single_var_np_imp_strip_all_body_single_unchanged: \n  \"strip_all_single_var B = None \\<Longrightarrow> strip_all_single_body B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_single_var B = None \\<Longrightarrow>\n    strip_all_single_body B = B", "by (auto elim!: strip_all_single_var.elims)"], ["", "lemma strip_all_single_form: \"strip_all_single_var B = Some \\<tau>\n  \\<Longrightarrow> Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $ Abs \\<tau> (strip_all_single_body B) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_single_var B = Some \\<tau> \\<Longrightarrow>\n    Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> (strip_all_single_body B) =\n    B", "by (auto elim!: strip_all_single_var.elims split: if_splits)"], ["", "lemma proves_strip_all_single:\n  assumes \"\\<Theta>, \\<Gamma> \\<turnstile> B\" \"strip_all_single_var B = Some \\<tau>\"\n    \"typ_of t = Some \\<tau>\" \"term_ok \\<Theta> t\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_bv t (strip_all_single_body B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv t (strip_all_single_body B)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv t (strip_all_single_body B)", "have 1: \"Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $ Abs \\<tau> (strip_all_single_body B) = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> (strip_all_single_body B) =\n    B", "using assms(2) strip_all_single_form"], ["proof (prove)\nusing this:\n  strip_all_single_var B = Some \\<tau>\n  strip_all_single_var ?B = Some ?\\<tau> \\<Longrightarrow>\n  Ct STR ''Pure.all'' ((?\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs ?\\<tau> (strip_all_single_body ?B) =\n  ?B\n\ngoal (1 subgoal):\n 1. Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> (strip_all_single_body B) =\n    B", "by blast"], ["proof (state)\nthis:\n  Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs \\<tau> (strip_all_single_body B) =\n  B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv t (strip_all_single_body B)", "hence \"\\<Theta>, \\<Gamma> \\<turnstile> Abs \\<tau> (strip_all_single_body B) \\<bullet> t\""], ["proof (prove)\nusing this:\n  Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs \\<tau> (strip_all_single_body B) =\n  B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> Abs \\<tau>\n                                    (strip_all_single_body B) \\<bullet>\n                                   t", "using assms forall_elim"], ["proof (prove)\nusing this:\n  Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs \\<tau> (strip_all_single_body B) =\n  B\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  strip_all_single_var B = Some \\<tau>\n  typ_of t = Some \\<tau>\n  term_ok \\<Theta> t\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n       ((?\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n      Abs ?\\<tau> ?B;\n   \\<turnstile>\\<^sub>\\<tau> ?a : ?\\<tau>;\n   wf_term (sig ?\\<Theta>) ?a\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_bv ?a ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> Abs \\<tau>\n                                    (strip_all_single_body B) \\<bullet>\n                                   t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ct STR ''Pure.all''\n              ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n             Abs \\<tau> (strip_all_single_body B) =\n             B;\n     \\<Theta>,\\<Gamma> \\<turnstile> B; strip_all_single_var B = Some \\<tau>;\n     typ_of t = Some \\<tau>; term_ok \\<Theta> t;\n     \\<And>\\<Theta> \\<Gamma> \\<tau> B a.\n        \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B;\n         \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n         wf_term (sig \\<Theta>) a\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a\n                    B\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> Abs \\<tau>\n                (strip_all_single_body B) \\<bullet>\n               t", "have \"has_typ t \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<turnstile>\\<^sub>\\<tau> t : \\<tau>", "by (meson \\<open>typ_of t = Some \\<tau>\\<close> has_typ_iff_typ_of)"], ["proof (state)\nthis:\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ct STR ''Pure.all''\n              ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n             Abs \\<tau> (strip_all_single_body B) =\n             B;\n     \\<Theta>,\\<Gamma> \\<turnstile> B; strip_all_single_var B = Some \\<tau>;\n     typ_of t = Some \\<tau>; term_ok \\<Theta> t;\n     \\<And>\\<Theta> \\<Gamma> \\<tau> B a.\n        \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n           ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n          Abs \\<tau> B;\n         \\<turnstile>\\<^sub>\\<tau> a : \\<tau>;\n         wf_term (sig \\<Theta>) a\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a\n                    B\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> Abs \\<tau>\n                (strip_all_single_body B) \\<bullet>\n               t", "then"], ["proof (chain)\npicking this:\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau>\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> Abs \\<tau>\n                                    (strip_all_single_body B) \\<bullet>\n                                   t", "by (metis \"1\" assms(1) assms(4) betapply.simps(1) forall_elim term_ok_def wt_term_def)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> Abs \\<tau>\n                                  (strip_all_single_body B) \\<bullet>\n                                 t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> Abs \\<tau>\n                                  (strip_all_single_body B) \\<bullet>\n                                 t\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv t (strip_all_single_body B)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> Abs \\<tau>\n                                  (strip_all_single_body B) \\<bullet>\n                                 t\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv t (strip_all_single_body B)", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_bv t (strip_all_single_body B)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary proves_strip_all_single_Fv:\n  assumes \"\\<Theta>, \\<Gamma> \\<turnstile> B\" \"strip_all_single_var B = Some \\<tau>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>) (strip_all_single_body B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "have ok: \"term_ok \\<Theta> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> B", "using assms(1) proved_terms_well_formed(2)"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  ?\\<Theta>,?\\<Gamma> \\<turnstile> ?p \\<Longrightarrow> term_ok ?\\<Theta> ?p\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> B", "by auto"], ["proof (state)\nthis:\n  term_ok \\<Theta> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "thm strip_all_single_form \n      wt_term_def term_ok_var typ_of_var typ_ok_def proves_strip_all_single \n      strip_all_single_form"], ["proof (state)\nthis:\n  term_ok \\<Theta> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "have s: \"B = Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $ Abs \\<tau> (strip_all_single_body B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B =\n    Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> (strip_all_single_body B)", "using assms(2) strip_all_single_form[symmetric]"], ["proof (prove)\nusing this:\n  strip_all_single_var B = Some \\<tau>\n  strip_all_single_var ?t = Some ?\\<tau> \\<Longrightarrow>\n  ?t =\n  Ct STR ''Pure.all'' ((?\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs ?\\<tau> (strip_all_single_body ?t)\n\ngoal (1 subgoal):\n 1. B =\n    Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n    Abs \\<tau> (strip_all_single_body B)", "by simp"], ["proof (state)\nthis:\n  B =\n  Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs \\<tau> (strip_all_single_body B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "have \"\\<tau> \\<in> Types B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<in> Types B", "by (subst s, simp)"], ["proof (state)\nthis:\n  \\<tau> \\<in> Types B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "hence \"typ_ok \\<Theta> \\<tau>\""], ["proof (prove)\nusing this:\n  \\<tau> \\<in> Types B\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> \\<tau>", "by (metis ok s term_ok'.simps(4) term_ok'.simps(5) term_okD1 typ_ok_def typ_ok_sig_imp_wf_type)"], ["proof (state)\nthis:\n  typ_ok \\<Theta> \\<tau>\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "hence \"term_ok \\<Theta> (Fv x \\<tau>)\""], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> \\<tau>\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv x \\<tau>)", "using term_ok_var"], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> \\<tau>\n  term_ok ?\\<Theta> (Fv ?idn ?\\<tau>) = typ_ok ?\\<Theta> ?\\<tau>\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv x \\<tau>)", "by blast"], ["proof (state)\nthis:\n  term_ok \\<Theta> (Fv x \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "then"], ["proof (chain)\npicking this:\n  term_ok \\<Theta> (Fv x \\<tau>)", "show ?thesis"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (Fv x \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "using assms proves_strip_all_single[where \\<tau>=\\<tau>]"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (Fv x \\<tau>)\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  strip_all_single_var B = Some \\<tau>\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   strip_all_single_var ?B = Some \\<tau>; typ_of ?t = Some \\<tau>;\n   term_ok ?\\<Theta> ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_bv ?t\n                (strip_all_single_body ?B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "by auto"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                  (strip_all_single_body B)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strip_all_vars_no_strip_all_body_unchanged[simp]: \n  \"strip_all_vars B = [] \\<Longrightarrow> strip_all_body B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_vars B = [] \\<Longrightarrow> strip_all_body B = B", "by (auto elim!: strip_all_vars.elims)"], ["", "lemma \"strip_all_vars B = (\\<tau>s@[\\<tau>]) \\<Longrightarrow> strip_all_body B \n  = strip_all_single_body (Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $ Abs \\<tau> (strip_all_body B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_vars B = \\<tau>s @ [\\<tau>] \\<Longrightarrow>\n    strip_all_body B =\n    strip_all_single_body\n     (Ct STR ''Pure.all''\n       ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n      Abs \\<tau> (strip_all_body B))", "by simp"], ["", "lemma strip_all_vars_incr_bv: \"strip_all_vars (incr_bv inc lev t) = strip_all_vars t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_vars (incr_bv inc lev t) = strip_all_vars t", "by (induction t arbitrary: lev rule: strip_all_vars.induct) auto"], ["", "lemma strip_all_vars_incr_boundvars: \"strip_all_vars (incr_boundvars inc t) = strip_all_vars t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_vars (incr_boundvars inc t) = strip_all_vars t", "using incr_boundvars_def strip_all_vars_incr_bv"], ["proof (prove)\nusing this:\n  incr_boundvars ?inc ?t = incr_bv ?inc 0 ?t\n  strip_all_vars (incr_bv ?inc ?lev ?t) = strip_all_vars ?t\n\ngoal (1 subgoal):\n 1. strip_all_vars (incr_boundvars inc t) = strip_all_vars t", "by simp"], ["", "lemma strip_all_vars_subst_bv1_Fv:\n  \"strip_all_vars (subst_bv1 B lev (Fv x \\<tau>)) = strip_all_vars B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_vars (subst_bv1 B lev (Fv x \\<tau>)) = strip_all_vars B", "by (induction B arbitrary: lev rule: strip_all_vars.induct) (auto simp add: incr_boundvars_def)"], ["", "lemma strip_all_vars_subst_bv_Fv:\n  \"strip_all_vars (subst_bv (Fv x \\<tau>) B) = strip_all_vars B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_vars (subst_bv (Fv x \\<tau>) B) = strip_all_vars B", "by (simp add: strip_all_vars_subst_bv1_Fv subst_bv_def)"], ["", "lemma \"strip_all_single_var B = Some \\<tau>\n  \\<Longrightarrow> strip_all_vars (subst_bv (Fv x \\<tau>) (strip_all_single_body B)) = tl (strip_all_vars B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_single_var B = Some \\<tau> \\<Longrightarrow>\n    strip_all_vars (subst_bv (Fv x \\<tau>) (strip_all_single_body B)) =\n    tl (strip_all_vars B)", "by (metis list.sel(3) strip_all_vars_step strip_all_vars_subst_bv_Fv)"], ["", "(* Allowing general terms instead of just vars here is more difficult as one could create new leading\n  \\<And>s *)"], ["", "corollary proves_strip_all_vars_Fv:\n  assumes \"length xs = length (strip_all_vars B)\" \"\\<Theta>, \\<Gamma> \\<turnstile> B\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> fold (\\<lambda>(x,\\<tau>). subst_bv (Fv x \\<tau>) o strip_all_single_body)\n    (zip xs (strip_all_vars B)) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>(x, \\<tau>).\n  subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                    (zip xs (strip_all_vars B)) B", "using assms"], ["proof (prove)\nusing this:\n  length xs = length (strip_all_vars B)\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>(x, \\<tau>).\n  subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                    (zip xs (strip_all_vars B)) B", "proof (induction xs \"strip_all_vars B\" arbitrary: B rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>[] = strip_all_vars B;\n        \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip [] (strip_all_vars B)) B\n 2. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "case Nil"], ["proof (state)\nthis:\n  [] = strip_all_vars B\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>[] = strip_all_vars B;\n        \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip [] (strip_all_vars B)) B\n 2. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "then"], ["proof (chain)\npicking this:\n  [] = strip_all_vars B\n  \\<Theta>,\\<Gamma> \\<turnstile> B", "show ?case"], ["proof (prove)\nusing this:\n  [] = strip_all_vars B\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>a.\n  case a of\n  (x, \\<tau>) \\<Rightarrow>\n    subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                    (zip [] (strip_all_vars B)) B", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                  (\\<lambda>a.\ncase a of\n(x, \\<tau>) \\<Rightarrow>\n  subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                  (zip [] (strip_all_vars B)) B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "case (Cons x xs \\<tau> \\<tau>s)"], ["proof (state)\nthis:\n  length xs = length \\<tau>s\n  \\<lbrakk>\\<tau>s = strip_all_vars ?B;\n   \\<Theta>,\\<Gamma> \\<turnstile> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>(x, \\<tau>).\n                  subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n              (zip xs (strip_all_vars ?B)) ?B\n  \\<tau> # \\<tau>s = strip_all_vars B\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "have st: \"strip_all_single_var B = Some \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_single_var B = Some \\<tau>", "by (metis Cons.hyps(3) is_all_iff_strip_all_vars_not_empty list.distinct(1) list.inject \n        option.exhaust strip_all_single_var_is_all strip_all_vars_step)"], ["proof (state)\nthis:\n  strip_all_single_var B = Some \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "moreover"], ["proof (state)\nthis:\n  strip_all_single_var B = Some \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "have \"term_ok \\<Theta> (Fv x \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv x \\<tau>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv x \\<tau>)", "obtain B' where \"Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $ Abs \\<tau> B' = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>B'.\n        Ct STR ''Pure.all''\n         ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n        Abs \\<tau> B' =\n        B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using st strip_all_single_form"], ["proof (prove)\nusing this:\n  strip_all_single_var B = Some \\<tau>\n  strip_all_single_var ?B = Some ?\\<tau> \\<Longrightarrow>\n  Ct STR ''Pure.all'' ((?\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs ?\\<tau> (strip_all_single_body ?B) =\n  ?B\n\ngoal (1 subgoal):\n 1. (\\<And>B'.\n        Ct STR ''Pure.all''\n         ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n        Abs \\<tau> B' =\n        B \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs \\<tau> B' =\n  B\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv x \\<tau>)", "moreover"], ["proof (state)\nthis:\n  Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs \\<tau> B' =\n  B\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv x \\<tau>)", "have \"term_ok \\<Theta> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> B", "using Cons.prems proved_terms_well_formed(2)"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  ?\\<Theta>,?\\<Gamma> \\<turnstile> ?p \\<Longrightarrow> term_ok ?\\<Theta> ?p\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> B", "by auto"], ["proof (state)\nthis:\n  term_ok \\<Theta> B\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv x \\<tau>)", "ultimately"], ["proof (chain)\npicking this:\n  Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs \\<tau> B' =\n  B\n  term_ok \\<Theta> B", "have \"typ_ok \\<Theta> \\<tau>\""], ["proof (prove)\nusing this:\n  Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs \\<tau> B' =\n  B\n  term_ok \\<Theta> B\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> \\<tau>", "using term_ok'.simps(5) term_ok'.simps(4) term_ok_def wt_term_def typ_ok_def"], ["proof (prove)\nusing this:\n  Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n  Abs \\<tau> B' =\n  B\n  term_ok \\<Theta> B\n  term_ok' ?\\<Sigma> (Abs ?T ?t) =\n  (typ_ok_sig ?\\<Sigma> ?T \\<and> term_ok' ?\\<Sigma> ?t)\n  term_ok' ?\\<Sigma> (?t $ ?u) =\n  (term_ok' ?\\<Sigma> ?t \\<and> term_ok' ?\\<Sigma> ?u)\n  term_ok ?\\<Theta> ?t \\<equiv> wt_term (sig ?\\<Theta>) ?t\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  typ_ok ?\\<Theta> ?T \\<equiv> wf_type (sig ?\\<Theta>) ?T\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> \\<tau>", "by blast"], ["proof (state)\nthis:\n  typ_ok \\<Theta> \\<tau>\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv x \\<tau>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> \\<tau>\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv x \\<tau>)", "unfolding term_ok_def wt_term_def typ_ok_def"], ["proof (prove)\nusing this:\n  wf_type (sig \\<Theta>) \\<tau>\n\ngoal (1 subgoal):\n 1. wf_term (sig \\<Theta>) (Fv x \\<tau>) \\<and>\n    (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> Fv x \\<tau> : T)", "by simp"], ["proof (state)\nthis:\n  term_ok \\<Theta> (Fv x \\<tau>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  term_ok \\<Theta> (Fv x \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "ultimately"], ["proof (chain)\npicking this:\n  strip_all_single_var B = Some \\<tau>\n  term_ok \\<Theta> (Fv x \\<tau>)", "have 1: \"\\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>) (strip_all_single_body B)\""], ["proof (prove)\nusing this:\n  strip_all_single_var B = Some \\<tau>\n  term_ok \\<Theta> (Fv x \\<tau>)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "using proves_strip_all_single"], ["proof (prove)\nusing this:\n  strip_all_single_var B = Some \\<tau>\n  term_ok \\<Theta> (Fv x \\<tau>)\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   strip_all_single_var ?B = Some ?\\<tau>; typ_of ?t = Some ?\\<tau>;\n   term_ok ?\\<Theta> ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_bv ?t\n                (strip_all_single_body ?B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "by (simp add: Cons.prems proves_strip_all_single_Fv)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                  (strip_all_single_body B)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "have \"\\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>(x, \\<tau>). subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n    (zip xs (strip_all_vars (subst_bv (Fv x \\<tau>) (strip_all_single_body B)))) \n      (subst_bv (Fv x \\<tau>) (strip_all_single_body B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>(x, \\<tau>).\n  subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                    (zip xs\n(strip_all_vars (subst_bv (Fv x \\<tau>) (strip_all_single_body B))))\n                                    (subst_bv (Fv x \\<tau>)\n(strip_all_single_body B))", "apply (rule Cons.hyps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<tau>s =\n    strip_all_vars (subst_bv (Fv x \\<tau>) (strip_all_single_body B))\n 2. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "apply (metis Cons.hyps(3) list.inject st strip_all_vars_step strip_all_vars_subst_bv_Fv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "using 1"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                  (strip_all_single_body B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B)", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                  (\\<lambda>(x, \\<tau>).\nsubst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                  (zip xs\n                                    (strip_all_vars\n(subst_bv (Fv x \\<tau>) (strip_all_single_body B))))\n                                  (subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "moreover"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                  (\\<lambda>(x, \\<tau>).\nsubst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                  (zip xs\n                                    (strip_all_vars\n(subst_bv (Fv x \\<tau>) (strip_all_single_body B))))\n                                  (subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "have \"strip_all_vars B = \\<tau> # \\<tau>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_all_vars B = \\<tau> # \\<tau>s", "using Cons.hyps(3)"], ["proof (prove)\nusing this:\n  \\<tau> # \\<tau>s = strip_all_vars B\n\ngoal (1 subgoal):\n 1. strip_all_vars B = \\<tau> # \\<tau>s", "by auto"], ["proof (state)\nthis:\n  strip_all_vars B = \\<tau> # \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys B.\n       \\<lbrakk>length xs = length ys;\n        \\<And>B.\n           \\<lbrakk>ys = strip_all_vars B;\n            \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                       (\\<lambda>(x, \\<tau>).\n                           subst_bv (Fv x \\<tau>) \\<circ>\n                           strip_all_single_body)\n                       (zip xs (strip_all_vars B)) B;\n        y # ys = strip_all_vars B; \\<Theta>,\\<Gamma> \\<turnstile> B\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>(x, \\<tau>).\n                       subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                   (zip (x # xs) (strip_all_vars B)) B", "ultimately"], ["proof (chain)\npicking this:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                  (\\<lambda>(x, \\<tau>).\nsubst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                  (zip xs\n                                    (strip_all_vars\n(subst_bv (Fv x \\<tau>) (strip_all_single_body B))))\n                                  (subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B))\n  strip_all_vars B = \\<tau> # \\<tau>s", "show ?case"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                  (\\<lambda>(x, \\<tau>).\nsubst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                  (zip xs\n                                    (strip_all_vars\n(subst_bv (Fv x \\<tau>) (strip_all_single_body B))))\n                                  (subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B))\n  strip_all_vars B = \\<tau> # \\<tau>s\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>(x, \\<tau>).\n  subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                    (zip (x # xs) (strip_all_vars B)) B", "using st strip_all_vars_step strip_all_vars_subst_bv_Fv"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                  (\\<lambda>(x, \\<tau>).\nsubst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                  (zip xs\n                                    (strip_all_vars\n(subst_bv (Fv x \\<tau>) (strip_all_single_body B))))\n                                  (subst_bv (Fv x \\<tau>)\n                                    (strip_all_single_body B))\n  strip_all_vars B = \\<tau> # \\<tau>s\n  strip_all_single_var B = Some \\<tau>\n  strip_all_single_var ?t = Some ?T \\<Longrightarrow>\n  ?T # strip_all_vars (strip_all_single_body ?t) = strip_all_vars ?t\n  strip_all_vars (subst_bv (Fv ?x ?\\<tau>) ?B) = strip_all_vars ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>(x, \\<tau>).\n  subst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                    (zip (x # xs) (strip_all_vars B)) B", "by fastforce"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                  (\\<lambda>(x, \\<tau>).\nsubst_bv (Fv x \\<tau>) \\<circ> strip_all_single_body)\n                                  (zip (x # xs) (strip_all_vars B)) B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trivial_pre_depr: \"term_ok \\<Theta> c \\<Longrightarrow> typ_of c = Some propT \\<Longrightarrow> \\<Theta>, {c} \\<turnstile> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>term_ok \\<Theta> c; typ_of c = Some propT\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,{c} \\<turnstile> c", "by (rule \"assume\") (simp_all add: wt_term_def)"], ["", "lemma trivial_pre:\n  assumes \"wf_theory \\<Theta>\" \"term_ok \\<Theta> c\" \"typ_of c = Some propT\"\n  shows \"\\<Theta>, {} \\<turnstile> c \\<longmapsto> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,{} \\<turnstile> c \\<longmapsto> c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>,{} \\<turnstile> c \\<longmapsto> c", "have s: \"{} = {c} - {c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} = {c} - {c}", "by simp"], ["proof (state)\nthis:\n  {} = {c} - {c}\n\ngoal (1 subgoal):\n 1. \\<Theta>,{} \\<turnstile> c \\<longmapsto> c", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,{} \\<turnstile> c \\<longmapsto> c", "apply (subst s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,{c} - {c} \\<turnstile> c \\<longmapsto> c", "apply (rule \"implies_intro\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,{c} \\<turnstile> c\n 3. wf_term (sig \\<Theta>) c\n 4. \\<turnstile>\\<^sub>\\<tau> c : propT", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  term_ok \\<Theta> c\n  typ_of c = Some propT\n\ngoal (4 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,{c} \\<turnstile> c\n 3. wf_term (sig \\<Theta>) c\n 4. \\<turnstile>\\<^sub>\\<tau> c : propT", "by (auto simp add: wt_term_def intro: \"assume\")"], ["proof (state)\nthis:\n  \\<Theta>,{} \\<turnstile> c \\<longmapsto> c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inst_var: \n  assumes wf_theory: \"wf_theory \\<Theta>\"\n  assumes B: \"\\<Theta>, \\<Gamma> \\<turnstile> B\"\n  assumes a_ok: \"term_ok \\<Theta> a\" \n  assumes typ_a: \"typ_of a = Some \\<tau>\"\n  assumes free: \"(x,\\<tau>) \\<notin> FV \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "have s1: \"mk_all x \\<tau> B = Ct STR ''Pure.all'' ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $ \n    Abs \\<tau> (bind_fv (x, \\<tau>) B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_all x \\<tau> B = mk_all x \\<tau> B", "by (simp add: typ_of_def)"], ["proof (state)\nthis:\n  mk_all x \\<tau> B = mk_all x \\<tau> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "have closed_B: \"is_closed B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_closed B", "using B proved_terms_well_formed_pre"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  ?\\<Theta>,?\\<Gamma> \\<turnstile> ?p \\<Longrightarrow>\n  typ_of ?p = Some propT \\<and> term_ok ?\\<Theta> ?p\n\ngoal (1 subgoal):\n 1. is_closed B", "using typ_of_imp_closed"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  ?\\<Theta>,?\\<Gamma> \\<turnstile> ?p \\<Longrightarrow>\n  typ_of ?p = Some propT \\<and> term_ok ?\\<Theta> ?p\n  typ_of ?t = Some ?ty \\<Longrightarrow> is_closed ?t\n\ngoal (1 subgoal):\n 1. is_closed B", "by blast"], ["proof (state)\nthis:\n  is_closed B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "have \"typ_ok \\<Theta> \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> \\<tau>", "using wt_term_def typ_ok_def term_ok_imp_typ_ok"], ["proof (prove)\nusing this:\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  typ_ok ?\\<Theta> ?T \\<equiv> wf_type (sig ?\\<Theta>) ?T\n  \\<lbrakk>wf_theory ?thy; term_ok ?thy ?t; typ_of ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?thy ?ty\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> \\<tau>", "using a_ok wf_theory typ_a"], ["proof (prove)\nusing this:\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  typ_ok ?\\<Theta> ?T \\<equiv> wf_type (sig ?\\<Theta>) ?T\n  \\<lbrakk>wf_theory ?thy; term_ok ?thy ?t; typ_of ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?thy ?ty\n  term_ok \\<Theta> a\n  wf_theory \\<Theta>\n  typ_of a = Some \\<tau>\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> \\<tau>", "by blast"], ["proof (state)\nthis:\n  typ_ok \\<Theta> \\<tau>\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "hence p1: \"\\<Theta>, \\<Gamma> \\<turnstile> mk_all x \\<tau> B\""], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> \\<tau>\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> mk_all x \\<tau> B", "using forall_intro[OF wf_theory B] B typ_a wt_term_def wf_theory \n        term_ok_imp_typ_ok free"], ["proof (prove)\nusing this:\n  typ_ok \\<Theta> \\<tau>\n  \\<lbrakk>(?x, ?\\<tau>) \\<notin> FV \\<Gamma>;\n   wf_type (sig \\<Theta>) ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> mk_all ?x ?\\<tau> B\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  typ_of a = Some \\<tau>\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  wf_theory \\<Theta>\n  \\<lbrakk>wf_theory ?thy; term_ok ?thy ?t; typ_of ?t = Some ?ty\\<rbrakk>\n  \\<Longrightarrow> typ_ok ?thy ?ty\n  (x, \\<tau>) \\<notin> FV \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> mk_all x \\<tau> B", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> mk_all x \\<tau> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "have \"\\<Theta>, \\<Gamma> \\<turnstile> subst_bv a (bind_fv (x, \\<tau>) B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a (bind_fv (x, \\<tau>) B)", "using forall_elim[of _ _ \\<tau>] p1 typ_a a_ok proves_strip_all_single"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n       ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n      Abs \\<tau> ?B;\n   \\<turnstile>\\<^sub>\\<tau> ?a : \\<tau>;\n   wf_term (sig ?\\<Theta>) ?a\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_bv ?a ?B\n  \\<Theta>,\\<Gamma> \\<turnstile> mk_all x \\<tau> B\n  typ_of a = Some \\<tau>\n  term_ok \\<Theta> a\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   strip_all_single_var ?B = Some ?\\<tau>; typ_of ?t = Some ?\\<tau>;\n   term_ok ?\\<Theta> ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_bv ?t\n                (strip_all_single_body ?B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a (bind_fv (x, \\<tau>) B)", "by (meson has_typ_iff_typ_of term_ok_def wt_term_def)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a (bind_fv (x, \\<tau>) B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "have \"\\<Theta>, \\<Gamma> \\<turnstile> subst_bv a ((bind_fv (x, \\<tau>) B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a (bind_fv (x, \\<tau>) B)", "using forall_elim[of _ _ \\<tau>] p1 typ_a a_ok proves_strip_all_single"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n       ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n      Abs \\<tau> ?B;\n   \\<turnstile>\\<^sub>\\<tau> ?a : \\<tau>;\n   wf_term (sig ?\\<Theta>) ?a\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_bv ?a ?B\n  \\<Theta>,\\<Gamma> \\<turnstile> mk_all x \\<tau> B\n  typ_of a = Some \\<tau>\n  term_ok \\<Theta> a\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   strip_all_single_var ?B = Some ?\\<tau>; typ_of ?t = Some ?\\<tau>;\n   term_ok ?\\<Theta> ?t\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_bv ?t\n                (strip_all_single_body ?B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a (bind_fv (x, \\<tau>) B)", "by (meson has_typ_iff_typ_of term_ok_def wt_term_def)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a (bind_fv (x, \\<tau>) B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "thus \"\\<Theta>, \\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B\""], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a (bind_fv (x, \\<tau>) B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "using instantiate_var_same_type'' assms closed_B"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_bv a (bind_fv (x, \\<tau>) B)\n  \\<lbrakk>typ_of ?a = Some ?\\<tau>; is_closed ?B\\<rbrakk>\n  \\<Longrightarrow> Abs_fv ?x ?\\<tau> ?B \\<bullet> ?a =\n                    subst_term [((?x, ?\\<tau>), ?a)] ?B\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> a\n  typ_of a = Some \\<tau>\n  (x, \\<tau>) \\<notin> FV \\<Gamma>\n  is_closed B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), a)] B\n\ngoal:\nNo subgoals!", "qed"], ["", "(* MOVE *)"], ["", "lemma subst_term_single_no_change[simp]:\n  assumes nvar: \"(x,\\<tau>)\\<notin>fv B\"\n  shows \"subst_term [((x,\\<tau>), t)] B = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term [((x, \\<tau>), t)] B = B", "using assms"], ["proof (prove)\nusing this:\n  (x, \\<tau>) \\<notin> fv B\n\ngoal (1 subgoal):\n 1. subst_term [((x, \\<tau>), t)] B = B", "by (induction B) auto"], ["", "lemma fv_subst_term_single:\n  assumes var: \"(x,\\<tau>)\\<in>fv B\"\n  assumes \"\\<And>p . p \\<in> fv t \\<Longrightarrow> p ~= (x,\\<tau>)\"\n  shows \"fv (subst_term [((x,\\<tau>), t)] B) = fv B - {(x,\\<tau>)} \\<union> fv t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (subst_term [((x, \\<tau>), t)] B) =\n    fv B - {(x, \\<tau>)} \\<union> fv t", "using assms"], ["proof (prove)\nusing this:\n  (x, \\<tau>) \\<in> fv B\n  ?p \\<in> fv t \\<Longrightarrow> ?p \\<noteq> (x, \\<tau>)\n\ngoal (1 subgoal):\n 1. fv (subst_term [((x, \\<tau>), t)] B) =\n    fv B - {(x, \\<tau>)} \\<union> fv t", "proof (induction B)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(x, \\<tau>) \\<in> fv (Ct x1 x2);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Ct x1 x2)) =\n                         fv (Ct x1 x2) - {(x, \\<tau>)} \\<union> fv t\n 2. \\<And>x1 x2.\n       \\<lbrakk>(x, \\<tau>) \\<in> fv (Fv x1 x2);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Fv x1 x2)) =\n                         fv (Fv x1 x2) - {(x, \\<tau>)} \\<union> fv t\n 3. \\<And>xa.\n       \\<lbrakk>(x, \\<tau>) \\<in> fv (Bv xa);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Bv xa)) =\n                         fv (Bv xa) - {(x, \\<tau>)} \\<union> fv t\n 4. \\<And>x1 B.\n       \\<lbrakk>\\<lbrakk>(x, \\<tau>) \\<in> fv B;\n                 \\<And>p.\n                    p \\<in> fv t \\<Longrightarrow>\n                    p \\<noteq> (x, \\<tau>)\\<rbrakk>\n                \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B) =\n                                  fv B - {(x, \\<tau>)} \\<union> fv t;\n        (x, \\<tau>) \\<in> fv (Abs x1 B);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Abs x1 B)) =\n                         fv (Abs x1 B) - {(x, \\<tau>)} \\<union> fv t\n 5. \\<And>B1 B2.\n       \\<lbrakk>\\<lbrakk>(x, \\<tau>) \\<in> fv B1;\n                 \\<And>p.\n                    p \\<in> fv t \\<Longrightarrow>\n                    p \\<noteq> (x, \\<tau>)\\<rbrakk>\n                \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B1) =\n                                  fv B1 - {(x, \\<tau>)} \\<union> fv t;\n        \\<lbrakk>(x, \\<tau>) \\<in> fv B2;\n         \\<And>p.\n            p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n        \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B2) =\n                          fv B2 - {(x, \\<tau>)} \\<union> fv t;\n        (x, \\<tau>) \\<in> fv (B1 $ B2);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (B1 $ B2)) =\n                         fv (B1 $ B2) - {(x, \\<tau>)} \\<union> fv t", "case (App B1 B2)"], ["proof (state)\nthis:\n  \\<lbrakk>(x, \\<tau>) \\<in> fv B1;\n   \\<And>p. p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n  \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B1) =\n                    fv B1 - {(x, \\<tau>)} \\<union> fv t\n  \\<lbrakk>(x, \\<tau>) \\<in> fv B2;\n   \\<And>p. p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n  \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B2) =\n                    fv B2 - {(x, \\<tau>)} \\<union> fv t\n  (x, \\<tau>) \\<in> fv (B1 $ B2)\n  ?p \\<in> fv t \\<Longrightarrow> ?p \\<noteq> (x, \\<tau>)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(x, \\<tau>) \\<in> fv (Ct x1 x2);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Ct x1 x2)) =\n                         fv (Ct x1 x2) - {(x, \\<tau>)} \\<union> fv t\n 2. \\<And>x1 x2.\n       \\<lbrakk>(x, \\<tau>) \\<in> fv (Fv x1 x2);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Fv x1 x2)) =\n                         fv (Fv x1 x2) - {(x, \\<tau>)} \\<union> fv t\n 3. \\<And>xa.\n       \\<lbrakk>(x, \\<tau>) \\<in> fv (Bv xa);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Bv xa)) =\n                         fv (Bv xa) - {(x, \\<tau>)} \\<union> fv t\n 4. \\<And>x1 B.\n       \\<lbrakk>\\<lbrakk>(x, \\<tau>) \\<in> fv B;\n                 \\<And>p.\n                    p \\<in> fv t \\<Longrightarrow>\n                    p \\<noteq> (x, \\<tau>)\\<rbrakk>\n                \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B) =\n                                  fv B - {(x, \\<tau>)} \\<union> fv t;\n        (x, \\<tau>) \\<in> fv (Abs x1 B);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Abs x1 B)) =\n                         fv (Abs x1 B) - {(x, \\<tau>)} \\<union> fv t\n 5. \\<And>B1 B2.\n       \\<lbrakk>\\<lbrakk>(x, \\<tau>) \\<in> fv B1;\n                 \\<And>p.\n                    p \\<in> fv t \\<Longrightarrow>\n                    p \\<noteq> (x, \\<tau>)\\<rbrakk>\n                \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B1) =\n                                  fv B1 - {(x, \\<tau>)} \\<union> fv t;\n        \\<lbrakk>(x, \\<tau>) \\<in> fv B2;\n         \\<And>p.\n            p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n        \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B2) =\n                          fv B2 - {(x, \\<tau>)} \\<union> fv t;\n        (x, \\<tau>) \\<in> fv (B1 $ B2);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (B1 $ B2)) =\n                         fv (B1 $ B2) - {(x, \\<tau>)} \\<union> fv t", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(x, \\<tau>) \\<in> fv B1;\n   \\<And>p. p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n  \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B1) =\n                    fv B1 - {(x, \\<tau>)} \\<union> fv t\n  \\<lbrakk>(x, \\<tau>) \\<in> fv B2;\n   \\<And>p. p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n  \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B2) =\n                    fv B2 - {(x, \\<tau>)} \\<union> fv t\n  (x, \\<tau>) \\<in> fv (B1 $ B2)\n  ?p \\<in> fv t \\<Longrightarrow> ?p \\<noteq> (x, \\<tau>)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, \\<tau>) \\<in> fv B1;\n   \\<And>p. p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n  \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B1) =\n                    fv B1 - {(x, \\<tau>)} \\<union> fv t\n  \\<lbrakk>(x, \\<tau>) \\<in> fv B2;\n   \\<And>p. p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n  \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B2) =\n                    fv B2 - {(x, \\<tau>)} \\<union> fv t\n  (x, \\<tau>) \\<in> fv (B1 $ B2)\n  ?p \\<in> fv t \\<Longrightarrow> ?p \\<noteq> (x, \\<tau>)\n\ngoal (1 subgoal):\n 1. fv (subst_term [((x, \\<tau>), t)] (B1 $ B2)) =\n    fv (B1 $ B2) - {(x, \\<tau>)} \\<union> fv t", "by (cases \"(x,\\<tau>)\\<in>fv B1\"; cases \"(x,\\<tau>)\\<in>fv B2\") auto"], ["proof (state)\nthis:\n  fv (subst_term [((x, \\<tau>), t)] (B1 $ B2)) =\n  fv (B1 $ B2) - {(x, \\<tau>)} \\<union> fv t\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>(x, \\<tau>) \\<in> fv (Ct x1 x2);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Ct x1 x2)) =\n                         fv (Ct x1 x2) - {(x, \\<tau>)} \\<union> fv t\n 2. \\<And>x1 x2.\n       \\<lbrakk>(x, \\<tau>) \\<in> fv (Fv x1 x2);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Fv x1 x2)) =\n                         fv (Fv x1 x2) - {(x, \\<tau>)} \\<union> fv t\n 3. \\<And>xa.\n       \\<lbrakk>(x, \\<tau>) \\<in> fv (Bv xa);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Bv xa)) =\n                         fv (Bv xa) - {(x, \\<tau>)} \\<union> fv t\n 4. \\<And>x1 B.\n       \\<lbrakk>\\<lbrakk>(x, \\<tau>) \\<in> fv B;\n                 \\<And>p.\n                    p \\<in> fv t \\<Longrightarrow>\n                    p \\<noteq> (x, \\<tau>)\\<rbrakk>\n                \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] B) =\n                                  fv B - {(x, \\<tau>)} \\<union> fv t;\n        (x, \\<tau>) \\<in> fv (Abs x1 B);\n        \\<And>p.\n           p \\<in> fv t \\<Longrightarrow> p \\<noteq> (x, \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> fv (subst_term [((x, \\<tau>), t)] (Abs x1 B)) =\n                         fv (Abs x1 B) - {(x, \\<tau>)} \\<union> fv t", "qed simp_all"], ["", "(* TODO: Get rid of distinctness and non_overlap by performing standard single to parallel substitution\n  construction: Rename variables, then substitute the now non problematic terms\n\n  TODO: Check assms for useless ones, improve syntax\n*)"], ["", "lemma inst_vars_pre: \n  assumes wf_theory: \"wf_theory \\<Theta>\"\n  assumes B: \"\\<Theta>, \\<Gamma> \\<turnstile> B\"\n  (*assumes vars: \"set (map fst insts) \\<subseteq> fv B\"*)\n  assumes vars_ok: \"list_all (term_ok \\<Theta>) (map snd insts)\"\n  assumes typs_ok: \"list_all (\\<lambda>((idx, ty), t) . typ_of t = Some ty) insts\"\n  assumes free: \"list_all (\\<lambda>((idx, ty), t) . (idx, ty) \\<notin> FV \\<Gamma>) insts\"\n  assumes typ_a: \"typ_of a = Some \\<tau>\"\n  assumes distinct: \"distinct (map fst insts)\"\n  assumes no_overlap: \"\\<And>x . x \\<in> (\\<Union>t \\<in> snd ` (set insts) . fv t) \\<Longrightarrow> x \\<notin> fst ` (set insts)\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single]) insts B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    insts B", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd insts)\n  list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) insts\n  list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>) insts\n  typ_of a = Some \\<tau>\n  distinct (map fst insts)\n  ?x \\<in> \\<Union> (fv ` snd ` set insts) \\<Longrightarrow>\n  ?x \\<notin> fst ` set insts\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    insts B", "proof(induction insts arbitrary: B)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd []);\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) [];\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         [];\n        typ_of a = Some \\<tau>; distinct (map fst []);\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n           x \\<notin> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) [] B\n 2. \\<And>aa insts B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>wf_theory \\<Theta>;\n                    \\<Theta>,\\<Gamma> \\<turnstile> B;\n                    list_all (term_ok \\<Theta>) (map snd insts);\n                    list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                     insts;\n                    list_all\n                     (\\<lambda>((idx, ty), t).\n                         (idx, ty) \\<notin> FV \\<Gamma>)\n                     insts;\n                    typ_of a = Some \\<tau>; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                               (\\<lambda>single. subst_term [single]) insts\n                               B;\n        wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd (aa # insts));\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (aa # insts);\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         (aa # insts);\n        typ_of a = Some \\<tau>; distinct (map fst (aa # insts));\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set (aa # insts)) \\<Longrightarrow>\n           x \\<notin> fst ` set (aa # insts)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) (aa # insts) B", "case Nil"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd [])\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   []\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n          b)\n   []\n  typ_of a = Some \\<tau>\n  distinct (map fst [])\n  ?x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []\n\ngoal (2 subgoals):\n 1. \\<And>B.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd []);\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) [];\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         [];\n        typ_of a = Some \\<tau>; distinct (map fst []);\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n           x \\<notin> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) [] B\n 2. \\<And>aa insts B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>wf_theory \\<Theta>;\n                    \\<Theta>,\\<Gamma> \\<turnstile> B;\n                    list_all (term_ok \\<Theta>) (map snd insts);\n                    list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                     insts;\n                    list_all\n                     (\\<lambda>((idx, ty), t).\n                         (idx, ty) \\<notin> FV \\<Gamma>)\n                     insts;\n                    typ_of a = Some \\<tau>; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                               (\\<lambda>single. subst_term [single]) insts\n                               B;\n        wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd (aa # insts));\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (aa # insts);\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         (aa # insts);\n        typ_of a = Some \\<tau>; distinct (map fst (aa # insts));\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set (aa # insts)) \\<Longrightarrow>\n           x \\<notin> fst ` set (aa # insts)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) (aa # insts) B", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd [])\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   []\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n          b)\n   []\n  typ_of a = Some \\<tau>\n  distinct (map fst [])\n  ?x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd [])\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   []\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n          b)\n   []\n  typ_of a = Some \\<tau>\n  distinct (map fst [])\n  ?x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    [] B", "using B"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd [])\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   []\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n          b)\n   []\n  typ_of a = Some \\<tau>\n  distinct (map fst [])\n  ?x \\<in> \\<Union> (fv ` snd ` set []) \\<Longrightarrow>\n  ?x \\<notin> fst ` set []\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    [] B", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  [] B\n\ngoal (1 subgoal):\n 1. \\<And>aa insts B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>wf_theory \\<Theta>;\n                    \\<Theta>,\\<Gamma> \\<turnstile> B;\n                    list_all (term_ok \\<Theta>) (map snd insts);\n                    list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                     insts;\n                    list_all\n                     (\\<lambda>((idx, ty), t).\n                         (idx, ty) \\<notin> FV \\<Gamma>)\n                     insts;\n                    typ_of a = Some \\<tau>; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                               (\\<lambda>single. subst_term [single]) insts\n                               B;\n        wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd (aa # insts));\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (aa # insts);\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         (aa # insts);\n        typ_of a = Some \\<tau>; distinct (map fst (aa # insts));\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set (aa # insts)) \\<Longrightarrow>\n           x \\<notin> fst ` set (aa # insts)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) (aa # insts) B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa insts B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>wf_theory \\<Theta>;\n                    \\<Theta>,\\<Gamma> \\<turnstile> B;\n                    list_all (term_ok \\<Theta>) (map snd insts);\n                    list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                     insts;\n                    list_all\n                     (\\<lambda>((idx, ty), t).\n                         (idx, ty) \\<notin> FV \\<Gamma>)\n                     insts;\n                    typ_of a = Some \\<tau>; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                               (\\<lambda>single. subst_term [single]) insts\n                               B;\n        wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd (aa # insts));\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (aa # insts);\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         (aa # insts);\n        typ_of a = Some \\<tau>; distinct (map fst (aa # insts));\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set (aa # insts)) \\<Longrightarrow>\n           x \\<notin> fst ` set (aa # insts)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) (aa # insts) B", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> ?B;\n   list_all (term_ok \\<Theta>) (map snd xs);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n           b)\n    xs;\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (idx, ty) \\<Rightarrow>\n             \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n           b)\n    xs;\n   typ_of a = Some \\<tau>; distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single]) xs ?B\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd (x # xs))\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n          b)\n   (x # xs)\n  typ_of a = Some \\<tau>\n  distinct (map fst (x # xs))\n  ?x \\<in> \\<Union> (fv ` snd ` set (x # xs)) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa insts B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>wf_theory \\<Theta>;\n                    \\<Theta>,\\<Gamma> \\<turnstile> B;\n                    list_all (term_ok \\<Theta>) (map snd insts);\n                    list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                     insts;\n                    list_all\n                     (\\<lambda>((idx, ty), t).\n                         (idx, ty) \\<notin> FV \\<Gamma>)\n                     insts;\n                    typ_of a = Some \\<tau>; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                               (\\<lambda>single. subst_term [single]) insts\n                               B;\n        wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd (aa # insts));\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (aa # insts);\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         (aa # insts);\n        typ_of a = Some \\<tau>; distinct (map fst (aa # insts));\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set (aa # insts)) \\<Longrightarrow>\n           x \\<notin> fst ` set (aa # insts)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) (aa # insts) B", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> ?B;\n   list_all (term_ok \\<Theta>) (map snd xs);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n           b)\n    xs;\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (idx, ty) \\<Rightarrow>\n             \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n           b)\n    xs;\n   typ_of a = Some \\<tau>; distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single]) xs ?B\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd (x # xs))\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n          b)\n   (x # xs)\n  typ_of a = Some \\<tau>\n  distinct (map fst (x # xs))\n  ?x \\<in> \\<Union> (fv ` snd ` set (x # xs)) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (x # xs)", "obtain idn ty t where x: \"x = ((idn, ty), t)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> ?B;\n   list_all (term_ok \\<Theta>) (map snd xs);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n           b)\n    xs;\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (idx, ty) \\<Rightarrow>\n             \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n           b)\n    xs;\n   typ_of a = Some \\<tau>; distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single]) xs ?B\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd (x # xs))\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n          b)\n   (x # xs)\n  typ_of a = Some \\<tau>\n  distinct (map fst (x # xs))\n  ?x \\<in> \\<Union> (fv ` snd ` set (x # xs)) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (x # xs)\n\ngoal (1 subgoal):\n 1. (\\<And>idn ty t.\n        x = ((idn, ty), t) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  x = ((idn, ty), t)\n\ngoal (1 subgoal):\n 1. \\<And>aa insts B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>wf_theory \\<Theta>;\n                    \\<Theta>,\\<Gamma> \\<turnstile> B;\n                    list_all (term_ok \\<Theta>) (map snd insts);\n                    list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                     insts;\n                    list_all\n                     (\\<lambda>((idx, ty), t).\n                         (idx, ty) \\<notin> FV \\<Gamma>)\n                     insts;\n                    typ_of a = Some \\<tau>; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                               (\\<lambda>single. subst_term [single]) insts\n                               B;\n        wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd (aa # insts));\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (aa # insts);\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         (aa # insts);\n        typ_of a = Some \\<tau>; distinct (map fst (aa # insts));\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set (aa # insts)) \\<Longrightarrow>\n           x \\<notin> fst ` set (aa # insts)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) (aa # insts) B", "have \"\\<Theta>, \\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single]) (x # xs) B\n    \\<longleftrightarrow> \\<Theta>, \\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single]) xs (subst_term [x] B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                     (\\<lambda>single. subst_term [single])\n                                     (x # xs) B) =\n    (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                     (\\<lambda>single. subst_term [single])\n                                     xs (subst_term [x] B))", "by simp"], ["proof (state)\nthis:\n  (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (x # xs) B) =\n  (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                   (\\<lambda>single. subst_term [single]) xs\n                                   (subst_term [x] B))\n\ngoal (1 subgoal):\n 1. \\<And>aa insts B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>wf_theory \\<Theta>;\n                    \\<Theta>,\\<Gamma> \\<turnstile> B;\n                    list_all (term_ok \\<Theta>) (map snd insts);\n                    list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                     insts;\n                    list_all\n                     (\\<lambda>((idx, ty), t).\n                         (idx, ty) \\<notin> FV \\<Gamma>)\n                     insts;\n                    typ_of a = Some \\<tau>; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                               (\\<lambda>single. subst_term [single]) insts\n                               B;\n        wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd (aa # insts));\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (aa # insts);\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         (aa # insts);\n        typ_of a = Some \\<tau>; distinct (map fst (aa # insts));\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set (aa # insts)) \\<Longrightarrow>\n           x \\<notin> fst ` set (aa # insts)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) (aa # insts) B", "moreover"], ["proof (state)\nthis:\n  (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (x # xs) B) =\n  (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                   (\\<lambda>single. subst_term [single]) xs\n                                   (subst_term [x] B))\n\ngoal (1 subgoal):\n 1. \\<And>aa insts B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>wf_theory \\<Theta>;\n                    \\<Theta>,\\<Gamma> \\<turnstile> B;\n                    list_all (term_ok \\<Theta>) (map snd insts);\n                    list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                     insts;\n                    list_all\n                     (\\<lambda>((idx, ty), t).\n                         (idx, ty) \\<notin> FV \\<Gamma>)\n                     insts;\n                    typ_of a = Some \\<tau>; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                               (\\<lambda>single. subst_term [single]) insts\n                               B;\n        wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd (aa # insts));\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (aa # insts);\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         (aa # insts);\n        typ_of a = Some \\<tau>; distinct (map fst (aa # insts));\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set (aa # insts)) \\<Longrightarrow>\n           x \\<notin> fst ` set (aa # insts)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) (aa # insts) B", "have \"\\<Theta>, \\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single]) xs (subst_term [x] B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    xs (subst_term [x] B)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    xs (subst_term [x] B)", "have single: \"\\<Theta>, \\<Gamma> \\<turnstile> (subst_term [x] B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [x] B", "using inst_var Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   term_ok ?\\<Theta> ?a; typ_of ?a = Some ?\\<tau>;\n   (?x, ?\\<tau>) \\<notin> FV ?\\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_term\n                [((?x, ?\\<tau>), ?a)] ?B\n  \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> ?B;\n   list_all (term_ok \\<Theta>) (map snd xs);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n           b)\n    xs;\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (idx, ty) \\<Rightarrow>\n             \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n           b)\n    xs;\n   typ_of a = Some \\<tau>; distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single]) xs ?B\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd (x # xs))\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n          b)\n   (x # xs)\n  typ_of a = Some \\<tau>\n  distinct (map fst (x # xs))\n  ?x \\<in> \\<Union> (fv ` snd ` set (x # xs)) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [x] B", "by (simp add: x)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [x] B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    xs (subst_term [x] B)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    xs (subst_term [x] B)", "using Cons single"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> ?B;\n   list_all (term_ok \\<Theta>) (map snd xs);\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n           b)\n    xs;\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (idx, ty) \\<Rightarrow>\n             \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n           b)\n    xs;\n   typ_of a = Some \\<tau>; distinct (map fst xs);\n   \\<And>x.\n      x \\<in> \\<Union> (fv ` snd ` set xs) \\<Longrightarrow>\n      x \\<notin> fst ` set xs\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single]) xs ?B\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  list_all (term_ok \\<Theta>) (map snd (x # xs))\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of (idx, ty) \\<Rightarrow> \\<lambda>t. typ_of t = Some ty)\n          b)\n   (x # xs)\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idx, ty) \\<Rightarrow>\n            \\<lambda>t. (idx, ty) \\<notin> FV \\<Gamma>)\n          b)\n   (x # xs)\n  typ_of a = Some \\<tau>\n  distinct (map fst (x # xs))\n  ?x \\<in> \\<Union> (fv ` snd ` set (x # xs)) \\<Longrightarrow>\n  ?x \\<notin> fst ` set (x # xs)\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [x] B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    xs (subst_term [x] B)", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  xs (subst_term [x] B)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  xs (subst_term [x] B)\n\ngoal (1 subgoal):\n 1. \\<And>aa insts B.\n       \\<lbrakk>\\<And>B.\n                   \\<lbrakk>wf_theory \\<Theta>;\n                    \\<Theta>,\\<Gamma> \\<turnstile> B;\n                    list_all (term_ok \\<Theta>) (map snd insts);\n                    list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty)\n                     insts;\n                    list_all\n                     (\\<lambda>((idx, ty), t).\n                         (idx, ty) \\<notin> FV \\<Gamma>)\n                     insts;\n                    typ_of a = Some \\<tau>; distinct (map fst insts);\n                    \\<And>x.\n                       x \\<in> \\<Union>\n                                (fv ` snd ` set insts) \\<Longrightarrow>\n                       x \\<notin> fst ` set insts\\<rbrakk>\n                   \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                               (\\<lambda>single. subst_term [single]) insts\n                               B;\n        wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        list_all (term_ok \\<Theta>) (map snd (aa # insts));\n        list_all (\\<lambda>((idx, ty), t). typ_of t = Some ty) (aa # insts);\n        list_all (\\<lambda>((idx, ty), t). (idx, ty) \\<notin> FV \\<Gamma>)\n         (aa # insts);\n        typ_of a = Some \\<tau>; distinct (map fst (aa # insts));\n        \\<And>x.\n           x \\<in> \\<Union> (fv ` snd ` set (aa # insts)) \\<Longrightarrow>\n           x \\<notin> fst ` set (aa # insts)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single]) (aa # insts) B", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (x # xs) B) =\n  (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                   (\\<lambda>single. subst_term [single]) xs\n                                   (subst_term [x] B))\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  xs (subst_term [x] B)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                   (\\<lambda>single. subst_term [single])\n                                   (x # xs) B) =\n  (\\<Theta>,\\<Gamma> \\<turnstile> fold\n                                   (\\<lambda>single. subst_term [single]) xs\n                                   (subst_term [x] B))\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  xs (subst_term [x] B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (x # xs) B", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (x # xs) B\n\ngoal:\nNo subgoals!", "qed"], ["", "(* MOVE *)"], ["", "lemma subterm_term_ok': \n  \"is_std_sig \\<Sigma> \\<Longrightarrow> term_ok' \\<Sigma> t \\<Longrightarrow> is_closed st \\<Longrightarrow> occs st t \\<Longrightarrow> term_ok' \\<Sigma> st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t; is_closed st;\n     occs st t\\<rbrakk>\n    \\<Longrightarrow> term_ok' \\<Sigma> st", "proof (induction t arbitrary: st)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Ct x1 x2);\n        is_closed st; occs st (Ct x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 2. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        is_closed st; occs st (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 3. \\<And>x st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv x); is_closed st;\n        occs st (Bv x)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 4. \\<And>x1 t st.\n       \\<lbrakk>\\<And>st.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    is_closed st; occs st t\\<rbrakk>\n                   \\<Longrightarrow> term_ok' \\<Sigma> st;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t); is_closed st;\n        occs st (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 5. \\<And>t1 t2 st.\n       \\<lbrakk>\\<And>st.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    is_closed st; occs st t1\\<rbrakk>\n                   \\<Longrightarrow> term_ok' \\<Sigma> st;\n        \\<And>st.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2; is_closed st;\n            occs st t2\\<rbrakk>\n           \\<Longrightarrow> term_ok' \\<Sigma> st;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2); is_closed st;\n        occs st (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st", "case (Abs T t)"], ["proof (state)\nthis:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t; is_closed ?st;\n   occs ?st t\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Abs T t)\n  is_closed st\n  occs st (Abs T t)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Ct x1 x2);\n        is_closed st; occs st (Ct x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 2. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        is_closed st; occs st (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 3. \\<And>x st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv x); is_closed st;\n        occs st (Bv x)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 4. \\<And>x1 t st.\n       \\<lbrakk>\\<And>st.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t;\n                    is_closed st; occs st t\\<rbrakk>\n                   \\<Longrightarrow> term_ok' \\<Sigma> st;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Abs x1 t); is_closed st;\n        occs st (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 5. \\<And>t1 t2 st.\n       \\<lbrakk>\\<And>st.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    is_closed st; occs st t1\\<rbrakk>\n                   \\<Longrightarrow> term_ok' \\<Sigma> st;\n        \\<And>st.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2; is_closed st;\n            occs st t2\\<rbrakk>\n           \\<Longrightarrow> term_ok' \\<Sigma> st;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2); is_closed st;\n        occs st (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t; is_closed ?st;\n   occs ?st t\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Abs T t)\n  is_closed st\n  occs st (Abs T t)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t; is_closed ?st;\n   occs ?st t\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (Abs T t)\n  is_closed st\n  occs st (Abs T t)\n\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> st", "by (auto simp add: is_open_def)"], ["proof (state)\nthis:\n  term_ok' \\<Sigma> st\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Ct x1 x2);\n        is_closed st; occs st (Ct x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 2. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        is_closed st; occs st (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 3. \\<And>x st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv x); is_closed st;\n        occs st (Bv x)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 4. \\<And>t1 t2 st.\n       \\<lbrakk>\\<And>st.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    is_closed st; occs st t1\\<rbrakk>\n                   \\<Longrightarrow> term_ok' \\<Sigma> st;\n        \\<And>st.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2; is_closed st;\n            occs st t2\\<rbrakk>\n           \\<Longrightarrow> term_ok' \\<Sigma> st;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2); is_closed st;\n        occs st (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Ct x1 x2);\n        is_closed st; occs st (Ct x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 2. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        is_closed st; occs st (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 3. \\<And>x st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv x); is_closed st;\n        occs st (Bv x)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 4. \\<And>t1 t2 st.\n       \\<lbrakk>\\<And>st.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    is_closed st; occs st t1\\<rbrakk>\n                   \\<Longrightarrow> term_ok' \\<Sigma> st;\n        \\<And>st.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2; is_closed st;\n            occs st t2\\<rbrakk>\n           \\<Longrightarrow> term_ok' \\<Sigma> st;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2); is_closed st;\n        occs st (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st", "case (App t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1; is_closed ?st;\n   occs ?st t1\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2; is_closed ?st;\n   occs ?st t2\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (t1 $ t2)\n  is_closed st\n  occs st (t1 $ t2)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Ct x1 x2);\n        is_closed st; occs st (Ct x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 2. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        is_closed st; occs st (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 3. \\<And>x st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv x); is_closed st;\n        occs st (Bv x)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 4. \\<And>t1 t2 st.\n       \\<lbrakk>\\<And>st.\n                   \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1;\n                    is_closed st; occs st t1\\<rbrakk>\n                   \\<Longrightarrow> term_ok' \\<Sigma> st;\n        \\<And>st.\n           \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2; is_closed st;\n            occs st t2\\<rbrakk>\n           \\<Longrightarrow> term_ok' \\<Sigma> st;\n        is_std_sig \\<Sigma>; term_ok' \\<Sigma> (t1 $ t2); is_closed st;\n        occs st (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1; is_closed ?st;\n   occs ?st t1\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2; is_closed ?st;\n   occs ?st t2\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (t1 $ t2)\n  is_closed st\n  occs st (t1 $ t2)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1; is_closed ?st;\n   occs ?st t1\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2; is_closed ?st;\n   occs ?st t2\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (t1 $ t2)\n  is_closed st\n  occs st (t1 $ t2)\n\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> st", "using term_ok'_occs"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t1; is_closed ?st;\n   occs ?st t1\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> t2; is_closed ?st;\n   occs ?st t2\\<rbrakk>\n  \\<Longrightarrow> term_ok' \\<Sigma> ?st\n  is_std_sig \\<Sigma>\n  term_ok' \\<Sigma> (t1 $ t2)\n  is_closed st\n  occs st (t1 $ t2)\n  \\<lbrakk>is_std_sig ?\\<Sigma>; term_ok' ?\\<Sigma> ?t; occs ?u ?t\\<rbrakk>\n  \\<Longrightarrow> term_ok' ?\\<Sigma> ?u\n\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> st", "by blast"], ["proof (state)\nthis:\n  term_ok' \\<Sigma> st\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Ct x1 x2);\n        is_closed st; occs st (Ct x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 2. \\<And>x1 x2 st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Fv x1 x2);\n        is_closed st; occs st (Fv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st\n 3. \\<And>x st.\n       \\<lbrakk>is_std_sig \\<Sigma>; term_ok' \\<Sigma> (Bv x); is_closed st;\n        occs st (Bv x)\\<rbrakk>\n       \\<Longrightarrow> term_ok' \\<Sigma> st", "qed auto"], ["", "(* MOVE *)"], ["", "lemma infinite_fv_UNIV: \"infinite (UNIV :: (indexname \\<times> typ) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "by (simp add: finite_prod)"], ["", "lemma implies_intro'_pre:\n  assumes \"wf_theory \\<Theta>\" \"\\<Theta>, \\<Gamma> \\<turnstile> B\" \"term_ok \\<Theta> A\" \"typ_of A = Some propT\" \"A \\<notin> \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> A \\<longmapsto> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "using assms proves.implies_intro"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   wf_term (sig ?\\<Theta>) ?A; \\<turnstile>\\<^sub>\\<tau> ?A : propT\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> -\n                              {?A} \\<turnstile> ?A \\<longmapsto> ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "apply (simp add: wt_term_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     term_ok' (sig \\<Theta>) A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n     \\<And>\\<Theta> \\<Gamma> B A.\n        \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n         term_ok' (sig \\<Theta>) A; typ_of A = Some propT\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> -\n                                   {A} \\<turnstile> A \\<longmapsto>\n              B\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "by (metis Diff_empty Diff_insert0)"], ["", "lemma implies_intro'_pre2:\n  assumes \"wf_theory \\<Theta>\" \"\\<Theta>, \\<Gamma> \\<turnstile> B\" \"term_ok \\<Theta> A\" \"typ_of A = Some propT\" \"A \\<in> \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> A \\<longmapsto> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "have 1: \"\\<Theta>, \\<Gamma> - {A} \\<turnstile> A \\<longmapsto> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> - {A} \\<turnstile> A \\<longmapsto> B", "using assms proves.implies_intro"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<in> \\<Gamma>\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   wf_term (sig ?\\<Theta>) ?A; \\<turnstile>\\<^sub>\\<tau> ?A : propT\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> -\n                              {?A} \\<turnstile> ?A \\<longmapsto> ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> - {A} \\<turnstile> A \\<longmapsto> B", "by (simp add: wt_term_def)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> - {A} \\<turnstile> A \\<longmapsto> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "have \"\\<Theta>, \\<Gamma> - {A} - {A} \\<turnstile> A \\<longmapsto> (A \\<longmapsto> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> - {A} -\n             {A} \\<turnstile> A \\<longmapsto> A \\<longmapsto> B", "using assms proves.implies_intro"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<in> \\<Gamma>\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   wf_term (sig ?\\<Theta>) ?A; \\<turnstile>\\<^sub>\\<tau> ?A : propT\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> -\n                              {?A} \\<turnstile> ?A \\<longmapsto> ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> - {A} -\n             {A} \\<turnstile> A \\<longmapsto> A \\<longmapsto> B", "by (simp add: 1 implies_intro'_pre)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> - {A} -\n           {A} \\<turnstile> A \\<longmapsto> A \\<longmapsto> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "moreover"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> - {A} -\n           {A} \\<turnstile> A \\<longmapsto> A \\<longmapsto> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "have \"\\<Theta>, {A} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,{A} \\<turnstile> A", "using proves.assume assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_term (sig ?\\<Theta>) ?A; \\<turnstile>\\<^sub>\\<tau> ?A : propT;\n   ?A \\<in> ?\\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> ?A\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<in> \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Theta>,{A} \\<turnstile> A", "by (simp add: trivial_pre_depr)"], ["proof (state)\nthis:\n  \\<Theta>,{A} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "moreover"], ["proof (state)\nthis:\n  \\<Theta>,{A} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "have \"\\<Gamma> = (\\<Gamma> - {A} - {A}) \\<union> {A}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Gamma> - {A} - {A} \\<union> {A}", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<in> \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Gamma> - {A} - {A} \\<union> {A}", "by auto"], ["proof (state)\nthis:\n  \\<Gamma> = \\<Gamma> - {A} - {A} \\<union> {A}\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "ultimately"], ["proof (chain)\npicking this:\n  \\<Theta>,\\<Gamma> - {A} -\n           {A} \\<turnstile> A \\<longmapsto> A \\<longmapsto> B\n  \\<Theta>,{A} \\<turnstile> A\n  \\<Gamma> = \\<Gamma> - {A} - {A} \\<union> {A}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> - {A} -\n           {A} \\<turnstile> A \\<longmapsto> A \\<longmapsto> B\n  \\<Theta>,{A} \\<turnstile> A\n  \\<Gamma> = \\<Gamma> - {A} - {A} \\<union> {A}\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "using proves.implies_elim"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> - {A} -\n           {A} \\<turnstile> A \\<longmapsto> A \\<longmapsto> B\n  \\<Theta>,{A} \\<turnstile> A\n  \\<Gamma> = \\<Gamma> - {A} - {A} \\<union> {A}\n  \\<lbrakk>?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<turnstile> ?A \\<longmapsto> ?B;\n   ?\\<Theta>,?\\<Gamma>\\<^sub>2 \\<turnstile> ?A\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<union>\n                              ?\\<Gamma>\\<^sub>2 \\<turnstile> ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B", "by metis"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> B\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Names are suspect, change *)"], ["", "lemma subst_term_preserves_typ_of1[simp]: \n  \"typ_of1 Ts (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) = typ_of1 Ts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of1 Ts (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) = typ_of1 Ts t", "by (induction Ts t rule: typ_of1.induct) (fastforce)+"], ["", "lemma subst_term_preserves_typ_of[simp]:\n  \"typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) = typ_of t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) = typ_of t", "using typ_of_def"], ["proof (prove)\nusing this:\n  typ_of ?t \\<equiv> typ_of1 [] ?t\n\ngoal (1 subgoal):\n 1. typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) = typ_of t", "by simp"], ["", "lemma subst_term_preserves_term_ok'[simp]: \n  \"term_ok' \\<Sigma> (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) \\<longleftrightarrow> term_ok' \\<Sigma> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' \\<Sigma> (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) =\n    term_ok' \\<Sigma> t", "by (induction t) auto"], ["", "lemma subst_term_preserves_term_ok[simp]:\n  \"term_ok \\<Theta> (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) \\<longleftrightarrow> term_ok \\<Theta> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) =\n    term_ok \\<Theta> A", "by (simp add: wt_term_def)"], ["", "lemma not_in_FV_in_fv_not_in: \"(x,\\<tau>) \\<notin> FV \\<Gamma> \\<Longrightarrow> (x,\\<tau>) \\<in> fv t \\<Longrightarrow> t \\<notin> \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, \\<tau>) \\<notin> FV \\<Gamma>;\n     (x, \\<tau>) \\<in> fv t\\<rbrakk>\n    \\<Longrightarrow> t \\<notin> \\<Gamma>", "by auto"], ["", "lemma subst_term_fv: \"fv (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) \n  = (if (x,\\<tau>) \\<in> fv t then insert (y,\\<tau>) else id) (fv t - {(x,\\<tau>)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) =\n    (if (x, \\<tau>) \\<in> fv t then insert (y, \\<tau>) else id)\n     (fv t - {(x, \\<tau>)})", "by (induction t) auto"], ["", "lemma rename_free: \n  assumes wf_theory: \"wf_theory \\<Theta>\"\n  assumes B: \"\\<Theta>, \\<Gamma> \\<turnstile> B\"\n  assumes free: \"(x,\\<tau>)\\<notin> FV \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), Fv y \\<tau>)] B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), Fv y \\<tau>)] B", "by (metis B free inst_var proved_terms_well_formed(2) subst_term_single_no_change\n      term_ok_vars_typ_ok term_ok_var wf_theory typ_of_var)"], ["", "lemma tvs_subst_term_single[simp]: \"tvs (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = tvs A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = tvs A", "by (induction A) auto"], ["", "(* Conditions are a bit random, clear up *)"], ["", "lemma weaken_proves': \"\\<Theta>, \\<Gamma> \\<turnstile> B \\<Longrightarrow> term_ok \\<Theta> A \\<Longrightarrow> typ_of A = Some propT \\<Longrightarrow> A \\<notin> \\<Gamma>\n  \\<Longrightarrow> finite \\<Gamma> \n  \\<Longrightarrow> \\<Theta>, insert A \\<Gamma> \\<turnstile> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> B; term_ok \\<Theta> A;\n     typ_of A = Some propT; A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B", "proof (induction \\<Gamma> B arbitrary: A rule: proves.induct)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma> Aa.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>; term_ok \\<Theta> Aa;\n        typ_of Aa = Some propT; Aa \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   \\<Gamma> \\<turnstile> tsubst A \\<rho>\n 2. \\<And>A \\<Gamma> Aa.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT; Aa \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa \\<Gamma> \\<turnstile> A\n 3. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 4. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 5. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 7. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 8. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "case (axiom A insts \\<Gamma> A')"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> insts\n  term_ok \\<Theta> A'\n  typ_of A' = Some propT\n  A' \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (9 subgoals):\n 1. \\<And>A \\<rho> \\<Gamma> Aa.\n       \\<lbrakk>wf_theory \\<Theta>; A \\<in> axioms \\<Theta>;\n        wf_inst \\<Theta> \\<rho>; term_ok \\<Theta> Aa;\n        typ_of Aa = Some propT; Aa \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   \\<Gamma> \\<turnstile> tsubst A \\<rho>\n 2. \\<And>A \\<Gamma> Aa.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT; Aa \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa \\<Gamma> \\<turnstile> A\n 3. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 4. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 5. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 6. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 7. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 8. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 9. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> insts\n  term_ok \\<Theta> A'\n  typ_of A' = Some propT\n  A' \\<notin> \\<Gamma>\n  finite \\<Gamma>", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> insts\n  term_ok \\<Theta> A'\n  typ_of A' = Some propT\n  A' \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A' \\<Gamma> \\<turnstile> tsubst A insts", "using proves.axiom axiom"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> insts\n  term_ok \\<Theta> A'\n  typ_of A' = Some propT\n  A' \\<notin> \\<Gamma>\n  finite \\<Gamma>\n  \\<lbrakk>wf_theory ?\\<Theta>; ?A \\<in> axioms ?\\<Theta>;\n   wf_inst ?\\<Theta> ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> tsubst ?A ?\\<rho>\n  wf_theory \\<Theta>\n  A \\<in> axioms \\<Theta>\n  wf_inst \\<Theta> insts\n  term_ok \\<Theta> A'\n  typ_of A' = Some propT\n  A' \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A' \\<Gamma> \\<turnstile> tsubst A insts", "by metis"], ["proof (state)\nthis:\n  \\<Theta>,insert A' \\<Gamma> \\<turnstile> tsubst A insts\n\ngoal (8 subgoals):\n 1. \\<And>A \\<Gamma> Aa.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT; Aa \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa \\<Gamma> \\<turnstile> A\n 2. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 3. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 4. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 5. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 6. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 7. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 8. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>A \\<Gamma> Aa.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT; Aa \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa \\<Gamma> \\<turnstile> A\n 2. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 3. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 4. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 5. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 6. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 7. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 8. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "case (\"assume\" A \\<Gamma> A')"], ["proof (state)\nthis:\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  A \\<in> \\<Gamma>\n  term_ok \\<Theta> A'\n  typ_of A' = Some propT\n  A' \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (8 subgoals):\n 1. \\<And>A \\<Gamma> Aa.\n       \\<lbrakk>wf_term (sig \\<Theta>) A;\n        \\<turnstile>\\<^sub>\\<tau> A : propT; A \\<in> \\<Gamma>;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT; Aa \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa \\<Gamma> \\<turnstile> A\n 2. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 3. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 4. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 5. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 6. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 7. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 8. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "then"], ["proof (chain)\npicking this:\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  A \\<in> \\<Gamma>\n  term_ok \\<Theta> A'\n  typ_of A' = Some propT\n  A' \\<notin> \\<Gamma>\n  finite \\<Gamma>", "show ?case"], ["proof (prove)\nusing this:\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  A \\<in> \\<Gamma>\n  term_ok \\<Theta> A'\n  typ_of A' = Some propT\n  A' \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A' \\<Gamma> \\<turnstile> A", "using proves.intros"], ["proof (prove)\nusing this:\n  wf_term (sig \\<Theta>) A\n  \\<turnstile>\\<^sub>\\<tau> A : propT\n  A \\<in> \\<Gamma>\n  term_ok \\<Theta> A'\n  typ_of A' = Some propT\n  A' \\<notin> \\<Gamma>\n  finite \\<Gamma>\n  \\<lbrakk>wf_theory ?\\<Theta>; ?A \\<in> axioms ?\\<Theta>;\n   wf_inst ?\\<Theta> ?\\<rho>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> tsubst ?A ?\\<rho>\n  \\<lbrakk>wf_term (sig ?\\<Theta>) ?A; \\<turnstile>\\<^sub>\\<tau> ?A : propT;\n   ?A \\<in> ?\\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> ?A\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   (?x, ?\\<tau>) \\<notin> FV ?\\<Gamma>;\n   wf_type (sig ?\\<Theta>) ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> mk_all ?x ?\\<tau> ?B\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n       ((?\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n      Abs ?\\<tau> ?B;\n   \\<turnstile>\\<^sub>\\<tau> ?a : ?\\<tau>;\n   wf_term (sig ?\\<Theta>) ?a\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_bv ?a ?B\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   wf_term (sig ?\\<Theta>) ?A; \\<turnstile>\\<^sub>\\<tau> ?A : propT\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> -\n                              {?A} \\<turnstile> ?A \\<longmapsto> ?B\n  \\<lbrakk>?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<turnstile> ?A \\<longmapsto> ?B;\n   ?\\<Theta>,?\\<Gamma>\\<^sub>2 \\<turnstile> ?A\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<union>\n                              ?\\<Gamma>\\<^sub>2 \\<turnstile> ?B\n  \\<lbrakk>wf_theory ?\\<Theta>;\n   const_type (sig ?\\<Theta>) (const_of_class ?c) =\n   Some (itselfT Core.aT \\<rightarrow> propT);\n   wf_type (sig ?\\<Theta>) ?T;\n   has_sort (osig (sig ?\\<Theta>)) ?T (insert ?c full_sort)\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> mk_of_class ?T ?c\n  \\<lbrakk>wf_theory ?\\<Theta>; wt_term (sig ?\\<Theta>) (Abs ?T ?t);\n   wf_term (sig ?\\<Theta>) ?u; \\<turnstile>\\<^sub>\\<tau> ?u : ?T\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> mk_eq (Abs ?T ?t $ ?u)\n                (subst_bv ?u ?t)\n  \\<lbrakk>wf_theory ?\\<Theta>; wf_term (sig ?\\<Theta>) ?t;\n   \\<turnstile>\\<^sub>\\<tau> ?t : ?\\<tau> \\<rightarrow> ?\\<tau>'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> mk_eq\n                (Abs ?\\<tau> (?t $ Bv 0)) ?t\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A' \\<Gamma> \\<turnstile> A", "by blast"], ["proof (state)\nthis:\n  \\<Theta>,insert A' \\<Gamma> \\<turnstile> A\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "case (forall_intro \\<Gamma> B x \\<tau>)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  (x, \\<tau>) \\<notin> FV \\<Gamma>\n  wf_type (sig \\<Theta>) \\<tau>\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "have \"\\<exists>y . y\\<notin>fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)", "have \"finite (FV \\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (FV \\<Gamma>)", "using finite_fv forall_intro.prems"], ["proof (prove)\nusing this:\n  finite (fv ?t)\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (1 subgoal):\n 1. finite (FV \\<Gamma>)", "by auto"], ["proof (state)\nthis:\n  finite (FV \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)", "hence \"finite (fv A \\<union> fv B \\<union> FV \\<Gamma>)\""], ["proof (prove)\nusing this:\n  finite (FV \\<Gamma>)\n\ngoal (1 subgoal):\n 1. finite (fv A \\<union> fv B \\<union> FV \\<Gamma>)", "by simp"], ["proof (state)\nthis:\n  finite (fv A \\<union> fv B \\<union> FV \\<Gamma>)\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)", "hence \"finite (fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>))\""], ["proof (prove)\nusing this:\n  finite (fv A \\<union> fv B \\<union> FV \\<Gamma>)\n\ngoal (1 subgoal):\n 1. finite (fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>))", "by simp"], ["proof (state)\nthis:\n  finite (fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>))\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)", "using variant_variable_fresh"], ["proof (prove)\nusing this:\n  finite (fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>))\n  finite ?S \\<Longrightarrow> fst (variant_variable ?s ?S) \\<notin> ?S\n\ngoal (1 subgoal):\n 1. \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "from this"], ["proof (chain)\npicking this:\n  \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)", "obtain y where \"y\\<notin>fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)\""], ["proof (prove)\nusing this:\n  \\<exists>y. y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<notin> fst `\n                   (fv A \\<union> fv B \\<union>\n                    FV \\<Gamma>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "have not_in_ren: \"subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>", "proof(cases \"(x, \\<tau>) \\<in> fv A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, \\<tau>) \\<in> fv A \\<Longrightarrow>\n    subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>\n 2. (x, \\<tau>) \\<notin> fv A \\<Longrightarrow>\n    subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>", "case True"], ["proof (state)\nthis:\n  (x, \\<tau>) \\<in> fv A\n\ngoal (2 subgoals):\n 1. (x, \\<tau>) \\<in> fv A \\<Longrightarrow>\n    subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>\n 2. (x, \\<tau>) \\<notin> fv A \\<Longrightarrow>\n    subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>", "apply (rule not_in_FV_in_fv_not_in[of y \\<tau>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (y, \\<tau>) \\<notin> FV \\<Gamma>\n 2. (y, \\<tau>) \\<in> fv (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)", "apply (metis (full_types) Un_iff \\<open>y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)\\<close> fst_conv image_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, \\<tau>) \\<in> fv (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)", "using True subst_term_fv"], ["proof (prove)\nusing this:\n  (x, \\<tau>) \\<in> fv A\n  fv (subst_term [((?x, ?\\<tau>), Fv ?y ?\\<tau>)] ?t) =\n  (if (?x, ?\\<tau>) \\<in> fv ?t then insert (?y, ?\\<tau>) else id)\n   (fv ?t - {(?x, ?\\<tau>)})\n\ngoal (1 subgoal):\n 1. (y, \\<tau>) \\<in> fv (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)", "by auto"], ["proof (state)\nthis:\n  subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>\n\ngoal (1 subgoal):\n 1. (x, \\<tau>) \\<notin> fv A \\<Longrightarrow>\n    subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, \\<tau>) \\<notin> fv A \\<Longrightarrow>\n    subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>", "case False"], ["proof (state)\nthis:\n  (x, \\<tau>) \\<notin> fv A\n\ngoal (1 subgoal):\n 1. (x, \\<tau>) \\<notin> fv A \\<Longrightarrow>\n    subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>", "hence \"subst_term [((x, \\<tau>), Fv y \\<tau>)] A = A\""], ["proof (prove)\nusing this:\n  (x, \\<tau>) \\<notin> fv A\n\ngoal (1 subgoal):\n 1. subst_term [((x, \\<tau>), Fv y \\<tau>)] A = A", "by simp"], ["proof (state)\nthis:\n  subst_term [((x, \\<tau>), Fv y \\<tau>)] A = A\n\ngoal (1 subgoal):\n 1. (x, \\<tau>) \\<notin> fv A \\<Longrightarrow>\n    subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  subst_term [((x, \\<tau>), Fv y \\<tau>)] A = A", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_term [((x, \\<tau>), Fv y \\<tau>)] A = A\n\ngoal (1 subgoal):\n 1. subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>", "by (simp add: forall_intro.prems(3))"], ["proof (state)\nthis:\n  subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "have term_ok_ren: \"term_ok \\<Theta> (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)", "using forall_intro.prems(1) subst_term_preserves_term_ok"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> A\n  term_ok ?\\<Theta> (subst_term [((?x, ?\\<tau>), Fv ?y ?\\<tau>)] ?A) =\n  term_ok ?\\<Theta> ?A\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)", "by blast"], ["proof (state)\nthis:\n  term_ok \\<Theta> (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "have typ_of_ren: \"typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = Some propT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = Some propT", "using forall_intro.prems"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (1 subgoal):\n 1. typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = Some propT", "by auto"], ["proof (state)\nthis:\n  typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = Some propT\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "hence \"\\<Theta>, insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) \\<Gamma> \\<turnstile> B\""], ["proof (prove)\nusing this:\n  typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = Some propT\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n              \\<Gamma> \\<turnstile> B", "using forall_intro.IH forall_intro.prems(3) forall_intro.prems(4) \n      not_in_ren term_ok_ren typ_of_ren"], ["proof (prove)\nusing this:\n  typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = Some propT\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma> \\<turnstile> B\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>\n  subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>\n  term_ok \\<Theta> (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n  typ_of (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) = Some propT\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n              \\<Gamma> \\<turnstile> B", "by blast"], ["proof (state)\nthis:\n  \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n            \\<Gamma> \\<turnstile> B\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "have \"\\<Theta>, insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) \\<Gamma> \\<turnstile> mk_all x \\<tau> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n              \\<Gamma> \\<turnstile> mk_all x \\<tau> B", "apply (rule proves.forall_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n              \\<Gamma> \\<turnstile> B\n 3. (x, \\<tau>)\n    \\<notin> FV (insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n                  \\<Gamma>)\n 4. wf_type (sig \\<Theta>) \\<tau>", "apply (simp add: forall_intro.hyps(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n              \\<Gamma> \\<turnstile> B\n 2. (x, \\<tau>)\n    \\<notin> FV (insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n                  \\<Gamma>)\n 3. wf_type (sig \\<Theta>) \\<tau>", "using \\<open>\\<Theta>, insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A) \\<Gamma> \\<turnstile> B\\<close>"], ["proof (prove)\nusing this:\n  \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n            \\<Gamma> \\<turnstile> B\n\ngoal (3 subgoals):\n 1. \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n              \\<Gamma> \\<turnstile> B\n 2. (x, \\<tau>)\n    \\<notin> FV (insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n                  \\<Gamma>)\n 3. wf_type (sig \\<Theta>) \\<tau>", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x, \\<tau>)\n    \\<notin> FV (insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n                  \\<Gamma>)\n 2. wf_type (sig \\<Theta>) \\<tau>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, \\<tau>)\n    \\<notin> FV (insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n                  \\<Gamma>)", "using subst_term_fv \\<open>(x, \\<tau>) \\<notin> FV \\<Gamma>\\<close>"], ["proof (prove)\nusing this:\n  fv (subst_term [((?x, ?\\<tau>), Fv ?y ?\\<tau>)] ?t) =\n  (if (?x, ?\\<tau>) \\<in> fv ?t then insert (?y, ?\\<tau>) else id)\n   (fv ?t - {(?x, ?\\<tau>)})\n  (x, \\<tau>) \\<notin> FV \\<Gamma>\n\ngoal (1 subgoal):\n 1. (x, \\<tau>)\n    \\<notin> FV (insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n                  \\<Gamma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x \\<tau> y t.\n                fv (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) =\n                (if (x, \\<tau>) \\<in> fv t then insert (y, \\<tau>) else id)\n                 (fv t - {(x, \\<tau>)});\n     \\<forall>xa\\<in>\\<Gamma>. (x, \\<tau>) \\<notin> fv xa\\<rbrakk>\n    \\<Longrightarrow> (x, \\<tau>) \\<in> fv A \\<longrightarrow> x \\<noteq> y", "by (metis Un_iff \\<open>y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)\\<close> fst_conv image_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_type (sig \\<Theta>) \\<tau>", "using forall_intro.hyps(4)"], ["proof (prove)\nusing this:\n  wf_type (sig \\<Theta>) \\<tau>\n\ngoal (1 subgoal):\n 1. wf_type (sig \\<Theta>) \\<tau>", "by blast"], ["proof (state)\nthis:\n  \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n            \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "hence \"\\<Theta>, \\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<longmapsto> mk_all x \\<tau> B\""], ["proof (prove)\nusing this:\n  \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n            \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                                    A \\<longmapsto>\n                                   mk_all x \\<tau> B", "using forall_intro.hyps(1) forall_intro.hyps(2) forall_intro.hyps(4)\n      forall_intro.prems(1) forall_intro.prems(3) \n      implies_intro'_pre local.forall_intro not_in_ren proves.forall_intro \n      subst_term_preserves_typ_of term_ok_ren"], ["proof (prove)\nusing this:\n  \\<Theta>,insert (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n            \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_type (sig \\<Theta>) \\<tau>\n  term_ok \\<Theta> A\n  A \\<notin> \\<Gamma>\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   term_ok ?\\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> ?\\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> ?A \\<longmapsto> ?B\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  (x, \\<tau>) \\<notin> FV \\<Gamma>\n  wf_type (sig \\<Theta>) \\<tau>\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>\n  subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<notin> \\<Gamma>\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   (?x, ?\\<tau>) \\<notin> FV ?\\<Gamma>;\n   wf_type (sig ?\\<Theta>) ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> mk_all ?x ?\\<tau> ?B\n  typ_of (subst_term [((?x, ?\\<tau>), Fv ?y ?\\<tau>)] ?t) = typ_of ?t\n  term_ok \\<Theta> (subst_term [((x, \\<tau>), Fv y \\<tau>)] A)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                                    A \\<longmapsto>\n                                   mk_all x \\<tau> B", "by auto"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                                  A \\<longmapsto>\n                                 mk_all x \\<tau> B\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "hence \"\\<Theta>, \\<Gamma> \\<turnstile> subst_term [((y, \\<tau>), Fv x \\<tau>)] \n    (subst_term [((x, \\<tau>), Fv y \\<tau>)] A \\<longmapsto> mk_all x \\<tau> B)\""], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                                  A \\<longmapsto>\n                                 mk_all x \\<tau> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((y, \\<tau>), Fv x \\<tau>)]\n                                    (subst_term [((x, \\<tau>), Fv y \\<tau>)]\nA \\<longmapsto>\n                                     mk_all x \\<tau> B)", "by (smt Un_iff \\<open>y \\<notin> fst ` (fv A \\<union> fv B \\<union> FV \\<Gamma>)\\<close> forall_intro.hyps(1) \n        fst_conv image_eqI rename_free)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((y, \\<tau>), Fv x \\<tau>)]\n                                  (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                                    A \\<longmapsto>\n                                   mk_all x \\<tau> B)\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "hence \"\\<Theta>, \\<Gamma> \\<turnstile> A \\<longmapsto> mk_all x \\<tau> B\""], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((y, \\<tau>), Fv x \\<tau>)]\n                                  (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                                    A \\<longmapsto>\n                                   mk_all x \\<tau> B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> mk_all x \\<tau> B", "using forall_intro proves.forall_intro implies_intro'_pre"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((y, \\<tau>), Fv x \\<tau>)]\n                                  (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                                    A \\<longmapsto>\n                                   mk_all x \\<tau> B)\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  (x, \\<tau>) \\<notin> FV \\<Gamma>\n  wf_type (sig \\<Theta>) \\<tau>\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   (?x, ?\\<tau>) \\<notin> FV ?\\<Gamma>;\n   wf_type (sig ?\\<Theta>) ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> mk_all ?x ?\\<tau> ?B\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   term_ok ?\\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> ?\\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> ?A \\<longmapsto> ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> mk_all x \\<tau> B", "by auto"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> mk_all x \\<tau> B\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "moreover"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> mk_all x \\<tau> B\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "have \"\\<Theta>, {A} \\<turnstile> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,{A} \\<turnstile> A", "using forall_intro.prems(1) local.forall_intro(7) trivial_pre_depr"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  \\<lbrakk>term_ok ?\\<Theta> ?c; typ_of ?c = Some propT\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,{?c} \\<turnstile> ?c\n\ngoal (1 subgoal):\n 1. \\<Theta>,{A} \\<turnstile> A", "by blast"], ["proof (state)\nthis:\n  \\<Theta>,{A} \\<turnstile> A\n\ngoal (7 subgoals):\n 1. \\<And>\\<Gamma> B x \\<tau> A.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        (x, \\<tau>) \\<notin> FV \\<Gamma>; wf_type (sig \\<Theta>) \\<tau>;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n 2. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 3. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 4. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 5. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 6. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 7. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "ultimately"], ["proof (chain)\npicking this:\n  \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> mk_all x \\<tau> B\n  \\<Theta>,{A} \\<turnstile> A", "show ?case"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> mk_all x \\<tau> B\n  \\<Theta>,{A} \\<turnstile> A\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A \\<Gamma> \\<turnstile> mk_all x \\<tau> B", "using implies_elim"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> A \\<longmapsto> mk_all x \\<tau> B\n  \\<Theta>,{A} \\<turnstile> A\n  \\<lbrakk>?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<turnstile> ?A \\<longmapsto> ?B;\n   ?\\<Theta>,?\\<Gamma>\\<^sub>2 \\<turnstile> ?A\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<union>\n                              ?\\<Gamma>\\<^sub>2 \\<turnstile> ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A \\<Gamma> \\<turnstile> mk_all x \\<tau> B", "by fastforce"], ["proof (state)\nthis:\n  \\<Theta>,insert A \\<Gamma> \\<turnstile> mk_all x \\<tau> B\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 2. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 3. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 4. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 5. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 6. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 2. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 3. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 4. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 5. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 6. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "case (forall_elim \\<Gamma> \\<tau> B a)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                                  ((\\<tau> \\<rightarrow>\n                                    propT) \\<rightarrow>\n                                   propT) $\n                                 Abs \\<tau> B\n  \\<turnstile>\\<^sub>\\<tau> a : \\<tau>\n  wf_term (sig \\<Theta>) a\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A\n                              \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n               ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n              Abs \\<tau> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (6 subgoals):\n 1. \\<And>\\<Gamma> \\<tau> B a A.\n       \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n          ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n         Abs \\<tau> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A\n \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                        ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n                       Abs \\<tau> B;\n        \\<turnstile>\\<^sub>\\<tau> a : \\<tau>; wf_term (sig \\<Theta>) a;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> subst_bv a B\n 2. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 3. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 4. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 5. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 6. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "then"], ["proof (chain)\npicking this:\n  \\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                                  ((\\<tau> \\<rightarrow>\n                                    propT) \\<rightarrow>\n                                   propT) $\n                                 Abs \\<tau> B\n  \\<turnstile>\\<^sub>\\<tau> a : \\<tau>\n  wf_term (sig \\<Theta>) a\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A\n                              \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n               ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n              Abs \\<tau> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>", "show ?case"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                                  ((\\<tau> \\<rightarrow>\n                                    propT) \\<rightarrow>\n                                   propT) $\n                                 Abs \\<tau> B\n  \\<turnstile>\\<^sub>\\<tau> a : \\<tau>\n  wf_term (sig \\<Theta>) a\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A\n                              \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n               ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n              Abs \\<tau> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A \\<Gamma> \\<turnstile> subst_bv a B", "using proves.forall_elim"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n                                  ((\\<tau> \\<rightarrow>\n                                    propT) \\<rightarrow>\n                                   propT) $\n                                 Abs \\<tau> B\n  \\<turnstile>\\<^sub>\\<tau> a : \\<tau>\n  wf_term (sig \\<Theta>) a\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A\n                              \\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n               ((\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n              Abs \\<tau> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\n  finite \\<Gamma>\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> Ct STR ''Pure.all''\n       ((?\\<tau> \\<rightarrow> propT) \\<rightarrow> propT) $\n      Abs ?\\<tau> ?B;\n   \\<turnstile>\\<^sub>\\<tau> ?a : ?\\<tau>;\n   wf_term (sig ?\\<Theta>) ?a\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> subst_bv ?a ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A \\<Gamma> \\<turnstile> subst_bv a B", "by blast"], ["proof (state)\nthis:\n  \\<Theta>,insert A \\<Gamma> \\<turnstile> subst_bv a B\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 2. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 3. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 4. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 5. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 2. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 3. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 4. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 5. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "case (implies_intro \\<Gamma> B N)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_term (sig \\<Theta>) N\n  \\<turnstile>\\<^sub>\\<tau> N : propT\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma> - {N}\n  finite (\\<Gamma> - {N})\n\ngoal (5 subgoals):\n 1. \\<And>\\<Gamma> B A Aa.\n       \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n        \\<And>A.\n           \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n            A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n        wf_term (sig \\<Theta>) A; \\<turnstile>\\<^sub>\\<tau> A : propT;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma> - {A}; finite (\\<Gamma> - {A})\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma> -\n                                    {A}) \\<turnstile> A \\<longmapsto> B\n 2. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 3. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 4. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 5. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_term (sig \\<Theta>) N\n  \\<turnstile>\\<^sub>\\<tau> N : propT\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma> - {N}\n  finite (\\<Gamma> - {N})", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_term (sig \\<Theta>) N\n  \\<turnstile>\\<^sub>\\<tau> N : propT\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma> - {N}\n  finite (\\<Gamma> - {N})\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A (\\<Gamma> - {N}) \\<turnstile> N \\<longmapsto> B", "proof (cases \"A=N\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A = N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B\n 2. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "case True"], ["proof (state)\nthis:\n  A = N\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A = N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B\n 2. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "(* Do this less automatic probably, for speed reasons*)"], ["proof (state)\nthis:\n  A = N\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A = N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B\n 2. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "hence \"\\<Theta>,\\<Gamma> - {N} \\<turnstile> N \\<longmapsto> B\""], ["proof (prove)\nusing this:\n  A = N\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> - {N} \\<turnstile> N \\<longmapsto> B", "using implies_intro.hyps(1) implies_intro.hyps(2) implies_intro.hyps(3) \n          implies_intro.hyps(4) proves.implies_intro"], ["proof (prove)\nusing this:\n  A = N\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_term (sig \\<Theta>) N\n  \\<turnstile>\\<^sub>\\<tau> N : propT\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   wf_term (sig ?\\<Theta>) ?A; \\<turnstile>\\<^sub>\\<tau> ?A : propT\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> -\n                              {?A} \\<turnstile> ?A \\<longmapsto> ?B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> - {N} \\<turnstile> N \\<longmapsto> B", "by blast"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> - {N} \\<turnstile> N \\<longmapsto> B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A = N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B\n 2. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "hence \"\\<Theta>,\\<Gamma> - {N} \\<turnstile> A \\<longmapsto> N \\<longmapsto> B\""], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> - {N} \\<turnstile> N \\<longmapsto> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> - {N} \\<turnstile> A \\<longmapsto> N \\<longmapsto> B", "using True implies_intro'_pre implies_intro.hyps(1) implies_intro.hyps(3) \n          implies_intro.hyps(4) implies_intro.prems(1)"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> - {N} \\<turnstile> N \\<longmapsto> B\n  A = N\n  \\<lbrakk>wf_theory ?\\<Theta>; ?\\<Theta>,?\\<Gamma> \\<turnstile> ?B;\n   term_ok ?\\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> ?\\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> ?A \\<longmapsto> ?B\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) N\n  \\<turnstile>\\<^sub>\\<tau> N : propT\n  term_ok \\<Theta> A\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> - {N} \\<turnstile> A \\<longmapsto> N \\<longmapsto> B", "by blast"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> - {N} \\<turnstile> A \\<longmapsto> N \\<longmapsto> B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A = N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B\n 2. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "hence \"\\<Theta>,insert N \\<Gamma> \\<turnstile> B\""], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> - {N} \\<turnstile> A \\<longmapsto> N \\<longmapsto> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert N \\<Gamma> \\<turnstile> B", "using True implies_elim implies_intro insert_absorb"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> - {N} \\<turnstile> A \\<longmapsto> N \\<longmapsto> B\n  A = N\n  \\<lbrakk>?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<turnstile> ?A \\<longmapsto> ?B;\n   ?\\<Theta>,?\\<Gamma>\\<^sub>2 \\<turnstile> ?A\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<union>\n                              ?\\<Gamma>\\<^sub>2 \\<turnstile> ?B\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_term (sig \\<Theta>) N\n  \\<turnstile>\\<^sub>\\<tau> N : propT\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma> \\<turnstile> B\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma> - {N}\n  finite (\\<Gamma> - {N})\n  ?a \\<in> ?A \\<Longrightarrow> insert ?a ?A = ?A\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert N \\<Gamma> \\<turnstile> B", "by fastforce"], ["proof (state)\nthis:\n  \\<Theta>,insert N \\<Gamma> \\<turnstile> B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A = N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B\n 2. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "then"], ["proof (chain)\npicking this:\n  \\<Theta>,insert N \\<Gamma> \\<turnstile> B", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Theta>,insert N \\<Gamma> \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A (\\<Gamma> - {N}) \\<turnstile> N \\<longmapsto> B", "using True implies_elim implies_intro.hyps(3) implies_intro.hyps(4) implies_intro.prems(1) \n        trivial_pre_depr"], ["proof (prove)\nusing this:\n  \\<Theta>,insert N \\<Gamma> \\<turnstile> B\n  A = N\n  \\<lbrakk>?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<turnstile> ?A \\<longmapsto> ?B;\n   ?\\<Theta>,?\\<Gamma>\\<^sub>2 \\<turnstile> ?A\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<union>\n                              ?\\<Gamma>\\<^sub>2 \\<turnstile> ?B\n  wf_term (sig \\<Theta>) N\n  \\<turnstile>\\<^sub>\\<tau> N : propT\n  term_ok \\<Theta> A\n  \\<lbrakk>term_ok ?\\<Theta> ?c; typ_of ?c = Some propT\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,{?c} \\<turnstile> ?c\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A (\\<Gamma> - {N}) \\<turnstile> N \\<longmapsto> B", "by (simp add: implies_intro'_pre2 implies_intro.hyps(1))"], ["proof (state)\nthis:\n  \\<Theta>,insert A (\\<Gamma> - {N}) \\<turnstile> N \\<longmapsto> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "case False"], ["proof (state)\nthis:\n  A \\<noteq> N\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "hence s: \"insert A (\\<Gamma> - {N}) = insert A \\<Gamma> - {N}\""], ["proof (prove)\nusing this:\n  A \\<noteq> N\n\ngoal (1 subgoal):\n 1. insert A (\\<Gamma> - {N}) = insert A \\<Gamma> - {N}", "by auto"], ["proof (state)\nthis:\n  insert A (\\<Gamma> - {N}) = insert A \\<Gamma> - {N}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "have I: \"\\<Theta>,insert A \\<Gamma> \\<turnstile> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,insert A \\<Gamma> \\<turnstile> B", "using implies_intro.prems False"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma> - {N}\n  finite (\\<Gamma> - {N})\n  A \\<noteq> N\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A \\<Gamma> \\<turnstile> B", "by (auto intro!: implies_intro.IH)"], ["proof (state)\nthis:\n  \\<Theta>,insert A \\<Gamma> \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     wf_term (sig \\<Theta>) N; \\<turnstile>\\<^sub>\\<tau> N : propT;\n     \\<And>A.\n        \\<lbrakk>term_ok \\<Theta> A; typ_of A = Some propT;\n         A \\<notin> \\<Gamma>; finite \\<Gamma>\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B;\n     term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma> - {N};\n     finite (\\<Gamma> - {N}); A \\<noteq> N\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A\n                                (\\<Gamma> -\n                                 {N}) \\<turnstile> N \\<longmapsto> B", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,insert A (\\<Gamma> - {N}) \\<turnstile> N \\<longmapsto> B", "apply (subst s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,insert A \\<Gamma> - {N} \\<turnstile> N \\<longmapsto> B", "apply (rule proves.implies_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,insert A \\<Gamma> \\<turnstile> B\n 3. wf_term (sig \\<Theta>) N\n 4. \\<turnstile>\\<^sub>\\<tau> N : propT", "using implies_intro.hyps I"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  wf_term (sig \\<Theta>) N\n  \\<turnstile>\\<^sub>\\<tau> N : propT\n  \\<Theta>,insert A \\<Gamma> \\<turnstile> B\n\ngoal (4 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,insert A \\<Gamma> \\<turnstile> B\n 3. wf_term (sig \\<Theta>) N\n 4. \\<turnstile>\\<^sub>\\<tau> N : propT", "by auto"], ["proof (state)\nthis:\n  \\<Theta>,insert A (\\<Gamma> - {N}) \\<turnstile> N \\<longmapsto> B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Theta>,insert A (\\<Gamma> - {N}) \\<turnstile> N \\<longmapsto> B\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 2. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 3. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 4. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 2. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 3. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 4. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "case (implies_elim \\<Gamma>\\<^sub>1 A' B \\<Gamma>\\<^sub>2)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A' \\<longmapsto> B\n  \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A'\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A\n                              \\<Gamma>\\<^sub>1 \\<turnstile> A' \\<longmapsto>\n                      B\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma>\\<^sub>2 \\<turnstile> A'\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2\n  finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\n\ngoal (4 subgoals):\n 1. \\<And>\\<Gamma>\\<^sub>1 A B \\<Gamma>\\<^sub>2 Aa.\n       \\<lbrakk>\\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>1 \\<turnstile> A \\<longmapsto> B;\n        \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A;\n        \\<And>Aa.\n           \\<lbrakk>term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n            Aa \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<Theta>,insert Aa\n \\<Gamma>\\<^sub>2 \\<turnstile> A;\n        term_ok \\<Theta> Aa; typ_of Aa = Some propT;\n        Aa \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2;\n        finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert Aa\n                                   (\\<Gamma>\\<^sub>1 \\<union>\n                                    \\<Gamma>\\<^sub>2) \\<turnstile> B\n 2. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 3. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 4. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,insert A\n              (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2) \\<turnstile> B", "using proves.implies_elim implies_elim"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<turnstile> ?A \\<longmapsto> ?B;\n   ?\\<Theta>,?\\<Gamma>\\<^sub>2 \\<turnstile> ?A\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma>\\<^sub>1 \\<union>\n                              ?\\<Gamma>\\<^sub>2 \\<turnstile> ?B\n  \\<Theta>,\\<Gamma>\\<^sub>1 \\<turnstile> A' \\<longmapsto> B\n  \\<Theta>,\\<Gamma>\\<^sub>2 \\<turnstile> A'\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>\\<^sub>1; finite \\<Gamma>\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A\n                              \\<Gamma>\\<^sub>1 \\<turnstile> A' \\<longmapsto>\n                      B\n  \\<lbrakk>term_ok \\<Theta> ?A; typ_of ?A = Some propT;\n   ?A \\<notin> \\<Gamma>\\<^sub>2; finite \\<Gamma>\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,insert ?A \\<Gamma>\\<^sub>2 \\<turnstile> A'\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2\n  finite (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A\n              (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2) \\<turnstile> B", "by (metis UnCI Un_insert_left finite_Un)"], ["proof (state)\nthis:\n  \\<Theta>,insert A\n            (\\<Gamma>\\<^sub>1 \\<union> \\<Gamma>\\<^sub>2) \\<turnstile> B\n\ngoal (3 subgoals):\n 1. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 2. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 3. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 2. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 3. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "case (\\<beta>_conversion \\<Gamma> s T t x)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  wt_term (sig \\<Theta>) (Abs \\<Gamma> s)\n  wf_term (sig \\<Theta>) T\n  \\<turnstile>\\<^sub>\\<tau> T : \\<Gamma>\n  term_ok \\<Theta> x\n  typ_of x = Some propT\n  x \\<notin> t\n  finite t\n\ngoal (3 subgoals):\n 1. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 2. \\<And>T t u \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wt_term (sig \\<Theta>) (Abs T t);\n        wf_term (sig \\<Theta>) u; \\<turnstile>\\<^sub>\\<tau> u : T;\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq (Abs T t $ u)\n                    (subst_bv u t)\n 3. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  wt_term (sig \\<Theta>) (Abs \\<Gamma> s)\n  wf_term (sig \\<Theta>) T\n  \\<turnstile>\\<^sub>\\<tau> T : \\<Gamma>\n  term_ok \\<Theta> x\n  typ_of x = Some propT\n  x \\<notin> t\n  finite t", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wt_term (sig \\<Theta>) (Abs \\<Gamma> s)\n  wf_term (sig \\<Theta>) T\n  \\<turnstile>\\<^sub>\\<tau> T : \\<Gamma>\n  term_ok \\<Theta> x\n  typ_of x = Some propT\n  x \\<notin> t\n  finite t\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert x\n              t \\<turnstile> mk_eq (Abs \\<Gamma> s $ T) (subst_bv T s)", "using proves.\\<beta>_conversion"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wt_term (sig \\<Theta>) (Abs \\<Gamma> s)\n  wf_term (sig \\<Theta>) T\n  \\<turnstile>\\<^sub>\\<tau> T : \\<Gamma>\n  term_ok \\<Theta> x\n  typ_of x = Some propT\n  x \\<notin> t\n  finite t\n  \\<lbrakk>wf_theory ?\\<Theta>; wt_term (sig ?\\<Theta>) (Abs ?T ?t);\n   wf_term (sig ?\\<Theta>) ?u; \\<turnstile>\\<^sub>\\<tau> ?u : ?T\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> mk_eq (Abs ?T ?t $ ?u)\n                (subst_bv ?u ?t)\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert x\n              t \\<turnstile> mk_eq (Abs \\<Gamma> s $ T) (subst_bv T s)", "by blast"], ["proof (state)\nthis:\n  \\<Theta>,insert x t \\<turnstile> mk_eq (Abs \\<Gamma> s $ T) (subst_bv T s)\n\ngoal (2 subgoals):\n 1. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 2. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 2. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "case (eta t \\<tau> \\<tau>')"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>_\n  finite \\<Gamma>_\n\ngoal (2 subgoals):\n 1. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c\n 2. \\<And>t \\<tau> \\<tau>' \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>; wf_term (sig \\<Theta>) t;\n        \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>';\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_eq\n                    (Abs \\<tau> (t $ Bv 0)) t", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>_\n  finite \\<Gamma>_", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>_\n  finite \\<Gamma>_\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A \\<Gamma>_ \\<turnstile> mk_eq (Abs \\<tau> (t $ Bv 0)) t", "using proves.eta"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  wf_term (sig \\<Theta>) t\n  \\<turnstile>\\<^sub>\\<tau> t : \\<tau> \\<rightarrow> \\<tau>'\n  term_ok \\<Theta> A\n  typ_of A = Some propT\n  A \\<notin> \\<Gamma>_\n  finite \\<Gamma>_\n  \\<lbrakk>wf_theory ?\\<Theta>; wf_term (sig ?\\<Theta>) ?t;\n   \\<turnstile>\\<^sub>\\<tau> ?t : ?\\<tau> \\<rightarrow> ?\\<tau>'\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,?\\<Gamma> \\<turnstile> mk_eq\n                (Abs ?\\<tau> (?t $ Bv 0)) ?t\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert A \\<Gamma>_ \\<turnstile> mk_eq (Abs \\<tau> (t $ Bv 0)) t", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,insert A \\<Gamma>_ \\<turnstile> mk_eq (Abs \\<tau> (t $ Bv 0)) t\n\ngoal (1 subgoal):\n 1. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c", "case (of_class c T' T \\<Gamma>)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  const_type (sig \\<Theta>) (const_of_class c) =\n  Some (itselfT Core.aT \\<rightarrow> propT)\n  wf_type (sig \\<Theta>) T'\n  has_sort (osig (sig \\<Theta>)) T' (insert c full_sort)\n  term_ok \\<Theta> \\<Gamma>\n  typ_of \\<Gamma> = Some propT\n  \\<Gamma> \\<notin> T\n  finite T\n\ngoal (1 subgoal):\n 1. \\<And>c T \\<Gamma> A.\n       \\<lbrakk>wf_theory \\<Theta>;\n        const_type (sig \\<Theta>) (const_of_class c) =\n        Some (itselfT Core.aT \\<rightarrow> propT);\n        wf_type (sig \\<Theta>) T;\n        has_sort (osig (sig \\<Theta>)) T (insert c full_sort);\n        term_ok \\<Theta> A; typ_of A = Some propT; A \\<notin> \\<Gamma>;\n        finite \\<Gamma>\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,insert A\n                                   \\<Gamma> \\<turnstile> mk_of_class T c", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  const_type (sig \\<Theta>) (const_of_class c) =\n  Some (itselfT Core.aT \\<rightarrow> propT)\n  wf_type (sig \\<Theta>) T'\n  has_sort (osig (sig \\<Theta>)) T' (insert c full_sort)\n  term_ok \\<Theta> \\<Gamma>\n  typ_of \\<Gamma> = Some propT\n  \\<Gamma> \\<notin> T\n  finite T", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  const_type (sig \\<Theta>) (const_of_class c) =\n  Some (itselfT Core.aT \\<rightarrow> propT)\n  wf_type (sig \\<Theta>) T'\n  has_sort (osig (sig \\<Theta>)) T' (insert c full_sort)\n  term_ok \\<Theta> \\<Gamma>\n  typ_of \\<Gamma> = Some propT\n  \\<Gamma> \\<notin> T\n  finite T\n\ngoal (1 subgoal):\n 1. \\<Theta>,insert \\<Gamma> T \\<turnstile> mk_of_class T' c", "by (simp add: proves.of_class)"], ["proof (state)\nthis:\n  \\<Theta>,insert \\<Gamma> T \\<turnstile> mk_of_class T' c\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary weaken_proves: \"\\<Theta>, \\<Gamma> \\<turnstile> B \\<Longrightarrow> term_ok \\<Theta> A \\<Longrightarrow> typ_of A = Some propT\n  \\<Longrightarrow> finite \\<Gamma> \n  \\<Longrightarrow> \\<Theta>, insert A \\<Gamma> \\<turnstile> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> B; term_ok \\<Theta> A;\n     typ_of A = Some propT; finite \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B", "using weaken_proves'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?\\<Theta>,?\\<Gamma> \\<turnstile> ?B; term_ok ?\\<Theta> ?A;\n   typ_of ?A = Some propT; ?A \\<notin> ?\\<Gamma>; finite ?\\<Gamma>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Theta>,insert ?A ?\\<Gamma> \\<turnstile> ?B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Theta>,\\<Gamma> \\<turnstile> B; term_ok \\<Theta> A;\n     typ_of A = Some propT; finite \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,insert A \\<Gamma> \\<turnstile> B", "by (metis insert_absorb)"], ["", "lemma weaken_proves_set: \"finite \\<Gamma>2 \\<Longrightarrow> \\<Theta>, \\<Gamma> \\<turnstile> B \\<Longrightarrow> \\<forall>A\\<in>\\<Gamma>2 . term_ok \\<Theta> A \\<Longrightarrow> \\<forall>A\\<in>\\<Gamma>2 . typ_of A = Some propT\n  \\<Longrightarrow> finite \\<Gamma>\n  \\<Longrightarrow> \\<Theta>, \\<Gamma> \\<union> \\<Gamma>2 \\<turnstile> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite \\<Gamma>2; \\<Theta>,\\<Gamma> \\<turnstile> B;\n     \\<forall>A\\<in>\\<Gamma>2. term_ok \\<Theta> A;\n     \\<forall>A\\<in>\\<Gamma>2. typ_of A = Some propT;\n     finite \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<union> \\<Gamma>2 \\<turnstile> B", "by (induction \\<Gamma>2 arbitrary: \\<Gamma> rule: finite_induct) (use weaken_proves in auto)"], ["", "(* Maybe do directly instead *)"], ["", "lemma no_tvsT_imp_subst_typ_unchanged: \"tvsT T = empty \\<Longrightarrow> subst_typ insts T = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvsT T = {} \\<Longrightarrow> subst_typ insts T = T", "by (simp add: no_tvsT_imp_tsubsT_unchanged tsubstT_simulates_subst_typ)"], ["", "lemma subst_typ_fv:\n  shows \"apsnd (subst_typ insts) ` fv B = fv (subst_typ' insts B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apsnd (subst_typ insts) ` fv B = fv (subst_typ' insts B)", "by (induction B) auto"], ["", "lemma subst_typ_fv_point:\n  assumes \"(x, \\<tau>) \\<in> fv B\" \n  shows \"(x, subst_typ insts \\<tau>) \\<in> fv (subst_typ' insts B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, subst_typ insts \\<tau>) \\<in> fv (subst_typ' insts B)", "using subst_typ_fv"], ["proof (prove)\nusing this:\n  apsnd (subst_typ ?insts) ` fv ?B = fv (subst_typ' ?insts ?B)\n\ngoal (1 subgoal):\n 1. (x, subst_typ insts \\<tau>) \\<in> fv (subst_typ' insts B)", "by (metis apsnd_conv assms image_eqI)"], ["", "lemma subst_typ_typ_ok:\n  assumes \"typ_ok_sig \\<Sigma> \\<tau>\"\n  assumes \"list_all (typ_ok_sig \\<Sigma>) (map snd insts)\"\n  shows \"typ_ok_sig \\<Sigma> (subst_typ insts \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ insts \\<tau>)", "using assms"], ["proof (prove)\nusing this:\n  typ_ok_sig \\<Sigma> \\<tau>\n  list_all (typ_ok_sig \\<Sigma>) (map snd insts)\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ insts \\<tau>)", "proof (induction \\<tau>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; typ_ok_sig \\<Sigma> x2a;\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x2a);\n        typ_ok_sig \\<Sigma> (Ty x1 x2);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>typ_ok_sig \\<Sigma> (Tv x1 x2);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv x1 x2))", "case (Tv idn \\<tau>)"], ["proof (state)\nthis:\n  typ_ok_sig \\<Sigma> (Tv idn \\<tau>)\n  list_all (typ_ok_sig \\<Sigma>) (map snd insts)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; typ_ok_sig \\<Sigma> x2a;\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x2a);\n        typ_ok_sig \\<Sigma> (Ty x1 x2);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>typ_ok_sig \\<Sigma> (Tv x1 x2);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Tv x1 x2))", "then"], ["proof (chain)\npicking this:\n  typ_ok_sig \\<Sigma> (Tv idn \\<tau>)\n  list_all (typ_ok_sig \\<Sigma>) (map snd insts)", "show ?case"], ["proof (prove)\nusing this:\n  typ_ok_sig \\<Sigma> (Tv idn \\<tau>)\n  list_all (typ_ok_sig \\<Sigma>) (map snd insts)\n\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn \\<tau>))", "by (cases \"lookup (\\<lambda>x. x = (idn, \\<tau>)) insts\")\n      (fastforce simp add: list_all_iff dest: lookup_present_eq_key' split: prod.splits)+"], ["proof (state)\nthis:\n  typ_ok_sig \\<Sigma> (subst_typ insts (Tv idn \\<tau>))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; typ_ok_sig \\<Sigma> x2a;\n                    list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok_sig \\<Sigma>\n(subst_typ insts x2a);\n        typ_ok_sig \\<Sigma> (Ty x1 x2);\n        list_all (typ_ok_sig \\<Sigma>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok_sig \\<Sigma> (subst_typ insts (Ty x1 x2))", "qed (auto simp add: list_all_iff lookup_present_eq_key' split: option.splits)"], ["", "lemma subst_typ_comp_single_left: \"subst_typ [single] (subst_typ insts T) \n  = subst_typ (map (apsnd (subst_typ [single])) insts@[single]) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [single] (subst_typ insts T) =\n    subst_typ (map (apsnd (subst_typ [single])) insts @ [single]) T", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           subst_typ [single] (subst_typ insts x2a) =\n           subst_typ (map (apsnd (subst_typ [single])) insts @ [single])\n            x2a) \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Ty x1 x2)) =\n       subst_typ (map (apsnd (subst_typ [single])) insts @ [single])\n        (Ty x1 x2)\n 2. \\<And>x1 x2.\n       subst_typ [single] (subst_typ insts (Tv x1 x2)) =\n       subst_typ (map (apsnd (subst_typ [single])) insts @ [single])\n        (Tv x1 x2)", "case (Tv idn ty)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           subst_typ [single] (subst_typ insts x2a) =\n           subst_typ (map (apsnd (subst_typ [single])) insts @ [single])\n            x2a) \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Ty x1 x2)) =\n       subst_typ (map (apsnd (subst_typ [single])) insts @ [single])\n        (Ty x1 x2)\n 2. \\<And>x1 x2.\n       subst_typ [single] (subst_typ insts (Tv x1 x2)) =\n       subst_typ (map (apsnd (subst_typ [single])) insts @ [single])\n        (Tv x1 x2)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [single] (subst_typ insts (Tv idn ty)) =\n    subst_typ (map (apsnd (subst_typ [single])) insts @ [single])\n     (Tv idn ty)", "by (induction insts) auto"], ["proof (state)\nthis:\n  subst_typ [single] (subst_typ insts (Tv idn ty)) =\n  subst_typ (map (apsnd (subst_typ [single])) insts @ [single]) (Tv idn ty)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           subst_typ [single] (subst_typ insts x2a) =\n           subst_typ (map (apsnd (subst_typ [single])) insts @ [single])\n            x2a) \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Ty x1 x2)) =\n       subst_typ (map (apsnd (subst_typ [single])) insts @ [single])\n        (Ty x1 x2)", "qed auto"], ["", "lemma subst_typ_comp_single_left_stronger: \"subst_typ [single] (subst_typ insts T) \n  = subst_typ (map (apsnd (subst_typ [single])) insts\n  @ (if fst single \\<in> set (map fst insts) then [] else [single])) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [single] (subst_typ insts T) =\n    subst_typ\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     T", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           subst_typ [single] (subst_typ insts x2a) =\n           subst_typ\n            (map (apsnd (subst_typ [single])) insts @\n             (if fst single \\<in> set (map fst insts) then []\n              else [single]))\n            x2a) \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Ty x1 x2)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Ty x1 x2)\n 2. \\<And>x1 x2.\n       subst_typ [single] (subst_typ insts (Tv x1 x2)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Tv x1 x2)", "case (Tv idn S)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           subst_typ [single] (subst_typ insts x2a) =\n           subst_typ\n            (map (apsnd (subst_typ [single])) insts @\n             (if fst single \\<in> set (map fst insts) then []\n              else [single]))\n            x2a) \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Ty x1 x2)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Ty x1 x2)\n 2. \\<And>x1 x2.\n       subst_typ [single] (subst_typ insts (Tv x1 x2)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Tv x1 x2)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [single] (subst_typ insts (Tv idn S)) =\n    subst_typ\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     (Tv idn S)", "proof (cases \"lookup (\\<lambda>x. x = (idn,S)) insts\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S)) insts = None \\<Longrightarrow>\n    subst_typ [single] (subst_typ insts (Tv idn S)) =\n    subst_typ\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     (Tv idn S)\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) insts = Some a \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Tv idn S)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Tv idn S)", "case None"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S)) insts = None\n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S)) insts = None \\<Longrightarrow>\n    subst_typ [single] (subst_typ insts (Tv idn S)) =\n    subst_typ\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     (Tv idn S)\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) insts = Some a \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Tv idn S)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Tv idn S)", "hence \"lookup (\\<lambda>x. x = (idn, S)) (map (apsnd (subst_typ [single])) insts) = None\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S)) insts = None\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, S))\n     (map (apsnd (subst_typ [single])) insts) =\n    None", "by (induction insts) (auto split: if_splits)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S))\n   (map (apsnd (subst_typ [single])) insts) =\n  None\n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S)) insts = None \\<Longrightarrow>\n    subst_typ [single] (subst_typ insts (Tv idn S)) =\n    subst_typ\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     (Tv idn S)\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) insts = Some a \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Tv idn S)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Tv idn S)", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (idn, S))\n   (map (apsnd (subst_typ [single])) insts) =\n  None", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S))\n   (map (apsnd (subst_typ [single])) insts) =\n  None\n\ngoal (1 subgoal):\n 1. subst_typ [single] (subst_typ insts (Tv idn S)) =\n    subst_typ\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     (Tv idn S)", "using None"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S))\n   (map (apsnd (subst_typ [single])) insts) =\n  None\n  lookup (\\<lambda>x. x = (idn, S)) insts = None\n\ngoal (1 subgoal):\n 1. subst_typ [single] (subst_typ insts (Tv idn S)) =\n    subst_typ\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     (Tv idn S)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = (idn, S))\n              (map (apsnd (subst_typ [single])) insts) =\n             None;\n     lookup (\\<lambda>x. x = (idn, S)) insts = None\\<rbrakk>\n    \\<Longrightarrow> (fst single \\<in> fst ` set insts \\<longrightarrow>\n                       the_default (Tv idn S)\n                        (lookup (\\<lambda>x. x = (idn, S)) [single]) =\n                       Tv idn S) \\<and>\n                      (fst single \\<notin> fst ` set insts \\<longrightarrow>\n                       the_default (Tv idn S)\n                        (lookup (\\<lambda>x. x = (idn, S)) [single]) =\n                       the_default (Tv idn S)\n                        (lookup (\\<lambda>x. x = (idn, S))\n                          (map (apsnd (subst_typ [single])) insts @\n                           [single])))", "by (metis eq_fst_iff list.set_map lookup.simps(2) lookup_None_iff subst_typ.simps(2) \n          subst_typ_comp subst_typ_nil the_default.simps(1))"], ["proof (state)\nthis:\n  subst_typ [single] (subst_typ insts (Tv idn S)) =\n  subst_typ\n   (map (apsnd (subst_typ [single])) insts @\n    (if fst single \\<in> set (map fst insts) then [] else [single]))\n   (Tv idn S)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) insts = Some a \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Tv idn S)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Tv idn S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) insts = Some a \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Tv idn S)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Tv idn S)", "case (Some a)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S)) insts = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) insts = Some a \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Tv idn S)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Tv idn S)", "hence \"lookup (\\<lambda>x. x = (idn, S)) (map (apsnd (subst_typ [single])) insts) = Some (subst_typ [single] a)\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S)) insts = Some a\n\ngoal (1 subgoal):\n 1. lookup (\\<lambda>x. x = (idn, S))\n     (map (apsnd (subst_typ [single])) insts) =\n    Some (subst_typ [single] a)", "by (induction insts) (auto split: if_splits)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S))\n   (map (apsnd (subst_typ [single])) insts) =\n  Some (subst_typ [single] a)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S)) insts = Some a \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Tv idn S)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Tv idn S)", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (idn, S))\n   (map (apsnd (subst_typ [single])) insts) =\n  Some (subst_typ [single] a)", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S))\n   (map (apsnd (subst_typ [single])) insts) =\n  Some (subst_typ [single] a)\n\ngoal (1 subgoal):\n 1. subst_typ [single] (subst_typ insts (Tv idn S)) =\n    subst_typ\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     (Tv idn S)", "using Some"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S))\n   (map (apsnd (subst_typ [single])) insts) =\n  Some (subst_typ [single] a)\n  lookup (\\<lambda>x. x = (idn, S)) insts = Some a\n\ngoal (1 subgoal):\n 1. subst_typ [single] (subst_typ insts (Tv idn S)) =\n    subst_typ\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     (Tv idn S)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lookup (\\<lambda>x. x = (idn, S))\n              (map (apsnd (subst_typ [single])) insts) =\n             Some (subst_typ [single] a);\n     lookup (\\<lambda>x. x = (idn, S)) insts = Some a\\<rbrakk>\n    \\<Longrightarrow> fst single \\<notin> fst ` set insts \\<longrightarrow>\n                      subst_typ [single] a =\n                      the_default (Tv idn S)\n                       (lookup (\\<lambda>x. x = (idn, S))\n                         (map (apsnd (subst_typ [single])) insts @\n                          [single]))", "by (metis subst_typ.simps(2) subst_typ_comp_single_left the_default.simps(2))"], ["proof (state)\nthis:\n  subst_typ [single] (subst_typ insts (Tv idn S)) =\n  subst_typ\n   (map (apsnd (subst_typ [single])) insts @\n    (if fst single \\<in> set (map fst insts) then [] else [single]))\n   (Tv idn S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_typ [single] (subst_typ insts (Tv idn S)) =\n  subst_typ\n   (map (apsnd (subst_typ [single])) insts @\n    (if fst single \\<in> set (map fst insts) then [] else [single]))\n   (Tv idn S)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (\\<And>x2a.\n           x2a \\<in> set x2 \\<Longrightarrow>\n           subst_typ [single] (subst_typ insts x2a) =\n           subst_typ\n            (map (apsnd (subst_typ [single])) insts @\n             (if fst single \\<in> set (map fst insts) then []\n              else [single]))\n            x2a) \\<Longrightarrow>\n       subst_typ [single] (subst_typ insts (Ty x1 x2)) =\n       subst_typ\n        (map (apsnd (subst_typ [single])) insts @\n         (if fst single \\<in> set (map fst insts) then [] else [single]))\n        (Ty x1 x2)", "qed auto"], ["", "lemma subst_typ'_comp_single_left: \"subst_typ' [single] (subst_typ' insts t)\n  = subst_typ' (map (apsnd (subst_typ [single])) insts@[single]) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' [single] (subst_typ' insts t) =\n    subst_typ' (map (apsnd (subst_typ [single])) insts @ [single]) t", "by (induction t) (use subst_typ_comp_single_left in auto)"], ["", "lemma subst_typ'_comp_single_left_stronger: \"subst_typ' [single] (subst_typ' insts t)\n  = subst_typ' (map (apsnd (subst_typ [single])) insts\n  @ (if fst single \\<in> set (map fst insts) then [] else [single])) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' [single] (subst_typ' insts t) =\n    subst_typ'\n     (map (apsnd (subst_typ [single])) insts @\n      (if fst single \\<in> set (map fst insts) then [] else [single]))\n     t", "by (induction t) (use subst_typ_comp_single_left_stronger in auto)"], ["", "lemma subst_typ_preserves_typ_ok:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"typ_ok \\<Theta> T\"\n  assumes \"list_all (typ_ok \\<Theta>) (map snd insts)\"\n  shows \"typ_ok \\<Theta> (subst_typ insts T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (subst_typ insts T)", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  typ_ok \\<Theta> T\n  list_all (typ_ok \\<Theta>) (map snd insts)\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (subst_typ insts T)", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    typ_ok \\<Theta> x2a;\n                    list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts x2a);\n        wf_theory \\<Theta>; typ_ok \\<Theta> (Ty x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Ty x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Tv x1 x2))", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; wf_theory \\<Theta>; typ_ok \\<Theta> ?x2a;\n   list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n  \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts ?x2a)\n  wf_theory \\<Theta>\n  typ_ok \\<Theta> (Ty n Ts)\n  list_all (typ_ok \\<Theta>) (map snd insts)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    typ_ok \\<Theta> x2a;\n                    list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts x2a);\n        wf_theory \\<Theta>; typ_ok \\<Theta> (Ty x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Ty x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Tv x1 x2))", "have I: \"\\<forall>x \\<in> set Ts . typ_ok \\<Theta> (subst_typ insts x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)", "using Ty"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts; wf_theory \\<Theta>; typ_ok \\<Theta> ?x2a;\n   list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n  \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts ?x2a)\n  wf_theory \\<Theta>\n  typ_ok \\<Theta> (Ty n Ts)\n  list_all (typ_ok \\<Theta>) (map snd insts)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)", "by (auto simp add: typ_ok_def list_all_iff split: option.splits)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    typ_ok \\<Theta> x2a;\n                    list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts x2a);\n        wf_theory \\<Theta>; typ_ok \\<Theta> (Ty x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Ty x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Tv x1 x2))", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    typ_ok \\<Theta> x2a;\n                    list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts x2a);\n        wf_theory \\<Theta>; typ_ok \\<Theta> (Ty x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Ty x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Tv x1 x2))", "have \"(\\<forall>x \\<in> set Ts . typ_ok \\<Theta> (subst_typ insts x)) =\n     (\\<forall>x \\<in> set (map (subst_typ insts) Ts) . typ_ok \\<Theta> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)) =\n    (\\<forall>x\\<in>set (map (subst_typ insts) Ts). typ_ok \\<Theta> x)", "by (induction Ts) auto"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)) =\n  (\\<forall>x\\<in>set (map (subst_typ insts) Ts). typ_ok \\<Theta> x)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    typ_ok \\<Theta> x2a;\n                    list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts x2a);\n        wf_theory \\<Theta>; typ_ok \\<Theta> (Ty x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Ty x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Tv x1 x2))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)\n  (\\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)) =\n  (\\<forall>x\\<in>set (map (subst_typ insts) Ts). typ_ok \\<Theta> x)", "have \"list_all (wf_type (sig \\<Theta>)) (map (subst_typ insts) Ts)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)\n  (\\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)) =\n  (\\<forall>x\\<in>set (map (subst_typ insts) Ts). typ_ok \\<Theta> x)\n\ngoal (1 subgoal):\n 1. list_all (wf_type (sig \\<Theta>)) (map (subst_typ insts) Ts)", "using  list_allI typ_ok_def Ball_set typ_ok_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)\n  (\\<forall>x\\<in>set Ts. typ_ok \\<Theta> (subst_typ insts x)) =\n  (\\<forall>x\\<in>set (map (subst_typ insts) Ts). typ_ok \\<Theta> x)\n  (\\<And>x. x \\<in> set ?l \\<Longrightarrow> ?P x) \\<Longrightarrow>\n  list_all ?P ?l\n  typ_ok ?\\<Theta> ?T \\<equiv> wf_type (sig ?\\<Theta>) ?T\n  Ball (set ?xs) ?P = list_all ?P ?xs\n  typ_ok ?\\<Theta> ?T \\<equiv> wf_type (sig ?\\<Theta>) ?T\n\ngoal (1 subgoal):\n 1. list_all (wf_type (sig \\<Theta>)) (map (subst_typ insts) Ts)", "by fastforce"], ["proof (state)\nthis:\n  list_all (wf_type (sig \\<Theta>)) (map (subst_typ insts) Ts)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    typ_ok \\<Theta> x2a;\n                    list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n                   \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts x2a);\n        wf_theory \\<Theta>; typ_ok \\<Theta> (Ty x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Ty x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Tv x1 x2))", "then"], ["proof (chain)\npicking this:\n  list_all (wf_type (sig \\<Theta>)) (map (subst_typ insts) Ts)", "show ?case"], ["proof (prove)\nusing this:\n  list_all (wf_type (sig \\<Theta>)) (map (subst_typ insts) Ts)\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (subst_typ insts (Ty n Ts))", "using Ty list.pred_mono_strong"], ["proof (prove)\nusing this:\n  list_all (wf_type (sig \\<Theta>)) (map (subst_typ insts) Ts)\n  \\<lbrakk>?x2a \\<in> set Ts; wf_theory \\<Theta>; typ_ok \\<Theta> ?x2a;\n   list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n  \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts ?x2a)\n  wf_theory \\<Theta>\n  typ_ok \\<Theta> (Ty n Ts)\n  list_all (typ_ok \\<Theta>) (map snd insts)\n  \\<lbrakk>list_all ?P ?x;\n   \\<And>z.\n      \\<lbrakk>z \\<in> set ?x; ?P z\\<rbrakk>\n      \\<Longrightarrow> ?Pa z\\<rbrakk>\n  \\<Longrightarrow> list_all ?Pa ?x\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (subst_typ insts (Ty n Ts))", "by (force split: option.splits)"], ["proof (state)\nthis:\n  typ_ok \\<Theta> (subst_typ insts (Ty n Ts))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Tv x1 x2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Tv x1 x2))", "case (Tv idn \\<tau>)"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  typ_ok \\<Theta> (Tv idn \\<tau>)\n  list_all (typ_ok \\<Theta>) (map snd insts)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>wf_theory \\<Theta>; typ_ok \\<Theta> (Tv x1 x2);\n        list_all (typ_ok \\<Theta>) (map snd insts)\\<rbrakk>\n       \\<Longrightarrow> typ_ok \\<Theta> (subst_typ insts (Tv x1 x2))", "then"], ["proof (chain)\npicking this:\n  wf_theory \\<Theta>\n  typ_ok \\<Theta> (Tv idn \\<tau>)\n  list_all (typ_ok \\<Theta>) (map snd insts)", "show ?case"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  typ_ok \\<Theta> (Tv idn \\<tau>)\n  list_all (typ_ok \\<Theta>) (map snd insts)\n\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (subst_typ insts (Tv idn \\<tau>))", "by (induction insts) auto"], ["proof (state)\nthis:\n  typ_ok \\<Theta> (subst_typ insts (Tv idn \\<tau>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typ_ok_Ty[simp]: \"typ_ok \\<Theta> (Ty n Ts) \\<Longrightarrow> list_all (typ_ok \\<Theta>) Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok \\<Theta> (Ty n Ts) \\<Longrightarrow>\n    list_all (typ_ok \\<Theta>) Ts", "by (auto simp add: typ_ok_def list.pred_mono_strong split: option.splits)"], ["", "lemma typ_ok_sig_Ty[simp]: \"typ_ok_sig \\<Sigma> (Ty n Ts) \\<Longrightarrow> list_all (typ_ok_sig \\<Sigma>) Ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_ok_sig \\<Sigma> (Ty n Ts) \\<Longrightarrow>\n    list_all (typ_ok_sig \\<Sigma>) Ts", "by (auto simp add: list.pred_mono_strong split: option.splits)"], ["", "lemma wf_theory_imp_wf_osig: \"wf_theory \\<Theta> \\<Longrightarrow> wf_osig (osig (sig \\<Theta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_theory \\<Theta> \\<Longrightarrow> wf_osig (osig (sig \\<Theta>))", "by (cases \\<Theta> rule: theory_full_exhaust) simp"], ["", "lemma the_lift2_option_Somes[simp]: \"the (lift2_option f (Some a) (Some b)) = f a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (lift2_option f (Some a) (Some b)) = f a b", "by simp"], ["", "lemma class_les_mgd:\n  assumes \"wf_osig oss\" \n  assumes \"tcsigs oss type = Some mgd\"\n  assumes \"mgd C' = Some Ss'\"\n  assumes \"class_les (subclass oss) C' C\"\n  shows \"mgd C \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mgd C \\<noteq> None", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mgd C \\<noteq> None", "have \"complete_tcsigs (subclass oss) (tcsigs oss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete_tcsigs (subclass oss) (tcsigs oss)", "using assms(1)"], ["proof (prove)\nusing this:\n  wf_osig oss\n\ngoal (1 subgoal):\n 1. complete_tcsigs (subclass oss) (tcsigs oss)", "by (cases oss) simp"], ["proof (state)\nthis:\n  complete_tcsigs (subclass oss) (tcsigs oss)\n\ngoal (1 subgoal):\n 1. mgd C \\<noteq> None", "thus ?thesis"], ["proof (prove)\nusing this:\n  complete_tcsigs (subclass oss) (tcsigs oss)\n\ngoal (1 subgoal):\n 1. mgd C \\<noteq> None", "using assms(2-4)"], ["proof (prove)\nusing this:\n  complete_tcsigs (subclass oss) (tcsigs oss)\n  tcsigs oss type = Some mgd\n  mgd C' = Some Ss'\n  class_les (subclass oss) C' C\n\ngoal (1 subgoal):\n 1. mgd C \\<noteq> None", "by (auto simp add: class_les_def class_leq_def complete_tcsigs_def intro!: domI ranI)"], ["proof (state)\nthis:\n  mgd C \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sort_sort_leq_osig:\n  assumes \"wf_osig (sub, tcs)\" \"has_sort (sub,tcs) T S\" \"sort_leq sub S S'\"\n  shows \"has_sort (sub,tcs) T S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (sub, tcs) T S'", "using assms(2,3,1)"], ["proof (prove)\nusing this:\n  has_sort (sub, tcs) T S\n  sort_leq sub S S'\n  wf_osig (sub, tcs)\n\ngoal (1 subgoal):\n 1. has_sort (sub, tcs) T S'", "proof (induction \"(sub,tcs)\" T S arbitrary: S' rule: has_sort.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S S' a S'a.\n       \\<lbrakk>sort_leq sub S S'; sort_leq sub S' S'a;\n        wf_osig (sub, tcs)\\<rbrakk>\n       \\<Longrightarrow> has_sort (sub, tcs) (Tv a S) S'a\n 2. \\<And>\\<kappa> dm S Ts S'.\n       \\<lbrakk>tcs \\<kappa> = Some dm;\n        \\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and>\n              list_all2\n               (\\<lambda>x1 x2.\n                   has_sort (sub, tcs) x1 x2 \\<and>\n                   (True \\<and> True \\<longrightarrow>\n                    (\\<forall>x.\n                        sort_leq sub x2 x \\<longrightarrow>\n                        wf_osig (sub, tcs) \\<longrightarrow>\n                        has_sort (sub, tcs) x1 x)))\n               Ts Ss;\n        sort_leq sub S S'; wf_osig (sub, tcs)\\<rbrakk>\n       \\<Longrightarrow> has_sort (sub, tcs) (Ty \\<kappa> Ts) S'", "case (has_sort_Tv S S' tcs a)"], ["proof (state)\nthis:\n  sort_leq sub S S'\n  sort_leq sub S' a\n  wf_osig (sub, tcs)\n\ngoal (2 subgoals):\n 1. \\<And>S S' a S'a.\n       \\<lbrakk>sort_leq sub S S'; sort_leq sub S' S'a;\n        wf_osig (sub, tcs)\\<rbrakk>\n       \\<Longrightarrow> has_sort (sub, tcs) (Tv a S) S'a\n 2. \\<And>\\<kappa> dm S Ts S'.\n       \\<lbrakk>tcs \\<kappa> = Some dm;\n        \\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and>\n              list_all2\n               (\\<lambda>x1 x2.\n                   has_sort (sub, tcs) x1 x2 \\<and>\n                   (True \\<and> True \\<longrightarrow>\n                    (\\<forall>x.\n                        sort_leq sub x2 x \\<longrightarrow>\n                        wf_osig (sub, tcs) \\<longrightarrow>\n                        has_sort (sub, tcs) x1 x)))\n               Ts Ss;\n        sort_leq sub S S'; wf_osig (sub, tcs)\\<rbrakk>\n       \\<Longrightarrow> has_sort (sub, tcs) (Ty \\<kappa> Ts) S'", "then"], ["proof (chain)\npicking this:\n  sort_leq sub S S'\n  sort_leq sub S' a\n  wf_osig (sub, tcs)", "show ?case"], ["proof (prove)\nusing this:\n  sort_leq sub S S'\n  sort_leq sub S' a\n  wf_osig (sub, tcs)\n\ngoal (1 subgoal):\n 1. has_sort (sub, tcs) (Tv tcs S) a", "using wf_osig.simps wf_subclass_loc.intro wf_subclass_loc.sort_leq_trans"], ["proof (prove)\nusing this:\n  sort_leq sub S S'\n  sort_leq sub S' a\n  wf_osig (sub, tcs)\n  wf_osig (?sub, ?tcs) = (wf_subclass ?sub \\<and> wf_tcsigs ?sub ?tcs)\n  wf_subclass ?cs \\<Longrightarrow> wf_subclass_loc ?cs\n  \\<lbrakk>wf_subclass_loc ?cs; sort_leq ?cs ?x ?y;\n   sort_leq ?cs ?y ?z\\<rbrakk>\n  \\<Longrightarrow> sort_leq ?cs ?x ?z\n\ngoal (1 subgoal):\n 1. has_sort (sub, tcs) (Tv tcs S) a", "by blast"], ["proof (state)\nthis:\n  has_sort (sub, tcs) (Tv tcs S) a\n\ngoal (1 subgoal):\n 1. \\<And>\\<kappa> dm S Ts S'.\n       \\<lbrakk>tcs \\<kappa> = Some dm;\n        \\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and>\n              list_all2\n               (\\<lambda>x1 x2.\n                   has_sort (sub, tcs) x1 x2 \\<and>\n                   (True \\<and> True \\<longrightarrow>\n                    (\\<forall>x.\n                        sort_leq sub x2 x \\<longrightarrow>\n                        wf_osig (sub, tcs) \\<longrightarrow>\n                        has_sort (sub, tcs) x1 x)))\n               Ts Ss;\n        sort_leq sub S S'; wf_osig (sub, tcs)\\<rbrakk>\n       \\<Longrightarrow> has_sort (sub, tcs) (Ty \\<kappa> Ts) S'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<kappa> dm S Ts S'.\n       \\<lbrakk>tcs \\<kappa> = Some dm;\n        \\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and>\n              list_all2\n               (\\<lambda>x1 x2.\n                   has_sort (sub, tcs) x1 x2 \\<and>\n                   (True \\<and> True \\<longrightarrow>\n                    (\\<forall>x.\n                        sort_leq sub x2 x \\<longrightarrow>\n                        wf_osig (sub, tcs) \\<longrightarrow>\n                        has_sort (sub, tcs) x1 x)))\n               Ts Ss;\n        sort_leq sub S S'; wf_osig (sub, tcs)\\<rbrakk>\n       \\<Longrightarrow> has_sort (sub, tcs) (Ty \\<kappa> Ts) S'", "case (has_sort_Ty \\<kappa> K S Ts)"], ["proof (state)\nthis:\n  tcs \\<kappa> = Some K\n  \\<forall>c\\<in>S.\n     \\<exists>Ss.\n        K c = Some Ss \\<and>\n        list_all2\n         (\\<lambda>x1 x2.\n             has_sort (sub, tcs) x1 x2 \\<and>\n             (True \\<and> True \\<longrightarrow>\n              (\\<forall>x.\n                  sort_leq sub x2 x \\<longrightarrow>\n                  wf_osig (sub, tcs) \\<longrightarrow>\n                  has_sort (sub, tcs) x1 x)))\n         Ts Ss\n  sort_leq sub S S'\n  wf_osig (sub, tcs)\n\ngoal (1 subgoal):\n 1. \\<And>\\<kappa> dm S Ts S'.\n       \\<lbrakk>tcs \\<kappa> = Some dm;\n        \\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and>\n              list_all2\n               (\\<lambda>x1 x2.\n                   has_sort (sub, tcs) x1 x2 \\<and>\n                   (True \\<and> True \\<longrightarrow>\n                    (\\<forall>x.\n                        sort_leq sub x2 x \\<longrightarrow>\n                        wf_osig (sub, tcs) \\<longrightarrow>\n                        has_sort (sub, tcs) x1 x)))\n               Ts Ss;\n        sort_leq sub S S'; wf_osig (sub, tcs)\\<rbrakk>\n       \\<Longrightarrow> has_sort (sub, tcs) (Ty \\<kappa> Ts) S'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (sub, tcs) (Ty \\<kappa> Ts) S'", "proof (rule has_sort.has_sort_Ty[where dm=K])"], ["proof (state)\ngoal (2 subgoals):\n 1. tcs \\<kappa> = Some K\n 2. \\<forall>c\\<in>S'.\n       \\<exists>Ss.\n          K c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "show \"tcs \\<kappa> = Some K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tcs \\<kappa> = Some K", "using has_sort_Ty.hyps(1)"], ["proof (prove)\nusing this:\n  tcs \\<kappa> = Some K\n\ngoal (1 subgoal):\n 1. tcs \\<kappa> = Some K", "."], ["proof (state)\nthis:\n  tcs \\<kappa> = Some K\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>S'.\n       \\<exists>Ss.\n          K c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>S'.\n       \\<exists>Ss.\n          K c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "show \"\\<forall>C\\<in>S'. \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S'.\n       \\<exists>Ss.\n          K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "proof (rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> S' \\<Longrightarrow>\n       \\<exists>Ss.\n          K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> S' \\<Longrightarrow>\n       \\<exists>Ss.\n          K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "assume C: \"C \\<in> S'\""], ["proof (state)\nthis:\n  C \\<in> S'\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       C \\<in> S' \\<Longrightarrow>\n       \\<exists>Ss.\n          K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "show \"\\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "proof (cases \"C \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss\n 2. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "case True"], ["proof (state)\nthis:\n  C \\<in> S\n\ngoal (2 subgoals):\n 1. C \\<in> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss\n 2. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "then"], ["proof (chain)\npicking this:\n  C \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "using list_all2_mono has_sort_Ty.hyps(2)"], ["proof (prove)\nusing this:\n  C \\<in> S\n  \\<lbrakk>list_all2 ?P ?xs ?ys;\n   \\<And>xs ys. ?P xs ys \\<Longrightarrow> ?Q xs ys\\<rbrakk>\n  \\<Longrightarrow> list_all2 ?Q ?xs ?ys\n  \\<forall>c\\<in>S.\n     \\<exists>Ss.\n        K c = Some Ss \\<and>\n        list_all2\n         (\\<lambda>x1 x2.\n             has_sort (sub, tcs) x1 x2 \\<and>\n             (True \\<and> True \\<longrightarrow>\n              (\\<forall>x.\n                  sort_leq sub x2 x \\<longrightarrow>\n                  wf_osig (sub, tcs) \\<longrightarrow>\n                  has_sort (sub, tcs) x1 x)))\n         Ts Ss\n\ngoal (1 subgoal):\n 1. \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "case False"], ["proof (state)\nthis:\n  C \\<notin> S\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "from this"], ["proof (chain)\npicking this:\n  C \\<notin> S", "obtain C' where C': \n          \"C' \\<in> S\" \"class_les sub C' C\""], ["proof (prove)\nusing this:\n  C \\<notin> S\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        \\<lbrakk>C' \\<in> S; class_les sub C' C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis C class_les_def has_sort_Ty.prems(1) has_sort_Ty.prems(2) sort_leq_def \n              subclass.simps wf_osig_imp_wf_subclass_loc wf_subclass_loc.class_leq_antisym)"], ["proof (state)\nthis:\n  C' \\<in> S\n  class_les sub C' C\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "from this"], ["proof (chain)\npicking this:\n  C' \\<in> S\n  class_les sub C' C", "obtain Ss' where Ss': \n          \"K C' = Some Ss'\" \"list_all2 (has_sort (sub,tcs)) Ts Ss'\""], ["proof (prove)\nusing this:\n  C' \\<in> S\n  class_les sub C' C\n\ngoal (1 subgoal):\n 1. (\\<And>Ss'.\n        \\<lbrakk>K C' = Some Ss';\n         list_all2 (has_sort (sub, tcs)) Ts Ss'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using list_all2_mono has_sort_Ty.hyps(2)"], ["proof (prove)\nusing this:\n  C' \\<in> S\n  class_les sub C' C\n  \\<lbrakk>list_all2 ?P ?xs ?ys;\n   \\<And>xs ys. ?P xs ys \\<Longrightarrow> ?Q xs ys\\<rbrakk>\n  \\<Longrightarrow> list_all2 ?Q ?xs ?ys\n  \\<forall>c\\<in>S.\n     \\<exists>Ss.\n        K c = Some Ss \\<and>\n        list_all2\n         (\\<lambda>x1 x2.\n             has_sort (sub, tcs) x1 x2 \\<and>\n             (True \\<and> True \\<longrightarrow>\n              (\\<forall>x.\n                  sort_leq sub x2 x \\<longrightarrow>\n                  wf_osig (sub, tcs) \\<longrightarrow>\n                  has_sort (sub, tcs) x1 x)))\n         Ts Ss\n\ngoal (1 subgoal):\n 1. (\\<And>Ss'.\n        \\<lbrakk>K C' = Some Ss';\n         list_all2 (has_sort (sub, tcs)) Ts Ss'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  K C' = Some Ss'\n  list_all2 (has_sort (sub, tcs)) Ts Ss'\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "from this"], ["proof (chain)\npicking this:\n  K C' = Some Ss'\n  list_all2 (has_sort (sub, tcs)) Ts Ss'", "obtain Ss where Ss: \"K C = Some Ss\""], ["proof (prove)\nusing this:\n  K C' = Some Ss'\n  list_all2 (has_sort (sub, tcs)) Ts Ss'\n\ngoal (1 subgoal):\n 1. (\\<And>Ss. K C = Some Ss \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using has_sort_Ty.prems class_les_mgd C'(2) has_sort_Ty.hyps(1) wf_theory_imp_wf_osig"], ["proof (prove)\nusing this:\n  K C' = Some Ss'\n  list_all2 (has_sort (sub, tcs)) Ts Ss'\n  sort_leq sub S S'\n  wf_osig (sub, tcs)\n  \\<lbrakk>wf_osig ?oss; tcsigs ?oss ?type = Some ?mgd;\n   ?mgd ?C' = Some ?Ss'; class_les (subclass ?oss) ?C' ?C\\<rbrakk>\n  \\<Longrightarrow> ?mgd ?C \\<noteq> None\n  class_les sub C' C\n  tcs \\<kappa> = Some K\n  wf_theory ?\\<Theta> \\<Longrightarrow> wf_osig (osig (sig ?\\<Theta>))\n\ngoal (1 subgoal):\n 1. (\\<And>Ss. K C = Some Ss \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  K C = Some Ss\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "have lengthSs': \"length Ts = length Ss'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Ts = length Ss'", "using Ss'(2) list_all2_lengthD"], ["proof (prove)\nusing this:\n  list_all2 (has_sort (sub, tcs)) Ts Ss'\n  list_all2 ?P ?xs ?ys \\<Longrightarrow> length ?xs = length ?ys\n\ngoal (1 subgoal):\n 1. length Ts = length Ss'", "by auto"], ["proof (state)\nthis:\n  length Ts = length Ss'\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "have coregular: \n          \"coregular_tcsigs sub tcs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coregular_tcsigs sub tcs", "using has_sort_Ty.prems(2) wf_theory_imp_wf_osig wf_tcsigs_def"], ["proof (prove)\nusing this:\n  wf_osig (sub, tcs)\n  wf_theory ?\\<Theta> \\<Longrightarrow> wf_osig (osig (sig ?\\<Theta>))\n  wf_tcsigs ?sub ?tcs =\n  (coregular_tcsigs ?sub ?tcs \\<and>\n   complete_tcsigs ?sub ?tcs \\<and>\n   consistent_length_tcsigs ?tcs \\<and>\n   all_normalized_and_ex_tcsigs ?sub ?tcs)\n\ngoal (1 subgoal):\n 1. coregular_tcsigs sub tcs", "by (metis wf_osig.simps)"], ["proof (state)\nthis:\n  coregular_tcsigs sub tcs\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "hence leq: \"list_all2 (sort_leq sub) Ss' Ss\""], ["proof (prove)\nusing this:\n  coregular_tcsigs sub tcs\n\ngoal (1 subgoal):\n 1. list_all2 (sort_leq sub) Ss' Ss", "using C'(2) Ss'(1) Ss has_sort_Ty.hyps(1) ranI"], ["proof (prove)\nusing this:\n  coregular_tcsigs sub tcs\n  class_les sub C' C\n  K C' = Some Ss'\n  K C = Some Ss\n  tcs \\<kappa> = Some K\n  ?m ?a = Some ?b \\<Longrightarrow> ?b \\<in> ran ?m\n\ngoal (1 subgoal):\n 1. list_all2 (sort_leq sub) Ss' Ss", "by (metis class_les_def coregular_tcsigs_def domI option.sel)"], ["proof (state)\nthis:\n  list_all2 (sort_leq sub) Ss' Ss\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "have \"list_all2 (has_sort (sub,tcs)) Ts Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (has_sort (sub, tcs)) Ts Ss", "proof(rule list_all2_all_nthI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length Ts = length Ss\n 2. \\<And>n.\n       n < length Ts \\<Longrightarrow> has_sort (sub, tcs) (Ts ! n) (Ss ! n)", "show \"length Ts = length Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Ts = length Ss", "using Ss Ss'(1) lengthSs' wf_theory_imp_wf_osig leq list_all2_lengthD"], ["proof (prove)\nusing this:\n  K C = Some Ss\n  K C' = Some Ss'\n  length Ts = length Ss'\n  wf_theory ?\\<Theta> \\<Longrightarrow> wf_osig (osig (sig ?\\<Theta>))\n  list_all2 (sort_leq sub) Ss' Ss\n  list_all2 ?P ?xs ?ys \\<Longrightarrow> length ?xs = length ?ys\n\ngoal (1 subgoal):\n 1. length Ts = length Ss", "by auto"], ["proof (state)\nthis:\n  length Ts = length Ss\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length Ts \\<Longrightarrow> has_sort (sub, tcs) (Ts ! n) (Ss ! n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length Ts \\<Longrightarrow> has_sort (sub, tcs) (Ts ! n) (Ss ! n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length Ts \\<Longrightarrow> has_sort (sub, tcs) (Ts ! n) (Ss ! n)", "assume n: \"n < length Ts\""], ["proof (state)\nthis:\n  n < length Ts\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length Ts \\<Longrightarrow> has_sort (sub, tcs) (Ts ! n) (Ss ! n)", "hence \"sort_leq sub (Ss' ! n) (Ss ! n)\""], ["proof (prove)\nusing this:\n  n < length Ts\n\ngoal (1 subgoal):\n 1. sort_leq sub (Ss' ! n) (Ss ! n)", "using leq"], ["proof (prove)\nusing this:\n  n < length Ts\n  list_all2 (sort_leq sub) Ss' Ss\n\ngoal (1 subgoal):\n 1. sort_leq sub (Ss' ! n) (Ss ! n)", "by (simp add: lengthSs' list_all2_nthD)"], ["proof (state)\nthis:\n  sort_leq sub (Ss' ! n) (Ss ! n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length Ts \\<Longrightarrow> has_sort (sub, tcs) (Ts ! n) (Ss ! n)", "thus \"has_sort (sub,tcs) (Ts ! n) (Ss ! n)\""], ["proof (prove)\nusing this:\n  sort_leq sub (Ss' ! n) (Ss ! n)\n\ngoal (1 subgoal):\n 1. has_sort (sub, tcs) (Ts ! n) (Ss ! n)", "using has_sort_Ty.hyps(2) has_sort_Ty.prems(2) C'(1) Ss'(1) n list_all2_nthD"], ["proof (prove)\nusing this:\n  sort_leq sub (Ss' ! n) (Ss ! n)\n  \\<forall>c\\<in>S.\n     \\<exists>Ss.\n        K c = Some Ss \\<and>\n        list_all2\n         (\\<lambda>x1 x2.\n             has_sort (sub, tcs) x1 x2 \\<and>\n             (True \\<and> True \\<longrightarrow>\n              (\\<forall>x.\n                  sort_leq sub x2 x \\<longrightarrow>\n                  wf_osig (sub, tcs) \\<longrightarrow>\n                  has_sort (sub, tcs) x1 x)))\n         Ts Ss\n  wf_osig (sub, tcs)\n  C' \\<in> S\n  K C' = Some Ss'\n  n < length Ts\n  \\<lbrakk>list_all2 ?P ?xs ?ys; ?p < length ?xs\\<rbrakk>\n  \\<Longrightarrow> ?P (?xs ! ?p) (?ys ! ?p)\n\ngoal (1 subgoal):\n 1. has_sort (sub, tcs) (Ts ! n) (Ss ! n)", "by fastforce"], ["proof (state)\nthis:\n  has_sort (sub, tcs) (Ts ! n) (Ss ! n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 (has_sort (sub, tcs)) Ts Ss\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "thus \"\\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss\""], ["proof (prove)\nusing this:\n  list_all2 (has_sort (sub, tcs)) Ts Ss\n\ngoal (1 subgoal):\n 1. \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "using Ss"], ["proof (prove)\nusing this:\n  list_all2 (has_sort (sub, tcs)) Ts Ss\n  K C = Some Ss\n\ngoal (1 subgoal):\n 1. \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss", "by (simp)"], ["proof (state)\nthis:\n  \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C\\<in>S'.\n     \\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_sort (sub, tcs) (Ty \\<kappa> Ts) S'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_sort_sort_leq: \"wf_theory \\<Theta> \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) T S \n  \\<Longrightarrow> sort_leq (subclass (osig (sig \\<Theta>))) S S'\n  \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) T S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) T S;\n     sort_leq (subclass (osig (sig \\<Theta>))) S S'\\<rbrakk>\n    \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) T S'", "by (metis has_sort_sort_leq_osig subclass.elims wf_theory_imp_wf_osig)"], ["", "lemma subst_typ_preserves_has_sort:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"has_sort (osig (sig \\<Theta>)) T S\"\n  assumes \"list_all (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S) insts\"\n  shows \"has_sort (osig (sig \\<Theta>)) (subst_typ insts T) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts T) S", "using assms"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  has_sort (osig (sig \\<Theta>)) T S\n  list_all (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n   insts\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts T) S", "proof(induction T arbitrary: S)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    has_sort (osig (sig \\<Theta>)) x2a S;\n                    list_all\n                     (\\<lambda>((idn, S), T).\n                         has_sort (osig (sig \\<Theta>)) T S)\n                     insts\\<rbrakk>\n                   \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n(subst_typ insts x2a) S;\n        wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) (Ty x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Ty x1 x2)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "case (Ty \\<kappa> Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; wf_theory \\<Theta>;\n   has_sort (osig (sig \\<Theta>)) ?x2a ?S;\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (idn, S) \\<Rightarrow>\n             \\<lambda>T. has_sort (osig (sig \\<Theta>)) T S)\n           b)\n    insts\\<rbrakk>\n  \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) (subst_typ insts ?x2a) ?S\n  wf_theory \\<Theta>\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> Ts) S\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idn, S) \\<Rightarrow>\n            \\<lambda>T. has_sort (osig (sig \\<Theta>)) T S)\n          b)\n   insts\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    has_sort (osig (sig \\<Theta>)) x2a S;\n                    list_all\n                     (\\<lambda>((idn, S), T).\n                         has_sort (osig (sig \\<Theta>)) T S)\n                     insts\\<rbrakk>\n                   \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n(subst_typ insts x2a) S;\n        wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) (Ty x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Ty x1 x2)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "obtain cl tcs where cltcs: \"osig (sig \\<Theta>) = (cl, tcs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cl tcs.\n        osig (sig \\<Theta>) = (cl, tcs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  osig (sig \\<Theta>) = (cl, tcs)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    has_sort (osig (sig \\<Theta>)) x2a S;\n                    list_all\n                     (\\<lambda>((idn, S), T).\n                         has_sort (osig (sig \\<Theta>)) T S)\n                     insts\\<rbrakk>\n                   \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n(subst_typ insts x2a) S;\n        wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) (Ty x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Ty x1 x2)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "moreover"], ["proof (state)\nthis:\n  osig (sig \\<Theta>) = (cl, tcs)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    has_sort (osig (sig \\<Theta>)) x2a S;\n                    list_all\n                     (\\<lambda>((idn, S), T).\n                         has_sort (osig (sig \\<Theta>)) T S)\n                     insts\\<rbrakk>\n                   \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n(subst_typ insts x2a) S;\n        wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) (Ty x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Ty x1 x2)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "obtain K where \"tcsigs (osig (sig \\<Theta>)) \\<kappa> = Some K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>K.\n        tcsigs (osig (sig \\<Theta>)) \\<kappa> = Some K \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Ty.prems(2) has_sort.simps"], ["proof (prove)\nusing this:\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> Ts) S\n  has_sort ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>sub S S' tcs a.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Tv a S \\<and> ?a3.0 = S' \\<and> sort_leq sub S S') \\<or>\n   (\\<exists>tcs \\<kappa> dm S sub Ts.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Ty \\<kappa> Ts \\<and>\n       ?a3.0 = S \\<and>\n       tcs \\<kappa> = Some dm \\<and>\n       (\\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss)))\n\ngoal (1 subgoal):\n 1. (\\<And>K.\n        tcsigs (osig (sig \\<Theta>)) \\<kappa> = Some K \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tcsigs (osig (sig \\<Theta>)) \\<kappa> = Some K\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    has_sort (osig (sig \\<Theta>)) x2a S;\n                    list_all\n                     (\\<lambda>((idn, S), T).\n                         has_sort (osig (sig \\<Theta>)) T S)\n                     insts\\<rbrakk>\n                   \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n(subst_typ insts x2a) S;\n        wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) (Ty x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Ty x1 x2)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "ultimately"], ["proof (chain)\npicking this:\n  osig (sig \\<Theta>) = (cl, tcs)\n  tcsigs (osig (sig \\<Theta>)) \\<kappa> = Some K", "have mgd: \"tcs \\<kappa> = Some K\""], ["proof (prove)\nusing this:\n  osig (sig \\<Theta>) = (cl, tcs)\n  tcsigs (osig (sig \\<Theta>)) \\<kappa> = Some K\n\ngoal (1 subgoal):\n 1. tcs \\<kappa> = Some K", "by simp"], ["proof (state)\nthis:\n  tcs \\<kappa> = Some K\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    has_sort (osig (sig \\<Theta>)) x2a S;\n                    list_all\n                     (\\<lambda>((idn, S), T).\n                         has_sort (osig (sig \\<Theta>)) T S)\n                     insts\\<rbrakk>\n                   \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n(subst_typ insts x2a) S;\n        wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) (Ty x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Ty x1 x2)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "have \"has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ty \\<kappa> Ts)) S\n    = has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ty \\<kappa> Ts)) S =\n    has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts))\n     S", "by simp"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ty \\<kappa> Ts)) S =\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts)) S\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    has_sort (osig (sig \\<Theta>)) x2a S;\n                    list_all\n                     (\\<lambda>((idn, S), T).\n                         has_sort (osig (sig \\<Theta>)) T S)\n                     insts\\<rbrakk>\n                   \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n(subst_typ insts x2a) S;\n        wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) (Ty x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Ty x1 x2)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "moreover"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ty \\<kappa> Ts)) S =\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts)) S\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    has_sort (osig (sig \\<Theta>)) x2a S;\n                    list_all\n                     (\\<lambda>((idn, S), T).\n                         has_sort (osig (sig \\<Theta>)) T S)\n                     insts\\<rbrakk>\n                   \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n(subst_typ insts x2a) S;\n        wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) (Ty x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Ty x1 x2)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "have \"has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts))\n     S", "proof (subst cltcs, rule has_sort_Ty[of tcs, OF mgd], rule ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          K c = Some Ss \\<and>\n          list_all2 (has_sort (cl, tcs)) (map (subst_typ insts) Ts) Ss", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          K c = Some Ss \\<and>\n          list_all2 (has_sort (cl, tcs)) (map (subst_typ insts) Ts) Ss", "assume C: \"C \\<in> S\""], ["proof (state)\nthis:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          K c = Some Ss \\<and>\n          list_all2 (has_sort (cl, tcs)) (map (subst_typ insts) Ts) Ss", "obtain Ss where Ss: \"K C = Some Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ss. K C = Some Ss \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using C Ty.prems(2) mgd has_sort.simps cltcs"], ["proof (prove)\nusing this:\n  C \\<in> S\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> Ts) S\n  tcs \\<kappa> = Some K\n  has_sort ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>sub S S' tcs a.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Tv a S \\<and> ?a3.0 = S' \\<and> sort_leq sub S S') \\<or>\n   (\\<exists>tcs \\<kappa> dm S sub Ts.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Ty \\<kappa> Ts \\<and>\n       ?a3.0 = S \\<and>\n       tcs \\<kappa> = Some dm \\<and>\n       (\\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss)))\n  osig (sig \\<Theta>) = (cl, tcs)\n\ngoal (1 subgoal):\n 1. (\\<And>Ss. K C = Some Ss \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  K C = Some Ss\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          K c = Some Ss \\<and>\n          list_all2 (has_sort (cl, tcs)) (map (subst_typ insts) Ts) Ss", "have \"list_all2 (has_sort (osig (sig \\<Theta>))) (map (subst_typ insts) Ts) Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (has_sort (osig (sig \\<Theta>))) (map (subst_typ insts) Ts) Ss", "proof (rule list_all2_all_nthI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (map (subst_typ insts) Ts) = length Ss\n 2. \\<And>n.\n       n < length (map (subst_typ insts) Ts) \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n)\n        (Ss ! n)", "show \"length (map (subst_typ insts) Ts) = length Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (subst_typ insts) Ts) = length Ss", "using C Ss Ty.prems(2) list_all2_lengthD mgd has_sort.simps cltcs"], ["proof (prove)\nusing this:\n  C \\<in> S\n  K C = Some Ss\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> Ts) S\n  list_all2 ?P ?xs ?ys \\<Longrightarrow> length ?xs = length ?ys\n  tcs \\<kappa> = Some K\n  has_sort ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>sub S S' tcs a.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Tv a S \\<and> ?a3.0 = S' \\<and> sort_leq sub S S') \\<or>\n   (\\<exists>tcs \\<kappa> dm S sub Ts.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Ty \\<kappa> Ts \\<and>\n       ?a3.0 = S \\<and>\n       tcs \\<kappa> = Some dm \\<and>\n       (\\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss)))\n  osig (sig \\<Theta>) = (cl, tcs)\n\ngoal (1 subgoal):\n 1. length (map (subst_typ insts) Ts) = length Ss", "by fastforce"], ["proof (state)\nthis:\n  length (map (subst_typ insts) Ts) = length Ss\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (map (subst_typ insts) Ts) \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n)\n        (Ss ! n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (map (subst_typ insts) Ts) \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n)\n        (Ss ! n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (map (subst_typ insts) Ts) \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n)\n        (Ss ! n)", "assume n: \"n < length (map (subst_typ insts) Ts)\""], ["proof (state)\nthis:\n  n < length (map (subst_typ insts) Ts)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (map (subst_typ insts) Ts) \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n)\n        (Ss ! n)", "have \"list_all2 (has_sort (cl, tcs)) Ts Ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (has_sort (cl, tcs)) Ts Ss", "using C Ss Ty.prems(2) cltcs has_sort.simps mgd"], ["proof (prove)\nusing this:\n  C \\<in> S\n  K C = Some Ss\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> Ts) S\n  osig (sig \\<Theta>) = (cl, tcs)\n  has_sort ?a1.0 ?a2.0 ?a3.0 =\n  ((\\<exists>sub S S' tcs a.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Tv a S \\<and> ?a3.0 = S' \\<and> sort_leq sub S S') \\<or>\n   (\\<exists>tcs \\<kappa> dm S sub Ts.\n       ?a1.0 = (sub, tcs) \\<and>\n       ?a2.0 = Ty \\<kappa> Ts \\<and>\n       ?a3.0 = S \\<and>\n       tcs \\<kappa> = Some dm \\<and>\n       (\\<forall>c\\<in>S.\n           \\<exists>Ss.\n              dm c = Some Ss \\<and> list_all2 (has_sort (sub, tcs)) Ts Ss)))\n  tcs \\<kappa> = Some K\n\ngoal (1 subgoal):\n 1. list_all2 (has_sort (cl, tcs)) Ts Ss", "by auto"], ["proof (state)\nthis:\n  list_all2 (has_sort (cl, tcs)) Ts Ss\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (map (subst_typ insts) Ts) \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n)\n        (Ss ! n)", "hence 1: \"has_sort (osig (sig \\<Theta>)) (Ts ! n) (Ss ! n)\""], ["proof (prove)\nusing this:\n  list_all2 (has_sort (cl, tcs)) Ts Ss\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (Ts ! n) (Ss ! n)", "using cltcs list_all2_conv_all_nth n"], ["proof (prove)\nusing this:\n  list_all2 (has_sort (cl, tcs)) Ts Ss\n  osig (sig \\<Theta>) = (cl, tcs)\n  list_all2 ?P ?xs ?ys =\n  (length ?xs = length ?ys \\<and>\n   (\\<forall>i<length ?xs. ?P (?xs ! i) (?ys ! i)))\n  n < length (map (subst_typ insts) Ts)\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (Ts ! n) (Ss ! n)", "by auto"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (Ts ! n) (Ss ! n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (map (subst_typ insts) Ts) \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n)\n        (Ss ! n)", "have \"has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ts ! n)) (Ss ! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ts ! n)) (Ss ! n)", "using 1 n Ty.prems cltcs C Ss mgd Ty.IH"], ["proof (prove)\nusing this:\n  has_sort (osig (sig \\<Theta>)) (Ts ! n) (Ss ! n)\n  n < length (map (subst_typ insts) Ts)\n  wf_theory \\<Theta>\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> Ts) S\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idn, S) \\<Rightarrow>\n            \\<lambda>T. has_sort (osig (sig \\<Theta>)) T S)\n          b)\n   insts\n  osig (sig \\<Theta>) = (cl, tcs)\n  C \\<in> S\n  K C = Some Ss\n  tcs \\<kappa> = Some K\n  \\<lbrakk>?x2a \\<in> set Ts; wf_theory \\<Theta>;\n   has_sort (osig (sig \\<Theta>)) ?x2a ?S;\n   list_all\n    (\\<lambda>a.\n        case a of\n        (a, b) \\<Rightarrow>\n          (case a of\n           (idn, S) \\<Rightarrow>\n             \\<lambda>T. has_sort (osig (sig \\<Theta>)) T S)\n           b)\n    insts\\<rbrakk>\n  \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) (subst_typ insts ?x2a) ?S\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ts ! n)) (Ss ! n)", "by auto"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ts ! n)) (Ss ! n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length (map (subst_typ insts) Ts) \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n)\n        (Ss ! n)", "then"], ["proof (chain)\npicking this:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ts ! n)) (Ss ! n)", "show \"has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n) (Ss ! n)\""], ["proof (prove)\nusing this:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ts ! n)) (Ss ! n)\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n) (Ss ! n)", "using n"], ["proof (prove)\nusing this:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ts ! n)) (Ss ! n)\n  n < length (map (subst_typ insts) Ts)\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n) (Ss ! n)", "by auto"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (map (subst_typ insts) Ts ! n) (Ss ! n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 (has_sort (osig (sig \\<Theta>))) (map (subst_typ insts) Ts) Ss\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> S \\<Longrightarrow>\n       \\<exists>Ss.\n          K c = Some Ss \\<and>\n          list_all2 (has_sort (cl, tcs)) (map (subst_typ insts) Ts) Ss", "thus \"\\<exists>Ss. K C = Some Ss \\<and> list_all2 (has_sort (cl, tcs)) (map (subst_typ insts) Ts) Ss\""], ["proof (prove)\nusing this:\n  list_all2 (has_sort (osig (sig \\<Theta>))) (map (subst_typ insts) Ts) Ss\n\ngoal (1 subgoal):\n 1. \\<exists>Ss.\n       K C = Some Ss \\<and>\n       list_all2 (has_sort (cl, tcs)) (map (subst_typ insts) Ts) Ss", "using Ss cltcs"], ["proof (prove)\nusing this:\n  list_all2 (has_sort (osig (sig \\<Theta>))) (map (subst_typ insts) Ts) Ss\n  K C = Some Ss\n  osig (sig \\<Theta>) = (cl, tcs)\n\ngoal (1 subgoal):\n 1. \\<exists>Ss.\n       K C = Some Ss \\<and>\n       list_all2 (has_sort (cl, tcs)) (map (subst_typ insts) Ts) Ss", "by simp"], ["proof (state)\nthis:\n  \\<exists>Ss.\n     K C = Some Ss \\<and>\n     list_all2 (has_sort (cl, tcs)) (map (subst_typ insts) Ts) Ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts)) S\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>\\<And>x2a S.\n                   \\<lbrakk>x2a \\<in> set x2; wf_theory \\<Theta>;\n                    has_sort (osig (sig \\<Theta>)) x2a S;\n                    list_all\n                     (\\<lambda>((idn, S), T).\n                         has_sort (osig (sig \\<Theta>)) T S)\n                     insts\\<rbrakk>\n                   \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n(subst_typ insts x2a) S;\n        wf_theory \\<Theta>; has_sort (osig (sig \\<Theta>)) (Ty x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Ty x1 x2)) S\n 2. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "ultimately"], ["proof (chain)\npicking this:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ty \\<kappa> Ts)) S =\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts)) S\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts)) S", "show ?case"], ["proof (prove)\nusing this:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ty \\<kappa> Ts)) S =\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts)) S\n  has_sort (osig (sig \\<Theta>)) (Ty \\<kappa> (map (subst_typ insts) Ts)) S\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ty \\<kappa> Ts)) S", "by simp"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Ty \\<kappa> Ts)) S\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "case (Tv idn S')"], ["proof (state)\nthis:\n  wf_theory \\<Theta>\n  has_sort (osig (sig \\<Theta>)) (Tv idn S') S\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idn, S) \\<Rightarrow>\n            \\<lambda>T. has_sort (osig (sig \\<Theta>)) T S)\n          b)\n   insts\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 S.\n       \\<lbrakk>wf_theory \\<Theta>;\n        has_sort (osig (sig \\<Theta>)) (Tv x1 x2) S;\n        list_all\n         (\\<lambda>((idn, S), T). has_sort (osig (sig \\<Theta>)) T S)\n         insts\\<rbrakk>\n       \\<Longrightarrow> has_sort (osig (sig \\<Theta>))\n                          (subst_typ insts (Tv x1 x2)) S", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "proof(cases \"(lookup (\\<lambda>x. x = (idn, S')) insts)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S')) insts = None \\<Longrightarrow>\n    has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S')) insts = Some a \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "case None"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S')) insts = None\n\ngoal (2 subgoals):\n 1. lookup (\\<lambda>x. x = (idn, S')) insts = None \\<Longrightarrow>\n    has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S\n 2. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S')) insts = Some a \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "then"], ["proof (chain)\npicking this:\n  lookup (\\<lambda>x. x = (idn, S')) insts = None", "show ?thesis"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S')) insts = None\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "using Tv"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S')) insts = None\n  wf_theory \\<Theta>\n  has_sort (osig (sig \\<Theta>)) (Tv idn S') S\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idn, S) \\<Rightarrow>\n            \\<lambda>T. has_sort (osig (sig \\<Theta>)) T S)\n          b)\n   insts\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "by simp"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S')) insts = Some a \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S')) insts = Some a \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "case (Some res)"], ["proof (state)\nthis:\n  lookup (\\<lambda>x. x = (idn, S')) insts = Some res\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S')) insts = Some a \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "hence \"((idn, S'), res) \\<in> set insts\""], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S')) insts = Some res\n\ngoal (1 subgoal):\n 1. ((idn, S'), res) \\<in> set insts", "using lookup_present_eq_key'"], ["proof (prove)\nusing this:\n  lookup (\\<lambda>x. x = (idn, S')) insts = Some res\n  lookup (\\<lambda>x. x = ?k) ?al = Some ?v \\<Longrightarrow>\n  (?k, ?v) \\<in> set ?al\n\ngoal (1 subgoal):\n 1. ((idn, S'), res) \\<in> set insts", "by fast"], ["proof (state)\nthis:\n  ((idn, S'), res) \\<in> set insts\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S')) insts = Some a \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "hence \"has_sort (osig (sig \\<Theta>)) res S'\""], ["proof (prove)\nusing this:\n  ((idn, S'), res) \\<in> set insts\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) res S'", "using Tv"], ["proof (prove)\nusing this:\n  ((idn, S'), res) \\<in> set insts\n  wf_theory \\<Theta>\n  has_sort (osig (sig \\<Theta>)) (Tv idn S') S\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idn, S) \\<Rightarrow>\n            \\<lambda>T. has_sort (osig (sig \\<Theta>)) T S)\n          b)\n   insts\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) res S'", "using split_list"], ["proof (prove)\nusing this:\n  ((idn, S'), res) \\<in> set insts\n  wf_theory \\<Theta>\n  has_sort (osig (sig \\<Theta>)) (Tv idn S') S\n  list_all\n   (\\<lambda>a.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (idn, S) \\<Rightarrow>\n            \\<lambda>T. has_sort (osig (sig \\<Theta>)) T S)\n          b)\n   insts\n  ?x \\<in> set ?xs \\<Longrightarrow> \\<exists>ys zs. ?xs = ys @ ?x # zs\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) res S'", "by fastforce"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) res S'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S')) insts = Some a \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "moreover"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) res S'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S')) insts = Some a \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "have 1: \"sort_leq (subclass (osig (sig \\<Theta>))) S' S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sort_leq (subclass (osig (sig \\<Theta>))) S' S", "using Tv.prems(2) has_sort_Tv_imp_sort_leq"], ["proof (prove)\nusing this:\n  has_sort (osig (sig \\<Theta>)) (Tv idn S') S\n  has_sort ?oss (Tv ?idn ?S) ?S' \\<Longrightarrow>\n  sort_leq (subclass ?oss) ?S ?S'\n\ngoal (1 subgoal):\n 1. sort_leq (subclass (osig (sig \\<Theta>))) S' S", "by blast"], ["proof (state)\nthis:\n  sort_leq (subclass (osig (sig \\<Theta>))) S' S\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       lookup (\\<lambda>x. x = (idn, S')) insts = Some a \\<Longrightarrow>\n       has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "ultimately"], ["proof (chain)\npicking this:\n  has_sort (osig (sig \\<Theta>)) res S'\n  sort_leq (subclass (osig (sig \\<Theta>))) S' S", "show ?thesis"], ["proof (prove)\nusing this:\n  has_sort (osig (sig \\<Theta>)) res S'\n  sort_leq (subclass (osig (sig \\<Theta>))) S' S\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "using Some Tv(2) has_sort_Tv_imp_sort_leq"], ["proof (prove)\nusing this:\n  has_sort (osig (sig \\<Theta>)) res S'\n  sort_leq (subclass (osig (sig \\<Theta>))) S' S\n  lookup (\\<lambda>x. x = (idn, S')) insts = Some res\n  has_sort (osig (sig \\<Theta>)) (Tv idn S') S\n  has_sort ?oss (Tv ?idn ?S) ?S' \\<Longrightarrow>\n  sort_leq (subclass ?oss) ?S ?S'\n\ngoal (1 subgoal):\n 1. has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>has_sort (osig (sig \\<Theta>)) res S';\n     lookup (\\<lambda>x. x = (idn, S')) insts = Some res;\n     has_sort (osig (sig \\<Theta>)) (Tv idn S') S;\n     \\<And>oss idn S S'.\n        has_sort oss (Tv idn S) S' \\<Longrightarrow>\n        sort_leq (subclass oss) S S'\\<rbrakk>\n    \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) res S", "using assms(1) 1 has_sort_sort_leq"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  sort_leq (subclass (osig (sig \\<Theta>))) S' S\n  \\<lbrakk>wf_theory ?\\<Theta>; has_sort (osig (sig ?\\<Theta>)) ?T ?S;\n   sort_leq (subclass (osig (sig ?\\<Theta>))) ?S ?S'\\<rbrakk>\n  \\<Longrightarrow> has_sort (osig (sig ?\\<Theta>)) ?T ?S'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>has_sort (osig (sig \\<Theta>)) res S';\n     lookup (\\<lambda>x. x = (idn, S')) insts = Some res;\n     has_sort (osig (sig \\<Theta>)) (Tv idn S') S;\n     \\<And>oss idn S S'.\n        has_sort oss (Tv idn S) S' \\<Longrightarrow>\n        sort_leq (subclass oss) S S'\\<rbrakk>\n    \\<Longrightarrow> has_sort (osig (sig \\<Theta>)) res S", "by blast"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_sort (osig (sig \\<Theta>)) (subst_typ insts (Tv idn S')) S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_typ_preserves_Some_typ_of1:\n  assumes \"typ_of1 Ts t = Some T\"\n  shows \"typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) \n      = Some (subst_typ insts T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n    Some (subst_typ insts T)", "using assms"], ["proof (prove)\nusing this:\n  typ_of1 Ts t = Some T\n\ngoal (1 subgoal):\n 1. typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n    Some (subst_typ insts T)", "proof (induction t arbitrary: T Ts)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Ct x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Ct x1 x2)) =\n       Some (subst_typ insts T)\n 2. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Fv x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Fv x1 x2)) =\n       Some (subst_typ insts T)\n 3. \\<And>x T Ts.\n       typ_of1 Ts (Bv x) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Bv x)) =\n       Some (subst_typ insts T)\n 4. \\<And>x1 t T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n                   Some (subst_typ insts T);\n        typ_of1 Ts (Abs x1 t) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (Abs x1 t)) =\n                         Some (subst_typ insts T)\n 5. \\<And>t1 t2 T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t1 = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts)\n                    (subst_typ' insts t1) =\n                   Some (subst_typ insts T);\n        \\<And>T Ts.\n           typ_of1 Ts t2 = Some T \\<Longrightarrow>\n           typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n           Some (subst_typ insts T);\n        typ_of1 Ts (t1 $ t2) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (t1 $ t2)) =\n                         Some (subst_typ insts T)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Ct x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Ct x1 x2)) =\n       Some (subst_typ insts T)\n 2. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Fv x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Fv x1 x2)) =\n       Some (subst_typ insts T)\n 3. \\<And>x T Ts.\n       typ_of1 Ts (Bv x) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Bv x)) =\n       Some (subst_typ insts T)\n 4. \\<And>x1 t T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n                   Some (subst_typ insts T);\n        typ_of1 Ts (Abs x1 t) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (Abs x1 t)) =\n                         Some (subst_typ insts T)\n 5. \\<And>t1 t2 T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t1 = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts)\n                    (subst_typ' insts t1) =\n                   Some (subst_typ insts T);\n        \\<And>T Ts.\n           typ_of1 Ts t2 = Some T \\<Longrightarrow>\n           typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n           Some (subst_typ insts T);\n        typ_of1 Ts (t1 $ t2) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (t1 $ t2)) =\n                         Some (subst_typ insts T)", "case (App t1 t2)"], ["proof (state)\nthis:\n  typ_of1 ?Ts t1 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts ?T)\n  typ_of1 ?Ts t2 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t2) =\n  Some (subst_typ insts ?T)\n  typ_of1 Ts (t1 $ t2) = Some T\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Ct x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Ct x1 x2)) =\n       Some (subst_typ insts T)\n 2. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Fv x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Fv x1 x2)) =\n       Some (subst_typ insts T)\n 3. \\<And>x T Ts.\n       typ_of1 Ts (Bv x) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Bv x)) =\n       Some (subst_typ insts T)\n 4. \\<And>x1 t T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n                   Some (subst_typ insts T);\n        typ_of1 Ts (Abs x1 t) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (Abs x1 t)) =\n                         Some (subst_typ insts T)\n 5. \\<And>t1 t2 T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t1 = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts)\n                    (subst_typ' insts t1) =\n                   Some (subst_typ insts T);\n        \\<And>T Ts.\n           typ_of1 Ts t2 = Some T \\<Longrightarrow>\n           typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n           Some (subst_typ insts T);\n        typ_of1 Ts (t1 $ t2) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (t1 $ t2)) =\n                         Some (subst_typ insts T)", "from this"], ["proof (chain)\npicking this:\n  typ_of1 ?Ts t1 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts ?T)\n  typ_of1 ?Ts t2 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t2) =\n  Some (subst_typ insts ?T)\n  typ_of1 Ts (t1 $ t2) = Some T", "obtain RT where \"typ_of1 Ts t1 = Some (RT \\<rightarrow> T)\""], ["proof (prove)\nusing this:\n  typ_of1 ?Ts t1 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts ?T)\n  typ_of1 ?Ts t2 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t2) =\n  Some (subst_typ insts ?T)\n  typ_of1 Ts (t1 $ t2) = Some T\n\ngoal (1 subgoal):\n 1. (\\<And>RT.\n        typ_of1 Ts t1 = Some (RT \\<rightarrow> T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using typ_of1_split_App_obtains"], ["proof (prove)\nusing this:\n  typ_of1 ?Ts t1 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts ?T)\n  typ_of1 ?Ts t2 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t2) =\n  Some (subst_typ insts ?T)\n  typ_of1 Ts (t1 $ t2) = Some T\n  \\<lbrakk>typ_of1 ?Ts (?t $ ?u) = Some ?ty;\n   \\<And>uty.\n      \\<lbrakk>typ_of1 ?Ts ?t = Some (uty \\<rightarrow> ?ty);\n       typ_of1 ?Ts ?u = Some uty\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>RT.\n        typ_of1 Ts t1 = Some (RT \\<rightarrow> T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  typ_of1 Ts t1 = Some (RT \\<rightarrow> T)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Ct x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Ct x1 x2)) =\n       Some (subst_typ insts T)\n 2. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Fv x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Fv x1 x2)) =\n       Some (subst_typ insts T)\n 3. \\<And>x T Ts.\n       typ_of1 Ts (Bv x) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Bv x)) =\n       Some (subst_typ insts T)\n 4. \\<And>x1 t T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n                   Some (subst_typ insts T);\n        typ_of1 Ts (Abs x1 t) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (Abs x1 t)) =\n                         Some (subst_typ insts T)\n 5. \\<And>t1 t2 T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t1 = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts)\n                    (subst_typ' insts t1) =\n                   Some (subst_typ insts T);\n        \\<And>T Ts.\n           typ_of1 Ts t2 = Some T \\<Longrightarrow>\n           typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n           Some (subst_typ insts T);\n        typ_of1 Ts (t1 $ t2) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (t1 $ t2)) =\n                         Some (subst_typ insts T)", "hence \"typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t1) =\n    Some (subst_typ insts (RT \\<rightarrow> T))\""], ["proof (prove)\nusing this:\n  typ_of1 Ts t1 = Some (RT \\<rightarrow> T)\n\ngoal (1 subgoal):\n 1. typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t1) =\n    Some (subst_typ insts (RT \\<rightarrow> T))", "using App.IH(1)"], ["proof (prove)\nusing this:\n  typ_of1 Ts t1 = Some (RT \\<rightarrow> T)\n  typ_of1 ?Ts t1 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts ?T)\n\ngoal (1 subgoal):\n 1. typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t1) =\n    Some (subst_typ insts (RT \\<rightarrow> T))", "by blast"], ["proof (state)\nthis:\n  typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts (RT \\<rightarrow> T))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Ct x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Ct x1 x2)) =\n       Some (subst_typ insts T)\n 2. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Fv x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Fv x1 x2)) =\n       Some (subst_typ insts T)\n 3. \\<And>x T Ts.\n       typ_of1 Ts (Bv x) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Bv x)) =\n       Some (subst_typ insts T)\n 4. \\<And>x1 t T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n                   Some (subst_typ insts T);\n        typ_of1 Ts (Abs x1 t) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (Abs x1 t)) =\n                         Some (subst_typ insts T)\n 5. \\<And>t1 t2 T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t1 = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts)\n                    (subst_typ' insts t1) =\n                   Some (subst_typ insts T);\n        \\<And>T Ts.\n           typ_of1 Ts t2 = Some T \\<Longrightarrow>\n           typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n           Some (subst_typ insts T);\n        typ_of1 Ts (t1 $ t2) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (t1 $ t2)) =\n                         Some (subst_typ insts T)", "moreover"], ["proof (state)\nthis:\n  typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts (RT \\<rightarrow> T))\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Ct x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Ct x1 x2)) =\n       Some (subst_typ insts T)\n 2. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Fv x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Fv x1 x2)) =\n       Some (subst_typ insts T)\n 3. \\<And>x T Ts.\n       typ_of1 Ts (Bv x) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Bv x)) =\n       Some (subst_typ insts T)\n 4. \\<And>x1 t T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n                   Some (subst_typ insts T);\n        typ_of1 Ts (Abs x1 t) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (Abs x1 t)) =\n                         Some (subst_typ insts T)\n 5. \\<And>t1 t2 T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t1 = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts)\n                    (subst_typ' insts t1) =\n                   Some (subst_typ insts T);\n        \\<And>T Ts.\n           typ_of1 Ts t2 = Some T \\<Longrightarrow>\n           typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n           Some (subst_typ insts T);\n        typ_of1 Ts (t1 $ t2) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (t1 $ t2)) =\n                         Some (subst_typ insts T)", "have \"typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) = Some (subst_typ insts RT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n    Some (subst_typ insts RT)", "using App \\<open>typ_of1 Ts t1 = Some (RT \\<rightarrow> T)\\<close> typ_of1_fun_typ"], ["proof (prove)\nusing this:\n  typ_of1 ?Ts t1 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts ?T)\n  typ_of1 ?Ts t2 = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ insts) ?Ts) (subst_typ' insts t2) =\n  Some (subst_typ insts ?T)\n  typ_of1 Ts (t1 $ t2) = Some T\n  typ_of1 Ts t1 = Some (RT \\<rightarrow> T)\n  \\<lbrakk>typ_of1 ?Ts (?t $ ?u) = Some ?R;\n   typ_of1 ?Ts ?t = Some (?U \\<rightarrow> ?R)\\<rbrakk>\n  \\<Longrightarrow> typ_of1 ?Ts ?u = Some ?U\n\ngoal (1 subgoal):\n 1. typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n    Some (subst_typ insts RT)", "by blast"], ["proof (state)\nthis:\n  typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n  Some (subst_typ insts RT)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Ct x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Ct x1 x2)) =\n       Some (subst_typ insts T)\n 2. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Fv x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Fv x1 x2)) =\n       Some (subst_typ insts T)\n 3. \\<And>x T Ts.\n       typ_of1 Ts (Bv x) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Bv x)) =\n       Some (subst_typ insts T)\n 4. \\<And>x1 t T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n                   Some (subst_typ insts T);\n        typ_of1 Ts (Abs x1 t) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (Abs x1 t)) =\n                         Some (subst_typ insts T)\n 5. \\<And>t1 t2 T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t1 = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts)\n                    (subst_typ' insts t1) =\n                   Some (subst_typ insts T);\n        \\<And>T Ts.\n           typ_of1 Ts t2 = Some T \\<Longrightarrow>\n           typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n           Some (subst_typ insts T);\n        typ_of1 Ts (t1 $ t2) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (t1 $ t2)) =\n                         Some (subst_typ insts T)", "ultimately"], ["proof (chain)\npicking this:\n  typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts (RT \\<rightarrow> T))\n  typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n  Some (subst_typ insts RT)", "show ?case"], ["proof (prove)\nusing this:\n  typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t1) =\n  Some (subst_typ insts (RT \\<rightarrow> T))\n  typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t2) =\n  Some (subst_typ insts RT)\n\ngoal (1 subgoal):\n 1. typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (t1 $ t2)) =\n    Some (subst_typ insts T)", "by simp"], ["proof (state)\nthis:\n  typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (t1 $ t2)) =\n  Some (subst_typ insts T)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Ct x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Ct x1 x2)) =\n       Some (subst_typ insts T)\n 2. \\<And>x1 x2 T Ts.\n       typ_of1 Ts (Fv x1 x2) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Fv x1 x2)) =\n       Some (subst_typ insts T)\n 3. \\<And>x T Ts.\n       typ_of1 Ts (Bv x) = Some T \\<Longrightarrow>\n       typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts (Bv x)) =\n       Some (subst_typ insts T)\n 4. \\<And>x1 t T Ts.\n       \\<lbrakk>\\<And>T Ts.\n                   typ_of1 Ts t = Some T \\<Longrightarrow>\n                   typ_of1 (map (subst_typ insts) Ts) (subst_typ' insts t) =\n                   Some (subst_typ insts T);\n        typ_of1 Ts (Abs x1 t) = Some T\\<rbrakk>\n       \\<Longrightarrow> typ_of1 (map (subst_typ insts) Ts)\n                          (subst_typ' insts (Abs x1 t)) =\n                         Some (subst_typ insts T)", "qed (fastforce split: if_splits simp add: bind_eq_Some_conv)+"], ["", "corollary subst_typ_preserves_Some_typ_of:\n  assumes \"typ_of t = Some T\"\n  shows \"typ_of (subst_typ' insts t) \n      = Some (subst_typ insts T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typ_of (subst_typ' insts t) = Some (subst_typ insts T)", "using assms subst_typ_preserves_Some_typ_of1 typ_of_def"], ["proof (prove)\nusing this:\n  typ_of t = Some T\n  typ_of1 ?Ts ?t = Some ?T \\<Longrightarrow>\n  typ_of1 (map (subst_typ ?insts) ?Ts) (subst_typ' ?insts ?t) =\n  Some (subst_typ ?insts ?T)\n  typ_of ?t \\<equiv> typ_of1 [] ?t\n\ngoal (1 subgoal):\n 1. typ_of (subst_typ' insts t) = Some (subst_typ insts T)", "by fastforce"], ["", "lemma subst_typ'_incr_bv: \n  \"subst_typ' insts (incr_bv inc lev t) = incr_bv inc lev (subst_typ' insts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' insts (incr_bv inc lev t) =\n    incr_bv inc lev (subst_typ' insts t)", "by (induction inc lev t rule: incr_bv.induct) auto"], ["", "lemma subst_typ'_incr_boundvars:\n  \"subst_typ' insts (incr_boundvars lev t) = incr_boundvars lev (subst_typ' insts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' insts (incr_boundvars lev t) =\n    incr_boundvars lev (subst_typ' insts t)", "using subst_typ'_incr_bv incr_boundvars_def"], ["proof (prove)\nusing this:\n  subst_typ' ?insts (incr_bv ?inc ?lev ?t) =\n  incr_bv ?inc ?lev (subst_typ' ?insts ?t)\n  incr_boundvars ?inc ?t = incr_bv ?inc 0 ?t\n\ngoal (1 subgoal):\n 1. subst_typ' insts (incr_boundvars lev t) =\n    incr_boundvars lev (subst_typ' insts t)", "by simp"], ["", "lemma subst_typ'_subst_bv1: \"subst_typ' insts (subst_bv1 t n u) \n  = subst_bv1 (subst_typ' insts t) n (subst_typ' insts u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' insts (subst_bv1 t n u) =\n    subst_bv1 (subst_typ' insts t) n (subst_typ' insts u)", "by (induction t n u rule: subst_bv1.induct) (auto simp add: subst_typ'_incr_boundvars)"], ["", "lemma subst_typ'_subst_bv: \"subst_typ' insts (subst_bv t u) \n  = subst_bv (subst_typ' insts t) (subst_typ' insts u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' insts (subst_bv t u) =\n    subst_bv (subst_typ' insts t) (subst_typ' insts u)", "using subst_typ'_subst_bv1 subst_bv_def"], ["proof (prove)\nusing this:\n  subst_typ' ?insts (subst_bv1 ?t ?n ?u) =\n  subst_bv1 (subst_typ' ?insts ?t) ?n (subst_typ' ?insts ?u)\n  subst_bv ?u ?t \\<equiv> subst_bv1 ?t 0 ?u\n\ngoal (1 subgoal):\n 1. subst_typ' insts (subst_bv t u) =\n    subst_bv (subst_typ' insts t) (subst_typ' insts u)", "by simp"], ["", "lemma subst_typ_no_tvsT_unchanged:\n  \"\\<forall>(f, s) \\<in> set insts . f \\<notin> tvsT T \\<Longrightarrow> subst_typ insts T = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(f, s)\\<in>set insts. f \\<notin> tvsT T \\<Longrightarrow>\n    subst_typ insts T = T", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    \\<forall>(f, s)\\<in>set insts.\n                       f \\<notin> tvsT x2a\\<rbrakk>\n                   \\<Longrightarrow> subst_typ insts x2a = x2a;\n        \\<forall>(f, s)\\<in>set insts. f \\<notin> tvsT (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Ty x1 x2) = Ty x1 x2\n 2. \\<And>x1 x2.\n       \\<forall>(f, s)\\<in>set insts.\n          f \\<notin> tvsT (Tv x1 x2) \\<Longrightarrow>\n       subst_typ insts (Tv x1 x2) = Tv x1 x2", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   \\<forall>a\\<in>set insts.\n      case a of (f, s) \\<Rightarrow> f \\<notin> tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> subst_typ insts ?x2a = ?x2a\n  \\<forall>a\\<in>set insts.\n     case a of (f, s) \\<Rightarrow> f \\<notin> tvsT (Ty n Ts)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    \\<forall>(f, s)\\<in>set insts.\n                       f \\<notin> tvsT x2a\\<rbrakk>\n                   \\<Longrightarrow> subst_typ insts x2a = x2a;\n        \\<forall>(f, s)\\<in>set insts. f \\<notin> tvsT (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> subst_typ insts (Ty x1 x2) = Ty x1 x2\n 2. \\<And>x1 x2.\n       \\<forall>(f, s)\\<in>set insts.\n          f \\<notin> tvsT (Tv x1 x2) \\<Longrightarrow>\n       subst_typ insts (Tv x1 x2) = Tv x1 x2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   \\<forall>a\\<in>set insts.\n      case a of (f, s) \\<Rightarrow> f \\<notin> tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> subst_typ insts ?x2a = ?x2a\n  \\<forall>a\\<in>set insts.\n     case a of (f, s) \\<Rightarrow> f \\<notin> tvsT (Ty n Ts)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   \\<forall>a\\<in>set insts.\n      case a of (f, s) \\<Rightarrow> f \\<notin> tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> subst_typ insts ?x2a = ?x2a\n  \\<forall>a\\<in>set insts.\n     case a of (f, s) \\<Rightarrow> f \\<notin> tvsT (Ty n Ts)\n\ngoal (1 subgoal):\n 1. subst_typ insts (Ty n Ts) = Ty n Ts", "by (induction Ts) (fastforce split: prod.splits)+"], ["proof (state)\nthis:\n  subst_typ insts (Ty n Ts) = Ty n Ts\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<forall>(f, s)\\<in>set insts.\n          f \\<notin> tvsT (Tv x1 x2) \\<Longrightarrow>\n       subst_typ insts (Tv x1 x2) = Tv x1 x2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<forall>(f, s)\\<in>set insts.\n          f \\<notin> tvsT (Tv x1 x2) \\<Longrightarrow>\n       subst_typ insts (Tv x1 x2) = Tv x1 x2", "case (Tv idn S)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set insts.\n     case a of (f, s) \\<Rightarrow> f \\<notin> tvsT (Tv idn S)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<forall>(f, s)\\<in>set insts.\n          f \\<notin> tvsT (Tv x1 x2) \\<Longrightarrow>\n       subst_typ insts (Tv x1 x2) = Tv x1 x2", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set insts.\n     case a of (f, s) \\<Rightarrow> f \\<notin> tvsT (Tv idn S)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set insts.\n     case a of (f, s) \\<Rightarrow> f \\<notin> tvsT (Tv idn S)\n\ngoal (1 subgoal):\n 1. subst_typ insts (Tv idn S) = Tv idn S", "by simp (smt case_prodD case_prodE find_None_iff lookup_None_iff_find_None the_default.simps(1))"], ["proof (state)\nthis:\n  subst_typ insts (Tv idn S) = Tv idn S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_typ'_no_tvs_unchanged:\n  \"\\<forall>(f, s) \\<in> set insts . f \\<notin> tvs t \\<Longrightarrow> subst_typ' insts t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(f, s)\\<in>set insts. f \\<notin> tvs t \\<Longrightarrow>\n    subst_typ' insts t = t", "by (induction t) (use subst_typ_no_tvsT_unchanged in \\<open>fastforce+\\<close>)"], ["", "(* This is weaker than the previously proved version, but probably easier to use... *)"], ["", "lemma subst_typ'_preserves_term_ok':\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"inst_ok \\<Theta> insts\"\n  assumes \"term_ok' (sig \\<Theta>) t\"\n  shows \"term_ok' (sig \\<Theta>) (subst_typ' insts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (subst_typ' insts t)", "using assms term_ok'_subst_typ' typ_ok_def"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  inst_ok \\<Theta> insts\n  term_ok' (sig \\<Theta>) t\n  \\<lbrakk>is_std_sig ?\\<Sigma>; term_ok' ?\\<Sigma> ?t;\n   distinct (map fst ?insts);\n   list_all (typ_ok_sig ?\\<Sigma>) (map snd ?insts)\\<rbrakk>\n  \\<Longrightarrow> term_ok' ?\\<Sigma> (subst_typ' ?insts ?t)\n  typ_ok ?\\<Theta> ?T \\<equiv> wf_type (sig ?\\<Theta>) ?T\n\ngoal (1 subgoal):\n 1. term_ok' (sig \\<Theta>) (subst_typ' insts t)", "by (metis list.pred_mono_strong wf_theory_imp_is_std_sig wf_type_imp_typ_ok_sig)"], ["", "lemma subst_typ'_preserves_term_ok:\n  assumes \"wf_theory \\<Theta>\"\n  assumes \"inst_ok \\<Theta> insts\"\n  assumes \"term_ok \\<Theta> t\"\n  shows \"term_ok \\<Theta> (subst_typ' insts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (subst_typ' insts t)", "using assms subst_typ_preserves_Some_typ_of wt_term_def subst_typ'_preserves_term_ok'"], ["proof (prove)\nusing this:\n  wf_theory \\<Theta>\n  inst_ok \\<Theta> insts\n  term_ok \\<Theta> t\n  typ_of ?t = Some ?T \\<Longrightarrow>\n  typ_of (subst_typ' ?insts ?t) = Some (subst_typ ?insts ?T)\n  wt_term ?\\<Sigma> ?t \\<equiv>\n  wf_term ?\\<Sigma> ?t \\<and> (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> ?t : T)\n  \\<lbrakk>wf_theory ?\\<Theta>; inst_ok ?\\<Theta> ?insts;\n   term_ok' (sig ?\\<Theta>) ?t\\<rbrakk>\n  \\<Longrightarrow> term_ok' (sig ?\\<Theta>) (subst_typ' ?insts ?t)\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (subst_typ' insts t)", "by auto"], ["", "lemma subst_typ_rename_vars_cancel:\n  assumes \"y \\<notin> fst ` tvsT T\" \n  shows \"subst_typ [((y,S), Tv x S)] (subst_typ [((x,S), Tv y S)] T) = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ [((y, S), Tv x S)] (subst_typ [((x, S), Tv y S)] T) = T", "using assms"], ["proof (prove)\nusing this:\n  y \\<notin> fst ` tvsT T\n\ngoal (1 subgoal):\n 1. subst_typ [((y, S), Tv x S)] (subst_typ [((x, S), Tv y S)] T) = T", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    y \\<notin> fst ` tvsT x2a\\<rbrakk>\n                   \\<Longrightarrow> subst_typ [((y, S), Tv x S)]\n(subst_typ [((x, S), Tv y S)] x2a) =\n                                     x2a;\n        y \\<notin> fst ` tvsT (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> subst_typ [((y, S), Tv x S)]\n                          (subst_typ [((x, S), Tv y S)] (Ty x1 x2)) =\n                         Ty x1 x2\n 2. \\<And>x1 x2.\n       y \\<notin> fst ` tvsT (Tv x1 x2) \\<Longrightarrow>\n       subst_typ [((y, S), Tv x S)]\n        (subst_typ [((x, S), Tv y S)] (Tv x1 x2)) =\n       Tv x1 x2", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; y \\<notin> fst ` tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> subst_typ [((y, S), Tv x S)]\n                     (subst_typ [((x, S), Tv y S)] ?x2a) =\n                    ?x2a\n  y \\<notin> fst ` tvsT (Ty n Ts)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    y \\<notin> fst ` tvsT x2a\\<rbrakk>\n                   \\<Longrightarrow> subst_typ [((y, S), Tv x S)]\n(subst_typ [((x, S), Tv y S)] x2a) =\n                                     x2a;\n        y \\<notin> fst ` tvsT (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> subst_typ [((y, S), Tv x S)]\n                          (subst_typ [((x, S), Tv y S)] (Ty x1 x2)) =\n                         Ty x1 x2\n 2. \\<And>x1 x2.\n       y \\<notin> fst ` tvsT (Tv x1 x2) \\<Longrightarrow>\n       subst_typ [((y, S), Tv x S)]\n        (subst_typ [((x, S), Tv y S)] (Tv x1 x2)) =\n       Tv x1 x2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts; y \\<notin> fst ` tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> subst_typ [((y, S), Tv x S)]\n                     (subst_typ [((x, S), Tv y S)] ?x2a) =\n                    ?x2a\n  y \\<notin> fst ` tvsT (Ty n Ts)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts; y \\<notin> fst ` tvsT ?x2a\\<rbrakk>\n  \\<Longrightarrow> subst_typ [((y, S), Tv x S)]\n                     (subst_typ [((x, S), Tv y S)] ?x2a) =\n                    ?x2a\n  y \\<notin> fst ` tvsT (Ty n Ts)\n\ngoal (1 subgoal):\n 1. subst_typ [((y, S), Tv x S)] (subst_typ [((x, S), Tv y S)] (Ty n Ts)) =\n    Ty n Ts", "by (induction Ts) auto"], ["proof (state)\nthis:\n  subst_typ [((y, S), Tv x S)] (subst_typ [((x, S), Tv y S)] (Ty n Ts)) =\n  Ty n Ts\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       y \\<notin> fst ` tvsT (Tv x1 x2) \\<Longrightarrow>\n       subst_typ [((y, S), Tv x S)]\n        (subst_typ [((x, S), Tv y S)] (Tv x1 x2)) =\n       Tv x1 x2", "qed auto"], ["", "lemma subst_typ'_rename_tvars_cancel:\n  assumes \"y \\<notin> fst ` tvs t\" assumes \"y \\<notin> fst ` tvsT \\<tau>\" \n  shows \"subst_typ' [((y,S), Tv x S)] ((bind_fv2 (x, subst_typ [((x,S), Tv y S)] \\<tau>)) \n    lev (subst_typ' [((x,S), Tv y S)] t))\n  = bind_fv2 (x, \\<tau>) lev t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' [((y, S), Tv x S)]\n     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n       (subst_typ' [((x, S), Tv y S)] t)) =\n    bind_fv2 (x, \\<tau>) lev t", "using assms"], ["proof (prove)\nusing this:\n  y \\<notin> fst ` tvs t\n  y \\<notin> fst ` tvsT \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ' [((y, S), Tv x S)]\n     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n       (subst_typ' [((x, S), Tv y S)] t)) =\n    bind_fv2 (x, \\<tau>) lev t", "proof (induction t arbitrary: lev)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Ct x1 x2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Ct x1 x2))) =\n                         bind_fv2 (x, \\<tau>) lev (Ct x1 x2)\n 2. \\<And>x1 x2 lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Fv x1 x2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Fv x1 x2))) =\n                         bind_fv2 (x, \\<tau>) lev (Fv x1 x2)\n 3. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 4. \\<And>x1 t lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t)) =\n                                     bind_fv2 (x, \\<tau>) lev t;\n        y \\<notin> fst ` tvs (Abs x1 t);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Abs x1 t))) =\n                         bind_fv2 (x, \\<tau>) lev (Abs x1 t)\n 5. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "case (Ct n T)"], ["proof (state)\nthis:\n  y \\<notin> fst ` tvs (Ct n T)\n  y \\<notin> fst ` tvsT \\<tau>\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Ct x1 x2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Ct x1 x2))) =\n                         bind_fv2 (x, \\<tau>) lev (Ct x1 x2)\n 2. \\<And>x1 x2 lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Fv x1 x2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Fv x1 x2))) =\n                         bind_fv2 (x, \\<tau>) lev (Fv x1 x2)\n 3. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 4. \\<And>x1 t lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t)) =\n                                     bind_fv2 (x, \\<tau>) lev t;\n        y \\<notin> fst ` tvs (Abs x1 t);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Abs x1 t))) =\n                         bind_fv2 (x, \\<tau>) lev (Abs x1 t)\n 5. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "then"], ["proof (chain)\npicking this:\n  y \\<notin> fst ` tvs (Ct n T)\n  y \\<notin> fst ` tvsT \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  y \\<notin> fst ` tvs (Ct n T)\n  y \\<notin> fst ` tvsT \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ' [((y, S), Tv x S)]\n     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n       (subst_typ' [((x, S), Tv y S)] (Ct n T))) =\n    bind_fv2 (x, \\<tau>) lev (Ct n T)", "by (simp add: subst_typ_rename_vars_cancel)"], ["proof (state)\nthis:\n  subst_typ' [((y, S), Tv x S)]\n   (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n     (subst_typ' [((x, S), Tv y S)] (Ct n T))) =\n  bind_fv2 (x, \\<tau>) lev (Ct n T)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Fv x1 x2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Fv x1 x2))) =\n                         bind_fv2 (x, \\<tau>) lev (Fv x1 x2)\n 2. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 3. \\<And>x1 t lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t)) =\n                                     bind_fv2 (x, \\<tau>) lev t;\n        y \\<notin> fst ` tvs (Abs x1 t);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Abs x1 t))) =\n                         bind_fv2 (x, \\<tau>) lev (Abs x1 t)\n 4. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Fv x1 x2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Fv x1 x2))) =\n                         bind_fv2 (x, \\<tau>) lev (Fv x1 x2)\n 2. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 3. \\<And>x1 t lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t)) =\n                                     bind_fv2 (x, \\<tau>) lev t;\n        y \\<notin> fst ` tvs (Abs x1 t);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Abs x1 t))) =\n                         bind_fv2 (x, \\<tau>) lev (Abs x1 t)\n 4. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "case (Fv idn T)"], ["proof (state)\nthis:\n  y \\<notin> fst ` tvs (Fv idn T)\n  y \\<notin> fst ` tvsT \\<tau>\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Fv x1 x2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Fv x1 x2))) =\n                         bind_fv2 (x, \\<tau>) lev (Fv x1 x2)\n 2. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 3. \\<And>x1 t lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t)) =\n                                     bind_fv2 (x, \\<tau>) lev t;\n        y \\<notin> fst ` tvs (Abs x1 t);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Abs x1 t))) =\n                         bind_fv2 (x, \\<tau>) lev (Abs x1 t)\n 4. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "then"], ["proof (chain)\npicking this:\n  y \\<notin> fst ` tvs (Fv idn T)\n  y \\<notin> fst ` tvsT \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  y \\<notin> fst ` tvs (Fv idn T)\n  y \\<notin> fst ` tvsT \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ' [((y, S), Tv x S)]\n     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n       (subst_typ' [((x, S), Tv y S)] (Fv idn T))) =\n    bind_fv2 (x, \\<tau>) lev (Fv idn T)", "by (clarsimp simp add: subst_typ_rename_vars_cancel) (metis subst_typ_rename_vars_cancel)"], ["proof (state)\nthis:\n  subst_typ' [((y, S), Tv x S)]\n   (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n     (subst_typ' [((x, S), Tv y S)] (Fv idn T))) =\n  bind_fv2 (x, \\<tau>) lev (Fv idn T)\n\ngoal (3 subgoals):\n 1. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 2. \\<And>x1 t lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t)) =\n                                     bind_fv2 (x, \\<tau>) lev t;\n        y \\<notin> fst ` tvs (Abs x1 t);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Abs x1 t))) =\n                         bind_fv2 (x, \\<tau>) lev (Abs x1 t)\n 3. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 2. \\<And>x1 t lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t)) =\n                                     bind_fv2 (x, \\<tau>) lev t;\n        y \\<notin> fst ` tvs (Abs x1 t);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Abs x1 t))) =\n                         bind_fv2 (x, \\<tau>) lev (Abs x1 t)\n 3. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "case (Abs T t)"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<notin> fst ` tvs t; y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n  \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) ?lev\n                       (subst_typ' [((x, S), Tv y S)] t)) =\n                    bind_fv2 (x, \\<tau>) ?lev t\n  y \\<notin> fst ` tvs (Abs T t)\n  y \\<notin> fst ` tvsT \\<tau>\n\ngoal (3 subgoals):\n 1. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 2. \\<And>x1 t lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t)) =\n                                     bind_fv2 (x, \\<tau>) lev t;\n        y \\<notin> fst ` tvs (Abs x1 t);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev\n                            (subst_typ' [((x, S), Tv y S)] (Abs x1 t))) =\n                         bind_fv2 (x, \\<tau>) lev (Abs x1 t)\n 3. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<notin> fst ` tvs t; y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n  \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) ?lev\n                       (subst_typ' [((x, S), Tv y S)] t)) =\n                    bind_fv2 (x, \\<tau>) ?lev t\n  y \\<notin> fst ` tvs (Abs T t)\n  y \\<notin> fst ` tvsT \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ' [((y, S), Tv x S)]\n     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n       (subst_typ' [((x, S), Tv y S)] (Abs T t))) =\n    bind_fv2 (x, \\<tau>) lev (Abs T t)", "by (simp add: image_Un subst_typ_rename_vars_cancel)"], ["proof (state)\nthis:\n  subst_typ' [((y, S), Tv x S)]\n   (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n     (subst_typ' [((x, S), Tv y S)] (Abs T t))) =\n  bind_fv2 (x, \\<tau>) lev (Abs T t)\n\ngoal (2 subgoals):\n 1. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 2. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 2. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "case (App t1 t2)"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<notin> fst ` tvs t1; y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n  \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) ?lev\n                       (subst_typ' [((x, S), Tv y S)] t1)) =\n                    bind_fv2 (x, \\<tau>) ?lev t1\n  \\<lbrakk>y \\<notin> fst ` tvs t2; y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n  \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) ?lev\n                       (subst_typ' [((x, S), Tv y S)] t2)) =\n                    bind_fv2 (x, \\<tau>) ?lev t2\n  y \\<notin> fst ` tvs (t1 $ t2)\n  y \\<notin> fst ` tvsT \\<tau>\n\ngoal (2 subgoals):\n 1. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)\n 2. \\<And>t1 t2 lev.\n       \\<lbrakk>\\<And>lev.\n                   \\<lbrakk>y \\<notin> fst ` tvs t1;\n                    y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n(bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n  (subst_typ' [((x, S), Tv y S)] t1)) =\n                                     bind_fv2 (x, \\<tau>) lev t1;\n        \\<And>lev.\n           \\<lbrakk>y \\<notin> fst ` tvs t2;\n            y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                              (bind_fv2\n                                (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n                                (subst_typ' [((x, S), Tv y S)] t2)) =\n                             bind_fv2 (x, \\<tau>) lev t2;\n        y \\<notin> fst ` tvs (t1 $ t2);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n                         bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>y \\<notin> fst ` tvs t1; y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n  \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) ?lev\n                       (subst_typ' [((x, S), Tv y S)] t1)) =\n                    bind_fv2 (x, \\<tau>) ?lev t1\n  \\<lbrakk>y \\<notin> fst ` tvs t2; y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n  \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) ?lev\n                       (subst_typ' [((x, S), Tv y S)] t2)) =\n                    bind_fv2 (x, \\<tau>) ?lev t2\n  y \\<notin> fst ` tvs (t1 $ t2)\n  y \\<notin> fst ` tvsT \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<notin> fst ` tvs t1; y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n  \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) ?lev\n                       (subst_typ' [((x, S), Tv y S)] t1)) =\n                    bind_fv2 (x, \\<tau>) ?lev t1\n  \\<lbrakk>y \\<notin> fst ` tvs t2; y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n  \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) ?lev\n                       (subst_typ' [((x, S), Tv y S)] t2)) =\n                    bind_fv2 (x, \\<tau>) ?lev t2\n  y \\<notin> fst ` tvs (t1 $ t2)\n  y \\<notin> fst ` tvsT \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ' [((y, S), Tv x S)]\n     (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n       (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n    bind_fv2 (x, \\<tau>) lev (t1 $ t2)", "by (simp add: image_Un)"], ["proof (state)\nthis:\n  subst_typ' [((y, S), Tv x S)]\n   (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>) lev\n     (subst_typ' [((x, S), Tv y S)] (t1 $ t2))) =\n  bind_fv2 (x, \\<tau>) lev (t1 $ t2)\n\ngoal (1 subgoal):\n 1. \\<And>xa lev.\n       \\<lbrakk>y \\<notin> fst ` tvs (Bv xa);\n        y \\<notin> fst ` tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((y, S), Tv x S)]\n                          (bind_fv2 (x, subst_typ [((x, S), Tv y S)] \\<tau>)\n                            lev (subst_typ' [((x, S), Tv y S)] (Bv xa))) =\n                         bind_fv2 (x, \\<tau>) lev (Bv xa)", "qed auto"], ["", "lemma bind_fv2_renamed_var:\n  assumes \"y \\<notin> fst ` fv t\" \n  shows \"bind_fv2 (y, \\<tau>) i (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) \n    = bind_fv2 (x, \\<tau>) i t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_fv2 (y, \\<tau>) i (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) =\n    bind_fv2 (x, \\<tau>) i t", "using assms"], ["proof (prove)\nusing this:\n  y \\<notin> fst ` fv t\n\ngoal (1 subgoal):\n 1. bind_fv2 (y, \\<tau>) i (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) =\n    bind_fv2 (x, \\<tau>) i t", "proof (induction t arbitrary: i)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i.\n       y \\<notin> fst ` fv (Ct x1 x2) \\<Longrightarrow>\n       bind_fv2 (y, \\<tau>) i\n        (subst_term [((x, \\<tau>), Fv y \\<tau>)] (Ct x1 x2)) =\n       bind_fv2 (x, \\<tau>) i (Ct x1 x2)\n 2. \\<And>x1 x2 i.\n       y \\<notin> fst ` fv (Fv x1 x2) \\<Longrightarrow>\n       bind_fv2 (y, \\<tau>) i\n        (subst_term [((x, \\<tau>), Fv y \\<tau>)] (Fv x1 x2)) =\n       bind_fv2 (x, \\<tau>) i (Fv x1 x2)\n 3. \\<And>xa i.\n       y \\<notin> fst ` fv (Bv xa) \\<Longrightarrow>\n       bind_fv2 (y, \\<tau>) i\n        (subst_term [((x, \\<tau>), Fv y \\<tau>)] (Bv xa)) =\n       bind_fv2 (x, \\<tau>) i (Bv xa)\n 4. \\<And>x1 t i.\n       \\<lbrakk>\\<And>i.\n                   y \\<notin> fst ` fv t \\<Longrightarrow>\n                   bind_fv2 (y, \\<tau>) i\n                    (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) =\n                   bind_fv2 (x, \\<tau>) i t;\n        y \\<notin> fst ` fv (Abs x1 t)\\<rbrakk>\n       \\<Longrightarrow> bind_fv2 (y, \\<tau>) i\n                          (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                            (Abs x1 t)) =\n                         bind_fv2 (x, \\<tau>) i (Abs x1 t)\n 5. \\<And>t1 t2 i.\n       \\<lbrakk>\\<And>i.\n                   y \\<notin> fst ` fv t1 \\<Longrightarrow>\n                   bind_fv2 (y, \\<tau>) i\n                    (subst_term [((x, \\<tau>), Fv y \\<tau>)] t1) =\n                   bind_fv2 (x, \\<tau>) i t1;\n        \\<And>i.\n           y \\<notin> fst ` fv t2 \\<Longrightarrow>\n           bind_fv2 (y, \\<tau>) i\n            (subst_term [((x, \\<tau>), Fv y \\<tau>)] t2) =\n           bind_fv2 (x, \\<tau>) i t2;\n        y \\<notin> fst ` fv (t1 $ t2)\\<rbrakk>\n       \\<Longrightarrow> bind_fv2 (y, \\<tau>) i\n                          (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                            (t1 $ t2)) =\n                         bind_fv2 (x, \\<tau>) i (t1 $ t2)", "qed auto"], ["", "lemma bind_fv_renamed_var:\n  assumes \"y \\<notin> fst ` fv t\" \n  shows \"bind_fv (y, \\<tau>) (subst_term [((x, \\<tau>), Fv y \\<tau>)] t)\n    = bind_fv (x, \\<tau>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_fv (y, \\<tau>) (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) =\n    bind_fv (x, \\<tau>) t", "using bind_fv2_renamed_var bind_fv_def assms"], ["proof (prove)\nusing this:\n  ?y \\<notin> fst ` fv ?t \\<Longrightarrow>\n  bind_fv2 (?y, ?\\<tau>) ?i\n   (subst_term [((?x, ?\\<tau>), Fv ?y ?\\<tau>)] ?t) =\n  bind_fv2 (?x, ?\\<tau>) ?i ?t\n  bind_fv ?vT ?t = bind_fv2 ?vT 0 ?t\n  y \\<notin> fst ` fv t\n\ngoal (1 subgoal):\n 1. bind_fv (y, \\<tau>) (subst_term [((x, \\<tau>), Fv y \\<tau>)] t) =\n    bind_fv (x, \\<tau>) t", "by auto"], ["", "lemma subst_typ'_rename_tvar_bind_fv2:\n  assumes \"y \\<notin> fst ` fv t\" \n  assumes \"(b, S) \\<notin> tvs t\"\n  assumes \"(b, S) \\<notin> tvsT \\<tau>\"\n  shows \"bind_fv2 (y, subst_typ [((a, S), Tv b S)] \\<tau>) i \n  (subst_typ' [((a,S), Tv b S)] (subst_term [((x, \\<tau>), Fv y \\<tau>)] t))\n    = subst_typ' [((a,S), Tv b S)] (bind_fv2 (x, \\<tau>) i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_fv2 (y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n     (subst_typ' [((a, S), Tv b S)]\n       (subst_term [((x, \\<tau>), Fv y \\<tau>)] t)) =\n    subst_typ' [((a, S), Tv b S)] (bind_fv2 (x, \\<tau>) i t)", "using assms"], ["proof (prove)\nusing this:\n  y \\<notin> fst ` fv t\n  (b, S) \\<notin> tvs t\n  (b, S) \\<notin> tvsT \\<tau>\n\ngoal (1 subgoal):\n 1. bind_fv2 (y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n     (subst_typ' [((a, S), Tv b S)]\n       (subst_term [((x, \\<tau>), Fv y \\<tau>)] t)) =\n    subst_typ' [((a, S), Tv b S)] (bind_fv2 (x, \\<tau>) i t)", "proof (induction t arbitrary: i)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2 i.\n       \\<lbrakk>y \\<notin> fst ` fv (Ct x1 x2);\n        (b, S) \\<notin> tvs (Ct x1 x2); (b, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> bind_fv2 (y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n                          (subst_typ' [((a, S), Tv b S)]\n                            (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                              (Ct x1 x2))) =\n                         subst_typ' [((a, S), Tv b S)]\n                          (bind_fv2 (x, \\<tau>) i (Ct x1 x2))\n 2. \\<And>x1 x2 i.\n       \\<lbrakk>y \\<notin> fst ` fv (Fv x1 x2);\n        (b, S) \\<notin> tvs (Fv x1 x2); (b, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> bind_fv2 (y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n                          (subst_typ' [((a, S), Tv b S)]\n                            (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                              (Fv x1 x2))) =\n                         subst_typ' [((a, S), Tv b S)]\n                          (bind_fv2 (x, \\<tau>) i (Fv x1 x2))\n 3. \\<And>xa i.\n       \\<lbrakk>y \\<notin> fst ` fv (Bv xa); (b, S) \\<notin> tvs (Bv xa);\n        (b, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> bind_fv2 (y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n                          (subst_typ' [((a, S), Tv b S)]\n                            (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                              (Bv xa))) =\n                         subst_typ' [((a, S), Tv b S)]\n                          (bind_fv2 (x, \\<tau>) i (Bv xa))\n 4. \\<And>x1 t i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>y \\<notin> fst ` fv t; (b, S) \\<notin> tvs t;\n                    (b, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> bind_fv2\n(y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n(subst_typ' [((a, S), Tv b S)]\n  (subst_term [((x, \\<tau>), Fv y \\<tau>)] t)) =\n                                     subst_typ' [((a, S), Tv b S)]\n(bind_fv2 (x, \\<tau>) i t);\n        y \\<notin> fst ` fv (Abs x1 t); (b, S) \\<notin> tvs (Abs x1 t);\n        (b, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> bind_fv2 (y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n                          (subst_typ' [((a, S), Tv b S)]\n                            (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                              (Abs x1 t))) =\n                         subst_typ' [((a, S), Tv b S)]\n                          (bind_fv2 (x, \\<tau>) i (Abs x1 t))\n 5. \\<And>t1 t2 i.\n       \\<lbrakk>\\<And>i.\n                   \\<lbrakk>y \\<notin> fst ` fv t1; (b, S) \\<notin> tvs t1;\n                    (b, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> bind_fv2\n(y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n(subst_typ' [((a, S), Tv b S)]\n  (subst_term [((x, \\<tau>), Fv y \\<tau>)] t1)) =\n                                     subst_typ' [((a, S), Tv b S)]\n(bind_fv2 (x, \\<tau>) i t1);\n        \\<And>i.\n           \\<lbrakk>y \\<notin> fst ` fv t2; (b, S) \\<notin> tvs t2;\n            (b, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n           \\<Longrightarrow> bind_fv2\n                              (y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n                              (subst_typ' [((a, S), Tv b S)]\n                                (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                                  t2)) =\n                             subst_typ' [((a, S), Tv b S)]\n                              (bind_fv2 (x, \\<tau>) i t2);\n        y \\<notin> fst ` fv (t1 $ t2); (b, S) \\<notin> tvs (t1 $ t2);\n        (b, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> bind_fv2 (y, subst_typ [((a, S), Tv b S)] \\<tau>) i\n                          (subst_typ' [((a, S), Tv b S)]\n                            (subst_term [((x, \\<tau>), Fv y \\<tau>)]\n                              (t1 $ t2))) =\n                         subst_typ' [((a, S), Tv b S)]\n                          (bind_fv2 (x, \\<tau>) i (t1 $ t2))", "qed auto"], ["", "lemma subst_typ'_rename_tvar_bind_fv:\n  assumes \"y \\<notin> fst ` fv t\" \n  assumes \"(b, S) \\<notin> tvs t\"\n  assumes \"(b, S) \\<notin> tvsT \\<tau>\"\n  shows \"bind_fv (y, subst_typ [((a,S), Tv b S)] \\<tau>) \n  (subst_typ' [((a,S), Tv b S)] (subst_term [((x, \\<tau>), Fv y \\<tau>)] t))\n    = subst_typ' [((a,S), Tv b S)] (bind_fv (x, \\<tau>) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_fv (y, subst_typ [((a, S), Tv b S)] \\<tau>)\n     (subst_typ' [((a, S), Tv b S)]\n       (subst_term [((x, \\<tau>), Fv y \\<tau>)] t)) =\n    subst_typ' [((a, S), Tv b S)] (bind_fv (x, \\<tau>) t)", "using bind_fv_def assms subst_typ'_rename_tvar_bind_fv2"], ["proof (prove)\nusing this:\n  bind_fv ?vT ?t = bind_fv2 ?vT 0 ?t\n  y \\<notin> fst ` fv t\n  (b, S) \\<notin> tvs t\n  (b, S) \\<notin> tvsT \\<tau>\n  \\<lbrakk>?y \\<notin> fst ` fv ?t; (?b, ?S) \\<notin> tvs ?t;\n   (?b, ?S) \\<notin> tvsT ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> bind_fv2 (?y, subst_typ [((?a, ?S), Tv ?b ?S)] ?\\<tau>)\n                     ?i (subst_typ' [((?a, ?S), Tv ?b ?S)]\n                          (subst_term [((?x, ?\\<tau>), Fv ?y ?\\<tau>)]\n                            ?t)) =\n                    subst_typ' [((?a, ?S), Tv ?b ?S)]\n                     (bind_fv2 (?x, ?\\<tau>) ?i ?t)\n\ngoal (1 subgoal):\n 1. bind_fv (y, subst_typ [((a, S), Tv b S)] \\<tau>)\n     (subst_typ' [((a, S), Tv b S)]\n       (subst_term [((x, \\<tau>), Fv y \\<tau>)] t)) =\n    subst_typ' [((a, S), Tv b S)] (bind_fv (x, \\<tau>) t)", "by auto"], ["", "lemma tvar_in_fv_in_tvs: \"(a, \\<tau>) \\<in> fv B \\<Longrightarrow> (x, S) \\<in> tvsT \\<tau> \\<Longrightarrow> (x, S) \\<in> tvs B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, \\<tau>) \\<in> fv B; (x, S) \\<in> tvsT \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (x, S) \\<in> tvs B", "by (induction B) auto"], ["", "lemma tvs_bind_fv2_subset: \"tvs (bind_fv2 (a, \\<tau>) i B) \\<subseteq> tvs B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (bind_fv2 (a, \\<tau>) i B) \\<subseteq> tvs B", "by (induction B arbitrary: i) auto"], ["", "lemma tvs_bind_fv_subset: \"tvs (bind_fv (a, \\<tau>) B) \\<subseteq> tvs B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tvs (bind_fv (a, \\<tau>) B) \\<subseteq> tvs B", "using tvs_bind_fv2_subset bind_fv_def"], ["proof (prove)\nusing this:\n  tvs (bind_fv2 (?a, ?\\<tau>) ?i ?B) \\<subseteq> tvs ?B\n  bind_fv ?vT ?t = bind_fv2 ?vT 0 ?t\n\ngoal (1 subgoal):\n 1. tvs (bind_fv (a, \\<tau>) B) \\<subseteq> tvs B", "by simp"], ["", "lemma subst_typ_rename_tvar_preserves_eq:\n  \"(y, S) \\<notin> tvsT T \\<Longrightarrow> (y, S) \\<notin> tvsT \\<tau> \\<Longrightarrow>\n    subst_typ [((x, S), Tv y S)] T = subst_typ [((x, S), Tv y S)] \\<tau> \\<Longrightarrow> T=\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, S) \\<notin> tvsT T; (y, S) \\<notin> tvsT \\<tau>;\n     subst_typ [((x, S), Tv y S)] T =\n     subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n    \\<Longrightarrow> T = \\<tau>", "proof (induction T arbitrary: \\<tau>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 \\<tau>.\n       \\<lbrakk>\\<And>x2a \\<tau>.\n                   \\<lbrakk>x2a \\<in> set x2; (y, S) \\<notin> tvsT x2a;\n                    (y, S) \\<notin> tvsT \\<tau>;\n                    subst_typ [((x, S), Tv y S)] x2a =\n                    subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> x2a = \\<tau>;\n        (y, S) \\<notin> tvsT (Ty x1 x2); (y, S) \\<notin> tvsT \\<tau>;\n        subst_typ [((x, S), Tv y S)] (Ty x1 x2) =\n        subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n       \\<Longrightarrow> Ty x1 x2 = \\<tau>\n 2. \\<And>x1 x2 \\<tau>.\n       \\<lbrakk>(y, S) \\<notin> tvsT (Tv x1 x2);\n        (y, S) \\<notin> tvsT \\<tau>;\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2) =\n        subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n       \\<Longrightarrow> Tv x1 x2 = \\<tau>", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; (y, S) \\<notin> tvsT ?x2a;\n   (y, S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((x, S), Tv y S)] ?x2a =\n   subst_typ [((x, S), Tv y S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?x2a = ?\\<tau>\n  (y, S) \\<notin> tvsT (Ty n Ts)\n  (y, S) \\<notin> tvsT \\<tau>\n  subst_typ [((x, S), Tv y S)] (Ty n Ts) =\n  subst_typ [((x, S), Tv y S)] \\<tau>\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 \\<tau>.\n       \\<lbrakk>\\<And>x2a \\<tau>.\n                   \\<lbrakk>x2a \\<in> set x2; (y, S) \\<notin> tvsT x2a;\n                    (y, S) \\<notin> tvsT \\<tau>;\n                    subst_typ [((x, S), Tv y S)] x2a =\n                    subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> x2a = \\<tau>;\n        (y, S) \\<notin> tvsT (Ty x1 x2); (y, S) \\<notin> tvsT \\<tau>;\n        subst_typ [((x, S), Tv y S)] (Ty x1 x2) =\n        subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n       \\<Longrightarrow> Ty x1 x2 = \\<tau>\n 2. \\<And>x1 x2 \\<tau>.\n       \\<lbrakk>(y, S) \\<notin> tvsT (Tv x1 x2);\n        (y, S) \\<notin> tvsT \\<tau>;\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2) =\n        subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n       \\<Longrightarrow> Tv x1 x2 = \\<tau>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts; (y, S) \\<notin> tvsT ?x2a;\n   (y, S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((x, S), Tv y S)] ?x2a =\n   subst_typ [((x, S), Tv y S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?x2a = ?\\<tau>\n  (y, S) \\<notin> tvsT (Ty n Ts)\n  (y, S) \\<notin> tvsT \\<tau>\n  subst_typ [((x, S), Tv y S)] (Ty n Ts) =\n  subst_typ [((x, S), Tv y S)] \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts; (y, S) \\<notin> tvsT ?x2a;\n   (y, S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((x, S), Tv y S)] ?x2a =\n   subst_typ [((x, S), Tv y S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?x2a = ?\\<tau>\n  (y, S) \\<notin> tvsT (Ty n Ts)\n  (y, S) \\<notin> tvsT \\<tau>\n  subst_typ [((x, S), Tv y S)] (Ty n Ts) =\n  subst_typ [((x, S), Tv y S)] \\<tau>\n\ngoal (1 subgoal):\n 1. Ty n Ts = \\<tau>", "proof (induction \\<tau>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    \\<And>x2a \\<tau>.\n                       \\<lbrakk>x2a \\<in> set Ts; (y, S) \\<notin> tvsT x2a;\n                        (y, S) \\<notin> tvsT \\<tau>;\n                        subst_typ [((x, S), Tv y S)] x2a =\n                        subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n                       \\<Longrightarrow> x2a = \\<tau>;\n                    (y, S) \\<notin> tvsT (Ty n Ts);\n                    (y, S) \\<notin> tvsT x2a;\n                    subst_typ [((x, S), Tv y S)] (Ty n Ts) =\n                    subst_typ [((x, S), Tv y S)] x2a\\<rbrakk>\n                   \\<Longrightarrow> Ty n Ts = x2a;\n        \\<And>x2a \\<tau>.\n           \\<lbrakk>x2a \\<in> set Ts; (y, S) \\<notin> tvsT x2a;\n            (y, S) \\<notin> tvsT \\<tau>;\n            subst_typ [((x, S), Tv y S)] x2a =\n            subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n           \\<Longrightarrow> x2a = \\<tau>;\n        (y, S) \\<notin> tvsT (Ty n Ts); (y, S) \\<notin> tvsT (Ty x1 x2);\n        subst_typ [((x, S), Tv y S)] (Ty n Ts) =\n        subst_typ [((x, S), Tv y S)] (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> Ty n Ts = Ty x1 x2\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a \\<tau>.\n                   \\<lbrakk>x2a \\<in> set Ts; (y, S) \\<notin> tvsT x2a;\n                    (y, S) \\<notin> tvsT \\<tau>;\n                    subst_typ [((x, S), Tv y S)] x2a =\n                    subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> x2a = \\<tau>;\n        (y, S) \\<notin> tvsT (Ty n Ts); (y, S) \\<notin> tvsT (Tv x1 x2);\n        subst_typ [((x, S), Tv y S)] (Ty n Ts) =\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> Ty n Ts = Tv x1 x2", "case (Ty n Ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   \\<And>x2a \\<tau>.\n      \\<lbrakk>x2a \\<in> set Ts__; (y, S) \\<notin> tvsT x2a;\n       (y, S) \\<notin> tvsT \\<tau>;\n       subst_typ [((x, S), Tv y S)] x2a =\n       subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n      \\<Longrightarrow> x2a = \\<tau>;\n   (y, S) \\<notin> tvsT (Ty n__ Ts__); (y, S) \\<notin> tvsT ?x2a;\n   subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n   subst_typ [((x, S), Tv y S)] ?x2a\\<rbrakk>\n  \\<Longrightarrow> Ty n__ Ts__ = ?x2a\n  \\<lbrakk>?x2a \\<in> set Ts__; (y, S) \\<notin> tvsT ?x2a;\n   (y, S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((x, S), Tv y S)] ?x2a =\n   subst_typ [((x, S), Tv y S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?x2a = ?\\<tau>\n  (y, S) \\<notin> tvsT (Ty n__ Ts__)\n  (y, S) \\<notin> tvsT (Ty n Ts)\n  subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n  subst_typ [((x, S), Tv y S)] (Ty n Ts)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2;\n                    \\<And>x2a \\<tau>.\n                       \\<lbrakk>x2a \\<in> set Ts__;\n                        (y, S) \\<notin> tvsT x2a;\n                        (y, S) \\<notin> tvsT \\<tau>;\n                        subst_typ [((x, S), Tv y S)] x2a =\n                        subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n                       \\<Longrightarrow> x2a = \\<tau>;\n                    (y, S) \\<notin> tvsT (Ty n__ Ts__);\n                    (y, S) \\<notin> tvsT x2a;\n                    subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n                    subst_typ [((x, S), Tv y S)] x2a\\<rbrakk>\n                   \\<Longrightarrow> Ty n__ Ts__ = x2a;\n        \\<And>x2a \\<tau>.\n           \\<lbrakk>x2a \\<in> set Ts__; (y, S) \\<notin> tvsT x2a;\n            (y, S) \\<notin> tvsT \\<tau>;\n            subst_typ [((x, S), Tv y S)] x2a =\n            subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n           \\<Longrightarrow> x2a = \\<tau>;\n        (y, S) \\<notin> tvsT (Ty n__ Ts__); (y, S) \\<notin> tvsT (Ty x1 x2);\n        subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n        subst_typ [((x, S), Tv y S)] (Ty x1 x2)\\<rbrakk>\n       \\<Longrightarrow> Ty n__ Ts__ = Ty x1 x2\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a \\<tau>.\n                   \\<lbrakk>x2a \\<in> set Ts__; (y, S) \\<notin> tvsT x2a;\n                    (y, S) \\<notin> tvsT \\<tau>;\n                    subst_typ [((x, S), Tv y S)] x2a =\n                    subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> x2a = \\<tau>;\n        (y, S) \\<notin> tvsT (Ty n__ Ts__); (y, S) \\<notin> tvsT (Tv x1 x2);\n        subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> Ty n__ Ts__ = Tv x1 x2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   \\<And>x2a \\<tau>.\n      \\<lbrakk>x2a \\<in> set Ts__; (y, S) \\<notin> tvsT x2a;\n       (y, S) \\<notin> tvsT \\<tau>;\n       subst_typ [((x, S), Tv y S)] x2a =\n       subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n      \\<Longrightarrow> x2a = \\<tau>;\n   (y, S) \\<notin> tvsT (Ty n__ Ts__); (y, S) \\<notin> tvsT ?x2a;\n   subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n   subst_typ [((x, S), Tv y S)] ?x2a\\<rbrakk>\n  \\<Longrightarrow> Ty n__ Ts__ = ?x2a\n  \\<lbrakk>?x2a \\<in> set Ts__; (y, S) \\<notin> tvsT ?x2a;\n   (y, S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((x, S), Tv y S)] ?x2a =\n   subst_typ [((x, S), Tv y S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?x2a = ?\\<tau>\n  (y, S) \\<notin> tvsT (Ty n__ Ts__)\n  (y, S) \\<notin> tvsT (Ty n Ts)\n  subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n  subst_typ [((x, S), Tv y S)] (Ty n Ts)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts;\n   \\<And>x2a \\<tau>.\n      \\<lbrakk>x2a \\<in> set Ts__; (y, S) \\<notin> tvsT x2a;\n       (y, S) \\<notin> tvsT \\<tau>;\n       subst_typ [((x, S), Tv y S)] x2a =\n       subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n      \\<Longrightarrow> x2a = \\<tau>;\n   (y, S) \\<notin> tvsT (Ty n__ Ts__); (y, S) \\<notin> tvsT ?x2a;\n   subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n   subst_typ [((x, S), Tv y S)] ?x2a\\<rbrakk>\n  \\<Longrightarrow> Ty n__ Ts__ = ?x2a\n  \\<lbrakk>?x2a \\<in> set Ts__; (y, S) \\<notin> tvsT ?x2a;\n   (y, S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((x, S), Tv y S)] ?x2a =\n   subst_typ [((x, S), Tv y S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?x2a = ?\\<tau>\n  (y, S) \\<notin> tvsT (Ty n__ Ts__)\n  (y, S) \\<notin> tvsT (Ty n Ts)\n  subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n  subst_typ [((x, S), Tv y S)] (Ty n Ts)\n\ngoal (1 subgoal):\n 1. Ty n__ Ts__ = Ty n Ts", "by simp (smt list.inj_map_strong)"], ["proof (state)\nthis:\n  Ty n__ Ts__ = Ty n Ts\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a \\<tau>.\n                   \\<lbrakk>x2a \\<in> set Ts__; (y, S) \\<notin> tvsT x2a;\n                    (y, S) \\<notin> tvsT \\<tau>;\n                    subst_typ [((x, S), Tv y S)] x2a =\n                    subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> x2a = \\<tau>;\n        (y, S) \\<notin> tvsT (Ty n__ Ts__); (y, S) \\<notin> tvsT (Tv x1 x2);\n        subst_typ [((x, S), Tv y S)] (Ty n__ Ts__) =\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> Ty n__ Ts__ = Tv x1 x2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a \\<tau>.\n                   \\<lbrakk>x2a \\<in> set Ts; (y, S) \\<notin> tvsT x2a;\n                    (y, S) \\<notin> tvsT \\<tau>;\n                    subst_typ [((x, S), Tv y S)] x2a =\n                    subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> x2a = \\<tau>;\n        (y, S) \\<notin> tvsT (Ty n Ts); (y, S) \\<notin> tvsT (Tv x1 x2);\n        subst_typ [((x, S), Tv y S)] (Ty n Ts) =\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> Ty n Ts = Tv x1 x2", "case (Tv n S)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set Ts; (y, S) \\<notin> tvsT ?x2a;\n   (y, S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((x, S), Tv y S)] ?x2a =\n   subst_typ [((x, S), Tv y S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?x2a = ?\\<tau>\n  (y, S) \\<notin> tvsT (Ty n__ Ts)\n  (y, S) \\<notin> tvsT (Tv n S)\n  subst_typ [((x, S), Tv y S)] (Ty n__ Ts) =\n  subst_typ [((x, S), Tv y S)] (Tv n S)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a \\<tau>.\n                   \\<lbrakk>x2a \\<in> set Ts; (y, S) \\<notin> tvsT x2a;\n                    (y, S) \\<notin> tvsT \\<tau>;\n                    subst_typ [((x, S), Tv y S)] x2a =\n                    subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n                   \\<Longrightarrow> x2a = \\<tau>;\n        (y, S) \\<notin> tvsT (Ty n__ Ts); (y, S) \\<notin> tvsT (Tv x1 x2);\n        subst_typ [((x, S), Tv y S)] (Ty n__ Ts) =\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2)\\<rbrakk>\n       \\<Longrightarrow> Ty n__ Ts = Tv x1 x2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x2a \\<in> set Ts; (y, S) \\<notin> tvsT ?x2a;\n   (y, S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((x, S), Tv y S)] ?x2a =\n   subst_typ [((x, S), Tv y S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?x2a = ?\\<tau>\n  (y, S) \\<notin> tvsT (Ty n__ Ts)\n  (y, S) \\<notin> tvsT (Tv n S)\n  subst_typ [((x, S), Tv y S)] (Ty n__ Ts) =\n  subst_typ [((x, S), Tv y S)] (Tv n S)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set Ts; (y, S) \\<notin> tvsT ?x2a;\n   (y, S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((x, S), Tv y S)] ?x2a =\n   subst_typ [((x, S), Tv y S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?x2a = ?\\<tau>\n  (y, S) \\<notin> tvsT (Ty n__ Ts)\n  (y, S) \\<notin> tvsT (Tv n S)\n  subst_typ [((x, S), Tv y S)] (Ty n__ Ts) =\n  subst_typ [((x, S), Tv y S)] (Tv n S)\n\ngoal (1 subgoal):\n 1. Ty n__ Ts = Tv n S", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  Ty n__ Ts = Tv n S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ty n Ts = \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 \\<tau>.\n       \\<lbrakk>(y, S) \\<notin> tvsT (Tv x1 x2);\n        (y, S) \\<notin> tvsT \\<tau>;\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2) =\n        subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n       \\<Longrightarrow> Tv x1 x2 = \\<tau>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 \\<tau>.\n       \\<lbrakk>(y, S) \\<notin> tvsT (Tv x1 x2);\n        (y, S) \\<notin> tvsT \\<tau>;\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2) =\n        subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n       \\<Longrightarrow> Tv x1 x2 = \\<tau>", "case (Tv n S)"], ["proof (state)\nthis:\n  (y, S) \\<notin> tvsT (Tv n S)\n  (y, S) \\<notin> tvsT \\<tau>\n  subst_typ [((x, S), Tv y S)] (Tv n S) =\n  subst_typ [((x, S), Tv y S)] \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 \\<tau>.\n       \\<lbrakk>(y, S) \\<notin> tvsT (Tv x1 x2);\n        (y, S) \\<notin> tvsT \\<tau>;\n        subst_typ [((x, S), Tv y S)] (Tv x1 x2) =\n        subst_typ [((x, S), Tv y S)] \\<tau>\\<rbrakk>\n       \\<Longrightarrow> Tv x1 x2 = \\<tau>", "then"], ["proof (chain)\npicking this:\n  (y, S) \\<notin> tvsT (Tv n S)\n  (y, S) \\<notin> tvsT \\<tau>\n  subst_typ [((x, S), Tv y S)] (Tv n S) =\n  subst_typ [((x, S), Tv y S)] \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  (y, S) \\<notin> tvsT (Tv n S)\n  (y, S) \\<notin> tvsT \\<tau>\n  subst_typ [((x, S), Tv y S)] (Tv n S) =\n  subst_typ [((x, S), Tv y S)] \\<tau>\n\ngoal (1 subgoal):\n 1. Tv n S = \\<tau>", "by (induction \\<tau>) (auto split: if_splits)"], ["proof (state)\nthis:\n  Tv n S = \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_typ'_subst_term_rename_var_swap:\n  assumes \"b \\<notin> fst ` fv B\"\n  assumes \"(y, S) \\<notin> tvs B\"\n  assumes \"(y, S) \\<notin> tvsT \\<tau>\"\n  shows \"subst_typ' [((x, S), Tv y S)] (subst_term [((a, \\<tau>), Fv b \\<tau>)] B)\n    = subst_term [((a, (subst_typ [((x, S), Tv y S)] \\<tau>)), Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))] \n      (subst_typ' [((x, S), Tv y S)] B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_typ' [((x, S), Tv y S)]\n     (subst_term [((a, \\<tau>), Fv b \\<tau>)] B) =\n    subst_term\n     [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n       Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n     (subst_typ' [((x, S), Tv y S)] B)", "using assms"], ["proof (prove)\nusing this:\n  b \\<notin> fst ` fv B\n  (y, S) \\<notin> tvs B\n  (y, S) \\<notin> tvsT \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ' [((x, S), Tv y S)]\n     (subst_term [((a, \\<tau>), Fv b \\<tau>)] B) =\n    subst_term\n     [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n       Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n     (subst_typ' [((x, S), Tv y S)] B)", "proof (induction B)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>b \\<notin> fst ` fv (Ct x1 x2);\n        (y, S) \\<notin> tvs (Ct x1 x2); (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Ct x1 x2)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Ct x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>b \\<notin> fst ` fv (Fv x1 x2);\n        (y, S) \\<notin> tvs (Fv x1 x2); (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Fv x1 x2)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Fv x1 x2))\n 3. \\<And>xa.\n       \\<lbrakk>b \\<notin> fst ` fv (Bv xa); (y, S) \\<notin> tvs (Bv xa);\n        (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Bv xa)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Bv xa))\n 4. \\<And>x1 B.\n       \\<lbrakk>\\<lbrakk>b \\<notin> fst ` fv B; (y, S) \\<notin> tvs B;\n                 (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n                \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                                   (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                                     B) =\n                                  subst_term\n                                   [((a,\nsubst_typ [((x, S), Tv y S)] \\<tau>),\n                                     Fv b\n(subst_typ [((x, S), Tv y S)] \\<tau>))]\n                                   (subst_typ' [((x, S), Tv y S)] B);\n        b \\<notin> fst ` fv (Abs x1 B); (y, S) \\<notin> tvs (Abs x1 B);\n        (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Abs x1 B)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Abs x1 B))\n 5. \\<And>B1 B2.\n       \\<lbrakk>\\<lbrakk>b \\<notin> fst ` fv B1; (y, S) \\<notin> tvs B1;\n                 (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n                \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                                   (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                                     B1) =\n                                  subst_term\n                                   [((a,\nsubst_typ [((x, S), Tv y S)] \\<tau>),\n                                     Fv b\n(subst_typ [((x, S), Tv y S)] \\<tau>))]\n                                   (subst_typ' [((x, S), Tv y S)] B1);\n        \\<lbrakk>b \\<notin> fst ` fv B2; (y, S) \\<notin> tvs B2;\n         (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n        \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                           (subst_term [((a, \\<tau>), Fv b \\<tau>)] B2) =\n                          subst_term\n                           [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                             Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                           (subst_typ' [((x, S), Tv y S)] B2);\n        b \\<notin> fst ` fv (B1 $ B2); (y, S) \\<notin> tvs (B1 $ B2);\n        (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (B1 $ B2)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (B1 $ B2))", "case (Fv idn T)"], ["proof (state)\nthis:\n  b \\<notin> fst ` fv (Fv idn T)\n  (y, S) \\<notin> tvs (Fv idn T)\n  (y, S) \\<notin> tvsT \\<tau>\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>b \\<notin> fst ` fv (Ct x1 x2);\n        (y, S) \\<notin> tvs (Ct x1 x2); (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Ct x1 x2)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Ct x1 x2))\n 2. \\<And>x1 x2.\n       \\<lbrakk>b \\<notin> fst ` fv (Fv x1 x2);\n        (y, S) \\<notin> tvs (Fv x1 x2); (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Fv x1 x2)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Fv x1 x2))\n 3. \\<And>xa.\n       \\<lbrakk>b \\<notin> fst ` fv (Bv xa); (y, S) \\<notin> tvs (Bv xa);\n        (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Bv xa)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Bv xa))\n 4. \\<And>x1 B.\n       \\<lbrakk>\\<lbrakk>b \\<notin> fst ` fv B; (y, S) \\<notin> tvs B;\n                 (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n                \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                                   (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                                     B) =\n                                  subst_term\n                                   [((a,\nsubst_typ [((x, S), Tv y S)] \\<tau>),\n                                     Fv b\n(subst_typ [((x, S), Tv y S)] \\<tau>))]\n                                   (subst_typ' [((x, S), Tv y S)] B);\n        b \\<notin> fst ` fv (Abs x1 B); (y, S) \\<notin> tvs (Abs x1 B);\n        (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Abs x1 B)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Abs x1 B))\n 5. \\<And>B1 B2.\n       \\<lbrakk>\\<lbrakk>b \\<notin> fst ` fv B1; (y, S) \\<notin> tvs B1;\n                 (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n                \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                                   (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                                     B1) =\n                                  subst_term\n                                   [((a,\nsubst_typ [((x, S), Tv y S)] \\<tau>),\n                                     Fv b\n(subst_typ [((x, S), Tv y S)] \\<tau>))]\n                                   (subst_typ' [((x, S), Tv y S)] B1);\n        \\<lbrakk>b \\<notin> fst ` fv B2; (y, S) \\<notin> tvs B2;\n         (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n        \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                           (subst_term [((a, \\<tau>), Fv b \\<tau>)] B2) =\n                          subst_term\n                           [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                             Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                           (subst_typ' [((x, S), Tv y S)] B2);\n        b \\<notin> fst ` fv (B1 $ B2); (y, S) \\<notin> tvs (B1 $ B2);\n        (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (B1 $ B2)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (B1 $ B2))", "then"], ["proof (chain)\npicking this:\n  b \\<notin> fst ` fv (Fv idn T)\n  (y, S) \\<notin> tvs (Fv idn T)\n  (y, S) \\<notin> tvsT \\<tau>", "show ?case"], ["proof (prove)\nusing this:\n  b \\<notin> fst ` fv (Fv idn T)\n  (y, S) \\<notin> tvs (Fv idn T)\n  (y, S) \\<notin> tvsT \\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ' [((x, S), Tv y S)]\n     (subst_term [((a, \\<tau>), Fv b \\<tau>)] (Fv idn T)) =\n    subst_term\n     [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n       Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n     (subst_typ' [((x, S), Tv y S)] (Fv idn T))", "using subst_typ_rename_tvar_preserves_eq"], ["proof (prove)\nusing this:\n  b \\<notin> fst ` fv (Fv idn T)\n  (y, S) \\<notin> tvs (Fv idn T)\n  (y, S) \\<notin> tvsT \\<tau>\n  \\<lbrakk>(?y, ?S) \\<notin> tvsT ?T; (?y, ?S) \\<notin> tvsT ?\\<tau>;\n   subst_typ [((?x, ?S), Tv ?y ?S)] ?T =\n   subst_typ [((?x, ?S), Tv ?y ?S)] ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> ?T = ?\\<tau>\n\ngoal (1 subgoal):\n 1. subst_typ' [((x, S), Tv y S)]\n     (subst_term [((a, \\<tau>), Fv b \\<tau>)] (Fv idn T)) =\n    subst_term\n     [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n       Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n     (subst_typ' [((x, S), Tv y S)] (Fv idn T))", "by auto"], ["proof (state)\nthis:\n  subst_typ' [((x, S), Tv y S)]\n   (subst_term [((a, \\<tau>), Fv b \\<tau>)] (Fv idn T)) =\n  subst_term\n   [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n     Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n   (subst_typ' [((x, S), Tv y S)] (Fv idn T))\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>b \\<notin> fst ` fv (Ct x1 x2);\n        (y, S) \\<notin> tvs (Ct x1 x2); (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Ct x1 x2)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Ct x1 x2))\n 2. \\<And>xa.\n       \\<lbrakk>b \\<notin> fst ` fv (Bv xa); (y, S) \\<notin> tvs (Bv xa);\n        (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Bv xa)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Bv xa))\n 3. \\<And>x1 B.\n       \\<lbrakk>\\<lbrakk>b \\<notin> fst ` fv B; (y, S) \\<notin> tvs B;\n                 (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n                \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                                   (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                                     B) =\n                                  subst_term\n                                   [((a,\nsubst_typ [((x, S), Tv y S)] \\<tau>),\n                                     Fv b\n(subst_typ [((x, S), Tv y S)] \\<tau>))]\n                                   (subst_typ' [((x, S), Tv y S)] B);\n        b \\<notin> fst ` fv (Abs x1 B); (y, S) \\<notin> tvs (Abs x1 B);\n        (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (Abs x1 B)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (Abs x1 B))\n 4. \\<And>B1 B2.\n       \\<lbrakk>\\<lbrakk>b \\<notin> fst ` fv B1; (y, S) \\<notin> tvs B1;\n                 (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n                \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                                   (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                                     B1) =\n                                  subst_term\n                                   [((a,\nsubst_typ [((x, S), Tv y S)] \\<tau>),\n                                     Fv b\n(subst_typ [((x, S), Tv y S)] \\<tau>))]\n                                   (subst_typ' [((x, S), Tv y S)] B1);\n        \\<lbrakk>b \\<notin> fst ` fv B2; (y, S) \\<notin> tvs B2;\n         (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n        \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                           (subst_term [((a, \\<tau>), Fv b \\<tau>)] B2) =\n                          subst_term\n                           [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                             Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                           (subst_typ' [((x, S), Tv y S)] B2);\n        b \\<notin> fst ` fv (B1 $ B2); (y, S) \\<notin> tvs (B1 $ B2);\n        (y, S) \\<notin> tvsT \\<tau>\\<rbrakk>\n       \\<Longrightarrow> subst_typ' [((x, S), Tv y S)]\n                          (subst_term [((a, \\<tau>), Fv b \\<tau>)]\n                            (B1 $ B2)) =\n                         subst_term\n                          [((a, subst_typ [((x, S), Tv y S)] \\<tau>),\n                            Fv b (subst_typ [((x, S), Tv y S)] \\<tau>))]\n                          (subst_typ' [((x, S), Tv y S)] (B1 $ B2))", "qed auto"], ["", "(* My naming needs work, also those lemmas might be subsumed *)"], ["", "lemma tvar_not_in_term_imp_free_not_in_term:\n  \"(y, S) \\<in> tvsT \\<tau> \\<Longrightarrow> (y,S) \\<notin> tvs t \\<Longrightarrow> (a, \\<tau>) \\<notin> fv t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(y, S) \\<in> tvsT \\<tau>; (y, S) \\<notin> tvs t\\<rbrakk>\n    \\<Longrightarrow> (a, \\<tau>) \\<notin> fv t", "by (induction t) auto"], ["", "lemma tvar_not_in_term_imp_free_not_in_term_set:\n  \"finite \\<Gamma> \\<Longrightarrow> (y, S) \\<in> tvsT \\<tau> \\<Longrightarrow> (y,S) \\<notin> tvs_Set \\<Gamma> \\<Longrightarrow> (a, \\<tau>) \\<notin> FV \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite \\<Gamma>; (y, S) \\<in> tvsT \\<tau>;\n     (y, S) \\<notin> tvs_Set \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> (a, \\<tau>) \\<notin> FV \\<Gamma>", "using tvar_not_in_term_imp_free_not_in_term"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?y, ?S) \\<in> tvsT ?\\<tau>; (?y, ?S) \\<notin> tvs ?t\\<rbrakk>\n  \\<Longrightarrow> (?a, ?\\<tau>) \\<notin> fv ?t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite \\<Gamma>; (y, S) \\<in> tvsT \\<tau>;\n     (y, S) \\<notin> tvs_Set \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> (a, \\<tau>) \\<notin> FV \\<Gamma>", "by simp"], ["", "(* I can probably weaken vars a bit, should only need wf criteria on insts, nothing more *)"], ["", "lemma inst_var_multiple: \n  assumes wf_theory: \"wf_theory \\<Theta>\"\n  assumes B: \"\\<Theta>, \\<Gamma> \\<turnstile> B\"\n  assumes vars: \"\\<forall>(x,\\<tau>)\\<in>fst ` set insts . term_ok \\<Theta> (Fv x \\<tau>)\"\n  assumes a_ok: \"\\<forall>a\\<in>snd ` set insts . term_ok \\<Theta> a\" \n  assumes typ_a: \"\\<forall>((_,\\<tau>), a)\\<in>set insts . typ_of a = Some \\<tau>\"\n  assumes free: \"\\<forall>(v, _)\\<in>set insts . v \\<notin> FV \\<Gamma>\"\n  assumes distinct: \"distinct (map fst insts)\"\n  assumes finite: \"finite \\<Gamma>\"\n  shows \"\\<Theta>, \\<Gamma> \\<turnstile> subst_term insts B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B", "obtain fresh_idns where fresh_idns:\n    \"length fresh_idns = length insts\"\n    \"\\<forall>idn \\<in> set fresh_idns . \n      idn \\<notin> fst ` (fv B \\<union> (\\<Union>t\\<in>snd ` set insts . (fv t)) \\<union> (fst ` set insts)) \\<union> fst ` (FV \\<Gamma>)\"\n    \"distinct fresh_idns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fresh_idns.\n        \\<lbrakk>length fresh_idns = length insts;\n         \\<forall>idn\\<in>set fresh_idns.\n            idn\n            \\<notin> fst `\n                     (fv B \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n                      fst ` set insts) \\<union>\n                     fst ` FV \\<Gamma>;\n         distinct fresh_idns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using distinct_fresh_rename_idns fresh_fresh_rename_idns length_fresh_rename_idns finite_FV finite"], ["proof (prove)\nusing this:\n  finite ?G \\<Longrightarrow> distinct (fresh_rename_idns ?n ?B ?insts ?G)\n  finite ?G \\<Longrightarrow>\n  \\<forall>nm\\<in>set (fresh_rename_idns ?n ?B ?insts ?G).\n     nm \\<notin> fst `\n                 (fv ?B \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                  fst ` set ?insts) \\<union>\n                 ?G\n  finite ?G \\<Longrightarrow>\n  length (fresh_rename_idns ?n ?B ?insts ?G) = ?n\n  finite ?S \\<Longrightarrow> finite (FV ?S)\n  finite \\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>fresh_idns.\n        \\<lbrakk>length fresh_idns = length insts;\n         \\<forall>idn\\<in>set fresh_idns.\n            idn\n            \\<notin> fst `\n                     (fv B \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n                      fst ` set insts) \\<union>\n                     fst ` FV \\<Gamma>;\n         distinct fresh_idns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis finite_imageI)"], ["proof (state)\nthis:\n  length fresh_idns = length insts\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts) \\<union>\n              fst ` FV \\<Gamma>\n  distinct fresh_idns\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B", "have 0: \"subst_term insts B                                        \n    = fold (\\<lambda>single acc . subst_term [single] acc) (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      (fold (\\<lambda>single acc . subst_term [single] acc) (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_term insts B =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       B)", "using fresh_idns distinct subst_term_combine'"], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts) \\<union>\n              fst ` FV \\<Gamma>\n  distinct fresh_idns\n  distinct (map fst insts)\n  \\<lbrakk>length ?fresh_idns = length ?insts; distinct ?fresh_idns;\n   distinct (map fst ?insts);\n   \\<forall>idn\\<in>set ?fresh_idns.\n      idn\n      \\<notin> fst `\n               (fv ?t \\<union> \\<Union> (fv ` snd ` set ?insts) \\<union>\n                fst ` set ?insts)\\<rbrakk>\n  \\<Longrightarrow> subst_term ?insts ?t =\n                    fold (\\<lambda>single. subst_term [single])\n                     (zip (zip ?fresh_idns (map snd (map fst ?insts)))\n                       (map snd ?insts))\n                     (fold (\\<lambda>single. subst_term [single])\n                       (zip (map fst ?insts)\n                         (map2 Fv ?fresh_idns (map snd (map fst ?insts))))\n                       ?t)\n\ngoal (1 subgoal):\n 1. subst_term insts B =\n    fold (\\<lambda>single. subst_term [single])\n     (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts))))\n       B)", "by simp"], ["proof (state)\nthis:\n  subst_term insts B =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B", "from fresh_idns vars a_ok typ_a free distinct"], ["proof (chain)\npicking this:\n  length fresh_idns = length insts\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts) \\<union>\n              fst ` FV \\<Gamma>\n  distinct fresh_idns\n  \\<forall>(x, \\<tau>)\\<in>fst ` set insts. term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set insts. term_ok \\<Theta> a\n  \\<forall>((uu_, \\<tau>), a)\\<in>set insts. typ_of a = Some \\<tau>\n  \\<forall>(v, uu_)\\<in>set insts. v \\<notin> FV \\<Gamma>\n  distinct (map fst insts)", "have 1: \n    \"\\<Theta>, \\<Gamma> \\<turnstile> (fold (\\<lambda>single acc . subst_term [single] acc) \n    (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B)\""], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts) \\<union>\n              fst ` FV \\<Gamma>\n  distinct fresh_idns\n  \\<forall>(x, \\<tau>)\\<in>fst ` set insts. term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set insts. term_ok \\<Theta> a\n  \\<forall>((uu_, \\<tau>), a)\\<in>set insts. typ_of a = Some \\<tau>\n  \\<forall>(v, uu_)\\<in>set insts. v \\<notin> FV \\<Gamma>\n  distinct (map fst insts)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst insts)\n(map2 Fv fresh_idns (map snd (map fst insts))))\n                                    B", "proof (induction fresh_idns insts rule: rev_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>idn\\<in>set [].\n                idn\n                \\<notin> fst `\n                         (fv B \\<union>\n                          \\<Union> (fv ` snd ` set []) \\<union>\n                          fst ` set []) \\<union>\n                         fst ` FV \\<Gamma>;\n     distinct [];\n     \\<forall>(x, \\<tau>)\\<in>fst ` set []. term_ok \\<Theta> (Fv x \\<tau>);\n     Ball (snd ` set []) (term_ok \\<Theta>);\n     \\<forall>((uu_, \\<tau>), a)\\<in>set []. typ_of a = Some \\<tau>;\n     \\<forall>(v, uu_)\\<in>set []. v \\<notin> FV \\<Gamma>;\n     distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                (\\<lambda>single. subst_term [single])\n                (zip (map fst []) (map2 Fv [] (map snd (map fst [])))) B\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "case Nil"], ["proof (state)\nthis:\n  \\<forall>idn\\<in>set [].\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set []) \\<union>\n               fst ` set []) \\<union>\n              fst ` FV \\<Gamma>\n  distinct []\n  \\<forall>a\\<in>fst ` set [].\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set []. term_ok \\<Theta> a\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set [].\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>idn\\<in>set [].\n                idn\n                \\<notin> fst `\n                         (fv B \\<union>\n                          \\<Union> (fv ` snd ` set []) \\<union>\n                          fst ` set []) \\<union>\n                         fst ` FV \\<Gamma>;\n     distinct [];\n     \\<forall>(x, \\<tau>)\\<in>fst ` set []. term_ok \\<Theta> (Fv x \\<tau>);\n     Ball (snd ` set []) (term_ok \\<Theta>);\n     \\<forall>((uu_, \\<tau>), a)\\<in>set []. typ_of a = Some \\<tau>;\n     \\<forall>(v, uu_)\\<in>set []. v \\<notin> FV \\<Gamma>;\n     distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                (\\<lambda>single. subst_term [single])\n                (zip (map fst []) (map2 Fv [] (map snd (map fst [])))) B\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "then"], ["proof (chain)\npicking this:\n  \\<forall>idn\\<in>set [].\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set []) \\<union>\n               fst ` set []) \\<union>\n              fst ` FV \\<Gamma>\n  distinct []\n  \\<forall>a\\<in>fst ` set [].\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set []. term_ok \\<Theta> a\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set [].\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst [])", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set [].\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set []) \\<union>\n               fst ` set []) \\<union>\n              fst ` FV \\<Gamma>\n  distinct []\n  \\<forall>a\\<in>fst ` set [].\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set []. term_ok \\<Theta> a\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set [].\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst [])\n(map2 Fv [] (map snd (map fst []))))\n                                    B", "using B"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set [].\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set []) \\<union>\n               fst ` set []) \\<union>\n              fst ` FV \\<Gamma>\n  distinct []\n  \\<forall>a\\<in>fst ` set [].\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set []. term_ok \\<Theta> a\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set [].\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst [])\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst [])\n(map2 Fv [] (map snd (map fst []))))\n                                    B", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst [])\n                                    (map2 Fv [] (map snd (map fst []))))\n                                  B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "case (snoc x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>\\<forall>idn\\<in>set xs.\n              idn\n              \\<notin> fst `\n                       (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                        fst ` set ys) \\<union>\n                       fst ` FV \\<Gamma>;\n   distinct xs;\n   \\<forall>a\\<in>fst ` set ys.\n      case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>);\n   \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a;\n   \\<forall>a\\<in>set ys.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n         b;\n   \\<forall>a\\<in>set ys.\n      case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>;\n   distinct (map fst ys)\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single])\n              (zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "from snoc"], ["proof (chain)\npicking this:\n  length xs = length ys\n  \\<lbrakk>\\<forall>idn\\<in>set xs.\n              idn\n              \\<notin> fst `\n                       (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                        fst ` set ys) \\<union>\n                       fst ` FV \\<Gamma>;\n   distinct xs;\n   \\<forall>a\\<in>fst ` set ys.\n      case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>);\n   \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a;\n   \\<forall>a\\<in>set ys.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n         b;\n   \\<forall>a\\<in>set ys.\n      case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>;\n   distinct (map fst ys)\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single])\n              (zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))", "have term_oky: \"term_ok \\<Theta> (Fv (fst (fst y)) (snd (fst y)))\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  \\<lbrakk>\\<forall>idn\\<in>set xs.\n              idn\n              \\<notin> fst `\n                       (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                        fst ` set ys) \\<union>\n                       fst ` FV \\<Gamma>;\n   distinct xs;\n   \\<forall>a\\<in>fst ` set ys.\n      case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>);\n   \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a;\n   \\<forall>a\\<in>set ys.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n         b;\n   \\<forall>a\\<in>set ys.\n      case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>;\n   distinct (map fst ys)\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single])\n              (zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))\n\ngoal (1 subgoal):\n 1. term_ok \\<Theta> (Fv (fst (fst y)) (snd (fst y)))", "by (auto simp add: wt_term_def split: prod.splits)"], ["proof (state)\nthis:\n  term_ok \\<Theta> (Fv (fst (fst y)) (snd (fst y)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "have 1: \"\\<Theta>, \\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n            (zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst ys)\n(map2 Fv xs (map snd (map fst ys))))\n                                    B", "apply (rule snoc.IH)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<forall>idn\\<in>set xs.\n       idn\n       \\<notin> fst `\n                (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                 fst ` set ys) \\<union>\n                fst ` FV \\<Gamma>\n 2. distinct xs\n 3. \\<forall>a\\<in>fst ` set ys.\n       case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n 4. \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a\n 5. \\<forall>a\\<in>set ys.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n          b\n 6. \\<forall>a\\<in>set ys.\n       case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n 7. distinct (map fst ys)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>idn\\<in>set xs.\n       idn\n       \\<notin> fst `\n                (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                 fst ` set ys) \\<union>\n                fst ` FV \\<Gamma>", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>idn\\<in>set xs.\n       idn\n       \\<notin> fst `\n                (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                 fst ` set ys) \\<union>\n                fst ` FV \\<Gamma>", "by (clarsimp split: prod.splits) (smt UN_I Un_iff fst_conv image_iff)"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct xs\n 2. \\<forall>a\\<in>fst ` set ys.\n       case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n 3. \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a\n 4. \\<forall>a\\<in>set ys.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n          b\n 5. \\<forall>a\\<in>set ys.\n       case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n 6. distinct (map fst ys)", "using snoc.prems(2-7)"], ["proof (prove)\nusing this:\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))\n\ngoal (6 subgoals):\n 1. distinct xs\n 2. \\<forall>a\\<in>fst ` set ys.\n       case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n 3. \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a\n 4. \\<forall>a\\<in>set ys.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n          b\n 5. \\<forall>a\\<in>set ys.\n       case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n 6. distinct (map fst ys)", "by auto"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst ys)\n                                    (map2 Fv xs (map snd (map fst ys))))\n                                  B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "moreover"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst ys)\n                                    (map2 Fv xs (map snd (map fst ys))))\n                                  B\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "obtain yn n where ynn: \"fst y = (yn, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yn n. fst y = (yn, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  fst y = (yn, n)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "moreover"], ["proof (state)\nthis:\n  fst y = (yn, n)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "have \"\\<Theta>,\\<Gamma> \\<turnstile> subst_term [(fst y, Fv x n)]\n          (fold (\\<lambda>single. subst_term [single]) (zip (map fst (ys))\n            (map2 Fv (xs) (map snd (map fst (ys))))) B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [(fst y, Fv x n)]\n                                    (fold\n(\\<lambda>single. subst_term [single])\n(zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B)", "apply (simp only: ynn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((yn, n), Fv x n)]\n                                    (fold\n(\\<lambda>single. subst_term [single])\n(zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B)", "apply (rule inst_var[of \"\\<Theta>\" \\<Gamma> \"(fold (\\<lambda>single. subst_term [single]) (zip (map fst (ys))\n            (map2 Fv (xs) (map snd (map fst (ys))))) B)\" \"(Fv x n)\" \"n\" \"yn\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst ys)\n(map2 Fv xs (map snd (map fst ys))))\n                                    B\n 3. term_ok \\<Theta> (Fv x n)\n 4. typ_of (Fv x n) = Some n\n 5. (yn, n) \\<notin> FV \\<Gamma>", "using snoc.prems \\<open>wf_theory \\<Theta>\\<close> 1"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst ys)\n                                    (map2 Fv xs (map snd (map fst ys))))\n                                  B\n\ngoal (5 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst ys)\n(map2 Fv xs (map snd (map fst ys))))\n                                    B\n 3. term_ok \\<Theta> (Fv x n)\n 4. typ_of (Fv x n) = Some n\n 5. (yn, n) \\<notin> FV \\<Gamma>", "apply (solves simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. term_ok \\<Theta> (Fv x n)\n 2. typ_of (Fv x n) = Some n\n 3. (yn, n) \\<notin> FV \\<Gamma>", "using term_oky ynn"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (Fv (fst (fst y)) (snd (fst y)))\n  fst y = (yn, n)\n\ngoal (3 subgoals):\n 1. term_ok \\<Theta> (Fv x n)\n 2. typ_of (Fv x n) = Some n\n 3. (yn, n) \\<notin> FV \\<Gamma>", "apply (simp add: wt_term_def typ_of_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. typ_of (Fv x n) = Some n\n 2. (yn, n) \\<notin> FV \\<Gamma>", "using term_oky ynn"], ["proof (prove)\nusing this:\n  term_ok \\<Theta> (Fv (fst (fst y)) (snd (fst y)))\n  fst y = (yn, n)\n\ngoal (2 subgoals):\n 1. typ_of (Fv x n) = Some n\n 2. (yn, n) \\<notin> FV \\<Gamma>", "apply (simp add: wt_term_def typ_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (yn, n) \\<notin> FV \\<Gamma>", "using snoc.prems(6) ynn"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  fst y = (yn, n)\n\ngoal (1 subgoal):\n 1. (yn, n) \\<notin> FV \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [(fst y, Fv x n)]\n                                  (fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst ys)\n(map2 Fv xs (map snd (map fst ys))))\n                                    B)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "moreover"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [(fst y, Fv x n)]\n                                  (fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst ys)\n(map2 Fv xs (map snd (map fst ys))))\n                                    B)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "have \"fold (\\<lambda>single. subst_term [single]) (zip (map fst (ys @ [y]))\n      (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y]))))) B\n      = subst_term [(fst y, Fv x (snd (fst y)))]\n          (fold (\\<lambda>single. subst_term [single]) (zip (map fst (ys))\n            (map2 Fv (xs) (map snd (map fst (ys))))) B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_term [single])\n     (zip (map fst (ys @ [y]))\n       (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n     B =\n    subst_term [(fst y, Fv x (snd (fst y)))]\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B)", "using snoc.hyps"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_term [single])\n     (zip (map fst (ys @ [y]))\n       (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n     B =\n    subst_term [(fst y, Fv x (snd (fst y)))]\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B)", "by (induction xs ys rule: list_induct2) simp_all"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst (ys @ [y]))\n     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n   B =\n  subst_term [(fst y, Fv x (snd (fst y)))]\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (map fst ys) (map2 Fv xs (map snd (map fst ys))))\n                    B;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (map fst (ys @ [y]))\n                     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                   B", "ultimately"], ["proof (chain)\npicking this:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst ys)\n                                    (map2 Fv xs (map snd (map fst ys))))\n                                  B\n  fst y = (yn, n)\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [(fst y, Fv x n)]\n                                  (fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst ys)\n(map2 Fv xs (map snd (map fst ys))))\n                                    B)\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst (ys @ [y]))\n     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n   B =\n  subst_term [(fst y, Fv x (snd (fst y)))]\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B)", "show ?case"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst ys)\n                                    (map2 Fv xs (map snd (map fst ys))))\n                                  B\n  fst y = (yn, n)\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [(fst y, Fv x n)]\n                                  (fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst ys)\n(map2 Fv xs (map snd (map fst ys))))\n                                    B)\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst (ys @ [y]))\n     (map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n   B =\n  subst_term [(fst y, Fv x (snd (fst y)))]\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst ys) (map2 Fv xs (map snd (map fst ys)))) B)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (map fst (ys @ [y]))\n(map2 Fv (xs @ [x]) (map snd (map fst (ys @ [y])))))\n                                    B", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst (ys @ [y]))\n                                    (map2 Fv (xs @ [x])\n(map snd (map fst (ys @ [y])))))\n                                  B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst insts)\n                                    (map2 Fv fresh_idns\n(map snd (map fst insts))))\n                                  B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B", "define point where \"point \\<equiv> (fold (\\<lambda>single acc . subst_term [single] acc) \n    (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B)\""], ["proof (state)\nthis:\n  point \\<equiv>\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B", "from fresh_idns vars a_ok typ_a free distinct"], ["proof (chain)\npicking this:\n  length fresh_idns = length insts\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts) \\<union>\n              fst ` FV \\<Gamma>\n  distinct fresh_idns\n  \\<forall>(x, \\<tau>)\\<in>fst ` set insts. term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set insts. term_ok \\<Theta> a\n  \\<forall>((uu_, \\<tau>), a)\\<in>set insts. typ_of a = Some \\<tau>\n  \\<forall>(v, uu_)\\<in>set insts. v \\<notin> FV \\<Gamma>\n  distinct (map fst insts)", "have 2: \n    \"\\<Theta>, \\<Gamma> \\<turnstile> fold (\\<lambda>single acc . subst_term [single] acc)\n      (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts)) \n      point\""], ["proof (prove)\nusing this:\n  length fresh_idns = length insts\n  \\<forall>idn\\<in>set fresh_idns.\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set insts) \\<union>\n               fst ` set insts) \\<union>\n              fst ` FV \\<Gamma>\n  distinct fresh_idns\n  \\<forall>(x, \\<tau>)\\<in>fst ` set insts. term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set insts. term_ok \\<Theta> a\n  \\<forall>((uu_, \\<tau>), a)\\<in>set insts. typ_of a = Some \\<tau>\n  \\<forall>(v, uu_)\\<in>set insts. v \\<notin> FV \\<Gamma>\n  distinct (map fst insts)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip\n(zip fresh_idns (map snd (map fst insts))) (map snd insts))\n                                    point", "proof (induction fresh_idns insts rule: rev_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>idn\\<in>set [].\n                idn\n                \\<notin> fst `\n                         (fv B \\<union>\n                          \\<Union> (fv ` snd ` set []) \\<union>\n                          fst ` set []) \\<union>\n                         fst ` FV \\<Gamma>;\n     distinct [];\n     \\<forall>(x, \\<tau>)\\<in>fst ` set []. term_ok \\<Theta> (Fv x \\<tau>);\n     Ball (snd ` set []) (term_ok \\<Theta>);\n     \\<forall>((uu_, \\<tau>), a)\\<in>set []. typ_of a = Some \\<tau>;\n     \\<forall>(v, uu_)\\<in>set []. v \\<notin> FV \\<Gamma>;\n     distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                (\\<lambda>single. subst_term [single])\n                (zip (zip [] (map snd (map fst []))) (map snd [])) point\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "case Nil"], ["proof (state)\nthis:\n  \\<forall>idn\\<in>set [].\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set []) \\<union>\n               fst ` set []) \\<union>\n              fst ` FV \\<Gamma>\n  distinct []\n  \\<forall>a\\<in>fst ` set [].\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set []. term_ok \\<Theta> a\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set [].\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>idn\\<in>set [].\n                idn\n                \\<notin> fst `\n                         (fv B \\<union>\n                          \\<Union> (fv ` snd ` set []) \\<union>\n                          fst ` set []) \\<union>\n                         fst ` FV \\<Gamma>;\n     distinct [];\n     \\<forall>(x, \\<tau>)\\<in>fst ` set []. term_ok \\<Theta> (Fv x \\<tau>);\n     Ball (snd ` set []) (term_ok \\<Theta>);\n     \\<forall>((uu_, \\<tau>), a)\\<in>set []. typ_of a = Some \\<tau>;\n     \\<forall>(v, uu_)\\<in>set []. v \\<notin> FV \\<Gamma>;\n     distinct (map fst [])\\<rbrakk>\n    \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                (\\<lambda>single. subst_term [single])\n                (zip (zip [] (map snd (map fst []))) (map snd [])) point\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "then"], ["proof (chain)\npicking this:\n  \\<forall>idn\\<in>set [].\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set []) \\<union>\n               fst ` set []) \\<union>\n              fst ` FV \\<Gamma>\n  distinct []\n  \\<forall>a\\<in>fst ` set [].\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set []. term_ok \\<Theta> a\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set [].\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst [])", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set [].\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set []) \\<union>\n               fst ` set []) \\<union>\n              fst ` FV \\<Gamma>\n  distinct []\n  \\<forall>a\\<in>fst ` set [].\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set []. term_ok \\<Theta> a\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set [].\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip [] (map snd (map fst [])))\n(map snd []))\n                                    point", "using B"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set [].\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set []) \\<union>\n               fst ` set []) \\<union>\n              fst ` FV \\<Gamma>\n  distinct []\n  \\<forall>a\\<in>fst ` set [].\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set []. term_ok \\<Theta> a\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set [].\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst [])\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip [] (map snd (map fst [])))\n(map snd []))\n                                    point", "using 1 point_def"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set [].\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set []) \\<union>\n               fst ` set []) \\<union>\n              fst ` FV \\<Gamma>\n  distinct []\n  \\<forall>a\\<in>fst ` set [].\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set []. term_ok \\<Theta> a\n  \\<forall>a\\<in>set [].\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set [].\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst [])\n  \\<Theta>,\\<Gamma> \\<turnstile> B\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst insts)\n                                    (map2 Fv fresh_idns\n(map snd (map fst insts))))\n                                  B\n  point \\<equiv>\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip [] (map snd (map fst [])))\n(map snd []))\n                                    point", "by auto"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip [] (map snd (map fst [])))\n                                    (map snd []))\n                                  point\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "case (snoc x xs y ys)"], ["proof (state)\nthis:\n  length xs = length ys\n  \\<lbrakk>\\<forall>idn\\<in>set xs.\n              idn\n              \\<notin> fst `\n                       (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                        fst ` set ys) \\<union>\n                       fst ` FV \\<Gamma>;\n   distinct xs;\n   \\<forall>a\\<in>fst ` set ys.\n      case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>);\n   \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a;\n   \\<forall>a\\<in>set ys.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n         b;\n   \\<forall>a\\<in>set ys.\n      case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>;\n   distinct (map fst ys)\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single])\n              (zip (zip xs (map snd (map fst ys))) (map snd ys)) point\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "from snoc"], ["proof (chain)\npicking this:\n  length xs = length ys\n  \\<lbrakk>\\<forall>idn\\<in>set xs.\n              idn\n              \\<notin> fst `\n                       (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                        fst ` set ys) \\<union>\n                       fst ` FV \\<Gamma>;\n   distinct xs;\n   \\<forall>a\\<in>fst ` set ys.\n      case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>);\n   \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a;\n   \\<forall>a\\<in>set ys.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n         b;\n   \\<forall>a\\<in>set ys.\n      case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>;\n   distinct (map fst ys)\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single])\n              (zip (zip xs (map snd (map fst ys))) (map snd ys)) point\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))", "have typ_ofy: \"typ_of (snd y) = Some (snd (fst y))\""], ["proof (prove)\nusing this:\n  length xs = length ys\n  \\<lbrakk>\\<forall>idn\\<in>set xs.\n              idn\n              \\<notin> fst `\n                       (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                        fst ` set ys) \\<union>\n                       fst ` FV \\<Gamma>;\n   distinct xs;\n   \\<forall>a\\<in>fst ` set ys.\n      case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>);\n   \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a;\n   \\<forall>a\\<in>set ys.\n      case a of\n      (a, b) \\<Rightarrow>\n        (case a of\n         (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n         b;\n   \\<forall>a\\<in>set ys.\n      case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>;\n   distinct (map fst ys)\\<rbrakk>\n  \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n              (\\<lambda>single. subst_term [single])\n              (zip (zip xs (map snd (map fst ys))) (map snd ys)) point\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))\n\ngoal (1 subgoal):\n 1. typ_of (snd y) = Some (snd (fst y))", "by auto"], ["proof (state)\nthis:\n  typ_of (snd y) = Some (snd (fst y))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "have 1: \" \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n            (zip (zip xs (map snd (map fst ys))) (map snd ys))\n            point\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip xs (map snd (map fst ys)))\n(map snd ys))\n                                    point", "apply (rule snoc.IH)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<forall>idn\\<in>set xs.\n       idn\n       \\<notin> fst `\n                (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                 fst ` set ys) \\<union>\n                fst ` FV \\<Gamma>\n 2. distinct xs\n 3. \\<forall>a\\<in>fst ` set ys.\n       case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n 4. \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a\n 5. \\<forall>a\\<in>set ys.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n          b\n 6. \\<forall>a\\<in>set ys.\n       case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n 7. distinct (map fst ys)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>idn\\<in>set xs.\n       idn\n       \\<notin> fst `\n                (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                 fst ` set ys) \\<union>\n                fst ` FV \\<Gamma>", "using snoc.prems(1)"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<forall>idn\\<in>set xs.\n       idn\n       \\<notin> fst `\n                (fv B \\<union> \\<Union> (fv ` snd ` set ys) \\<union>\n                 fst ` set ys) \\<union>\n                fst ` FV \\<Gamma>", "by (clarsimp split: prod.splits) (smt UN_I Un_iff fst_conv image_iff)"], ["proof (prove)\ngoal (6 subgoals):\n 1. distinct xs\n 2. \\<forall>a\\<in>fst ` set ys.\n       case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n 3. \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a\n 4. \\<forall>a\\<in>set ys.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n          b\n 5. \\<forall>a\\<in>set ys.\n       case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n 6. distinct (map fst ys)", "using snoc.prems(2-7)"], ["proof (prove)\nusing this:\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))\n\ngoal (6 subgoals):\n 1. distinct xs\n 2. \\<forall>a\\<in>fst ` set ys.\n       case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n 3. \\<forall>a\\<in>snd ` set ys. term_ok \\<Theta> a\n 4. \\<forall>a\\<in>set ys.\n       case a of\n       (a, b) \\<Rightarrow>\n         (case a of\n          (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n          b\n 5. \\<forall>a\\<in>set ys.\n       case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n 6. distinct (map fst ys)", "by auto"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip xs (map snd (map fst ys)))\n                                    (map snd ys))\n                                  point\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "moreover"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip xs (map snd (map fst ys)))\n                                    (map snd ys))\n                                  point\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "obtain yn n where ynn: \"fst y = (yn, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>yn n. fst y = (yn, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  fst y = (yn, n)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "moreover"], ["proof (state)\nthis:\n  fst y = (yn, n)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "have \"\\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, snd (fst y)), snd y)] (fold (\\<lambda>single. subst_term [single])\n            (zip (zip (xs) (map snd (map fst (ys))))\n              (map snd (ys)))\n            point)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, snd (fst y)), snd y)]\n                                    (fold\n(\\<lambda>single. subst_term [single])\n(zip (zip xs (map snd (map fst ys))) (map snd ys)) point)", "apply (simp only: ynn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, snd (yn, n)), snd y)]\n                                    (fold\n(\\<lambda>single. subst_term [single])\n(zip (zip xs (map snd (map fst ys))) (map snd ys)) point)", "apply (rule inst_var)"], ["proof (prove)\ngoal (5 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip xs (map snd (map fst ys)))\n(map snd ys))\n                                    point\n 3. term_ok \\<Theta> (snd y)\n 4. typ_of (snd y) = Some (snd (yn, n))\n 5. (x, snd (yn, n)) \\<notin> FV \\<Gamma>", "using snoc.prems \\<open>wf_theory \\<Theta>\\<close> 1"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))\n  wf_theory \\<Theta>\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip xs (map snd (map fst ys)))\n                                    (map snd ys))\n                                  point\n\ngoal (5 subgoals):\n 1. wf_theory \\<Theta>\n 2. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip xs (map snd (map fst ys)))\n(map snd ys))\n                                    point\n 3. term_ok \\<Theta> (snd y)\n 4. typ_of (snd y) = Some (snd (yn, n))\n 5. (x, snd (yn, n)) \\<notin> FV \\<Gamma>", "apply (solves simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. typ_of (snd y) = Some (snd (yn, n))\n 2. (x, snd (yn, n)) \\<notin> FV \\<Gamma>", "using typ_ofy ynn"], ["proof (prove)\nusing this:\n  typ_of (snd y) = Some (snd (fst y))\n  fst y = (yn, n)\n\ngoal (2 subgoals):\n 1. typ_of (snd y) = Some (snd (yn, n))\n 2. (x, snd (yn, n)) \\<notin> FV \\<Gamma>", "apply (simp add: wt_term_def typ_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, snd (yn, n)) \\<notin> FV \\<Gamma>", "using snoc.prems"], ["proof (prove)\nusing this:\n  \\<forall>idn\\<in>set (xs @ [x]).\n     idn\n     \\<notin> fst `\n              (fv B \\<union> \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n               fst ` set (ys @ [y])) \\<union>\n              fst ` FV \\<Gamma>\n  distinct (xs @ [x])\n  \\<forall>a\\<in>fst ` set (ys @ [y]).\n     case a of (x, \\<tau>) \\<Rightarrow> term_ok \\<Theta> (Fv x \\<tau>)\n  \\<forall>a\\<in>snd ` set (ys @ [y]). term_ok \\<Theta> a\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of\n     (a, b) \\<Rightarrow>\n       (case a of\n        (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n        b\n  \\<forall>a\\<in>set (ys @ [y]).\n     case a of (v, uu_) \\<Rightarrow> v \\<notin> FV \\<Gamma>\n  distinct (map fst (ys @ [y]))\n\ngoal (1 subgoal):\n 1. (x, snd (yn, n)) \\<notin> FV \\<Gamma>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> fst (fst y) \\<and>\n             x \\<notin> fst `\n                        (fv B \\<union>\n                         (fv (snd y) \\<union>\n                          (\\<Union>a\\<in>set ys. fv (snd a))) \\<union>\n                         fst ` set ys) \\<and>\n             x \\<notin> fst ` \\<Union> (fv ` \\<Gamma>) \\<and>\n             (\\<forall>idn\\<in>set xs.\n                 idn \\<noteq> fst (fst y) \\<and>\n                 idn\n                 \\<notin> fst `\n                          (fv B \\<union>\n                           (fv (snd y) \\<union>\n                            (\\<Union>a\\<in>set ys. fv (snd a))) \\<union>\n                           fst ` set ys) \\<and>\n                 idn \\<notin> fst ` \\<Union> (fv ` \\<Gamma>));\n     distinct xs \\<and> x \\<notin> set xs;\n     (case fst y of\n      (x, \\<tau>) \\<Rightarrow> wt_term (sig \\<Theta>) (Fv x \\<tau>)) \\<and>\n     (\\<forall>x\\<in>set ys.\n         case fst x of\n         (x, \\<tau>) \\<Rightarrow> wt_term (sig \\<Theta>) (Fv x \\<tau>));\n     wt_term (sig \\<Theta>) (snd y) \\<and>\n     (\\<forall>x\\<in>set ys. wt_term (sig \\<Theta>) (snd x));\n     (case y of\n      (x, xa) \\<Rightarrow>\n        (case x of\n         (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n         xa) \\<and>\n     (\\<forall>x\\<in>set ys.\n         case x of\n         (x, xa) \\<Rightarrow>\n           (case x of\n            (uu_, \\<tau>) \\<Rightarrow> \\<lambda>a. typ_of a = Some \\<tau>)\n            xa);\n     (case y of\n      (v, uu_) \\<Rightarrow>\n        \\<forall>x\\<in>\\<Gamma>. v \\<notin> fv x) \\<and>\n     (\\<forall>x\\<in>set ys.\n         case x of\n         (v, uu_) \\<Rightarrow> \\<forall>x\\<in>\\<Gamma>. v \\<notin> fv x);\n     distinct (map fst ys) \\<and> fst y \\<notin> fst ` set ys\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa\\<in>\\<Gamma>. (x, n) \\<notin> fv xa", "by (metis (full_types, hide_lams) UN_I fst_conv image_eqI)"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, snd (fst y)), snd y)]\n                                  (fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip xs (map snd (map fst ys)))\n(map snd ys))\n                                    point)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "moreover"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, snd (fst y)), snd y)]\n                                  (fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip xs (map snd (map fst ys)))\n(map snd ys))\n                                    point)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "have \"fold (\\<lambda>single. subst_term [single])\n            (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n              (map snd (ys @ [y])))\n            point = subst_term [((x, snd (fst y)), snd y)] (fold (\\<lambda>single. subst_term [single])\n            (zip (zip (xs) (map snd (map fst (ys))))\n              (map snd (ys)))\n            point)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_term [single])\n     (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n       (map snd (ys @ [y])))\n     point =\n    subst_term [((x, snd (fst y)), snd y)]\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (zip xs (map snd (map fst ys))) (map snd ys)) point)", "using snoc.hyps"], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>single. subst_term [single])\n     (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n       (map snd (ys @ [y])))\n     point =\n    subst_term [((x, snd (fst y)), snd y)]\n     (fold (\\<lambda>single. subst_term [single])\n       (zip (zip xs (map snd (map fst ys))) (map snd ys)) point)", "by (induction xs ys rule: list_induct2) simp_all"], ["proof (state)\nthis:\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n     (map snd (ys @ [y])))\n   point =\n  subst_term [((x, snd (fst y)), snd y)]\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (zip xs (map snd (map fst ys))) (map snd ys)) point)\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>\\<forall>idn\\<in>set xs.\n                    idn\n                    \\<notin> fst `\n                             (fv B \\<union>\n                              \\<Union> (fv ` snd ` set ys) \\<union>\n                              fst ` set ys) \\<union>\n                             fst ` FV \\<Gamma>;\n         distinct xs;\n         \\<forall>(x, \\<tau>)\\<in>fst ` set ys.\n            term_ok \\<Theta> (Fv x \\<tau>);\n         Ball (snd ` set ys) (term_ok \\<Theta>);\n         \\<forall>((uu_, \\<tau>), a)\\<in>set ys. typ_of a = Some \\<tau>;\n         \\<forall>(v, uu_)\\<in>set ys. v \\<notin> FV \\<Gamma>;\n         distinct (map fst ys)\\<rbrakk>\n        \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                    (\\<lambda>single. subst_term [single])\n                    (zip (zip xs (map snd (map fst ys))) (map snd ys))\n                    point;\n        \\<forall>idn\\<in>set (xs @ [x]).\n           idn\n           \\<notin> fst `\n                    (fv B \\<union>\n                     \\<Union> (fv ` snd ` set (ys @ [y])) \\<union>\n                     fst ` set (ys @ [y])) \\<union>\n                    fst ` FV \\<Gamma>;\n        distinct (xs @ [x]);\n        \\<forall>(x, \\<tau>)\\<in>fst ` set (ys @ [y]).\n           term_ok \\<Theta> (Fv x \\<tau>);\n        Ball (snd ` set (ys @ [y])) (term_ok \\<Theta>);\n        \\<forall>((uu_, \\<tau>), a)\\<in>set (ys @ [y]).\n           typ_of a = Some \\<tau>;\n        \\<forall>(v, uu_)\\<in>set (ys @ [y]). v \\<notin> FV \\<Gamma>;\n        distinct (map fst (ys @ [y]))\\<rbrakk>\n       \\<Longrightarrow> \\<Theta>,\\<Gamma> \\<turnstile> fold\n                   (\\<lambda>single. subst_term [single])\n                   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n                     (map snd (ys @ [y])))\n                   point", "ultimately"], ["proof (chain)\npicking this:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip xs (map snd (map fst ys)))\n                                    (map snd ys))\n                                  point\n  fst y = (yn, n)\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, snd (fst y)), snd y)]\n                                  (fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip xs (map snd (map fst ys)))\n(map snd ys))\n                                    point)\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n     (map snd (ys @ [y])))\n   point =\n  subst_term [((x, snd (fst y)), snd y)]\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (zip xs (map snd (map fst ys))) (map snd ys)) point)", "show ?case"], ["proof (prove)\nusing this:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip xs (map snd (map fst ys)))\n                                    (map snd ys))\n                                  point\n  fst y = (yn, n)\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term [((x, snd (fst y)), snd y)]\n                                  (fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip (zip xs (map snd (map fst ys)))\n(map snd ys))\n                                    point)\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip (xs @ [x]) (map snd (map fst (ys @ [y]))))\n     (map snd (ys @ [y])))\n   point =\n  subst_term [((x, snd (fst y)), snd y)]\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (zip xs (map snd (map fst ys))) (map snd ys)) point)\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> fold\n                                    (\\<lambda>single. subst_term [single])\n                                    (zip\n(zip (xs @ [x]) (map snd (map fst (ys @ [y])))) (map snd (ys @ [y])))\n                                    point", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip (xs @ [x])\n   (map snd (map fst (ys @ [y]))))\n                                    (map snd (ys @ [y])))\n                                  point\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip fresh_idns\n   (map snd (map fst insts)))\n                                    (map snd insts))\n                                  point\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B", "from 0 1 2"], ["proof (chain)\npicking this:\n  subst_term insts B =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B)\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst insts)\n                                    (map2 Fv fresh_idns\n(map snd (map fst insts))))\n                                  B\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip fresh_idns\n   (map snd (map fst insts)))\n                                    (map snd insts))\n                                  point", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_term insts B =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B)\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst insts)\n                                    (map2 Fv fresh_idns\n(map snd (map fst insts))))\n                                  B\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip fresh_idns\n   (map snd (map fst insts)))\n                                    (map snd insts))\n                                  point\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B", "using point_def"], ["proof (prove)\nusing this:\n  subst_term insts B =\n  fold (\\<lambda>single. subst_term [single])\n   (zip (zip fresh_idns (map snd (map fst insts))) (map snd insts))\n   (fold (\\<lambda>single. subst_term [single])\n     (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B)\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (map fst insts)\n                                    (map2 Fv fresh_idns\n(map snd (map fst insts))))\n                                  B\n  \\<Theta>,\\<Gamma> \\<turnstile> fold (\\<lambda>single. subst_term [single])\n                                  (zip (zip fresh_idns\n   (map snd (map fst insts)))\n                                    (map snd insts))\n                                  point\n  point \\<equiv>\n  fold (\\<lambda>single. subst_term [single])\n   (zip (map fst insts) (map2 Fv fresh_idns (map snd (map fst insts)))) B\n\ngoal (1 subgoal):\n 1. \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B", "by simp"], ["proof (state)\nthis:\n  \\<Theta>,\\<Gamma> \\<turnstile> subst_term insts B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma term_ok_eta_red_step: \n  \"\\<not> is_dependent t \\<Longrightarrow> term_ok \\<Theta> (Abs T (t $ Bv 0)) \\<Longrightarrow> term_ok \\<Theta> (decr 0 t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_dependent t;\n     term_ok \\<Theta> (Abs T (t $ Bv 0))\\<rbrakk>\n    \\<Longrightarrow> term_ok \\<Theta> (decr 0 t)", "unfolding term_ok_def wt_term_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_dependent t;\n     wf_term (sig \\<Theta>) (Abs T (t $ Bv 0)) \\<and>\n     (\\<exists>Ta. \\<turnstile>\\<^sub>\\<tau> Abs T (t $ Bv 0) : Ta)\\<rbrakk>\n    \\<Longrightarrow> wf_term (sig \\<Theta>) (decr 0 t) \\<and>\n                      (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> decr 0 t : T)", "using term_ok'_decr eta_preserves_typ_of"], ["proof (prove)\nusing this:\n  term_ok' ?\\<Sigma> ?t \\<Longrightarrow> term_ok' ?\\<Sigma> (decr ?i ?t)\n  \\<lbrakk>?t \\<rightarrow>\\<^sub>\\<eta> ?t';\n   typ_of ?t = Some ?\\<tau>\\<rbrakk>\n  \\<Longrightarrow> typ_of ?t' = Some ?\\<tau>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> is_dependent t;\n     wf_term (sig \\<Theta>) (Abs T (t $ Bv 0)) \\<and>\n     (\\<exists>Ta. \\<turnstile>\\<^sub>\\<tau> Abs T (t $ Bv 0) : Ta)\\<rbrakk>\n    \\<Longrightarrow> wf_term (sig \\<Theta>) (decr 0 t) \\<and>\n                      (\\<exists>T. \\<turnstile>\\<^sub>\\<tau> decr 0 t : T)", "by simp blast"], ["", "end"]]}