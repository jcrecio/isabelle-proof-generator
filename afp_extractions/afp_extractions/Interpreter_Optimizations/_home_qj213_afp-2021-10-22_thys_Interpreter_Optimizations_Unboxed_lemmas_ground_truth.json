{"file_name": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations/Unboxed_lemmas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations", "problem_names": ["lemma typeof_bind_OpDyn[simp]: \"typeof \\<circ> OpDyn = (\\<lambda>_. None)\"", "lemma is_dyn_operand_eq_typeof: \"is_dyn_operand = (\\<lambda>x. typeof x = None)\"", "lemma is_dyn_operand_eq_typeof_Dyn[simp]: \"is_dyn_operand x \\<longleftrightarrow> typeof x = None\"", "lemma typeof_unboxed_eq_const:\n  fixes x\n  shows\n    \"typeof x = None \\<longleftrightarrow> (\\<exists>d. x = OpDyn d)\"\n    \"typeof x = Some Ubx1 \\<longleftrightarrow> (\\<exists>n. x = OpUbx1 n)\"\n    \"typeof x = Some Ubx2 \\<longleftrightarrow> (\\<exists>b. x = OpUbx2 b)\"", "lemmas typeof_unboxed_inversion = typeof_unboxed_eq_const[THEN iffD1]", "lemma cast_inversions:\n  \"cast_Dyn x = Some d \\<Longrightarrow> x = OpDyn d\"\n  \"cast_Ubx1 x = Some n \\<Longrightarrow> x = OpUbx1 n\"\n  \"cast_Ubx2 x = Some b \\<Longrightarrow> x = OpUbx2 b\"", "lemma traverse_cast_Dyn_replicate:\n  assumes \"traverse cast_Dyn xs = Some ys\"\n  shows \"map typeof xs = replicate (length xs) None\"", "lemma unbox_typeof[simp]: \"unbox \\<tau> d = Some blob \\<Longrightarrow> typeof blob = Some \\<tau>\"", "lemma cast_and_box_imp_typeof[simp]: \"cast_and_box \\<tau> blob = Some d \\<Longrightarrow> typeof blob = Some \\<tau>\"", "lemma norm_unbox_inverse[simp]: \"unbox \\<tau> d = Some blob \\<Longrightarrow> norm_unboxed blob = d\"", "lemma norm_cast_and_box_inverse[simp]:\n  \"cast_and_box \\<tau> blob = Some d \\<Longrightarrow> norm_unboxed blob = d\"", "lemma typeof_and_norm_unboxed_imp_cast_and_box:\n  assumes \"typeof x' = Some \\<tau>\" \"norm_unboxed x' = x\"\n  shows \"cast_and_box \\<tau> x' = Some x\"", "lemma norm_unboxed_bind_OpDyn[simp]: \"norm_unboxed \\<circ> OpDyn = id\"", "lemmas box_stack_Nil[simp] = list.map(1)[of \"box_frame f\" for f, folded box_stack_def]", "lemmas box_stack_Cons[simp] = list.map(2)[of \"box_frame f\" for f, folded box_stack_def]", "lemma typeof_box_operand[simp]: \"typeof (box_operand x) = None\"", "lemma is_dyn_box_operand: \"is_dyn_operand (box_operand x)\"", "lemma is_dyn_operand_comp_box_operand[simp]: \"is_dyn_operand \\<circ> box_operand = (\\<lambda>_. True)\"", "lemma norm_box_operand[simp]: \"norm_unboxed (box_operand x) = norm_unboxed x\""], "translations": [["", "lemma typeof_bind_OpDyn[simp]: \"typeof \\<circ> OpDyn = (\\<lambda>_. None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof \\<circ> OpDyn = Map.empty", "by auto"], ["", "lemma is_dyn_operand_eq_typeof: \"is_dyn_operand = (\\<lambda>x. typeof x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_dyn_operand = (\\<lambda>x. typeof x = None)", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_dyn_operand x = (typeof x = None)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. is_dyn_operand x = (typeof x = None)", "show \"is_dyn_operand x = (typeof x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_dyn_operand x = (typeof x = None)", "by (cases x; simp)"], ["proof (state)\nthis:\n  is_dyn_operand x = (typeof x = None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_dyn_operand_eq_typeof_Dyn[simp]: \"is_dyn_operand x \\<longleftrightarrow> typeof x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_dyn_operand x = (typeof x = None)", "by (cases x; simp)"], ["", "lemma typeof_unboxed_eq_const:\n  fixes x\n  shows\n    \"typeof x = None \\<longleftrightarrow> (\\<exists>d. x = OpDyn d)\"\n    \"typeof x = Some Ubx1 \\<longleftrightarrow> (\\<exists>n. x = OpUbx1 n)\"\n    \"typeof x = Some Ubx2 \\<longleftrightarrow> (\\<exists>b. x = OpUbx2 b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (typeof x = None) = (\\<exists>d. x = OpDyn d) &&&\n    (typeof x = Some Ubx1) = (\\<exists>n. x = OpUbx1 n) &&&\n    (typeof x = Some Ubx2) = (\\<exists>b. x = OpUbx2 b)", "by (cases x; simp)+"], ["", "lemmas typeof_unboxed_inversion = typeof_unboxed_eq_const[THEN iffD1]"], ["", "lemma cast_inversions:\n  \"cast_Dyn x = Some d \\<Longrightarrow> x = OpDyn d\"\n  \"cast_Ubx1 x = Some n \\<Longrightarrow> x = OpUbx1 n\"\n  \"cast_Ubx2 x = Some b \\<Longrightarrow> x = OpUbx2 b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast_Dyn x = Some d \\<Longrightarrow> x = OpDyn d) &&&\n    (cast_Ubx1 x = Some n \\<Longrightarrow> x = OpUbx1 n) &&&\n    (cast_Ubx2 x = Some b \\<Longrightarrow> x = OpUbx2 b)", "by (cases x; simp)+"], ["", "lemma traverse_cast_Dyn_replicate:\n  assumes \"traverse cast_Dyn xs = Some ys\"\n  shows \"map typeof xs = replicate (length xs) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map typeof xs = replicate (length xs) None", "using assms"], ["proof (prove)\nusing this:\n  traverse cast_Dyn xs = Some ys\n\ngoal (1 subgoal):\n 1. map typeof xs = replicate (length xs) None", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       traverse cast_Dyn [] = Some ys \\<Longrightarrow>\n       map typeof [] = replicate (length []) None\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   map typeof xs = replicate (length xs) None;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> map typeof (a # xs) =\n                         replicate (length (a # xs)) None", "case Nil"], ["proof (state)\nthis:\n  traverse cast_Dyn [] = Some ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       traverse cast_Dyn [] = Some ys \\<Longrightarrow>\n       map typeof [] = replicate (length []) None\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   map typeof xs = replicate (length xs) None;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> map typeof (a # xs) =\n                         replicate (length (a # xs)) None", "then"], ["proof (chain)\npicking this:\n  traverse cast_Dyn [] = Some ys", "show ?case"], ["proof (prove)\nusing this:\n  traverse cast_Dyn [] = Some ys\n\ngoal (1 subgoal):\n 1. map typeof [] = replicate (length []) None", "by simp"], ["proof (state)\nthis:\n  map typeof [] = replicate (length []) None\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   map typeof xs = replicate (length xs) None;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> map typeof (a # xs) =\n                         replicate (length (a # xs)) None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   map typeof xs = replicate (length xs) None;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> map typeof (a # xs) =\n                         replicate (length (a # xs)) None", "case (Cons x xs)"], ["proof (state)\nthis:\n  traverse cast_Dyn xs = Some ?ys \\<Longrightarrow>\n  map typeof xs = replicate (length xs) None\n  traverse cast_Dyn (x # xs) = Some ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   map typeof xs = replicate (length xs) None;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> map typeof (a # xs) =\n                         replicate (length (a # xs)) None", "from Cons.prems"], ["proof (chain)\npicking this:\n  traverse cast_Dyn (x # xs) = Some ys", "show ?case"], ["proof (prove)\nusing this:\n  traverse cast_Dyn (x # xs) = Some ys\n\ngoal (1 subgoal):\n 1. map typeof (x # xs) = replicate (length (x # xs)) None", "by (auto intro: Cons.IH dest: cast_inversions(1) simp add: bind_eq_Some_conv)"], ["proof (state)\nthis:\n  map typeof (x # xs) = replicate (length (x # xs)) None\n\ngoal:\nNo subgoals!", "qed"], ["", "context unboxedval begin"], ["", "lemma unbox_typeof[simp]: \"unbox \\<tau> d = Some blob \\<Longrightarrow> typeof blob = Some \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unbox \\<tau> d = Some blob \\<Longrightarrow> typeof blob = Some \\<tau>", "by (cases \\<tau>; auto)"], ["", "lemma cast_and_box_imp_typeof[simp]: \"cast_and_box \\<tau> blob = Some d \\<Longrightarrow> typeof blob = Some \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast_and_box \\<tau> blob = Some d \\<Longrightarrow>\n    typeof blob = Some \\<tau>", "using cast_inversions[of blob]"], ["proof (prove)\nusing this:\n  cast_Dyn blob = Some ?d \\<Longrightarrow> blob = OpDyn ?d\n  cast_Ubx1 blob = Some ?n \\<Longrightarrow> blob = OpUbx1 ?n\n  cast_Ubx2 blob = Some ?b \\<Longrightarrow> blob = OpUbx2 ?b\n\ngoal (1 subgoal):\n 1. cast_and_box \\<tau> blob = Some d \\<Longrightarrow>\n    typeof blob = Some \\<tau>", "by (induction \\<tau>; auto dest: cast_inversions[of blob])"], ["", "lemma norm_unbox_inverse[simp]: \"unbox \\<tau> d = Some blob \\<Longrightarrow> norm_unboxed blob = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unbox \\<tau> d = Some blob \\<Longrightarrow> norm_unboxed blob = d", "using box_unbox_inverse"], ["proof (prove)\nusing this:\n  unbox_ubx1 ?d = Some ?u1.0 \\<Longrightarrow> box_ubx1 ?u1.0 = ?d\n  unbox_ubx2 ?d = Some ?u2.0 \\<Longrightarrow> box_ubx2 ?u2.0 = ?d\n\ngoal (1 subgoal):\n 1. unbox \\<tau> d = Some blob \\<Longrightarrow> norm_unboxed blob = d", "by (cases \\<tau>; auto)"], ["", "lemma norm_cast_and_box_inverse[simp]:\n  \"cast_and_box \\<tau> blob = Some d \\<Longrightarrow> norm_unboxed blob = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast_and_box \\<tau> blob = Some d \\<Longrightarrow>\n    norm_unboxed blob = d", "by (induction \\<tau>; auto elim: cast_Dyn.elims cast_Ubx1.elims cast_Ubx2.elims)"], ["", "lemma typeof_and_norm_unboxed_imp_cast_and_box:\n  assumes \"typeof x' = Some \\<tau>\" \"norm_unboxed x' = x\"\n  shows \"cast_and_box \\<tau> x' = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast_and_box \\<tau> x' = Some x", "using assms"], ["proof (prove)\nusing this:\n  typeof x' = Some \\<tau>\n  norm_unboxed x' = x\n\ngoal (1 subgoal):\n 1. cast_and_box \\<tau> x' = Some x", "by (induction \\<tau>; induction x'; simp)"], ["", "lemma norm_unboxed_bind_OpDyn[simp]: \"norm_unboxed \\<circ> OpDyn = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unboxed \\<circ> OpDyn = id", "by auto"], ["", "lemmas box_stack_Nil[simp] = list.map(1)[of \"box_frame f\" for f, folded box_stack_def]"], ["", "lemmas box_stack_Cons[simp] = list.map(2)[of \"box_frame f\" for f, folded box_stack_def]"], ["", "lemma typeof_box_operand[simp]: \"typeof (box_operand x) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof (box_operand x) = None", "by (cases x; simp)"], ["", "lemma is_dyn_box_operand: \"is_dyn_operand (box_operand x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_dyn_operand (box_operand x)", "by (cases x) simp_all"], ["", "lemma is_dyn_operand_comp_box_operand[simp]: \"is_dyn_operand \\<circ> box_operand = (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_dyn_operand \\<circ> box_operand = (\\<lambda>_. True)", "using is_dyn_box_operand"], ["proof (prove)\nusing this:\n  is_dyn_operand (box_operand ?x)\n\ngoal (1 subgoal):\n 1. is_dyn_operand \\<circ> box_operand = (\\<lambda>_. True)", "by auto"], ["", "lemma norm_box_operand[simp]: \"norm_unboxed (box_operand x) = norm_unboxed x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unboxed (box_operand x) = norm_unboxed x", "by (cases x) simp_all"], ["", "end"], ["", "end"]]}