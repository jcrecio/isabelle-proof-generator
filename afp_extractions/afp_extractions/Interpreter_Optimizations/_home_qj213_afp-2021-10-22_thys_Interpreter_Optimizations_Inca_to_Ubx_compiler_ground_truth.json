{"file_name": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations/Inca_to_Ubx_compiler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations", "problem_names": ["lemma rewrite_prog_map_f:\n  assumes \"\\<And>x \\<Sigma>1 n x' \\<Sigma>2. rewrite_instr n x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow> f x' = x\"\n  shows \"rewrite_prog n xs \\<Sigma>1 = Ok (ys, \\<Sigma>2) \\<Longrightarrow> map f ys = xs\"", "lemma sp_rewrite_prog:\n  assumes\n    \"rewrite_prog f n p1 \\<Sigma>1 = Ok (p2, \\<Sigma>2)\" and\n    \"\\<And>x \\<Sigma>1 n x' \\<Sigma>2. f n x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow> Subx.sp_instr F x' \\<Sigma>1 = Ok \\<Sigma>2\"\n  shows \"Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2\"", "lemma sp_lift_instr:\n  assumes\n    \"lift_instr instr \\<Sigma>1 = Ok (instr', \\<Sigma>2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x)\"\n  shows \"Subx.sp_instr F instr' \\<Sigma>1 = Ok \\<Sigma>2\"", "lemma sp_lift: \n  assumes\n    \"lift n p1 \\<Sigma>1 = Ok (p2, \\<Sigma>2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x)\"\n  shows \"Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2\"", "lemma norm_lift_instr: \"lift_instr x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow> norm_instr x' = x\"", "lemma norm_lift:\n  assumes \"lift n xs \\<Sigma>1 = Ok (ys, \\<Sigma>2)\"\n  shows \"map norm_instr ys = xs\"", "lemma\n  assumes\n    \"optim 0 [IPush d\\<^sub>1, IPush d\\<^sub>2, IStore y] [] = Ok (xs, ys)\"\n    \"unbox_ubx1 d\\<^sub>1 = Some x\"\n    \"unbox_ubx1 d\\<^sub>2 = None\" \"unbox_ubx2 d\\<^sub>2 = None\"\n  shows \"xs = [IPushUbx1 x, IPush d\\<^sub>2, IStoreUbx Ubx1 y] \\<and> ys = []\"", "lemma norm_optim_instr: \"optim_instr n x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow> norm_instr x' = norm_instr x\"\n    for x \\<Sigma>1 n x' \\<Sigma>2", "lemma norm_optim:\n  assumes \"optim n xs \\<Sigma>1 = Ok (ys, \\<Sigma>2)\"\n  shows \"map norm_instr ys = map norm_instr xs\"", "lemma sp_optim_instr:\n  assumes\n    \"optim_instr n instr \\<Sigma>1 = Ok (instr', \\<Sigma>2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x) \"\n  shows \"Subx.sp_instr F instr' \\<Sigma>1 = Ok \\<Sigma>2\"", "lemma sp_optim:\n  assumes\n    \"optim n p1 \\<Sigma>1 = Ok (p2, \\<Sigma>2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x)\"\n  shows \"Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2\"", "lemma rel_compile_fundef:\n  assumes \"compile_fundef fd1 = Ok fd2\"\n  shows \"rel_fundef norm_eq fd1 fd2\"", "lemma sp_compile_fundef:\n  assumes\n    \"compile_fundef fd1 = Ok fd2\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x)\"\n  shows \"sp_fundef F fd2 (body fd2) = Ok [None]\"", "lemma rel_compile_env_entry:\n  assumes \"compile_env_entry \\<O> \\<A> (f, fd1) = Ok (f, fd2)\"\n  shows \"rel_fundef norm_eq fd1 fd2\"", "lemma sp_compile_env_entry:\n  assumes\n    \"compile_env_entry \\<A> \\<O> (f, fd1) = Ok (f, fd2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> x) (F x)\"\n  shows \"sp_fundef F fd2 (body fd2) = Ok [None]\"", "lemma list_assoc_those_compile_env_entries:\n  \"Result.those (map (compile_env_entry \\<A> \\<O>) xs) = Ok ys \\<Longrightarrow>\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2) (map_of xs f) (map_of ys f)\"", "lemma compile_env_rel_compile_fundef:\n  assumes \"compile_env \\<A> \\<O> F1 = Ok F2\"\n  shows \"rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2) (Finca_get F1 f) (Fubx_get F2 f)\"", "lemma rel_those_compile_env_entries:\n  \"Result.those (map (compile_env_entry \\<A> \\<O>) xs) = Ok ys \\<Longrightarrow>\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list xs)) (Fubx_get (Subx.Fenv.from_list ys))\"", "lemma rel_fundefs_compile_env:\n  assumes \"compile_env \\<A> \\<O> e = Ok e'\"\n  shows \"rel_fundefs (Finca_get e) (Fubx_get e')\"", "lemma sp_fundefs_compile_env:\n  assumes\n    \"compile_env \\<A> \\<O> F1 = Ok F2\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> x) (Finca_get F1 x)\"\n  shows \"sp_fundefs (Fubx_get F2)\"", "lemma compile_load:\n  assumes\n    compile_p1: \"compile p1 = Some p2\" and\n    load: \"Subx.load p2 s2\"\n  shows \"\\<exists>s1. Sinca.load p1 s1 \\<and> match s1 s2\""], "translations": [["", "lemma rewrite_prog_map_f:\n  assumes \"\\<And>x \\<Sigma>1 n x' \\<Sigma>2. rewrite_instr n x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow> f x' = x\"\n  shows \"rewrite_prog n xs \\<Sigma>1 = Ok (ys, \\<Sigma>2) \\<Longrightarrow> map f ys = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rewrite_prog n xs \\<Sigma>1 = Ok (ys, \\<Sigma>2) \\<Longrightarrow>\n    map f ys = xs", "by (induction xs arbitrary: \\<Sigma>1 n ys; auto simp: assms)"], ["", "end"], ["", "fun gen_pop_push where\n  \"gen_pop_push instr (domain, codomain) \\<Sigma> = (\n    let ar = length domain in\n    if ar \\<le> length \\<Sigma> \\<and> take ar \\<Sigma> = domain then\n      Ok (instr, codomain # drop ar \\<Sigma>)\n    else\n      Error ()\n  )\""], ["", "context inca_to_ubx_simulation begin"], ["", "lemma sp_rewrite_prog:\n  assumes\n    \"rewrite_prog f n p1 \\<Sigma>1 = Ok (p2, \\<Sigma>2)\" and\n    \"\\<And>x \\<Sigma>1 n x' \\<Sigma>2. f n x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow> Subx.sp_instr F x' \\<Sigma>1 = Ok \\<Sigma>2\"\n  shows \"Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2", "using assms(1)"], ["proof (prove)\nusing this:\n  rewrite_prog f n p1 \\<Sigma>1 = Ok (p2, \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2", "by (induction p1 arbitrary: \\<Sigma>1 n p2; auto simp: assms(2))"], ["", "section \\<open>Lifting\\<close>"], ["", "context\n  fixes\n    get_arity :: \"'fun \\<Rightarrow> nat option\" and\n    load_oracle :: \"nat \\<Rightarrow> type option\"\nbegin"], ["", "fun lift_instr where\n  \"lift_instr (Inca.IPush x) \\<Sigma> = Ok (IPush x, None # \\<Sigma>)\" |\n  \"lift_instr Inca.IPop (_ # \\<Sigma>) = Ok (IPop, \\<Sigma>)\" |\n  \"lift_instr (Inca.ILoad x) (None # \\<Sigma>) = Ok (ILoad x, None # \\<Sigma>)\" |\n  \"lift_instr (Inca.IStore x) (None # None # \\<Sigma>) = Ok (IStore x, \\<Sigma>)\" |\n  \"lift_instr (Inca.IOp op) \\<Sigma> = gen_pop_push (IOp op) (replicate (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op) None, None) \\<Sigma>\" |\n  \"lift_instr (Inca.IOpInl opinl) \\<Sigma> =\n    gen_pop_push (IOpInl opinl) (replicate (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)) None, None) \\<Sigma>\" |\n  \"lift_instr (Inca.ICall f) \\<Sigma> = do {\n    ar \\<leftarrow> Result.of_option () (get_arity f);\n    gen_pop_push (ICall f) (replicate ar None, None) \\<Sigma>\n  }\" |\n  \"lift_instr _ _ = Error ()\""], ["", "definition lift where\n  \"lift = rewrite_prog (\\<lambda>_. lift_instr)\""], ["", "lemma sp_lift_instr:\n  assumes\n    \"lift_instr instr \\<Sigma>1 = Ok (instr', \\<Sigma>2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x)\"\n  shows \"Subx.sp_instr F instr' \\<Sigma>1 = Ok \\<Sigma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp_instr F instr' \\<Sigma>1 = Ok \\<Sigma>2", "using assms(1)"], ["proof (prove)\nusing this:\n  lift_instr instr \\<Sigma>1 = Ok (instr', \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. Subx.sp_instr F instr' \\<Sigma>1 = Ok \\<Sigma>2", "proof (induction instr \\<Sigma>1 rule: lift_instr.induct)"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.IPush x) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 2. \\<And>uu_ \\<Sigma>.\n       lift_instr Inca.instr.IPop (uu_ # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (uu_ # \\<Sigma>) = Ok \\<Sigma>2\n 3. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # \\<Sigma>) = Ok \\<Sigma>2\n 4. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # None # \\<Sigma>) = Ok \\<Sigma>2\n 5. \\<And>op \\<Sigma>.\n       lift_instr (Inca.instr.IOp op) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 6. \\<And>opinl \\<Sigma>.\n       lift_instr (Inca.instr.IOpInl opinl) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 7. \\<And>f \\<Sigma>.\n       lift_instr (Inca.instr.ICall f) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 8. lift_instr Inca.instr.IPop [] = Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' [] = Ok \\<Sigma>2\n 9. \\<And>v.\n       lift_instr (Inca.instr.ILoad v) [] =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' [] = Ok \\<Sigma>2\n 10. \\<And>v vc vb.\n        lift_instr (Inca.instr.ILoad v) (Some vc # vb) =\n        Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n        Subx.sp_instr F instr' (Some vc # vb) = Ok \\<Sigma>2\nA total of 15 subgoals...", "fix f \\<Sigma> n"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.IPush x) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 2. \\<And>uu_ \\<Sigma>.\n       lift_instr Inca.instr.IPop (uu_ # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (uu_ # \\<Sigma>) = Ok \\<Sigma>2\n 3. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # \\<Sigma>) = Ok \\<Sigma>2\n 4. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # None # \\<Sigma>) = Ok \\<Sigma>2\n 5. \\<And>op \\<Sigma>.\n       lift_instr (Inca.instr.IOp op) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 6. \\<And>opinl \\<Sigma>.\n       lift_instr (Inca.instr.IOpInl opinl) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 7. \\<And>f \\<Sigma>.\n       lift_instr (Inca.instr.ICall f) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 8. lift_instr Inca.instr.IPop [] = Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' [] = Ok \\<Sigma>2\n 9. \\<And>v.\n       lift_instr (Inca.instr.ILoad v) [] =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' [] = Ok \\<Sigma>2\n 10. \\<And>v vc vb.\n        lift_instr (Inca.instr.ILoad v) (Some vc # vb) =\n        Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n        Subx.sp_instr F instr' (Some vc # vb) = Ok \\<Sigma>2\nA total of 15 subgoals...", "assume \"lift_instr (Inca.ICall f) \\<Sigma> = Ok (instr', \\<Sigma>2)\""], ["proof (state)\nthis:\n  lift_instr (Inca.instr.ICall f) \\<Sigma> = Ok (instr', \\<Sigma>2)\n\ngoal (15 subgoals):\n 1. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.IPush x) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 2. \\<And>uu_ \\<Sigma>.\n       lift_instr Inca.instr.IPop (uu_ # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (uu_ # \\<Sigma>) = Ok \\<Sigma>2\n 3. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # \\<Sigma>) = Ok \\<Sigma>2\n 4. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # None # \\<Sigma>) = Ok \\<Sigma>2\n 5. \\<And>op \\<Sigma>.\n       lift_instr (Inca.instr.IOp op) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 6. \\<And>opinl \\<Sigma>.\n       lift_instr (Inca.instr.IOpInl opinl) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 7. \\<And>f \\<Sigma>.\n       lift_instr (Inca.instr.ICall f) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 8. lift_instr Inca.instr.IPop [] = Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' [] = Ok \\<Sigma>2\n 9. \\<And>v.\n       lift_instr (Inca.instr.ILoad v) [] =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' [] = Ok \\<Sigma>2\n 10. \\<And>v vc vb.\n        lift_instr (Inca.instr.ILoad v) (Some vc # vb) =\n        Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n        Subx.sp_instr F instr' (Some vc # vb) = Ok \\<Sigma>2\nA total of 15 subgoals...", "thus \"Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\""], ["proof (prove)\nusing this:\n  lift_instr (Inca.instr.ICall f) \\<Sigma> = Ok (instr', \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "using assms(2)[of f]"], ["proof (prove)\nusing this:\n  lift_instr (Inca.instr.ICall f) \\<Sigma> = Ok (instr', \\<Sigma>2)\n  rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity f) (F f)\n\ngoal (1 subgoal):\n 1. Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "by (auto simp: option_rel_Some1)"], ["proof (state)\nthis:\n  Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n\ngoal (14 subgoals):\n 1. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.IPush x) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 2. \\<And>uu_ \\<Sigma>.\n       lift_instr Inca.instr.IPop (uu_ # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (uu_ # \\<Sigma>) = Ok \\<Sigma>2\n 3. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # \\<Sigma>) = Ok \\<Sigma>2\n 4. \\<And>x \\<Sigma>.\n       lift_instr (Inca.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # None # \\<Sigma>) = Ok \\<Sigma>2\n 5. \\<And>op \\<Sigma>.\n       lift_instr (Inca.instr.IOp op) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 6. \\<And>opinl \\<Sigma>.\n       lift_instr (Inca.instr.IOpInl opinl) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 7. lift_instr Inca.instr.IPop [] = Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' [] = Ok \\<Sigma>2\n 8. \\<And>v.\n       lift_instr (Inca.instr.ILoad v) [] =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' [] = Ok \\<Sigma>2\n 9. \\<And>v vc vb.\n       lift_instr (Inca.instr.ILoad v) (Some vc # vb) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (Some vc # vb) = Ok \\<Sigma>2\n 10. \\<And>v.\n        lift_instr (Inca.instr.IStore v) [] =\n        Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n        Subx.sp_instr F instr' [] = Ok \\<Sigma>2\nA total of 14 subgoals...", "qed (auto simp add: Let_def)"], ["", "lemma sp_lift: \n  assumes\n    \"lift n p1 \\<Sigma>1 = Ok (p2, \\<Sigma>2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x)\"\n  shows \"Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2", "using assms"], ["proof (prove)\nusing this:\n  lift n p1 \\<Sigma>1 = Ok (p2, \\<Sigma>2)\n  rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity ?x51) (F ?x51)\n\ngoal (1 subgoal):\n 1. Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2", "by (auto elim!: sp_rewrite_prog sp_lift_instr simp: lift_def)"], ["", "lemma norm_lift_instr: \"lift_instr x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow> norm_instr x' = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_instr x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow>\n    norm_instr x' = x", "by (induction x \\<Sigma>1 rule: lift_instr.induct;\n        auto simp: Let_def )"], ["", "lemma norm_lift:\n  assumes \"lift n xs \\<Sigma>1 = Ok (ys, \\<Sigma>2)\"\n  shows \"map norm_instr ys = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map norm_instr ys = xs", "by (auto intro!: rewrite_prog_map_f[OF _ assms[unfolded lift_def]] simp: norm_lift_instr)"], ["", "section \\<open>Optimization\\<close>"], ["", "fun result_alternative :: \"('a, 'b) result \\<Rightarrow> ('a, 'b) result \\<Rightarrow> ('a, 'b) result\" (infixr \"<|>\" 51) where\n  \"result_alternative (Ok x) _ = Ok x\" |\n  \"result_alternative _ (Ok x) = Ok x\" |\n  \"result_alternative (Error e) _ = Error e\""], ["", "definition try_unbox where\n  \"try_unbox \\<tau> x \\<Sigma> unbox mk_instr \\<equiv>\n    (case unbox x of Some n \\<Rightarrow> Ok (mk_instr n, Some \\<tau> # \\<Sigma>) | None \\<Rightarrow> Error ())\""], ["", "fun optim_instr where\n  \"optim_instr _ (IPush d) \\<Sigma> =\n    try_unbox Ubx1 d \\<Sigma> unbox_ubx1 IPushUbx1 <|>\n    try_unbox Ubx2 d \\<Sigma> unbox_ubx2 IPushUbx2 <|>\n    Ok (IPush d, None # \\<Sigma>)\n  \" |\n  \"optim_instr _ (IPushUbx1 n) \\<Sigma> = Ok (IPushUbx1 n, Some Ubx1 # \\<Sigma>)\" |\n  \"optim_instr _ (IPushUbx2 b) \\<Sigma> = Ok (IPushUbx2 b, Some Ubx2 # \\<Sigma>)\" |\n  \"optim_instr _ IPop (_ # \\<Sigma>) = Ok (IPop, \\<Sigma>)\" |\n  \"optim_instr n (ILoad x) (None # \\<Sigma>) = (\n    case load_oracle n of\n      Some \\<tau> \\<Rightarrow> Ok (ILoadUbx \\<tau> x, Some \\<tau> # \\<Sigma>) |\n      _ \\<Rightarrow> Ok (ILoad x, None # \\<Sigma>)\n  )\" |\n  \"optim_instr _ (ILoadUbx \\<tau> x) (None # \\<Sigma>) = Ok (ILoadUbx \\<tau> x, Some \\<tau> # \\<Sigma>)\" |\n  \"optim_instr _ (IStore x) (None # None # \\<Sigma>) = Ok (IStore x, \\<Sigma>)\" |\n  \"optim_instr _ (IStore x) (None # Some \\<tau> # \\<Sigma>) = Ok (IStoreUbx \\<tau> x, \\<Sigma>)\" |\n  \"optim_instr _ (IStoreUbx \\<tau>\\<^sub>1 x) (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) = (if \\<tau>\\<^sub>1 = \\<tau>\\<^sub>2 then Ok (IStoreUbx \\<tau>\\<^sub>1 x, \\<Sigma>) else Error ())\" |\n  \"optim_instr _ (IOp op) \\<Sigma> = gen_pop_push (IOp op) (replicate (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op) None, None) \\<Sigma>\" |\n  \"optim_instr _ (IOpInl opinl) \\<Sigma> = (\n    let ar = \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) in\n    if ar \\<le> length \\<Sigma> then\n      case \\<UU>\\<bb>\\<xx> opinl (take ar \\<Sigma>) of\n        None \\<Rightarrow> gen_pop_push (IOpInl opinl) (replicate ar None, None) \\<Sigma> |\n        Some opubx \\<Rightarrow> Ok (IOpUbx opubx, snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx) # drop ar \\<Sigma>)\n    else\n      Error ()\n  )\" |\n  \"optim_instr _ (IOpUbx opubx) \\<Sigma> = gen_pop_push (IOpUbx opubx) (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx) \\<Sigma>\" |\n  \"optim_instr _ (ICall f) \\<Sigma> = do {\n    ar \\<leftarrow> Result.of_option () (get_arity f);\n    gen_pop_push (ICall f) (replicate ar None, None) \\<Sigma>\n  }\" |\n  \"optim_instr _ _ _ = Error ()\""], ["", "definition optim where\n  \"optim \\<equiv> rewrite_prog optim_instr\""], ["", "lemma\n  assumes\n    \"optim 0 [IPush d\\<^sub>1, IPush d\\<^sub>2, IStore y] [] = Ok (xs, ys)\"\n    \"unbox_ubx1 d\\<^sub>1 = Some x\"\n    \"unbox_ubx1 d\\<^sub>2 = None\" \"unbox_ubx2 d\\<^sub>2 = None\"\n  shows \"xs = [IPushUbx1 x, IPush d\\<^sub>2, IStoreUbx Ubx1 y] \\<and> ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = [IPushUbx1 x, Ubx.instr.IPush d\\<^sub>2, IStoreUbx Ubx1 y] \\<and>\n    ys = []", "using assms(1)"], ["proof (prove)\nusing this:\n  optim 0\n   [Ubx.instr.IPush d\\<^sub>1, Ubx.instr.IPush d\\<^sub>2,\n    Ubx.instr.IStore y]\n   [] =\n  Ok (xs, ys)\n\ngoal (1 subgoal):\n 1. xs = [IPushUbx1 x, Ubx.instr.IPush d\\<^sub>2, IStoreUbx Ubx1 y] \\<and>\n    ys = []", "by (simp add: assms optim_def try_unbox_def)"], ["", "lemma norm_optim_instr: \"optim_instr n x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow> norm_instr x' = norm_instr x\"\n    for x \\<Sigma>1 n x' \\<Sigma>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. optim_instr n x \\<Sigma>1 = Ok (x', \\<Sigma>2) \\<Longrightarrow>\n    norm_instr x' = norm_instr x", "proof (induction n x \\<Sigma>1 rule: optim_instr.induct)"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>uu_ d \\<Sigma>.\n       optim_instr uu_ (Ubx.instr.IPush d) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IPush d)\n 2. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 3. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 4. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 5. \\<And>n x \\<Sigma>.\n       optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n 6. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 7. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 8. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 9. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 10. \\<And>vd_ op \\<Sigma>.\n        optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.IOp op)\nA total of 27 subgoals...", "fix d \\<Sigma>1 n"], ["proof (state)\ngoal (27 subgoals):\n 1. \\<And>uu_ d \\<Sigma>.\n       optim_instr uu_ (Ubx.instr.IPush d) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IPush d)\n 2. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 3. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 4. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 5. \\<And>n x \\<Sigma>.\n       optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n 6. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 7. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 8. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 9. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 10. \\<And>vd_ op \\<Sigma>.\n        optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.IOp op)\nA total of 27 subgoals...", "assume \"optim_instr n (Ubx.IPush d) \\<Sigma>1 = Ok (x', \\<Sigma>2)\""], ["proof (state)\nthis:\n  optim_instr n (Ubx.instr.IPush d) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n\ngoal (27 subgoals):\n 1. \\<And>uu_ d \\<Sigma>.\n       optim_instr uu_ (Ubx.instr.IPush d) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IPush d)\n 2. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 3. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 4. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 5. \\<And>n x \\<Sigma>.\n       optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n 6. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 7. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 8. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 9. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 10. \\<And>vd_ op \\<Sigma>.\n        optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.IOp op)\nA total of 27 subgoals...", "thus \"norm_instr x' = norm_instr (Ubx.instr.IPush d)\""], ["proof (prove)\nusing this:\n  optim_instr n (Ubx.instr.IPush d) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.IPush d)", "using Subx.box_unbox_inverse"], ["proof (prove)\nusing this:\n  optim_instr n (Ubx.instr.IPush d) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n  unbox_ubx1 ?d = Some ?u1.0 \\<Longrightarrow> box_ubx1 ?u1.0 = ?d\n  unbox_ubx2 ?d = Some ?u2.0 \\<Longrightarrow> box_ubx2 ?u2.0 = ?d\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.IPush d)", "by (auto elim!: result_alternative.elims simp: try_unbox_def option.case_eq_if)"], ["proof (state)\nthis:\n  norm_instr x' = norm_instr (Ubx.instr.IPush d)\n\ngoal (26 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>n x \\<Sigma>.\n       optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n 5. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 6. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 8. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 9. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 10. \\<And>ve_ opinl \\<Sigma>.\n        optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\nA total of 26 subgoals...", "next"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>n x \\<Sigma>.\n       optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n 5. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 6. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 8. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 9. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 10. \\<And>ve_ opinl \\<Sigma>.\n        optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\nA total of 26 subgoals...", "fix x \\<Sigma>1 n"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>n x \\<Sigma>.\n       optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n 5. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 6. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 8. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 9. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 10. \\<And>ve_ opinl \\<Sigma>.\n        optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\nA total of 26 subgoals...", "assume assms: \"optim_instr n (Ubx.ILoad x) (None # \\<Sigma>1) = Ok (x', \\<Sigma>2)\""], ["proof (state)\nthis:\n  optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>1) = Ok (x', \\<Sigma>2)\n\ngoal (26 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>n x \\<Sigma>.\n       optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n 5. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 6. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 8. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 9. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 10. \\<And>ve_ opinl \\<Sigma>.\n        optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\nA total of 26 subgoals...", "thus \"norm_instr x' = norm_instr (Ubx.ILoad x)\""], ["proof (prove)\nusing this:\n  optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>1) = Ok (x', \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.ILoad x)", "proof (cases \"load_oracle n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>1) =\n             Ok (x', \\<Sigma>2);\n     load_oracle n = None\\<rbrakk>\n    \\<Longrightarrow> norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n 2. \\<And>a.\n       \\<lbrakk>optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>1) =\n                Ok (x', \\<Sigma>2);\n        load_oracle n = Some a\\<rbrakk>\n       \\<Longrightarrow> norm_instr x' = norm_instr (Ubx.instr.ILoad x)", "case None"], ["proof (state)\nthis:\n  load_oracle n = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>1) =\n             Ok (x', \\<Sigma>2);\n     load_oracle n = None\\<rbrakk>\n    \\<Longrightarrow> norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n 2. \\<And>a.\n       \\<lbrakk>optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>1) =\n                Ok (x', \\<Sigma>2);\n        load_oracle n = Some a\\<rbrakk>\n       \\<Longrightarrow> norm_instr x' = norm_instr (Ubx.instr.ILoad x)", "then"], ["proof (chain)\npicking this:\n  load_oracle n = None", "show ?thesis"], ["proof (prove)\nusing this:\n  load_oracle n = None\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.ILoad x)", "using assms"], ["proof (prove)\nusing this:\n  load_oracle n = None\n  optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>1) = Ok (x', \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.ILoad x)", "by simp"], ["proof (state)\nthis:\n  norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>1) =\n                Ok (x', \\<Sigma>2);\n        load_oracle n = Some a\\<rbrakk>\n       \\<Longrightarrow> norm_instr x' = norm_instr (Ubx.instr.ILoad x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>1) =\n                Ok (x', \\<Sigma>2);\n        load_oracle n = Some a\\<rbrakk>\n       \\<Longrightarrow> norm_instr x' = norm_instr (Ubx.instr.ILoad x)", "case (Some x)"], ["proof (state)\nthis:\n  load_oracle n = Some x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>optim_instr n (Ubx.instr.ILoad xa__) (None # \\<Sigma>1) =\n                Ok (x', \\<Sigma>2);\n        load_oracle n = Some a\\<rbrakk>\n       \\<Longrightarrow> norm_instr x' = norm_instr (Ubx.instr.ILoad xa__)", "then"], ["proof (chain)\npicking this:\n  load_oracle n = Some x", "show ?thesis"], ["proof (prove)\nusing this:\n  load_oracle n = Some x\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.ILoad xa__)", "using assms"], ["proof (prove)\nusing this:\n  load_oracle n = Some x\n  optim_instr n (Ubx.instr.ILoad xa__) (None # \\<Sigma>1) =\n  Ok (x', \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.ILoad xa__)", "by (cases x) auto"], ["proof (state)\nthis:\n  norm_instr x' = norm_instr (Ubx.instr.ILoad xa__)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm_instr x' = norm_instr (Ubx.instr.ILoad x)\n\ngoal (25 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>ve_ opinl \\<Sigma>.\n       optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n 10. \\<And>vf_ opubx \\<Sigma>.\n        optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (IOpUbx opubx)\nA total of 25 subgoals...", "next"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>ve_ opinl \\<Sigma>.\n       optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n 10. \\<And>vf_ opubx \\<Sigma>.\n        optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (IOpUbx opubx)\nA total of 25 subgoals...", "fix opinl \\<Sigma>1 n"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>ve_ opinl \\<Sigma>.\n       optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n 10. \\<And>vf_ opubx \\<Sigma>.\n        optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (IOpUbx opubx)\nA total of 25 subgoals...", "assume assms: \"optim_instr n (IOpInl opinl) \\<Sigma>1 = Ok (x', \\<Sigma>2)\""], ["proof (state)\nthis:\n  optim_instr n (Ubx.instr.IOpInl opinl) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n\ngoal (25 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>ve_ opinl \\<Sigma>.\n       optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n 10. \\<And>vf_ opubx \\<Sigma>.\n        optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (IOpUbx opubx)\nA total of 25 subgoals...", "then"], ["proof (chain)\npicking this:\n  optim_instr n (Ubx.instr.IOpInl opinl) \\<Sigma>1 = Ok (x', \\<Sigma>2)", "have arity_le_\\<Sigma>1: \"\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) \\<le> length \\<Sigma>1\""], ["proof (prove)\nusing this:\n  optim_instr n (Ubx.instr.IOpInl opinl) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n    \\<le> length \\<Sigma>1", "using prod.inject"], ["proof (prove)\nusing this:\n  optim_instr n (Ubx.instr.IOpInl opinl) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n  ((?x1.0, ?x2.0) = (?y1.0, ?y2.0)) = (?x1.0 = ?y1.0 \\<and> ?x2.0 = ?y2.0)\n\ngoal (1 subgoal):\n 1. \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n    \\<le> length \\<Sigma>1", "by fastforce"], ["proof (state)\nthis:\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n  \\<le> length \\<Sigma>1\n\ngoal (25 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>ve_ opinl \\<Sigma>.\n       optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n 10. \\<And>vf_ opubx \\<Sigma>.\n        optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (IOpUbx opubx)\nA total of 25 subgoals...", "show \"norm_instr x' = norm_instr (IOpInl opinl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "proof (cases \"\\<UU>\\<bb>\\<xx> opinl (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)) \\<Sigma>1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<UU>\\<bb>\\<xx> opinl\n     (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n       \\<Sigma>1) =\n    None \\<Longrightarrow>\n    norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n 2. \\<And>a.\n       \\<UU>\\<bb>\\<xx> opinl\n        (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n          \\<Sigma>1) =\n       Some a \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "case None"], ["proof (state)\nthis:\n  \\<UU>\\<bb>\\<xx> opinl\n   (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n     \\<Sigma>1) =\n  None\n\ngoal (2 subgoals):\n 1. \\<UU>\\<bb>\\<xx> opinl\n     (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n       \\<Sigma>1) =\n    None \\<Longrightarrow>\n    norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n 2. \\<And>a.\n       \\<UU>\\<bb>\\<xx> opinl\n        (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n          \\<Sigma>1) =\n       Some a \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "then"], ["proof (chain)\npicking this:\n  \\<UU>\\<bb>\\<xx> opinl\n   (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n     \\<Sigma>1) =\n  None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<UU>\\<bb>\\<xx> opinl\n   (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n     \\<Sigma>1) =\n  None\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "using assms arity_le_\\<Sigma>1"], ["proof (prove)\nusing this:\n  \\<UU>\\<bb>\\<xx> opinl\n   (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n     \\<Sigma>1) =\n  None\n  optim_instr n (Ubx.instr.IOpInl opinl) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n  \\<le> length \\<Sigma>1\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<UU>\\<bb>\\<xx> opinl\n        (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n          \\<Sigma>1) =\n       Some a \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<UU>\\<bb>\\<xx> opinl\n        (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n          \\<Sigma>1) =\n       Some a \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "case (Some opubx)"], ["proof (state)\nthis:\n  \\<UU>\\<bb>\\<xx> opinl\n   (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n     \\<Sigma>1) =\n  Some opubx\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<UU>\\<bb>\\<xx> opinl\n        (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n          \\<Sigma>1) =\n       Some a \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "then"], ["proof (chain)\npicking this:\n  \\<UU>\\<bb>\\<xx> opinl\n   (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n     \\<Sigma>1) =\n  Some opubx", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<UU>\\<bb>\\<xx> opinl\n   (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n     \\<Sigma>1) =\n  Some opubx\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "using assms arity_le_\\<Sigma>1"], ["proof (prove)\nusing this:\n  \\<UU>\\<bb>\\<xx> opinl\n   (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n     \\<Sigma>1) =\n  Some opubx\n  optim_instr n (Ubx.instr.IOpInl opinl) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n  \\<le> length \\<Sigma>1\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)", "by (auto simp: case_prod_beta Subx.\\<UU>\\<bb>\\<xx>_invertible)"], ["proof (state)\nthis:\n  norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm_instr x' = norm_instr (Ubx.instr.IOpInl opinl)\n\ngoal (24 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>vf_ opubx \\<Sigma>.\n       optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IOpUbx opubx)\n 10. \\<And>vg_ f \\<Sigma>.\n        optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.ICall f)\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>vf_ opubx \\<Sigma>.\n       optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IOpUbx opubx)\n 10. \\<And>vg_ f \\<Sigma>.\n        optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.ICall f)\nA total of 24 subgoals...", "fix opubx \\<Sigma>1 n"], ["proof (state)\ngoal (24 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>vf_ opubx \\<Sigma>.\n       optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IOpUbx opubx)\n 10. \\<And>vg_ f \\<Sigma>.\n        optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.ICall f)\nA total of 24 subgoals...", "assume assms: \"optim_instr n (IOpUbx opubx) \\<Sigma>1 = Ok (x', \\<Sigma>2)\""], ["proof (state)\nthis:\n  optim_instr n (IOpUbx opubx) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n\ngoal (24 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>vf_ opubx \\<Sigma>.\n       optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IOpUbx opubx)\n 10. \\<And>vg_ f \\<Sigma>.\n        optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr (Ubx.instr.ICall f)\nA total of 24 subgoals...", "then"], ["proof (chain)\npicking this:\n  optim_instr n (IOpUbx opubx) \\<Sigma>1 = Ok (x', \\<Sigma>2)", "show \"norm_instr x' = norm_instr (IOpUbx opubx)\""], ["proof (prove)\nusing this:\n  optim_instr n (IOpUbx opubx) \\<Sigma>1 = Ok (x', \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. norm_instr x' = norm_instr (IOpUbx opubx)", "by (cases \"\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx\"; auto simp: Let_def)"], ["proof (state)\nthis:\n  norm_instr x' = norm_instr (IOpUbx opubx)\n\ngoal (23 subgoals):\n 1. \\<And>uv_ n \\<Sigma>.\n       optim_instr uv_ (IPushUbx1 n) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx1 n)\n 2. \\<And>uw_ b \\<Sigma>.\n       optim_instr uw_ (IPushUbx2 b) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IPushUbx2 b)\n 3. \\<And>ux_ uy_ \\<Sigma>.\n       optim_instr ux_ Ubx.instr.IPop (uy_ # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr Ubx.instr.IPop\n 4. \\<And>uz_ \\<tau> x \\<Sigma>.\n       optim_instr uz_ (ILoadUbx \\<tau> x) (None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (ILoadUbx \\<tau> x)\n 5. \\<And>va_ x \\<Sigma>.\n       optim_instr va_ (Ubx.instr.IStore x) (None # None # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 6. \\<And>vb_ x \\<tau> \\<Sigma>.\n       optim_instr vb_ (Ubx.instr.IStore x)\n        (None # Some \\<tau> # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IStore x)\n 7. \\<And>vc_ \\<tau>\\<^sub>1 x \\<tau>\\<^sub>2 \\<Sigma>.\n       optim_instr vc_ (IStoreUbx \\<tau>\\<^sub>1 x)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (IStoreUbx \\<tau>\\<^sub>1 x)\n 8. \\<And>vd_ op \\<Sigma>.\n       optim_instr vd_ (Ubx.instr.IOp op) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.IOp op)\n 9. \\<And>vg_ f \\<Sigma>.\n       optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n       Ok (x', \\<Sigma>2) \\<Longrightarrow>\n       norm_instr x' = norm_instr (Ubx.instr.ICall f)\n 10. \\<And>vh_.\n        optim_instr vh_ Ubx.instr.IPop [] =\n        Ok (x', \\<Sigma>2) \\<Longrightarrow>\n        norm_instr x' = norm_instr Ubx.instr.IPop\nA total of 23 subgoals...", "qed (auto simp: Let_def)"], ["", "lemma norm_optim:\n  assumes \"optim n xs \\<Sigma>1 = Ok (ys, \\<Sigma>2)\"\n  shows \"map norm_instr ys = map norm_instr xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map norm_instr ys = map norm_instr xs", "using assms"], ["proof (prove)\nusing this:\n  optim n xs \\<Sigma>1 = Ok (ys, \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. map norm_instr ys = map norm_instr xs", "unfolding optim_def"], ["proof (prove)\nusing this:\n  rewrite_prog optim_instr n xs \\<Sigma>1 = Ok (ys, \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. map norm_instr ys = map norm_instr xs", "by (induction xs arbitrary: \\<Sigma>1 n ys \\<Sigma>2; auto simp: norm_optim_instr)"], ["", "lemma sp_optim_instr:\n  assumes\n    \"optim_instr n instr \\<Sigma>1 = Ok (instr', \\<Sigma>2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x) \"\n  shows \"Subx.sp_instr F instr' \\<Sigma>1 = Ok \\<Sigma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp_instr F instr' \\<Sigma>1 = Ok \\<Sigma>2", "using assms(1)"], ["proof (prove)\nusing this:\n  optim_instr n instr \\<Sigma>1 = Ok (instr', \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. Subx.sp_instr F instr' \\<Sigma>1 = Ok \\<Sigma>2", "apply (induction n instr \\<Sigma>1 rule: optim_instr.induct;\n      (auto simp: Let_def; fail)?)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>uu_ d \\<Sigma>.\n       optim_instr uu_ (Ubx.instr.IPush d) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 2. \\<And>n x \\<Sigma>.\n       optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # \\<Sigma>) = Ok \\<Sigma>2\n 3. \\<And>ve_ opinl \\<Sigma>.\n       optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 4. \\<And>vf_ opubx \\<Sigma>.\n       optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 5. \\<And>vg_ f \\<Sigma>.\n       optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "subgoal for _ d"], ["proof (prove)\ngoal (1 subgoal):\n 1. optim_instr uu_ (Ubx.instr.IPush d) \\<Sigma>_ =\n    Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' \\<Sigma>_ = Ok \\<Sigma>2", "by (auto elim!: result_alternative.elims simp: try_unbox_def option.case_eq_if)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n x \\<Sigma>.\n       optim_instr n (Ubx.instr.ILoad x) (None # \\<Sigma>) =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' (None # \\<Sigma>) = Ok \\<Sigma>2\n 2. \\<And>ve_ opinl \\<Sigma>.\n       optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 3. \\<And>vf_ opubx \\<Sigma>.\n       optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 4. \\<And>vg_ f \\<Sigma>.\n       optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "subgoal for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. optim_instr n (Ubx.instr.ILoad x_) (None # \\<Sigma>_) =\n    Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' (None # \\<Sigma>_) = Ok \\<Sigma>2", "by (cases \"load_oracle n\"; auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ve_ opinl \\<Sigma>.\n       optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 2. \\<And>vf_ opubx \\<Sigma>.\n       optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 3. \\<And>vg_ f \\<Sigma>.\n       optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "subgoal for _ opinl \\<Sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. optim_instr ve_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n    Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n    \\<le> length \\<Sigma> \\<and>\n    (case \\<UU>\\<bb>\\<xx> opinl\n           (take\n             (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n             \\<Sigma>) of\n     None \\<Rightarrow>\n       gen_pop_push (Ubx.instr.IOpInl opinl)\n        (replicate\n          (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n          None,\n         None)\n        \\<Sigma>\n     | Some opubx \\<Rightarrow>\n         Ok (IOpUbx opubx,\n             snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx) #\n             drop\n              (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n              \\<Sigma>)) =\n    Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "apply (cases \"\\<UU>\\<bb>\\<xx> opinl (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)) \\<Sigma>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n             \\<le> length \\<Sigma> \\<and>\n             (case \\<UU>\\<bb>\\<xx> opinl\n                    (take\n                      (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                        (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                      \\<Sigma>) of\n              None \\<Rightarrow>\n                gen_pop_push (Ubx.instr.IOpInl opinl)\n                 (replicate\n                   (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                     (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                   None,\n                  None)\n                 \\<Sigma>\n              | Some opubx \\<Rightarrow>\n                  Ok (IOpUbx opubx,\n                      snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx) #\n                      drop\n                       (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                         (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                       \\<Sigma>)) =\n             Ok (instr', \\<Sigma>2);\n     \\<UU>\\<bb>\\<xx> opinl\n      (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n        \\<Sigma>) =\n     None\\<rbrakk>\n    \\<Longrightarrow> Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 2. \\<And>a.\n       \\<lbrakk>\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n                \\<le> length \\<Sigma> \\<and>\n                (case \\<UU>\\<bb>\\<xx> opinl\n                       (take\n                         (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                           (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                         \\<Sigma>) of\n                 None \\<Rightarrow>\n                   gen_pop_push (Ubx.instr.IOpInl opinl)\n                    (replicate\n                      (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                        (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                      None,\n                     None)\n                    \\<Sigma>\n                 | Some opubx \\<Rightarrow>\n                     Ok (IOpUbx opubx,\n                         snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>\n                               opubx) #\n                         drop\n                          (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                            (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                          \\<Sigma>)) =\n                Ok (instr', \\<Sigma>2);\n        \\<UU>\\<bb>\\<xx> opinl\n         (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n           \\<Sigma>) =\n        Some a\\<rbrakk>\n       \\<Longrightarrow> Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "apply (auto dest: list_all_eq_const_imp_replicate\n        simp: case_prod_beta Let_def min.absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<UU>\\<bb>\\<xx> opinl\n                 (take\n                   (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                     (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                   \\<Sigma>) =\n                Some a;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n        \\<le> length \\<Sigma>;\n        instr' = IOpUbx a;\n        \\<Sigma>2 =\n        snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> a) #\n        drop (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n         \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> Subx.sp_gen_pop_push\n                          (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> a)\n                          \\<Sigma> =\n                         Ok (snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>\n                                   a) #\n                             drop\n                              (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                                (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                              \\<Sigma>)", "subgoal for opubx"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<UU>\\<bb>\\<xx> opinl\n              (take\n                (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                  (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                \\<Sigma>) =\n             Some opubx;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n     \\<le> length \\<Sigma>;\n     instr' = IOpUbx opubx;\n     \\<Sigma>2 =\n     snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx) #\n     drop (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n      \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> Subx.sp_gen_pop_push\n                       (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n                       \\<Sigma> =\n                      Ok (snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>\n                                opubx) #\n                          drop\n                           (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                             (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                           \\<Sigma>)", "using Subx.\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>_\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>[of opubx]"], ["proof (prove)\nusing this:\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n   (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) =\n  length (fst (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<UU>\\<bb>\\<xx> opinl\n              (take\n                (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                  (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                \\<Sigma>) =\n             Some opubx;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n     \\<le> length \\<Sigma>;\n     instr' = IOpUbx opubx;\n     \\<Sigma>2 =\n     snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx) #\n     drop (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n      \\<Sigma>\\<rbrakk>\n    \\<Longrightarrow> Subx.sp_gen_pop_push\n                       (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n                       \\<Sigma> =\n                      Ok (snd (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>\n                                opubx) #\n                          drop\n                           (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                             (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                           \\<Sigma>)", "by (cases \"\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx\"; auto simp: Subx.\\<UU>\\<bb>\\<xx>_invertible dest: Subx.\\<UU>\\<bb>\\<xx>_opubx_type)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vf_ opubx \\<Sigma>.\n       optim_instr vf_ (IOpUbx opubx) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2\n 2. \\<And>vg_ f \\<Sigma>.\n       optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "subgoal for _ opubx"], ["proof (prove)\ngoal (1 subgoal):\n 1. optim_instr vf_ (IOpUbx opubx) \\<Sigma>_ =\n    Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' \\<Sigma>_ = Ok \\<Sigma>2", "by (cases \"\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx\"; auto simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vg_ f \\<Sigma>.\n       optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma> =\n       Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n       Subx.sp_instr F instr' \\<Sigma> = Ok \\<Sigma>2", "subgoal for _ f"], ["proof (prove)\ngoal (1 subgoal):\n 1. optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma>_ =\n    Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' \\<Sigma>_ = Ok \\<Sigma>2", "using assms(2)[of f]"], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity f) (F f)\n\ngoal (1 subgoal):\n 1. optim_instr vg_ (Ubx.instr.ICall f) \\<Sigma>_ =\n    Ok (instr', \\<Sigma>2) \\<Longrightarrow>\n    Subx.sp_instr F instr' \\<Sigma>_ = Ok \\<Sigma>2", "by (auto simp: option_rel_Some1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sp_optim:\n  assumes\n    \"optim n p1 \\<Sigma>1 = Ok (p2, \\<Sigma>2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x)\"\n  shows \"Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2", "using assms"], ["proof (prove)\nusing this:\n  optim n p1 \\<Sigma>1 = Ok (p2, \\<Sigma>2)\n  rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity ?x57) (F ?x57)\n\ngoal (1 subgoal):\n 1. Subx.sp F p2 \\<Sigma>1 = Ok \\<Sigma>2", "by (auto elim!: sp_rewrite_prog sp_optim_instr simp: optim_def)"], ["", "section \\<open>Compilation of function definition\\<close>"], ["", "fun compile_fundef where\n  \"compile_fundef (Fundef instrs ar) = do {\n    (xs, \\<Sigma>\\<^sub>1) \\<leftarrow> lift 0 instrs (replicate ar None :: type option list);\n\n    \\<comment> \\<open>Ensure that the function returns a single dynamic result\\<close>\n    () \\<leftarrow> if \\<Sigma>\\<^sub>1 = [None] then Ok () else Error ();\n\n    (ys, \\<Sigma>\\<^sub>2) \\<leftarrow> optim 0 xs (replicate ar None);\n\n    Ok (Fundef (\n    if \\<Sigma>\\<^sub>2 = [None] then\n      ys \\<comment> \\<open>use optimization\\<close>\n    else\n      xs \\<comment> \\<open>cancel optimization\\<close>\n    ) ar)\n  }\""], ["", "lemma rel_compile_fundef:\n  assumes \"compile_fundef fd1 = Ok fd2\"\n  shows \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "proof (cases fd1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       fd1 = Fundef x1 x2 \\<Longrightarrow>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "case (Fundef xs ar)"], ["proof (state)\nthis:\n  fd1 = Fundef xs ar\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       fd1 = Fundef x1 x2 \\<Longrightarrow>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "obtain ys zs \\<Sigma>2 where\n    lift_xs: \"lift 0 xs (replicate ar None :: type option list) = Ok (ys, [None])\" and\n    optim_ys: \"optim 0 ys (replicate ar None :: type option list) = Ok (zs, \\<Sigma>2)\" and\n    check: \"fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys zs \\<Sigma>2.\n        \\<lbrakk>lift 0 xs (replicate ar None) = Ok (ys, [None]);\n         optim 0 ys (replicate ar None) = Ok (zs, \\<Sigma>2);\n         fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  compile_fundef fd1 = Ok fd2\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs \\<Sigma>2.\n        \\<lbrakk>lift 0 xs (replicate ar None) = Ok (ys, [None]);\n         optim 0 ys (replicate ar None) = Ok (zs, \\<Sigma>2);\n         fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Fundef"], ["proof (prove)\nusing this:\n  compile_fundef (Fundef xs ar) = Ok fd2\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs \\<Sigma>2.\n        \\<lbrakk>lift 0 xs (replicate ar None) = Ok (ys, [None]);\n         optim 0 ys (replicate ar None) = Ok (zs, \\<Sigma>2);\n         fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding compile_fundef.simps"], ["proof (prove)\nusing this:\n  lift 0 xs (replicate ar None) \\<bind>\n  (\\<lambda>(xs, \\<Sigma>\\<^sub>1).\n      (if \\<Sigma>\\<^sub>1 = [None] then Ok () else Error ()) \\<bind>\n      (\\<lambda>().\n          optim 0 xs (replicate ar None) \\<bind>\n          (\\<lambda>(ys, \\<Sigma>\\<^sub>2).\n              Ok (Fundef (if \\<Sigma>\\<^sub>2 = [None] then ys else xs)\n                   ar)))) =\n  Ok fd2\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs \\<Sigma>2.\n        \\<lbrakk>lift 0 xs (replicate ar None) = Ok (ys, [None]);\n         optim 0 ys (replicate ar None) = Ok (zs, \\<Sigma>2);\n         fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Nitpick.case_unit_unfold if_then_else_distributive)"], ["proof (state)\nthis:\n  lift 0 xs (replicate ar None) = Ok (ys, [None])\n  optim 0 ys (replicate ar None) = Ok (zs, \\<Sigma>2)\n  fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       fd1 = Fundef x1 x2 \\<Longrightarrow>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "then"], ["proof (chain)\npicking this:\n  lift 0 xs (replicate ar None) = Ok (ys, [None])\n  optim 0 ys (replicate ar None) = Ok (zs, \\<Sigma>2)\n  fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar", "have \"map norm_instr ys = xs\""], ["proof (prove)\nusing this:\n  lift 0 xs (replicate ar None) = Ok (ys, [None])\n  optim 0 ys (replicate ar None) = Ok (zs, \\<Sigma>2)\n  fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\n\ngoal (1 subgoal):\n 1. map norm_instr ys = xs", "by (auto intro: norm_lift)"], ["proof (state)\nthis:\n  map norm_instr ys = xs\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       fd1 = Fundef x1 x2 \\<Longrightarrow>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "proof (cases \"\\<Sigma>2 = [None]\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Sigma>2 = [None] \\<Longrightarrow>\n    rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n 2. \\<Sigma>2 \\<noteq> [None] \\<Longrightarrow>\n    rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "case True"], ["proof (state)\nthis:\n  \\<Sigma>2 = [None]\n\ngoal (2 subgoals):\n 1. \\<Sigma>2 = [None] \\<Longrightarrow>\n    rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n 2. \\<Sigma>2 \\<noteq> [None] \\<Longrightarrow>\n    rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "then"], ["proof (chain)\npicking this:\n  \\<Sigma>2 = [None]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sigma>2 = [None]\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using True Fundef"], ["proof (prove)\nusing this:\n  \\<Sigma>2 = [None]\n  \\<Sigma>2 = [None]\n  fd1 = Fundef xs ar\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using check norm_lift[OF lift_xs, symmetric]"], ["proof (prove)\nusing this:\n  \\<Sigma>2 = [None]\n  \\<Sigma>2 = [None]\n  fd1 = Fundef xs ar\n  fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\n  xs = map norm_instr ys\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using norm_optim[OF optim_ys, symmetric]"], ["proof (prove)\nusing this:\n  \\<Sigma>2 = [None]\n  \\<Sigma>2 = [None]\n  fd1 = Fundef xs ar\n  fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\n  xs = map norm_instr ys\n  map norm_instr ys = map norm_instr zs\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by (simp add: list.rel_map list.rel_refl)"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<Sigma>2 \\<noteq> [None] \\<Longrightarrow>\n    rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sigma>2 \\<noteq> [None] \\<Longrightarrow>\n    rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "case False"], ["proof (state)\nthis:\n  \\<Sigma>2 \\<noteq> [None]\n\ngoal (1 subgoal):\n 1. \\<Sigma>2 \\<noteq> [None] \\<Longrightarrow>\n    rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "then"], ["proof (chain)\npicking this:\n  \\<Sigma>2 \\<noteq> [None]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sigma>2 \\<noteq> [None]\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using Fundef check norm_lift[OF lift_xs, symmetric]"], ["proof (prove)\nusing this:\n  \\<Sigma>2 \\<noteq> [None]\n  fd1 = Fundef xs ar\n  fd2 = Fundef (if \\<Sigma>2 = [None] then zs else ys) ar\n  xs = map norm_instr ys\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by (simp add: list.rel_map list.rel_refl)"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sp_compile_fundef:\n  assumes\n    \"compile_fundef fd1 = Ok fd2\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity x) (F x)\"\n  shows \"sp_fundef F fd2 (body fd2) = Ok [None]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef F fd2 (body fd2) = Ok [None]", "proof (cases fd1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       fd1 = Fundef x1 x2 \\<Longrightarrow>\n       sp_fundef F fd2 (body fd2) = Ok [None]", "case (Fundef xs ar)"], ["proof (state)\nthis:\n  fd1 = Fundef xs ar\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       fd1 = Fundef x1 x2 \\<Longrightarrow>\n       sp_fundef F fd2 (body fd2) = Ok [None]", "with assms"], ["proof (chain)\npicking this:\n  compile_fundef fd1 = Ok fd2\n  rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity ?x62) (F ?x62)\n  fd1 = Fundef xs ar", "show ?thesis"], ["proof (prove)\nusing this:\n  compile_fundef fd1 = Ok fd2\n  rel_option (\\<lambda>ar fd. arity fd = ar) (get_arity ?x62) (F ?x62)\n  fd1 = Fundef xs ar\n\ngoal (1 subgoal):\n 1. sp_fundef F fd2 (body fd2) = Ok [None]", "by (auto elim!: sp_optim sp_lift simp: sp_fundef_def Nitpick.case_unit_unfold if_eq_const_conv)"], ["proof (state)\nthis:\n  sp_fundef F fd2 (body fd2) = Ok [None]\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "locale inca_ubx_compiler =\n  inca_to_ubx_simulation Finca_empty Finca_get\n  for\n    Finca_empty and\n    Finca_get :: \"_ \\<Rightarrow> 'fun \\<Rightarrow> _ option\" +\n  fixes\n    load_oracle :: \"'fun \\<Rightarrow> nat \\<Rightarrow> type option\"\nbegin"], ["", "section \\<open>Compilation of function environment\\<close>"], ["", "definition compile_env_entry where\n  \"compile_env_entry \\<A> \\<O> x = map_result id (Pair (fst x)) (compile_fundef \\<A> (\\<O> (fst x)) (snd x))\""], ["", "lemma rel_compile_env_entry:\n  assumes \"compile_env_entry \\<O> \\<A> (f, fd1) = Ok (f, fd2)\"\n  shows \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using assms"], ["proof (prove)\nusing this:\n  compile_env_entry \\<O> \\<A> (f, fd1) = Ok (f, fd2)\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "unfolding compile_env_entry_def"], ["proof (prove)\nusing this:\n  map_result id (Pair (fst (f, fd1)))\n   (compile_fundef \\<O> (\\<A> (fst (f, fd1))) (snd (f, fd1))) =\n  Ok (f, fd2)\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using rel_compile_fundef"], ["proof (prove)\nusing this:\n  map_result id (Pair (fst (f, fd1)))\n   (compile_fundef \\<O> (\\<A> (fst (f, fd1))) (snd (f, fd1))) =\n  Ok (f, fd2)\n  compile_fundef ?get_arity ?load_oracle ?fd1.0 =\n  Ok ?fd2.0 \\<Longrightarrow>\n  rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by auto"], ["", "lemma sp_compile_env_entry:\n  assumes\n    \"compile_env_entry \\<A> \\<O> (f, fd1) = Ok (f, fd2)\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> x) (F x)\"\n  shows \"sp_fundef F fd2 (body fd2) = Ok [None]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef F fd2 (body fd2) = Ok [None]", "using assms"], ["proof (prove)\nusing this:\n  compile_env_entry \\<A> \\<O> (f, fd1) = Ok (f, fd2)\n  rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> ?x63) (F ?x63)\n\ngoal (1 subgoal):\n 1. sp_fundef F fd2 (body fd2) = Ok [None]", "unfolding compile_env_entry_def"], ["proof (prove)\nusing this:\n  map_result id (Pair (fst (f, fd1)))\n   (compile_fundef \\<A> (\\<O> (fst (f, fd1))) (snd (f, fd1))) =\n  Ok (f, fd2)\n  rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> ?x63) (F ?x63)\n\ngoal (1 subgoal):\n 1. sp_fundef F fd2 (body fd2) = Ok [None]", "by (auto elim: sp_compile_fundef)"], ["", "definition compile_env where\n  \"compile_env \\<A> \\<O> e \\<equiv>\n    map_result id Subx.Fenv.from_list\n      (Result.those (map (compile_env_entry \\<A> \\<O>) (Finca_to_list e))) \""], ["", "lemma list_assoc_those_compile_env_entries:\n  \"Result.those (map (compile_env_entry \\<A> \\<O>) xs) = Ok ys \\<Longrightarrow>\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2) (map_of xs f) (map_of ys f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n    Ok ys \\<Longrightarrow>\n    rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (map_of xs f) (map_of ys f)", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       Result.those (map (compile_env_entry \\<A> \\<O>) []) =\n       Ok ys \\<Longrightarrow>\n       rel_option\n        (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n        (map_of [] f) (map_of ys f)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_option\n                    (\\<lambda>fd1 fd2.\n                        compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                    (map_of xs f) (map_of ys f);\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (\\<lambda>fd1 fd2.\n                              compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                          (map_of (a # xs) f) (map_of ys f)", "case Nil"], ["proof (state)\nthis:\n  Result.those (map (compile_env_entry \\<A> \\<O>) []) = Ok ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       Result.those (map (compile_env_entry \\<A> \\<O>) []) =\n       Ok ys \\<Longrightarrow>\n       rel_option\n        (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n        (map_of [] f) (map_of ys f)\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_option\n                    (\\<lambda>fd1 fd2.\n                        compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                    (map_of xs f) (map_of ys f);\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (\\<lambda>fd1 fd2.\n                              compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                          (map_of (a # xs) f) (map_of ys f)", "then"], ["proof (chain)\npicking this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) []) = Ok ys", "show ?case"], ["proof (prove)\nusing this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) []) = Ok ys\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (map_of [] f) (map_of ys f)", "by simp"], ["proof (state)\nthis:\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (map_of [] f) (map_of ys f)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_option\n                    (\\<lambda>fd1 fd2.\n                        compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                    (map_of xs f) (map_of ys f);\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (\\<lambda>fd1 fd2.\n                              compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                          (map_of (a # xs) f) (map_of ys f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_option\n                    (\\<lambda>fd1 fd2.\n                        compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                    (map_of xs f) (map_of ys f);\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (\\<lambda>fd1 fd2.\n                              compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                          (map_of (a # xs) f) (map_of ys f)", "case (Cons x xs)"], ["proof (state)\nthis:\n  Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n  Ok ?ys63 \\<Longrightarrow>\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (map_of xs f) (map_of ?ys63 f)\n  Result.those (map (compile_env_entry \\<A> \\<O>) (x # xs)) = Ok ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_option\n                    (\\<lambda>fd1 fd2.\n                        compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                    (map_of xs f) (map_of ys f);\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (\\<lambda>fd1 fd2.\n                              compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                          (map_of (a # xs) f) (map_of ys f)", "then"], ["proof (chain)\npicking this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n  Ok ?ys63 \\<Longrightarrow>\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (map_of xs f) (map_of ?ys63 f)\n  Result.those (map (compile_env_entry \\<A> \\<O>) (x # xs)) = Ok ys", "obtain y ys' where\n    xs_def: \"ys = y # ys'\" and\n    comp_x: \"compile_env_entry \\<A> \\<O> x = Ok y\" and\n    comp_xs: \"Result.those (map (compile_env_entry \\<A> \\<O>) xs) = Ok ys'\""], ["proof (prove)\nusing this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n  Ok ?ys63 \\<Longrightarrow>\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (map_of xs f) (map_of ?ys63 f)\n  Result.those (map (compile_env_entry \\<A> \\<O>) (x # xs)) = Ok ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        \\<lbrakk>ys = y # ys'; compile_env_entry \\<A> \\<O> x = Ok y;\n         Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n         Ok ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ys = y # ys'\n  compile_env_entry \\<A> \\<O> x = Ok y\n  Result.those (map (compile_env_entry \\<A> \\<O>) xs) = Ok ys'\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_option\n                    (\\<lambda>fd1 fd2.\n                        compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                    (map_of xs f) (map_of ys f);\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (\\<lambda>fd1 fd2.\n                              compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                          (map_of (a # xs) f) (map_of ys f)", "obtain g fd1 fd2 where prods: \"x = (g, fd1)\" \"y = (g, fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g fd1 fd2.\n        \\<lbrakk>x = (g, fd1); y = (g, fd2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using comp_x"], ["proof (prove)\nusing this:\n  compile_env_entry \\<A> \\<O> x = Ok y\n\ngoal (1 subgoal):\n 1. (\\<And>g fd1 fd2.\n        \\<lbrakk>x = (g, fd1); y = (g, fd2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x) (auto simp: compile_env_entry_def)"], ["proof (state)\nthis:\n  x = (g, fd1)\n  y = (g, fd2)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_option\n                    (\\<lambda>fd1 fd2.\n                        compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                    (map_of xs f) (map_of ys f);\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (\\<lambda>fd1 fd2.\n                              compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                          (map_of (a # xs) f) (map_of ys f)", "have \"compile_fundef \\<A> (\\<O> g) fd1 = Ok fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compile_fundef \\<A> (\\<O> g) fd1 = Ok fd2", "using comp_x"], ["proof (prove)\nusing this:\n  compile_env_entry \\<A> \\<O> x = Ok y\n\ngoal (1 subgoal):\n 1. compile_fundef \\<A> (\\<O> g) fd1 = Ok fd2", "unfolding prods compile_env_entry_def"], ["proof (prove)\nusing this:\n  map_result id (Pair (fst (g, fd1)))\n   (compile_fundef \\<A> (\\<O> (fst (g, fd1))) (snd (g, fd1))) =\n  Ok (g, fd2)\n\ngoal (1 subgoal):\n 1. compile_fundef \\<A> (\\<O> g) fd1 = Ok fd2", "by auto"], ["proof (state)\nthis:\n  compile_fundef \\<A> (\\<O> g) fd1 = Ok fd2\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_option\n                    (\\<lambda>fd1 fd2.\n                        compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                    (map_of xs f) (map_of ys f);\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (\\<lambda>fd1 fd2.\n                              compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n                          (map_of (a # xs) f) (map_of ys f)", "then"], ["proof (chain)\npicking this:\n  compile_fundef \\<A> (\\<O> g) fd1 = Ok fd2", "show ?case"], ["proof (prove)\nusing this:\n  compile_fundef \\<A> (\\<O> g) fd1 = Ok fd2\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (map_of (x # xs) f) (map_of ys f)", "unfolding prods xs_def"], ["proof (prove)\nusing this:\n  compile_fundef \\<A> (\\<O> g) fd1 = Ok fd2\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (map_of ((g, fd1) # xs) f) (map_of ((g, fd2) # ys') f)", "using Cons.IH[OF comp_xs]"], ["proof (prove)\nusing this:\n  compile_fundef \\<A> (\\<O> g) fd1 = Ok fd2\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (map_of xs f) (map_of ys' f)\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (map_of ((g, fd1) # xs) f) (map_of ((g, fd2) # ys') f)", "by simp"], ["proof (state)\nthis:\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (map_of (x # xs) f) (map_of ys f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compile_env_rel_compile_fundef:\n  assumes \"compile_env \\<A> \\<O> F1 = Ok F2\"\n  shows \"rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2) (Finca_get F1 f) (Fubx_get F2 f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (Fubx_get F2 f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (Fubx_get F2 f)", "obtain xs where those_xs: \"Result.those (map (compile_env_entry \\<A> \\<O>) (Finca_to_list F1)) = Ok xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        Result.those\n         (map (compile_env_entry \\<A> \\<O>) (Finca_to_list F1)) =\n        Ok xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms[unfolded compile_env_def]"], ["proof (prove)\nusing this:\n  map_result id Subx.Fenv.from_list\n   (Result.those (map (compile_env_entry \\<A> \\<O>) (Finca_to_list F1))) =\n  Ok F2\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        Result.those\n         (map (compile_env_entry \\<A> \\<O>) (Finca_to_list F1)) =\n        Ok xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Result.those (map (compile_env_entry \\<A> \\<O>) (Finca_to_list F1)) =\n  Ok xs\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (Fubx_get F2 f)", "hence F2_def: \"F2 = Subx.Fenv.from_list xs\""], ["proof (prove)\nusing this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) (Finca_to_list F1)) =\n  Ok xs\n\ngoal (1 subgoal):\n 1. F2 = Subx.Fenv.from_list xs", "using assms[unfolded compile_env_def]"], ["proof (prove)\nusing this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) (Finca_to_list F1)) =\n  Ok xs\n  map_result id Subx.Fenv.from_list\n   (Result.those (map (compile_env_entry \\<A> \\<O>) (Finca_to_list F1))) =\n  Ok F2\n\ngoal (1 subgoal):\n 1. F2 = Subx.Fenv.from_list xs", "by simp"], ["proof (state)\nthis:\n  F2 = Subx.Fenv.from_list xs\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (Fubx_get F2 f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (Fubx_get F2 f)", "proof (cases \"map_of (Finca_to_list F1) f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of (Finca_to_list F1) f = None \\<Longrightarrow>\n    rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (Fubx_get F2 f)\n 2. \\<And>a.\n       map_of (Finca_to_list F1) f = Some a \\<Longrightarrow>\n       rel_option\n        (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n        (Finca_get F1 f) (Fubx_get F2 f)", "case None"], ["proof (state)\nthis:\n  map_of (Finca_to_list F1) f = None\n\ngoal (2 subgoals):\n 1. map_of (Finca_to_list F1) f = None \\<Longrightarrow>\n    rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (Fubx_get F2 f)\n 2. \\<And>a.\n       map_of (Finca_to_list F1) f = Some a \\<Longrightarrow>\n       rel_option\n        (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n        (Finca_get F1 f) (Fubx_get F2 f)", "then"], ["proof (chain)\npicking this:\n  map_of (Finca_to_list F1) f = None", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (Finca_to_list F1) f = None\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (Fubx_get F2 f)", "unfolding F2_def Subx.Fenv.from_list_correct[symmetric]"], ["proof (prove)\nusing this:\n  map_of (Finca_to_list F1) f = None\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (map_of xs f)", "unfolding Sinca.Fenv.to_list_correct[symmetric]"], ["proof (prove)\nusing this:\n  map_of (Finca_to_list F1) f = None\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (map_of (Finca_to_list F1) f) (map_of xs f)", "using list_assoc_those_compile_env_entries[OF those_xs, of f]"], ["proof (prove)\nusing this:\n  map_of (Finca_to_list F1) f = None\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (map_of (Finca_to_list F1) f) (map_of xs f)\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (map_of (Finca_to_list F1) f) (map_of xs f)", "by simp"], ["proof (state)\nthis:\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (Finca_get F1 f) (Fubx_get F2 f)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (Finca_to_list F1) f = Some a \\<Longrightarrow>\n       rel_option\n        (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n        (Finca_get F1 f) (Fubx_get F2 f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (Finca_to_list F1) f = Some a \\<Longrightarrow>\n       rel_option\n        (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n        (Finca_get F1 f) (Fubx_get F2 f)", "case (Some fd1)"], ["proof (state)\nthis:\n  map_of (Finca_to_list F1) f = Some fd1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (Finca_to_list F1) f = Some a \\<Longrightarrow>\n       rel_option\n        (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n        (Finca_get F1 f) (Fubx_get F2 f)", "then"], ["proof (chain)\npicking this:\n  map_of (Finca_to_list F1) f = Some fd1", "show ?thesis"], ["proof (prove)\nusing this:\n  map_of (Finca_to_list F1) f = Some fd1\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (Fubx_get F2 f)", "unfolding F2_def Subx.Fenv.from_list_correct[symmetric]"], ["proof (prove)\nusing this:\n  map_of (Finca_to_list F1) f = Some fd1\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (Finca_get F1 f) (map_of xs f)", "unfolding Sinca.Fenv.to_list_correct[symmetric]"], ["proof (prove)\nusing this:\n  map_of (Finca_to_list F1) f = Some fd1\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (map_of (Finca_to_list F1) f) (map_of xs f)", "using list_assoc_those_compile_env_entries[OF those_xs, of f]"], ["proof (prove)\nusing this:\n  map_of (Finca_to_list F1) f = Some fd1\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (map_of (Finca_to_list F1) f) (map_of xs f)\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n     (map_of (Finca_to_list F1) f) (map_of xs f)", "by simp"], ["proof (state)\nthis:\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (Finca_get F1 f) (Fubx_get F2 f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (Finca_get F1 f) (Fubx_get F2 f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_those_compile_env_entries:\n  \"Result.those (map (compile_env_entry \\<A> \\<O>) xs) = Ok ys \\<Longrightarrow>\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list xs)) (Fubx_get (Subx.Fenv.from_list ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n    Ok ys \\<Longrightarrow>\n    rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n     (Fubx_get (Subx.Fenv.from_list ys))", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       Result.those (map (compile_env_entry \\<A> \\<O>) []) =\n       Ok ys \\<Longrightarrow>\n       rel_fundefs (Finca_get (Sinca.Fenv.from_list []))\n        (Fubx_get (Subx.Fenv.from_list ys))\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n                    (Fubx_get (Subx.Fenv.from_list ys));\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_fundefs\n                          (Finca_get (Sinca.Fenv.from_list (a # xs)))\n                          (Fubx_get (Subx.Fenv.from_list ys))", "case Nil"], ["proof (state)\nthis:\n  Result.those (map (compile_env_entry \\<A> \\<O>) []) = Ok ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       Result.those (map (compile_env_entry \\<A> \\<O>) []) =\n       Ok ys \\<Longrightarrow>\n       rel_fundefs (Finca_get (Sinca.Fenv.from_list []))\n        (Fubx_get (Subx.Fenv.from_list ys))\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n                    (Fubx_get (Subx.Fenv.from_list ys));\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_fundefs\n                          (Finca_get (Sinca.Fenv.from_list (a # xs)))\n                          (Fubx_get (Subx.Fenv.from_list ys))", "then"], ["proof (chain)\npicking this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) []) = Ok ys", "show ?case"], ["proof (prove)\nusing this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) []) = Ok ys\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get (Sinca.Fenv.from_list []))\n     (Fubx_get (Subx.Fenv.from_list ys))", "using rel_fundefs_empty"], ["proof (prove)\nusing this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) []) = Ok ys\n  rel_fundefs Map.empty Map.empty\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get (Sinca.Fenv.from_list []))\n     (Fubx_get (Subx.Fenv.from_list ys))", "by simp"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list []))\n   (Fubx_get (Subx.Fenv.from_list ys))\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n                    (Fubx_get (Subx.Fenv.from_list ys));\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_fundefs\n                          (Finca_get (Sinca.Fenv.from_list (a # xs)))\n                          (Fubx_get (Subx.Fenv.from_list ys))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n                    (Fubx_get (Subx.Fenv.from_list ys));\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_fundefs\n                          (Finca_get (Sinca.Fenv.from_list (a # xs)))\n                          (Fubx_get (Subx.Fenv.from_list ys))", "case (Cons x xs)"], ["proof (state)\nthis:\n  Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n  Ok ?ys63 \\<Longrightarrow>\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n   (Fubx_get (Subx.Fenv.from_list ?ys63))\n  Result.those (map (compile_env_entry \\<A> \\<O>) (x # xs)) = Ok ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n                    (Fubx_get (Subx.Fenv.from_list ys));\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_fundefs\n                          (Finca_get (Sinca.Fenv.from_list (a # xs)))\n                          (Fubx_get (Subx.Fenv.from_list ys))", "then"], ["proof (chain)\npicking this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n  Ok ?ys63 \\<Longrightarrow>\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n   (Fubx_get (Subx.Fenv.from_list ?ys63))\n  Result.those (map (compile_env_entry \\<A> \\<O>) (x # xs)) = Ok ys", "obtain y ys' where\n    xs_def: \"ys = y # ys'\" and\n    comp_x: \"compile_env_entry \\<A> \\<O> x = Ok y\" and\n    comp_xs: \"Result.those (map (compile_env_entry \\<A> \\<O>) xs) = Ok ys'\""], ["proof (prove)\nusing this:\n  Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n  Ok ?ys63 \\<Longrightarrow>\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n   (Fubx_get (Subx.Fenv.from_list ?ys63))\n  Result.those (map (compile_env_entry \\<A> \\<O>) (x # xs)) = Ok ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        \\<lbrakk>ys = y # ys'; compile_env_entry \\<A> \\<O> x = Ok y;\n         Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n         Ok ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ys = y # ys'\n  compile_env_entry \\<A> \\<O> x = Ok y\n  Result.those (map (compile_env_entry \\<A> \\<O>) xs) = Ok ys'\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n                    (Fubx_get (Subx.Fenv.from_list ys));\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_fundefs\n                          (Finca_get (Sinca.Fenv.from_list (a # xs)))\n                          (Fubx_get (Subx.Fenv.from_list ys))", "obtain f fd1 fd2 where prods: \"x = (f, fd1)\" \"y = (f, fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f fd1 fd2.\n        \\<lbrakk>x = (f, fd1); y = (f, fd2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using comp_x"], ["proof (prove)\nusing this:\n  compile_env_entry \\<A> \\<O> x = Ok y\n\ngoal (1 subgoal):\n 1. (\\<And>f fd1 fd2.\n        \\<lbrakk>x = (f, fd1); y = (f, fd2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x) (auto simp: compile_env_entry_def)"], ["proof (state)\nthis:\n  x = (f, fd1)\n  y = (f, fd2)\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n                    (Fubx_get (Subx.Fenv.from_list ys));\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_fundefs\n                          (Finca_get (Sinca.Fenv.from_list (a # xs)))\n                          (Fubx_get (Subx.Fenv.from_list ys))", "have \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using rel_compile_env_entry[OF comp_x[unfolded prods]]"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "."], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   Result.those (map (compile_env_entry \\<A> \\<O>) xs) =\n                   Ok ys \\<Longrightarrow>\n                   rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n                    (Fubx_get (Subx.Fenv.from_list ys));\n        Result.those (map (compile_env_entry \\<A> \\<O>) (a # xs)) =\n        Ok ys\\<rbrakk>\n       \\<Longrightarrow> rel_fundefs\n                          (Finca_get (Sinca.Fenv.from_list (a # xs)))\n                          (Fubx_get (Subx.Fenv.from_list ys))", "then"], ["proof (chain)\npicking this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "show ?case"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get (Sinca.Fenv.from_list (x # xs)))\n     (Fubx_get (Subx.Fenv.from_list ys))", "unfolding prods xs_def"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get (Sinca.Fenv.from_list ((f, fd1) # xs)))\n     (Fubx_get (Subx.Fenv.from_list ((f, fd2) # ys')))", "unfolding Sinca.Fenv.from_list_correct[symmetric] Subx.Fenv.from_list_correct[symmetric]"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_fundefs (map_of ((f, fd1) # xs)) (map_of ((f, fd2) # ys'))", "unfolding rel_fundefs_def"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (map_of ((f, fd1) # xs) x) (map_of ((f, fd2) # ys') x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2;\n        x \\<noteq> f\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (rel_fundef (\\<lambda>y z. y = norm_instr z))\n                          (map_of xs x) (map_of ys' x)", "using Cons.IH[OF comp_xs]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list xs))\n   (Fubx_get (Subx.Fenv.from_list ys'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2;\n        x \\<noteq> f\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (rel_fundef (\\<lambda>y z. y = norm_instr z))\n                          (map_of xs x) (map_of ys' x)", "unfolding Sinca.Fenv.from_list_correct[symmetric] Subx.Fenv.from_list_correct[symmetric]"], ["proof (prove)\nusing this:\n  rel_fundefs (map_of xs) (map_of ys')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2;\n        x \\<noteq> f\\<rbrakk>\n       \\<Longrightarrow> rel_option\n                          (rel_fundef (\\<lambda>y z. y = norm_instr z))\n                          (map_of xs x) (map_of ys' x)", "by (simp add: rel_fundefs_def)"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list (x # xs)))\n   (Fubx_get (Subx.Fenv.from_list ys))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_fundefs_compile_env:\n  assumes \"compile_env \\<A> \\<O> e = Ok e'\"\n  shows \"rel_fundefs (Finca_get e) (Fubx_get e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get e) (Fubx_get e')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get e) (Fubx_get e')", "obtain xs where\n    FOO: \"Result.those (map (compile_env_entry \\<A> \\<O>) (Finca_to_list e)) = Ok xs\" and\n    BAR: \"e' = Subx.Fenv.from_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>Result.those\n                  (map (compile_env_entry \\<A> \\<O>) (Finca_to_list e)) =\n                 Ok xs;\n         e' = Subx.Fenv.from_list xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  compile_env \\<A> \\<O> e = Ok e'\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>Result.those\n                  (map (compile_env_entry \\<A> \\<O>) (Finca_to_list e)) =\n                 Ok xs;\n         e' = Subx.Fenv.from_list xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: compile_env_def)"], ["proof (state)\nthis:\n  Result.those (map (compile_env_entry \\<A> \\<O>) (Finca_to_list e)) = Ok xs\n  e' = Subx.Fenv.from_list xs\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get e) (Fubx_get e')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get e) (Fubx_get e')", "using rel_those_compile_env_entries[OF FOO]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list (Finca_to_list e)))\n   (Fubx_get (Subx.Fenv.from_list xs))\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get e) (Fubx_get e')", "unfolding BAR"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get (Sinca.Fenv.from_list (Finca_to_list e)))\n   (Fubx_get (Subx.Fenv.from_list xs))\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get e) (Fubx_get (Subx.Fenv.from_list xs))", "unfolding Sinca.Fenv.get_from_list_to_list"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get e) (Fubx_get (Subx.Fenv.from_list xs))\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get e) (Fubx_get (Subx.Fenv.from_list xs))", "."], ["proof (state)\nthis:\n  rel_fundefs (Finca_get e) (Fubx_get e')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sp_fundefs_compile_env:\n  assumes\n    \"compile_env \\<A> \\<O> F1 = Ok F2\" and\n    \"\\<And>x. rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> x) (Finca_get F1 x)\"\n  shows \"sp_fundefs (Fubx_get F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2)", "unfolding sp_fundefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f fd.\n       Fubx_get F2 f = Some fd \\<longrightarrow>\n       sp_fundef (Fubx_get F2) fd (body fd) = Ok [None]", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f fd.\n       Fubx_get F2 f = Some fd \\<Longrightarrow>\n       sp_fundef (Fubx_get F2) fd (body fd) = Ok [None]", "fix f fd2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f fd.\n       Fubx_get F2 f = Some fd \\<Longrightarrow>\n       sp_fundef (Fubx_get F2) fd (body fd) = Ok [None]", "assume F2_f: \"Fubx_get F2 f = Some fd2\""], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. \\<And>f fd.\n       Fubx_get F2 f = Some fd \\<Longrightarrow>\n       sp_fundef (Fubx_get F2) fd (body fd) = Ok [None]", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2", "obtain fd1 where\n      \"Finca_get F1 f = Some fd1\" and\n      compile_fd1: \"compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using compile_env_rel_compile_fundef[OF assms(1), of f]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2\n  rel_option (\\<lambda>fd1 fd2. compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2)\n   (Finca_get F1 f) (Fubx_get F2 f)\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: option_rel_Some2)"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  compile_fundef \\<A> (\\<O> f) fd1 = Ok fd2\n\ngoal (1 subgoal):\n 1. \\<And>f fd.\n       Fubx_get F2 f = Some fd \\<Longrightarrow>\n       sp_fundef (Fubx_get F2) fd (body fd) = Ok [None]", "note rel_F1_F2 = rel_fundefs_compile_env[OF assms(1)]"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. \\<And>f fd.\n       Fubx_get F2 f = Some fd \\<Longrightarrow>\n       sp_fundef (Fubx_get F2) fd (body fd) = Ok [None]", "have \"rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f) (Fubx_get F2 f)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f) (Fubx_get F2 f)", "using assms(2)[of f]"], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f) (Finca_get F1 f)\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f) (Fubx_get F2 f)", "proof (cases rule: option.rel_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<A> f = None; Finca_get F1 f = None\\<rbrakk>\n    \\<Longrightarrow> rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f)\n                       (Fubx_get F2 f)\n 2. \\<And>x y.\n       \\<lbrakk>\\<A> f = Some x; Finca_get F1 f = Some y;\n        arity y = x\\<rbrakk>\n       \\<Longrightarrow> rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f)\n                          (Fubx_get F2 f)", "case None"], ["proof (state)\nthis:\n  \\<A> f = None\n  Finca_get F1 f = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<A> f = None; Finca_get F1 f = None\\<rbrakk>\n    \\<Longrightarrow> rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f)\n                       (Fubx_get F2 f)\n 2. \\<And>x y.\n       \\<lbrakk>\\<A> f = Some x; Finca_get F1 f = Some y;\n        arity y = x\\<rbrakk>\n       \\<Longrightarrow> rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f)\n                          (Fubx_get F2 f)", "then"], ["proof (chain)\npicking this:\n  \\<A> f = None\n  Finca_get F1 f = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<A> f = None\n  Finca_get F1 f = None\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f) (Fubx_get F2 f)", "using rel_fundefs_None1[OF rel_F1_F2]"], ["proof (prove)\nusing this:\n  \\<A> f = None\n  Finca_get F1 f = None\n  Finca_get F1 ?x = None \\<Longrightarrow> Fubx_get F2 ?x = None\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f) (Fubx_get F2 f)", "by simp"], ["proof (state)\nthis:\n  rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f) (Fubx_get F2 f)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<A> f = Some x; Finca_get F1 f = Some y;\n        arity y = x\\<rbrakk>\n       \\<Longrightarrow> rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f)\n                          (Fubx_get F2 f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<A> f = Some x; Finca_get F1 f = Some y;\n        arity y = x\\<rbrakk>\n       \\<Longrightarrow> rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f)\n                          (Fubx_get F2 f)", "case (Some ar fd1)"], ["proof (state)\nthis:\n  \\<A> f = Some ar\n  Finca_get F1 f = Some fd1\n  arity fd1 = ar\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<A> f = Some x; Finca_get F1 f = Some y;\n        arity y = x\\<rbrakk>\n       \\<Longrightarrow> rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f)\n                          (Fubx_get F2 f)", "then"], ["proof (chain)\npicking this:\n  \\<A> f = Some ar\n  Finca_get F1 f = Some fd1\n  arity fd1 = ar", "obtain fd2 where\n        \"Fubx_get F2 f = Some fd2\" and\n        rel_fd1_fd2: \"rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\""], ["proof (prove)\nusing this:\n  \\<A> f = Some ar\n  Finca_get F1 f = Some fd1\n  arity fd1 = ar\n\ngoal (1 subgoal):\n 1. (\\<And>fd2.\n        \\<lbrakk>Fubx_get F2 f = Some fd2;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some1[OF rel_F1_F2]"], ["proof (prove)\nusing this:\n  \\<A> f = Some ar\n  Finca_get F1 f = Some fd1\n  arity fd1 = ar\n  Finca_get F1 ?x = Some ?y \\<Longrightarrow>\n  \\<exists>z.\n     Fubx_get F2 ?x = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) ?y z\n\ngoal (1 subgoal):\n 1. (\\<And>fd2.\n        \\<lbrakk>Fubx_get F2 f = Some fd2;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson rel_fundefs_Some1)"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>\\<A> f = Some x; Finca_get F1 f = Some y;\n        arity y = x\\<rbrakk>\n       \\<Longrightarrow> rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f)\n                          (Fubx_get F2 f)", "with Some"], ["proof (chain)\npicking this:\n  \\<A> f = Some ar\n  Finca_get F1 f = Some fd1\n  arity fd1 = ar\n  Fubx_get F2 f = Some fd2\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<A> f = Some ar\n  Finca_get F1 f = Some fd1\n  arity fd1 = ar\n  Fubx_get F2 f = Some fd2\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f) (Fubx_get F2 f)", "by (simp add: rel_fundef_arities)"], ["proof (state)\nthis:\n  rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> f) (Fubx_get F2 f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> ?f63) (Fubx_get F2 ?f63)\n\ngoal (1 subgoal):\n 1. \\<And>f fd.\n       Fubx_get F2 f = Some fd \\<Longrightarrow>\n       sp_fundef (Fubx_get F2) fd (body fd) = Ok [None]", "thus \"sp_fundef (Fubx_get F2) fd2 (body fd2) = Ok [None]\""], ["proof (prove)\nusing this:\n  rel_option (\\<lambda>ar fd. arity fd = ar) (\\<A> ?f63) (Fubx_get F2 ?f63)\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) fd2 (body fd2) = Ok [None]", "by (auto intro!: sp_compile_fundef[OF compile_fd1])"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get F2) fd2 (body fd2) = Ok [None]\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Compilation of program\\<close>"], ["", "fun compile where\n  \"compile (Prog F H f) = Result.to_option (do {\n    F' \\<leftarrow> compile_env (map_option arity \\<circ> Finca_get F) load_oracle F;\n    Ok (Prog F' H f)\n  })\""], ["", "lemma compile_load:\n  assumes\n    compile_p1: \"compile p1 = Some p2\" and\n    load: \"Subx.load p2 s2\"\n  shows \"\\<exists>s1. Sinca.load p1 s1 \\<and> match s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "obtain F1 H main where p1_def: \"p1 = Prog F1 H main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>F1 H main.\n        p1 = Prog F1 H main \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p1) simp"], ["proof (state)\nthis:\n  p1 = Prog F1 H main\n\ngoal (1 subgoal):\n 1. \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "then"], ["proof (chain)\npicking this:\n  p1 = Prog F1 H main", "obtain F2 where\n    compile_F1: \"compile_env (map_option arity \\<circ> Finca_get F1) load_oracle F1 = Ok F2\" and\n    p2_def: \"p2 = Prog F2 H main\""], ["proof (prove)\nusing this:\n  p1 = Prog F1 H main\n\ngoal (1 subgoal):\n 1. (\\<And>F2.\n        \\<lbrakk>compile_env (map_option arity \\<circ> Finca_get F1)\n                  load_oracle F1 =\n                 Ok F2;\n         p2 = Prog F2 H main\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using compile_p1"], ["proof (prove)\nusing this:\n  p1 = Prog F1 H main\n  compile p1 = Some p2\n\ngoal (1 subgoal):\n 1. (\\<And>F2.\n        \\<lbrakk>compile_env (map_option arity \\<circ> Finca_get F1)\n                  load_oracle F1 =\n                 Ok F2;\n         p2 = Prog F2 H main\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  compile_env (map_option arity \\<circ> Finca_get F1) load_oracle F1 = Ok F2\n  p2 = Prog F2 H main\n\ngoal (1 subgoal):\n 1. \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "note rel_F1_F2 = rel_fundefs_compile_env[OF compile_F1]"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "using assms(2)"], ["proof (prove)\nusing this:\n  Subx.load p2 s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "unfolding p2_def"], ["proof (prove)\nusing this:\n  Subx.load (Prog F2 H main) s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "proof (cases _ s2 rule: Subx.load.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State F2 H [Frame main 0 []];\n        Fubx_get F2 main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "case (1 fd2)"], ["proof (state)\nthis:\n  s2 = State F2 H [Frame main 0 []]\n  Fubx_get F2 main = Some fd2\n  arity fd2 = 0\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State F2 H [Frame main 0 []];\n        Fubx_get F2 main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "let ?s1 = \"State F1 H [Frame main 0 []]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State F2 H [Frame main 0 []];\n        Fubx_get F2 main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "from 1"], ["proof (chain)\npicking this:\n  s2 = State F2 H [Frame main 0 []]\n  Fubx_get F2 main = Some fd2\n  arity fd2 = 0", "obtain fd1 where\n      Fstd_main: \"Finca_get F1 main = Some fd1\" and\n      \"compile_fundef (map_option arity \\<circ> Finca_get F1) (load_oracle main) fd1 = Ok fd2\""], ["proof (prove)\nusing this:\n  s2 = State F2 H [Frame main 0 []]\n  Fubx_get F2 main = Some fd2\n  arity fd2 = 0\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 main = Some fd1;\n         compile_fundef (map_option arity \\<circ> Finca_get F1)\n          (load_oracle main) fd1 =\n         Ok fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using compile_env_rel_compile_fundef[OF compile_F1, of main]"], ["proof (prove)\nusing this:\n  s2 = State F2 H [Frame main 0 []]\n  Fubx_get F2 main = Some fd2\n  arity fd2 = 0\n  rel_option\n   (\\<lambda>fd1 fd2.\n       compile_fundef (map_option arity \\<circ> Finca_get F1)\n        (load_oracle main) fd1 =\n       Ok fd2)\n   (Finca_get F1 main) (Fubx_get F2 main)\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 main = Some fd1;\n         compile_fundef (map_option arity \\<circ> Finca_get F1)\n          (load_oracle main) fd1 =\n         Ok fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: option_rel_Some2)"], ["proof (state)\nthis:\n  Finca_get F1 main = Some fd1\n  compile_fundef (map_option arity \\<circ> Finca_get F1) (load_oracle main)\n   fd1 =\n  Ok fd2\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State F2 H [Frame main 0 []];\n        Fubx_get F2 main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "with 1"], ["proof (chain)\npicking this:\n  s2 = State F2 H [Frame main 0 []]\n  Fubx_get F2 main = Some fd2\n  arity fd2 = 0\n  Finca_get F1 main = Some fd1\n  compile_fundef (map_option arity \\<circ> Finca_get F1) (load_oracle main)\n   fd1 =\n  Ok fd2", "have \"arity fd1 = 0\""], ["proof (prove)\nusing this:\n  s2 = State F2 H [Frame main 0 []]\n  Fubx_get F2 main = Some fd2\n  arity fd2 = 0\n  Finca_get F1 main = Some fd1\n  compile_fundef (map_option arity \\<circ> Finca_get F1) (load_oracle main)\n   fd1 =\n  Ok fd2\n\ngoal (1 subgoal):\n 1. arity fd1 = 0", "using fundef.rel_sel rel_compile_fundef"], ["proof (prove)\nusing this:\n  s2 = State F2 H [Frame main 0 []]\n  Fubx_get F2 main = Some fd2\n  arity fd2 = 0\n  Finca_get F1 main = Some fd1\n  compile_fundef (map_option arity \\<circ> Finca_get F1) (load_oracle main)\n   fd1 =\n  Ok fd2\n  rel_fundef ?R ?a ?b =\n  (list_all2 ?R (body ?a) (body ?b) \\<and> arity ?a = arity ?b)\n  compile_fundef ?get_arity ?load_oracle ?fd1.0 =\n  Ok ?fd2.0 \\<Longrightarrow>\n  rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0\n\ngoal (1 subgoal):\n 1. arity fd1 = 0", "by metis"], ["proof (state)\nthis:\n  arity fd1 = 0\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State F2 H [Frame main 0 []];\n        Fubx_get F2 main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "hence \"Sinca.load p1 ?s1\""], ["proof (prove)\nusing this:\n  arity fd1 = 0\n\ngoal (1 subgoal):\n 1. Sinca.load p1 (State F1 H [Frame main 0 []])", "unfolding p1_def"], ["proof (prove)\nusing this:\n  arity fd1 = 0\n\ngoal (1 subgoal):\n 1. Sinca.load (Prog F1 H main) (State F1 H [Frame main 0 []])", "by (auto intro!: Sinca.load.intros[OF Fstd_main])"], ["proof (state)\nthis:\n  Sinca.load p1 (State F1 H [Frame main 0 []])\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State F2 H [Frame main 0 []];\n        Fubx_get F2 main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "moreover"], ["proof (state)\nthis:\n  Sinca.load p1 (State F1 H [Frame main 0 []])\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State F2 H [Frame main 0 []];\n        Fubx_get F2 main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "have \"?s1 \\<sim> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H [Frame main 0 []] \\<sim> s2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. State F1 H [Frame main 0 []] \\<sim> s2", "have \"sp_fundefs (Fubx_get F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2)", "by (auto intro: sp_fundefs_compile_env[OF compile_F1] simp: option.rel_map option.rel_refl)"], ["proof (state)\nthis:\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H [Frame main 0 []] \\<sim> s2", "moreover"], ["proof (state)\nthis:\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H [Frame main 0 []] \\<sim> s2", "have \"rel_stacktraces (Fubx_get F2) [Frame main 0 []] [Frame main 0 []] None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) [Frame main 0 []] [Frame main 0 []] None", "using 1"], ["proof (prove)\nusing this:\n  s2 = State F2 H [Frame main 0 []]\n  Fubx_get F2 main = Some fd2\n  arity fd2 = 0\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) [Frame main 0 []] [Frame main 0 []] None", "by (auto intro!: rel_stacktraces.intros simp: sp_fundef_def)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2) [Frame main 0 []] [Frame main 0 []] None\n\ngoal (1 subgoal):\n 1. State F1 H [Frame main 0 []] \\<sim> s2", "ultimately"], ["proof (chain)\npicking this:\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) [Frame main 0 []] [Frame main 0 []] None", "show ?thesis"], ["proof (prove)\nusing this:\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) [Frame main 0 []] [Frame main 0 []] None\n\ngoal (1 subgoal):\n 1. State F1 H [Frame main 0 []] \\<sim> s2", "unfolding 1"], ["proof (prove)\nusing this:\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) [Frame main 0 []] [Frame main 0 []] None\n\ngoal (1 subgoal):\n 1. State F1 H [Frame main 0 []] \\<sim> State F2 H [Frame main 0 []]", "using rel_F1_F2"], ["proof (prove)\nusing this:\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) [Frame main 0 []] [Frame main 0 []] None\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H [Frame main 0 []] \\<sim> State F2 H [Frame main 0 []]", "by (auto intro!: match.intros)"], ["proof (state)\nthis:\n  State F1 H [Frame main 0 []] \\<sim> s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State F1 H [Frame main 0 []] \\<sim> s2\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State F2 H [Frame main 0 []];\n        Fubx_get F2 main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.load p1 (State F1 H [Frame main 0 []])\n  State F1 H [Frame main 0 []] \\<sim> s2", "show ?thesis"], ["proof (prove)\nusing this:\n  Sinca.load p1 (State F1 H [Frame main 0 []])\n  State F1 H [Frame main 0 []] \\<sim> s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2", "by auto"], ["proof (state)\nthis:\n  \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1. Sinca.load p1 s1 \\<and> s1 \\<sim> s2\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation std_to_inca_compiler:\n  compiler Sinca.step Subx.step Sinca.final Subx.final Sinca.load Subx.load\n    \"\\<lambda>_ _. False\" \"\\<lambda>_. match\" compile"], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler Sinca.step Subx.step Sinca.final Subx.final Sinca.load\n     Subx.load (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>)) compile", "using compile_load"], ["proof (prove)\nusing this:\n  \\<lbrakk>compile ?p1.0 = Some ?p2.0; Subx.load ?p2.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1. Sinca.load ?p1.0 s1 \\<and> s1 \\<sim> ?s2.0\n\ngoal (1 subgoal):\n 1. compiler Sinca.step Subx.step Sinca.final Subx.final Sinca.load\n     Subx.load (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>)) compile", "by unfold_locales auto"], ["", "end"], ["", "end"]]}