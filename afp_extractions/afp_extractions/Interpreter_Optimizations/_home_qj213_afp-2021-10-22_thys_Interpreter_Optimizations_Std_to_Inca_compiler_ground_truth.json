{"file_name": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations/Std_to_Inca_compiler.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations", "problem_names": ["lemma norm_compile_instr:\n  \"norm_instr (compile_instr instr) = instr\"", "lemma rel_compile_fundef: \"rel_fundef norm_eq fd (compile_fundef fd)\"", "lemma Finca_get_compile: \"Finca_get (compile_env e) x = map_option compile_fundef (Fstd_get e x)\"", "lemma rel_fundefs_compile_env: \"rel_fundefs (Fstd_get e) (Finca_get (compile_env e))\"", "theorem compile_load:\n  assumes \"compile p1 = Some p2\" and \"Sinca.load p2 s2\"\n  shows \"\\<exists>s1. Sstd.load p1 s1 \\<and> match s1 s2\"", "theorem compile_complete:\n  assumes \"Sstd.load p\\<^sub>1 s\\<^sub>1\"\n  shows \"\\<exists>p\\<^sub>2 s\\<^sub>2. compile p\\<^sub>1 = Some p\\<^sub>2 \\<and> Sinca.load p\\<^sub>2 s\\<^sub>2 \\<and> match s\\<^sub>1 s\\<^sub>2\""], "translations": [["", "lemma norm_compile_instr:\n  \"norm_instr (compile_instr instr) = instr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_instr (compile_instr instr) = instr", "by (cases instr) auto"], ["", "lemma rel_compile_fundef: \"rel_fundef norm_eq fd (compile_fundef fd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd (compile_fundef fd)", "proof (cases fd)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       fd = Fundef x1 x2 \\<Longrightarrow>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) fd (compile_fundef fd)", "case (Fundef xs ar)"], ["proof (state)\nthis:\n  fd = Fundef xs ar\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       fd = Fundef x1 x2 \\<Longrightarrow>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) fd (compile_fundef fd)", "then"], ["proof (chain)\npicking this:\n  fd = Fundef xs ar", "show ?thesis"], ["proof (prove)\nusing this:\n  fd = Fundef xs ar\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd (compile_fundef fd)", "by (simp add: list.rel_map list.rel_eq norm_compile_instr)"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd (compile_fundef fd)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition compile_env where\n  \"compile_env e = Sinca.Fenv.from_list (map (map_prod id compile_fundef) (Fstd_to_list e))\""], ["", "lemma Finca_get_compile: \"Finca_get (compile_env e) x = map_option compile_fundef (Fstd_get e x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finca_get (compile_env e) x = map_option compile_fundef (Fstd_get e x)", "using Sinca.Fenv.from_list_correct[symmetric] Sstd.Fenv.to_list_correct"], ["proof (prove)\nusing this:\n  Finca_get (Sinca.Fenv.from_list ?xs) ?k = map_of ?xs ?k\n  map_of (Fstd_to_list ?e) = Fstd_get ?e\n\ngoal (1 subgoal):\n 1. Finca_get (compile_env e) x = map_option compile_fundef (Fstd_get e x)", "by (simp add: compile_env_def map_prod_def map_of_map)"], ["", "lemma rel_fundefs_compile_env: \"rel_fundefs (Fstd_get e) (Finca_get (compile_env e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Fstd_get e) (Finca_get (compile_env e))", "unfolding rel_fundefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n        (Fstd_get e x) (Finca_get (compile_env e) x)", "unfolding Finca_get_compile"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n        (Fstd_get e x) (map_option compile_fundef (Fstd_get e x))", "unfolding option.rel_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       rel_option\n        (\\<lambda>x y.\n            rel_fundef (\\<lambda>x y. x = norm_instr y) x\n             (compile_fundef y))\n        (Fstd_get e x) (Fstd_get e x)", "by (auto intro: option.rel_refl rel_compile_fundef)"], ["", "fun compile where\n  \"compile (Prog F H main) = Some (Prog (compile_env F) H main)\""], ["", "theorem compile_load:\n  assumes \"compile p1 = Some p2\" and \"Sinca.load p2 s2\"\n  shows \"\\<exists>s1. Sstd.load p1 s1 \\<and> match s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "proof (cases p1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       p1 = Prog x1 x2 x3 \\<Longrightarrow>\n       \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "case (Prog F H main)"], ["proof (state)\nthis:\n  p1 = Prog F H main\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       p1 = Prog x1 x2 x3 \\<Longrightarrow>\n       \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "then"], ["proof (chain)\npicking this:\n  p1 = Prog F H main", "have p2_def: \"p2 = Prog (compile_env F) H main\""], ["proof (prove)\nusing this:\n  p1 = Prog F H main\n\ngoal (1 subgoal):\n 1. p2 = Prog (compile_env F) H main", "using assms(1)"], ["proof (prove)\nusing this:\n  p1 = Prog F H main\n  compile p1 = Some p2\n\ngoal (1 subgoal):\n 1. p2 = Prog (compile_env F) H main", "by simp"], ["proof (state)\nthis:\n  p2 = Prog (compile_env F) H main\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3.\n       p1 = Prog x1 x2 x3 \\<Longrightarrow>\n       \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "using assms(2)"], ["proof (prove)\nusing this:\n  Sinca.load p2 s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "unfolding p2_def"], ["proof (prove)\nusing this:\n  Sinca.load (Prog (compile_env F) H main) s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "proof (cases _ s2 rule: Sinca.load.cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State (compile_env F) H [Frame main 0 []];\n        Finca_get (compile_env F) main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "case (1 fd')"], ["proof (state)\nthis:\n  s2 = State (compile_env F) H [Frame main 0 []]\n  Finca_get (compile_env F) main = Some fd'\n  arity fd' = 0\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State (compile_env F) H [Frame main 0 []];\n        Finca_get (compile_env F) main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "let ?s1 = \"State F H [Frame main 0 []]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State (compile_env F) H [Frame main 0 []];\n        Finca_get (compile_env F) main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "from 1"], ["proof (chain)\npicking this:\n  s2 = State (compile_env F) H [Frame main 0 []]\n  Finca_get (compile_env F) main = Some fd'\n  arity fd' = 0", "obtain fd where\n      Fstd_main: \"Fstd_get F main = Some fd\" and \"fd' = compile_fundef fd\""], ["proof (prove)\nusing this:\n  s2 = State (compile_env F) H [Frame main 0 []]\n  Finca_get (compile_env F) main = Some fd'\n  arity fd' = 0\n\ngoal (1 subgoal):\n 1. (\\<And>fd.\n        \\<lbrakk>Fstd_get F main = Some fd; fd' = compile_fundef fd\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Finca_get_compile"], ["proof (prove)\nusing this:\n  s2 = State (compile_env F) H [Frame main 0 []]\n  Finca_get (compile_env F) main = Some fd'\n  arity fd' = 0\n  Finca_get (compile_env ?e) ?x = map_option compile_fundef (Fstd_get ?e ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>fd.\n        \\<lbrakk>Fstd_get F main = Some fd; fd' = compile_fundef fd\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Fstd_get F main = Some fd\n  fd' = compile_fundef fd\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State (compile_env F) H [Frame main 0 []];\n        Finca_get (compile_env F) main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "with 1"], ["proof (chain)\npicking this:\n  s2 = State (compile_env F) H [Frame main 0 []]\n  Finca_get (compile_env F) main = Some fd'\n  arity fd' = 0\n  Fstd_get F main = Some fd\n  fd' = compile_fundef fd", "have \"arity fd = 0\""], ["proof (prove)\nusing this:\n  s2 = State (compile_env F) H [Frame main 0 []]\n  Finca_get (compile_env F) main = Some fd'\n  arity fd' = 0\n  Fstd_get F main = Some fd\n  fd' = compile_fundef fd\n\ngoal (1 subgoal):\n 1. arity fd = 0", "by (metis fundef.rel_sel rel_compile_fundef)"], ["proof (state)\nthis:\n  arity fd = 0\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State (compile_env F) H [Frame main 0 []];\n        Finca_get (compile_env F) main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "hence \"Sstd.load p1 ?s1\""], ["proof (prove)\nusing this:\n  arity fd = 0\n\ngoal (1 subgoal):\n 1. Sstd.load p1 (State F H [Frame main 0 []])", "unfolding Prog"], ["proof (prove)\nusing this:\n  arity fd = 0\n\ngoal (1 subgoal):\n 1. Sstd.load (Prog F H main) (State F H [Frame main 0 []])", "by (auto intro: Sstd.load.intros[OF Fstd_main])"], ["proof (state)\nthis:\n  Sstd.load p1 (State F H [Frame main 0 []])\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State (compile_env F) H [Frame main 0 []];\n        Finca_get (compile_env F) main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "moreover"], ["proof (state)\nthis:\n  Sstd.load p1 (State F H [Frame main 0 []])\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State (compile_env F) H [Frame main 0 []];\n        Finca_get (compile_env F) main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "have \"?s1 \\<sim> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F H [Frame main 0 []] \\<sim> s2", "unfolding 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. State F H [Frame main 0 []] \\<sim>\n    State (compile_env F) H [Frame main 0 []]", "using rel_fundefs_compile_env"], ["proof (prove)\nusing this:\n  rel_fundefs (Fstd_get ?e) (Finca_get (compile_env ?e))\n\ngoal (1 subgoal):\n 1. State F H [Frame main 0 []] \\<sim>\n    State (compile_env F) H [Frame main 0 []]", "by (auto intro!: match.intros)"], ["proof (state)\nthis:\n  State F H [Frame main 0 []] \\<sim> s2\n\ngoal (1 subgoal):\n 1. \\<And>fd.\n       \\<lbrakk>s2 = State (compile_env F) H [Frame main 0 []];\n        Finca_get (compile_env F) main = Some fd; arity fd = 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "ultimately"], ["proof (chain)\npicking this:\n  Sstd.load p1 (State F H [Frame main 0 []])\n  State F H [Frame main 0 []] \\<sim> s2", "show ?thesis"], ["proof (prove)\nusing this:\n  Sstd.load p1 (State F H [Frame main 0 []])\n  State F H [Frame main 0 []] \\<sim> s2\n\ngoal (1 subgoal):\n 1. \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2", "by auto"], ["proof (state)\nthis:\n  \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1. Sstd.load p1 s1 \\<and> s1 \\<sim> s2\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale std_to_inca_compiler:\n  compiler Sstd.step Sinca.step Sstd.final Sinca.final Sstd.load Sinca.load\n    \"\\<lambda>_ _. False\" \"\\<lambda>_. match\" compile"], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler Sstd.step Sinca.step Sstd.final Sinca.final Sstd.load\n     Sinca.load (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>)) compile", "using compile_load"], ["proof (prove)\nusing this:\n  \\<lbrakk>compile ?p1.0 = Some ?p2.0; Sinca.load ?p2.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1. Sstd.load ?p1.0 s1 \\<and> s1 \\<sim> ?s2.0\n\ngoal (1 subgoal):\n 1. compiler Sstd.step Sinca.step Sstd.final Sinca.final Sstd.load\n     Sinca.load (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>)) compile", "by unfold_locales auto"], ["", "theorem compile_complete:\n  assumes \"Sstd.load p\\<^sub>1 s\\<^sub>1\"\n  shows \"\\<exists>p\\<^sub>2 s\\<^sub>2. compile p\\<^sub>1 = Some p\\<^sub>2 \\<and> Sinca.load p\\<^sub>2 s\\<^sub>2 \\<and> match s\\<^sub>1 s\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p\\<^sub>2 s\\<^sub>2.\n       compile p\\<^sub>1 = Some p\\<^sub>2 \\<and>\n       Sinca.load p\\<^sub>2 s\\<^sub>2 \\<and> s\\<^sub>1 \\<sim> s\\<^sub>2", "using assms"], ["proof (prove)\nusing this:\n  Sstd.load p\\<^sub>1 s\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<^sub>2 s\\<^sub>2.\n       compile p\\<^sub>1 = Some p\\<^sub>2 \\<and>\n       Sinca.load p\\<^sub>2 s\\<^sub>2 \\<and> s\\<^sub>1 \\<sim> s\\<^sub>2", "by (auto elim!: Sstd.load.cases\n      intro!: match.intros rel_fundefs_compile_env\n      simp add: Sinca.load.simps Finca_get_compile rel_fundef_arities[OF rel_compile_fundef])"], ["", "end"], ["", "end"]]}