{"file_name": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations/Op_example.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations", "problem_names": ["lemma eval_arith_domain: \"length xs = ar op \\<Longrightarrow> \\<exists>y. eval op xs = y\"", "lemma inl_inj: \"inj inl\"", "lemma inl_invertible: \"inl op xs = Some opinl \\<Longrightarrow> deinl opinl = op\"", "lemma eval_AddNum_correct:\n  \"length xs = 2 \\<Longrightarrow> eval_AddNum xs = eval_Add xs\"", "lemma eval_MulNum_correct:\n  \"length xs = 2 \\<Longrightarrow> eval_MulNum xs = eval_Mul xs\"", "lemma eval_inl_correct:\n  \"length xs = ar (deinl opinl) \\<Longrightarrow> eval_inl opinl xs = eval (deinl opinl) xs\"", "lemma inl_isinl:\n  \"inl op xs = Some opinl \\<Longrightarrow> isinl opinl xs\"", "lemma ubx_invertible: \"ubx opinl xs = Some opubx \\<Longrightarrow> deubx opubx = opinl\"", "lemma eval_ubx_correct:\n  \"eval_ubx opubx xs = Some z \\<Longrightarrow>\n    eval_inl (deubx opubx) (map unboxed_dynamic.norm_unboxed xs) = unboxed_dynamic.norm_unboxed z\"", "lemma eval_ubx_to_inl:\n  assumes \"eval_ubx opubx \\<Sigma> = Some z\"\n  shows \"inl (deinl (deubx opubx)) (map unboxed_dynamic.norm_unboxed \\<Sigma>) = Some (deubx opubx)\"", "lemma ubx_imp_typeof_opubx:\n  \"ubx opinl ts = Some opubx \\<Longrightarrow> fst (typeof_opubx opubx) = ts\"", "lemma typeof_opubx_correct:\n  \"typeof_opubx opubx = (map typeof xs, codomain) \\<Longrightarrow>\n    \\<exists>y. eval_ubx opubx xs = Some y \\<and> typeof y = codomain\"", "lemma typeof_opubx_complete:\n  \"eval_ubx opubx xs = Some y \\<Longrightarrow>\n    typeof_opubx opubx = (map typeof xs, typeof y)\"", "lemma typeof_opubx_ar: \"length (fst (typeof_opubx opubx)) = ar (deinl (deubx opubx))\""], "translations": [["", "lemma eval_arith_domain: \"length xs = ar op \\<Longrightarrow> \\<exists>y. eval op xs = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = ar op \\<Longrightarrow> \\<exists>y. eval op xs = y", "by simp"], ["", "interpretation op_Op: nary_operations eval ar"], ["proof (prove)\ngoal (1 subgoal):\n 1. nary_operations eval ar", "using eval_arith_domain"], ["proof (prove)\nusing this:\n  length ?xs = ar ?op \\<Longrightarrow> \\<exists>y. eval ?op ?xs = y\n\ngoal (1 subgoal):\n 1. nary_operations eval ar", "by (unfold_locales; simp)"], ["", "section \\<open>Inlined operations\\<close>"], ["", "datatype opinl =\n  OpAddNum |\n  OpMulNum"], ["", "fun inl :: \"op \\<Rightarrow> dynamic list \\<Rightarrow> opinl option\" where\n  \"inl OpAdd [DNum _, DNum _] = Some OpAddNum\" |\n  \"inl OpMul [DNum _, DNum _] = Some OpMulNum\" |\n  \"inl _ _ = None\""], ["", "inductive isinl :: \"opinl \\<Rightarrow> dynamic list \\<Rightarrow> bool\" where\n  \"isinl OpAddNum [DNum _, DNum _]\" |\n  \"isinl OpMulNum [DNum _, DNum _]\""], ["", "fun deinl :: \"opinl \\<Rightarrow> op\" where\n  \"deinl OpAddNum = OpAdd\" |\n  \"deinl OpMulNum = OpMul\""], ["", "lemma inl_inj: \"inj inl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj inl", "unfolding inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. inl x = inl y \\<longrightarrow> x = y", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. inl x = inl y \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. inl x = inl y \\<Longrightarrow> x = y", "assume \"inl x = inl y\""], ["proof (state)\nthis:\n  inl x = inl y\n\ngoal (1 subgoal):\n 1. \\<And>x y. inl x = inl y \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  inl x = inl y\n\ngoal (1 subgoal):\n 1. x = y", "unfolding fun_eq_iff"], ["proof (prove)\nusing this:\n  \\<forall>xa. inl x xa = inl y xa\n\ngoal (1 subgoal):\n 1. x = y", "by (cases x; cases y; auto elim: inl.elims simp: HOL.eq_commute[of None])"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inl_invertible: \"inl op xs = Some opinl \\<Longrightarrow> deinl opinl = op\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inl op xs = Some opinl \\<Longrightarrow> deinl opinl = op", "by (induction op xs rule: inl.induct; simp)"], ["", "fun eval_AddNum :: \"dynamic list \\<Rightarrow> dynamic\" where\n  \"eval_AddNum [DNum x, DNum y] = DNum (x + y)\" |\n  \"eval_AddNum [DBool x, DBool y] = DBool (x \\<or> y)\" |\n  \"eval_AddNum [_, _] = DNil\""], ["", "fun eval_MulNum :: \"dynamic list \\<Rightarrow> dynamic\" where\n  \"eval_MulNum [DNum x, DNum y] = DNum (x * y)\" |\n  \"eval_MulNum [DBool x, DBool y] = DBool (x \\<and> y)\" |\n  \"eval_MulNum [_, _] = DNil\""], ["", "fun eval_inl :: \"opinl \\<Rightarrow> dynamic list \\<Rightarrow> dynamic\" where\n  \"eval_inl OpAddNum = eval_AddNum\" |\n  \"eval_inl OpMulNum = eval_MulNum\""], ["", "lemma eval_AddNum_correct:\n  \"length xs = 2 \\<Longrightarrow> eval_AddNum xs = eval_Add xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = 2 \\<Longrightarrow> eval_AddNum xs = eval_Add xs", "by (induction xs rule: eval_AddNum.induct; simp)"], ["", "lemma eval_MulNum_correct:\n  \"length xs = 2 \\<Longrightarrow> eval_MulNum xs = eval_Mul xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = 2 \\<Longrightarrow> eval_MulNum xs = eval_Mul xs", "by (induction xs rule: eval_MulNum.induct; simp)"], ["", "lemma eval_inl_correct:\n  \"length xs = ar (deinl opinl) \\<Longrightarrow> eval_inl opinl xs = eval (deinl opinl) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = ar (deinl opinl) \\<Longrightarrow>\n    eval_inl opinl xs = eval (deinl opinl) xs", "using eval_AddNum_correct eval_MulNum_correct"], ["proof (prove)\nusing this:\n  length ?xs = 2 \\<Longrightarrow> eval_AddNum ?xs = eval_Add ?xs\n  length ?xs = 2 \\<Longrightarrow> eval_MulNum ?xs = eval_Mul ?xs\n\ngoal (1 subgoal):\n 1. length xs = ar (deinl opinl) \\<Longrightarrow>\n    eval_inl opinl xs = eval (deinl opinl) xs", "by (cases opinl; simp)"], ["", "lemma inl_isinl:\n  \"inl op xs = Some opinl \\<Longrightarrow> isinl opinl xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inl op xs = Some opinl \\<Longrightarrow> isinl opinl xs", "by (induction op xs rule: inl.induct; auto intro: isinl.intros)"], ["", "interpretation op_OpInl: nary_operations_inl eval ar eval_inl inl isinl deinl"], ["proof (prove)\ngoal (1 subgoal):\n 1. nary_operations_inl eval ar eval_inl inl isinl deinl", "using inl_invertible"], ["proof (prove)\nusing this:\n  inl ?op ?xs = Some ?opinl \\<Longrightarrow> deinl ?opinl = ?op\n\ngoal (1 subgoal):\n 1. nary_operations_inl eval ar eval_inl inl isinl deinl", "using eval_inl_correct"], ["proof (prove)\nusing this:\n  inl ?op ?xs = Some ?opinl \\<Longrightarrow> deinl ?opinl = ?op\n  length ?xs = ar (deinl ?opinl) \\<Longrightarrow>\n  eval_inl ?opinl ?xs = eval (deinl ?opinl) ?xs\n\ngoal (1 subgoal):\n 1. nary_operations_inl eval ar eval_inl inl isinl deinl", "using inl_isinl"], ["proof (prove)\nusing this:\n  inl ?op ?xs = Some ?opinl \\<Longrightarrow> deinl ?opinl = ?op\n  length ?xs = ar (deinl ?opinl) \\<Longrightarrow>\n  eval_inl ?opinl ?xs = eval (deinl ?opinl) ?xs\n  inl ?op ?xs = Some ?opinl \\<Longrightarrow> isinl ?opinl ?xs\n\ngoal (1 subgoal):\n 1. nary_operations_inl eval ar eval_inl inl isinl deinl", "by (unfold_locales; simp)"], ["", "section \\<open>Unboxed operations\\<close>"], ["", "datatype opubx =\n  OpAddNumUbx"], ["", "fun ubx :: \"opinl \\<Rightarrow> type option list \\<Rightarrow> opubx option\" where\n  \"ubx OpAddNum [Some Ubx1, Some Ubx1] = Some OpAddNumUbx\" |\n  \"ubx _ _ = None\""], ["", "fun deubx :: \"opubx \\<Rightarrow> opinl\" where\n  \"deubx OpAddNumUbx = OpAddNum\""], ["", "lemma ubx_invertible: \"ubx opinl xs = Some opubx \\<Longrightarrow> deubx opubx = opinl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Op_example.ubx opinl xs = Some opubx \\<Longrightarrow>\n    deubx opubx = opinl", "by (induction opinl xs rule: ubx.induct; simp)"], ["", "fun eval_AddNumUbx :: \"(dynamic, nat, bool) unboxed list \\<Rightarrow> (dynamic, nat, bool) unboxed option\" where\n  \"eval_AddNumUbx [OpUbx1 x, OpUbx1 y] = Some (OpUbx1 (x + y))\" |\n  \"eval_AddNumUbx _ = None\""], ["", "fun eval_ubx :: \"opubx \\<Rightarrow> (dynamic, nat, bool) unboxed list \\<Rightarrow> (dynamic, nat, bool) unboxed option\" where\n  \"eval_ubx OpAddNumUbx = eval_AddNumUbx\""], ["", "lemma eval_ubx_correct:\n  \"eval_ubx opubx xs = Some z \\<Longrightarrow>\n    eval_inl (deubx opubx) (map unboxed_dynamic.norm_unboxed xs) = unboxed_dynamic.norm_unboxed z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_ubx opubx xs = Some z \\<Longrightarrow>\n    eval_inl (deubx opubx) (map unboxed_dynamic.norm_unboxed xs) =\n    unboxed_dynamic.norm_unboxed z", "apply (cases opubx; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eval_AddNumUbx xs = Some z; opubx = OpAddNumUbx\\<rbrakk>\n    \\<Longrightarrow> eval_AddNum (map unboxed_dynamic.norm_unboxed xs) =\n                      unboxed_dynamic.norm_unboxed z", "apply (induction xs rule: eval_AddNumUbx.induct; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>opubx = OpAddNumUbx; z = OpUbx1 (x + y)\\<rbrakk>\n       \\<Longrightarrow> eval_AddNum [box_num x, box_num y] =\n                         box_num (x + y)", "by (simp add: box_num_def)"], ["", "lemma eval_ubx_to_inl:\n  assumes \"eval_ubx opubx \\<Sigma> = Some z\"\n  shows \"inl (deinl (deubx opubx)) (map unboxed_dynamic.norm_unboxed \\<Sigma>) = Some (deubx opubx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inl (deinl (deubx opubx)) (map unboxed_dynamic.norm_unboxed \\<Sigma>) =\n    Some (deubx opubx)", "proof (cases opubx)"], ["proof (state)\ngoal (1 subgoal):\n 1. opubx = OpAddNumUbx \\<Longrightarrow>\n    inl (deinl (deubx opubx)) (map unboxed_dynamic.norm_unboxed \\<Sigma>) =\n    Some (deubx opubx)", "case OpAddNumUbx"], ["proof (state)\nthis:\n  opubx = OpAddNumUbx\n\ngoal (1 subgoal):\n 1. opubx = OpAddNumUbx \\<Longrightarrow>\n    inl (deinl (deubx opubx)) (map unboxed_dynamic.norm_unboxed \\<Sigma>) =\n    Some (deubx opubx)", "then"], ["proof (chain)\npicking this:\n  opubx = OpAddNumUbx", "have \"eval_AddNumUbx \\<Sigma> = Some z\""], ["proof (prove)\nusing this:\n  opubx = OpAddNumUbx\n\ngoal (1 subgoal):\n 1. eval_AddNumUbx \\<Sigma> = Some z", "using assms"], ["proof (prove)\nusing this:\n  opubx = OpAddNumUbx\n  eval_ubx opubx \\<Sigma> = Some z\n\ngoal (1 subgoal):\n 1. eval_AddNumUbx \\<Sigma> = Some z", "by simp"], ["proof (state)\nthis:\n  eval_AddNumUbx \\<Sigma> = Some z\n\ngoal (1 subgoal):\n 1. opubx = OpAddNumUbx \\<Longrightarrow>\n    inl (deinl (deubx opubx)) (map unboxed_dynamic.norm_unboxed \\<Sigma>) =\n    Some (deubx opubx)", "then"], ["proof (chain)\npicking this:\n  eval_AddNumUbx \\<Sigma> = Some z", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_AddNumUbx \\<Sigma> = Some z\n\ngoal (1 subgoal):\n 1. inl (deinl (deubx opubx)) (map unboxed_dynamic.norm_unboxed \\<Sigma>) =\n    Some (deubx opubx)", "using OpAddNumUbx"], ["proof (prove)\nusing this:\n  eval_AddNumUbx \\<Sigma> = Some z\n  opubx = OpAddNumUbx\n\ngoal (1 subgoal):\n 1. inl (deinl (deubx opubx)) (map unboxed_dynamic.norm_unboxed \\<Sigma>) =\n    Some (deubx opubx)", "apply (induction \\<Sigma> rule: eval_AddNumUbx.induct; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>OpUbx1 (x + y) = z; eval_AddNumUbx \\<Sigma> = Some z;\n        opubx = OpAddNumUbx\\<rbrakk>\n       \\<Longrightarrow> inl OpAdd [box_num x, box_num y] = Some OpAddNum", "by (simp add: box_num_def)"], ["proof (state)\nthis:\n  inl (deinl (deubx opubx)) (map unboxed_dynamic.norm_unboxed \\<Sigma>) =\n  Some (deubx opubx)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Abstract interpretation\\<close>"], ["", "fun typeof_opubx :: \"opubx \\<Rightarrow> type option list \\<times> type option\" where\n  \"typeof_opubx OpAddNumUbx = ([Some Ubx1, Some Ubx1], Some Ubx1)\""], ["", "lemma ubx_imp_typeof_opubx:\n  \"ubx opinl ts = Some opubx \\<Longrightarrow> fst (typeof_opubx opubx) = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Op_example.ubx opinl ts = Some opubx \\<Longrightarrow>\n    fst (typeof_opubx opubx) = ts", "by (induction opinl ts rule: ubx.induct; simp)"], ["", "lemma typeof_opubx_correct:\n  \"typeof_opubx opubx = (map typeof xs, codomain) \\<Longrightarrow>\n    \\<exists>y. eval_ubx opubx xs = Some y \\<and> typeof y = codomain\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof_opubx opubx = (map typeof xs, codomain) \\<Longrightarrow>\n    \\<exists>y. eval_ubx opubx xs = Some y \\<and> typeof y = codomain", "proof (induction opubx)"], ["proof (state)\ngoal (1 subgoal):\n 1. typeof_opubx OpAddNumUbx = (map typeof xs, codomain) \\<Longrightarrow>\n    \\<exists>y. eval_ubx OpAddNumUbx xs = Some y \\<and> typeof y = codomain", "case OpAddNumUbx"], ["proof (state)\nthis:\n  typeof_opubx OpAddNumUbx = (map typeof xs, codomain)\n\ngoal (1 subgoal):\n 1. typeof_opubx OpAddNumUbx = (map typeof xs, codomain) \\<Longrightarrow>\n    \\<exists>y. eval_ubx OpAddNumUbx xs = Some y \\<and> typeof y = codomain", "obtain n1 n2 where xs_def: \"xs = [OpUbx1 n1, OpUbx1 n2]\" and \"codomain = Some Ubx1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n1 n2.\n        \\<lbrakk>xs = [OpUbx1 n1, OpUbx1 n2]; codomain = Some Ubx1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using OpAddNumUbx[symmetric]"], ["proof (prove)\nusing this:\n  (map typeof xs, codomain) = typeof_opubx OpAddNumUbx\n\ngoal (1 subgoal):\n 1. (\\<And>n1 n2.\n        \\<lbrakk>xs = [OpUbx1 n1, OpUbx1 n2]; codomain = Some Ubx1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: typeof_unboxed_inversion)"], ["proof (state)\nthis:\n  xs = [OpUbx1 n1, OpUbx1 n2]\n  codomain = Some Ubx1\n\ngoal (1 subgoal):\n 1. typeof_opubx OpAddNumUbx = (map typeof xs, codomain) \\<Longrightarrow>\n    \\<exists>y. eval_ubx OpAddNumUbx xs = Some y \\<and> typeof y = codomain", "then"], ["proof (chain)\npicking this:\n  xs = [OpUbx1 n1, OpUbx1 n2]\n  codomain = Some Ubx1", "show ?case"], ["proof (prove)\nusing this:\n  xs = [OpUbx1 n1, OpUbx1 n2]\n  codomain = Some Ubx1\n\ngoal (1 subgoal):\n 1. \\<exists>y. eval_ubx OpAddNumUbx xs = Some y \\<and> typeof y = codomain", "by simp"], ["proof (state)\nthis:\n  \\<exists>y. eval_ubx OpAddNumUbx xs = Some y \\<and> typeof y = codomain\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typeof_opubx_complete:\n  \"eval_ubx opubx xs = Some y \\<Longrightarrow>\n    typeof_opubx opubx = (map typeof xs, typeof y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_ubx opubx xs = Some y \\<Longrightarrow>\n    typeof_opubx opubx = (map typeof xs, typeof y)", "proof (induction opubx)"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_ubx OpAddNumUbx xs = Some y \\<Longrightarrow>\n    typeof_opubx OpAddNumUbx = (map typeof xs, typeof y)", "case OpAddNumUbx"], ["proof (state)\nthis:\n  eval_ubx OpAddNumUbx xs = Some y\n\ngoal (1 subgoal):\n 1. eval_ubx OpAddNumUbx xs = Some y \\<Longrightarrow>\n    typeof_opubx OpAddNumUbx = (map typeof xs, typeof y)", "then"], ["proof (chain)\npicking this:\n  eval_ubx OpAddNumUbx xs = Some y", "show ?case"], ["proof (prove)\nusing this:\n  eval_ubx OpAddNumUbx xs = Some y\n\ngoal (1 subgoal):\n 1. typeof_opubx OpAddNumUbx = (map typeof xs, typeof y)", "by (auto elim: eval_AddNumUbx.elims)"], ["proof (state)\nthis:\n  typeof_opubx OpAddNumUbx = (map typeof xs, typeof y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma typeof_opubx_ar: \"length (fst (typeof_opubx opubx)) = ar (deinl (deubx opubx))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (typeof_opubx opubx)) = ar (deinl (deubx opubx))", "by (induction opubx; simp)"], ["", "interpretation op_OpUbx:\n  nary_operations_ubx\n    eval ar eval_inl inl isinl deinl\n    is_true is_false box_num unbox_num box_bool unbox_bool\n    eval_ubx ubx deubx typeof_opubx"], ["proof (prove)\ngoal (1 subgoal):\n 1. nary_operations_ubx eval ar eval_inl inl isinl deinl is_true is_false\n     box_num unbox_num box_bool unbox_bool eval_ubx Op_example.ubx deubx\n     typeof_opubx", "using ubx_invertible"], ["proof (prove)\nusing this:\n  Op_example.ubx ?opinl ?xs = Some ?opubx \\<Longrightarrow>\n  deubx ?opubx = ?opinl\n\ngoal (1 subgoal):\n 1. nary_operations_ubx eval ar eval_inl inl isinl deinl is_true is_false\n     box_num unbox_num box_bool unbox_bool eval_ubx Op_example.ubx deubx\n     typeof_opubx", "using eval_ubx_correct"], ["proof (prove)\nusing this:\n  Op_example.ubx ?opinl ?xs = Some ?opubx \\<Longrightarrow>\n  deubx ?opubx = ?opinl\n  eval_ubx ?opubx ?xs = Some ?z \\<Longrightarrow>\n  eval_inl (deubx ?opubx) (map unboxed_dynamic.norm_unboxed ?xs) =\n  unboxed_dynamic.norm_unboxed ?z\n\ngoal (1 subgoal):\n 1. nary_operations_ubx eval ar eval_inl inl isinl deinl is_true is_false\n     box_num unbox_num box_bool unbox_bool eval_ubx Op_example.ubx deubx\n     typeof_opubx", "using eval_ubx_to_inl"], ["proof (prove)\nusing this:\n  Op_example.ubx ?opinl ?xs = Some ?opubx \\<Longrightarrow>\n  deubx ?opubx = ?opinl\n  eval_ubx ?opubx ?xs = Some ?z \\<Longrightarrow>\n  eval_inl (deubx ?opubx) (map unboxed_dynamic.norm_unboxed ?xs) =\n  unboxed_dynamic.norm_unboxed ?z\n  eval_ubx ?opubx ?\\<Sigma> = Some ?z \\<Longrightarrow>\n  inl (deinl (deubx ?opubx)) (map unboxed_dynamic.norm_unboxed ?\\<Sigma>) =\n  Some (deubx ?opubx)\n\ngoal (1 subgoal):\n 1. nary_operations_ubx eval ar eval_inl inl isinl deinl is_true is_false\n     box_num unbox_num box_bool unbox_bool eval_ubx Op_example.ubx deubx\n     typeof_opubx", "using ubx_imp_typeof_opubx"], ["proof (prove)\nusing this:\n  Op_example.ubx ?opinl ?xs = Some ?opubx \\<Longrightarrow>\n  deubx ?opubx = ?opinl\n  eval_ubx ?opubx ?xs = Some ?z \\<Longrightarrow>\n  eval_inl (deubx ?opubx) (map unboxed_dynamic.norm_unboxed ?xs) =\n  unboxed_dynamic.norm_unboxed ?z\n  eval_ubx ?opubx ?\\<Sigma> = Some ?z \\<Longrightarrow>\n  inl (deinl (deubx ?opubx)) (map unboxed_dynamic.norm_unboxed ?\\<Sigma>) =\n  Some (deubx ?opubx)\n  Op_example.ubx ?opinl ?ts = Some ?opubx \\<Longrightarrow>\n  fst (typeof_opubx ?opubx) = ?ts\n\ngoal (1 subgoal):\n 1. nary_operations_ubx eval ar eval_inl inl isinl deinl is_true is_false\n     box_num unbox_num box_bool unbox_bool eval_ubx Op_example.ubx deubx\n     typeof_opubx", "using typeof_opubx_correct"], ["proof (prove)\nusing this:\n  Op_example.ubx ?opinl ?xs = Some ?opubx \\<Longrightarrow>\n  deubx ?opubx = ?opinl\n  eval_ubx ?opubx ?xs = Some ?z \\<Longrightarrow>\n  eval_inl (deubx ?opubx) (map unboxed_dynamic.norm_unboxed ?xs) =\n  unboxed_dynamic.norm_unboxed ?z\n  eval_ubx ?opubx ?\\<Sigma> = Some ?z \\<Longrightarrow>\n  inl (deinl (deubx ?opubx)) (map unboxed_dynamic.norm_unboxed ?\\<Sigma>) =\n  Some (deubx ?opubx)\n  Op_example.ubx ?opinl ?ts = Some ?opubx \\<Longrightarrow>\n  fst (typeof_opubx ?opubx) = ?ts\n  typeof_opubx ?opubx = (map typeof ?xs, ?codomain) \\<Longrightarrow>\n  \\<exists>y. eval_ubx ?opubx ?xs = Some y \\<and> typeof y = ?codomain\n\ngoal (1 subgoal):\n 1. nary_operations_ubx eval ar eval_inl inl isinl deinl is_true is_false\n     box_num unbox_num box_bool unbox_bool eval_ubx Op_example.ubx deubx\n     typeof_opubx", "using typeof_opubx_complete"], ["proof (prove)\nusing this:\n  Op_example.ubx ?opinl ?xs = Some ?opubx \\<Longrightarrow>\n  deubx ?opubx = ?opinl\n  eval_ubx ?opubx ?xs = Some ?z \\<Longrightarrow>\n  eval_inl (deubx ?opubx) (map unboxed_dynamic.norm_unboxed ?xs) =\n  unboxed_dynamic.norm_unboxed ?z\n  eval_ubx ?opubx ?\\<Sigma> = Some ?z \\<Longrightarrow>\n  inl (deinl (deubx ?opubx)) (map unboxed_dynamic.norm_unboxed ?\\<Sigma>) =\n  Some (deubx ?opubx)\n  Op_example.ubx ?opinl ?ts = Some ?opubx \\<Longrightarrow>\n  fst (typeof_opubx ?opubx) = ?ts\n  typeof_opubx ?opubx = (map typeof ?xs, ?codomain) \\<Longrightarrow>\n  \\<exists>y. eval_ubx ?opubx ?xs = Some y \\<and> typeof y = ?codomain\n  eval_ubx ?opubx ?xs = Some ?y \\<Longrightarrow>\n  typeof_opubx ?opubx = (map typeof ?xs, typeof ?y)\n\ngoal (1 subgoal):\n 1. nary_operations_ubx eval ar eval_inl inl isinl deinl is_true is_false\n     box_num unbox_num box_bool unbox_bool eval_ubx Op_example.ubx deubx\n     typeof_opubx", "using typeof_opubx_ar"], ["proof (prove)\nusing this:\n  Op_example.ubx ?opinl ?xs = Some ?opubx \\<Longrightarrow>\n  deubx ?opubx = ?opinl\n  eval_ubx ?opubx ?xs = Some ?z \\<Longrightarrow>\n  eval_inl (deubx ?opubx) (map unboxed_dynamic.norm_unboxed ?xs) =\n  unboxed_dynamic.norm_unboxed ?z\n  eval_ubx ?opubx ?\\<Sigma> = Some ?z \\<Longrightarrow>\n  inl (deinl (deubx ?opubx)) (map unboxed_dynamic.norm_unboxed ?\\<Sigma>) =\n  Some (deubx ?opubx)\n  Op_example.ubx ?opinl ?ts = Some ?opubx \\<Longrightarrow>\n  fst (typeof_opubx ?opubx) = ?ts\n  typeof_opubx ?opubx = (map typeof ?xs, ?codomain) \\<Longrightarrow>\n  \\<exists>y. eval_ubx ?opubx ?xs = Some y \\<and> typeof y = ?codomain\n  eval_ubx ?opubx ?xs = Some ?y \\<Longrightarrow>\n  typeof_opubx ?opubx = (map typeof ?xs, typeof ?y)\n  length (fst (typeof_opubx ?opubx)) = ar (deinl (deubx ?opubx))\n\ngoal (1 subgoal):\n 1. nary_operations_ubx eval ar eval_inl inl isinl deinl is_true is_false\n     box_num unbox_num box_bool unbox_bool eval_ubx Op_example.ubx deubx\n     typeof_opubx", "by (unfold_locales; (simp; fail)?)"], ["", "end"]]}