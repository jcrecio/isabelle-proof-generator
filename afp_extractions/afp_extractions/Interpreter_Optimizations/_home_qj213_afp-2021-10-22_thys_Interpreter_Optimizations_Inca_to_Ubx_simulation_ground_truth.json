{"file_name": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations/Inca_to_Ubx_simulation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations", "problem_names": ["lemmas sp_fundef_generalize =\n  Subx.sp_generalize[where \\<Sigma> = \"replicate (arity fd) None\" for fd, simplified, folded sp_fundef_def]", "lemma eq_sp_to_eq_sp_fundef:\n  assumes \"Subx.sp F1 = (Subx.sp F2 :: ('dyn, 'id, _, _, _, _, 'num, 'bool) Ubx.instr list \\<Rightarrow> _)\"\n  shows \"sp_fundef F1 = (sp_fundef F2 :: _ \\<Rightarrow> ('dyn, 'id, _, _, _, _, 'num, 'bool) Ubx.instr list \\<Rightarrow> _)\"", "lemma norm_generalize_instr: \"norm_instr (Subx.generalize_instr instr) = norm_instr instr\"", "lemma rel_fundef_body_nth:\n  assumes \"rel_fundef norm_eq fd1 fd2\" and \"pc < length (body fd1)\"\n  shows \"body fd1 ! pc = norm_instr (body fd2 ! pc)\"", "lemma rel_fundef_rewrite_body:\n  assumes\n    \"rel_fundef norm_eq fd1 fd2\" and\n    \"norm_instr (body fd2 ! pc) = norm_instr instr\"\n  shows \"rel_fundef norm_eq fd1 (rewrite_fundef_body fd2 pc instr)\"", "lemma rel_fundef_generalize:\n  assumes \"rel_fundef norm_eq fd1 fd2\"\n  shows \"rel_fundef norm_eq fd1 (Subx.generalize_fundef fd2)\"", "lemma rel_fundefs_empty: \"rel_fundefs (\\<lambda>_. None) (\\<lambda>_. None)\"", "lemma rel_fundefs_None1:\n  assumes \"rel_fundefs f g\" and \"f x = None\"\n  shows \"g x = None\"", "lemma rel_fundefs_None2:\n  assumes \"rel_fundefs f g\" and \"g x = None\"\n  shows \"f x = None\"", "lemma rel_fundefs_Some1:\n  assumes \"rel_fundefs f g\" and \"f x = Some y\"\n  shows \"\\<exists>z. g x = Some z \\<and> rel_fundef norm_eq y z\"", "lemma rel_fundefs_Some2:\n  assumes \"rel_fundefs f g\" and \"g x = Some y\"\n  shows \"\\<exists>z. f x = Some z \\<and> rel_fundef norm_eq z y\"", "lemma rel_fundefs_rel_option:\n  assumes \"rel_fundefs f g\" and \"\\<And>x y. rel_fundef norm_eq x y \\<Longrightarrow> h x y\"\n  shows \"rel_option h (f z) (g z)\"", "lemma norm_stack_Nil[simp]: \"norm_stack [] = []\"", "lemma norm_stack_Cons[simp]: \"norm_stack (d # \\<Sigma>) = Subx.norm_unboxed d # norm_stack \\<Sigma>\"", "lemma norm_stack_append: \"norm_stack (xs @ ys) = norm_stack xs @ norm_stack ys\"", "lemmas drop_norm_stack = drop_map[where f = Subx.norm_unboxed, folded norm_stack_def]", "lemmas take_norm_stack = take_map[where f = Subx.norm_unboxed, folded norm_stack_def]", "lemmas norm_stack_map = map_map[where f = Subx.norm_unboxed, folded norm_stack_def]", "lemma norm_box_stack[simp]: \"norm_stack (map Subx.box_operand \\<Sigma>) = norm_stack \\<Sigma>\"", "lemma length_norm_stack[simp]: \"length (norm_stack xs) = length xs\"", "lemma all_same_arities_commutative: \"all_same_arities F1 F2 = all_same_arities F2 F1\"", "lemma sp_instr_same_arities:\n  \"all_same_arities F1 F2 \\<Longrightarrow> Subx.sp_instr F1 x ys = Subx.sp_instr F2 x ys\"", "lemma sp_same_arities:\n  assumes \"all_same_arities F1 F2\"\n  shows \"Subx.sp F1 = Subx.sp F2\"", "lemmas sp_fundef_same_arities = sp_same_arities[THEN eq_sp_to_eq_sp_fundef]", "lemma all_same_arities_add:\n  assumes \"Fubx_get F f = Some fd1\" and \"arity fd1 = arity fd2\"\n  shows \"all_same_arities (Fubx_get F) (Fubx_get (Fubx_add F f fd2))\"", "lemma all_same_arities_generalize_fundef:\n  assumes \"Fubx_get F f = Some fd\"\n  shows \"all_same_arities (Fubx_get F) (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\"", "lemma rel_stacktraces_box:\n  assumes\n    \"rel_stacktraces F1 xs ys opt\" and\n    \"F2 f = map_option Subx.generalize_fundef (F1 f)\" and\n    \"\\<And>g. f \\<noteq> g \\<Longrightarrow> F2 g = F1 g\" and\n    \"all_same_arities F1 F2\"\n  shows \"rel_stacktraces F2 xs (Subx.box_stack f ys) opt\"", "lemma rel_stacktraces_generalize:\n  assumes\n    \"rel_stacktraces (Fubx_get F) st1 st2 (Some f)\" and\n    \"Fubx_get F f = Some fd \" and\n    sp_prefix: \"sp_fundef (Fubx_get F) fd (take pc (body fd)) = Ok (None # map typeof \\<Sigma>2)\" and\n    norm_stacks: \"\\<Sigma>1 = norm_stack \\<Sigma>2\" and\n    pc_in_range: \"pc < length (body fd)\" and\n    sp_instr: \"Subx.sp_instr (Fubx_get F) (Subx.generalize_instr (body fd ! pc))\n      (None # map (\\<lambda>_. None) \\<Sigma>2) = Ok (None # map (typeof \\<circ> Subx.box_operand) \\<Sigma>2)\"\n  shows \"rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n          (Frame f (Suc pc) (d # \\<Sigma>1) # st1)\n          (Frame f (Suc pc) (OpDyn d # map Subx.box_operand \\<Sigma>2) # Subx.box_stack f st2) None\"", "lemma rel_fundefs_rewrite:\n  assumes\n    rel_F1_F2: \"rel_fundefs (Finca_get F1) (Fubx_get F2)\" and\n    F2_get_f: \"Fubx_get F2 f = Some fd2\" and\n    F2_add_f: \"Fubx_add F2 f (rewrite_fundef_body fd2 pc instr) = F2'\" and\n    eq_norm: \"norm_instr (body fd2 ! pc) = norm_instr instr\"\n  shows \"rel_fundefs (Finca_get F1) (Fubx_get F2')\"", "lemma rel_fundef_rewrite_both:\n  assumes \"rel_fundef norm_eq fd1 fd2\" and \"norm_instr y = x\"\n  shows \"rel_fundef norm_eq (rewrite_fundef_body fd1 pc x) (rewrite_fundef_body fd2 pc y)\"", "lemma rel_fundefs_rewrite_both:\n  assumes\n    rel_init: \"rel_fundefs (Finca_get F1) (Fubx_get F2)\" and\n    rel_new: \"rel_fundef norm_eq fd1 fd2\"\n  shows \"rel_fundefs (Finca_get (Finca_add F1 f fd1)) (Fubx_get (Fubx_add F2 f fd2))\"", "lemma rel_fundefs_generalize:\n  assumes\n    rel_F1_F2: \"rel_fundefs (Finca_get F1) (Fubx_get F2)\" and\n    F2_get_f: \"Fubx_get F2 f = Some fd2\"\n  shows \"rel_fundefs (Finca_get F1) (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\"", "lemma rel_stacktraces_rewrite_fundef:\n  assumes\n    \"rel_stacktraces (Fubx_get F2) xs ys opt\" and\n    \"Fubx_get F2 f = Some fd\" and\n    \"pc < length (body fd)\" and\n    \"\\<forall>\\<Sigma>. Subx.sp_instr (Fubx_get F2) (body fd ! pc) \\<Sigma> = Subx.sp_instr (Fubx_get F2) instr \\<Sigma>\" and\n    \"\\<not> is_fun_call (body fd ! pc)\"\n  shows \"rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) xs ys opt\"", "lemma sp_fundefs_get:\n  assumes \"sp_fundefs F\" and \"F f = Some fd\"\n  shows \"sp_fundef F fd (body fd) = Ok [None]\"", "lemma sp_fundefs_generalize:\n  assumes \"sp_fundefs (Fubx_get F)\" and \"Fubx_get F f = Some fd\"\n  shows \"sp_fundefs (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\"", "lemma sp_fundefs_add:\n  assumes\n    \"sp_fundefs (Fubx_get F)\" and\n    \"sp_fundef (Fubx_get F) fd (body fd) = Ok [None]\" and\n    \"all_same_arities (Fubx_get F) (Fubx_get (Fubx_add F f fd))\"\n  shows \"sp_fundefs (Fubx_get (Fubx_add F f fd))\"", "lemma traverse_cast_Dyn_to_norm: \"traverse cast_Dyn xs = Some ys \\<Longrightarrow> norm_stack xs = ys\"", "lemma traverse_cast_Dyn_to_all_Dyn:\n  \"traverse cast_Dyn xs = Some ys \\<Longrightarrow> list_all (\\<lambda>x. typeof x = None) xs\"", "lemma backward_lockstep_simulation:\n  assumes \"Subx.step s2 s2'\" and \"s1 \\<sim> s2\"\n  shows \"\\<exists>s1'. Sinca.step s1 s1' \\<and> s1' \\<sim> s2'\"", "lemma match_final_backward:\n  \"s1 \\<sim> s2 \\<Longrightarrow> Subx.final s2 \\<Longrightarrow> Sinca.final s1\"", "lemma traverse_cast_Dyn_eq_norm_stack:\n  assumes \"list_all (\\<lambda>x. x = None) (map typeof xs)\"\n  shows \"traverse cast_Dyn xs = Some (norm_stack xs)\"", "lemma forward_lockstep_simulation:\n  assumes \"Sinca.step s1 s1'\" and \"s1 \\<sim> s2\"\n  shows \"\\<exists>s2'. Subx.step s2 s2' \\<and> s1' \\<sim> s2'\"", "lemma match_final_forward:\n  \"s1 \\<sim> s2 \\<Longrightarrow> Sinca.final s1 \\<Longrightarrow> Subx.final s2\""], "translations": [["", "lemmas sp_fundef_generalize =\n  Subx.sp_generalize[where \\<Sigma> = \"replicate (arity fd) None\" for fd, simplified, folded sp_fundef_def]"], ["", "lemma eq_sp_to_eq_sp_fundef:\n  assumes \"Subx.sp F1 = (Subx.sp F2 :: ('dyn, 'id, _, _, _, _, 'num, 'bool) Ubx.instr list \\<Rightarrow> _)\"\n  shows \"sp_fundef F1 = (sp_fundef F2 :: _ \\<Rightarrow> ('dyn, 'id, _, _, _, _, 'num, 'bool) Ubx.instr list \\<Rightarrow> _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef F1 = sp_fundef F2", "using assms(1)"], ["proof (prove)\nusing this:\n  Subx.sp F1 = Subx.sp F2\n\ngoal (1 subgoal):\n 1. sp_fundef F1 = sp_fundef F2", "by (intro ext; simp add: sp_fundef_def)"], ["", "definition sp_fundefs where\n  \"sp_fundefs F \\<equiv> \\<forall>f fd. F f = Some fd \\<longrightarrow> sp_fundef F fd (body fd) = Ok [None]\""], ["", "section \\<open>Normalization\\<close>"], ["", "fun norm_instr where\n  \"norm_instr (Ubx.IPush d) = Inca.IPush d\" |\n  \"norm_instr (Ubx.IPushUbx1 n) = Inca.IPush (box_ubx1 n)\" |\n  \"norm_instr (Ubx.IPushUbx2 b) = Inca.IPush (box_ubx2 b)\" |\n  \"norm_instr Ubx.IPop = Inca.IPop\" |\n  \"norm_instr (Ubx.ILoad x) = Inca.ILoad x\" |\n  \"norm_instr (Ubx.ILoadUbx _ x) = Inca.ILoad x\" |\n  \"norm_instr (Ubx.IStore x) = Inca.IStore x\" |\n  \"norm_instr (Ubx.IStoreUbx _ x) = Inca.IStore x\" |\n  \"norm_instr (Ubx.IOp op) = Inca.IOp op\" |\n  \"norm_instr (Ubx.IOpInl op) = Inca.IOpInl op\" |\n  \"norm_instr (Ubx.IOpUbx op) = Inca.IOpInl (\\<BB>\\<oo>\\<xx> op)\" |\n  \"norm_instr (Ubx.ICJump n) = Inca.ICJump n\" |\n  \"norm_instr (Ubx.ICall x) = Inca.ICall x\""], ["", "definition rel_fundefs where\n  \"rel_fundefs f g = (\\<forall>x. rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z)) (f x) (g x))\""], ["", "abbreviation (input) norm_eq where\n  \"norm_eq x y \\<equiv> x = norm_instr y\""], ["", "lemma norm_generalize_instr: \"norm_instr (Subx.generalize_instr instr) = norm_instr instr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_instr (Subx.generalize_instr instr) = norm_instr instr", "by (cases instr) simp_all"], ["", "lemma rel_fundef_body_nth:\n  assumes \"rel_fundef norm_eq fd1 fd2\" and \"pc < length (body fd1)\"\n  shows \"body fd1 ! pc = norm_instr (body fd2 ! pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. body fd1 ! pc = norm_instr (body fd2 ! pc)", "using assms"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. body fd1 ! pc = norm_instr (body fd2 ! pc)", "by (auto dest: list_all2_nthD simp: fundef.rel_sel)"], ["", "lemma rel_fundef_rewrite_body:\n  assumes\n    \"rel_fundef norm_eq fd1 fd2\" and\n    \"norm_instr (body fd2 ! pc) = norm_instr instr\"\n  shows \"rel_fundef norm_eq fd1 (rewrite_fundef_body fd2 pc instr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n     (rewrite_fundef_body fd2 pc instr)", "using assms(1)"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n     (rewrite_fundef_body fd2 pc instr)", "proof (cases rule: fundef.rel_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a y1a y2a.\n       \\<lbrakk>fd1 = Fundef x1a x2a; fd2 = Fundef y1a y2a;\n        list_all2 (\\<lambda>x y. x = norm_instr y) x1a y1a;\n        x2a = y2a\\<rbrakk>\n       \\<Longrightarrow> rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n                          (rewrite_fundef_body fd2 pc instr)", "case (Fundef xs ar' ys ar)"], ["proof (state)\nthis:\n  fd1 = Fundef xs ar'\n  fd2 = Fundef ys ar\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs ys\n  ar' = ar\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a y1a y2a.\n       \\<lbrakk>fd1 = Fundef x1a x2a; fd2 = Fundef y1a y2a;\n        list_all2 (\\<lambda>x y. x = norm_instr y) x1a y1a;\n        x2a = y2a\\<rbrakk>\n       \\<Longrightarrow> rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n                          (rewrite_fundef_body fd2 pc instr)", "hence \"length xs = length ys\""], ["proof (prove)\nusing this:\n  fd1 = Fundef xs ar'\n  fd2 = Fundef ys ar\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs ys\n  ar' = ar\n\ngoal (1 subgoal):\n 1. length xs = length ys", "by (simp add: list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a y1a y2a.\n       \\<lbrakk>fd1 = Fundef x1a x2a; fd2 = Fundef y1a y2a;\n        list_all2 (\\<lambda>x y. x = norm_instr y) x1a y1a;\n        x2a = y2a\\<rbrakk>\n       \\<Longrightarrow> rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n                          (rewrite_fundef_body fd2 pc instr)", "hence \"length xs = length (rewrite ys pc instr)\""], ["proof (prove)\nusing this:\n  length xs = length ys\n\ngoal (1 subgoal):\n 1. length xs = length (rewrite ys pc instr)", "by simp"], ["proof (state)\nthis:\n  length xs = length (rewrite ys pc instr)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a y1a y2a.\n       \\<lbrakk>fd1 = Fundef x1a x2a; fd2 = Fundef y1a y2a;\n        list_all2 (\\<lambda>x y. x = norm_instr y) x1a y1a;\n        x2a = y2a\\<rbrakk>\n       \\<Longrightarrow> rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n                          (rewrite_fundef_body fd2 pc instr)", "hence \"list_all2 norm_eq xs (rewrite ys pc instr)\""], ["proof (prove)\nusing this:\n  length xs = length (rewrite ys pc instr)\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. x = norm_instr y) xs (rewrite ys pc instr)", "proof (elim list_all2_all_nthI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length xs \\<Longrightarrow>\n       xs ! n = norm_instr (rewrite ys pc instr ! n)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length xs \\<Longrightarrow>\n       xs ! n = norm_instr (rewrite ys pc instr ! n)", "assume \"n < length xs\""], ["proof (state)\nthis:\n  n < length xs\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length xs \\<Longrightarrow>\n       xs ! n = norm_instr (rewrite ys pc instr ! n)", "hence \"n < length ys\""], ["proof (prove)\nusing this:\n  n < length xs\n\ngoal (1 subgoal):\n 1. n < length ys", "by (simp add: \\<open>length xs = length ys\\<close>)"], ["proof (state)\nthis:\n  n < length ys\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < length xs \\<Longrightarrow>\n       xs ! n = norm_instr (rewrite ys pc instr ! n)", "thus \"xs ! n = norm_instr (rewrite ys pc instr ! n)\""], ["proof (prove)\nusing this:\n  n < length ys\n\ngoal (1 subgoal):\n 1. xs ! n = norm_instr (rewrite ys pc instr ! n)", "using list_all2_nthD[OF \\<open>list_all2 norm_eq xs ys\\<close> \\<open>n < length xs\\<close>, symmetric]"], ["proof (prove)\nusing this:\n  n < length ys\n  norm_instr (ys ! n) = xs ! n\n\ngoal (1 subgoal):\n 1. xs ! n = norm_instr (rewrite ys pc instr ! n)", "using assms(2)[unfolded Fundef(2), simplified]"], ["proof (prove)\nusing this:\n  n < length ys\n  norm_instr (ys ! n) = xs ! n\n  norm_instr (ys ! pc) = norm_instr instr\n\ngoal (1 subgoal):\n 1. xs ! n = norm_instr (rewrite ys pc instr ! n)", "by (cases \"pc = n\"; simp)"], ["proof (state)\nthis:\n  xs ! n = norm_instr (rewrite ys pc instr ! n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs (rewrite ys pc instr)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a y1a y2a.\n       \\<lbrakk>fd1 = Fundef x1a x2a; fd2 = Fundef y1a y2a;\n        list_all2 (\\<lambda>x y. x = norm_instr y) x1a y1a;\n        x2a = y2a\\<rbrakk>\n       \\<Longrightarrow> rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n                          (rewrite_fundef_body fd2 pc instr)", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs (rewrite ys pc instr)\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n     (rewrite_fundef_body fd2 pc instr)", "using Fundef"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs (rewrite ys pc instr)\n  fd1 = Fundef xs ar'\n  fd2 = Fundef ys ar\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs ys\n  ar' = ar\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n     (rewrite_fundef_body fd2 pc instr)", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n   (rewrite_fundef_body fd2 pc instr)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_fundef_generalize:\n  assumes \"rel_fundef norm_eq fd1 fd2\"\n  shows \"rel_fundef norm_eq fd1 (Subx.generalize_fundef fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n     (Subx.generalize_fundef fd2)", "using assms(1)"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n     (Subx.generalize_fundef fd2)", "proof (cases rule: fundef.rel_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a y1a y2a.\n       \\<lbrakk>fd1 = Fundef x1a x2a; fd2 = Fundef y1a y2a;\n        list_all2 (\\<lambda>x y. x = norm_instr y) x1a y1a;\n        x2a = y2a\\<rbrakk>\n       \\<Longrightarrow> rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n                          (Subx.generalize_fundef fd2)", "case (Fundef xs ar' ys ar)"], ["proof (state)\nthis:\n  fd1 = Fundef xs ar'\n  fd2 = Fundef ys ar\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs ys\n  ar' = ar\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a y1a y2a.\n       \\<lbrakk>fd1 = Fundef x1a x2a; fd2 = Fundef y1a y2a;\n        list_all2 (\\<lambda>x y. x = norm_instr y) x1a y1a;\n        x2a = y2a\\<rbrakk>\n       \\<Longrightarrow> rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n                          (Subx.generalize_fundef fd2)", "hence \"list_all2 (\\<lambda>x y. x = norm_instr y) xs (map Subx.generalize_instr ys)\""], ["proof (prove)\nusing this:\n  fd1 = Fundef xs ar'\n  fd2 = Fundef ys ar\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs ys\n  ar' = ar\n\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x y. x = norm_instr y) xs\n     (map Subx.generalize_instr ys)", "by (auto elim!: list_all2_mono simp: list.rel_map norm_generalize_instr)"], ["proof (state)\nthis:\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs\n   (map Subx.generalize_instr ys)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a y1a y2a.\n       \\<lbrakk>fd1 = Fundef x1a x2a; fd2 = Fundef y1a y2a;\n        list_all2 (\\<lambda>x y. x = norm_instr y) x1a y1a;\n        x2a = y2a\\<rbrakk>\n       \\<Longrightarrow> rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n                          (Subx.generalize_fundef fd2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs\n   (map Subx.generalize_instr ys)\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n     (Subx.generalize_fundef fd2)", "using Fundef"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs\n   (map Subx.generalize_instr ys)\n  fd1 = Fundef xs ar'\n  fd2 = Fundef ys ar\n  list_all2 (\\<lambda>x y. x = norm_instr y) xs ys\n  ar' = ar\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n     (Subx.generalize_fundef fd2)", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n   (Subx.generalize_fundef fd2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_fundefs_empty: \"rel_fundefs (\\<lambda>_. None) (\\<lambda>_. None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs Map.empty Map.empty", "by (simp add: rel_fundefs_def)"], ["", "lemma rel_fundefs_None1:\n  assumes \"rel_fundefs f g\" and \"f x = None\"\n  shows \"g x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g x = None", "by (metis assms rel_fundefs_def rel_option_None1)"], ["", "lemma rel_fundefs_None2:\n  assumes \"rel_fundefs f g\" and \"g x = None\"\n  shows \"f x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = None", "by (metis assms rel_fundefs_def rel_option_None2)"], ["", "lemma rel_fundefs_Some1:\n  assumes \"rel_fundefs f g\" and \"f x = Some y\"\n  shows \"\\<exists>z. g x = Some z \\<and> rel_fundef norm_eq y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       g x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       g x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) y z", "from assms(1)"], ["proof (chain)\npicking this:\n  rel_fundefs f g", "have \"rel_option (rel_fundef norm_eq) (f x) (g x)\""], ["proof (prove)\nusing this:\n  rel_fundefs f g\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)", "unfolding rel_fundefs_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z)) (f x) (g x)\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)", "by simp"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       g x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) y z", "with assms(2)"], ["proof (chain)\npicking this:\n  f x = Some y\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)", "show ?thesis"], ["proof (prove)\nusing this:\n  f x = Some y\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       g x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) y z", "by (simp add: option_rel_Some1)"], ["proof (state)\nthis:\n  \\<exists>z.\n     g x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) y z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_fundefs_Some2:\n  assumes \"rel_fundefs f g\" and \"g x = Some y\"\n  shows \"\\<exists>z. f x = Some z \\<and> rel_fundef norm_eq z y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       f x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) z y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       f x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) z y", "from assms(1)"], ["proof (chain)\npicking this:\n  rel_fundefs f g", "have \"rel_option (rel_fundef norm_eq) (f x) (g x)\""], ["proof (prove)\nusing this:\n  rel_fundefs f g\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)", "unfolding rel_fundefs_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z)) (f x) (g x)\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)", "by simp"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       f x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) z y", "with assms(2)"], ["proof (chain)\npicking this:\n  g x = Some y\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)", "show ?thesis"], ["proof (prove)\nusing this:\n  g x = Some y\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f x) (g x)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       f x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) z y", "by (simp add: option_rel_Some2)"], ["proof (state)\nthis:\n  \\<exists>z.\n     f x = Some z \\<and> rel_fundef (\\<lambda>x y. x = norm_instr y) z y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_fundefs_rel_option:\n  assumes \"rel_fundefs f g\" and \"\\<And>x y. rel_fundef norm_eq x y \\<Longrightarrow> h x y\"\n  shows \"rel_option h (f z) (g z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option h (f z) (g z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_option h (f z) (g z)", "have \"rel_option (rel_fundef norm_eq) (f z) (g z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f z) (g z)", "using assms(1)[unfolded rel_fundefs_def]"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z)) (f x) (g x)\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f z) (g z)", "by simp"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f z) (g z)\n\ngoal (1 subgoal):\n 1. rel_option h (f z) (g z)", "then"], ["proof (chain)\npicking this:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f z) (g z)", "show ?thesis"], ["proof (prove)\nusing this:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (f z) (g z)\n\ngoal (1 subgoal):\n 1. rel_option h (f z) (g z)", "unfolding rel_option_unfold"], ["proof (prove)\nusing this:\n  Option.is_none (f z) = Option.is_none (g z) \\<and>\n  (\\<not> Option.is_none (f z) \\<longrightarrow>\n   \\<not> Option.is_none (g z) \\<longrightarrow>\n   rel_fundef (\\<lambda>x y. x = norm_instr y) (the (f z)) (the (g z)))\n\ngoal (1 subgoal):\n 1. Option.is_none (f z) = Option.is_none (g z) \\<and>\n    (\\<not> Option.is_none (f z) \\<longrightarrow>\n     \\<not> Option.is_none (g z) \\<longrightarrow>\n     h (the (f z)) (the (g z)))", "by (auto simp add: assms(2))"], ["proof (state)\nthis:\n  rel_option h (f z) (g z)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Equivalence of call stacks\\<close>"], ["", "definition norm_stack :: \"('dyn, 'ubx1, 'ubx2) unboxed list \\<Rightarrow> 'dyn list\" where\n  \"norm_stack \\<Sigma> \\<equiv> List.map Subx.norm_unboxed \\<Sigma>\""], ["", "lemma norm_stack_Nil[simp]: \"norm_stack [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_stack [] = []", "by (simp add: norm_stack_def)"], ["", "lemma norm_stack_Cons[simp]: \"norm_stack (d # \\<Sigma>) = Subx.norm_unboxed d # norm_stack \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_stack (d # \\<Sigma>) = Subx.norm_unboxed d # norm_stack \\<Sigma>", "by (simp add: norm_stack_def)"], ["", "lemma norm_stack_append: \"norm_stack (xs @ ys) = norm_stack xs @ norm_stack ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_stack (xs @ ys) = norm_stack xs @ norm_stack ys", "by (simp add: norm_stack_def)"], ["", "lemmas drop_norm_stack = drop_map[where f = Subx.norm_unboxed, folded norm_stack_def]"], ["", "lemmas take_norm_stack = take_map[where f = Subx.norm_unboxed, folded norm_stack_def]"], ["", "lemmas norm_stack_map = map_map[where f = Subx.norm_unboxed, folded norm_stack_def]"], ["", "lemma norm_box_stack[simp]: \"norm_stack (map Subx.box_operand \\<Sigma>) = norm_stack \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_stack (map Subx.box_operand \\<Sigma>) = norm_stack \\<Sigma>", "by (induction \\<Sigma>) (auto simp: norm_stack_def)"], ["", "lemma length_norm_stack[simp]: \"length (norm_stack xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (norm_stack xs) = length xs", "by (simp add: norm_stack_def)"], ["", "definition is_valid_fun_call where\n  \"is_valid_fun_call get fd2 n \\<Sigma>2 g \\<equiv> n < length (body fd2) \\<and> body fd2 ! n = ICall g \\<and>\n      (\\<exists>gd. get g = Some gd \\<and> list_all is_dyn_operand (take (arity gd) \\<Sigma>2))\""], ["", "inductive rel_stacktraces for get where\n  rel_stacktraces_Nil:\n    \"rel_stacktraces get [] [] opt\" |\n\n  rel_stacktraces_Cons:\n    \"rel_stacktraces get st1 st2 (Some f) \\<Longrightarrow>\n    \\<Sigma>1 = norm_stack \\<Sigma>2 \\<Longrightarrow>\n    get f = Some fd2 \\<Longrightarrow>\n    sp_fundef get fd2 (take n (body fd2)) = Ok (map typeof \\<Sigma>2) \\<Longrightarrow>\n    pred_option (is_valid_fun_call get fd2 n \\<Sigma>2) opt \\<Longrightarrow>\n    rel_stacktraces get (Frame f n \\<Sigma>1 # st1) (Frame f n \\<Sigma>2 # st2) opt\""], ["", "definition all_same_arities where\n  \"all_same_arities F1 F2 \\<equiv> \\<forall>f. rel_option (\\<lambda>fd gd. arity fd = arity gd) (F1 f) (F2 f)\""], ["", "lemma all_same_arities_commutative: \"all_same_arities F1 F2 = all_same_arities F2 F1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_same_arities F1 F2 = all_same_arities F2 F1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. all_same_arities F1 F2 \\<Longrightarrow> all_same_arities F2 F1\n 2. all_same_arities F2 F1 \\<Longrightarrow> all_same_arities F1 F2", "assume \"all_same_arities F1 F2\""], ["proof (state)\nthis:\n  all_same_arities F1 F2\n\ngoal (2 subgoals):\n 1. all_same_arities F1 F2 \\<Longrightarrow> all_same_arities F2 F1\n 2. all_same_arities F2 F1 \\<Longrightarrow> all_same_arities F1 F2", "then"], ["proof (chain)\npicking this:\n  all_same_arities F1 F2", "show \"all_same_arities F2 F1\""], ["proof (prove)\nusing this:\n  all_same_arities F1 F2\n\ngoal (1 subgoal):\n 1. all_same_arities F2 F1", "unfolding all_same_arities_def"], ["proof (prove)\nusing this:\n  \\<forall>f. rel_option (\\<lambda>fd gd. arity fd = arity gd) (F1 f) (F2 f)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       rel_option (\\<lambda>fd gd. arity fd = arity gd) (F2 f) (F1 f)", "by (simp add: rel_option_unfold)"], ["proof (state)\nthis:\n  all_same_arities F2 F1\n\ngoal (1 subgoal):\n 1. all_same_arities F2 F1 \\<Longrightarrow> all_same_arities F1 F2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. all_same_arities F2 F1 \\<Longrightarrow> all_same_arities F1 F2", "assume \"all_same_arities F2 F1\""], ["proof (state)\nthis:\n  all_same_arities F2 F1\n\ngoal (1 subgoal):\n 1. all_same_arities F2 F1 \\<Longrightarrow> all_same_arities F1 F2", "then"], ["proof (chain)\npicking this:\n  all_same_arities F2 F1", "show \"all_same_arities F1 F2\""], ["proof (prove)\nusing this:\n  all_same_arities F2 F1\n\ngoal (1 subgoal):\n 1. all_same_arities F1 F2", "unfolding all_same_arities_def"], ["proof (prove)\nusing this:\n  \\<forall>f. rel_option (\\<lambda>fd gd. arity fd = arity gd) (F2 f) (F1 f)\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       rel_option (\\<lambda>fd gd. arity fd = arity gd) (F1 f) (F2 f)", "by (simp add: rel_option_unfold)"], ["proof (state)\nthis:\n  all_same_arities F1 F2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sp_instr_same_arities:\n  \"all_same_arities F1 F2 \\<Longrightarrow> Subx.sp_instr F1 x ys = Subx.sp_instr F2 x ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_same_arities F1 F2 \\<Longrightarrow>\n    Subx.sp_instr F1 x ys = Subx.sp_instr F2 x ys", "proof (induction F1 x ys rule: Subx.sp_instr.induct)"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>uu_ uv_ \\<Sigma>.\n       all_same_arities uu_ F2 \\<Longrightarrow>\n       Subx.sp_instr uu_ (Ubx.instr.IPush uv_) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.IPush uv_) \\<Sigma>\n 2. \\<And>uw_ ux_ \\<Sigma>.\n       all_same_arities uw_ F2 \\<Longrightarrow>\n       Subx.sp_instr uw_ (IPushUbx1 ux_) \\<Sigma> =\n       Subx.sp_instr F2 (IPushUbx1 ux_) \\<Sigma>\n 3. \\<And>uy_ uz_ \\<Sigma>.\n       all_same_arities uy_ F2 \\<Longrightarrow>\n       Subx.sp_instr uy_ (IPushUbx2 uz_) \\<Sigma> =\n       Subx.sp_instr F2 (IPushUbx2 uz_) \\<Sigma>\n 4. \\<And>va_ vb_ \\<Sigma>.\n       all_same_arities va_ F2 \\<Longrightarrow>\n       Subx.sp_instr va_ Ubx.instr.IPop (vb_ # \\<Sigma>) =\n       Subx.sp_instr F2 Ubx.instr.IPop (vb_ # \\<Sigma>)\n 5. \\<And>vc_ vd_ \\<Sigma>.\n       all_same_arities vc_ F2 \\<Longrightarrow>\n       Subx.sp_instr vc_ (Ubx.instr.ILoad vd_) (None # \\<Sigma>) =\n       Subx.sp_instr F2 (Ubx.instr.ILoad vd_) (None # \\<Sigma>)\n 6. \\<And>ve_ \\<tau> vf_ \\<Sigma>.\n       all_same_arities ve_ F2 \\<Longrightarrow>\n       Subx.sp_instr ve_ (ILoadUbx \\<tau> vf_) (None # \\<Sigma>) =\n       Subx.sp_instr F2 (ILoadUbx \\<tau> vf_) (None # \\<Sigma>)\n 7. \\<And>vg_ vh_ \\<Sigma>.\n       all_same_arities vg_ F2 \\<Longrightarrow>\n       Subx.sp_instr vg_ (Ubx.instr.IStore vh_) (None # None # \\<Sigma>) =\n       Subx.sp_instr F2 (Ubx.instr.IStore vh_) (None # None # \\<Sigma>)\n 8. \\<And>vi_ \\<tau>\\<^sub>1 vj_ \\<tau>\\<^sub>2 \\<Sigma>.\n       all_same_arities vi_ F2 \\<Longrightarrow>\n       Subx.sp_instr vi_ (IStoreUbx \\<tau>\\<^sub>1 vj_)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Subx.sp_instr F2 (IStoreUbx \\<tau>\\<^sub>1 vj_)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>)\n 9. \\<And>vk_ op \\<Sigma>.\n       all_same_arities vk_ F2 \\<Longrightarrow>\n       Subx.sp_instr vk_ (Ubx.instr.IOp op) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.IOp op) \\<Sigma>\n 10. \\<And>vl_ opinl \\<Sigma>.\n        all_same_arities vl_ F2 \\<Longrightarrow>\n        Subx.sp_instr vl_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n        Subx.sp_instr F2 (Ubx.instr.IOpInl opinl) \\<Sigma>\nA total of 26 subgoals...", "fix F1 f \\<Sigma>"], ["proof (state)\ngoal (26 subgoals):\n 1. \\<And>uu_ uv_ \\<Sigma>.\n       all_same_arities uu_ F2 \\<Longrightarrow>\n       Subx.sp_instr uu_ (Ubx.instr.IPush uv_) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.IPush uv_) \\<Sigma>\n 2. \\<And>uw_ ux_ \\<Sigma>.\n       all_same_arities uw_ F2 \\<Longrightarrow>\n       Subx.sp_instr uw_ (IPushUbx1 ux_) \\<Sigma> =\n       Subx.sp_instr F2 (IPushUbx1 ux_) \\<Sigma>\n 3. \\<And>uy_ uz_ \\<Sigma>.\n       all_same_arities uy_ F2 \\<Longrightarrow>\n       Subx.sp_instr uy_ (IPushUbx2 uz_) \\<Sigma> =\n       Subx.sp_instr F2 (IPushUbx2 uz_) \\<Sigma>\n 4. \\<And>va_ vb_ \\<Sigma>.\n       all_same_arities va_ F2 \\<Longrightarrow>\n       Subx.sp_instr va_ Ubx.instr.IPop (vb_ # \\<Sigma>) =\n       Subx.sp_instr F2 Ubx.instr.IPop (vb_ # \\<Sigma>)\n 5. \\<And>vc_ vd_ \\<Sigma>.\n       all_same_arities vc_ F2 \\<Longrightarrow>\n       Subx.sp_instr vc_ (Ubx.instr.ILoad vd_) (None # \\<Sigma>) =\n       Subx.sp_instr F2 (Ubx.instr.ILoad vd_) (None # \\<Sigma>)\n 6. \\<And>ve_ \\<tau> vf_ \\<Sigma>.\n       all_same_arities ve_ F2 \\<Longrightarrow>\n       Subx.sp_instr ve_ (ILoadUbx \\<tau> vf_) (None # \\<Sigma>) =\n       Subx.sp_instr F2 (ILoadUbx \\<tau> vf_) (None # \\<Sigma>)\n 7. \\<And>vg_ vh_ \\<Sigma>.\n       all_same_arities vg_ F2 \\<Longrightarrow>\n       Subx.sp_instr vg_ (Ubx.instr.IStore vh_) (None # None # \\<Sigma>) =\n       Subx.sp_instr F2 (Ubx.instr.IStore vh_) (None # None # \\<Sigma>)\n 8. \\<And>vi_ \\<tau>\\<^sub>1 vj_ \\<tau>\\<^sub>2 \\<Sigma>.\n       all_same_arities vi_ F2 \\<Longrightarrow>\n       Subx.sp_instr vi_ (IStoreUbx \\<tau>\\<^sub>1 vj_)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Subx.sp_instr F2 (IStoreUbx \\<tau>\\<^sub>1 vj_)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>)\n 9. \\<And>vk_ op \\<Sigma>.\n       all_same_arities vk_ F2 \\<Longrightarrow>\n       Subx.sp_instr vk_ (Ubx.instr.IOp op) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.IOp op) \\<Sigma>\n 10. \\<And>vl_ opinl \\<Sigma>.\n        all_same_arities vl_ F2 \\<Longrightarrow>\n        Subx.sp_instr vl_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n        Subx.sp_instr F2 (Ubx.instr.IOpInl opinl) \\<Sigma>\nA total of 26 subgoals...", "assume assms: \"all_same_arities F1 F2\""], ["proof (state)\nthis:\n  all_same_arities F1 F2\n\ngoal (26 subgoals):\n 1. \\<And>uu_ uv_ \\<Sigma>.\n       all_same_arities uu_ F2 \\<Longrightarrow>\n       Subx.sp_instr uu_ (Ubx.instr.IPush uv_) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.IPush uv_) \\<Sigma>\n 2. \\<And>uw_ ux_ \\<Sigma>.\n       all_same_arities uw_ F2 \\<Longrightarrow>\n       Subx.sp_instr uw_ (IPushUbx1 ux_) \\<Sigma> =\n       Subx.sp_instr F2 (IPushUbx1 ux_) \\<Sigma>\n 3. \\<And>uy_ uz_ \\<Sigma>.\n       all_same_arities uy_ F2 \\<Longrightarrow>\n       Subx.sp_instr uy_ (IPushUbx2 uz_) \\<Sigma> =\n       Subx.sp_instr F2 (IPushUbx2 uz_) \\<Sigma>\n 4. \\<And>va_ vb_ \\<Sigma>.\n       all_same_arities va_ F2 \\<Longrightarrow>\n       Subx.sp_instr va_ Ubx.instr.IPop (vb_ # \\<Sigma>) =\n       Subx.sp_instr F2 Ubx.instr.IPop (vb_ # \\<Sigma>)\n 5. \\<And>vc_ vd_ \\<Sigma>.\n       all_same_arities vc_ F2 \\<Longrightarrow>\n       Subx.sp_instr vc_ (Ubx.instr.ILoad vd_) (None # \\<Sigma>) =\n       Subx.sp_instr F2 (Ubx.instr.ILoad vd_) (None # \\<Sigma>)\n 6. \\<And>ve_ \\<tau> vf_ \\<Sigma>.\n       all_same_arities ve_ F2 \\<Longrightarrow>\n       Subx.sp_instr ve_ (ILoadUbx \\<tau> vf_) (None # \\<Sigma>) =\n       Subx.sp_instr F2 (ILoadUbx \\<tau> vf_) (None # \\<Sigma>)\n 7. \\<And>vg_ vh_ \\<Sigma>.\n       all_same_arities vg_ F2 \\<Longrightarrow>\n       Subx.sp_instr vg_ (Ubx.instr.IStore vh_) (None # None # \\<Sigma>) =\n       Subx.sp_instr F2 (Ubx.instr.IStore vh_) (None # None # \\<Sigma>)\n 8. \\<And>vi_ \\<tau>\\<^sub>1 vj_ \\<tau>\\<^sub>2 \\<Sigma>.\n       all_same_arities vi_ F2 \\<Longrightarrow>\n       Subx.sp_instr vi_ (IStoreUbx \\<tau>\\<^sub>1 vj_)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Subx.sp_instr F2 (IStoreUbx \\<tau>\\<^sub>1 vj_)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>)\n 9. \\<And>vk_ op \\<Sigma>.\n       all_same_arities vk_ F2 \\<Longrightarrow>\n       Subx.sp_instr vk_ (Ubx.instr.IOp op) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.IOp op) \\<Sigma>\n 10. \\<And>vl_ opinl \\<Sigma>.\n        all_same_arities vl_ F2 \\<Longrightarrow>\n        Subx.sp_instr vl_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n        Subx.sp_instr F2 (Ubx.instr.IOpInl opinl) \\<Sigma>\nA total of 26 subgoals...", "show \"Subx.sp_instr F1 (Ubx.ICall f) \\<Sigma> = Subx.sp_instr F2 (Ubx.ICall f) \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n    Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "proof (cases \"F1 f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. F1 f = None \\<Longrightarrow>\n    Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n    Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>\n 2. \\<And>a.\n       F1 f = Some a \\<Longrightarrow>\n       Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "case None"], ["proof (state)\nthis:\n  F1 f = None\n\ngoal (2 subgoals):\n 1. F1 f = None \\<Longrightarrow>\n    Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n    Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>\n 2. \\<And>a.\n       F1 f = Some a \\<Longrightarrow>\n       Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "then"], ["proof (chain)\npicking this:\n  F1 f = None", "have \"F2 f = None\""], ["proof (prove)\nusing this:\n  F1 f = None\n\ngoal (1 subgoal):\n 1. F2 f = None", "using HOL.spec[OF assms[unfolded all_same_arities_def], of f]"], ["proof (prove)\nusing this:\n  F1 f = None\n  rel_option (\\<lambda>fd gd. arity fd = arity gd) (F1 f) (F2 f)\n\ngoal (1 subgoal):\n 1. F2 f = None", "by simp"], ["proof (state)\nthis:\n  F2 f = None\n\ngoal (2 subgoals):\n 1. F1 f = None \\<Longrightarrow>\n    Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n    Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>\n 2. \\<And>a.\n       F1 f = Some a \\<Longrightarrow>\n       Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "with None"], ["proof (chain)\npicking this:\n  F1 f = None\n  F2 f = None", "show ?thesis"], ["proof (prove)\nusing this:\n  F1 f = None\n  F2 f = None\n\ngoal (1 subgoal):\n 1. Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n    Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "by simp"], ["proof (state)\nthis:\n  Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n  Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       F1 f = Some a \\<Longrightarrow>\n       Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       F1 f = Some a \\<Longrightarrow>\n       Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "case (Some a)"], ["proof (state)\nthis:\n  F1 f = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       F1 f = Some a \\<Longrightarrow>\n       Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "then"], ["proof (chain)\npicking this:\n  F1 f = Some a", "obtain b where \"F2 f = Some b\" and \"arity a = arity b\""], ["proof (prove)\nusing this:\n  F1 f = Some a\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>F2 f = Some b; arity a = arity b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using HOL.spec[OF assms[unfolded all_same_arities_def], of f]"], ["proof (prove)\nusing this:\n  F1 f = Some a\n  rel_option (\\<lambda>fd gd. arity fd = arity gd) (F1 f) (F2 f)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>F2 f = Some b; arity a = arity b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: option_rel_Some1)"], ["proof (state)\nthis:\n  F2 f = Some b\n  arity a = arity b\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       F1 f = Some a \\<Longrightarrow>\n       Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "with Some"], ["proof (chain)\npicking this:\n  F1 f = Some a\n  F2 f = Some b\n  arity a = arity b", "show ?thesis"], ["proof (prove)\nusing this:\n  F1 f = Some a\n  F2 f = Some b\n  arity a = arity b\n\ngoal (1 subgoal):\n 1. Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n    Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>", "by simp"], ["proof (state)\nthis:\n  Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n  Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Subx.sp_instr F1 (Ubx.instr.ICall f) \\<Sigma> =\n  Subx.sp_instr F2 (Ubx.instr.ICall f) \\<Sigma>\n\ngoal (25 subgoals):\n 1. \\<And>uu_ uv_ \\<Sigma>.\n       all_same_arities uu_ F2 \\<Longrightarrow>\n       Subx.sp_instr uu_ (Ubx.instr.IPush uv_) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.IPush uv_) \\<Sigma>\n 2. \\<And>uw_ ux_ \\<Sigma>.\n       all_same_arities uw_ F2 \\<Longrightarrow>\n       Subx.sp_instr uw_ (IPushUbx1 ux_) \\<Sigma> =\n       Subx.sp_instr F2 (IPushUbx1 ux_) \\<Sigma>\n 3. \\<And>uy_ uz_ \\<Sigma>.\n       all_same_arities uy_ F2 \\<Longrightarrow>\n       Subx.sp_instr uy_ (IPushUbx2 uz_) \\<Sigma> =\n       Subx.sp_instr F2 (IPushUbx2 uz_) \\<Sigma>\n 4. \\<And>va_ vb_ \\<Sigma>.\n       all_same_arities va_ F2 \\<Longrightarrow>\n       Subx.sp_instr va_ Ubx.instr.IPop (vb_ # \\<Sigma>) =\n       Subx.sp_instr F2 Ubx.instr.IPop (vb_ # \\<Sigma>)\n 5. \\<And>vc_ vd_ \\<Sigma>.\n       all_same_arities vc_ F2 \\<Longrightarrow>\n       Subx.sp_instr vc_ (Ubx.instr.ILoad vd_) (None # \\<Sigma>) =\n       Subx.sp_instr F2 (Ubx.instr.ILoad vd_) (None # \\<Sigma>)\n 6. \\<And>ve_ \\<tau> vf_ \\<Sigma>.\n       all_same_arities ve_ F2 \\<Longrightarrow>\n       Subx.sp_instr ve_ (ILoadUbx \\<tau> vf_) (None # \\<Sigma>) =\n       Subx.sp_instr F2 (ILoadUbx \\<tau> vf_) (None # \\<Sigma>)\n 7. \\<And>vg_ vh_ \\<Sigma>.\n       all_same_arities vg_ F2 \\<Longrightarrow>\n       Subx.sp_instr vg_ (Ubx.instr.IStore vh_) (None # None # \\<Sigma>) =\n       Subx.sp_instr F2 (Ubx.instr.IStore vh_) (None # None # \\<Sigma>)\n 8. \\<And>vi_ \\<tau>\\<^sub>1 vj_ \\<tau>\\<^sub>2 \\<Sigma>.\n       all_same_arities vi_ F2 \\<Longrightarrow>\n       Subx.sp_instr vi_ (IStoreUbx \\<tau>\\<^sub>1 vj_)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>) =\n       Subx.sp_instr F2 (IStoreUbx \\<tau>\\<^sub>1 vj_)\n        (None # Some \\<tau>\\<^sub>2 # \\<Sigma>)\n 9. \\<And>vk_ op \\<Sigma>.\n       all_same_arities vk_ F2 \\<Longrightarrow>\n       Subx.sp_instr vk_ (Ubx.instr.IOp op) \\<Sigma> =\n       Subx.sp_instr F2 (Ubx.instr.IOp op) \\<Sigma>\n 10. \\<And>vl_ opinl \\<Sigma>.\n        all_same_arities vl_ F2 \\<Longrightarrow>\n        Subx.sp_instr vl_ (Ubx.instr.IOpInl opinl) \\<Sigma> =\n        Subx.sp_instr F2 (Ubx.instr.IOpInl opinl) \\<Sigma>\nA total of 25 subgoals...", "qed simp_all"], ["", "lemma sp_same_arities:\n  assumes \"all_same_arities F1 F2\"\n  shows \"Subx.sp F1 = Subx.sp F2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp F1 = Subx.sp F2", "proof (intro ext allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. Subx.sp F1 x xa = Subx.sp F2 x xa", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. Subx.sp F1 x xa = Subx.sp F2 x xa", "show \"Subx.sp F1 xs ys = Subx.sp F2 xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp F1 xs ys = Subx.sp F2 xs ys", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. Subx.sp F1 [] ys = Subx.sp F2 [] ys\n 2. \\<And>a xs ys.\n       (\\<And>ys. Subx.sp F1 xs ys = Subx.sp F2 xs ys) \\<Longrightarrow>\n       Subx.sp F1 (a # xs) ys = Subx.sp F2 (a # xs) ys", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ys. Subx.sp F1 [] ys = Subx.sp F2 [] ys\n 2. \\<And>a xs ys.\n       (\\<And>ys. Subx.sp F1 xs ys = Subx.sp F2 xs ys) \\<Longrightarrow>\n       Subx.sp F1 (a # xs) ys = Subx.sp F2 (a # xs) ys", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp F1 [] ys = Subx.sp F2 [] ys", "by simp"], ["proof (state)\nthis:\n  Subx.sp F1 [] ys = Subx.sp F2 [] ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys. Subx.sp F1 xs ys = Subx.sp F2 xs ys) \\<Longrightarrow>\n       Subx.sp F1 (a # xs) ys = Subx.sp F2 (a # xs) ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys. Subx.sp F1 xs ys = Subx.sp F2 xs ys) \\<Longrightarrow>\n       Subx.sp F1 (a # xs) ys = Subx.sp F2 (a # xs) ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  Subx.sp F1 xs ?ys44 = Subx.sp F2 xs ?ys44\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       (\\<And>ys. Subx.sp F1 xs ys = Subx.sp F2 xs ys) \\<Longrightarrow>\n       Subx.sp F1 (a # xs) ys = Subx.sp F2 (a # xs) ys", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp F1 (x # xs) ys = Subx.sp F2 (x # xs) ys", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp_instr F1 x ys \\<bind> Subx.sp F1 xs =\n    Subx.sp_instr F2 x ys \\<bind> Subx.sp F2 xs", "apply (cases \"(F1, x, ys)\" rule: Subx.sp_instr.cases;\n          simp add: Cons.IH Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>opubx.\n       x = IOpUbx opubx \\<Longrightarrow>\n       Subx.sp_gen_pop_push (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n        ys \\<bind>\n       Subx.sp F1 xs =\n       Subx.sp_gen_pop_push (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n        ys \\<bind>\n       Subx.sp F2 xs\n 2. \\<And>f.\n       x = Ubx.instr.ICall f \\<Longrightarrow>\n       Result.of_option () (F1 f) \\<bind>\n       (\\<lambda>fd.\n           if arity fd \\<le> length ys \\<and>\n              take (arity fd) ys = replicate (arity fd) None\n           then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n       Subx.sp F1 xs =\n       Result.of_option () (F2 f) \\<bind>\n       (\\<lambda>fd.\n           if arity fd \\<le> length ys \\<and>\n              take (arity fd) ys = replicate (arity fd) None\n           then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n       Subx.sp F2 xs", "subgoal for opubx"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = IOpUbx opubx \\<Longrightarrow>\n    Subx.sp_gen_pop_push (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n     ys \\<bind>\n    Subx.sp F1 xs =\n    Subx.sp_gen_pop_push (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n     ys \\<bind>\n    Subx.sp F2 xs", "apply (cases \"\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>x = IOpUbx opubx;\n        \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (a, b)\\<rbrakk>\n       \\<Longrightarrow> Subx.sp_gen_pop_push\n                          (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n                          ys \\<bind>\n                         Subx.sp F1 xs =\n                         Subx.sp_gen_pop_push\n                          (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n                          ys \\<bind>\n                         Subx.sp F2 xs", "by (auto simp: Cons.IH Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       x = Ubx.instr.ICall f \\<Longrightarrow>\n       Result.of_option () (F1 f) \\<bind>\n       (\\<lambda>fd.\n           if arity fd \\<le> length ys \\<and>\n              take (arity fd) ys = replicate (arity fd) None\n           then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n       Subx.sp F1 xs =\n       Result.of_option () (F2 f) \\<bind>\n       (\\<lambda>fd.\n           if arity fd \\<le> length ys \\<and>\n              take (arity fd) ys = replicate (arity fd) None\n           then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n       Subx.sp F2 xs", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Ubx.instr.ICall f \\<Longrightarrow>\n    Result.of_option () (F1 f) \\<bind>\n    (\\<lambda>fd.\n        if arity fd \\<le> length ys \\<and>\n           take (arity fd) ys = replicate (arity fd) None\n        then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n    Subx.sp F1 xs =\n    Result.of_option () (F2 f) \\<bind>\n    (\\<lambda>fd.\n        if arity fd \\<le> length ys \\<and>\n           take (arity fd) ys = replicate (arity fd) None\n        then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n    Subx.sp F2 xs", "apply (rule option.rel_induct[of \"(\\<lambda>fd gd. arity fd = arity gd)\" \"F1 f\" \"F2 f\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. x = Ubx.instr.ICall f \\<Longrightarrow>\n    rel_option (\\<lambda>fd gd. arity fd = arity gd) (F1 f) (F2 f)\n 2. x = Ubx.instr.ICall f \\<Longrightarrow>\n    Result.of_option () None \\<bind>\n    (\\<lambda>fd.\n        if arity fd \\<le> length ys \\<and>\n           take (arity fd) ys = replicate (arity fd) None\n        then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n    Subx.sp F1 xs =\n    Result.of_option () None \\<bind>\n    (\\<lambda>fd.\n        if arity fd \\<le> length ys \\<and>\n           take (arity fd) ys = replicate (arity fd) None\n        then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n    Subx.sp F2 xs\n 3. \\<And>a2 b2.\n       \\<lbrakk>x = Ubx.instr.ICall f; arity a2 = arity b2\\<rbrakk>\n       \\<Longrightarrow> Result.of_option () (Some a2) \\<bind>\n                         (\\<lambda>fd.\n                             if arity fd \\<le> length ys \\<and>\n                                take (arity fd) ys =\n                                replicate (arity fd) None\n                             then Ok (None # drop (arity fd) ys)\n                             else Error ()) \\<bind>\n                         Subx.sp F1 xs =\n                         Result.of_option () (Some b2) \\<bind>\n                         (\\<lambda>fd.\n                             if arity fd \\<le> length ys \\<and>\n                                take (arity fd) ys =\n                                replicate (arity fd) None\n                             then Ok (None # drop (arity fd) ys)\n                             else Error ()) \\<bind>\n                         Subx.sp F2 xs", "using assms(1)[unfolded all_same_arities_def]"], ["proof (prove)\nusing this:\n  \\<forall>f. rel_option (\\<lambda>fd gd. arity fd = arity gd) (F1 f) (F2 f)\n\ngoal (3 subgoals):\n 1. x = Ubx.instr.ICall f \\<Longrightarrow>\n    rel_option (\\<lambda>fd gd. arity fd = arity gd) (F1 f) (F2 f)\n 2. x = Ubx.instr.ICall f \\<Longrightarrow>\n    Result.of_option () None \\<bind>\n    (\\<lambda>fd.\n        if arity fd \\<le> length ys \\<and>\n           take (arity fd) ys = replicate (arity fd) None\n        then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n    Subx.sp F1 xs =\n    Result.of_option () None \\<bind>\n    (\\<lambda>fd.\n        if arity fd \\<le> length ys \\<and>\n           take (arity fd) ys = replicate (arity fd) None\n        then Ok (None # drop (arity fd) ys) else Error ()) \\<bind>\n    Subx.sp F2 xs\n 3. \\<And>a2 b2.\n       \\<lbrakk>x = Ubx.instr.ICall f; arity a2 = arity b2\\<rbrakk>\n       \\<Longrightarrow> Result.of_option () (Some a2) \\<bind>\n                         (\\<lambda>fd.\n                             if arity fd \\<le> length ys \\<and>\n                                take (arity fd) ys =\n                                replicate (arity fd) None\n                             then Ok (None # drop (arity fd) ys)\n                             else Error ()) \\<bind>\n                         Subx.sp F1 xs =\n                         Result.of_option () (Some b2) \\<bind>\n                         (\\<lambda>fd.\n                             if arity fd \\<le> length ys \\<and>\n                                take (arity fd) ys =\n                                replicate (arity fd) None\n                             then Ok (None # drop (arity fd) ys)\n                             else Error ()) \\<bind>\n                         Subx.sp F2 xs", "by (auto simp add: Cons.IH)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Subx.sp F1 (x # xs) ys = Subx.sp F2 (x # xs) ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Subx.sp F1 xs ys = Subx.sp F2 xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas sp_fundef_same_arities = sp_same_arities[THEN eq_sp_to_eq_sp_fundef]"], ["", "lemma all_same_arities_add:\n  assumes \"Fubx_get F f = Some fd1\" and \"arity fd1 = arity fd2\"\n  shows \"all_same_arities (Fubx_get F) (Fubx_get (Fubx_add F f fd2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F) (Fubx_get (Fubx_add F f fd2))", "unfolding  all_same_arities_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>fa.\n       rel_option (\\<lambda>fd gd. arity fd = arity gd) (Fubx_get F fa)\n        (Fubx_get (Fubx_add F f fd2) fa)", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       rel_option (\\<lambda>fd gd. arity fd = arity gd) (Fubx_get F fa)\n        (Fubx_get (Fubx_add F f fd2) fa)", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       rel_option (\\<lambda>fd gd. arity fd = arity gd) (Fubx_get F fa)\n        (Fubx_get (Fubx_add F f fd2) fa)", "show \"rel_option (\\<lambda>fd gd. arity fd = arity gd)\n           (Fubx_get F g)\n           (Fubx_get (Fubx_add F f fd2) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd gd. arity fd = arity gd) (Fubx_get F g)\n     (Fubx_get (Fubx_add F f fd2) g)", "using assms"], ["proof (prove)\nusing this:\n  Fubx_get F f = Some fd1\n  arity fd1 = arity fd2\n\ngoal (1 subgoal):\n 1. rel_option (\\<lambda>fd gd. arity fd = arity gd) (Fubx_get F g)\n     (Fubx_get (Fubx_add F f fd2) g)", "by (cases \"f = g\") (simp_all add: option.rel_refl)"], ["proof (state)\nthis:\n  rel_option (\\<lambda>fd gd. arity fd = arity gd) (Fubx_get F g)\n   (Fubx_get (Fubx_add F f fd2) g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_same_arities_generalize_fundef:\n  assumes \"Fubx_get F f = Some fd\"\n  shows \"all_same_arities (Fubx_get F) (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F)\n     (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))", "using all_same_arities_add[OF assms(1)]"], ["proof (prove)\nusing this:\n  arity fd = arity ?fd2.0 \\<Longrightarrow>\n  all_same_arities (Fubx_get F) (Fubx_get (Fubx_add F f ?fd2.0))\n\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F)\n     (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))", "using ubx.arity_generalize_fundef"], ["proof (prove)\nusing this:\n  arity fd = arity ?fd2.0 \\<Longrightarrow>\n  all_same_arities (Fubx_get F) (Fubx_get (Fubx_add F f ?fd2.0))\n  ubx ?F_empty ?F_get ?F_add ?F_to_list ?heap_empty ?heap_get ?heap_add\n   ?heap_to_list ?is_true ?is_false ?box_ubx1.0 ?unbox_ubx1.0 ?box_ubx2.0\n   ?unbox_ubx2.0 ?\\<OO>\\<pp> ?\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n   ?\\<II>\\<nn>\\<ll>\\<OO>\\<pp> ?\\<II>\\<nn>\\<ll> ?\\<II>\\<ss>\\<II>\\<nn>\\<ll>\n   ?\\<DD>\\<ee>\\<II>\\<nn>\\<ll> ?\\<UU>\\<bb>\\<xx>\\<OO>\\<pp> ?\\<UU>\\<bb>\\<xx>\n   ?\\<BB>\\<oo>\\<xx>\n   ?\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> \\<Longrightarrow>\n  arity\n   (ubx.generalize_fundef ?box_ubx1.0 ?box_ubx2.0 ?\\<BB>\\<oo>\\<xx> ?fd2.0) =\n  arity ?fd2.0\n\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F)\n     (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))", "by simp"], ["", "lemma rel_stacktraces_box:\n  assumes\n    \"rel_stacktraces F1 xs ys opt\" and\n    \"F2 f = map_option Subx.generalize_fundef (F1 f)\" and\n    \"\\<And>g. f \\<noteq> g \\<Longrightarrow> F2 g = F1 g\" and\n    \"all_same_arities F1 F2\"\n  shows \"rel_stacktraces F2 xs (Subx.box_stack f ys) opt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces F2 xs (Subx.box_stack f ys) opt", "using assms(1)"], ["proof (prove)\nusing this:\n  rel_stacktraces F1 xs ys opt\n\ngoal (1 subgoal):\n 1. rel_stacktraces F2 xs (Subx.box_stack f ys) opt", "proof (induction xs ys opt rule: rel_stacktraces.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>opt. rel_stacktraces F2 [] (Subx.box_stack f []) opt\n 2. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces F1 st1 st2 (Some fa);\n        rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; F1 fa = Some fd2;\n        sp_fundef F1 fd2 (take n (body fd2)) = Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call F1 fd2 n \\<Sigma>2) opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces F2 (Frame fa n \\<Sigma>1 # st1)\n                          (Subx.box_stack f (Frame fa n \\<Sigma>2 # st2))\n                          opt", "case rel_stacktraces_Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>opt. rel_stacktraces F2 [] (Subx.box_stack f []) opt\n 2. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces F1 st1 st2 (Some fa);\n        rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; F1 fa = Some fd2;\n        sp_fundef F1 fd2 (take n (body fd2)) = Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call F1 fd2 n \\<Sigma>2) opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces F2 (Frame fa n \\<Sigma>1 # st1)\n                          (Subx.box_stack f (Frame fa n \\<Sigma>2 # st2))\n                          opt", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces F2 [] (Subx.box_stack f []) opt_", "by (auto intro: rel_stacktraces.intros)"], ["proof (state)\nthis:\n  rel_stacktraces F2 [] (Subx.box_stack f []) opt_\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces F1 st1 st2 (Some fa);\n        rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; F1 fa = Some fd2;\n        sp_fundef F1 fd2 (take n (body fd2)) = Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call F1 fd2 n \\<Sigma>2) opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces F2 (Frame fa n \\<Sigma>1 # st1)\n                          (Subx.box_stack f (Frame fa n \\<Sigma>2 # st2))\n                          opt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces F1 st1 st2 (Some fa);\n        rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; F1 fa = Some fd2;\n        sp_fundef F1 fd2 (take n (body fd2)) = Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call F1 fd2 n \\<Sigma>2) opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces F2 (Frame fa n \\<Sigma>1 # st1)\n                          (Subx.box_stack f (Frame fa n \\<Sigma>2 # st2))\n                          opt", "case (rel_stacktraces_Cons st1 st2 g \\<Sigma>1 \\<Sigma>2 gd n opt)"], ["proof (state)\nthis:\n  rel_stacktraces F1 st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  F1 g = Some gd\n  sp_fundef F1 gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call F1 gd n \\<Sigma>2) opt\n  rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some g)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces F1 st1 st2 (Some fa);\n        rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; F1 fa = Some fd2;\n        sp_fundef F1 fd2 (take n (body fd2)) = Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call F1 fd2 n \\<Sigma>2) opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces F2 (Frame fa n \\<Sigma>1 # st1)\n                          (Subx.box_stack f (Frame fa n \\<Sigma>2 # st2))\n                          opt", "note sp_F1_eq_sp_F2[simp] = sp_same_arities[OF assms(4)]"], ["proof (state)\nthis:\n  Subx.sp F1 = Subx.sp F2\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces F1 st1 st2 (Some fa);\n        rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; F1 fa = Some fd2;\n        sp_fundef F1 fd2 (take n (body fd2)) = Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call F1 fd2 n \\<Sigma>2) opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces F2 (Frame fa n \\<Sigma>1 # st1)\n                          (Subx.box_stack f (Frame fa n \\<Sigma>2 # st2))\n                          opt", "note sp_fundef_F1_eq_sp_fundef_F2[simp] = eq_sp_to_eq_sp_fundef[OF sp_F1_eq_sp_F2]"], ["proof (state)\nthis:\n  sp_fundef F1 = sp_fundef F2\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces F1 st1 st2 (Some fa);\n        rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; F1 fa = Some fd2;\n        sp_fundef F1 fd2 (take n (body fd2)) = Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call F1 fd2 n \\<Sigma>2) opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces F2 (Frame fa n \\<Sigma>1 # st1)\n                          (Subx.box_stack f (Frame fa n \\<Sigma>2 # st2))\n                          opt", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Subx.box_stack f (Frame g n \\<Sigma>2 # st2)) opt", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f = g \\<longrightarrow>\n     rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n      (Frame g n (map Subx.box_operand \\<Sigma>2) # Subx.box_stack g st2)\n      opt) \\<and>\n    (f \\<noteq> g \\<longrightarrow>\n     rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n      (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt)", "proof (intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. f = g \\<Longrightarrow>\n    rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n (map Subx.box_operand \\<Sigma>2) # Subx.box_stack g st2) opt\n 2. f \\<noteq> g \\<Longrightarrow>\n    rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt", "assume \"f = g\""], ["proof (state)\nthis:\n  f = g\n\ngoal (2 subgoals):\n 1. f = g \\<Longrightarrow>\n    rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n (map Subx.box_operand \\<Sigma>2) # Subx.box_stack g st2) opt\n 2. f \\<noteq> g \\<Longrightarrow>\n    rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt", "then"], ["proof (chain)\npicking this:\n  f = g", "have get2_g: \"F2 g = Some (Subx.generalize_fundef gd)\""], ["proof (prove)\nusing this:\n  f = g\n\ngoal (1 subgoal):\n 1. F2 g = Some (Subx.generalize_fundef gd)", "using assms(2) \\<open>F1 g = Some gd\\<close>"], ["proof (prove)\nusing this:\n  f = g\n  F2 f = map_option Subx.generalize_fundef (F1 f)\n  F1 g = Some gd\n\ngoal (1 subgoal):\n 1. F2 g = Some (Subx.generalize_fundef gd)", "by simp"], ["proof (state)\nthis:\n  F2 g = Some (Subx.generalize_fundef gd)\n\ngoal (2 subgoals):\n 1. f = g \\<Longrightarrow>\n    rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n (map Subx.box_operand \\<Sigma>2) # Subx.box_stack g st2) opt\n 2. f \\<noteq> g \\<Longrightarrow>\n    rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt", "show \"rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n      (Frame g n (map Subx.box_operand \\<Sigma>2) # Subx.box_stack g st2) opt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n (map Subx.box_operand \\<Sigma>2) # Subx.box_stack g st2) opt", "proof (intro rel_stacktraces.intros)"], ["proof (state)\ngoal (5 subgoals):\n 1. rel_stacktraces F2 st1 (Subx.box_stack g st2) (Some g)\n 2. \\<Sigma>1 = norm_stack (map Subx.box_operand \\<Sigma>2)\n 3. F2 g = Some ?fd2.0\n 4. sp_fundef F2 ?fd2.0 (take n (body ?fd2.0)) =\n    Ok (map typeof (map Subx.box_operand \\<Sigma>2))\n 5. pred_option\n     (is_valid_fun_call F2 ?fd2.0 n (map Subx.box_operand \\<Sigma>2)) opt", "show \"rel_stacktraces F2 st1 (Subx.box_stack g st2) (Some g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces F2 st1 (Subx.box_stack g st2) (Some g)", "using rel_stacktraces_Cons.IH"], ["proof (prove)\nusing this:\n  rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some g)\n\ngoal (1 subgoal):\n 1. rel_stacktraces F2 st1 (Subx.box_stack g st2) (Some g)", "unfolding \\<open>f = g\\<close>"], ["proof (prove)\nusing this:\n  rel_stacktraces F2 st1 (Subx.box_stack g st2) (Some g)\n\ngoal (1 subgoal):\n 1. rel_stacktraces F2 st1 (Subx.box_stack g st2) (Some g)", "by simp"], ["proof (state)\nthis:\n  rel_stacktraces F2 st1 (Subx.box_stack g st2) (Some g)\n\ngoal (4 subgoals):\n 1. \\<Sigma>1 = norm_stack (map Subx.box_operand \\<Sigma>2)\n 2. F2 g = Some ?fd2.0\n 3. sp_fundef F2 ?fd2.0 (take n (body ?fd2.0)) =\n    Ok (map typeof (map Subx.box_operand \\<Sigma>2))\n 4. pred_option\n     (is_valid_fun_call F2 ?fd2.0 n (map Subx.box_operand \\<Sigma>2)) opt", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Sigma>1 = norm_stack (map Subx.box_operand \\<Sigma>2)\n 2. F2 g = Some ?fd2.0\n 3. sp_fundef F2 ?fd2.0 (take n (body ?fd2.0)) =\n    Ok (map typeof (map Subx.box_operand \\<Sigma>2))\n 4. pred_option\n     (is_valid_fun_call F2 ?fd2.0 n (map Subx.box_operand \\<Sigma>2)) opt", "show \"\\<Sigma>1 = norm_stack (map Subx.box_operand \\<Sigma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>1 = norm_stack (map Subx.box_operand \\<Sigma>2)", "using \\<open>\\<Sigma>1 = norm_stack \\<Sigma>2\\<close>"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. \\<Sigma>1 = norm_stack (map Subx.box_operand \\<Sigma>2)", "by simp"], ["proof (state)\nthis:\n  \\<Sigma>1 = norm_stack (map Subx.box_operand \\<Sigma>2)\n\ngoal (3 subgoals):\n 1. F2 g = Some ?fd2.0\n 2. sp_fundef F2 ?fd2.0 (take n (body ?fd2.0)) =\n    Ok (map typeof (map Subx.box_operand \\<Sigma>2))\n 3. pred_option\n     (is_valid_fun_call F2 ?fd2.0 n (map Subx.box_operand \\<Sigma>2)) opt", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. F2 g = Some ?fd2.0\n 2. sp_fundef F2 ?fd2.0 (take n (body ?fd2.0)) =\n    Ok (map typeof (map Subx.box_operand \\<Sigma>2))\n 3. pred_option\n     (is_valid_fun_call F2 ?fd2.0 n (map Subx.box_operand \\<Sigma>2)) opt", "show \"F2 g = Some (Subx.generalize_fundef gd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F2 g = Some (Subx.generalize_fundef gd)", "using get2_g"], ["proof (prove)\nusing this:\n  F2 g = Some (Subx.generalize_fundef gd)\n\ngoal (1 subgoal):\n 1. F2 g = Some (Subx.generalize_fundef gd)", "."], ["proof (state)\nthis:\n  F2 g = Some (Subx.generalize_fundef gd)\n\ngoal (2 subgoals):\n 1. sp_fundef F2 (Subx.generalize_fundef gd)\n     (take n (body (Subx.generalize_fundef gd))) =\n    Ok (map typeof (map Subx.box_operand \\<Sigma>2))\n 2. pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundef F2 (Subx.generalize_fundef gd)\n     (take n (body (Subx.generalize_fundef gd))) =\n    Ok (map typeof (map Subx.box_operand \\<Sigma>2))\n 2. pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt", "show \"sp_fundef F2 (Subx.generalize_fundef gd) (take n (body (Subx.generalize_fundef gd))) =\n        Ok (map typeof (map Subx.box_operand \\<Sigma>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef F2 (Subx.generalize_fundef gd)\n     (take n (body (Subx.generalize_fundef gd))) =\n    Ok (map typeof (map Subx.box_operand \\<Sigma>2))", "using sp_fundef_generalize[OF rel_stacktraces_Cons.hyps(4)]"], ["proof (prove)\nusing this:\n  sp_fundef F1 gd (map Subx.generalize_instr (take n (body gd))) =\n  Ok (map Map.empty (map typeof \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. sp_fundef F2 (Subx.generalize_fundef gd)\n     (take n (body (Subx.generalize_fundef gd))) =\n    Ok (map typeof (map Subx.box_operand \\<Sigma>2))", "by (simp add: take_map sp_fundef_def)"], ["proof (state)\nthis:\n  sp_fundef F2 (Subx.generalize_fundef gd)\n   (take n (body (Subx.generalize_fundef gd))) =\n  Ok (map typeof (map Subx.box_operand \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt", "show \"pred_option\n        (is_valid_fun_call F2 (Subx.generalize_fundef gd) n (map Subx.box_operand \\<Sigma>2)) opt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt", "proof (cases opt)"], ["proof (state)\ngoal (2 subgoals):\n 1. opt = None \\<Longrightarrow>\n    pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt\n 2. \\<And>a.\n       opt = Some a \\<Longrightarrow>\n       pred_option\n        (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n          (map Subx.box_operand \\<Sigma>2))\n        opt", "case (Some h)"], ["proof (state)\nthis:\n  opt = Some h\n\ngoal (2 subgoals):\n 1. opt = None \\<Longrightarrow>\n    pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt\n 2. \\<And>a.\n       opt = Some a \\<Longrightarrow>\n       pred_option\n        (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n          (map Subx.box_operand \\<Sigma>2))\n        opt", "then"], ["proof (chain)\npicking this:\n  opt = Some h", "show ?thesis"], ["proof (prove)\nusing this:\n  opt = Some h\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt", "using rel_stacktraces_Cons.hyps(5)"], ["proof (prove)\nusing this:\n  opt = Some h\n  pred_option (is_valid_fun_call F1 gd n \\<Sigma>2) opt\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt", "apply (simp add: take_map list.pred_map list.pred_True is_valid_fun_call_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>opt = Some h;\n     n < length (body gd) \\<and>\n     body gd ! n = Ubx.instr.ICall h \\<and>\n     (\\<exists>gd.\n         F1 h = Some gd \\<and>\n         list_all is_dyn_operand (take (arity gd) \\<Sigma>2))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gd. F2 h = Some gd", "using \\<open>f = g\\<close> assms(3) get2_g"], ["proof (prove)\nusing this:\n  f = g\n  f \\<noteq> ?g44 \\<Longrightarrow> F2 ?g44 = F1 ?g44\n  F2 g = Some (Subx.generalize_fundef gd)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>opt = Some h;\n     n < length (body gd) \\<and>\n     body gd ! n = Ubx.instr.ICall h \\<and>\n     (\\<exists>gd.\n         F1 h = Some gd \\<and>\n         list_all is_dyn_operand (take (arity gd) \\<Sigma>2))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gd. F2 h = Some gd", "by fastforce"], ["proof (state)\nthis:\n  pred_option\n   (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n     (map Subx.box_operand \\<Sigma>2))\n   opt\n\ngoal (1 subgoal):\n 1. opt = None \\<Longrightarrow>\n    pred_option\n     (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n       (map Subx.box_operand \\<Sigma>2))\n     opt", "qed simp"], ["proof (state)\nthis:\n  pred_option\n   (is_valid_fun_call F2 (Subx.generalize_fundef gd) n\n     (map Subx.box_operand \\<Sigma>2))\n   opt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n   (Frame g n (map Subx.box_operand \\<Sigma>2) # Subx.box_stack g st2) opt\n\ngoal (1 subgoal):\n 1. f \\<noteq> g \\<Longrightarrow>\n    rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> g \\<Longrightarrow>\n    rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt", "assume \"f \\<noteq> g\""], ["proof (state)\nthis:\n  f \\<noteq> g\n\ngoal (1 subgoal):\n 1. f \\<noteq> g \\<Longrightarrow>\n    rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt", "show \"rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt", "using rel_stacktraces_Cons assms(3)[OF \\<open>f \\<noteq> g\\<close>]"], ["proof (prove)\nusing this:\n  rel_stacktraces F1 st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  F1 g = Some gd\n  sp_fundef F1 gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call F1 gd n \\<Sigma>2) opt\n  rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some g)\n  F2 g = F1 g\n\ngoal (1 subgoal):\n 1. rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n     (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt", "apply (auto intro!: rel_stacktraces.intros;\n          cases opt; simp add: sp_fundef_def is_valid_fun_call_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>Subx.sp F2 (take n (body gd)) (replicate (arity gd) None) =\n                Ok (map typeof \\<Sigma>2);\n        n < length (body gd) \\<and>\n        body gd ! n = Ubx.instr.ICall a \\<and>\n        (\\<exists>gd.\n            F1 a = Some gd \\<and>\n            list_all is_dyn_operand (take (arity gd) \\<Sigma>2));\n        opt = Some a; rel_stacktraces F1 st1 st2 (Some g);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; F1 g = Some gd;\n        rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some g);\n        F2 g = Some gd\\<rbrakk>\n       \\<Longrightarrow> \\<exists>gd.\n                            F2 a = Some gd \\<and>\n                            list_all is_dyn_operand\n                             (take (arity gd) \\<Sigma>2)", "subgoal for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Subx.sp F2 (take n (body gd)) (replicate (arity gd) None) =\n             Ok (map typeof \\<Sigma>2);\n     n < length (body gd) \\<and>\n     body gd ! n = Ubx.instr.ICall h \\<and>\n     (\\<exists>gd.\n         F1 h = Some gd \\<and>\n         list_all is_dyn_operand (take (arity gd) \\<Sigma>2));\n     opt = Some h; rel_stacktraces F1 st1 st2 (Some g);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; F1 g = Some gd;\n     rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some g);\n     F2 g = Some gd\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gd.\n                         F2 h = Some gd \\<and>\n                         list_all is_dyn_operand (take (arity gd) \\<Sigma>2)", "using assms(2,3)"], ["proof (prove)\nusing this:\n  F2 f = map_option Subx.generalize_fundef (F1 f)\n  f \\<noteq> ?g44 \\<Longrightarrow> F2 ?g44 = F1 ?g44\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Subx.sp F2 (take n (body gd)) (replicate (arity gd) None) =\n             Ok (map typeof \\<Sigma>2);\n     n < length (body gd) \\<and>\n     body gd ! n = Ubx.instr.ICall h \\<and>\n     (\\<exists>gd.\n         F1 h = Some gd \\<and>\n         list_all is_dyn_operand (take (arity gd) \\<Sigma>2));\n     opt = Some h; rel_stacktraces F1 st1 st2 (Some g);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; F1 g = Some gd;\n     rel_stacktraces F2 st1 (Subx.box_stack f st2) (Some g);\n     F2 g = Some gd\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gd.\n                         F2 h = Some gd \\<and>\n                         list_all is_dyn_operand (take (arity gd) \\<Sigma>2)", "by (cases \"f = h\"; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n   (Frame g n \\<Sigma>2 # Subx.box_stack f st2) opt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_stacktraces F2 (Frame g n \\<Sigma>1 # st1)\n   (Subx.box_stack f (Frame g n \\<Sigma>2 # st2)) opt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_stacktraces_generalize:\n  assumes\n    \"rel_stacktraces (Fubx_get F) st1 st2 (Some f)\" and\n    \"Fubx_get F f = Some fd \" and\n    sp_prefix: \"sp_fundef (Fubx_get F) fd (take pc (body fd)) = Ok (None # map typeof \\<Sigma>2)\" and\n    norm_stacks: \"\\<Sigma>1 = norm_stack \\<Sigma>2\" and\n    pc_in_range: \"pc < length (body fd)\" and\n    sp_instr: \"Subx.sp_instr (Fubx_get F) (Subx.generalize_instr (body fd ! pc))\n      (None # map (\\<lambda>_. None) \\<Sigma>2) = Ok (None # map (typeof \\<circ> Subx.box_operand) \\<Sigma>2)\"\n  shows \"rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n          (Frame f (Suc pc) (d # \\<Sigma>1) # st1)\n          (Frame f (Suc pc) (OpDyn d # map Subx.box_operand \\<Sigma>2) # Subx.box_stack f st2) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     (Frame f (Suc pc) (d # \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn d # map Subx.box_operand \\<Sigma>2) #\n      Subx.box_stack f st2)\n     None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     (Frame f (Suc pc) (d # \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn d # map Subx.box_operand \\<Sigma>2) #\n      Subx.box_stack f st2)\n     None", "let ?fd' = \"Subx.generalize_fundef fd\""], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     (Frame f (Suc pc) (d # \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn d # map Subx.box_operand \\<Sigma>2) #\n      Subx.box_stack f st2)\n     None", "let ?F' = \"Fubx_add F f ?fd'\""], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     (Frame f (Suc pc) (d # \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn d # map Subx.box_operand \\<Sigma>2) #\n      Subx.box_stack f st2)\n     None", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     (Frame f (Suc pc) (d # \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn d # map Subx.box_operand \\<Sigma>2) #\n      Subx.box_stack f st2)\n     None", "proof (intro rel_stacktraces_Cons)"], ["proof (state)\ngoal (5 subgoals):\n 1. rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     st1 (Subx.box_stack f st2) (Some f)\n 2. d # \\<Sigma>1 = norm_stack (OpDyn d # map Subx.box_operand \\<Sigma>2)\n 3. Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) f = Some ?fd2.0\n 4. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0\n     (take (Suc pc) (body ?fd2.0)) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))\n 5. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0 (Suc pc)\n       (OpDyn d # map Subx.box_operand \\<Sigma>2))\n     None", "show \"rel_stacktraces (Fubx_get ?F') st1 (Subx.box_stack f st2) (Some f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     st1 (Subx.box_stack f st2) (Some f)", "using assms(2) all_same_arities_generalize_fundef"], ["proof (prove)\nusing this:\n  Fubx_get F f = Some fd\n  Fubx_get ?F ?f = Some ?fd \\<Longrightarrow>\n  all_same_arities (Fubx_get ?F)\n   (Fubx_get (Fubx_add ?F ?f (Subx.generalize_fundef ?fd)))\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     st1 (Subx.box_stack f st2) (Some f)", "by (auto intro: rel_stacktraces_box[OF assms(1)])"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) st1\n   (Subx.box_stack f st2) (Some f)\n\ngoal (4 subgoals):\n 1. d # \\<Sigma>1 = norm_stack (OpDyn d # map Subx.box_operand \\<Sigma>2)\n 2. Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) f = Some ?fd2.0\n 3. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0\n     (take (Suc pc) (body ?fd2.0)) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))\n 4. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0 (Suc pc)\n       (OpDyn d # map Subx.box_operand \\<Sigma>2))\n     None", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. d # \\<Sigma>1 = norm_stack (OpDyn d # map Subx.box_operand \\<Sigma>2)\n 2. Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) f = Some ?fd2.0\n 3. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0\n     (take (Suc pc) (body ?fd2.0)) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))\n 4. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0 (Suc pc)\n       (OpDyn d # map Subx.box_operand \\<Sigma>2))\n     None", "show \"d # \\<Sigma>1 = norm_stack (OpDyn d # map Subx.box_operand \\<Sigma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d # \\<Sigma>1 = norm_stack (OpDyn d # map Subx.box_operand \\<Sigma>2)", "using norm_stacks"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. d # \\<Sigma>1 = norm_stack (OpDyn d # map Subx.box_operand \\<Sigma>2)", "by simp"], ["proof (state)\nthis:\n  d # \\<Sigma>1 = norm_stack (OpDyn d # map Subx.box_operand \\<Sigma>2)\n\ngoal (3 subgoals):\n 1. Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) f = Some ?fd2.0\n 2. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0\n     (take (Suc pc) (body ?fd2.0)) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))\n 3. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0 (Suc pc)\n       (OpDyn d # map Subx.box_operand \\<Sigma>2))\n     None", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) f = Some ?fd2.0\n 2. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0\n     (take (Suc pc) (body ?fd2.0)) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))\n 3. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) ?fd2.0 (Suc pc)\n       (OpDyn d # map Subx.box_operand \\<Sigma>2))\n     None", "show \"Fubx_get ?F' f = Some ?fd'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) f =\n    Some (Subx.generalize_fundef fd)", "by simp"], ["proof (state)\nthis:\n  Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) f =\n  Some (Subx.generalize_fundef fd)\n\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     (Subx.generalize_fundef fd)\n     (take (Suc pc) (body (Subx.generalize_fundef fd))) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))\n 2. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n       (Subx.generalize_fundef fd) (Suc pc)\n       (OpDyn d # map Subx.box_operand \\<Sigma>2))\n     None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     (Subx.generalize_fundef fd)\n     (take (Suc pc) (body (Subx.generalize_fundef fd))) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))\n 2. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n       (Subx.generalize_fundef fd) (Suc pc)\n       (OpDyn d # map Subx.box_operand \\<Sigma>2))\n     None", "show \"sp_fundef (Fubx_get ?F') ?fd' (take (Suc pc) (body ?fd')) =\n      Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n     (Subx.generalize_fundef fd)\n     (take (Suc pc) (body (Subx.generalize_fundef fd))) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))", "unfolding all_same_arities_generalize_fundef[THEN sp_fundef_same_arities,\n          OF assms(2), symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F) (Subx.generalize_fundef fd)\n     (take (Suc pc) (body (Subx.generalize_fundef fd))) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))", "using sp_fundef_generalize[OF sp_prefix] sp_instr"], ["proof (prove)\nusing this:\n  sp_fundef (Fubx_get F) fd\n   (map Subx.generalize_instr (take pc (body fd))) =\n  Ok (map Map.empty (None # map typeof \\<Sigma>2))\n  Subx.sp_instr (Fubx_get F) (Subx.generalize_instr (body fd ! pc))\n   (None # map Map.empty \\<Sigma>2) =\n  Ok (None # map (typeof \\<circ> Subx.box_operand) \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F) (Subx.generalize_fundef fd)\n     (take (Suc pc) (body (Subx.generalize_fundef fd))) =\n    Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))", "by (auto simp add: sp_fundef_def take_map take_Suc_conv_app_nth[OF pc_in_range])"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n   (Subx.generalize_fundef fd)\n   (take (Suc pc) (body (Subx.generalize_fundef fd))) =\n  Ok (map typeof (OpDyn d # map Subx.box_operand \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n       (Subx.generalize_fundef fd) (Suc pc)\n       (OpDyn d # map Subx.box_operand \\<Sigma>2))\n     None", "qed simp_all"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\n   (Frame f (Suc pc) (d # \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn d # map Subx.box_operand \\<Sigma>2) #\n    Subx.box_stack f st2)\n   None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_fundefs_rewrite:\n  assumes\n    rel_F1_F2: \"rel_fundefs (Finca_get F1) (Fubx_get F2)\" and\n    F2_get_f: \"Fubx_get F2 f = Some fd2\" and\n    F2_add_f: \"Fubx_add F2 f (rewrite_fundef_body fd2 pc instr) = F2'\" and\n    eq_norm: \"norm_instr (body fd2 ! pc) = norm_instr instr\"\n  shows \"rel_fundefs (Finca_get F1) (Fubx_get F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2')", "unfolding rel_fundefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get F1 x) (Fubx_get F2' x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get F1 x) (Fubx_get F2' x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get F1 x) (Fubx_get F2' x)", "show \"rel_option (rel_fundef norm_eq) (Finca_get F1 x) (Fubx_get F2' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "proof (cases \"x = f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "case True"], ["proof (state)\nthis:\n  x = f\n\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "then"], ["proof (chain)\npicking this:\n  x = f", "have F2'_get_x: \"Fubx_get F2' x = Some (rewrite_fundef_body fd2 pc instr)\""], ["proof (prove)\nusing this:\n  x = f\n\ngoal (1 subgoal):\n 1. Fubx_get F2' x = Some (rewrite_fundef_body fd2 pc instr)", "using F2_add_f"], ["proof (prove)\nusing this:\n  x = f\n  Fubx_add F2 f (rewrite_fundef_body fd2 pc instr) = F2'\n\ngoal (1 subgoal):\n 1. Fubx_get F2' x = Some (rewrite_fundef_body fd2 pc instr)", "by auto"], ["proof (state)\nthis:\n  Fubx_get F2' x = Some (rewrite_fundef_body fd2 pc instr)\n\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "obtain fd1 where \"Finca_get F1 f = Some fd1\" and rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_get_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "unfolding F2'_get_x option_rel_Some2"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       Finca_get F1 x = Some x' \\<and>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) x'\n        (rewrite_fundef_body fd2 pc instr)", "using True rel_fundef_rewrite_body[OF rel_fd1_fd2 eq_norm]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  x = f\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1\n   (rewrite_fundef_body fd2 pc instr)\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       Finca_get F1 x = Some x' \\<and>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) x'\n        (rewrite_fundef_body fd2 pc instr)", "by auto"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (Finca_get F1 x)\n   (Fubx_get F2' x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> f\n\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> f", "have \"Fubx_get F2' x = Fubx_get F2 x\""], ["proof (prove)\nusing this:\n  x \\<noteq> f\n\ngoal (1 subgoal):\n 1. Fubx_get F2' x = Fubx_get F2 x", "using F2_add_f"], ["proof (prove)\nusing this:\n  x \\<noteq> f\n  Fubx_add F2 f (rewrite_fundef_body fd2 pc instr) = F2'\n\ngoal (1 subgoal):\n 1. Fubx_get F2' x = Fubx_get F2 x", "by auto"], ["proof (state)\nthis:\n  Fubx_get F2' x = Fubx_get F2 x\n\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2' x = Fubx_get F2 x", "show ?thesis"], ["proof (prove)\nusing this:\n  Fubx_get F2' x = Fubx_get F2 x\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "using rel_F1_F2 rel_fundefs_def"], ["proof (prove)\nusing this:\n  Fubx_get F2' x = Fubx_get F2 x\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  rel_fundefs ?f ?g =\n  (\\<forall>x.\n      rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z)) (?f x)\n       (?g x))\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x) (Fubx_get F2' x)", "by fastforce"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (Finca_get F1 x)\n   (Fubx_get F2' x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (Finca_get F1 x)\n   (Fubx_get F2' x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_fundef_rewrite_both:\n  assumes \"rel_fundef norm_eq fd1 fd2\" and \"norm_instr y = x\"\n  shows \"rel_fundef norm_eq (rewrite_fundef_body fd1 pc x) (rewrite_fundef_body fd2 pc y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y)\n     (rewrite_fundef_body fd1 pc x) (rewrite_fundef_body fd2 pc y)", "using assms"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  norm_instr y = x\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y)\n     (rewrite_fundef_body fd1 pc x) (rewrite_fundef_body fd2 pc y)", "by (auto simp: fundef.rel_sel)"], ["", "lemma rel_fundefs_rewrite_both:\n  assumes\n    rel_init: \"rel_fundefs (Finca_get F1) (Fubx_get F2)\" and\n    rel_new: \"rel_fundef norm_eq fd1 fd2\"\n  shows \"rel_fundefs (Finca_get (Finca_add F1 f fd1)) (Fubx_get (Fubx_add F2 f fd2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get (Finca_add F1 f fd1))\n     (Fubx_get (Fubx_add F2 f fd2))", "unfolding rel_fundefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "show \"rel_option (rel_fundef norm_eq) (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "proof (cases \"x = f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "case True"], ["proof (state)\nthis:\n  x = f\n\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "then"], ["proof (chain)\npicking this:\n  x = f", "show ?thesis"], ["proof (prove)\nusing this:\n  x = f\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "using rel_new"], ["proof (prove)\nusing this:\n  x = f\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "by simp"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n   (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> f\n\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> f", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> f\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "using rel_init"], ["proof (prove)\nusing this:\n  x \\<noteq> f\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)", "by (simp add: rel_fundefs_def)"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n   (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n   (Finca_get (Finca_add F1 f fd1) x) (Fubx_get (Fubx_add F2 f fd2) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_fundefs_generalize:\n  assumes\n    rel_F1_F2: \"rel_fundefs (Finca_get F1) (Fubx_get F2)\" and\n    F2_get_f: \"Fubx_get F2 f = Some fd2\"\n  shows \"rel_fundefs (Finca_get F1) (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))", "unfolding rel_fundefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get F1 x)\n        (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get F1 x)\n        (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "let ?F2' = \"(Fubx_add F2 f (Subx.generalize_fundef fd2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get F1 x)\n        (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z))\n        (Finca_get F1 x)\n        (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "show \"rel_option (rel_fundef norm_eq) (Finca_get F1 x) (Fubx_get ?F2' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "proof (cases \"x = f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "case True"], ["proof (state)\nthis:\n  x = f\n\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "then"], ["proof (chain)\npicking this:\n  x = f", "have F2'_get_x: \"Fubx_get ?F2' x = Some (Subx.generalize_fundef fd2)\""], ["proof (prove)\nusing this:\n  x = f\n\ngoal (1 subgoal):\n 1. Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x =\n    Some (Subx.generalize_fundef fd2)", "using Subx.Fenv.get_add_eq"], ["proof (prove)\nusing this:\n  x = f\n  Fubx_get (Fubx_add ?e ?x ?v) ?x = Some ?v\n\ngoal (1 subgoal):\n 1. Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x =\n    Some (Subx.generalize_fundef fd2)", "by auto"], ["proof (state)\nthis:\n  Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x =\n  Some (Subx.generalize_fundef fd2)\n\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "obtain fd1 where \"Finca_get F1 f = Some fd1\" and \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_get_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (2 subgoals):\n 1. x = f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)\n 2. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "unfolding F2'_get_x option_rel_Some2"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       Finca_get F1 x = Some x' \\<and>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) x'\n        (Subx.generalize_fundef fd2)", "using True rel_fundef_generalize"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  x = f\n  rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0\n   ?fd2.0 \\<Longrightarrow>\n  rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0\n   (Subx.generalize_fundef ?fd2.0)\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       Finca_get F1 x = Some x' \\<and>\n       rel_fundef (\\<lambda>x y. x = norm_instr y) x'\n        (Subx.generalize_fundef fd2)", "by auto"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (Finca_get F1 x)\n   (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> f\n\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> f", "have \"Fubx_get ?F2' x = Fubx_get F2 x\""], ["proof (prove)\nusing this:\n  x \\<noteq> f\n\ngoal (1 subgoal):\n 1. Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x = Fubx_get F2 x", "using Subx.Fenv.get_add_neq"], ["proof (prove)\nusing this:\n  x \\<noteq> f\n  ?x \\<noteq> ?y \\<Longrightarrow>\n  Fubx_get (Fubx_add ?e ?x ?v) ?y = Fubx_get ?e ?y\n\ngoal (1 subgoal):\n 1. Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x = Fubx_get F2 x", "by auto"], ["proof (state)\nthis:\n  Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x = Fubx_get F2 x\n\ngoal (1 subgoal):\n 1. x \\<noteq> f \\<Longrightarrow>\n    rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "then"], ["proof (chain)\npicking this:\n  Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x = Fubx_get F2 x", "show ?thesis"], ["proof (prove)\nusing this:\n  Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x = Fubx_get F2 x\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "using rel_F1_F2 rel_fundefs_def"], ["proof (prove)\nusing this:\n  Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x = Fubx_get F2 x\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  rel_fundefs ?f ?g =\n  (\\<forall>x.\n      rel_option (rel_fundef (\\<lambda>y z. y = norm_instr z)) (?f x)\n       (?g x))\n\ngoal (1 subgoal):\n 1. rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y))\n     (Finca_get F1 x)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)", "by fastforce"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (Finca_get F1 x)\n   (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_option (rel_fundef (\\<lambda>x y. x = norm_instr y)) (Finca_get F1 x)\n   (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_stacktraces_rewrite_fundef:\n  assumes\n    \"rel_stacktraces (Fubx_get F2) xs ys opt\" and\n    \"Fubx_get F2 f = Some fd\" and\n    \"pc < length (body fd)\" and\n    \"\\<forall>\\<Sigma>. Subx.sp_instr (Fubx_get F2) (body fd ! pc) \\<Sigma> = Subx.sp_instr (Fubx_get F2) instr \\<Sigma>\" and\n    \"\\<not> is_fun_call (body fd ! pc)\"\n  shows \"rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) xs ys opt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) xs ys opt", "using assms(1)"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) xs ys opt\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) xs ys opt", "proof (induction xs ys opt rule: rel_stacktraces.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>opt.\n       rel_stacktraces\n        (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) [] []\n        opt\n 2. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some fa);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 fa = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2)\n         opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces\n                          (Fubx_get\n                            (Fubx_add F2 f\n                              (rewrite_fundef_body fd pc instr)))\n                          (Frame fa n \\<Sigma>1 # st1)\n                          (Frame fa n \\<Sigma>2 # st2) opt", "case rel_stacktraces_Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>opt.\n       rel_stacktraces\n        (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) [] []\n        opt\n 2. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some fa);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 fa = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2)\n         opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces\n                          (Fubx_get\n                            (Fubx_add F2 f\n                              (rewrite_fundef_body fd pc instr)))\n                          (Frame fa n \\<Sigma>1 # st1)\n                          (Frame fa n \\<Sigma>2 # st2) opt", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) [] [] opt_", "by (auto intro: rel_stacktraces.intros)"], ["proof (state)\nthis:\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) [] [] opt_\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some fa);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 fa = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2)\n         opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces\n                          (Fubx_get\n                            (Fubx_add F2 f\n                              (rewrite_fundef_body fd pc instr)))\n                          (Frame fa n \\<Sigma>1 # st1)\n                          (Frame fa n \\<Sigma>2 # st2) opt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some fa);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 fa = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2)\n         opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces\n                          (Fubx_get\n                            (Fubx_add F2 f\n                              (rewrite_fundef_body fd pc instr)))\n                          (Frame fa n \\<Sigma>1 # st1)\n                          (Frame fa n \\<Sigma>2 # st2) opt", "case (rel_stacktraces_Cons st1 st2 g \\<Sigma>1 \\<Sigma>2 gd n opt)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 g = Some gd\n  sp_fundef (Fubx_get F2) gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) opt\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some g)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some fa);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 fa = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2)\n         opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces\n                          (Fubx_get\n                            (Fubx_add F2 f\n                              (rewrite_fundef_body fd pc instr)))\n                          (Frame fa n \\<Sigma>1 # st1)\n                          (Frame fa n \\<Sigma>2 # st2) opt", "have same_arities: \"all_same_arities (Fubx_get F2)\n    (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F2)\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))", "using all_same_arities_add[OF assms(2)]"], ["proof (prove)\nusing this:\n  arity fd = arity ?fd2.0 \\<Longrightarrow>\n  all_same_arities (Fubx_get F2) (Fubx_get (Fubx_add F2 f ?fd2.0))\n\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F2)\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))", "by simp"], ["proof (state)\nthis:\n  all_same_arities (Fubx_get F2)\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 fa \\<Sigma>1 \\<Sigma>2 fd2 n opt.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some fa);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some fa);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 fa = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2)\n         opt\\<rbrakk>\n       \\<Longrightarrow> rel_stacktraces\n                          (Fubx_get\n                            (Fubx_add F2 f\n                              (rewrite_fundef_body fd pc instr)))\n                          (Frame fa n \\<Sigma>1 # st1)\n                          (Frame fa n \\<Sigma>2 # st2) opt", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "proof (cases \"g = f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g = f \\<Longrightarrow>\n    rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt\n 2. g \\<noteq> f \\<Longrightarrow>\n    rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "case True"], ["proof (state)\nthis:\n  g = f\n\ngoal (2 subgoals):\n 1. g = f \\<Longrightarrow>\n    rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt\n 2. g \\<noteq> f \\<Longrightarrow>\n    rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "then"], ["proof (chain)\npicking this:\n  g = f", "have \"gd = fd\""], ["proof (prove)\nusing this:\n  g = f\n\ngoal (1 subgoal):\n 1. gd = fd", "using assms(2) rel_stacktraces_Cons.hyps(3)"], ["proof (prove)\nusing this:\n  g = f\n  Fubx_get F2 f = Some fd\n  Fubx_get F2 g = Some gd\n\ngoal (1 subgoal):\n 1. gd = fd", "by auto"], ["proof (state)\nthis:\n  gd = fd\n\ngoal (2 subgoals):\n 1. g = f \\<Longrightarrow>\n    rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt\n 2. g \\<noteq> f \\<Longrightarrow>\n    rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "thus ?thesis"], ["proof (prove)\nusing this:\n  gd = fd\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "using True rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  gd = fd\n  g = f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 g = Some gd\n  sp_fundef (Fubx_get F2) gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) opt\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some g)\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "apply (auto intro!: rel_stacktraces.intros\n        simp: sp_fundef_same_arities[OF same_arities, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f)\\<rbrakk>\n    \\<Longrightarrow> sp_fundef (Fubx_get F2)\n                       (rewrite_fundef_body fd pc instr)\n                       (take n (rewrite (body fd) pc instr)) =\n                      Ok (map typeof \\<Sigma>2)\n 2. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f)\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                       opt", "apply (cases \"n \\<le> pc\"; simp add: sp_fundef_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     Subx.sp (Fubx_get F2) (take n (body fd)) (replicate (arity fd) None) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f);\n     \\<not> n \\<le> pc\\<rbrakk>\n    \\<Longrightarrow> Subx.sp (Fubx_get F2)\n                       (take n (rewrite (body fd) pc instr))\n                       (replicate (arity fd) None) =\n                      Ok (map typeof \\<Sigma>2)\n 2. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f)\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                       opt", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     Subx.sp (Fubx_get F2) (take n (body fd)) (replicate (arity fd) None) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f);\n     \\<not> n \\<le> pc\\<rbrakk>\n    \\<Longrightarrow> Subx.sp (Fubx_get F2)\n                       (take n (rewrite (body fd) pc instr))\n                       (replicate (arity fd) None) =\n                      Ok (map typeof \\<Sigma>2)", "using assms(3,4)"], ["proof (prove)\nusing this:\n  pc < length (body fd)\n  \\<forall>\\<Sigma>.\n     Subx.sp_instr (Fubx_get F2) (body fd ! pc) \\<Sigma> =\n     Subx.sp_instr (Fubx_get F2) instr \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     Subx.sp (Fubx_get F2) (take n (body fd)) (replicate (arity fd) None) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f);\n     \\<not> n \\<le> pc\\<rbrakk>\n    \\<Longrightarrow> Subx.sp (Fubx_get F2)\n                       (take n (rewrite (body fd) pc instr))\n                       (replicate (arity fd) None) =\n                      Ok (map typeof \\<Sigma>2)", "by (simp add: Subx.sp_rewrite_eq_Ok take_rewrite_swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f)\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                       opt", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f)\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                       opt", "using rel_stacktraces_Cons.hyps(5)"], ["proof (prove)\nusing this:\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) opt\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f)\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                       opt", "proof (induction opt)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) None;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f);\n     pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2)\n      None\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                       None\n 2. \\<And>option.\n       \\<lbrakk>gd = fd; g = f;\n        rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n        sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2)\n         (Some option);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some f);\n        pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2)\n         (Some option)\\<rbrakk>\n       \\<Longrightarrow> pred_option\n                          (is_valid_fun_call\n                            (Fubx_get\n                              (Fubx_add F2 f\n                                (rewrite_fundef_body fd pc instr)))\n                            (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                          (Some option)", "case (Some h)"], ["proof (state)\nthis:\n  gd = fd\n  g = f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd\n  sp_fundef (Fubx_get F2) fd (take n (body fd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) (Some h)\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some f)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) (Some h)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) None;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f);\n     pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2)\n      None\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                       None\n 2. \\<And>option.\n       \\<lbrakk>gd = fd; g = f;\n        rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n        sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2)\n         (Some option);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some f);\n        pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2)\n         (Some option)\\<rbrakk>\n       \\<Longrightarrow> pred_option\n                          (is_valid_fun_call\n                            (Fubx_get\n                              (Fubx_add F2 f\n                                (rewrite_fundef_body fd pc instr)))\n                            (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                          (Some option)", "hence \"rewrite (body fd) pc instr ! n = Ubx.ICall h\""], ["proof (prove)\nusing this:\n  gd = fd\n  g = f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd\n  sp_fundef (Fubx_get F2) fd (take n (body fd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) (Some h)\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some f)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) (Some h)\n\ngoal (1 subgoal):\n 1. rewrite (body fd) pc instr ! n = Ubx.instr.ICall h", "using \\<open>gd = fd\\<close>"], ["proof (prove)\nusing this:\n  gd = fd\n  g = f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd\n  sp_fundef (Fubx_get F2) fd (take n (body fd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) (Some h)\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some f)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) (Some h)\n  gd = fd\n\ngoal (1 subgoal):\n 1. rewrite (body fd) pc instr ! n = Ubx.instr.ICall h", "apply (simp add: is_valid_fun_call_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     n < length (body fd) \\<and>\n     body fd ! n = Ubx.instr.ICall h \\<and>\n     (\\<exists>gd.\n         Fubx_get F2 h = Some gd \\<and>\n         list_all is_dyn_operand (take (arity gd) \\<Sigma>2));\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f);\n     gd = fd\\<rbrakk>\n    \\<Longrightarrow> rewrite (body fd) pc instr ! n = Ubx.instr.ICall h", "by (metis assms(5) instr.disc nth_rewrite_neq)"], ["proof (state)\nthis:\n  rewrite (body fd) pc instr ! n = Ubx.instr.ICall h\n\ngoal (2 subgoals):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) None;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f);\n     pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2)\n      None\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                       None\n 2. \\<And>option.\n       \\<lbrakk>gd = fd; g = f;\n        rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n        sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2)\n         (Some option);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some f);\n        pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2)\n         (Some option)\\<rbrakk>\n       \\<Longrightarrow> pred_option\n                          (is_valid_fun_call\n                            (Fubx_get\n                              (Fubx_add F2 f\n                                (rewrite_fundef_body fd pc instr)))\n                            (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                          (Some option)", "then"], ["proof (chain)\npicking this:\n  rewrite (body fd) pc instr ! n = Ubx.instr.ICall h", "show ?case"], ["proof (prove)\nusing this:\n  rewrite (body fd) pc instr ! n = Ubx.instr.ICall h\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n       (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n     (Some h)", "using Some \\<open>gd = fd\\<close>"], ["proof (prove)\nusing this:\n  rewrite (body fd) pc instr ! n = Ubx.instr.ICall h\n  gd = fd\n  g = f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd\n  sp_fundef (Fubx_get F2) fd (take n (body fd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) (Some h)\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some f)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) (Some h)\n  gd = fd\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n       (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n     (Some h)", "apply (simp add: is_valid_fun_call_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rewrite (body fd) pc instr ! n = Ubx.instr.ICall h; g = f;\n     rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     n < length (body fd) \\<and>\n     body fd ! n = Ubx.instr.ICall h \\<and>\n     (\\<exists>gd.\n         Fubx_get F2 h = Some gd \\<and>\n         list_all is_dyn_operand (take (arity gd) \\<Sigma>2));\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f);\n     gd = fd\\<rbrakk>\n    \\<Longrightarrow> \\<exists>gd.\n                         Fubx_get\n                          (Fubx_add F2 f (rewrite_fundef_body fd pc instr))\n                          h =\n                         Some gd \\<and>\n                         list_all is_dyn_operand (take (arity gd) \\<Sigma>2)", "by (metis arity_rewrite_fundef_body assms(2) option.inject Subx.Fenv.get_add_eq Subx.Fenv.get_add_neq)"], ["proof (state)\nthis:\n  pred_option\n   (is_valid_fun_call\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n   (Some h)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gd = fd; g = f; rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd;\n     sp_fundef (Fubx_get F2) fd (take n (body fd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) fd n \\<Sigma>2) None;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some f);\n     pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2)\n      None\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         (rewrite_fundef_body fd pc instr) n \\<Sigma>2)\n                       None", "qed simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n   (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "case False"], ["proof (state)\nthis:\n  g \\<noteq> f\n\ngoal (1 subgoal):\n 1. g \\<noteq> f \\<Longrightarrow>\n    rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "thus ?thesis"], ["proof (prove)\nusing this:\n  g \\<noteq> f\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "using rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  g \\<noteq> f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 g = Some gd\n  sp_fundef (Fubx_get F2) gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) opt\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some g)\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n     (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt", "apply (auto intro!: rel_stacktraces.intros\n        simp: sp_fundef_same_arities[OF same_arities, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<noteq> f; rel_stacktraces (Fubx_get F2) st1 st2 (Some g);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 g = Some gd;\n     sp_fundef (Fubx_get F2) gd (take n (body gd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) opt;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some g)\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         gd n \\<Sigma>2)\n                       opt", "proof (induction opt)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<noteq> f; rel_stacktraces (Fubx_get F2) st1 st2 (Some g);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 g = Some gd;\n     sp_fundef (Fubx_get F2) gd (take n (body gd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) None;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some g)\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         gd n \\<Sigma>2)\n                       None\n 2. \\<And>option.\n       \\<lbrakk>g \\<noteq> f;\n        rel_stacktraces (Fubx_get F2) st1 st2 (Some g);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 g = Some gd;\n        sp_fundef (Fubx_get F2) gd (take n (body gd)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2)\n         (Some option);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some g)\\<rbrakk>\n       \\<Longrightarrow> pred_option\n                          (is_valid_fun_call\n                            (Fubx_get\n                              (Fubx_add F2 f\n                                (rewrite_fundef_body fd pc instr)))\n                            gd n \\<Sigma>2)\n                          (Some option)", "case (Some h)"], ["proof (state)\nthis:\n  g \\<noteq> f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 g = Some gd\n  sp_fundef (Fubx_get F2) gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) (Some h)\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some g)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>g \\<noteq> f; rel_stacktraces (Fubx_get F2) st1 st2 (Some g);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 g = Some gd;\n     sp_fundef (Fubx_get F2) gd (take n (body gd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) None;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some g)\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         gd n \\<Sigma>2)\n                       None\n 2. \\<And>option.\n       \\<lbrakk>g \\<noteq> f;\n        rel_stacktraces (Fubx_get F2) st1 st2 (Some g);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 g = Some gd;\n        sp_fundef (Fubx_get F2) gd (take n (body gd)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2)\n         (Some option);\n        rel_stacktraces\n         (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1\n         st2 (Some g)\\<rbrakk>\n       \\<Longrightarrow> pred_option\n                          (is_valid_fun_call\n                            (Fubx_get\n                              (Fubx_add F2 f\n                                (rewrite_fundef_body fd pc instr)))\n                            gd n \\<Sigma>2)\n                          (Some option)", "then"], ["proof (chain)\npicking this:\n  g \\<noteq> f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 g = Some gd\n  sp_fundef (Fubx_get F2) gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) (Some h)\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some g)", "show ?case"], ["proof (prove)\nusing this:\n  g \\<noteq> f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 g = Some gd\n  sp_fundef (Fubx_get F2) gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) (Some h)\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some g)\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) gd n\n       \\<Sigma>2)\n     (Some h)", "using Some assms(2)"], ["proof (prove)\nusing this:\n  g \\<noteq> f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 g = Some gd\n  sp_fundef (Fubx_get F2) gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) (Some h)\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some g)\n  g \\<noteq> f\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some g)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 g = Some gd\n  sp_fundef (Fubx_get F2) gd (take n (body gd)) = Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) (Some h)\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n   (Some g)\n  Fubx_get F2 f = Some fd\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call\n       (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) gd n\n       \\<Sigma>2)\n     (Some h)", "by (cases \"h = f\"; simp add: is_valid_fun_call_def)"], ["proof (state)\nthis:\n  pred_option\n   (is_valid_fun_call\n     (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) gd n\n     \\<Sigma>2)\n   (Some h)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<noteq> f; rel_stacktraces (Fubx_get F2) st1 st2 (Some g);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 g = Some gd;\n     sp_fundef (Fubx_get F2) gd (take n (body gd)) =\n     Ok (map typeof \\<Sigma>2);\n     pred_option (is_valid_fun_call (Fubx_get F2) gd n \\<Sigma>2) None;\n     rel_stacktraces\n      (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr))) st1 st2\n      (Some g)\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call\n                         (Fubx_get\n                           (Fubx_add F2 f\n                             (rewrite_fundef_body fd pc instr)))\n                         gd n \\<Sigma>2)\n                       None", "qed simp"], ["proof (state)\nthis:\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n   (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_stacktraces\n   (Fubx_get (Fubx_add F2 f (rewrite_fundef_body fd pc instr)))\n   (Frame g n \\<Sigma>1 # st1) (Frame g n \\<Sigma>2 # st2) opt\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Matching relation\\<close>"], ["", "lemma sp_fundefs_get:\n  assumes \"sp_fundefs F\" and \"F f = Some fd\"\n  shows \"sp_fundef F fd (body fd) = Ok [None]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef F fd (body fd) = Ok [None]", "using assms"], ["proof (prove)\nusing this:\n  sp_fundefs F\n  F f = Some fd\n\ngoal (1 subgoal):\n 1. sp_fundef F fd (body fd) = Ok [None]", "by (simp add: sp_fundefs_def)"], ["", "lemma sp_fundefs_generalize:\n  assumes \"sp_fundefs (Fubx_get F)\" and \"Fubx_get F f = Some fd\"\n  shows \"sp_fundefs (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)))", "unfolding sp_fundefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>fa fda.\n       Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) fa =\n       Some fda \\<longrightarrow>\n       sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) fda\n        (body fda) =\n       Ok [None]", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa fda.\n       Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) fa =\n       Some fda \\<Longrightarrow>\n       sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) fda\n        (body fda) =\n       Ok [None]", "fix g gd"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa fda.\n       Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) fa =\n       Some fda \\<Longrightarrow>\n       sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) fda\n        (body fda) =\n       Ok [None]", "assume get_g: \"Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) g = Some gd\""], ["proof (state)\nthis:\n  Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) g = Some gd\n\ngoal (1 subgoal):\n 1. \\<And>fa fda.\n       Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) fa =\n       Some fda \\<Longrightarrow>\n       sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) fda\n        (body fda) =\n       Ok [None]", "note sp_F_eq_sp_F' = all_same_arities_generalize_fundef[OF assms(2), THEN sp_same_arities, symmetric]"], ["proof (state)\nthis:\n  Subx.sp (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) =\n  Subx.sp (Fubx_get F)\n\ngoal (1 subgoal):\n 1. \\<And>fa fda.\n       Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) fa =\n       Some fda \\<Longrightarrow>\n       sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) fda\n        (body fda) =\n       Ok [None]", "show \"sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd (body gd) = Ok [None]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "proof (cases \"f = g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]\n 2. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "case True"], ["proof (state)\nthis:\n  f = g\n\ngoal (2 subgoals):\n 1. f = g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]\n 2. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "then"], ["proof (chain)\npicking this:\n  f = g", "have \"gd = Subx.generalize_fundef fd\""], ["proof (prove)\nusing this:\n  f = g\n\ngoal (1 subgoal):\n 1. gd = Subx.generalize_fundef fd", "using get_g"], ["proof (prove)\nusing this:\n  f = g\n  Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) g = Some gd\n\ngoal (1 subgoal):\n 1. gd = Subx.generalize_fundef fd", "by simp"], ["proof (state)\nthis:\n  gd = Subx.generalize_fundef fd\n\ngoal (2 subgoals):\n 1. f = g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]\n 2. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "then"], ["proof (chain)\npicking this:\n  gd = Subx.generalize_fundef fd", "show ?thesis"], ["proof (prove)\nusing this:\n  gd = Subx.generalize_fundef fd\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "using assms"], ["proof (prove)\nusing this:\n  gd = Subx.generalize_fundef fd\n  sp_fundefs (Fubx_get F)\n  Fubx_get F f = Some fd\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "by (simp add: sp_fundefs_def sp_fundef_def sp_F_eq_sp_F' Subx.sp_generalize2)"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n   (body gd) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "case False"], ["proof (state)\nthis:\n  f \\<noteq> g\n\ngoal (1 subgoal):\n 1. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> g", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<noteq> g\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "using get_g assms"], ["proof (prove)\nusing this:\n  f \\<noteq> g\n  Fubx_get (Fubx_add F f (Subx.generalize_fundef fd)) g = Some gd\n  sp_fundefs (Fubx_get F)\n  Fubx_get F f = Some fd\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n     (body gd) =\n    Ok [None]", "by (simp add: sp_fundefs_def sp_fundef_def sp_F_eq_sp_F')"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n   (body gd) =\n  Ok [None]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get (Fubx_add F f (Subx.generalize_fundef fd))) gd\n   (body gd) =\n  Ok [None]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sp_fundefs_add:\n  assumes\n    \"sp_fundefs (Fubx_get F)\" and\n    \"sp_fundef (Fubx_get F) fd (body fd) = Ok [None]\" and\n    \"all_same_arities (Fubx_get F) (Fubx_get (Fubx_add F f fd))\"\n  shows \"sp_fundefs (Fubx_get (Fubx_add F f fd))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get (Fubx_add F f fd))", "unfolding sp_fundefs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>fa fda.\n       Fubx_get (Fubx_add F f fd) fa = Some fda \\<longrightarrow>\n       sp_fundef (Fubx_get (Fubx_add F f fd)) fda (body fda) = Ok [None]", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa fda.\n       Fubx_get (Fubx_add F f fd) fa = Some fda \\<Longrightarrow>\n       sp_fundef (Fubx_get (Fubx_add F f fd)) fda (body fda) = Ok [None]", "fix g gd"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fa fda.\n       Fubx_get (Fubx_add F f fd) fa = Some fda \\<Longrightarrow>\n       sp_fundef (Fubx_get (Fubx_add F f fd)) fda (body fda) = Ok [None]", "assume \"Fubx_get (Fubx_add F f fd) g = Some gd\""], ["proof (state)\nthis:\n  Fubx_get (Fubx_add F f fd) g = Some gd\n\ngoal (1 subgoal):\n 1. \\<And>fa fda.\n       Fubx_get (Fubx_add F f fd) fa = Some fda \\<Longrightarrow>\n       sp_fundef (Fubx_get (Fubx_add F f fd)) fda (body fda) = Ok [None]", "show \"sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]", "proof (cases \"f = g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. f = g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]\n 2. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]", "case True"], ["proof (state)\nthis:\n  f = g\n\ngoal (2 subgoals):\n 1. f = g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]\n 2. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]", "then"], ["proof (chain)\npicking this:\n  f = g", "have \"gd = fd\""], ["proof (prove)\nusing this:\n  f = g\n\ngoal (1 subgoal):\n 1. gd = fd", "using \\<open>Fubx_get (Fubx_add F f fd) g = Some gd\\<close>"], ["proof (prove)\nusing this:\n  f = g\n  Fubx_get (Fubx_add F f fd) g = Some gd\n\ngoal (1 subgoal):\n 1. gd = fd", "by simp"], ["proof (state)\nthis:\n  gd = fd\n\ngoal (2 subgoals):\n 1. f = g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]\n 2. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]", "then"], ["proof (chain)\npicking this:\n  gd = fd", "show ?thesis"], ["proof (prove)\nusing this:\n  gd = fd\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]", "unfolding sp_fundef_same_arities[OF assms(3), symmetric]"], ["proof (prove)\nusing this:\n  gd = fd\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F) gd (body gd) = Ok [None]", "using assms(2)"], ["proof (prove)\nusing this:\n  gd = fd\n  sp_fundef (Fubx_get F) fd (body fd) = Ok [None]\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F) gd (body gd) = Ok [None]", "by simp"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]\n\ngoal (1 subgoal):\n 1. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]", "case False"], ["proof (state)\nthis:\n  f \\<noteq> g\n\ngoal (1 subgoal):\n 1. f \\<noteq> g \\<Longrightarrow>\n    sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> g", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<noteq> g\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]", "unfolding sp_fundef_same_arities[OF assms(3), symmetric]"], ["proof (prove)\nusing this:\n  f \\<noteq> g\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F) gd (body gd) = Ok [None]", "using \\<open>Fubx_get (Fubx_add F f fd) g = Some gd\\<close>"], ["proof (prove)\nusing this:\n  f \\<noteq> g\n  Fubx_get (Fubx_add F f fd) g = Some gd\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F) gd (body gd) = Ok [None]", "using sp_fundefs_get[OF assms(1)]"], ["proof (prove)\nusing this:\n  f \\<noteq> g\n  Fubx_get (Fubx_add F f fd) g = Some gd\n  Fubx_get F ?f = Some ?fd \\<Longrightarrow>\n  sp_fundef (Fubx_get F) ?fd (body ?fd) = Ok [None]\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F) gd (body gd) = Ok [None]", "by simp"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get (Fubx_add F f fd)) gd (body gd) = Ok [None]\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive match (infix \"\\<sim>\" 55) where\n  \"rel_fundefs (Finca_get F1) (Fubx_get F2) \\<Longrightarrow>\n  sp_fundefs (Fubx_get F2) \\<Longrightarrow>\n  rel_stacktraces (Fubx_get F2) st1 st2 None \\<Longrightarrow>\n  match (State F1 H st1) (State F2 H st2)\""], ["", "section \\<open>Backward simulation\\<close>"], ["", "lemma traverse_cast_Dyn_to_norm: \"traverse cast_Dyn xs = Some ys \\<Longrightarrow> norm_stack xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse cast_Dyn xs = Some ys \\<Longrightarrow> norm_stack xs = ys", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       traverse cast_Dyn [] = Some ys \\<Longrightarrow> norm_stack [] = ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   norm_stack xs = ys;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> norm_stack (a # xs) = ys", "case Nil"], ["proof (state)\nthis:\n  traverse cast_Dyn [] = Some ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       traverse cast_Dyn [] = Some ys \\<Longrightarrow> norm_stack [] = ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   norm_stack xs = ys;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> norm_stack (a # xs) = ys", "then"], ["proof (chain)\npicking this:\n  traverse cast_Dyn [] = Some ys", "show ?case"], ["proof (prove)\nusing this:\n  traverse cast_Dyn [] = Some ys\n\ngoal (1 subgoal):\n 1. norm_stack [] = ys", "by simp"], ["proof (state)\nthis:\n  norm_stack [] = ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   norm_stack xs = ys;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> norm_stack (a # xs) = ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   norm_stack xs = ys;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> norm_stack (a # xs) = ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  traverse cast_Dyn xs = Some ?ys45 \\<Longrightarrow> norm_stack xs = ?ys45\n  traverse cast_Dyn (x # xs) = Some ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   norm_stack xs = ys;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> norm_stack (a # xs) = ys", "from Cons.prems"], ["proof (chain)\npicking this:\n  traverse cast_Dyn (x # xs) = Some ys", "show ?case"], ["proof (prove)\nusing this:\n  traverse cast_Dyn (x # xs) = Some ys\n\ngoal (1 subgoal):\n 1. norm_stack (x # xs) = ys", "by (auto intro: Cons.IH elim: cast_Dyn.elims simp: Option.bind_eq_Some_conv)"], ["proof (state)\nthis:\n  norm_stack (x # xs) = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma traverse_cast_Dyn_to_all_Dyn:\n  \"traverse cast_Dyn xs = Some ys \\<Longrightarrow> list_all (\\<lambda>x. typeof x = None) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n    list_all (\\<lambda>x. typeof x = None) xs", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       traverse cast_Dyn [] = Some ys \\<Longrightarrow>\n       list_all (\\<lambda>x. typeof x = None) []\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   list_all (\\<lambda>x. typeof x = None) xs;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> list_all (\\<lambda>x. typeof x = None) (a # xs)", "case Nil"], ["proof (state)\nthis:\n  traverse cast_Dyn [] = Some ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       traverse cast_Dyn [] = Some ys \\<Longrightarrow>\n       list_all (\\<lambda>x. typeof x = None) []\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   list_all (\\<lambda>x. typeof x = None) xs;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> list_all (\\<lambda>x. typeof x = None) (a # xs)", "then"], ["proof (chain)\npicking this:\n  traverse cast_Dyn [] = Some ys", "show ?case"], ["proof (prove)\nusing this:\n  traverse cast_Dyn [] = Some ys\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. typeof x = None) []", "by simp"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. typeof x = None) []\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   list_all (\\<lambda>x. typeof x = None) xs;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> list_all (\\<lambda>x. typeof x = None) (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   list_all (\\<lambda>x. typeof x = None) xs;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> list_all (\\<lambda>x. typeof x = None) (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  traverse cast_Dyn xs = Some ?ys45 \\<Longrightarrow>\n  list_all (\\<lambda>x. typeof x = None) xs\n  traverse cast_Dyn (x # xs) = Some ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse cast_Dyn xs = Some ys \\<Longrightarrow>\n                   list_all (\\<lambda>x. typeof x = None) xs;\n        traverse cast_Dyn (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> list_all (\\<lambda>x. typeof x = None) (a # xs)", "from Cons.prems"], ["proof (chain)\npicking this:\n  traverse cast_Dyn (x # xs) = Some ys", "show ?case"], ["proof (prove)\nusing this:\n  traverse cast_Dyn (x # xs) = Some ys\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. typeof x = None) (x # xs)", "by (auto intro: Cons.IH elim: cast_Dyn.elims simp: Option.bind_eq_Some_conv)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. typeof x = None) (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma backward_lockstep_simulation:\n  assumes \"Subx.step s2 s2'\" and \"s1 \\<sim> s2\"\n  shows \"\\<exists>s1'. Sinca.step s1 s1' \\<and> s1' \\<sim> s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'. Sinca.step s1 s1' \\<and> s1' \\<sim> s2'", "using assms(2,1)"], ["proof (prove)\nusing this:\n  s1 \\<sim> s2\n  Subx.step s2 s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s1'. Sinca.step s1 s1' \\<and> s1' \\<sim> s2'", "proof (induction s1 s2 rule: match.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.step (State F2 H st2) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step (State F1 H st1) s1' \\<and>\n                            s1' \\<sim> s2'", "case (1 F1 F2 st1 st2 H)"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Subx.step (State F2 H st2) s2'\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.step (State F2 H st2) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step (State F1 H st1) s1' \\<and>\n                            s1' \\<sim> s2'", "have rel_F1_F2: \"rel_fundefs (Finca_get F1) (Fubx_get F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2)", "using 1"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Subx.step (State F2 H st2) s2'\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2)", "by simp"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.step (State F2 H st2) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step (State F1 H st1) s1' \\<and>\n                            s1' \\<sim> s2'", "have sp_F2: \"sp_fundefs (Fubx_get F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2)", "using 1"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Subx.step (State F2 H st2) s2'\n\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2)", "by simp"], ["proof (state)\nthis:\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.step (State F2 H st2) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step (State F1 H st1) s1' \\<and>\n                            s1' \\<sim> s2'", "from \"1\"(3,4)"], ["proof (chain)\npicking this:\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Subx.step (State F2 H st2) s2'", "show ?case"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Subx.step (State F2 H st2) s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s1'. Sinca.step (State F1 H st1) s1' \\<and> s1' \\<sim> s2'", "proof (induction st1 st2 \"None :: 'fun option\" rule: rel_stacktraces.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. Subx.step (State F2 H []) s2' \\<Longrightarrow>\n    \\<exists>s1'. Sinca.step (State F1 H []) s1' \\<and> s1' \\<sim> s2'\n 2. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "case rel_stacktraces_Nil"], ["proof (state)\nthis:\n  Subx.step (State F2 H []) s2'\n\ngoal (2 subgoals):\n 1. Subx.step (State F2 H []) s2' \\<Longrightarrow>\n    \\<exists>s1'. Sinca.step (State F1 H []) s1' \\<and> s1' \\<sim> s2'\n 2. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "hence False"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H []) s2'\n\ngoal (1 subgoal):\n 1. False", "by (auto elim: Subx.step.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. Subx.step (State F2 H []) s2' \\<Longrightarrow>\n    \\<exists>s1'. Sinca.step (State F1 H []) s1' \\<and> s1' \\<sim> s2'\n 2. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>s1'. Sinca.step (State F1 H []) s1' \\<and> s1' \\<sim> s2'", "by simp"], ["proof (state)\nthis:\n  \\<exists>s1'. Sinca.step (State F1 H []) s1' \\<and> s1' \\<sim> s2'\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "case (rel_stacktraces_Cons st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 pc)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "have F2_f: \"Fubx_get F2 f = Some fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fubx_get F2 f = Some fd2", "using rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n\ngoal (1 subgoal):\n 1. Fubx_get F2 f = Some fd2", "by simp"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "have rel_st1_st2: \"rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) st1 st2 (Some f)", "using rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) st1 st2 (Some f)", "by simp"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "have sp_fundef_prefix: \"sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) = Ok (map typeof \\<Sigma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n    Ok (map typeof \\<Sigma>2)", "using rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n    Ok (map typeof \\<Sigma>2)", "by simp"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "have \\<Sigma>1_def: \"\\<Sigma>1 = norm_stack \\<Sigma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>1 = norm_stack \\<Sigma>2", "using rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n\ngoal (1 subgoal):\n 1. \\<Sigma>1 = norm_stack \\<Sigma>2", "by simp"], ["proof (state)\nthis:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "note sp_fundef_def[simp]"], ["proof (state)\nthis:\n  sp_fundef ?F ?fd ?xs \\<equiv> Subx.sp ?F ?xs (replicate (arity ?fd) None)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "note sp_prefix = sp_fundef_prefix[unfolded sp_fundef_def]"], ["proof (state)\nthis:\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "have sp_generalized: \"Subx.sp (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n      (map Subx.generalize_instr (take pc (body fd2))) (replicate (arity fd2) None) =\n      Ok (map (\\<lambda>_. None) \\<Sigma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n     (map Subx.generalize_instr (take pc (body fd2)))\n     (replicate (arity fd2) None) =\n    Ok (map Map.empty \\<Sigma>2)", "using Subx.sp_generalize[OF sp_prefix, simplified]"], ["proof (prove)\nusing this:\n  Subx.sp (Fubx_get F2) (map Subx.generalize_instr (take pc (body fd2)))\n   (replicate (arity fd2) None) =\n  Ok (map Map.empty \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n     (map Subx.generalize_instr (take pc (body fd2)))\n     (replicate (arity fd2) None) =\n    Ok (map Map.empty \\<Sigma>2)", "using all_same_arities_generalize_fundef[OF F2_f]"], ["proof (prove)\nusing this:\n  Subx.sp (Fubx_get F2) (map Subx.generalize_instr (take pc (body fd2)))\n   (replicate (arity fd2) None) =\n  Ok (map Map.empty \\<Sigma>2)\n  all_same_arities (Fubx_get F2)\n   (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n     (map Subx.generalize_instr (take pc (body fd2)))\n     (replicate (arity fd2) None) =\n    Ok (map Map.empty \\<Sigma>2)", "by (simp add: sp_same_arities)"], ["proof (state)\nthis:\n  Subx.sp (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n   (map Subx.generalize_instr (take pc (body fd2)))\n   (replicate (arity fd2) None) =\n  Ok (map Map.empty \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Subx.step (State F2 H (Frame f n \\<Sigma>2 # st2)) s2'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f n \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> s2'", "from rel_stacktraces_Cons.prems(1)"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'", "show ?case"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> s2'", "proof (induction \"State F2 H (Frame f pc \\<Sigma>2 # st2)\" s2' rule: Subx.step.induct)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>fd d.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPush d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)\n 2. \\<And>fd n.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx1 n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n 3. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 4. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 6. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 7. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 8. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 10. \\<And>fd op ar \\<Sigma>' x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n         \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 18 subgoals...", "case (step_push fd2' d)"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPush d\n\ngoal (18 subgoals):\n 1. \\<And>fd d.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPush d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)\n 2. \\<And>fd n.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx1 n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n 3. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 4. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 6. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 7. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 8. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 10. \\<And>fd op ar \\<Sigma>' x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n         \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPush d", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPush d\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPush d\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (18 subgoals):\n 1. \\<And>fd d.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPush d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)\n 2. \\<And>fd n.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx1 n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n 3. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 4. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 6. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 7. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 8. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 10. \\<And>fd op ar \\<Sigma>' x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n         \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 18 subgoals...", "obtain fd1 where fd1_thms: \"Finca_get F1 f = Some fd1\" \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (18 subgoals):\n 1. \\<And>fd d.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPush d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)\n 2. \\<And>fd n.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx1 n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n 3. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 4. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 6. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 7. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 8. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 10. \\<And>fd op ar \\<Sigma>' x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n         \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 18 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "let ?s1' = \"State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1))", "using step_push fd1_thms"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPush d\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1))", "by (auto intro: Sinca.step_push simp: rel_fundef_body_nth)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "using step_push rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPush d\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "by (auto intro!: match.intros intro: rel_stacktraces.intros simp: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2) # st2)\n\ngoal (17 subgoals):\n 1. \\<And>fd n.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx1 n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n 2. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 3. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 6. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 7. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd op ar \\<Sigma>' opinl x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>fd n.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx1 n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n 2. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 3. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 6. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 7. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd op ar \\<Sigma>' opinl x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 17 subgoals...", "case (step_push_ubx1 fd2' n)"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx1 n\n\ngoal (17 subgoals):\n 1. \\<And>fd n.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx1 n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n 2. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 3. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 6. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 7. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd op ar \\<Sigma>' opinl x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx1 n", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx1 n\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx1 n\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (17 subgoals):\n 1. \\<And>fd n.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx1 n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n 2. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 3. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 6. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 7. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd op ar \\<Sigma>' opinl x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 17 subgoals...", "obtain fd1 where fd1_thms: \"Finca_get F1 f = Some fd1\" \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (17 subgoals):\n 1. \\<And>fd n.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx1 n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n 2. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 3. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 6. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 7. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd op ar \\<Sigma>' opinl x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 17 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "let ?s1' = \"State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1))", "using step_push_ubx1 fd1_thms"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx1 n\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1))", "by (auto intro: Sinca.step_push simp: rel_fundef_body_nth)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "using step_push_ubx1 rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx1 n\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "by (auto intro!: match.intros intro: rel_stacktraces.intros simp: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1))\n  State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1))\n  State F1 H (Frame f (Suc pc) (box_ubx1 n # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n\ngoal (16 subgoals):\n 1. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 2. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 6. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 2. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 6. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 16 subgoals...", "case (step_push_ubx2 fd2' b)"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx2 b\n\ngoal (16 subgoals):\n 1. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 2. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 6. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx2 b", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx2 b\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx2 b\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (16 subgoals):\n 1. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 2. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 6. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 16 subgoals...", "obtain fd1 where fd1_thms: \"Finca_get F1 f = Some fd1\" \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (16 subgoals):\n 1. \\<And>fd b.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IPushUbx2 b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n 2. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 5. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 6. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 16 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "let ?s1' = \"State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1))", "using step_push_ubx2 fd1_thms"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx2 b\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1))", "by (auto intro: Sinca.step_push simp: rel_fundef_body_nth)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "using step_push_ubx2 rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IPushUbx2 b\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "by (auto intro!: match.intros intro: rel_stacktraces.intros simp: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1))\n  State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1))\n  State F1 H (Frame f (Suc pc) (box_ubx2 b # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n\ngoal (15 subgoals):\n 1. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 5. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc\n            (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 5. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc\n            (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 15 subgoals...", "case (step_pop fd2' x \\<Sigma>2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPop\n  x # \\<Sigma>2' = \\<Sigma>2\n\ngoal (15 subgoals):\n 1. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 5. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc\n            (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPop\n  x # \\<Sigma>2' = \\<Sigma>2", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPop\n  x # \\<Sigma>2' = \\<Sigma>2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPop\n  x # \\<Sigma>2' = \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (15 subgoals):\n 1. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 5. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc\n            (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 15 subgoals...", "obtain fd1 where fd1_thms: \"Finca_get F1 f = Some fd1\" \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (15 subgoals):\n 1. \\<And>fd x \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IPop; x # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 4. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 5. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opinl ar \\<Sigma>' x F'.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>2;\n         traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n         Fubx_add F2 f\n          (rewrite_fundef_body fd pc\n            (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F' H\n                              (Frame f (Suc pc)\n                                (OpDyn x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 15 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "let ?s1' = \"State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))", "unfolding \\<Sigma>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))", "using step_pop fd1_thms"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPop\n  x # \\<Sigma>2' = \\<Sigma>2\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))", "by (auto intro!: Sinca.step_pop simp: rel_fundef_body_nth)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "using step_pop rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IPop\n  x # \\<Sigma>2' = \\<Sigma>2\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "by (auto intro!: match.intros intro: rel_stacktraces.intros simp: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n  State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n  State F1 H (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (14 subgoals):\n 1. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 4. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opubx op ar x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = IOpUbx opubx;\n         \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n         \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n         Some x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 4. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opubx op ar x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = IOpUbx opubx;\n         \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n         \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n         Some x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 14 subgoals...", "case (step_load fd2' x i i' d \\<Sigma>2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ILoad x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  i # \\<Sigma>2' = \\<Sigma>2\n\ngoal (14 subgoals):\n 1. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 4. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opubx op ar x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = IOpUbx opubx;\n         \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n         \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n         Some x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ILoad x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  i # \\<Sigma>2' = \\<Sigma>2", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ILoad x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  i # \\<Sigma>2' = \\<Sigma>2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ILoad x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  i # \\<Sigma>2' = \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (14 subgoals):\n 1. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 4. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opubx op ar x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = IOpUbx opubx;\n         \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n         \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n         Some x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 14 subgoals...", "obtain fd1 where\n        F1_f: \"Finca_get F1 f = Some fd1\" and\n        rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (14 subgoals):\n 1. \\<And>fd x i i' d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ILoad x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 3. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 4. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd opubx op ar x.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = IOpUbx opubx;\n         \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n         \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n         Some x\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                               st2)\nA total of 14 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "let ?s1' = \"State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "have pc_in_range: \"pc < length (body fd1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "using rel_fd1_fd2 step_load(2)"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  pc < length (body fd2')\n\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))", "using step_load rel_fundef_body_nth[OF rel_fd1_fd2 pc_in_range]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ILoad x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  i # \\<Sigma>2' = \\<Sigma>2\n  body fd1 ! pc = norm_instr (body fd2 ! pc)\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))", "by (auto intro!: Sinca.step_load[OF F1_f pc_in_range, of x]\n                dest: cast_inversions(1)\n                simp: \\<Sigma>1_def)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "using step_load refl rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ILoad x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  i # \\<Sigma>2' = \\<Sigma>2\n  ?t = ?t\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "by (auto intro!: match.intros intro: rel_stacktraces.intros(2)[OF rel_st1_st2]\n              dest!: cast_inversions(1)\n              simp: take_Suc_conv_app_nth[OF step_load(2), simplified])"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n  State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n  State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)\n\ngoal (13 subgoals):\n 1. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 3. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f n \\<Sigma> # st2)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 3. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f n \\<Sigma> # st2)\nA total of 13 subgoals...", "case (step_load_ubx_hit fd2' \\<tau> x i i' d blob \\<Sigma>2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = Some blob\n  i # \\<Sigma>2' = \\<Sigma>2\n\ngoal (13 subgoals):\n 1. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 3. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f n \\<Sigma> # st2)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = Some blob\n  i # \\<Sigma>2' = \\<Sigma>2", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = Some blob\n  i # \\<Sigma>2' = \\<Sigma>2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = Some blob\n  i # \\<Sigma>2' = \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (13 subgoals):\n 1. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 3. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f n \\<Sigma> # st2)\nA total of 13 subgoals...", "obtain fd1 where\n        F1_f: \"Finca_get F1 f = Some fd1\" and\n        rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (13 subgoals):\n 1. \\<And>fd \\<tau> x i i' d blob \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = Some blob;\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (blob # \\<Sigma>) # st2)\n 2. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 3. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f n \\<Sigma> # st2)\nA total of 13 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "let ?s1' = \"State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "have pc_in_range: \"pc < length (body fd1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "using rel_fd1_fd2 step_load_ubx_hit(2)"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  pc < length (body fd2')\n\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))", "using step_load_ubx_hit rel_fundef_body_nth[OF rel_fd1_fd2 pc_in_range]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = Some blob\n  i # \\<Sigma>2' = \\<Sigma>2\n  body fd1 ! pc = norm_instr (body fd2 ! pc)\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))", "by (auto intro!: Sinca.step_load[OF F1_f pc_in_range, of x]\n              dest: cast_inversions(1)\n              simp: rel_fundef_body_nth \\<Sigma>1_def)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "using step_load_ubx_hit rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = Some blob\n  i # \\<Sigma>2' = \\<Sigma>2\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "by (auto intro!: match.intros intro: rel_stacktraces.intros(2)[OF rel_st1_st2]\n              dest!: cast_inversions(1)\n              simp: take_Suc_conv_app_nth[OF step_load_ubx_hit(2), simplified])"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n  State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n  State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)\n\ngoal (12 subgoals):\n 1. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 2. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 2. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\nA total of 12 subgoals...", "case (step_load_ubx_miss fd2' \\<tau> x i i' d F2' \\<Sigma>2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = None\n  Fubx_add F2 f (Subx.generalize_fundef fd2') = F2'\n  i # \\<Sigma>2' = \\<Sigma>2\n\ngoal (12 subgoals):\n 1. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 2. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = None\n  Fubx_add F2 f (Subx.generalize_fundef fd2') = F2'\n  i # \\<Sigma>2' = \\<Sigma>2", "have fd2'_def[simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = None\n  Fubx_add F2 f (Subx.generalize_fundef fd2') = F2'\n  i # \\<Sigma>2' = \\<Sigma>2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = None\n  Fubx_add F2 f (Subx.generalize_fundef fd2') = F2'\n  i # \\<Sigma>2' = \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (12 subgoals):\n 1. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 2. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\nA total of 12 subgoals...", "obtain fd1 where\n        F1_f: \"Finca_get F1 f = Some fd1\" and\n        rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (12 subgoals):\n 1. \\<And>fd \\<tau> x i i' d F' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = ILoadUbx \\<tau> x; cast_Dyn i = Some i';\n        heap_get H (x, i') = Some d; Subx.unbox \\<tau> d = None;\n        Fubx_add F2 f (Subx.generalize_fundef fd) = F';\n        i # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Subx.box_stack f\n                               (Frame f (Suc pc) (OpDyn d # \\<Sigma>) #\n                                st2))\n 2. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 10. \\<And>fd n y d \\<Sigma>.\n        \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n         body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n         y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\nA total of 12 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H\n        (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H\n        (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "let ?s1' = \"State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H\n        (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "have pc_in_range: \"pc < length (body fd1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "using rel_fd1_fd2 step_load_ubx_miss(2)"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  pc < length (body fd2')\n\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H\n        (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))", "using step_load_ubx_miss F1_f rel_fd1_fd2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = None\n  Fubx_add F2 f (Subx.generalize_fundef fd2') = F2'\n  i # \\<Sigma>2' = \\<Sigma>2\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))", "by (auto intro!: Sinca.step_load[OF F1_f pc_in_range, of x]\n              dest!: cast_inversions(1)\n              simp: rel_fundef_body_nth \\<Sigma>1_def)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H\n        (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H\n        (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2' H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "proof (rule match.intros)"], ["proof (state)\ngoal (3 subgoals):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2')\n 2. sp_fundefs (Fubx_get F2')\n 3. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)) None", "show \"rel_fundefs (Finca_get F1) (Fubx_get F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2')", "unfolding step_load_ubx_miss.hyps(7)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2')))", "using rel_fundefs_generalize[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1)\n   (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1)\n     (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2')))", "by simp"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2')\n\ngoal (2 subgoals):\n 1. sp_fundefs (Fubx_get F2')\n 2. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)) None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundefs (Fubx_get F2')\n 2. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)) None", "show \"sp_fundefs (Fubx_get F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2')", "unfolding step_load_ubx_miss.hyps(7)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2')))", "using sp_fundefs_generalize[OF sp_F2 F2_f]"], ["proof (prove)\nusing this:\n  sp_fundefs (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2')))", "by simp"], ["proof (state)\nthis:\n  sp_fundefs (Fubx_get F2')\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)) None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)) None", "show \"rel_stacktraces (Fubx_get F2')\n            (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\n            (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)) None", "using step_load_ubx_miss sp_fundef_prefix"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = ILoadUbx \\<tau> x\n  cast_Dyn i = Some i'\n  heap_get H (x, i') = Some d\n  Subx.unbox \\<tau> d = None\n  Fubx_add F2 f (Subx.generalize_fundef fd2') = F2'\n  i # \\<Sigma>2' = \\<Sigma>2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)) None", "by (auto intro!: rel_stacktraces_generalize[OF rel_st1_st2 F2_f] dest: cast_inversions)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2')\n   (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1)\n   (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)) None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2' H\n   (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H\n        (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n  State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2' H\n   (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1))\n  State F1 H (Frame f (Suc pc) (d # norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2' H\n   (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H\n        (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2' H\n      (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2' H\n      (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n\ngoal (11 subgoals):\n 1. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 10. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n         arity gd = ar; ar \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n         list_all is_dyn_operand (take ar \\<Sigma>);\n         frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 10. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n         arity gd = ar; ar \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n         list_all is_dyn_operand (take ar \\<Sigma>);\n         frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\nA total of 11 subgoals...", "case (step_store fd2' x i i' y d H' \\<Sigma>2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IStore x\n  cast_Dyn i = Some i'\n  cast_Dyn y = Some d\n  heap_add H (x, i') d = H'\n  i # y # \\<Sigma>2' = \\<Sigma>2\n\ngoal (11 subgoals):\n 1. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 10. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n         arity gd = ar; ar \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n         list_all is_dyn_operand (take ar \\<Sigma>);\n         frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IStore x\n  cast_Dyn i = Some i'\n  cast_Dyn y = Some d\n  heap_add H (x, i') d = H'\n  i # y # \\<Sigma>2' = \\<Sigma>2", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IStore x\n  cast_Dyn i = Some i'\n  cast_Dyn y = Some d\n  heap_add H (x, i') d = H'\n  i # y # \\<Sigma>2' = \\<Sigma>2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IStore x\n  cast_Dyn i = Some i'\n  cast_Dyn y = Some d\n  heap_add H (x, i') d = H'\n  i # y # \\<Sigma>2' = \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (11 subgoals):\n 1. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 10. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n         arity gd = ar; ar \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n         list_all is_dyn_operand (take ar \\<Sigma>);\n         frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\nA total of 11 subgoals...", "obtain fd1 where fd1_thms: \"Finca_get F1 f = Some fd1\" \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (11 subgoals):\n 1. \\<And>fd x i i' y d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IStore x; cast_Dyn i = Some i';\n        cast_Dyn y = Some d; heap_add H (x, i') d = H';\n        i # y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 9. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 10. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n         arity gd = ar; ar \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n         list_all is_dyn_operand (take ar \\<Sigma>);\n         frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim>\n                             State F2 H\n                              (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\nA total of 11 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "let ?s1' = \"State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))", "unfolding \\<Sigma>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))", "using step_store fd1_thms"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IStore x\n  cast_Dyn i = Some i'\n  cast_Dyn y = Some d\n  heap_add H (x, i') d = H'\n  i # y # \\<Sigma>2' = \\<Sigma>2\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))", "by (auto intro!: Sinca.step_store dest!: cast_inversions\n              simp: rel_fundef_body_nth)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "using step_store rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IStore x\n  cast_Dyn i = Some i'\n  cast_Dyn y = Some d\n  heap_add H (x, i') d = H'\n  i # y # \\<Sigma>2' = \\<Sigma>2\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "by (auto intro!: match.intros rel_stacktraces.intros dest!: cast_inversions\n              simp: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n  State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n  State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (10 subgoals):\n 1. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Fubx_get F2 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Fubx_get F2 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_store_ubx fd2' \\<tau> x i i' blob d H' \\<Sigma>2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IStoreUbx \\<tau> x\n  cast_Dyn i = Some i'\n  Subx.cast_and_box \\<tau> blob = Some d\n  heap_add H (x, i') d = H'\n  i # blob # \\<Sigma>2' = \\<Sigma>2\n\ngoal (10 subgoals):\n 1. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Fubx_get F2 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IStoreUbx \\<tau> x\n  cast_Dyn i = Some i'\n  Subx.cast_and_box \\<tau> blob = Some d\n  heap_add H (x, i') d = H'\n  i # blob # \\<Sigma>2' = \\<Sigma>2", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IStoreUbx \\<tau> x\n  cast_Dyn i = Some i'\n  Subx.cast_and_box \\<tau> blob = Some d\n  heap_add H (x, i') d = H'\n  i # blob # \\<Sigma>2' = \\<Sigma>2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IStoreUbx \\<tau> x\n  cast_Dyn i = Some i'\n  Subx.cast_and_box \\<tau> blob = Some d\n  heap_add H (x, i') d = H'\n  i # blob # \\<Sigma>2' = \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (10 subgoals):\n 1. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Fubx_get F2 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain fd1 where\n        F1_f: \"Finca_get F1 f = Some fd1\" and\n        rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (10 subgoals):\n 1. \\<And>fd \\<tau> x i i' blob d H' \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IStoreUbx \\<tau> x; cast_Dyn i = Some i';\n        Subx.cast_and_box \\<tau> blob = Some d; heap_add H (x, i') d = H';\n        i # blob # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H' (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 8. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 9. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Fubx_get F2 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s1'.\n                             Sinca.step\n                              (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                              s1' \\<and>\n                             s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "let ?s1' = \"State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "have pc_in_range: \"pc < length (body fd1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "using rel_fd1_fd2 step_store_ubx.hyps(2)"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  pc < length (body fd2')\n\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "by auto"], ["proof (state)\nthis:\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))", "unfolding \\<Sigma>1_def \\<open>i # blob # \\<Sigma>2' = \\<Sigma>2\\<close>[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step\n     (State F1 H (Frame f pc (norm_stack (i # blob # \\<Sigma>2')) # st1))\n     (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))", "using step_store_ubx pc_in_range"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IStoreUbx \\<tau> x\n  cast_Dyn i = Some i'\n  Subx.cast_and_box \\<tau> blob = Some d\n  heap_add H (x, i') d = H'\n  i # blob # \\<Sigma>2' = \\<Sigma>2\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. Sinca.step\n     (State F1 H (Frame f pc (norm_stack (i # blob # \\<Sigma>2')) # st1))\n     (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))", "by (auto intro!: Sinca.step_store[OF F1_f]\n              dest!: cast_inversions\n              simp: rel_fundef_body_nth[OF rel_fd1_fd2])"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "using step_store_ubx rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IStoreUbx \\<tau> x\n  cast_Dyn i = Some i'\n  Subx.cast_and_box \\<tau> blob = Some d\n  heap_add H (x, i') d = H'\n  i # blob # \\<Sigma>2' = \\<Sigma>2\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n    State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "by (auto intro!: match.intros rel_stacktraces.intros\n              dest!: cast_inversions\n              simp: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n  State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1))\n  State F1 H' (Frame f (Suc pc) (norm_stack \\<Sigma>2') # st1) \\<sim>\n  State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H' (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (9 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_op fd2' op ar \\<Sigma>2' x)"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = None\n  \\<OO>\\<pp> op \\<Sigma>2' = x\n\ngoal (9 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = None\n  \\<OO>\\<pp> op \\<Sigma>2' = x", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = None\n  \\<OO>\\<pp> op \\<Sigma>2' = x\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = None\n  \\<OO>\\<pp> op \\<Sigma>2' = x\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (9 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain fd1 where fd1_thms: \"Finca_get F1 f = Some fd1\" \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (9 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = None;\n        \\<OO>\\<pp> op \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 7. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 8. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "let ?s1' = \"State F1 H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "unfolding \\<Sigma>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State F1 H\n       (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "using step_op fd1_thms take_norm_stack traverse_cast_Dyn_to_norm"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = None\n  \\<OO>\\<pp> op \\<Sigma>2' = x\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  take ?n (norm_stack ?xs) = norm_stack (take ?n ?xs)\n  traverse cast_Dyn ?xs = Some ?ys \\<Longrightarrow> norm_stack ?xs = ?ys\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State F1 H\n       (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "by (auto intro!: Sinca.step_op simp: rel_fundef_body_nth)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using step_op rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = None\n  \\<OO>\\<pp> op \\<Sigma>2' = x\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "by (auto intro!: match.intros rel_stacktraces.intros\n              simp: take_Suc_conv_app_nth drop_norm_stack Let_def take_map drop_map\n                traverse_cast_Dyn_replicate)"], ["proof (state)\nthis:\n  State F1 H\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n  State F1 H\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n  State F1 H\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (8 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_op_inl fd2' op ar \\<Sigma>2' opinl x F2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n\ngoal (8 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (8 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain fd1 where\n        F1_f: \"Finca_get F1 f = Some fd1\" and\n        rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (8 subgoals):\n 1. \\<And>fd op ar \\<Sigma>' opinl x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f (rewrite_fundef_body fd pc (Ubx.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 6. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 7. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "let ?F1' = \"Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.IOpInl opinl))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "let ?s1' = \"State ?F1' H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)))\n       H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "unfolding \\<Sigma>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)))\n       H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "using step_op_inl F1_f rel_fd1_fd2 take_norm_stack traverse_cast_Dyn_to_norm"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  take ?n (norm_stack ?xs) = norm_stack (take ?n ?xs)\n  traverse cast_Dyn ?xs = Some ?ys \\<Longrightarrow> norm_stack ?xs = ?ys\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)))\n       H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "by (auto intro!: Sinca.step_op_inl simp: rel_fundef_body_nth)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State\n     (Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State\n     (Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State\n     (Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n    State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl))))\n     (Fubx_get F2')\n 2. sp_fundefs (Fubx_get F2')\n 3. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "show \"rel_fundefs (Finca_get ?F1') (Fubx_get F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl))))\n     (Fubx_get F2')", "using step_op_inl.hyps(9)"], ["proof (prove)\nusing this:\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n\ngoal (1 subgoal):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl))))\n     (Fubx_get F2')", "using rel_fundefs_rewrite_both[OF rel_F1_F2]"], ["proof (prove)\nusing this:\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n  rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0\n   ?fd2.0 \\<Longrightarrow>\n  rel_fundefs (Finca_get (Finca_add F1 ?f ?fd1.0))\n   (Fubx_get (Fubx_add F2 ?f ?fd2.0))\n\ngoal (1 subgoal):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl))))\n     (Fubx_get F2')", "using rel_fundef_rewrite_both[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n  rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0\n   ?fd2.0 \\<Longrightarrow>\n  rel_fundefs (Finca_get (Finca_add F1 ?f ?fd1.0))\n   (Fubx_get (Fubx_add F2 ?f ?fd2.0))\n  norm_instr ?y = ?x \\<Longrightarrow>\n  rel_fundef (\\<lambda>x y. x = norm_instr y)\n   (rewrite_fundef_body fd1 ?pc ?x) (rewrite_fundef_body fd2 ?pc ?y)\n\ngoal (1 subgoal):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl))))\n     (Fubx_get F2')", "by auto"], ["proof (state)\nthis:\n  rel_fundefs\n   (Finca_get\n     (Finca_add F1 f\n       (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl))))\n   (Fubx_get F2')\n\ngoal (2 subgoals):\n 1. sp_fundefs (Fubx_get F2')\n 2. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundefs (Fubx_get F2')\n 2. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "show \"sp_fundefs (Fubx_get F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2')", "using step_op_inl.hyps all_same_arities_add sp_fundefs_get[OF sp_F2]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n  \\<lbrakk>Fubx_get ?F ?f = Some ?fd1.0;\n   arity ?fd1.0 = arity ?fd2.0\\<rbrakk>\n  \\<Longrightarrow> all_same_arities (Fubx_get ?F)\n                     (Fubx_get (Fubx_add ?F ?f ?fd2.0))\n  Fubx_get F2 ?f = Some ?fd \\<Longrightarrow>\n  sp_fundef (Fubx_get F2) ?fd (body ?fd) = Ok [None]\n\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2')", "using Sinca.\\<II>\\<nn>\\<ll>_invertible"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n  \\<lbrakk>Fubx_get ?F ?f = Some ?fd1.0;\n   arity ?fd1.0 = arity ?fd2.0\\<rbrakk>\n  \\<Longrightarrow> all_same_arities (Fubx_get ?F)\n                     (Fubx_get (Fubx_add ?F ?f ?fd2.0))\n  Fubx_get F2 ?f = Some ?fd \\<Longrightarrow>\n  sp_fundef (Fubx_get F2) ?fd (body ?fd) = Ok [None]\n  \\<II>\\<nn>\\<ll> ?op ?xs = Some ?opinl \\<Longrightarrow>\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> ?opinl = ?op\n\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2')", "by (auto intro!: sp_fundefs_add[OF sp_F2] Subx.sp_rewrite_eq_Ok\n                simp: Subx.sp_instr_op Let_def)"], ["proof (state)\nthis:\n  sp_fundefs (Fubx_get F2')\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "have sp_F2_F2': \"Subx.sp (Fubx_get F2) = Subx.sp (Fubx_get F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get F2) = Subx.sp (Fubx_get F2')", "using step_op_inl.hyps(1,9)"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get F2) = Subx.sp (Fubx_get F2')", "by (auto intro!: sp_same_arities all_same_arities_add)"], ["proof (state)\nthis:\n  Subx.sp (Fubx_get F2) = Subx.sp (Fubx_get F2')\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "let ?fd2' = \"rewrite_fundef_body fd2' pc (Ubx.IOpInl opinl)\""], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "show \"rel_stacktraces (Fubx_get F2')\n            (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n            (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using step_op_inl"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "proof (intro rel_stacktraces.intros)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> rel_stacktraces (Fubx_get F2') st1 st2 (Some f)\n 2. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> x # drop ar (norm_stack \\<Sigma>2) =\n                      norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 3. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> Fubx_get F2' f = Some ?fd2.9\n 4. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> sp_fundef (Fubx_get F2') ?fd2.9\n                       (take (Suc pc) (body ?fd2.9)) =\n                      Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n 5. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call (Fubx_get F2') ?fd2.9 (Suc pc)\n                         (OpDyn x # drop ar \\<Sigma>2))\n                       None", "show \"rel_stacktraces (Fubx_get F2') st1 st2 (Some f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2') st1 st2 (Some f)", "using step_op_inl Sinca.\\<II>\\<nn>\\<ll>_invertible"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n  \\<II>\\<nn>\\<ll> ?op ?xs = Some ?opinl \\<Longrightarrow>\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> ?opinl = ?op\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2') st1 st2 (Some f)", "by (auto intro!: rel_stacktraces_rewrite_fundef[OF rel_st1_st2] simp: Subx.sp_instr_op)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2') st1 st2 (Some f)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> x # drop ar (norm_stack \\<Sigma>2) =\n                      norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 2. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> Fubx_get F2' f = Some ?fd2.9\n 3. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> sp_fundef (Fubx_get F2') ?fd2.9\n                       (take (Suc pc) (body ?fd2.9)) =\n                      Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n 4. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call (Fubx_get F2') ?fd2.9 (Suc pc)\n                         (OpDyn x # drop ar \\<Sigma>2))\n                       None", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> x # drop ar (norm_stack \\<Sigma>2) =\n                      norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 2. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> Fubx_get F2' f = Some ?fd2.9\n 3. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> sp_fundef (Fubx_get F2') ?fd2.9\n                       (take (Suc pc) (body ?fd2.9)) =\n                      Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n 4. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call (Fubx_get F2') ?fd2.9 (Suc pc)\n                         (OpDyn x # drop ar \\<Sigma>2))\n                       None", "show \"sp_fundef (Fubx_get F2') ?fd2' (take (Suc pc) (body ?fd2'))  =\n              Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2')\n     (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl))\n     (take (Suc pc)\n       (body (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)))) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))", "using step_op_inl Sinca.\\<II>\\<nn>\\<ll>_invertible sp_prefix"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n  \\<II>\\<nn>\\<ll> ?op ?xs = Some ?opinl \\<Longrightarrow>\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> ?opinl = ?op\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2')\n     (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl))\n     (take (Suc pc)\n       (body (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)))) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))", "using traverse_cast_Dyn_to_all_Dyn"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) = F2'\n  \\<II>\\<nn>\\<ll> ?op ?xs = Some ?opinl \\<Longrightarrow>\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> ?opinl = ?op\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  traverse cast_Dyn ?xs = Some ?ys \\<Longrightarrow>\n  list_all (\\<lambda>x. typeof x = None) ?xs\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2')\n     (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl))\n     (take (Suc pc)\n       (body (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)))) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))", "by (auto simp: take_Suc_conv_app_nth[of pc] sp_F2_F2'[symmetric] Let_def\n                    take_map drop_map traverse_cast_Dyn_replicate)"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get F2')\n   (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl))\n   (take (Suc pc)\n     (body (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)))) =\n  Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> x # drop ar (norm_stack \\<Sigma>2) =\n                      norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 2. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> Fubx_get F2' f =\n                      Some\n                       (rewrite_fundef_body fd2' pc\n                         (Ubx.instr.IOpInl opinl))\n 3. \\<lbrakk>Fubx_get F2 f = Some fd2'; pc < length (body fd2');\n     body fd2' ! pc = Ubx.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>2;\n     traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2';\n     \\<II>\\<nn>\\<ll> op \\<Sigma>2' = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x;\n     Fubx_add F2 f (rewrite_fundef_body fd2' pc (Ubx.instr.IOpInl opinl)) =\n     F2'\\<rbrakk>\n    \\<Longrightarrow> pred_option\n                       (is_valid_fun_call (Fubx_get F2')\n                         (rewrite_fundef_body fd2' pc\n                           (Ubx.instr.IOpInl opinl))\n                         (Suc pc) (OpDyn x # drop ar \\<Sigma>2))\n                       None", "qed (auto simp add: drop_norm_stack)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2')\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State\n   (Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl))) H\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State\n     (Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n  State\n   (Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl))) H\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State\n     (Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n  State\n   (Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl))) H\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (7 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_op_inl_hit fd2' opinl ar \\<Sigma>2' x)"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n\ngoal (7 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (7 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain fd1 where fd1_thms: \"Finca_get F1 f = Some fd1\" \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (7 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 5. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 6. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "let ?s1' = \"State F1 H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "unfolding \\<Sigma>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State F1 H\n       (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "using step_op_inl_hit fd1_thms take_norm_stack traverse_cast_Dyn_to_norm"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  take ?n (norm_stack ?xs) = norm_stack (take ?n ?xs)\n  traverse cast_Dyn ?xs = Some ?ys \\<Longrightarrow> norm_stack ?xs = ?ys\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State F1 H\n       (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "by (auto intro!: Sinca.step_op_inl_hit simp: rel_fundef_body_nth)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using step_op_inl_hit rel_stacktraces_Cons rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "apply (auto intro!: match.intros rel_stacktraces.intros simp: take_Suc_conv_app_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pc < length (body fd2); body fd2 ! pc = Ubx.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n     \\<le> length \\<Sigma>2;\n     traverse cast_Dyn\n      (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n        \\<Sigma>2) =\n     Some \\<Sigma>2';\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2';\n     rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n     Subx.sp (Fubx_get F2) (take pc (body fd2))\n      (replicate (arity fd2) None) =\n     Ok (map typeof \\<Sigma>2);\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2';\n     rel_fundefs (Finca_get F1) (Fubx_get F2); sp_fundefs (Fubx_get F2);\n     ar = \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl);\n     x = \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2'\\<rbrakk>\n    \\<Longrightarrow> drop\n                       (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                         (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                       (norm_stack \\<Sigma>2) =\n                      norm_stack\n                       (drop\n                         (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                           (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                         \\<Sigma>2)\n 2. \\<lbrakk>pc < length (body fd2); body fd2 ! pc = Ubx.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n     \\<le> length \\<Sigma>2;\n     traverse cast_Dyn\n      (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n        \\<Sigma>2) =\n     Some \\<Sigma>2';\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2';\n     rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n     Subx.sp (Fubx_get F2) (take pc (body fd2))\n      (replicate (arity fd2) None) =\n     Ok (map typeof \\<Sigma>2);\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2';\n     rel_fundefs (Finca_get F1) (Fubx_get F2); sp_fundefs (Fubx_get F2);\n     ar = \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl);\n     x = \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2'\\<rbrakk>\n    \\<Longrightarrow> (let ar = \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                                 (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n                       in if take ar (map typeof \\<Sigma>2) =\n                             replicate ar None\n                          then Ok (None # drop ar (map typeof \\<Sigma>2))\n                          else Error ()) \\<bind>\n                      Subx.sp (Fubx_get F2) [] =\n                      Ok (None #\n                          map typeof\n                           (drop\n                             (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                               (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                             \\<Sigma>2))", "using drop_norm_stack"], ["proof (prove)\nusing this:\n  drop ?n (norm_stack ?xs) = norm_stack (drop ?n ?xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>pc < length (body fd2); body fd2 ! pc = Ubx.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n     \\<le> length \\<Sigma>2;\n     traverse cast_Dyn\n      (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n        \\<Sigma>2) =\n     Some \\<Sigma>2';\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2';\n     rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n     Subx.sp (Fubx_get F2) (take pc (body fd2))\n      (replicate (arity fd2) None) =\n     Ok (map typeof \\<Sigma>2);\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2';\n     rel_fundefs (Finca_get F1) (Fubx_get F2); sp_fundefs (Fubx_get F2);\n     ar = \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl);\n     x = \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2'\\<rbrakk>\n    \\<Longrightarrow> drop\n                       (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                         (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                       (norm_stack \\<Sigma>2) =\n                      norm_stack\n                       (drop\n                         (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                           (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                         \\<Sigma>2)\n 2. \\<lbrakk>pc < length (body fd2); body fd2 ! pc = Ubx.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n     \\<le> length \\<Sigma>2;\n     traverse cast_Dyn\n      (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n        \\<Sigma>2) =\n     Some \\<Sigma>2';\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2';\n     rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n     Subx.sp (Fubx_get F2) (take pc (body fd2))\n      (replicate (arity fd2) None) =\n     Ok (map typeof \\<Sigma>2);\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2';\n     rel_fundefs (Finca_get F1) (Fubx_get F2); sp_fundefs (Fubx_get F2);\n     ar = \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl);\n     x = \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2'\\<rbrakk>\n    \\<Longrightarrow> (let ar = \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                                 (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n                       in if take ar (map typeof \\<Sigma>2) =\n                             replicate ar None\n                          then Ok (None # drop ar (map typeof \\<Sigma>2))\n                          else Error ()) \\<bind>\n                      Subx.sp (Fubx_get F2) [] =\n                      Ok (None #\n                          map typeof\n                           (drop\n                             (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                               (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                             \\<Sigma>2))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pc < length (body fd2); body fd2 ! pc = Ubx.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n     \\<le> length \\<Sigma>2;\n     traverse cast_Dyn\n      (take (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n        \\<Sigma>2) =\n     Some \\<Sigma>2';\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2';\n     rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n     \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n     Subx.sp (Fubx_get F2) (take pc (body fd2))\n      (replicate (arity fd2) None) =\n     Ok (map typeof \\<Sigma>2);\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2';\n     rel_fundefs (Finca_get F1) (Fubx_get F2); sp_fundefs (Fubx_get F2);\n     ar = \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl);\n     x = \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2'\\<rbrakk>\n    \\<Longrightarrow> (let ar = \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                                 (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)\n                       in if take ar (map typeof \\<Sigma>2) =\n                             replicate ar None\n                          then Ok (None # drop ar (map typeof \\<Sigma>2))\n                          else Error ()) \\<bind>\n                      Subx.sp (Fubx_get F2) [] =\n                      Ok (None #\n                          map typeof\n                           (drop\n                             (\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n                               (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\n                             \\<Sigma>2))", "by (simp add: Let_def drop_map take_map traverse_cast_Dyn_replicate)"], ["proof (state)\nthis:\n  State F1 H\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n  State F1 H\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n  State F1 H\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_op_inl_miss fd2' opinl ar \\<Sigma>2' x F2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain fd1 where\n        F1_f: \"Finca_get F1 f = Some fd1\" and\n        rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar \\<Sigma>' x F'.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>2;\n        traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>';\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>';\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x;\n        Fubx_add F2 f\n         (rewrite_fundef_body fd pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F' H\n                             (Frame f (Suc pc)\n                               (OpDyn x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 4. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 5. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "let ?F1' = \"Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "let ?s1' = \"State ?F1' H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n       H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "unfolding \\<Sigma>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n       H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "using step_op_inl_miss F1_f rel_fd1_fd2 take_norm_stack traverse_cast_Dyn_to_norm"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  take ?n (norm_stack ?xs) = norm_stack (take ?n ?xs)\n  traverse cast_Dyn ?xs = Some ?ys \\<Longrightarrow> norm_stack ?xs = ?ys\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc (norm_stack \\<Sigma>2) # st1))\n     (State\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n       H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))", "by (auto intro!: Sinca.step_op_inl_miss simp: rel_fundef_body_nth)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State\n     (Finca_add F1 f\n       (rewrite_fundef_body fd1 pc\n         (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State\n     (Finca_add F1 f\n       (rewrite_fundef_body fd1 pc\n         (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State\n     (Finca_add F1 f\n       (rewrite_fundef_body fd1 pc\n         (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n    State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Fubx_get F2')\n 2. sp_fundefs (Fubx_get F2')\n 3. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "show \"rel_fundefs (Finca_get ?F1') (Fubx_get F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Fubx_get F2')", "using step_op_inl_miss"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n\ngoal (1 subgoal):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Fubx_get F2')", "using rel_fundefs_rewrite_both[OF rel_F1_F2]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n  rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0\n   ?fd2.0 \\<Longrightarrow>\n  rel_fundefs (Finca_get (Finca_add F1 ?f ?fd1.0))\n   (Fubx_get (Fubx_add F2 ?f ?fd2.0))\n\ngoal (1 subgoal):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Fubx_get F2')", "using rel_fundef_rewrite_both[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n  rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0\n   ?fd2.0 \\<Longrightarrow>\n  rel_fundefs (Finca_get (Finca_add F1 ?f ?fd1.0))\n   (Fubx_get (Fubx_add F2 ?f ?fd2.0))\n  norm_instr ?y = ?x \\<Longrightarrow>\n  rel_fundef (\\<lambda>x y. x = norm_instr y)\n   (rewrite_fundef_body fd1 ?pc ?x) (rewrite_fundef_body fd2 ?pc ?y)\n\ngoal (1 subgoal):\n 1. rel_fundefs\n     (Finca_get\n       (Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Fubx_get F2')", "by auto"], ["proof (state)\nthis:\n  rel_fundefs\n   (Finca_get\n     (Finca_add F1 f\n       (rewrite_fundef_body fd1 pc\n         (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n   (Fubx_get F2')\n\ngoal (2 subgoals):\n 1. sp_fundefs (Fubx_get F2')\n 2. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundefs (Fubx_get F2')\n 2. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "show \"sp_fundefs (Fubx_get F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2')", "using step_op_inl_miss.hyps all_same_arities_add sp_fundefs_get[OF sp_F2]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n  \\<lbrakk>Fubx_get ?F ?f = Some ?fd1.0;\n   arity ?fd1.0 = arity ?fd2.0\\<rbrakk>\n  \\<Longrightarrow> all_same_arities (Fubx_get ?F)\n                     (Fubx_get (Fubx_add ?F ?f ?fd2.0))\n  Fubx_get F2 ?f = Some ?fd \\<Longrightarrow>\n  sp_fundef (Fubx_get F2) ?fd (body ?fd) = Ok [None]\n\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2')", "by (auto intro!: sp_fundefs_add[OF sp_F2] Subx.sp_rewrite_eq_Ok\n                simp: Subx.sp_instr_op[symmetric])"], ["proof (state)\nthis:\n  sp_fundefs (Fubx_get F2')\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "have sp_F2_F2': \"Subx.sp (Fubx_get F2) = Subx.sp (Fubx_get F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get F2) = Subx.sp (Fubx_get F2')", "using step_op_inl_miss"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get F2) = Subx.sp (Fubx_get F2')", "by (auto intro!: sp_same_arities all_same_arities_add)"], ["proof (state)\nthis:\n  Subx.sp (Fubx_get F2) = Subx.sp (Fubx_get F2')\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "let ?fd2' = \"rewrite_fundef_body fd2' pc (Ubx.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\""], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "show \"rel_stacktraces (Fubx_get F2')\n            (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n            (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2')\n     (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. rel_stacktraces (Fubx_get F2') st1 st2 (Some f)\n 2. x # drop ar (norm_stack \\<Sigma>2) =\n    norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 3. Fubx_get F2' f = Some ?fd2.0\n 4. sp_fundef (Fubx_get F2') ?fd2.0 (take (Suc pc) (body ?fd2.0)) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n 5. pred_option\n     (is_valid_fun_call (Fubx_get F2') ?fd2.0 (Suc pc)\n       (OpDyn x # drop ar \\<Sigma>2))\n     None", "show \"rel_stacktraces (Fubx_get F2') st1 st2 (Some f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2') st1 st2 (Some f)", "using step_op_inl_miss.hyps"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2') st1 st2 (Some f)", "by (auto intro: rel_stacktraces_rewrite_fundef[OF rel_st1_st2] simp: Subx.sp_instr_op[symmetric])"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2') st1 st2 (Some f)\n\ngoal (4 subgoals):\n 1. x # drop ar (norm_stack \\<Sigma>2) =\n    norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 2. Fubx_get F2' f = Some ?fd2.0\n 3. sp_fundef (Fubx_get F2') ?fd2.0 (take (Suc pc) (body ?fd2.0)) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n 4. pred_option\n     (is_valid_fun_call (Fubx_get F2') ?fd2.0 (Suc pc)\n       (OpDyn x # drop ar \\<Sigma>2))\n     None", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. x # drop ar (norm_stack \\<Sigma>2) =\n    norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 2. Fubx_get F2' f = Some ?fd2.0\n 3. sp_fundef (Fubx_get F2') ?fd2.0 (take (Suc pc) (body ?fd2.0)) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n 4. pred_option\n     (is_valid_fun_call (Fubx_get F2') ?fd2.0 (Suc pc)\n       (OpDyn x # drop ar \\<Sigma>2))\n     None", "show \"Fubx_get F2' f = Some ?fd2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fubx_get F2' f =\n    Some\n     (rewrite_fundef_body fd2' pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))", "using step_op_inl_miss Subx.Fenv.get_add_eq"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n  Fubx_get (Fubx_add ?e ?x ?v) ?x = Some ?v\n\ngoal (1 subgoal):\n 1. Fubx_get F2' f =\n    Some\n     (rewrite_fundef_body fd2' pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))", "by blast"], ["proof (state)\nthis:\n  Fubx_get F2' f =\n  Some\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n\ngoal (3 subgoals):\n 1. x # drop ar (norm_stack \\<Sigma>2) =\n    norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 2. sp_fundef (Fubx_get F2')\n     (rewrite_fundef_body fd2' pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n     (take (Suc pc)\n       (body\n         (rewrite_fundef_body fd2' pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n 3. pred_option\n     (is_valid_fun_call (Fubx_get F2')\n       (rewrite_fundef_body fd2' pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n       (Suc pc) (OpDyn x # drop ar \\<Sigma>2))\n     None", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. x # drop ar (norm_stack \\<Sigma>2) =\n    norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 2. sp_fundef (Fubx_get F2')\n     (rewrite_fundef_body fd2' pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n     (take (Suc pc)\n       (body\n         (rewrite_fundef_body fd2' pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n 3. pred_option\n     (is_valid_fun_call (Fubx_get F2')\n       (rewrite_fundef_body fd2' pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n       (Suc pc) (OpDyn x # drop ar \\<Sigma>2))\n     None", "show \"sp_fundef (Fubx_get F2') ?fd2' (take (Suc pc) (body ?fd2')) =\n              Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2')\n     (rewrite_fundef_body fd2' pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n     (take (Suc pc)\n       (body\n         (rewrite_fundef_body fd2' pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))", "using \\<open>pc < length (body fd2')\\<close>"], ["proof (prove)\nusing this:\n  pc < length (body fd2')\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2')\n     (rewrite_fundef_body fd2' pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n     (take (Suc pc)\n       (body\n         (rewrite_fundef_body fd2' pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))", "using sp_prefix step_op_inl_miss traverse_cast_Dyn_to_all_Dyn"], ["proof (prove)\nusing this:\n  pc < length (body fd2')\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>2\n  traverse cast_Dyn (take ar \\<Sigma>2) = Some \\<Sigma>2'\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>2'\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>2' = x\n  Fubx_add F2 f\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F2'\n  traverse cast_Dyn ?xs = Some ?ys \\<Longrightarrow>\n  list_all (\\<lambda>x. typeof x = None) ?xs\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2')\n     (rewrite_fundef_body fd2' pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n     (take (Suc pc)\n       (body\n         (rewrite_fundef_body fd2' pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))) =\n    Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))", "by (auto simp add: take_Suc_conv_app_nth[of pc] sp_F2_F2'[symmetric]\n                  traverse_cast_Dyn_replicate take_map drop_map)"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get F2')\n   (rewrite_fundef_body fd2' pc\n     (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n   (take (Suc pc)\n     (body\n       (rewrite_fundef_body fd2' pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))) =\n  Ok (map typeof (OpDyn x # drop ar \\<Sigma>2))\n\ngoal (2 subgoals):\n 1. x # drop ar (norm_stack \\<Sigma>2) =\n    norm_stack (OpDyn x # drop ar \\<Sigma>2)\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2')\n       (rewrite_fundef_body fd2' pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))\n       (Suc pc) (OpDyn x # drop ar \\<Sigma>2))\n     None", "qed (simp_all add: drop_norm_stack)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2')\n   (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State\n   (Finca_add F1 f\n     (rewrite_fundef_body fd1 pc\n       (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n   H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State\n     (Finca_add F1 f\n       (rewrite_fundef_body fd1 pc\n         (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n  State\n   (Finca_add F1 f\n     (rewrite_fundef_body fd1 pc\n       (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n   H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State\n     (Finca_add F1 f\n       (rewrite_fundef_body fd1 pc\n         (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1))\n  State\n   (Finca_add F1 f\n     (rewrite_fundef_body fd1 pc\n       (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n   H (Frame f (Suc pc) (x # drop ar (norm_stack \\<Sigma>2)) # st1) \\<sim>\n  State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim>\n     State F2' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (5 subgoals):\n 1. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_op_ubx fd2' opubx op ar x)"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IOpUbx opubx\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n\ngoal (5 subgoals):\n 1. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IOpUbx opubx\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x", "have [simp]: \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IOpUbx opubx\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IOpUbx opubx\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. fd2' = fd2", "by simp"], ["proof (state)\nthis:\n  fd2' = fd2\n\ngoal (5 subgoals):\n 1. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain fd1 where fd1_thms: \"Finca_get F1 f = Some fd1\" \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (5 subgoals):\n 1. \\<And>fd opubx op ar x.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = IOpUbx opubx;\n        \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>2;\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>2) #\n                              st2)\n 2. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 3. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 4. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "let ?s1' = \"State F1 H (Frame f (Suc pc) (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "have \"pc < length (body fd1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "using fd1_thms(2) step_op_ubx.hyps(2)"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  pc < length (body fd2')\n\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "by auto"], ["proof (state)\nthis:\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "hence nth_fd1: \"body fd1 ! pc = Inca.instr.IOpInl (\\<BB>\\<oo>\\<xx> opubx)\""], ["proof (prove)\nusing this:\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. body fd1 ! pc = Inca.instr.IOpInl (\\<BB>\\<oo>\\<xx> opubx)", "using rel_fundef_body_nth[OF fd1_thms(2)]"], ["proof (prove)\nusing this:\n  pc < length (body fd1)\n  ?pc < length (body fd1) \\<Longrightarrow>\n  body fd1 ! ?pc = norm_instr (body fd2 ! ?pc)\n\ngoal (1 subgoal):\n 1. body fd1 ! pc = Inca.instr.IOpInl (\\<BB>\\<oo>\\<xx> opubx)", "using \\<open>body fd2' ! pc = IOpUbx opubx\\<close>"], ["proof (prove)\nusing this:\n  pc < length (body fd1)\n  ?pc < length (body fd1) \\<Longrightarrow>\n  body fd1 ! ?pc = norm_instr (body fd2 ! ?pc)\n  body fd2' ! pc = IOpUbx opubx\n\ngoal (1 subgoal):\n 1. body fd1 ! pc = Inca.instr.IOpInl (\\<BB>\\<oo>\\<xx> opubx)", "by simp"], ["proof (state)\nthis:\n  body fd1 ! pc = Inca.instr.IOpInl (\\<BB>\\<oo>\\<xx> opubx)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "have \"\\<II>\\<ss>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) (take ar (map Subx.norm_unboxed \\<Sigma>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<II>\\<ss>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)\n     (take ar (map Subx.norm_unboxed \\<Sigma>2))", "using step_op_ubx"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IOpUbx opubx\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n\ngoal (1 subgoal):\n 1. \\<II>\\<ss>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)\n     (take ar (map Subx.norm_unboxed \\<Sigma>2))", "by (auto intro: Sinca.\\<II>\\<nn>\\<ll>_\\<II>\\<ss>\\<II>\\<nn>\\<ll> Subx.\\<UU>\\<bb>\\<xx>\\<OO>\\<pp>_to_\\<II>\\<nn>\\<ll> simp: take_map)"], ["proof (state)\nthis:\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)\n   (take ar (map Subx.norm_unboxed \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "hence \"?STEP ?s1'\""], ["proof (prove)\nusing this:\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)\n   (take ar (map Subx.norm_unboxed \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame f (Suc pc)\n         (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n        st1))", "unfolding norm_stack_def \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)\n   (take ar (map Subx.norm_unboxed \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. Sinca.step\n     (State F1 H (Frame f pc (map Subx.norm_unboxed \\<Sigma>2) # st1))\n     (State F1 H\n       (Frame f (Suc pc)\n         (Subx.norm_unboxed x # drop ar (map Subx.norm_unboxed \\<Sigma>2)) #\n        st1))", "using step_op_ubx fd1_thms(1) nth_fd1 \\<open>pc < length (body fd1)\\<close>"], ["proof (prove)\nusing this:\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)\n   (take ar (map Subx.norm_unboxed \\<Sigma>2))\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IOpUbx opubx\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n  Finca_get F1 f = Some fd1\n  body fd1 ! pc = Inca.instr.IOpInl (\\<BB>\\<oo>\\<xx> opubx)\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. Sinca.step\n     (State F1 H (Frame f pc (map Subx.norm_unboxed \\<Sigma>2) # st1))\n     (State F1 H\n       (Frame f (Suc pc)\n         (Subx.norm_unboxed x # drop ar (map Subx.norm_unboxed \\<Sigma>2)) #\n        st1))", "using Subx.\\<UU>\\<bb>\\<xx>\\<OO>\\<pp>_correct"], ["proof (prove)\nusing this:\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)\n   (take ar (map Subx.norm_unboxed \\<Sigma>2))\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IOpUbx opubx\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n  Finca_get F1 f = Some fd1\n  body fd1 ! pc = Inca.instr.IOpInl (\\<BB>\\<oo>\\<xx> opubx)\n  pc < length (body fd1)\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> ?opubx ?\\<Sigma> = Some ?z \\<Longrightarrow>\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> (\\<BB>\\<oo>\\<xx> ?opubx)\n   (map Subx.norm_unboxed ?\\<Sigma>) =\n  Subx.norm_unboxed ?z\n\ngoal (1 subgoal):\n 1. Sinca.step\n     (State F1 H (Frame f pc (map Subx.norm_unboxed \\<Sigma>2) # st1))\n     (State F1 H\n       (Frame f (Suc pc)\n         (Subx.norm_unboxed x # drop ar (map Subx.norm_unboxed \\<Sigma>2)) #\n        st1))", "by (auto intro!: Sinca.step_op_inl_hit simp: take_map)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc)\n       (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n      st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc)\n       (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n      st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H\n     (Frame f (Suc pc)\n       (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n      st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "using step_op_ubx rel_stacktraces_Cons rel_F1_F2 sp_F2 Subx.\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>_complete"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = IOpUbx opubx\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>2\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> ?opubx ?xs = Some ?y \\<Longrightarrow>\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> ?opubx =\n  (map typeof ?xs, typeof ?y)\n\ngoal (1 subgoal):\n 1. State F1 H\n     (Frame f (Suc pc)\n       (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n      st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "by (auto intro!: match.intros rel_stacktraces.intros\n              simp: take_Suc_conv_app_nth drop_norm_stack Let_def drop_map take_map min.absorb2)"], ["proof (state)\nthis:\n  State F1 H\n   (Frame f (Suc pc)\n     (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n    st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc)\n       (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n      st1))\n  State F1 H\n   (Frame f (Suc pc)\n     (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n    st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame f (Suc pc)\n       (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n      st1))\n  State F1 H\n   (Frame f (Suc pc)\n     (Subx.norm_unboxed x # drop ar (norm_stack \\<Sigma>2)) #\n    st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim>\n       State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) (x # drop ar \\<Sigma>2) # st2)\n\ngoal (4 subgoals):\n 1. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 2. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 2. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_cjump_true fd2' n x \\<Sigma>2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ICJump n\n  cast_Dyn x = Some \\<Sigma>2'\n  is_true \\<Sigma>2'\n  x # \\<Sigma>_ = \\<Sigma>2\n\ngoal (4 subgoals):\n 1. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 2. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ICJump n\n  cast_Dyn x = Some \\<Sigma>2'\n  is_true \\<Sigma>2'\n  x # \\<Sigma>_ = \\<Sigma>2", "have False"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ICJump n\n  cast_Dyn x = Some \\<Sigma>2'\n  is_true \\<Sigma>2'\n  x # \\<Sigma>_ = \\<Sigma>2\n\ngoal (1 subgoal):\n 1. False", "using F2_f sp_fundefs_get[OF sp_F2, unfolded sp_fundef_def, THEN Subx.sp_no_jump] nth_mem"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ICJump n\n  cast_Dyn x = Some \\<Sigma>2'\n  is_true \\<Sigma>2'\n  x # \\<Sigma>_ = \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  Fubx_get F2 ?f1 = Some ?fd1 \\<Longrightarrow>\n  \\<forall>x\\<in>set (body ?fd1). \\<not> is_jump x\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_true d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (Frame f n \\<Sigma> # st2)\n 2. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 3. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f n \\<Sigma>_ # st2)", "by simp"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f n \\<Sigma>_ # st2)\n\ngoal (3 subgoals):\n 1. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_cjump_false fd2' n x \\<Sigma>2')"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ICJump n\n  cast_Dyn x = Some \\<Sigma>2'\n  is_false \\<Sigma>2'\n  x # \\<Sigma>_ = \\<Sigma>2\n\ngoal (3 subgoals):\n 1. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ICJump n\n  cast_Dyn x = Some \\<Sigma>2'\n  is_false \\<Sigma>2'\n  x # \\<Sigma>_ = \\<Sigma>2", "have False"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ICJump n\n  cast_Dyn x = Some \\<Sigma>2'\n  is_false \\<Sigma>2'\n  x # \\<Sigma>_ = \\<Sigma>2\n\ngoal (1 subgoal):\n 1. False", "using F2_f sp_fundefs_get[OF sp_F2, unfolded sp_fundef_def, THEN Subx.sp_no_jump] nth_mem"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2'\n  pc < length (body fd2')\n  body fd2' ! pc = Ubx.instr.ICJump n\n  cast_Dyn x = Some \\<Sigma>2'\n  is_false \\<Sigma>2'\n  x # \\<Sigma>_ = \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  Fubx_get F2 ?f1 = Some ?fd1 \\<Longrightarrow>\n  \\<forall>x\\<in>set (body ?fd1). \\<not> is_jump x\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>fd n y d \\<Sigma>.\n       \\<lbrakk>Fubx_get F2 f = Some fd; pc < length (body fd);\n        body fd ! pc = Ubx.instr.ICJump n; cast_Dyn y = Some d; is_false d;\n        y # \\<Sigma> = \\<Sigma>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H (Frame f (Suc pc) \\<Sigma> # st2)\n 2. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>_ # st2)", "by simp"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (Frame f (Suc pc) \\<Sigma>_ # st2)\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_fun_call f' fd2' pc' g gd2 ar \\<Sigma>2' frame\\<^sub>g)"], ["proof (state)\nthis:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')", "have [simp]: \"f' = f\" \"pc' = pc\" \"fd2' = fd2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n\ngoal (1 subgoal):\n 1. f' = f &&& pc' = pc &&& fd2' = fd2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. f' = f &&& pc' = pc &&& fd2' = fd2", "by auto"], ["proof (state)\nthis:\n  f' = f\n  pc' = pc\n  fd2' = fd2\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain fd1 where \"Finca_get F1 f = Some fd1\" and rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain gd1 where \"Finca_get F1 g = Some gd1\" and rel_gd1_gd2: \"rel_fundef norm_eq gd1 gd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>gd1.\n        \\<lbrakk>Finca_get F1 g = Some gd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) gd1 gd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step_fun_call rel_fundefs_Some2[OF rel_F1_F2]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n  Fubx_get F2 ?x = Some ?y \\<Longrightarrow>\n  \\<exists>z.\n     Finca_get F1 ?x = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z ?y\n\ngoal (1 subgoal):\n 1. (\\<And>gd1.\n        \\<lbrakk>Finca_get F1 g = Some gd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) gd1 gd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Finca_get F1 g = Some gd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) gd1 gd2\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "have pc_in_range: \"pc < length (body fd1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "using \\<open>pc' < length (body fd2')\\<close> rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  pc' < length (body fd2')\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd1)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd1)\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd ar \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Fubx_get F2 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Ubx.instr.ICall g; Fubx_get F2 g = Some gd;\n        arity gd = ar; ar \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>2 = Frame fa pca \\<Sigma>;\n        list_all is_dyn_operand (take ar \\<Sigma>);\n        frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim>\n                            State F2 H\n                             (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)", "let ?s1' = \"State F1 H (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g 0 (take (arity gd1) \\<Sigma>1) #\n        Frame f pc \\<Sigma>1 # st1))", "using step_fun_call rel_stacktraces_Cons.hyps(2) pc_in_range"], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd1)\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g 0 (take (arity gd1) \\<Sigma>1) #\n        Frame f pc \\<Sigma>1 # st1))", "using \\<open>Finca_get F1 f = Some fd1\\<close> \\<open>Finca_get F1 g = Some gd1\\<close>"], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd1)\n  Finca_get F1 f = Some fd1\n  Finca_get F1 g = Some gd1\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g 0 (take (arity gd1) \\<Sigma>1) #\n        Frame f pc \\<Sigma>1 # st1))", "using rel_fundef_body_nth[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd1)\n  Finca_get F1 f = Some fd1\n  Finca_get F1 g = Some gd1\n  ?pc < length (body fd1) \\<Longrightarrow>\n  body fd1 ! ?pc = norm_instr (body fd2 ! ?pc)\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g 0 (take (arity gd1) \\<Sigma>1) #\n        Frame f pc \\<Sigma>1 # st1))", "using rel_fundef_arities[OF rel_gd1_gd2, symmetric]"], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd1)\n  Finca_get F1 f = Some fd1\n  Finca_get F1 g = Some gd1\n  ?pc < length (body fd1) \\<Longrightarrow>\n  body fd1 ! ?pc = norm_instr (body fd2 ! ?pc)\n  arity gd2 = arity gd1\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g 0 (take (arity gd1) \\<Sigma>1) #\n        Frame f pc \\<Sigma>1 # st1))", "by (auto intro!: Sinca.step_fun_call)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) #\n      Frame f pc \\<Sigma>1 # st1) \\<sim>\n    State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2)\n 2. sp_fundefs (Fubx_get F2)\n 3. rel_stacktraces (Fubx_get F2)\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\n     (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2) None", "show \"rel_fundefs (Finca_get F1) (Fubx_get F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2)", "using rel_F1_F2"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2)", "."], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n\ngoal (2 subgoals):\n 1. sp_fundefs (Fubx_get F2)\n 2. rel_stacktraces (Fubx_get F2)\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\n     (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2) None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundefs (Fubx_get F2)\n 2. rel_stacktraces (Fubx_get F2)\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\n     (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2) None", "show \"sp_fundefs (Fubx_get F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2)", "using sp_F2"], ["proof (prove)\nusing this:\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2)", "."], ["proof (state)\nthis:\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\n     (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2) None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\n     (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2) None", "show \"rel_stacktraces (Fubx_get F2)\n            (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\n            (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\n     (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2) None", "unfolding step_fun_call(9)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\n     (Frame g 0 (take ar \\<Sigma>2') # Frame f pc \\<Sigma>2 # st2) None", "proof (rule rel_stacktraces.intros(2))"], ["proof (state)\ngoal (5 subgoals):\n 1. rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n     (Frame f pc \\<Sigma>2 # st2) (Some g)\n 2. take (arity gd1) \\<Sigma>1 = norm_stack (take ar \\<Sigma>2')\n 3. Fubx_get F2 g = Some ?fd2.0\n 4. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (take ar \\<Sigma>2'))\n 5. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0 (take ar \\<Sigma>2')) None", "show \"rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1) (Frame f pc \\<Sigma>2 # st2) (Some g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n     (Frame f pc \\<Sigma>2 # st2) (Some g)", "using rel_st1_st2 F2_f \\<Sigma>1_def sp_prefix"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n     (Frame f pc \\<Sigma>2 # st2) (Some g)", "using step_fun_call"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n     (Frame f pc \\<Sigma>2 # st2) (Some g)", "by (auto intro!: rel_stacktraces.intros\n                  elim!: list.pred_mono_strong simp: is_valid_fun_call_def)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n   (Frame f pc \\<Sigma>2 # st2) (Some g)\n\ngoal (4 subgoals):\n 1. take (arity gd1) \\<Sigma>1 = norm_stack (take ar \\<Sigma>2')\n 2. Fubx_get F2 g = Some ?fd2.0\n 3. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (take ar \\<Sigma>2'))\n 4. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0 (take ar \\<Sigma>2')) None", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. take (arity gd1) \\<Sigma>1 = norm_stack (take ar \\<Sigma>2')\n 2. Fubx_get F2 g = Some ?fd2.0\n 3. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (take ar \\<Sigma>2'))\n 4. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0 (take ar \\<Sigma>2')) None", "show \"take (arity gd1) \\<Sigma>1 = norm_stack (take ar \\<Sigma>2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (arity gd1) \\<Sigma>1 = norm_stack (take ar \\<Sigma>2')", "using \\<Sigma>1_def rel_fundef_arities[OF rel_gd1_gd2]"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  arity gd1 = arity gd2\n\ngoal (1 subgoal):\n 1. take (arity gd1) \\<Sigma>1 = norm_stack (take ar \\<Sigma>2')", "using step_fun_call"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  arity gd1 = arity gd2\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n\ngoal (1 subgoal):\n 1. take (arity gd1) \\<Sigma>1 = norm_stack (take ar \\<Sigma>2')", "by (simp add: take_norm_stack)"], ["proof (state)\nthis:\n  take (arity gd1) \\<Sigma>1 = norm_stack (take ar \\<Sigma>2')\n\ngoal (3 subgoals):\n 1. Fubx_get F2 g = Some ?fd2.0\n 2. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (take ar \\<Sigma>2'))\n 3. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0 (take ar \\<Sigma>2')) None", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Fubx_get F2 g = Some ?fd2.0\n 2. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (take ar \\<Sigma>2'))\n 3. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0 (take ar \\<Sigma>2')) None", "show \"Fubx_get F2 g = Some gd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fubx_get F2 g = Some gd2", "using step_fun_call"], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n\ngoal (1 subgoal):\n 1. Fubx_get F2 g = Some gd2", "by simp"], ["proof (state)\nthis:\n  Fubx_get F2 g = Some gd2\n\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n    Ok (map typeof (take ar \\<Sigma>2'))\n 2. pred_option (is_valid_fun_call (Fubx_get F2) gd2 0 (take ar \\<Sigma>2'))\n     None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n    Ok (map typeof (take ar \\<Sigma>2'))\n 2. pred_option (is_valid_fun_call (Fubx_get F2) gd2 0 (take ar \\<Sigma>2'))\n     None", "show \"sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) = Ok (map typeof (take ar \\<Sigma>2'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n    Ok (map typeof (take ar \\<Sigma>2'))", "using step_fun_call"], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  pc' < length (body fd2')\n  body fd2' ! pc' = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  arity gd2 = ar\n  ar \\<le> length \\<Sigma>2'\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  list_all is_dyn_operand (take ar \\<Sigma>2')\n  frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>2')\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n    Ok (map typeof (take ar \\<Sigma>2'))", "by (auto elim: replicate_eq_map)"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n  Ok (map typeof (take ar \\<Sigma>2'))\n\ngoal (1 subgoal):\n 1. pred_option (is_valid_fun_call (Fubx_get F2) gd2 0 (take ar \\<Sigma>2'))\n     None", "qed simp_all"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2)\n   (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1)\n   (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2) None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State F1 H\n   (Frame g 0 (take (arity gd1) \\<Sigma>1) #\n    Frame f pc \\<Sigma>1 # st1) \\<sim>\n  State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1))\n  State F1 H\n   (Frame g 0 (take (arity gd1) \\<Sigma>1) #\n    Frame f pc \\<Sigma>1 # st1) \\<sim>\n  State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame g 0 (take (arity gd1) \\<Sigma>1) # Frame f pc \\<Sigma>1 # st1))\n  State F1 H\n   (Frame g 0 (take (arity gd1) \\<Sigma>1) #\n    Frame f pc \\<Sigma>1 # st1) \\<sim>\n  State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (frame\\<^sub>g # Frame f pc \\<Sigma>2 # st2)\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "case (step_fun_end f' fd2' \\<Sigma>2\\<^sub>g pc' \\<Sigma>2' frame\\<^sub>g g pc\\<^sub>g frame\\<^sub>g' st2')"], ["proof (state)\nthis:\n  Fubx_get F2 f' = Some fd2'\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n  pc' = length (body fd2')\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g)\n   (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)\n  frame\\<^sub>g # st2' = st2\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "then"], ["proof (chain)\npicking this:\n  Fubx_get F2 f' = Some fd2'\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n  pc' = length (body fd2')\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g)\n   (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)\n  frame\\<^sub>g # st2' = st2", "have [simp]: \"f' = f\" \"fd2' = fd2\" \"pc' = pc\" \"\\<Sigma>2' = \\<Sigma>2\""], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n  pc' = length (body fd2')\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g)\n   (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)\n  frame\\<^sub>g # st2' = st2\n\ngoal (1 subgoal):\n 1. (f' = f &&& fd2' = fd2) &&& pc' = pc &&& \\<Sigma>2' = \\<Sigma>2", "using F2_f"], ["proof (prove)\nusing this:\n  Fubx_get F2 f' = Some fd2'\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n  pc' = length (body fd2')\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g)\n   (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)\n  frame\\<^sub>g # st2' = st2\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. (f' = f &&& fd2' = fd2) &&& pc' = pc &&& \\<Sigma>2' = \\<Sigma>2", "by auto"], ["proof (state)\nthis:\n  f' = f\n  fd2' = fd2\n  pc' = pc\n  \\<Sigma>2' = \\<Sigma>2\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain fd1 where \"Finca_get F1 f = Some fd1\" and rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "obtain gd2 \\<Sigma>1\\<^sub>g st1' where\n        st1_def: \"st1 = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g # st1'\" and\n        \"\\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g\" and\n        rel_st1'_st2': \"rel_stacktraces (Fubx_get F2) st1' st2' (Some g)\" and\n        \"Fubx_get F2 g = Some gd2\" and\n        sp_prefix_gd2: \"Subx.sp (Fubx_get F2) (take pc\\<^sub>g (body gd2))\n          (replicate (arity gd2) None) = Ok (map typeof \\<Sigma>2\\<^sub>g)\" and\n        pc\\<^sub>g_in_range: \"pc\\<^sub>g < length (body gd2)\" and\n        \"body gd2 ! pc\\<^sub>g = Ubx.ICall f\" and\n        prefix_all_dyn_\\<Sigma>2\\<^sub>g: \"list_all is_dyn_operand (take (arity fd2) \\<Sigma>2\\<^sub>g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>1\\<^sub>g st1' gd2.\n        \\<lbrakk>st1 = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g # st1';\n         \\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g;\n         rel_stacktraces (Fubx_get F2) st1' st2' (Some g);\n         Fubx_get F2 g = Some gd2;\n         Subx.sp (Fubx_get F2) (take pc\\<^sub>g (body gd2))\n          (replicate (arity gd2) None) =\n         Ok (map typeof \\<Sigma>2\\<^sub>g);\n         pc\\<^sub>g < length (body gd2);\n         body gd2 ! pc\\<^sub>g = Ubx.instr.ICall f;\n         list_all is_dyn_operand\n          (take (arity fd2) \\<Sigma>2\\<^sub>g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_st1_st2 step_fun_end"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f' = Some fd2'\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n  pc' = length (body fd2')\n  Frame f pc \\<Sigma>2 = Frame f' pc' \\<Sigma>2'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g)\n   (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)\n  frame\\<^sub>g # st2' = st2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>1\\<^sub>g st1' gd2.\n        \\<lbrakk>st1 = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g # st1';\n         \\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g;\n         rel_stacktraces (Fubx_get F2) st1' st2' (Some g);\n         Fubx_get F2 g = Some gd2;\n         Subx.sp (Fubx_get F2) (take pc\\<^sub>g (body gd2))\n          (replicate (arity gd2) None) =\n         Ok (map typeof \\<Sigma>2\\<^sub>g);\n         pc\\<^sub>g < length (body gd2);\n         body gd2 ! pc\\<^sub>g = Ubx.instr.ICall f;\n         list_all is_dyn_operand\n          (take (arity fd2) \\<Sigma>2\\<^sub>g)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: rel_stacktraces.cases simp: is_valid_fun_call_def)"], ["proof (state)\nthis:\n  st1 = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g # st1'\n  \\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g\n  rel_stacktraces (Fubx_get F2) st1' st2' (Some g)\n  Fubx_get F2 g = Some gd2\n  Subx.sp (Fubx_get F2) (take pc\\<^sub>g (body gd2))\n   (replicate (arity gd2) None) =\n  Ok (map typeof \\<Sigma>2\\<^sub>g)\n  pc\\<^sub>g < length (body gd2)\n  body gd2 ! pc\\<^sub>g = Ubx.instr.ICall f\n  list_all is_dyn_operand (take (arity fd2) \\<Sigma>2\\<^sub>g)\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "have pc_at_end: \"pc = length (body fd1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc = length (body fd1)", "using \\<open>pc' = length (body fd2')\\<close>"], ["proof (prove)\nusing this:\n  pc' = length (body fd2')\n\ngoal (1 subgoal):\n 1. pc = length (body fd1)", "using rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  pc' = length (body fd2')\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc = length (body fd1)", "by simp"], ["proof (state)\nthis:\n  pc = length (body fd1)\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Fubx_get F2 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>2 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s1'.\n                            Sinca.step\n                             (State F1 H (Frame f pc \\<Sigma>1 # st1))\n                             s1' \\<and>\n                            s1' \\<sim> State F2 H (frame\\<^sub>f' # st)", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g' # st2')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g' # st2')", "let ?s1' = \"State F1 H (Frame g (Suc pc\\<^sub>g) (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) # st1')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g' # st2')", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n        st1'))", "using step_fun_end.hyps(2)"], ["proof (prove)\nusing this:\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n        st1'))", "using st1_def \\<open>\\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g\\<close>"], ["proof (prove)\nusing this:\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n  st1 = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g # st1'\n  \\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n        st1'))", "using \\<open>Finca_get F1 f = Some fd1\\<close> pc_at_end"], ["proof (prove)\nusing this:\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n  st1 = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g # st1'\n  \\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g\n  Finca_get F1 f = Some fd1\n  pc = length (body fd1)\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n        st1'))", "using rel_fundef_arities[OF rel_fd1_fd2, symmetric]"], ["proof (prove)\nusing this:\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n  st1 = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g # st1'\n  \\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g\n  Finca_get F1 f = Some fd1\n  pc = length (body fd1)\n  arity fd2 = arity fd1\n\ngoal (1 subgoal):\n 1. Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n     (State F1 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n        st1'))", "by (auto intro!: Sinca.step_fun_end)"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1'))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g' # st2')", "moreover"], ["proof (state)\nthis:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1'))\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g' # st2')", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1') \\<sim>\n    State F2 H (frame\\<^sub>g' # st2')", "using rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1') \\<sim>\n    State F2 H (frame\\<^sub>g' # st2')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1')\n     (frame\\<^sub>g' # st2') None", "show \"rel_stacktraces (Fubx_get F2)\n            (Frame g (Suc pc\\<^sub>g) (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) # st1')\n            (frame\\<^sub>g' # st2') None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1')\n     (frame\\<^sub>g' # st2') None", "unfolding step_fun_end(6)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1')\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g) #\n      st2')\n     None", "using rel_st1'_st2'"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1' st2' (Some g)\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1')\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g) #\n      st2')\n     None", "proof (rule rel_stacktraces.rel_stacktraces_Cons)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g =\n    norm_stack (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)\n 2. Fubx_get F2 g = Some ?fd2.0\n 3. sp_fundef (Fubx_get F2) ?fd2.0 (take (Suc pc\\<^sub>g) (body ?fd2.0)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 4. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "show \"\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g = norm_stack (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g =\n    norm_stack (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)", "using \\<Sigma>1_def \\<open>\\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g\\<close>"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  \\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g\n\ngoal (1 subgoal):\n 1. \\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g =\n    norm_stack (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)", "using rel_fundef_arities[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  \\<Sigma>1\\<^sub>g = norm_stack \\<Sigma>2\\<^sub>g\n  arity fd1 = arity fd2\n\ngoal (1 subgoal):\n 1. \\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g =\n    norm_stack (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)", "by (simp add: norm_stack_append drop_norm_stack)"], ["proof (state)\nthis:\n  \\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g =\n  norm_stack (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g)\n\ngoal (3 subgoals):\n 1. Fubx_get F2 g = Some ?fd2.0\n 2. sp_fundef (Fubx_get F2) ?fd2.0 (take (Suc pc\\<^sub>g) (body ?fd2.0)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 3. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Fubx_get F2 g = Some ?fd2.0\n 2. sp_fundef (Fubx_get F2) ?fd2.0 (take (Suc pc\\<^sub>g) (body ?fd2.0)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 3. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "show \"Fubx_get F2 g = Some gd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fubx_get F2 g = Some gd2", "using \\<open>Fubx_get F2 g = Some gd2\\<close>"], ["proof (prove)\nusing this:\n  Fubx_get F2 g = Some gd2\n\ngoal (1 subgoal):\n 1. Fubx_get F2 g = Some gd2", "."], ["proof (state)\nthis:\n  Fubx_get F2 g = Some gd2\n\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "have \"arity fd2 \\<le> length \\<Sigma>2\\<^sub>g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity fd2 \\<le> length \\<Sigma>2\\<^sub>g", "using step_fun_end.hyps(2)"], ["proof (prove)\nusing this:\n  arity fd2' \\<le> length \\<Sigma>2\\<^sub>g\n\ngoal (1 subgoal):\n 1. arity fd2 \\<le> length \\<Sigma>2\\<^sub>g", "by simp"], ["proof (state)\nthis:\n  arity fd2 \\<le> length \\<Sigma>2\\<^sub>g\n\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "moreover"], ["proof (state)\nthis:\n  arity fd2 \\<le> length \\<Sigma>2\\<^sub>g\n\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "have \"list_all (\\<lambda>x. x = None) (take (arity fd2) (map typeof \\<Sigma>2\\<^sub>g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x = None)\n     (take (arity fd2) (map typeof \\<Sigma>2\\<^sub>g))", "using prefix_all_dyn_\\<Sigma>2\\<^sub>g"], ["proof (prove)\nusing this:\n  list_all is_dyn_operand (take (arity fd2) \\<Sigma>2\\<^sub>g)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x = None)\n     (take (arity fd2) (map typeof \\<Sigma>2\\<^sub>g))", "by (auto elim!: list.pred_mono_strong simp: take_map list.pred_map is_dyn_operand_def)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = None)\n   (take (arity fd2) (map typeof \\<Sigma>2\\<^sub>g))\n\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = None)\n   (take (arity fd2) (map typeof \\<Sigma>2\\<^sub>g))\n\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "have \"map typeof \\<Sigma>2 = [None]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map typeof \\<Sigma>2 = [None]", "using \\<open>pc' = length (body fd2')\\<close> sp_prefix"], ["proof (prove)\nusing this:\n  pc' = length (body fd2')\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. map typeof \\<Sigma>2 = [None]", "using sp_fundefs_get[OF sp_F2 F2_f]"], ["proof (prove)\nusing this:\n  pc' = length (body fd2')\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  sp_fundef (Fubx_get F2) fd2 (body fd2) = Ok [None]\n\ngoal (1 subgoal):\n 1. map typeof \\<Sigma>2 = [None]", "by simp"], ["proof (state)\nthis:\n  map typeof \\<Sigma>2 = [None]\n\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "ultimately"], ["proof (chain)\npicking this:\n  arity fd2 \\<le> length \\<Sigma>2\\<^sub>g\n  list_all (\\<lambda>x. x = None)\n   (take (arity fd2) (map typeof \\<Sigma>2\\<^sub>g))\n  map typeof \\<Sigma>2 = [None]", "show \"sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n              Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\""], ["proof (prove)\nusing this:\n  arity fd2 \\<le> length \\<Sigma>2\\<^sub>g\n  list_all (\\<lambda>x. x = None)\n   (take (arity fd2) (map typeof \\<Sigma>2\\<^sub>g))\n  map typeof \\<Sigma>2 = [None]\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))", "using sp_prefix_gd2"], ["proof (prove)\nusing this:\n  arity fd2 \\<le> length \\<Sigma>2\\<^sub>g\n  list_all (\\<lambda>x. x = None)\n   (take (arity fd2) (map typeof \\<Sigma>2\\<^sub>g))\n  map typeof \\<Sigma>2 = [None]\n  Subx.sp (Fubx_get F2) (take pc\\<^sub>g (body gd2))\n   (replicate (arity gd2) None) =\n  Ok (map typeof \\<Sigma>2\\<^sub>g)\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))", "using \\<open>body gd2 ! pc\\<^sub>g = Ubx.ICall f\\<close> F2_f"], ["proof (prove)\nusing this:\n  arity fd2 \\<le> length \\<Sigma>2\\<^sub>g\n  list_all (\\<lambda>x. x = None)\n   (take (arity fd2) (map typeof \\<Sigma>2\\<^sub>g))\n  map typeof \\<Sigma>2 = [None]\n  Subx.sp (Fubx_get F2) (take pc\\<^sub>g (body gd2))\n   (replicate (arity gd2) None) =\n  Ok (map typeof \\<Sigma>2\\<^sub>g)\n  body gd2 ! pc\\<^sub>g = Ubx.instr.ICall f\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n    Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))", "by (auto dest: list_all_eq_const_imp_replicate\n                  simp: take_Suc_conv_app_nth[OF pc\\<^sub>g_in_range] Let_def drop_map)"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get F2) gd2 (take (Suc pc\\<^sub>g) (body gd2)) =\n  Ok (map typeof (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 (Suc pc\\<^sub>g)\n       (\\<Sigma>2' @ drop (arity fd2') \\<Sigma>2\\<^sub>g))\n     None", "qed simp"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2)\n   (Frame g (Suc pc\\<^sub>g)\n     (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n    st1')\n   (frame\\<^sub>g' # st2') None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State F1 H\n   (Frame g (Suc pc\\<^sub>g)\n     (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n    st1') \\<sim>\n  State F2 H (frame\\<^sub>g' # st2')\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g' # st2')", "ultimately"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1'))\n  State F1 H\n   (Frame g (Suc pc\\<^sub>g)\n     (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n    st1') \\<sim>\n  State F2 H (frame\\<^sub>g' # st2')", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1))\n   (State F1 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n      st1'))\n  State F1 H\n   (Frame g (Suc pc\\<^sub>g)\n     (\\<Sigma>1 @ drop (arity fd1) \\<Sigma>1\\<^sub>g) #\n    st1') \\<sim>\n  State F2 H (frame\\<^sub>g' # st2')\n\ngoal (1 subgoal):\n 1. \\<exists>s1'.\n       Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n       s1' \\<sim> State F2 H (frame\\<^sub>g' # st2')", "by blast"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (frame\\<^sub>g' # st2')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> State F2 H (frame\\<^sub>g' # st2')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'.\n     Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1' \\<and>\n     s1' \\<sim> s2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s1'. Sinca.step (State F1 H st1) s1' \\<and> s1' \\<sim> s2'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma match_final_backward:\n  \"s1 \\<sim> s2 \\<Longrightarrow> Subx.final s2 \\<Longrightarrow> Sinca.final s1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<sim> s2; Subx.final s2\\<rbrakk>\n    \\<Longrightarrow> Sinca.final s1", "proof (induction s1 s2 rule: match.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.final (State F2 H st2)\\<rbrakk>\n       \\<Longrightarrow> Sinca.final (State F1 H st1)", "case (1 F1 F2 st1 st2 H)"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Subx.final (State F2 H st2)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.final (State F2 H st2)\\<rbrakk>\n       \\<Longrightarrow> Sinca.final (State F1 H st1)", "obtain f fd2 pc \\<Sigma>2 where\n    st2_def: \"st2 = [Frame f pc \\<Sigma>2]\" and \"Fubx_get F2 f = Some fd2\" and \"pc = length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f pc \\<Sigma>2 fd2.\n        \\<lbrakk>st2 = [Frame f pc \\<Sigma>2]; Fubx_get F2 f = Some fd2;\n         pc = length (body fd2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Subx.final (State F2 H st2)\\<close>"], ["proof (prove)\nusing this:\n  Subx.final (State F2 H st2)\n\ngoal (1 subgoal):\n 1. (\\<And>f pc \\<Sigma>2 fd2.\n        \\<lbrakk>st2 = [Frame f pc \\<Sigma>2]; Fubx_get F2 f = Some fd2;\n         pc = length (body fd2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: Subx.final.cases)"], ["proof (state)\nthis:\n  st2 = [Frame f pc \\<Sigma>2]\n  Fubx_get F2 f = Some fd2\n  pc = length (body fd2)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.final (State F2 H st2)\\<rbrakk>\n       \\<Longrightarrow> Sinca.final (State F1 H st1)", "obtain \\<Sigma>1 where st1_def: \"st1 = [Frame f pc \\<Sigma>1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>1.\n        st1 = [Frame f pc \\<Sigma>1] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>rel_stacktraces (Fubx_get F2) st1 st2 None\\<close>"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>1.\n        st1 = [Frame f pc \\<Sigma>1] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding st2_def"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 [Frame f pc \\<Sigma>2] None\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>1.\n        st1 = [Frame f pc \\<Sigma>1] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: rel_stacktraces.cases)"], ["proof (state)\nthis:\n  st1 = [Frame f pc \\<Sigma>1]\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.final (State F2 H st2)\\<rbrakk>\n       \\<Longrightarrow> Sinca.final (State F1 H st1)", "obtain fd1 where \"Finca_get F1 f = Some fd1\" and rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>rel_fundefs (Finca_get F1) (Fubx_get F2)\\<close> \\<open>Fubx_get F2 f = Some fd2\\<close>"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some2"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  Fubx_get F2 f = Some fd2\n  \\<lbrakk>rel_fundefs ?f ?g; ?g ?x = Some ?y\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z.\n                       ?f ?x = Some z \\<and>\n                       rel_fundef (\\<lambda>x y. x = norm_instr y) z ?y\n\ngoal (1 subgoal):\n 1. (\\<And>fd1.\n        \\<lbrakk>Finca_get F1 f = Some fd1;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.final (State F2 H st2)\\<rbrakk>\n       \\<Longrightarrow> Sinca.final (State F1 H st1)", "have \"length (body fd1) = length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (body fd1) = length (body fd2)", "using rel_fd1_fd2"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. length (body fd1) = length (body fd2)", "by simp"], ["proof (state)\nthis:\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Subx.final (State F2 H st2)\\<rbrakk>\n       \\<Longrightarrow> Sinca.final (State F1 H st1)", "thus ?case"], ["proof (prove)\nusing this:\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. Sinca.final (State F1 H st1)", "unfolding st1_def"], ["proof (prove)\nusing this:\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. Sinca.final (State F1 H [Frame f pc \\<Sigma>1])", "using \\<open>Finca_get F1 f = Some fd1\\<close> \\<open>pc = length (body fd2)\\<close>"], ["proof (prove)\nusing this:\n  length (body fd1) = length (body fd2)\n  Finca_get F1 f = Some fd1\n  pc = length (body fd2)\n\ngoal (1 subgoal):\n 1. Sinca.final (State F1 H [Frame f pc \\<Sigma>1])", "by (auto intro: Sinca.final.intros)"], ["proof (state)\nthis:\n  Sinca.final (State F1 H st1)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale inca_to_ubx_simulation:\n  backward_simulation Sinca.step Subx.step Sinca.final Subx.final \"\\<lambda>_ _. False\" \"\\<lambda>_. match\""], ["proof (prove)\ngoal (1 subgoal):\n 1. backward_simulation Sinca.step Subx.step Sinca.final Subx.final\n     (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>))", "using match_final_backward backward_lockstep_simulation\n   lockstep_to_plus_backward_simulation[of match Subx.step Sinca.step]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 \\<sim> ?s2.0; Subx.final ?s2.0\\<rbrakk>\n  \\<Longrightarrow> Sinca.final ?s1.0\n  \\<lbrakk>Subx.step ?s2.0 ?s2'; ?s1.0 \\<sim> ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'.\n                       Sinca.step ?s1.0 s1' \\<and> s1' \\<sim> ?s2'\n  \\<lbrakk>\\<And>s1 s2 s2'.\n              \\<lbrakk>s1 \\<sim> s2; Subx.step s2 s2'\\<rbrakk>\n              \\<Longrightarrow> \\<exists>s1'.\n                                   Sinca.step s1 s1' \\<and> s1' \\<sim> s2';\n   ?s1.0 \\<sim> ?s2.0; Subx.step ?s2.0 ?s2'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s1'.\n                       Sinca.step\\<^sup>+\\<^sup>+ ?s1.0 s1' \\<and>\n                       s1' \\<sim> ?s2'\n\ngoal (1 subgoal):\n 1. backward_simulation Sinca.step Subx.step Sinca.final Subx.final\n     (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>))", "by unfold_locales auto"], ["", "section \\<open>Forward simulation\\<close>"], ["", "lemma traverse_cast_Dyn_eq_norm_stack:\n  assumes \"list_all (\\<lambda>x. x = None) (map typeof xs)\"\n  shows \"traverse cast_Dyn xs = Some (norm_stack xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse cast_Dyn xs = Some (norm_stack xs)", "using assms"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = None) (map typeof xs)\n\ngoal (1 subgoal):\n 1. traverse cast_Dyn xs = Some (norm_stack xs)", "proof (induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_all (\\<lambda>x. x = None) (map typeof []) \\<Longrightarrow>\n    traverse cast_Dyn [] = Some (norm_stack [])\n 2. \\<And>a xs.\n       \\<lbrakk>list_all (\\<lambda>x. x = None)\n                 (map typeof xs) \\<Longrightarrow>\n                traverse cast_Dyn xs = Some (norm_stack xs);\n        list_all (\\<lambda>x. x = None) (map typeof (a # xs))\\<rbrakk>\n       \\<Longrightarrow> traverse cast_Dyn (a # xs) =\n                         Some (norm_stack (a # xs))", "case Nil"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = None) (map typeof [])\n\ngoal (2 subgoals):\n 1. list_all (\\<lambda>x. x = None) (map typeof []) \\<Longrightarrow>\n    traverse cast_Dyn [] = Some (norm_stack [])\n 2. \\<And>a xs.\n       \\<lbrakk>list_all (\\<lambda>x. x = None)\n                 (map typeof xs) \\<Longrightarrow>\n                traverse cast_Dyn xs = Some (norm_stack xs);\n        list_all (\\<lambda>x. x = None) (map typeof (a # xs))\\<rbrakk>\n       \\<Longrightarrow> traverse cast_Dyn (a # xs) =\n                         Some (norm_stack (a # xs))", "then"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>x. x = None) (map typeof [])", "show ?case"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = None) (map typeof [])\n\ngoal (1 subgoal):\n 1. traverse cast_Dyn [] = Some (norm_stack [])", "by simp"], ["proof (state)\nthis:\n  traverse cast_Dyn [] = Some (norm_stack [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>list_all (\\<lambda>x. x = None)\n                 (map typeof xs) \\<Longrightarrow>\n                traverse cast_Dyn xs = Some (norm_stack xs);\n        list_all (\\<lambda>x. x = None) (map typeof (a # xs))\\<rbrakk>\n       \\<Longrightarrow> traverse cast_Dyn (a # xs) =\n                         Some (norm_stack (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>list_all (\\<lambda>x. x = None)\n                 (map typeof xs) \\<Longrightarrow>\n                traverse cast_Dyn xs = Some (norm_stack xs);\n        list_all (\\<lambda>x. x = None) (map typeof (a # xs))\\<rbrakk>\n       \\<Longrightarrow> traverse cast_Dyn (a # xs) =\n                         Some (norm_stack (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = None) (map typeof xs) \\<Longrightarrow>\n  traverse cast_Dyn xs = Some (norm_stack xs)\n  list_all (\\<lambda>x. x = None) (map typeof (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>list_all (\\<lambda>x. x = None)\n                 (map typeof xs) \\<Longrightarrow>\n                traverse cast_Dyn xs = Some (norm_stack xs);\n        list_all (\\<lambda>x. x = None) (map typeof (a # xs))\\<rbrakk>\n       \\<Longrightarrow> traverse cast_Dyn (a # xs) =\n                         Some (norm_stack (a # xs))", "from Cons.prems"], ["proof (chain)\npicking this:\n  list_all (\\<lambda>x. x = None) (map typeof (x # xs))", "have\n    typeof_x: \"typeof x = None\" and\n    typeof_xs: \"list_all (\\<lambda>x. x = None) (map typeof xs)\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = None) (map typeof (x # xs))\n\ngoal (1 subgoal):\n 1. typeof x = None &&& list_all (\\<lambda>x. x = None) (map typeof xs)", "by simp_all"], ["proof (state)\nthis:\n  typeof x = None\n  list_all (\\<lambda>x. x = None) (map typeof xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>list_all (\\<lambda>x. x = None)\n                 (map typeof xs) \\<Longrightarrow>\n                traverse cast_Dyn xs = Some (norm_stack xs);\n        list_all (\\<lambda>x. x = None) (map typeof (a # xs))\\<rbrakk>\n       \\<Longrightarrow> traverse cast_Dyn (a # xs) =\n                         Some (norm_stack (a # xs))", "obtain x' where \"x = OpDyn x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'. x = OpDyn x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using typeof_unboxed_inversion(1)[OF typeof_x]"], ["proof (prove)\nusing this:\n  \\<exists>d. x = OpDyn d\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = OpDyn x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = OpDyn x'\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>list_all (\\<lambda>x. x = None)\n                 (map typeof xs) \\<Longrightarrow>\n                traverse cast_Dyn xs = Some (norm_stack xs);\n        list_all (\\<lambda>x. x = None) (map typeof (a # xs))\\<rbrakk>\n       \\<Longrightarrow> traverse cast_Dyn (a # xs) =\n                         Some (norm_stack (a # xs))", "then"], ["proof (chain)\npicking this:\n  x = OpDyn x'", "show ?case"], ["proof (prove)\nusing this:\n  x = OpDyn x'\n\ngoal (1 subgoal):\n 1. traverse cast_Dyn (x # xs) = Some (norm_stack (x # xs))", "using Cons.IH[OF typeof_xs]"], ["proof (prove)\nusing this:\n  x = OpDyn x'\n  traverse cast_Dyn xs = Some (norm_stack xs)\n\ngoal (1 subgoal):\n 1. traverse cast_Dyn (x # xs) = Some (norm_stack (x # xs))", "by simp"], ["proof (state)\nthis:\n  traverse cast_Dyn (x # xs) = Some (norm_stack (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma forward_lockstep_simulation:\n  assumes \"Sinca.step s1 s1'\" and \"s1 \\<sim> s2\"\n  shows \"\\<exists>s2'. Subx.step s2 s2' \\<and> s1' \\<sim> s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'. Subx.step s2 s2' \\<and> s1' \\<sim> s2'", "using assms(2,1)"], ["proof (prove)\nusing this:\n  s1 \\<sim> s2\n  Sinca.step s1 s1'\n\ngoal (1 subgoal):\n 1. \\<exists>s2'. Subx.step s2 s2' \\<and> s1' \\<sim> s2'", "proof (induction s1 s2 rule: match.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.step (State F1 H st1) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step (State F2 H st2) s2' \\<and>\n                            s1' \\<sim> s2'", "case (1 F1 F2 st1 st2 H)"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Sinca.step (State F1 H st1) s1'\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.step (State F1 H st1) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step (State F2 H st2) s2' \\<and>\n                            s1' \\<sim> s2'", "have rel_F1_F2: \"rel_fundefs (Finca_get F1) (Fubx_get F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2)", "using 1"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Sinca.step (State F1 H st1) s1'\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1) (Fubx_get F2)", "by simp"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.step (State F1 H st1) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step (State F2 H st2) s2' \\<and>\n                            s1' \\<sim> s2'", "have sp_F2: \"sp_fundefs (Fubx_get F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2)", "using 1"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Sinca.step (State F1 H st1) s1'\n\ngoal (1 subgoal):\n 1. sp_fundefs (Fubx_get F2)", "by simp"], ["proof (state)\nthis:\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.step (State F1 H st1) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step (State F2 H st2) s2' \\<and>\n                            s1' \\<sim> s2'", "note rel_fundefs_rewrite_both' =\n    rel_fundef_rewrite_both[THEN rel_fundefs_rewrite_both[OF rel_F1_F2]]"], ["proof (state)\nthis:\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.1 ?fd2.1;\n   norm_instr ?y1 = ?x1\\<rbrakk>\n  \\<Longrightarrow> rel_fundefs\n                     (Finca_get\n                       (Finca_add F1 ?f\n                         (rewrite_fundef_body ?fd1.1 ?pc1 ?x1)))\n                     (Fubx_get\n                       (Fubx_add F2 ?f\n                         (rewrite_fundef_body ?fd2.1 ?pc1 ?y1)))\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.step (State F1 H st1) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step (State F2 H st2) s2' \\<and>\n                            s1' \\<sim> s2'", "from \"1\"(3,4)"], ["proof (chain)\npicking this:\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Sinca.step (State F1 H st1) s1'", "show ?case"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Sinca.step (State F1 H st1) s1'\n\ngoal (1 subgoal):\n 1. \\<exists>s2'. Subx.step (State F2 H st2) s2' \\<and> s1' \\<sim> s2'", "proof (induction st1 st2 \"None :: 'fun option\" rule: rel_stacktraces.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. Sinca.step (State F1 H []) s1' \\<Longrightarrow>\n    \\<exists>s2'. Subx.step (State F2 H []) s2' \\<and> s1' \\<sim> s2'\n 2. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "case rel_stacktraces_Nil"], ["proof (state)\nthis:\n  Sinca.step (State F1 H []) s1'\n\ngoal (2 subgoals):\n 1. Sinca.step (State F1 H []) s1' \\<Longrightarrow>\n    \\<exists>s2'. Subx.step (State F2 H []) s2' \\<and> s1' \\<sim> s2'\n 2. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "hence False"], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H []) s1'\n\ngoal (1 subgoal):\n 1. False", "by (auto elim: Sinca.step.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. Sinca.step (State F1 H []) s1' \\<Longrightarrow>\n    \\<exists>s2'. Subx.step (State F2 H []) s2' \\<and> s1' \\<sim> s2'\n 2. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>s2'. Subx.step (State F2 H []) s2' \\<and> s1' \\<sim> s2'", "by simp"], ["proof (state)\nthis:\n  \\<exists>s2'. Subx.step (State F2 H []) s2' \\<and> s1' \\<sim> s2'\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "case (rel_stacktraces_Cons st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 pc)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1'\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "have F2_f: \"Fubx_get F2 f = Some fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fubx_get F2 f = Some fd2", "using rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1'\n\ngoal (1 subgoal):\n 1. Fubx_get F2 f = Some fd2", "by simp"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "have rel_st1_st2: \"rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) st1 st2 (Some f)", "using rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1'\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) st1 st2 (Some f)", "by simp"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "have sp_fundef_prefix: \"sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) = Ok (map typeof \\<Sigma>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n    Ok (map typeof \\<Sigma>2)", "using rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1'\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n    Ok (map typeof \\<Sigma>2)", "by simp"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "have \\<Sigma>1_def: \"\\<Sigma>1 = norm_stack \\<Sigma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sigma>1 = norm_stack \\<Sigma>2", "using rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1'\n\ngoal (1 subgoal):\n 1. \\<Sigma>1 = norm_stack \\<Sigma>2", "by simp"], ["proof (state)\nthis:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "note sp_fundef_def[simp]"], ["proof (state)\nthis:\n  sp_fundef ?F ?fd ?xs \\<equiv> Subx.sp ?F ?xs (replicate (arity ?fd) None)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "note sp_prefix = sp_fundef_prefix[unfolded sp_fundef_def]"], ["proof (state)\nthis:\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "note ex_F1_f = rel_fundefs_Some2[OF rel_F1_F2 F2_f]"], ["proof (state)\nthis:\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "note sp_fundef_full = sp_fundefs_get[OF sp_F2 \\<open>Fubx_get F2 f = Some fd2\\<close>]"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get F2) fd2 (body fd2) = Ok [None]\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "note sp_full = sp_fundef_full[unfolded sp_fundef_def]"], ["proof (state)\nthis:\n  Subx.sp (Fubx_get F2) (body fd2) (replicate (arity fd2) None) = Ok [None]\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "hence sp_sufix: \"Subx.sp (Fubx_get F2)\n      (body fd2 ! pc # drop (Suc pc) (body fd2)) (map typeof \\<Sigma>2) = Ok [None]\"\n      if pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\nusing this:\n  Subx.sp (Fubx_get F2) (body fd2) (replicate (arity fd2) None) = Ok [None]\n\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get F2) (body fd2 ! pc # drop (Suc pc) (body fd2))\n     (map typeof \\<Sigma>2) =\n    Ok [None]", "unfolding Cons_nth_drop_Suc[OF pc_in_range]"], ["proof (prove)\nusing this:\n  Subx.sp (Fubx_get F2) (body fd2) (replicate (arity fd2) None) = Ok [None]\n\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get F2) (drop pc (body fd2)) (map typeof \\<Sigma>2) =\n    Ok [None]", "unfolding Subx.sp_eq_bind_take_drop[of _ \"body fd2\" _ pc]"], ["proof (prove)\nusing this:\n  Subx.sp (Fubx_get F2) (take pc (body fd2))\n   (replicate (arity fd2) None) \\<bind>\n  Subx.sp (Fubx_get F2) (drop pc (body fd2)) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get F2) (drop pc (body fd2)) (map typeof \\<Sigma>2) =\n    Ok [None]", "unfolding sp_prefix"], ["proof (prove)\nusing this:\n  Ok (map typeof \\<Sigma>2) \\<bind>\n  Subx.sp (Fubx_get F2) (drop pc (body fd2)) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. Subx.sp (Fubx_get F2) (drop pc (body fd2)) (map typeof \\<Sigma>2) =\n    Ok [None]", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2) \\<Longrightarrow>\n  Subx.sp (Fubx_get F2) (body fd2 ! pc # drop (Suc pc) (body fd2))\n   (map typeof \\<Sigma>2) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. \\<And>st1 st2 f \\<Sigma>1 \\<Sigma>2 fd2 n.\n       \\<lbrakk>rel_stacktraces (Fubx_get F2) st1 st2 (Some f);\n        \\<Sigma>1 = norm_stack \\<Sigma>2; Fubx_get F2 f = Some fd2;\n        sp_fundef (Fubx_get F2) fd2 (take n (body fd2)) =\n        Ok (map typeof \\<Sigma>2);\n        pred_option (is_valid_fun_call (Fubx_get F2) fd2 n \\<Sigma>2) None;\n        Sinca.step (State F1 H (Frame f n \\<Sigma>1 # st1)) s1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f n \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            s1' \\<sim> s2'", "from rel_stacktraces_Cons.prems(1)"], ["proof (chain)\npicking this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1'", "show ?case"], ["proof (prove)\nusing this:\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1'\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       s1' \\<sim> s2'", "proof (induction \"State F1 H (Frame f pc \\<Sigma>1 # st1)\" s1' rule: Sinca.step.induct)"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>fd d.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPush d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 4. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 10. \\<And>fd n d \\<Sigma>.\n        \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n         body fd ! pc = Inca.instr.ICJump n; is_false d;\n         d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "case (step_push fd1 d)"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPush d\n\ngoal (12 subgoals):\n 1. \\<And>fd d.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPush d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 4. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 10. \\<And>fd n d \\<Sigma>.\n        \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n         body fd ! pc = Inca.instr.ICJump n; is_false d;\n         d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPush d\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPush d\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (12 subgoals):\n 1. \\<And>fd d.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPush d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 4. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 10. \\<And>fd n d \\<Sigma>.\n        \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n         body fd ! pc = Inca.instr.ICJump n; is_false d;\n         d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_push rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPush d\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (12 subgoals):\n 1. \\<And>fd d.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPush d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 4. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 10. \\<And>fd n d \\<Sigma>.\n        \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n         body fd ! pc = Inca.instr.ICJump n; is_false d;\n         d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_push rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPush d\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (12 subgoals):\n 1. \\<And>fd d.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPush d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 4. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 10. \\<And>fd n d \\<Sigma>.\n        \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n         body fd ! pc = Inca.instr.ICJump n; is_false d;\n         d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim> s2'", "using step_push norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPush d\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim> s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case (IPush d2)"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.IPush d2\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = Ubx.instr.IPush d2", "have d_def: \"d = d2\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IPush d2\n\ngoal (1 subgoal):\n 1. d = d2", "using norm_instr_nth_body step_push.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IPush d2\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IPush d\n\ngoal (1 subgoal):\n 1. d = d2", "by auto"], ["proof (state)\nthis:\n  d = d2\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?s2' = \"State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2))", "using IPush step_push d_def F2_f pc_in_range"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IPush d2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPush d\n  d = d2\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2))", "by (auto intro: Subx.step_push)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2)", "using IPush d_def sp_prefix take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  body fd2 ! pc = Ubx.instr.IPush d2\n  d = d2\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2)", "by (auto intro!: match.intros rel_stacktraces.intros)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2)\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d2 # \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 4. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 4. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "case (IPushUbx1 n)"], ["proof (state)\nthis:\n  body fd2 ! pc = IPushUbx1 n\n\ngoal (12 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 4. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = IPushUbx1 n", "have d_def: \"d = box_ubx1 n\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = IPushUbx1 n\n\ngoal (1 subgoal):\n 1. d = box_ubx1 n", "using norm_instr_nth_body step_push.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = IPushUbx1 n\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IPush d\n\ngoal (1 subgoal):\n 1. d = box_ubx1 n", "by auto"], ["proof (state)\nthis:\n  d = box_ubx1 n\n\ngoal (12 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 4. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "let ?s2' = \"State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 4. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2))", "using IPushUbx1 step_push d_def F2_f pc_in_range"], ["proof (prove)\nusing this:\n  body fd2 ! pc = IPushUbx1 n\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPush d\n  d = box_ubx1 n\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2))", "by (auto intro: Subx.step_push_ubx1)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2))\n\ngoal (12 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 4. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2))\n\ngoal (12 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 4. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "using IPushUbx1 d_def sp_prefix take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  body fd2 ! pc = IPushUbx1 n\n  d = box_ubx1 n\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "by (auto intro!: match.intros rel_stacktraces.intros)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n\ngoal (12 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 4. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (11 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 3. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 3. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "case (IPushUbx2 b)"], ["proof (state)\nthis:\n  body fd2 ! pc = IPushUbx2 b\n\ngoal (11 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 3. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = IPushUbx2 b", "have d_def: \"d = box_ubx2 b\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = IPushUbx2 b\n\ngoal (1 subgoal):\n 1. d = box_ubx2 b", "using norm_instr_nth_body step_push.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = IPushUbx2 b\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IPush d\n\ngoal (1 subgoal):\n 1. d = box_ubx2 b", "by auto"], ["proof (state)\nthis:\n  d = box_ubx2 b\n\ngoal (11 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 3. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "let ?s2' = \"State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\""], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 3. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2))", "using IPushUbx2 step_push d_def F2_f pc_in_range"], ["proof (prove)\nusing this:\n  body fd2 ! pc = IPushUbx2 b\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPush d\n  d = box_ubx2 b\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2))", "by (auto intro: Subx.step_push_ubx2)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2))\n\ngoal (11 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 3. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2))\n\ngoal (11 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 3. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "using IPushUbx2 d_def sp_prefix take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  body fd2 ! pc = IPushUbx2 b\n  d = box_ubx2 b\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "by (auto intro!: match.intros rel_stacktraces.intros)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n\ngoal (11 subgoals):\n 1. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 2. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 3. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (10 subgoals):\n 1. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPush d;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                         s2'\n 2. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 3. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 4. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 5. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 6. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 7. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 8. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 9. \\<And>x12.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPush d;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim>\n                            s2'\n 10. \\<And>x13.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPush d;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICall x13\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (d # \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (11 subgoals):\n 1. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 10. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n         frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (frame\\<^sub>g #\n                               Frame f pc \\<Sigma>1 # st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 10. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n         frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (frame\\<^sub>g #\n                               Frame f pc \\<Sigma>1 # st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "case (step_pop fd1 x \\<Sigma>1')"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPop\n  x # \\<Sigma>1' = \\<Sigma>1\n\ngoal (11 subgoals):\n 1. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 10. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n         frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (frame\\<^sub>g #\n                               Frame f pc \\<Sigma>1 # st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPop\n  x # \\<Sigma>1' = \\<Sigma>1\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPop\n  x # \\<Sigma>1' = \\<Sigma>1\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (11 subgoals):\n 1. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 10. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n         frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (frame\\<^sub>g #\n                               Frame f pc \\<Sigma>1 # st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_pop rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPop\n  x # \\<Sigma>1' = \\<Sigma>1\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (11 subgoals):\n 1. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 10. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n         frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (frame\\<^sub>g #\n                               Frame f pc \\<Sigma>1 # st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_pop rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPop\n  x # \\<Sigma>1' = \\<Sigma>1\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (11 subgoals):\n 1. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 10. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n         frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (frame\\<^sub>g #\n                               Frame f pc \\<Sigma>1 # st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "obtain x' \\<Sigma>2' where \\<Sigma>2_def: \"\\<Sigma>2 = x' # \\<Sigma>2'\" and \"\\<Sigma>1' = norm_stack \\<Sigma>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x' \\<Sigma>2'.\n        \\<lbrakk>\\<Sigma>2 = x' # \\<Sigma>2';\n         \\<Sigma>1' = norm_stack \\<Sigma>2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step_pop \\<open>\\<Sigma>1 = norm_stack \\<Sigma>2\\<close> norm_stack_def"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPop\n  x # \\<Sigma>1' = \\<Sigma>1\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  norm_stack ?\\<Sigma> \\<equiv> map Subx.norm_unboxed ?\\<Sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>x' \\<Sigma>2'.\n        \\<lbrakk>\\<Sigma>2 = x' # \\<Sigma>2';\n         \\<Sigma>1' = norm_stack \\<Sigma>2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<Sigma>2 = x' # \\<Sigma>2'\n  \\<Sigma>1' = norm_stack \\<Sigma>2'\n\ngoal (11 subgoals):\n 1. \\<And>fd d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IPop; d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 3. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 9. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 10. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n        \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n         body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>;\n         Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n         frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (frame\\<^sub>g #\n                               Frame f pc \\<Sigma>1 # st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'", "using step_pop norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPop\n  x # \\<Sigma>1' = \\<Sigma>1\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case IPop"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.IPop\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?s2' = \"State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2))", "using IPop step_pop F2_f pc_in_range \\<Sigma>2_def"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IPop\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IPop\n  x # \\<Sigma>1' = \\<Sigma>1\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n  \\<Sigma>2 = x' # \\<Sigma>2'\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2))", "by (auto intro: Subx.step_pop)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f \\<open>\\<Sigma>1' = norm_stack \\<Sigma>2'\\<close>"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1' = norm_stack \\<Sigma>2'\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "using IPop sp_prefix take_Suc_conv_app_nth[OF pc_in_range] \\<Sigma>2_def"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1' = norm_stack \\<Sigma>2'\n  body fd2 ! pc = Ubx.instr.IPop\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n  \\<Sigma>2 = x' # \\<Sigma>2'\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "by (auto intro!: match.intros rel_stacktraces.intros)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2))\n  State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2))\n  State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IPop; x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'\n\ngoal (10 subgoals):\n 1. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 9. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 9. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_load fd1 var i d \\<Sigma>1')"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n\ngoal (10 subgoals):\n 1. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 9. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (10 subgoals):\n 1. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 9. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_load rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (10 subgoals):\n 1. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 9. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_load rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (10 subgoals):\n 1. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 9. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "obtain i' \\<Sigma>2' where\n        \\<Sigma>2_def: \"\\<Sigma>2 = i' # \\<Sigma>2'\" and norm_i': \"Subx.norm_unboxed i' = i\" and \"norm_stack \\<Sigma>2' = \\<Sigma>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i' \\<Sigma>2'.\n        \\<lbrakk>\\<Sigma>2 = i' # \\<Sigma>2'; Subx.norm_unboxed i' = i;\n         norm_stack \\<Sigma>2' = \\<Sigma>1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step_load \\<Sigma>1_def norm_stack_def"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  norm_stack ?\\<Sigma> \\<equiv> map Subx.norm_unboxed ?\\<Sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>i' \\<Sigma>2'.\n        \\<lbrakk>\\<Sigma>2 = i' # \\<Sigma>2'; Subx.norm_unboxed i' = i;\n         norm_stack \\<Sigma>2' = \\<Sigma>1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<Sigma>2 = i' # \\<Sigma>2'\n  Subx.norm_unboxed i' = i\n  norm_stack \\<Sigma>2' = \\<Sigma>1'\n\ngoal (10 subgoals):\n 1. \\<And>fd x y d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ILoad x; heap_get H (x, y) = Some d;\n        y # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>) # st1) \\<sim>\n                            s2'\n 2. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 8. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 9. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 10. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f\n        fa pc\\<^sub>f frame\\<^sub>f' st.\n        \\<lbrakk>Finca_get F1 g = Some gd;\n         arity gd \\<le> length \\<Sigma>\\<^sub>f;\n         pc\\<^sub>g = length (body gd);\n         Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n         frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n         frame\\<^sub>f' =\n         Frame fa (Suc pc\\<^sub>f)\n          (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n         frame\\<^sub>f # st = st1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "using step_load norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case (ILoad var')"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.ILoad var'\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = Ubx.instr.ILoad var'", "have [simp]: \"var' = var\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.ILoad var'\n\ngoal (1 subgoal):\n 1. var' = var", "using norm_instr_nth_body step_load.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.ILoad var'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.ILoad var\n\ngoal (1 subgoal):\n 1. var' = var", "by auto"], ["proof (state)\nthis:\n  var' = var\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?s2' = \"State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"i' = OpDyn i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' = OpDyn i", "using sp_sufix[OF pc_in_range, unfolded \\<Sigma>2_def ILoad, simplified]"], ["proof (prove)\nusing this:\n  Subx.sp_instr (Fubx_get F2) (Ubx.instr.ILoad var)\n   (typeof i' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. i' = OpDyn i", "using norm_i'"], ["proof (prove)\nusing this:\n  Subx.sp_instr (Fubx_get F2) (Ubx.instr.ILoad var)\n   (typeof i' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n  Subx.norm_unboxed i' = i\n\ngoal (1 subgoal):\n 1. i' = OpDyn i", "by (cases i'; simp)"], ["proof (state)\nthis:\n  i' = OpDyn i\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "hence \"?STEP ?s2'\""], ["proof (prove)\nusing this:\n  i' = OpDyn i\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "using ILoad step_load F2_f pc_in_range"], ["proof (prove)\nusing this:\n  i' = OpDyn i\n  body fd2 ! pc = Ubx.instr.ILoad var'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "by (auto intro!: Subx.step_load simp: \\<Sigma>2_def)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "using ILoad sp_prefix take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  body fd2 ! pc = Ubx.instr.ILoad var'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "by (auto intro!: match.intros rel_stacktraces.intros\n              simp: \\<open>norm_stack \\<Sigma>2' = \\<Sigma>1'\\<close> \\<open>i' = OpDyn i\\<close> \\<Sigma>2_def)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "case (ILoadUbx \\<tau> var')"], ["proof (state)\nthis:\n  body fd2 ! pc = ILoadUbx \\<tau> var'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = ILoadUbx \\<tau> var'", "have [simp]: \"var' = var\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = ILoadUbx \\<tau> var'\n\ngoal (1 subgoal):\n 1. var' = var", "using norm_instr_nth_body step_load.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = ILoadUbx \\<tau> var'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.ILoad var\n\ngoal (1 subgoal):\n 1. var' = var", "by auto"], ["proof (state)\nthis:\n  var' = var\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have [simp]: \"i' = OpDyn i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' = OpDyn i", "using sp_sufix[OF pc_in_range, unfolded \\<Sigma>2_def ILoadUbx, simplified]"], ["proof (prove)\nusing this:\n  Subx.sp_instr (Fubx_get F2) (ILoadUbx \\<tau> var)\n   (typeof i' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. i' = OpDyn i", "using norm_i'"], ["proof (prove)\nusing this:\n  Subx.sp_instr (Fubx_get F2) (ILoadUbx \\<tau> var)\n   (typeof i' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n  Subx.norm_unboxed i' = i\n\ngoal (1 subgoal):\n 1. i' = OpDyn i", "by (cases i'; simp)"], ["proof (state)\nthis:\n  i' = OpDyn i\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "proof (cases \"Subx.unbox \\<tau> d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Subx.unbox \\<tau> d = None \\<Longrightarrow>\n    \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n 2. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "case None"], ["proof (state)\nthis:\n  Subx.unbox \\<tau> d = None\n\ngoal (2 subgoals):\n 1. Subx.unbox \\<tau> d = None \\<Longrightarrow>\n    \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n 2. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "let ?F2' = \"Fubx_add F2 f (Subx.generalize_fundef fd2)\""], ["proof (state)\ngoal (2 subgoals):\n 1. Subx.unbox \\<tau> d = None \\<Longrightarrow>\n    \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n 2. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "let ?frame = \"Frame f (Suc pc) (OpDyn d # \\<Sigma>2')\""], ["proof (state)\ngoal (2 subgoals):\n 1. Subx.unbox \\<tau> d = None \\<Longrightarrow>\n    \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n 2. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "let ?s2' = \"State ?F2' H (Subx.box_stack f (?frame # st2))\""], ["proof (state)\ngoal (2 subgoals):\n 1. Subx.unbox \\<tau> d = None \\<Longrightarrow>\n    \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n 2. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n       (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)))", "using None ILoadUbx"], ["proof (prove)\nusing this:\n  Subx.unbox \\<tau> d = None\n  body fd2 ! pc = ILoadUbx \\<tau> var'\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n       (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)))", "using step_load pc_in_range F2_f"], ["proof (prove)\nusing this:\n  Subx.unbox \\<tau> d = None\n  body fd2 ! pc = ILoadUbx \\<tau> var'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n  pc < length (body fd2)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n       (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)))", "by (auto intro!: Subx.step_load_ubx_miss\n                simp add: \\<Sigma>2_def\n                simp del: Subx.box_stack_Cons)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)))\n\ngoal (2 subgoals):\n 1. Subx.unbox \\<tau> d = None \\<Longrightarrow>\n    \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n 2. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)))\n\ngoal (2 subgoals):\n 1. Subx.unbox \\<tau> d = None \\<Longrightarrow>\n    \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n 2. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "using rel_fundefs_generalize[OF rel_F1_F2 F2_f]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1)\n   (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "using sp_fundefs_generalize[OF sp_F2 F2_f]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1)\n   (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n  sp_fundefs (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "using sp_fundef_prefix ILoadUbx"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1)\n   (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n  sp_fundefs (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  body fd2 ! pc = ILoadUbx \\<tau> var'\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "using pc_in_range"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1)\n   (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n  sp_fundefs (Fubx_get (Fubx_add F2 f (Subx.generalize_fundef fd2)))\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  body fd2 ! pc = ILoadUbx \\<tau> var'\n  pc < length (body fd2)\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "by (auto intro!: match.intros rel_stacktraces_generalize[OF rel_st1_st2 F2_f]\n                simp: \\<Sigma>2_def \\<open>norm_stack \\<Sigma>2' = \\<Sigma>1'\\<close>)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n  State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n   (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n\ngoal (2 subgoals):\n 1. Subx.unbox \\<tau> d = None \\<Longrightarrow>\n    \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n 2. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n  State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n   (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n     (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2)))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n  State (Fubx_add F2 f (Subx.generalize_fundef fd2)) H\n   (Subx.box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>2') # st2))\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "case (Some blob)"], ["proof (state)\nthis:\n  Subx.unbox \\<tau> d = Some blob\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "let ?s2' = \"State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2))", "using Some ILoadUbx step_load F2_f pc_in_range"], ["proof (prove)\nusing this:\n  Subx.unbox \\<tau> d = Some blob\n  body fd2 ! pc = ILoadUbx \\<tau> var'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ILoad var\n  heap_get H (var, i) = Some d\n  i # \\<Sigma>1' = \\<Sigma>1\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2))", "by (auto intro: Subx.step_load_ubx_hit simp: \\<Sigma>2_def)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "using Some ILoadUbx sp_prefix take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Subx.unbox \\<tau> d = Some blob\n  body fd2 ! pc = ILoadUbx \\<tau> var'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "by (auto intro!: match.intros rel_stacktraces.intros\n                simp: \\<open>norm_stack \\<Sigma>2' = \\<Sigma>1'\\<close> \\<Sigma>2_def)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       Subx.unbox \\<tau> d = Some a \\<Longrightarrow>\n       \\<exists>s2'.\n          Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n          State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2))\n  State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (blob # \\<Sigma>2') # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n     i # \\<Sigma>1' = \\<Sigma>1; norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim>\n                         s2'\n 5. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n        i # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (d # \\<Sigma>1') #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ILoad var; heap_get H (var, i) = Some d;\n         i # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (d # \\<Sigma>1') #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (d # \\<Sigma>1') # st1) \\<sim> s2'\n\ngoal (9 subgoals):\n 1. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 8. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 8. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_store fd1 var i x H' \\<Sigma>1')"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IStore var\n  heap_add H (var, i) x = H'\n  i # x # \\<Sigma>1' = \\<Sigma>1\n\ngoal (9 subgoals):\n 1. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 8. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IStore var\n  heap_add H (var, i) x = H'\n  i # x # \\<Sigma>1' = \\<Sigma>1\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IStore var\n  heap_add H (var, i) x = H'\n  i # x # \\<Sigma>1' = \\<Sigma>1\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (9 subgoals):\n 1. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 8. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_store rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IStore var\n  heap_add H (var, i) x = H'\n  i # x # \\<Sigma>1' = \\<Sigma>1\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (9 subgoals):\n 1. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 8. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_store rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IStore var\n  heap_add H (var, i) x = H'\n  i # x # \\<Sigma>1' = \\<Sigma>1\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (9 subgoals):\n 1. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 8. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "obtain i' x' \\<Sigma>2' where\n        \\<Sigma>2_def: \"\\<Sigma>2 = i' # x' # \\<Sigma>2'\" and\n        norm_i': \"Subx.norm_unboxed i' = i\" and\n        norm_x': \"Subx.norm_unboxed x' = x\" and\n        \"norm_stack \\<Sigma>2' = \\<Sigma>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i' x' \\<Sigma>2'.\n        \\<lbrakk>\\<Sigma>2 = i' # x' # \\<Sigma>2'; Subx.norm_unboxed i' = i;\n         Subx.norm_unboxed x' = x;\n         norm_stack \\<Sigma>2' = \\<Sigma>1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step_store \\<Sigma>1_def norm_stack_def"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IStore var\n  heap_add H (var, i) x = H'\n  i # x # \\<Sigma>1' = \\<Sigma>1\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  norm_stack ?\\<Sigma> \\<equiv> map Subx.norm_unboxed ?\\<Sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>i' x' \\<Sigma>2'.\n        \\<lbrakk>\\<Sigma>2 = i' # x' # \\<Sigma>2'; Subx.norm_unboxed i' = i;\n         Subx.norm_unboxed x' = x;\n         norm_stack \\<Sigma>2' = \\<Sigma>1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<Sigma>2 = i' # x' # \\<Sigma>2'\n  Subx.norm_unboxed i' = i\n  Subx.norm_unboxed x' = x\n  norm_stack \\<Sigma>2' = \\<Sigma>1'\n\ngoal (9 subgoals):\n 1. \\<And>fd x y d H' \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IStore x; heap_add H (x, y) d = H';\n        y # d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 7. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 8. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 9. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'", "using step_store norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IStore var\n  heap_add H (var, i) x = H'\n  i # x # \\<Sigma>1' = \\<Sigma>1\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case (IStore var')"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.IStore var'\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = Ubx.instr.IStore var'", "have [simp]: \"var' = var\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IStore var'\n\ngoal (1 subgoal):\n 1. var' = var", "using norm_instr_nth_body step_store.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IStore var'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IStore var\n\ngoal (1 subgoal):\n 1. var' = var", "by auto"], ["proof (state)\nthis:\n  var' = var\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "note sp_sufix' = sp_sufix[OF pc_in_range, unfolded \\<Sigma>2_def IStore, simplified]"], ["proof (state)\nthis:\n  Subx.sp_instr (Fubx_get F2) (Ubx.instr.IStore var)\n   (typeof i' # typeof x' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have [simp]: \"i' = OpDyn i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' = OpDyn i", "using norm_i' sp_sufix'"], ["proof (prove)\nusing this:\n  Subx.norm_unboxed i' = i\n  Subx.sp_instr (Fubx_get F2) (Ubx.instr.IStore var)\n   (typeof i' # typeof x' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. i' = OpDyn i", "by (cases i'; simp)"], ["proof (state)\nthis:\n  i' = OpDyn i\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have [simp]: \"x' = OpDyn x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' = OpDyn x", "using norm_x' sp_sufix'"], ["proof (prove)\nusing this:\n  Subx.norm_unboxed x' = x\n  Subx.sp_instr (Fubx_get F2) (Ubx.instr.IStore var)\n   (typeof i' # typeof x' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. x' = OpDyn x", "by (cases x'; simp)"], ["proof (state)\nthis:\n  x' = OpDyn x\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?s2' = \"State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))", "using IStore \\<Sigma>2_def pc_in_range F2_f"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IStore var'\n  \\<Sigma>2 = i' # x' # \\<Sigma>2'\n  pc < length (body fd2)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))", "by (auto intro: Subx.step_store)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f \\<Sigma>2_def"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>2 = i' # x' # \\<Sigma>2'\n\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "using \\<open>norm_stack \\<Sigma>2' = \\<Sigma>1'\\<close> \\<open>heap_add H (var, i) x = H'\\<close>"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>2 = i' # x' # \\<Sigma>2'\n  norm_stack \\<Sigma>2' = \\<Sigma>1'\n  heap_add H (var, i) x = H'\n\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "using IStore sp_prefix take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>2 = i' # x' # \\<Sigma>2'\n  norm_stack \\<Sigma>2' = \\<Sigma>1'\n  heap_add H (var, i) x = H'\n  body fd2 ! pc = Ubx.instr.IStore var'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "by (auto intro!: match.intros rel_stacktraces.intros)"], ["proof (state)\nthis:\n  State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n  State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))\n  State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n  State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))\n  State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n  State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "case (IStoreUbx \\<tau> var')"], ["proof (state)\nthis:\n  body fd2 ! pc = IStoreUbx \\<tau> var'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = IStoreUbx \\<tau> var'", "have [simp]: \"var' = var\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = IStoreUbx \\<tau> var'\n\ngoal (1 subgoal):\n 1. var' = var", "using norm_instr_nth_body step_store.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = IStoreUbx \\<tau> var'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IStore var\n\ngoal (1 subgoal):\n 1. var' = var", "by auto"], ["proof (state)\nthis:\n  var' = var\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "note sp_sufix' = sp_sufix[OF pc_in_range, unfolded \\<Sigma>2_def IStoreUbx, simplified]"], ["proof (state)\nthis:\n  Subx.sp_instr (Fubx_get F2) (IStoreUbx \\<tau> var)\n   (typeof i' # typeof x' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have [simp]: \"i' = OpDyn i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' = OpDyn i", "using norm_i' sp_sufix'"], ["proof (prove)\nusing this:\n  Subx.norm_unboxed i' = i\n  Subx.sp_instr (Fubx_get F2) (IStoreUbx \\<tau> var)\n   (typeof i' # typeof x' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. i' = OpDyn i", "by (cases i'; simp)"], ["proof (state)\nthis:\n  i' = OpDyn i\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have typeof_x'[simp]: \"typeof x' = Some \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. typeof x' = Some \\<tau>", "using sp_sufix'"], ["proof (prove)\nusing this:\n  Subx.sp_instr (Fubx_get F2) (IStoreUbx \\<tau> var)\n   (typeof i' # typeof x' # map typeof \\<Sigma>2') \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. typeof x' = Some \\<tau>", "apply (auto simp add: Result.bind_eq_Ok_conv elim!: Subx.sp_instr.elims)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y \\<tau>\\<^sub>2.\n       \\<lbrakk>Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) y =\n                Ok [None];\n        Ok y =\n        (if \\<tau> = \\<tau>\\<^sub>2 then Ok (map typeof \\<Sigma>2')\n         else Error ());\n        typeof x' = Some \\<tau>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\\<^sub>2 = \\<tau>", "by (metis result.simps(4))"], ["proof (state)\nthis:\n  typeof x' = Some \\<tau>\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "let ?s2' = \"State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))", "unfolding \\<Sigma>2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc (i' # x' # \\<Sigma>2') # st2))\n     (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))", "using F2_f pc_in_range IStoreUbx"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n  body fd2 ! pc = IStoreUbx \\<tau> var'\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc (i' # x' # \\<Sigma>2') # st2))\n     (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))", "using Subx.typeof_and_norm_unboxed_imp_cast_and_box[OF typeof_x' norm_x']"], ["proof (prove)\nusing this:\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n  body fd2 ! pc = IStoreUbx \\<tau> var'\n  Subx.cast_and_box \\<tau> x' = Some x\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc (i' # x' # \\<Sigma>2') # st2))\n     (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))", "by (auto intro!: Subx.step_store_ubx)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f \\<Sigma>2_def"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>2 = i' # x' # \\<Sigma>2'\n\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "using \\<open>norm_stack \\<Sigma>2' = \\<Sigma>1'\\<close> \\<open>heap_add H (var, i) x = H'\\<close>"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>2 = i' # x' # \\<Sigma>2'\n  norm_stack \\<Sigma>2' = \\<Sigma>1'\n  heap_add H (var, i) x = H'\n\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "using IStoreUbx sp_prefix take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>2 = i' # x' # \\<Sigma>2'\n  norm_stack \\<Sigma>2' = \\<Sigma>1'\n  heap_add H (var, i) x = H'\n  body fd2 ! pc = IStoreUbx \\<tau> var'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n    State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "by (auto intro!: match.intros rel_stacktraces.intros)"], ["proof (state)\nthis:\n  State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n  State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))\n  State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n  State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2))\n  State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n  State F2 (heap_add H (var, i) x) (Frame f (Suc pc) \\<Sigma>2' # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n     i # x # \\<Sigma>1' = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H'\n                          (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 7. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 8. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 9. \\<And>x11.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n        i # x # \\<Sigma>1' = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IOpUbx x11\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H'\n                             (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IStore var; heap_add H (var, i) x = H';\n         i # x # \\<Sigma>1' = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H'\n                              (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H' (Frame f (Suc pc) \\<Sigma>1' # st1) \\<sim> s2'\n\ngoal (8 subgoals):\n 1. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 7. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 7. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_op fd1 op ar x)"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None\n  \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\n\ngoal (8 subgoals):\n 1. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 7. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None\n  \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None\n  \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (8 subgoals):\n 1. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 7. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_op rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None\n  \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (8 subgoals):\n 1. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 7. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_op rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None\n  \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (8 subgoals):\n 1. \\<And>fd op ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 6. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 7. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 8. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "using step_op norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None\n  \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n     \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n         \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case (IOp op')"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.IOp op'\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n     \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n         \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = Ubx.instr.IOp op'", "have \"op' = op\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOp op'\n\ngoal (1 subgoal):\n 1. op' = op", "using norm_instr_nth_body step_op.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOp op'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IOp op\n\ngoal (1 subgoal):\n 1. op' = op", "by auto"], ["proof (state)\nthis:\n  op' = op\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n     \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n         \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "hence \"ar \\<le> length \\<Sigma>2\" and\n          all_arg_Dyn: \"list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\""], ["proof (prove)\nusing this:\n  op' = op\n\ngoal (1 subgoal):\n 1. ar \\<le> length \\<Sigma>2 &&&\n    list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))", "using IOp step_op sp_sufix[OF pc_in_range]"], ["proof (prove)\nusing this:\n  op' = op\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None\n  \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\n  Subx.sp (Fubx_get F2) (body fd2 ! pc # drop (Suc pc) (body fd2))\n   (map typeof \\<Sigma>2) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. ar \\<le> length \\<Sigma>2 &&&\n    list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))", "by (auto simp: take_map)"], ["proof (state)\nthis:\n  ar \\<le> length \\<Sigma>2\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n     \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n         \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?s2' = \"State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n     \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n         \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using IOp step_op \\<open>op' = op\\<close> \\<Sigma>1_def pc_in_range F2_f"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None\n  \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\n  op' = op\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd2)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using traverse_cast_Dyn_eq_norm_stack[OF all_arg_Dyn]"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None\n  \\<OO>\\<pp> op (take ar \\<Sigma>1) = x\n  op' = op\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd2)\n  Fubx_get F2 f = Some fd2\n  traverse cast_Dyn (take ar \\<Sigma>2) =\n  Some (norm_stack (take ar \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "by (auto intro!: Subx.step_op simp: take_norm_stack)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n     \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n         \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n     \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n         \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using IOp sp_prefix take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using arg_cong[OF \\<Sigma>1_def, of \"drop ar\"] \\<open>ar \\<le> length \\<Sigma>2\\<close>"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n  drop ar \\<Sigma>1 = drop ar (norm_stack \\<Sigma>2)\n  ar \\<le> length \\<Sigma>2\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using \\<open>op' = op\\<close> all_arg_Dyn \\<Sigma>1_def \\<open>\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\\<close>"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n  drop ar \\<Sigma>1 = drop ar (norm_stack \\<Sigma>2)\n  ar \\<le> length \\<Sigma>2\n  op' = op\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "by (auto intro!: match.intros rel_stacktraces.intros\n              dest: list_all_eq_const_imp_replicate\n              simp: drop_norm_stack[symmetric] Let_def take_map drop_map)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n     \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n         \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n     \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n        \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = None;\n         \\<OO>\\<pp> op (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (7 subgoals):\n 1. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 6. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 6. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_op_inl fd1 op ar opinl x F1')"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n\ngoal (7 subgoals):\n 1. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 6. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (7 subgoals):\n 1. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 6. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_op_inl rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (7 subgoals):\n 1. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 6. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_op_inl rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (7 subgoals):\n 1. \\<And>fd op ar opinl x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc (Inca.instr.IOpInl opinl)) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 5. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 6. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 7. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "using step_op_inl norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case (IOp op')"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.IOp op'\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = Ubx.instr.IOp op'", "have \"op' = op\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOp op'\n\ngoal (1 subgoal):\n 1. op' = op", "using norm_instr_nth_body step_op_inl.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOp op'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IOp op\n\ngoal (1 subgoal):\n 1. op' = op", "by simp"], ["proof (state)\nthis:\n  op' = op\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "hence \"ar \\<le> length \\<Sigma>2\" and\n          all_arg_Dyn: \"list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\""], ["proof (prove)\nusing this:\n  op' = op\n\ngoal (1 subgoal):\n 1. ar \\<le> length \\<Sigma>2 &&&\n    list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))", "using IOp step_op_inl sp_sufix[OF pc_in_range]"], ["proof (prove)\nusing this:\n  op' = op\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n  Subx.sp (Fubx_get F2) (body fd2 ! pc # drop (Suc pc) (body fd2))\n   (map typeof \\<Sigma>2) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. ar \\<le> length \\<Sigma>2 &&&\n    list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))", "by (auto simp: take_map)"], ["proof (state)\nthis:\n  ar \\<le> length \\<Sigma>2\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?fd2' = \"rewrite_fundef_body fd2 pc (Ubx.IOpInl opinl)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?F2' = \"Fubx_add F2 f ?fd2'\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?frame = \"Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?s2' = \"State ?F2' H (?frame # st2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State\n       (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl)))\n       H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using IOp step_op_inl \\<open>op' = op\\<close>"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n  op' = op\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State\n       (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl)))\n       H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using \\<Sigma>1_def pc_in_range \\<open>Fubx_get F2 f = Some fd2\\<close>"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n  op' = op\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd2)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State\n       (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl)))\n       H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using all_arg_Dyn take_norm_stack traverse_cast_Dyn_eq_norm_stack"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOp op'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n  op' = op\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd2)\n  Fubx_get F2 f = Some fd2\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n  take ?n (norm_stack ?xs) = norm_stack (take ?n ?xs)\n  list_all (\\<lambda>x. x = None) (map typeof ?xs) \\<Longrightarrow>\n  traverse cast_Dyn ?xs = Some (norm_stack ?xs)\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State\n       (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl)))\n       H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "by (auto intro!: Subx.step_op_inl)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))) H\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))) H\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))) H\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. rel_fundefs (Finca_get F1')\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n 2. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n 3. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "show \"rel_fundefs (Finca_get F1') (Fubx_get ?F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1')\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))", "using step_op_inl rel_fd1_fd2"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOp op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n  F1'\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1')\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))", "by (auto intro: rel_fundefs_rewrite_both')"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1')\n   (Fubx_get\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n\ngoal (2 subgoals):\n 1. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n 2. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n 2. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "have \"arity fd2 = arity ?fd2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity fd2 = arity (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))", "by simp"], ["proof (state)\nthis:\n  arity fd2 = arity (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))\n\ngoal (2 subgoals):\n 1. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n 2. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "hence \"all_same_arities (Fubx_get F2) (Fubx_get ?F2')\""], ["proof (prove)\nusing this:\n  arity fd2 = arity (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))\n\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F2)\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))", "using all_same_arities_add[OF F2_f]"], ["proof (prove)\nusing this:\n  arity fd2 = arity (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))\n  arity fd2 = arity ?fd2.0 \\<Longrightarrow>\n  all_same_arities (Fubx_get F2) (Fubx_get (Fubx_add F2 f ?fd2.0))\n\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F2)\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))", "by simp"], ["proof (state)\nthis:\n  all_same_arities (Fubx_get F2)\n   (Fubx_get\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n\ngoal (2 subgoals):\n 1. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n 2. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "thus \"sp_fundefs (Fubx_get ?F2')\""], ["proof (prove)\nusing this:\n  all_same_arities (Fubx_get F2)\n   (Fubx_get\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n\ngoal (1 subgoal):\n 1. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))", "apply (auto intro!: sp_fundefs_add[OF sp_F2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F2)\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOpInl opinl)))) \\<Longrightarrow>\n    Subx.sp (Fubx_get F2) (rewrite (body fd2) pc (Ubx.instr.IOpInl opinl))\n     (replicate (arity fd2) None) =\n    Ok [None]", "apply (rule Subx.sp_rewrite_eq_Ok[OF pc_in_range _ sp_full])"], ["proof (prove)\ngoal (1 subgoal):\n 1. all_same_arities (Fubx_get F2)\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOpInl opinl)))) \\<Longrightarrow>\n    \\<forall>\\<Sigma>.\n       Subx.sp_instr (Fubx_get F2) (body fd2 ! pc) \\<Sigma> =\n       Subx.sp_instr (Fubx_get F2) (Ubx.instr.IOpInl opinl) \\<Sigma>", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Sigma>.\n       all_same_arities (Fubx_get F2)\n        (Fubx_get\n          (Fubx_add F2 f\n            (rewrite_fundef_body fd2 pc\n              (Ubx.instr.IOpInl opinl)))) \\<Longrightarrow>\n       Subx.sp_instr (Fubx_get F2) (body fd2 ! pc) \\<Sigma> =\n       Subx.sp_instr (Fubx_get F2) (Ubx.instr.IOpInl opinl) \\<Sigma>", "unfolding IOp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Sigma>.\n       all_same_arities (Fubx_get F2)\n        (Fubx_get\n          (Fubx_add F2 f\n            (rewrite_fundef_body fd2 pc\n              (Ubx.instr.IOpInl opinl)))) \\<Longrightarrow>\n       Subx.sp_instr (Fubx_get F2) (Ubx.instr.IOp op') \\<Sigma> =\n       Subx.sp_instr (Fubx_get F2) (Ubx.instr.IOpInl opinl) \\<Sigma>", "apply (rule Subx.sp_instr_op)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Sigma>.\n       all_same_arities (Fubx_get F2)\n        (Fubx_get\n          (Fubx_add F2 f\n            (rewrite_fundef_body fd2 pc\n              (Ubx.instr.IOpInl opinl)))) \\<Longrightarrow>\n       \\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl = op'", "using Sinca.\\<II>\\<nn>\\<ll>_invertible \\<open>op' = op\\<close> step_op_inl.hyps(6)"], ["proof (prove)\nusing this:\n  \\<II>\\<nn>\\<ll> ?op ?xs = Some ?opinl \\<Longrightarrow>\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> ?opinl = ?op\n  op' = op\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n\ngoal (1 subgoal):\n 1. \\<And>\\<Sigma>.\n       all_same_arities (Fubx_get F2)\n        (Fubx_get\n          (Fubx_add F2 f\n            (rewrite_fundef_body fd2 pc\n              (Ubx.instr.IOpInl opinl)))) \\<Longrightarrow>\n       \\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl = op'", "by blast"], ["proof (state)\nthis:\n  sp_fundefs\n   (Fubx_get\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "have \"rel_stacktraces (Fubx_get F2)\n            (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) (?frame # st2) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using rel_st1_st2 sp_prefix F2_f"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using IOp take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOp op'\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using arg_cong[OF \\<Sigma>1_def, of \"drop ar\"] \\<open>ar \\<le> length \\<Sigma>2\\<close>"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOp op'\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n  drop ar \\<Sigma>1 = drop ar (norm_stack \\<Sigma>2)\n  ar \\<le> length \\<Sigma>2\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using \\<open>op' = op\\<close> step_op_inl.hyps(4) all_arg_Dyn"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOp op'\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n  drop ar \\<Sigma>1 = drop ar (norm_stack \\<Sigma>2)\n  ar \\<le> length \\<Sigma>2\n  op' = op\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "by (auto intro!: rel_stacktraces.intros\n                  dest: list_all_eq_const_imp_replicate\n                  simp: drop_norm_stack[symmetric] Let_def take_map drop_map)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2)\n   (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "thus \"rel_stacktraces (Fubx_get ?F2')\n          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) (?frame # st2) None\""], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2)\n   (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using F2_f pc_in_range IOp"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2)\n   (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n  body fd2 ! pc = Ubx.instr.IOp op'\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using Sinca.\\<II>\\<nn>\\<ll>_invertible \\<open>op' = op\\<close> step_op_inl.hyps(6)"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2)\n   (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n  body fd2 ! pc = Ubx.instr.IOp op'\n  \\<II>\\<nn>\\<ll> ?op ?xs = Some ?opinl \\<Longrightarrow>\n  \\<DD>\\<ee>\\<II>\\<nn>\\<ll> ?opinl = ?op\n  op' = op\n  \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "by (auto intro!: rel_stacktraces_rewrite_fundef simp: Subx.sp_instr_op Let_def)"], ["proof (state)\nthis:\n  rel_stacktraces\n   (Fubx_get\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))))\n   (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State\n   (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))) H\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))) H\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n  State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State\n   (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))) H\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State\n     (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))) H\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n  State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State\n   (Fubx_add F2 f (rewrite_fundef_body fd2 pc (Ubx.instr.IOpInl opinl))) H\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOp op; \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x10.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOp op;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n        \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOp op;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar; ar \\<le> length \\<Sigma>1;\n         \\<II>\\<nn>\\<ll> op (take ar \\<Sigma>1) = Some opinl;\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc (Inca.instr.IOpInl opinl)) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_op_inl_hit fd1 opinl ar x)"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_op_inl_hit rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_op_inl_hit rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (6 subgoals):\n 1. \\<And>fd opinl ar x.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 4. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 5. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 6. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "using step_op_inl_hit norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case (IOpInl opinl')"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'", "have \"opinl' = opinl\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n\ngoal (1 subgoal):\n 1. opinl' = opinl", "using norm_instr_nth_body step_op_inl_hit.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n\ngoal (1 subgoal):\n 1. opinl' = opinl", "by simp"], ["proof (state)\nthis:\n  opinl' = opinl\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "hence \"ar \\<le> length \\<Sigma>2\" and\n          all_arg_Dyn: \"list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\""], ["proof (prove)\nusing this:\n  opinl' = opinl\n\ngoal (1 subgoal):\n 1. ar \\<le> length \\<Sigma>2 &&&\n    list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))", "using IOpInl step_op_inl_hit sp_sufix[OF pc_in_range]"], ["proof (prove)\nusing this:\n  opinl' = opinl\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Subx.sp (Fubx_get F2) (body fd2 ! pc # drop (Suc pc) (body fd2))\n   (map typeof \\<Sigma>2) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. ar \\<le> length \\<Sigma>2 &&&\n    list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))", "by (auto simp: take_map)"], ["proof (state)\nthis:\n  ar \\<le> length \\<Sigma>2\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?s2' = \"State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using IOpInl step_op_inl_hit \\<open>opinl' = opinl\\<close>"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  opinl' = opinl\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using \\<Sigma>1_def pc_in_range F2_f all_arg_Dyn"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  opinl' = opinl\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd2)\n  Fubx_get F2 f = Some fd2\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "by (auto intro: Subx.step_op_inl_hit traverse_cast_Dyn_eq_norm_stack\n                simp: take_norm_stack)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using IOpInl sp_prefix take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using arg_cong[OF \\<Sigma>1_def, of \"drop ar\"]"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n  drop ar \\<Sigma>1 = drop ar (norm_stack \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "using \\<open>ar \\<le> length \\<Sigma>2\\<close> \\<open>opinl' = opinl\\<close> step_op_inl_hit.hyps(4,5) all_arg_Dyn"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n  drop ar \\<Sigma>1 = drop ar (norm_stack \\<Sigma>2)\n  ar \\<le> length \\<Sigma>2\n  opinl' = opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "by (auto intro!: match.intros rel_stacktraces.intros\n              dest: list_all_eq_const_imp_replicate\n              simp: drop_norm_stack[symmetric] Let_def take_map drop_map)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "case (IOpUbx opubx)"], ["proof (state)\nthis:\n  body fd2 ! pc = IOpUbx opubx\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = IOpUbx opubx", "have \"\\<BB>\\<oo>\\<xx> opubx = opinl\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = IOpUbx opubx\n\ngoal (1 subgoal):\n 1. \\<BB>\\<oo>\\<xx> opubx = opinl", "using norm_instr_nth_body step_op_inl_hit.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = IOpUbx opubx\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n\ngoal (1 subgoal):\n 1. \\<BB>\\<oo>\\<xx> opubx = opinl", "by simp"], ["proof (state)\nthis:\n  \\<BB>\\<oo>\\<xx> opubx = opinl\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "hence \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>_opubx[simp]: \"\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) = ar\""], ["proof (prove)\nusing this:\n  \\<BB>\\<oo>\\<xx> opubx = opinl\n\ngoal (1 subgoal):\n 1. \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n     (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) =\n    ar", "using step_op_inl_hit.hyps(4,5)"], ["proof (prove)\nusing this:\n  \\<BB>\\<oo>\\<xx> opubx = opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n\ngoal (1 subgoal):\n 1. \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n     (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) =\n    ar", "by simp"], ["proof (state)\nthis:\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n   (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) =\n  ar\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "note sp_sufix' = sp_sufix[OF pc_in_range, unfolded IOpUbx, simplified, unfolded Let_def, simplified]"], ["proof (state)\nthis:\n  Subx.sp_gen_pop_push (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n   (map typeof \\<Sigma>2) \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "obtain dom codom where typeof_opubx: \"\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dom codom.\n        \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n        (dom, codom) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust_sel"], ["proof (prove)\nusing this:\n  (?prod = (fst ?prod, snd ?prod) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>dom codom.\n        \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n        (dom, codom) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "hence dom_def: \"dom = map typeof (take ar \\<Sigma>2)\""], ["proof (prove)\nusing this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n\ngoal (1 subgoal):\n 1. dom = map typeof (take ar \\<Sigma>2)", "unfolding \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>_opubx[unfolded Subx.\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>_\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>, symmetric]"], ["proof (prove)\nusing this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n\ngoal (1 subgoal):\n 1. dom =\n    map typeof\n     (take (length (fst (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)))\n       \\<Sigma>2)", "using sp_sufix'"], ["proof (prove)\nusing this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n  Subx.sp_gen_pop_push (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)\n   (map typeof \\<Sigma>2) \\<bind>\n  Subx.sp (Fubx_get F2) (drop (Suc pc) (body fd2)) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. dom =\n    map typeof\n     (take (length (fst (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)))\n       \\<Sigma>2)", "by (auto simp: Let_def take_map)"], ["proof (state)\nthis:\n  dom = map typeof (take ar \\<Sigma>2)\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "obtain x' where\n          eval_op: \"\\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x'\" and\n          typeof_x': \"typeof x' = codom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>\\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n                 Some x';\n         typeof x' = codom\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using typeof_opubx[unfolded dom_def, THEN Subx.\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>_correct]"], ["proof (prove)\nusing this:\n  \\<exists>y.\n     \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some y \\<and>\n     typeof y = codom\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>\\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n                 Some x';\n         typeof x' = codom\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x'\n  typeof x' = codom\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "let ?s2' = \"State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)\""], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2))", "using \\<Sigma>1_def step_op_inl_hit eval_op \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>_opubx"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x'\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n   (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) =\n  ar\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2))", "using pc_in_range IOpUbx F2_f"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x'\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n   (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) =\n  ar\n  pc < length (body fd2)\n  body fd2 ! pc = IOpUbx opubx\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2))", "by (auto intro!: Subx.step_op_ubx)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2))\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2))\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)", "have \"x = Subx.norm_unboxed x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = Subx.norm_unboxed x'", "using Subx.\\<UU>\\<bb>\\<xx>\\<OO>\\<pp>_correct[OF eval_op, unfolded \\<open>\\<BB>\\<oo>\\<xx> opubx = opinl\\<close>]"], ["proof (prove)\nusing this:\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl\n   (map Subx.norm_unboxed (take ar \\<Sigma>2)) =\n  Subx.norm_unboxed x'\n\ngoal (1 subgoal):\n 1. x = Subx.norm_unboxed x'", "using step_op_inl_hit \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl\n   (map Subx.norm_unboxed (take ar \\<Sigma>2)) =\n  Subx.norm_unboxed x'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. x = Subx.norm_unboxed x'", "by (simp add: take_map norm_stack_def)"], ["proof (state)\nthis:\n  x = Subx.norm_unboxed x'\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = Subx.norm_unboxed x'\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)", "using rel_F1_F2 sp_F2 rel_st1_st2 F2_f \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  x = Subx.norm_unboxed x'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)", "using sp_prefix take_Suc_conv_app_nth[OF pc_in_range, unfolded IOpUbx]"], ["proof (prove)\nusing this:\n  x = Subx.norm_unboxed x'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [IOpUbx opubx]\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)", "using step_op_inl_hit"], ["proof (prove)\nusing this:\n  x = Subx.norm_unboxed x'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [IOpUbx opubx]\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)", "using typeof_opubx typeof_x'"], ["proof (prove)\nusing this:\n  x = Subx.norm_unboxed x'\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [IOpUbx opubx]\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n  typeof x' = codom\n\ngoal (1 subgoal):\n 1. State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)", "by (auto intro!: match.intros rel_stacktraces.intros\n                simp: dom_def drop_norm_stack Let_def min.absorb2 take_map drop_map)"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2))\n  State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State F2 H (Frame f (Suc pc) (x' # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (5 subgoals):\n 1. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_op_inl_miss fd1 opinl ar x F1')"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n\ngoal (5 subgoals):\n 1. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (5 subgoals):\n 1. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_op_inl_miss rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (5 subgoals):\n 1. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_op_inl_miss rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (5 subgoals):\n 1. \\<And>fd opinl ar x F'.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 3. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 4. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 5. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "using step_op_inl_miss norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case (IOpInl opinl')"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'", "have \"opinl' = opinl\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n\ngoal (1 subgoal):\n 1. opinl' = opinl", "using norm_instr_nth_body step_op_inl_miss.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n\ngoal (1 subgoal):\n 1. opinl' = opinl", "by simp"], ["proof (state)\nthis:\n  opinl' = opinl\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "hence \"ar \\<le> length \\<Sigma>2\" and\n          all_arg_Dyn: \"list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\""], ["proof (prove)\nusing this:\n  opinl' = opinl\n\ngoal (1 subgoal):\n 1. ar \\<le> length \\<Sigma>2 &&&\n    list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))", "using IOpInl step_op_inl_miss sp_sufix[OF pc_in_range]"], ["proof (prove)\nusing this:\n  opinl' = opinl\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n  Subx.sp (Fubx_get F2) (body fd2 ! pc # drop (Suc pc) (body fd2))\n   (map typeof \\<Sigma>2) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. ar \\<le> length \\<Sigma>2 &&&\n    list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))", "by (auto simp: take_map)"], ["proof (state)\nthis:\n  ar \\<le> length \\<Sigma>2\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?fd2' = \"rewrite_fundef_body fd2 pc (Ubx.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?F2' = \"Fubx_add F2 f ?fd2'\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?frame = \"Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "let ?s2' = \"State ?F2' H (?frame # st2)\""], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?STEP ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n       H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using IOpInl step_op_inl_miss \\<open>opinl' = opinl\\<close>"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n  opinl' = opinl\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n       H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using \\<Sigma>1_def pc_in_range F2_f"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n  opinl' = opinl\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd2)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n       H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "using traverse_cast_Dyn_eq_norm_stack[OF all_arg_Dyn]"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n  opinl' = opinl\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  pc < length (body fd2)\n  Fubx_get F2 f = Some fd2\n  traverse cast_Dyn (take ar \\<Sigma>2) =\n  Some (norm_stack (take ar \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n       H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))", "by (auto intro!: Subx.step_op_inl_miss simp: take_norm_stack)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State\n     (Fubx_add F2 f\n       (rewrite_fundef_body fd2 pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State\n     (Fubx_add F2 f\n       (rewrite_fundef_body fd2 pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "have \"?MATCH ?s2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n    State\n     (Fubx_add F2 f\n       (rewrite_fundef_body fd2 pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. rel_fundefs (Finca_get F1')\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n 2. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n 3. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "show \"rel_fundefs (Finca_get F1') (Fubx_get ?F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1')\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))", "using step_op_inl_miss rel_fd1_fd2"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. rel_fundefs (Finca_get F1')\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))", "by (auto intro: rel_fundefs_rewrite_both')"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1')\n   (Fubx_get\n     (Fubx_add F2 f\n       (rewrite_fundef_body fd2 pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n\ngoal (2 subgoals):\n 1. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n 2. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n 2. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "show \"sp_fundefs (Fubx_get ?F2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))", "using IOpInl \\<open>opinl' = opinl\\<close> all_same_arities_add[OF F2_f] sp_full"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  opinl' = opinl\n  arity fd2 = arity ?fd2.0 \\<Longrightarrow>\n  all_same_arities (Fubx_get F2) (Fubx_get (Fubx_add F2 f ?fd2.0))\n  Subx.sp (Fubx_get F2) (body fd2) (replicate (arity fd2) None) = Ok [None]\n\ngoal (1 subgoal):\n 1. sp_fundefs\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))", "by (auto intro: sp_fundefs_add[OF sp_F2]\n                simp: Subx.sp_instr_op[symmetric] Subx.sp_rewrite[OF pc_in_range])"], ["proof (state)\nthis:\n  sp_fundefs\n   (Fubx_get\n     (Fubx_add F2 f\n       (rewrite_fundef_body fd2 pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "have \"rel_stacktraces (Fubx_get F2)\n            (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) (?frame # st2) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using rel_st1_st2 sp_prefix F2_f"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using IOpInl \\<Sigma>1_def take_Suc_conv_app_nth[OF pc_in_range]"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using \\<open>ar \\<le> length \\<Sigma>2\\<close> \\<open>opinl' = opinl\\<close> step_op_inl_miss.hyps(4,5)"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n  ar \\<le> length \\<Sigma>2\n  opinl' = opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using all_arg_Dyn"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n  Fubx_get F2 f = Some fd2\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  take (Suc pc) (body fd2) = take pc (body fd2) @ [body fd2 ! pc]\n  ar \\<le> length \\<Sigma>2\n  opinl' = opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  list_all (\\<lambda>x. x = None) (map typeof (take ar \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "by (auto intro!: rel_stacktraces.intros\n                  dest: list_all_eq_const_imp_replicate\n                  simp: drop_norm_stack Let_def take_map drop_map)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2)\n   (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "thus \"rel_stacktraces (Fubx_get ?F2')\n            (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) (?frame # st2) None\""], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2)\n   (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "using F2_f pc_in_range IOpInl"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2)\n   (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n  Fubx_get F2 f = Some fd2\n  pc < length (body fd2)\n  body fd2 ! pc = Ubx.instr.IOpInl opinl'\n\ngoal (1 subgoal):\n 1. rel_stacktraces\n     (Fubx_get\n       (Fubx_add F2 f\n         (rewrite_fundef_body fd2 pc\n           (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n     (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n     (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None", "by (auto intro: rel_stacktraces_rewrite_fundef\n                simp: \\<open>opinl' = opinl\\<close> Let_def Subx.sp_instr_op[symmetric])"], ["proof (state)\nthis:\n  rel_stacktraces\n   (Fubx_get\n     (Fubx_add F2 f\n       (rewrite_fundef_body fd2 pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl)))))\n   (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1)\n   (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2) None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State\n   (Fubx_add F2 f\n     (rewrite_fundef_body fd2 pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n   H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State\n     (Fubx_add F2 f\n       (rewrite_fundef_body fd2 pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n  State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State\n   (Fubx_add F2 f\n     (rewrite_fundef_body fd2 pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n   H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State\n     (Fubx_add F2 f\n       (rewrite_fundef_body fd2 pc\n         (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n     H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2))\n  State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n  State\n   (Fubx_add F2 f\n     (rewrite_fundef_body fd2 pc\n       (Ubx.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))))\n   H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>2) # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "case (IOpUbx opubx)"], ["proof (state)\nthis:\n  body fd2 ! pc = IOpUbx opubx\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = IOpUbx opubx", "have \"\\<BB>\\<oo>\\<xx> opubx = opinl\""], ["proof (prove)\nusing this:\n  body fd2 ! pc = IOpUbx opubx\n\ngoal (1 subgoal):\n 1. \\<BB>\\<oo>\\<xx> opubx = opinl", "using norm_instr_nth_body step_op_inl_miss.hyps(3)"], ["proof (prove)\nusing this:\n  body fd2 ! pc = IOpUbx opubx\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n\ngoal (1 subgoal):\n 1. \\<BB>\\<oo>\\<xx> opubx = opinl", "by simp"], ["proof (state)\nthis:\n  \\<BB>\\<oo>\\<xx> opubx = opinl\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "hence \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>_opubx: \"\\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) = ar\""], ["proof (prove)\nusing this:\n  \\<BB>\\<oo>\\<xx> opubx = opinl\n\ngoal (1 subgoal):\n 1. \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n     (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) =\n    ar", "using step_op_inl_miss.hyps(4,5)"], ["proof (prove)\nusing this:\n  \\<BB>\\<oo>\\<xx> opubx = opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n\ngoal (1 subgoal):\n 1. \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n     (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) =\n    ar", "by simp"], ["proof (state)\nthis:\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>\n   (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx)) =\n  ar\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "obtain dom codom where \"\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>dom codom.\n        \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n        (dom, codom) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using prod.exhaust_sel"], ["proof (prove)\nusing this:\n  (?prod = (fst ?prod, snd ?prod) \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>dom codom.\n        \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n        (dom, codom) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "hence \"\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (map typeof (take ar \\<Sigma>2), codom)\""], ["proof (prove)\nusing this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n\ngoal (1 subgoal):\n 1. \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n    (map typeof (take ar \\<Sigma>2), codom)", "unfolding \\<AA>\\<rr>\\<ii>\\<tt>\\<yy>_opubx[unfolded Subx.\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>_\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>, symmetric]"], ["proof (prove)\nusing this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n\ngoal (1 subgoal):\n 1. \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n    (map typeof\n      (take (length (fst (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)))\n        \\<Sigma>2),\n     codom)", "using sp_sufix[OF pc_in_range]"], ["proof (prove)\nusing this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n  Subx.sp (Fubx_get F2) (body fd2 ! pc # drop (Suc pc) (body fd2))\n   (map typeof \\<Sigma>2) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n    (map typeof\n      (take (length (fst (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)))\n        \\<Sigma>2),\n     codom)", "unfolding IOpUbx"], ["proof (prove)\nusing this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (dom, codom)\n  Subx.sp (Fubx_get F2) (IOpUbx opubx # drop (Suc pc) (body fd2))\n   (map typeof \\<Sigma>2) =\n  Ok [None]\n\ngoal (1 subgoal):\n 1. \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n    (map typeof\n      (take (length (fst (\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx)))\n        \\<Sigma>2),\n     codom)", "by (auto simp: Let_def case_prod_beta take_map)"], ["proof (state)\nthis:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n  (map typeof (take ar \\<Sigma>2), codom)\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n  (map typeof (take ar \\<Sigma>2), codom)", "obtain x where eval_op: \"\\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\""], ["proof (prove)\nusing this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n  (map typeof (take ar \\<Sigma>2), codom)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Subx.\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>_correct"], ["proof (prove)\nusing this:\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx =\n  (map typeof (take ar \\<Sigma>2), codom)\n  \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> ?opubx =\n  (map typeof ?xs, ?\\<tau>) \\<Longrightarrow>\n  \\<exists>y.\n     \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> ?opubx ?xs = Some y \\<and> typeof y = ?\\<tau>\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) =\n        Some x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "hence \"\\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\""], ["proof (prove)\nusing this:\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n\ngoal (1 subgoal):\n 1. \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)", "unfolding \\<Sigma>1_def norm_stack_def"], ["proof (prove)\nusing this:\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n\ngoal (1 subgoal):\n 1. \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl\n     (take ar (map Subx.norm_unboxed \\<Sigma>2))", "using \\<open>\\<BB>\\<oo>\\<xx> opubx = opinl\\<close>"], ["proof (prove)\nusing this:\n  \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>2) = Some x\n  \\<BB>\\<oo>\\<xx> opubx = opinl\n\ngoal (1 subgoal):\n 1. \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl\n     (take ar (map Subx.norm_unboxed \\<Sigma>2))", "by (auto intro: Sinca.\\<II>\\<nn>\\<ll>_\\<II>\\<ss>\\<II>\\<nn>\\<ll> Subx.\\<UU>\\<bb>\\<xx>\\<OO>\\<pp>_to_\\<II>\\<nn>\\<ll> simp: take_map)"], ["proof (state)\nthis:\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "hence False"], ["proof (prove)\nusing this:\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n\ngoal (1 subgoal):\n 1. False", "using step_op_inl_miss"], ["proof (prove)\nusing this:\n  \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.IOpInl opinl\n  \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar\n  ar \\<le> length \\<Sigma>1\n  \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1)\n  \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__\n  Finca_add F1 f\n   (rewrite_fundef_body fd1 pc\n     (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n  F1'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x11.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = IOpUbx x11\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1' H (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) # st1) \\<sim>\n       s2'", "by simp"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1' H (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) # st1) \\<sim>\n     s2'\n\ngoal (11 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.IOpInl opinl;\n     \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n     ar \\<le> length \\<Sigma>1;\n     \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n     \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n     Finca_add F1 f\n      (rewrite_fundef_body fd1 pc\n        (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n     F1';\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1' H\n                          (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                           st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.IOpInl opinl;\n        \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n        ar \\<le> length \\<Sigma>1;\n        \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n        \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n        Finca_add F1 f\n         (rewrite_fundef_body fd1 pc\n           (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n        F1';\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1' H\n                             (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                              st1) \\<sim>\n                            s2'\n 10. \\<And>x12.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.IOpInl opinl;\n         \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar;\n         ar \\<le> length \\<Sigma>1;\n         \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl (take ar \\<Sigma>1);\n         \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl (take ar \\<Sigma>1) = x__;\n         Finca_add F1 f\n          (rewrite_fundef_body fd1 pc\n            (Inca.instr.IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) =\n         F1';\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.ICJump x12\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1' H\n                              (Frame f (Suc pc) (x__ # drop ar \\<Sigma>1) #\n                               st1) \\<sim>\n                             s2'\nA total of 11 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1' H (Frame f (Suc pc) (x # drop ar \\<Sigma>1) # st1) \\<sim> s2'\n\ngoal (4 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_cjump_true fd1 n \\<Sigma>1')"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_true \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n\ngoal (4 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_true \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_true \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (4 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_cjump_true rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_true \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (4 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_cjump_true rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_true \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (4 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_true d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma> # st1) \\<sim> s2'\n 2. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 3. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 4. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim> s2'", "using step_cjump_true norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_true \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim> s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n     \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim> s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n         \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case (ICJump n')"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.ICJump n'\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n     \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim> s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n         \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = Ubx.instr.ICJump n'", "have False"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.ICJump n'\n\ngoal (1 subgoal):\n 1. False", "using F2_f sp_fundefs_get[OF sp_F2, unfolded sp_fundef_def, THEN Subx.sp_no_jump]"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.ICJump n'\n  Fubx_get F2 f = Some fd2\n  Fubx_get F2 ?f1 = Some ?fd1 \\<Longrightarrow>\n  \\<forall>x\\<in>set (body ?fd1). \\<not> is_jump x\n\ngoal (1 subgoal):\n 1. False", "using nth_mem pc_in_range"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.ICJump n'\n  Fubx_get F2 f = Some fd2\n  Fubx_get F2 ?f1 = Some ?fd1 \\<Longrightarrow>\n  \\<forall>x\\<in>set (body ?fd1). \\<not> is_jump x\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  pc < length (body fd2)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n     \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim> s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n         \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim> s2'", "by simp"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n     \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim> s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ICJump n; is_true \\<Sigma>1';\n         \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f n \\<Sigma>_ # st1) \\<sim> s2'\n\ngoal (3 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_cjump_false fd1 n \\<Sigma>1')"], ["proof (state)\nthis:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_false \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n\ngoal (3 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_false \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using ex_F1_f"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_false \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (3 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence norm_instr_nth_body: \"norm_instr (body fd2 ! pc) = body fd1 ! pc\""], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "using step_cjump_false rel_fundef_body_nth"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_false \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n  \\<lbrakk>rel_fundef (\\<lambda>x y. x = norm_instr y) ?fd1.0 ?fd2.0;\n   ?pc < length (body ?fd1.0)\\<rbrakk>\n  \\<Longrightarrow> body ?fd1.0 ! ?pc = norm_instr (body ?fd2.0 ! ?pc)\n\ngoal (1 subgoal):\n 1. norm_instr (body fd2 ! pc) = body fd1 ! pc", "by metis"], ["proof (state)\nthis:\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (3 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_cjump_false rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_false \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (3 subgoals):\n 1. \\<And>fd n d \\<Sigma>.\n       \\<lbrakk>Finca_get F1 f = Some fd; pc < length (body fd);\n        body fd ! pc = Inca.instr.ICJump n; is_false d;\n        d # \\<Sigma> = \\<Sigma>1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma> # st1) \\<sim>\n                            s2'\n 2. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 3. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim> s2'", "using step_cjump_false norm_instr_nth_body"], ["proof (prove)\nusing this:\n  Finca_get F1 f = Some fd1\n  pc < length (body fd1)\n  body fd1 ! pc = Inca.instr.ICJump n\n  is_false \\<Sigma>1'\n  \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1\n  norm_instr (body fd2 ! pc) = body fd1 ! pc\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim> s2'", "proof (cases \"body fd2 ! pc\")"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n     \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n         \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "case (ICJump n')"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.ICJump n'\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n     \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n         \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  body fd2 ! pc = Ubx.instr.ICJump n'", "have False"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.ICJump n'\n\ngoal (1 subgoal):\n 1. False", "using F2_f sp_fundefs_get[OF sp_F2, unfolded sp_fundef_def, THEN Subx.sp_no_jump]"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.ICJump n'\n  Fubx_get F2 f = Some fd2\n  Fubx_get F2 ?f1 = Some ?fd1 \\<Longrightarrow>\n  \\<forall>x\\<in>set (body ?fd1). \\<not> is_jump x\n\ngoal (1 subgoal):\n 1. False", "using nth_mem pc_in_range"], ["proof (prove)\nusing this:\n  body fd2 ! pc = Ubx.instr.ICJump n'\n  Fubx_get F2 f = Some fd2\n  Fubx_get F2 ?f1 = Some ?fd1 \\<Longrightarrow>\n  \\<forall>x\\<in>set (body ?fd1). \\<not> is_jump x\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  pc < length (body fd2)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (13 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n     \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n         \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                             s2'\nA total of 13 subgoals...", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim> s2'", "by simp"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim> s2'\n\ngoal (12 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IPush x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 2. \\<And>x2.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 3. \\<And>x3.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IPushUbx2 x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 4. \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n     body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n     \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n     norm_instr (body fd2 ! pc) = body fd1 ! pc;\n     body fd2 ! pc = Ubx.instr.IPop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s2'.\n                         Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                          s2' \\<and>\n                         State F1 H\n                          (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                         s2'\n 5. \\<And>x5.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.ILoad x5\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 6. \\<And>x61 x62.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = ILoadUbx x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 7. \\<And>x7.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IStore x7\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 8. \\<And>x81 x82.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = IStoreUbx x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 9. \\<And>x9.\n       \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n        body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n        \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n        norm_instr (body fd2 ! pc) = body fd1 ! pc;\n        body fd2 ! pc = Ubx.instr.IOp x9\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                            s2'\n 10. \\<And>x10.\n        \\<lbrakk>Finca_get F1 f = Some fd1; pc < length (body fd1);\n         body fd1 ! pc = Inca.instr.ICJump n; is_false \\<Sigma>1';\n         \\<Sigma>1' # \\<Sigma>_ = \\<Sigma>1;\n         norm_instr (body fd2 ! pc) = body fd1 ! pc;\n         body fd2 ! pc = Ubx.instr.IOpInl x10\\<rbrakk>\n        \\<Longrightarrow> \\<exists>s2'.\n                             Subx.step\n                              (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                              s2' \\<and>\n                             State F1 H\n                              (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim>\n                             s2'\nA total of 12 subgoals...", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (Frame f (Suc pc) \\<Sigma>_ # st1) \\<sim> s2'\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_fun_call f' fd1 pc' g gd1 \\<Sigma>1' frame\\<^sub>g)"], ["proof (state)\nthis:\n  Finca_get F1 f' = Some fd1\n  pc' < length (body fd1)\n  body fd1 ! pc' = Inca.instr.ICall g\n  Finca_get F1 g = Some gd1\n  arity gd1 \\<le> length \\<Sigma>1'\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g 0 (take (arity gd1) \\<Sigma>1')\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence [simp]: \"f' = f\" \"pc' = pc\" \"\\<Sigma>1' = \\<Sigma>1\""], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  pc' < length (body fd1)\n  body fd1 ! pc' = Inca.instr.ICall g\n  Finca_get F1 g = Some gd1\n  arity gd1 \\<le> length \\<Sigma>1'\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g 0 (take (arity gd1) \\<Sigma>1')\n\ngoal (1 subgoal):\n 1. f' = f &&& pc' = pc &&& \\<Sigma>1' = \\<Sigma>1", "by auto"], ["proof (state)\nthis:\n  f' = f\n  pc' = pc\n  \\<Sigma>1' = \\<Sigma>1\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  f' = f\n  pc' = pc\n  \\<Sigma>1' = \\<Sigma>1\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using step_fun_call ex_F1_f"], ["proof (prove)\nusing this:\n  f' = f\n  pc' = pc\n  \\<Sigma>1' = \\<Sigma>1\n  Finca_get F1 f' = Some fd1\n  pc' < length (body fd1)\n  body fd1 ! pc' = Inca.instr.ICall g\n  Finca_get F1 g = Some gd1\n  arity gd1 \\<le> length \\<Sigma>1'\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g 0 (take (arity gd1) \\<Sigma>1')\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "obtain gd2 where \"Fubx_get F2 g = Some gd2\" and rel_gd1_gd2: \"rel_fundef norm_eq gd1 gd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>gd2.\n        \\<lbrakk>Fubx_get F2 g = Some gd2;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) gd1 gd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using step_fun_call rel_fundefs_Some1[OF rel_F1_F2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  pc' < length (body fd1)\n  body fd1 ! pc' = Inca.instr.ICall g\n  Finca_get F1 g = Some gd1\n  arity gd1 \\<le> length \\<Sigma>1'\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g 0 (take (arity gd1) \\<Sigma>1')\n  Finca_get F1 ?x = Some ?y \\<Longrightarrow>\n  \\<exists>z.\n     Fubx_get F2 ?x = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) ?y z\n\ngoal (1 subgoal):\n 1. (\\<And>gd2.\n        \\<lbrakk>Fubx_get F2 g = Some gd2;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) gd1 gd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Fubx_get F2 g = Some gd2\n  rel_fundef (\\<lambda>x y. x = norm_instr y) gd1 gd2\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have pc_in_range: \"pc < length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "using step_fun_call rel_fd1_fd2"], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  pc' < length (body fd1)\n  body fd1 ! pc' = Inca.instr.ICall g\n  Finca_get F1 g = Some gd1\n  arity gd1 \\<le> length \\<Sigma>1'\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g 0 (take (arity gd1) \\<Sigma>1')\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. pc < length (body fd2)", "by simp"], ["proof (state)\nthis:\n  pc < length (body fd2)\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have nth_body2: \"body fd2 ! pc = Ubx.ICall g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. body fd2 ! pc = Ubx.instr.ICall g", "using rel_fundef_body_nth[OF rel_fd1_fd2 \\<open>pc' < length (body fd1)\\<close>, symmetric]"], ["proof (prove)\nusing this:\n  norm_instr (body fd2 ! pc') = body fd1 ! pc'\n\ngoal (1 subgoal):\n 1. body fd2 ! pc = Ubx.instr.ICall g", "unfolding \\<open>body fd1 ! pc' = Inca.ICall g\\<close>"], ["proof (prove)\nusing this:\n  norm_instr (body fd2 ! pc') = Inca.instr.ICall g\n\ngoal (1 subgoal):\n 1. body fd2 ! pc = Ubx.instr.ICall g", "by (cases \"body fd2 ! pc'\"; simp)"], ["proof (state)\nthis:\n  body fd2 ! pc = Ubx.instr.ICall g\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "have prefix_\\<Sigma>2_all_Dyn: \"list_all (\\<lambda>x. x = None) (map typeof (take (arity gd2) \\<Sigma>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x = None)\n     (map typeof (take (arity gd2) \\<Sigma>2))", "using \\<open>Fubx_get F2 g = Some gd2\\<close> sp_sufix[OF pc_in_range] nth_body2"], ["proof (prove)\nusing this:\n  Fubx_get F2 g = Some gd2\n  Subx.sp (Fubx_get F2) (body fd2 ! pc # drop (Suc pc) (body fd2))\n   (map typeof \\<Sigma>2) =\n  Ok [None]\n  body fd2 ! pc = Ubx.instr.ICall g\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x = None)\n     (map typeof (take (arity gd2) \\<Sigma>2))", "by (auto simp: Let_def take_map)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = None) (map typeof (take (arity gd2) \\<Sigma>2))\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence all_dyn_args: \"list_all is_dyn_operand (take (arity gd2) \\<Sigma>2)\""], ["proof (prove)\nusing this:\n  list_all (\\<lambda>x. x = None) (map typeof (take (arity gd2) \\<Sigma>2))\n\ngoal (1 subgoal):\n 1. list_all is_dyn_operand (take (arity gd2) \\<Sigma>2)", "by (auto elim: list.pred_mono_strong simp add: list.pred_map comp_def)"], ["proof (state)\nthis:\n  list_all is_dyn_operand (take (arity gd2) \\<Sigma>2)\n\ngoal (2 subgoals):\n 1. \\<And>fa fd pca g gd \\<Sigma> frame\\<^sub>g.\n       \\<lbrakk>Finca_get F1 fa = Some fd; pca < length (body fd);\n        body fd ! pca = Inca.instr.ICall g; Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>;\n        Frame f pc \\<Sigma>1 = Frame fa pca \\<Sigma>;\n        frame\\<^sub>g = Frame g 0 (take (arity gd) \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H\n                             (frame\\<^sub>g #\n                              Frame f pc \\<Sigma>1 # st1) \\<sim>\n                            s2'\n 2. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'", "let ?args = \"map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'", "let ?frame = \"Frame g 0 ?args\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'", "let ?s1' = \"State F2 H (?frame # Frame f pc \\<Sigma>2 # st2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H\n       (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n        Frame f pc \\<Sigma>2 # st2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H\n       (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n        Frame f pc \\<Sigma>2 # st2))", "have \"arity gd2 \\<le> length \\<Sigma>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity gd2 \\<le> length \\<Sigma>2", "using \\<open>arity gd1 \\<le> length \\<Sigma>1'\\<close>"], ["proof (prove)\nusing this:\n  arity gd1 \\<le> length \\<Sigma>1'\n\ngoal (1 subgoal):\n 1. arity gd2 \\<le> length \\<Sigma>2", "using rel_fundef_arities[OF rel_gd1_gd2] \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  arity gd1 \\<le> length \\<Sigma>1'\n  arity gd1 = arity gd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. arity gd2 \\<le> length \\<Sigma>2", "by simp"], ["proof (state)\nthis:\n  arity gd2 \\<le> length \\<Sigma>2\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H\n       (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n        Frame f pc \\<Sigma>2 # st2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  arity gd2 \\<le> length \\<Sigma>2\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H\n       (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n        Frame f pc \\<Sigma>2 # st2))", "using pc_in_range nth_body2"], ["proof (prove)\nusing this:\n  arity gd2 \\<le> length \\<Sigma>2\n  pc < length (body fd2)\n  body fd2 ! pc = Ubx.instr.ICall g\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H\n       (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n        Frame f pc \\<Sigma>2 # st2))", "using  \\<open>Fubx_get F2 g = Some gd2\\<close> rel_stacktraces_Cons.hyps(3)"], ["proof (prove)\nusing this:\n  arity gd2 \\<le> length \\<Sigma>2\n  pc < length (body fd2)\n  body fd2 ! pc = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H\n       (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n        Frame f pc \\<Sigma>2 # st2))", "using all_dyn_args"], ["proof (prove)\nusing this:\n  arity gd2 \\<le> length \\<Sigma>2\n  pc < length (body fd2)\n  body fd2 ! pc = Ubx.instr.ICall g\n  Fubx_get F2 g = Some gd2\n  Fubx_get F2 f = Some fd2\n  list_all is_dyn_operand (take (arity gd2) \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H\n       (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n        Frame f pc \\<Sigma>2 # st2))", "by (auto intro!: Subx.step_fun_call[of _ _ fd2] nth_equalityI\n                simp: typeof_unboxed_eq_const list_all_length norm_stack_def)"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2))\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2))\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim>\n    State F2 H\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2)", "using rel_F1_F2 sp_F2"], ["proof (prove)\nusing this:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n\ngoal (1 subgoal):\n 1. State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim>\n    State F2 H\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1)\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2)\n     None", "show \"rel_stacktraces (Fubx_get F2)\n           (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1)\n           (?frame # Frame f pc \\<Sigma>2 # st2) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1)\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2)\n     None", "unfolding step_fun_call(7)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2)\n     (Frame g 0 (take (arity gd1) \\<Sigma>1') # Frame f pc \\<Sigma>1 # st1)\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2)\n     None", "proof (rule rel_stacktraces.intros)"], ["proof (state)\ngoal (5 subgoals):\n 1. rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n     (Frame f pc \\<Sigma>2 # st2) (Some g)\n 2. take (arity gd1) \\<Sigma>1' =\n    norm_stack (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2)))\n 3. Fubx_get F2 g = Some ?fd2.0\n 4. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n 5. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0\n       (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n     None", "show \"rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1) (Frame f pc \\<Sigma>2 # st2)\n              (Some g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n     (Frame f pc \\<Sigma>2 # st2) (Some g)", "using pc_in_range nth_body2 rel_stacktraces_Cons"], ["proof (prove)\nusing this:\n  pc < length (body fd2)\n  body fd2 ! pc = Ubx.instr.ICall g\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1'\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n     (Frame f pc \\<Sigma>2 # st2) (Some g)", "using \\<open>Fubx_get F2 g = Some gd2\\<close> all_dyn_args"], ["proof (prove)\nusing this:\n  pc < length (body fd2)\n  body fd2 ! pc = Ubx.instr.ICall g\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  sp_fundef (Fubx_get F2) fd2 (take pc (body fd2)) =\n  Ok (map typeof \\<Sigma>2)\n  pred_option (is_valid_fun_call (Fubx_get F2) fd2 pc \\<Sigma>2) None\n  Sinca.step (State F1 H (Frame f pc \\<Sigma>1 # st1)) s1'\n  Fubx_get F2 g = Some gd2\n  list_all is_dyn_operand (take (arity gd2) \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n     (Frame f pc \\<Sigma>2 # st2) (Some g)", "by (auto intro!: rel_stacktraces.intros simp: is_valid_fun_call_def)"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2) (Frame f pc \\<Sigma>1 # st1)\n   (Frame f pc \\<Sigma>2 # st2) (Some g)\n\ngoal (4 subgoals):\n 1. take (arity gd1) \\<Sigma>1' =\n    norm_stack (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2)))\n 2. Fubx_get F2 g = Some ?fd2.0\n 3. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n 4. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0\n       (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n     None", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. take (arity gd1) \\<Sigma>1' =\n    norm_stack (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2)))\n 2. Fubx_get F2 g = Some ?fd2.0\n 3. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n 4. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0\n       (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n     None", "show \"take (arity gd1) \\<Sigma>1' = norm_stack ?args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take (arity gd1) \\<Sigma>1' =\n    norm_stack (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2)))", "using \\<Sigma>1_def"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n\ngoal (1 subgoal):\n 1. take (arity gd1) \\<Sigma>1' =\n    norm_stack (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2)))", "using rel_fundef_arities[OF rel_gd1_gd2]"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  arity gd1 = arity gd2\n\ngoal (1 subgoal):\n 1. take (arity gd1) \\<Sigma>1' =\n    norm_stack (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2)))", "by (simp add: norm_stack_map take_norm_stack)"], ["proof (state)\nthis:\n  take (arity gd1) \\<Sigma>1' =\n  norm_stack (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2)))\n\ngoal (3 subgoals):\n 1. Fubx_get F2 g = Some ?fd2.0\n 2. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n 3. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0\n       (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n     None", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Fubx_get F2 g = Some ?fd2.0\n 2. sp_fundef (Fubx_get F2) ?fd2.0 (take 0 (body ?fd2.0)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n 3. pred_option\n     (is_valid_fun_call (Fubx_get F2) ?fd2.0 0\n       (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n     None", "show \"Fubx_get F2 g = Some gd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fubx_get F2 g = Some gd2", "using \\<open>Fubx_get F2 g = Some gd2\\<close>"], ["proof (prove)\nusing this:\n  Fubx_get F2 g = Some gd2\n\ngoal (1 subgoal):\n 1. Fubx_get F2 g = Some gd2", "."], ["proof (state)\nthis:\n  Fubx_get F2 g = Some gd2\n\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 0\n       (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n     None", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n 2. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 0\n       (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n     None", "show \"sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) = Ok (map typeof ?args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))", "using \\<Sigma>1_def step_fun_call.hyps(5)"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  arity gd1 \\<le> length \\<Sigma>1'\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))", "using rel_fundef_arities[OF rel_gd1_gd2]"], ["proof (prove)\nusing this:\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  arity gd1 \\<le> length \\<Sigma>1'\n  arity gd1 = arity gd2\n\ngoal (1 subgoal):\n 1. sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n    Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))", "by (simp add: map_replicate_const)"], ["proof (state)\nthis:\n  sp_fundef (Fubx_get F2) gd2 (take 0 (body gd2)) =\n  Ok (map typeof (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n\ngoal (1 subgoal):\n 1. pred_option\n     (is_valid_fun_call (Fubx_get F2) gd2 0\n       (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))))\n     None", "qed simp_all"], ["proof (state)\nthis:\n  rel_stacktraces (Fubx_get F2) (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1)\n   (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n    Frame f pc \\<Sigma>2 # st2)\n   None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim>\n  State F2 H\n   (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n    Frame f pc \\<Sigma>2 # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2))\n  State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim>\n  State F2 H\n   (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n    Frame f pc \\<Sigma>2 # st2)", "show \"?thesis\""], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H\n     (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n      Frame f pc \\<Sigma>2 # st2))\n  State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim>\n  State F2 H\n   (Frame g 0 (map OpDyn (norm_stack (take (arity gd2) \\<Sigma>2))) #\n    Frame f pc \\<Sigma>2 # st2)\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'", "by blast"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (frame\\<^sub>g # Frame f pc \\<Sigma>1 # st1) \\<sim> s2'\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "case (step_fun_end f' fd1 \\<Sigma>1\\<^sub>g pc' \\<Sigma>1' frame\\<^sub>g g pc\\<^sub>g frame\\<^sub>g' st1')"], ["proof (state)\nthis:\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence [simp]: \"f' = f\" \"pc' = pc\" \"\\<Sigma>1' = \\<Sigma>1\""], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n\ngoal (1 subgoal):\n 1. f' = f &&& pc' = pc &&& \\<Sigma>1' = \\<Sigma>1", "by auto"], ["proof (state)\nthis:\n  f' = f\n  pc' = pc\n  \\<Sigma>1' = \\<Sigma>1\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\nusing this:\n  f' = f\n  pc' = pc\n  \\<Sigma>1' = \\<Sigma>1\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "using step_fun_end ex_F1_f"], ["proof (prove)\nusing this:\n  f' = f\n  pc' = pc\n  \\<Sigma>1' = \\<Sigma>1\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  \\<exists>z.\n     Finca_get F1 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) z fd2\n\ngoal (1 subgoal):\n 1. rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2", "by simp"], ["proof (state)\nthis:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "note arities_fd1_fd2 = rel_fundef_arities[OF rel_fd1_fd2]"], ["proof (state)\nthis:\n  arity fd1 = arity fd2\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "obtain \\<Sigma>2\\<^sub>g st2' where\n        st2_def: \"st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>2\\<^sub>g st2'.\n        st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using step_fun_end rel_st1_st2"], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>2\\<^sub>g st2'.\n        st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: rel_stacktraces.cases)"], ["proof (state)\nthis:\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "hence all_dyn_prefix_\\<Sigma>2\\<^sub>g: \"list_all (\\<lambda>x. x = None) (map typeof (take (arity fd2) \\<Sigma>2\\<^sub>g))\""], ["proof (prove)\nusing this:\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x = None)\n     (map typeof (take (arity fd2) \\<Sigma>2\\<^sub>g))", "using step_fun_end rel_st1_st2 F2_f"], ["proof (prove)\nusing this:\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. x = None)\n     (map typeof (take (arity fd2) \\<Sigma>2\\<^sub>g))", "by (auto\n            elim!: rel_stacktraces.cases[of _ \"_ # _\"] list.pred_mono_strong\n            simp: list.pred_map is_valid_fun_call_def)"], ["proof (state)\nthis:\n  list_all (\\<lambda>x. x = None)\n   (map typeof (take (arity fd2) \\<Sigma>2\\<^sub>g))\n\ngoal (1 subgoal):\n 1. \\<And>g gd \\<Sigma>\\<^sub>f pc\\<^sub>g \\<Sigma>\\<^sub>g frame\\<^sub>f fa\n       pc\\<^sub>f frame\\<^sub>f' st.\n       \\<lbrakk>Finca_get F1 g = Some gd;\n        arity gd \\<le> length \\<Sigma>\\<^sub>f;\n        pc\\<^sub>g = length (body gd);\n        Frame f pc \\<Sigma>1 = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g;\n        frame\\<^sub>f = Frame fa pc\\<^sub>f \\<Sigma>\\<^sub>f;\n        frame\\<^sub>f' =\n        Frame fa (Suc pc\\<^sub>f)\n         (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f);\n        frame\\<^sub>f # st = st1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s2'.\n                            Subx.step\n                             (State F2 H (Frame f pc \\<Sigma>2 # st2))\n                             s2' \\<and>\n                            State F1 H (frame\\<^sub>f' # st) \\<sim> s2'", "show ?case (is \"\\<exists>x. ?STEP x \\<and> ?MATCH x\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g' # st1') \\<sim> s2'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g' # st1') \\<sim> s2'", "let ?s1' = \"State F2 H (Frame g (Suc pc\\<^sub>g) (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) # st2')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g' # st1') \\<sim> s2'", "have \"?STEP ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n     (State F2 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n        st2'))", "unfolding st2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Subx.step\n     (State F2 H\n       (Frame f pc \\<Sigma>2 # Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'))\n     (State F2 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n        st2'))", "using step_fun_end st2_def rel_st1_st2"], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n\ngoal (1 subgoal):\n 1. Subx.step\n     (State F2 H\n       (Frame f pc \\<Sigma>2 # Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'))\n     (State F2 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n        st2'))", "using arities_fd1_fd2"], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  arity fd1 = arity fd2\n\ngoal (1 subgoal):\n 1. Subx.step\n     (State F2 H\n       (Frame f pc \\<Sigma>2 # Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'))\n     (State F2 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n        st2'))", "using rel_fundef_body_length[OF rel_fd1_fd2]"], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  arity fd1 = arity fd2\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. Subx.step\n     (State F2 H\n       (Frame f pc \\<Sigma>2 # Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'))\n     (State F2 H\n       (Frame g (Suc pc\\<^sub>g)\n         (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n        st2'))", "by (auto intro!: Subx.step_fun_end[OF \\<open>Fubx_get F2 f = Some fd2\\<close>]\n              elim!: rel_stacktraces.cases[of _ \"_ # _\"])"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2'))\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g' # st1') \\<sim> s2'", "moreover"], ["proof (state)\nthis:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2'))\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g' # st1') \\<sim> s2'", "have \"?MATCH ?s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. State F1 H (frame\\<^sub>g' # st1') \\<sim>\n    State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. State F1 H (frame\\<^sub>g' # st1') \\<sim>\n    State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2')", "have \"map typeof \\<Sigma>2 = [None]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map typeof \\<Sigma>2 = [None]", "using step_fun_end st2_def rel_st1_st2"], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n\ngoal (1 subgoal):\n 1. map typeof \\<Sigma>2 = [None]", "using rel_fd1_fd2 sp_full sp_prefix"], ["proof (prove)\nusing this:\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n  Subx.sp (Fubx_get F2) (body fd2) (replicate (arity fd2) None) = Ok [None]\n  Subx.sp (Fubx_get F2) (take pc (body fd2)) (replicate (arity fd2) None) =\n  Ok (map typeof \\<Sigma>2)\n\ngoal (1 subgoal):\n 1. map typeof \\<Sigma>2 = [None]", "by (auto elim!: rel_stacktraces.cases[of _ \"_ # _\"])"], ["proof (state)\nthis:\n  map typeof \\<Sigma>2 = [None]\n\ngoal (1 subgoal):\n 1. State F1 H (frame\\<^sub>g' # st1') \\<sim>\n    State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2')", "thus ?thesis"], ["proof (prove)\nusing this:\n  map typeof \\<Sigma>2 = [None]\n\ngoal (1 subgoal):\n 1. State F1 H (frame\\<^sub>g' # st1') \\<sim>\n    State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2')", "using step_fun_end st2_def rel_st1_st2"], ["proof (prove)\nusing this:\n  map typeof \\<Sigma>2 = [None]\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n\ngoal (1 subgoal):\n 1. State F1 H (frame\\<^sub>g' # st1') \\<sim>\n    State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2')", "using arities_fd1_fd2 \\<Sigma>1_def F2_f all_dyn_prefix_\\<Sigma>2\\<^sub>g"], ["proof (prove)\nusing this:\n  map typeof \\<Sigma>2 = [None]\n  Finca_get F1 f' = Some fd1\n  arity fd1 \\<le> length \\<Sigma>1\\<^sub>g\n  pc' = length (body fd1)\n  Frame f pc \\<Sigma>1 = Frame f' pc' \\<Sigma>1'\n  frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>1\\<^sub>g\n  frame\\<^sub>g' =\n  Frame g (Suc pc\\<^sub>g) (\\<Sigma>1' @ drop (arity fd1) \\<Sigma>1\\<^sub>g)\n  frame\\<^sub>g # st1' = st1\n  st2 = Frame g pc\\<^sub>g \\<Sigma>2\\<^sub>g # st2'\n  rel_stacktraces (Fubx_get F2) st1 st2 (Some f)\n  arity fd1 = arity fd2\n  \\<Sigma>1 = norm_stack \\<Sigma>2\n  Fubx_get F2 f = Some fd2\n  list_all (\\<lambda>x. x = None)\n   (map typeof (take (arity fd2) \\<Sigma>2\\<^sub>g))\n\ngoal (1 subgoal):\n 1. State F1 H (frame\\<^sub>g' # st1') \\<sim>\n    State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2')", "by (auto intro!: match.intros rel_stacktraces.intros\n                intro: rel_F1_F2 sp_F2\n                elim!: rel_stacktraces.cases[of _ \"_ # _\"]\n                dest: list_all_eq_const_imp_replicate\n                simp: take_Suc_conv_app_nth Let_def drop_norm_stack take_map drop_map\n                simp: is_valid_fun_call_def)"], ["proof (state)\nthis:\n  State F1 H (frame\\<^sub>g' # st1') \\<sim>\n  State F2 H\n   (Frame g (Suc pc\\<^sub>g)\n     (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n    st2')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  State F1 H (frame\\<^sub>g' # st1') \\<sim>\n  State F2 H\n   (Frame g (Suc pc\\<^sub>g)\n     (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n    st2')\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g' # st1') \\<sim> s2'", "ultimately"], ["proof (chain)\npicking this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2'))\n  State F1 H (frame\\<^sub>g' # st1') \\<sim>\n  State F2 H\n   (Frame g (Suc pc\\<^sub>g)\n     (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n    st2')", "show ?thesis"], ["proof (prove)\nusing this:\n  Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2))\n   (State F2 H\n     (Frame g (Suc pc\\<^sub>g)\n       (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n      st2'))\n  State F1 H (frame\\<^sub>g' # st1') \\<sim>\n  State F2 H\n   (Frame g (Suc pc\\<^sub>g)\n     (\\<Sigma>2 @ drop (arity fd2) \\<Sigma>2\\<^sub>g) #\n    st2')\n\ngoal (1 subgoal):\n 1. \\<exists>s2'.\n       Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n       State F1 H (frame\\<^sub>g' # st1') \\<sim> s2'", "by auto"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (frame\\<^sub>g' # st1') \\<sim> s2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     State F1 H (frame\\<^sub>g' # st1') \\<sim> s2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s2'.\n     Subx.step (State F2 H (Frame f pc \\<Sigma>2 # st2)) s2' \\<and>\n     s1' \\<sim> s2'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s2'. Subx.step (State F2 H st2) s2' \\<and> s1' \\<sim> s2'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma match_final_forward:\n  \"s1 \\<sim> s2 \\<Longrightarrow> Sinca.final s1 \\<Longrightarrow> Subx.final s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<sim> s2; Sinca.final s1\\<rbrakk>\n    \\<Longrightarrow> Subx.final s2", "proof (induction s1 s2 rule: match.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.final (State F1 H st1)\\<rbrakk>\n       \\<Longrightarrow> Subx.final (State F2 H st2)", "case (1 F1 F2 st1 st2 H)"], ["proof (state)\nthis:\n  rel_fundefs (Finca_get F1) (Fubx_get F2)\n  sp_fundefs (Fubx_get F2)\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n  Sinca.final (State F1 H st1)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.final (State F1 H st1)\\<rbrakk>\n       \\<Longrightarrow> Subx.final (State F2 H st2)", "obtain f fd1 pc \\<Sigma>1 where\n    st1_def: \"st1 = [Frame f pc \\<Sigma>1]\" and\n    F1_f: \"Finca_get F1 f = Some fd1\" and\n    pc_def: \"pc = length (body fd1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f pc \\<Sigma>1 fd1.\n        \\<lbrakk>st1 = [Frame f pc \\<Sigma>1]; Finca_get F1 f = Some fd1;\n         pc = length (body fd1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Sinca.final (State F1 H st1)\\<close>"], ["proof (prove)\nusing this:\n  Sinca.final (State F1 H st1)\n\ngoal (1 subgoal):\n 1. (\\<And>f pc \\<Sigma>1 fd1.\n        \\<lbrakk>st1 = [Frame f pc \\<Sigma>1]; Finca_get F1 f = Some fd1;\n         pc = length (body fd1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: Sinca.final.cases)"], ["proof (state)\nthis:\n  st1 = [Frame f pc \\<Sigma>1]\n  Finca_get F1 f = Some fd1\n  pc = length (body fd1)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.final (State F1 H st1)\\<rbrakk>\n       \\<Longrightarrow> Subx.final (State F2 H st2)", "obtain \\<Sigma>2 where st2_def: \"st2 = [Frame f pc \\<Sigma>2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>2.\n        st2 = [Frame f pc \\<Sigma>2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>rel_stacktraces (Fubx_get F2) st1 st2 None\\<close>"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) st1 st2 None\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>2.\n        st2 = [Frame f pc \\<Sigma>2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding st1_def"], ["proof (prove)\nusing this:\n  rel_stacktraces (Fubx_get F2) [Frame f pc \\<Sigma>1] st2 None\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>2.\n        st2 = [Frame f pc \\<Sigma>2] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: rel_stacktraces.cases)"], ["proof (state)\nthis:\n  st2 = [Frame f pc \\<Sigma>2]\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.final (State F1 H st1)\\<rbrakk>\n       \\<Longrightarrow> Subx.final (State F2 H st2)", "obtain fd2 where F2_f: \"Fubx_get F2 f = Some fd2\" and rel_fd1_fd2: \"rel_fundef norm_eq fd1 fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>fd2.\n        \\<lbrakk>Fubx_get F2 f = Some fd2;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rel_fundefs_Some1[OF \\<open>rel_fundefs (Finca_get F1) (Fubx_get F2)\\<close> F1_f]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     Fubx_get F2 f = Some z \\<and>\n     rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 z\n\ngoal (1 subgoal):\n 1. (\\<And>fd2.\n        \\<lbrakk>Fubx_get F2 f = Some fd2;\n         rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Fubx_get F2 f = Some fd2\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.final (State F1 H st1)\\<rbrakk>\n       \\<Longrightarrow> Subx.final (State F2 H st2)", "have \"length (body fd1) = length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (body fd1) = length (body fd2)", "using rel_fd1_fd2"], ["proof (prove)\nusing this:\n  rel_fundef (\\<lambda>x y. x = norm_instr y) fd1 fd2\n\ngoal (1 subgoal):\n 1. length (body fd1) = length (body fd2)", "by simp"], ["proof (state)\nthis:\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. \\<And>F1 F2 st1 st2 H.\n       \\<lbrakk>rel_fundefs (Finca_get F1) (Fubx_get F2);\n        sp_fundefs (Fubx_get F2);\n        rel_stacktraces (Fubx_get F2) st1 st2 None;\n        Sinca.final (State F1 H st1)\\<rbrakk>\n       \\<Longrightarrow> Subx.final (State F2 H st2)", "thus ?case"], ["proof (prove)\nusing this:\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. Subx.final (State F2 H st2)", "unfolding st2_def pc_def"], ["proof (prove)\nusing this:\n  length (body fd1) = length (body fd2)\n\ngoal (1 subgoal):\n 1. Subx.final (State F2 H [Frame f (length (body fd1)) \\<Sigma>2])", "using F2_f"], ["proof (prove)\nusing this:\n  length (body fd1) = length (body fd2)\n  Fubx_get F2 f = Some fd2\n\ngoal (1 subgoal):\n 1. Subx.final (State F2 H [Frame f (length (body fd1)) \\<Sigma>2])", "by (auto intro: Subx.final.intros)"], ["proof (state)\nthis:\n  Subx.final (State F2 H st2)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale inca_ubx_forward_simulation:\n  forward_simulation Sinca.step Subx.step Sinca.final Subx.final \"\\<lambda>_ _. False\" \"\\<lambda>_. match\""], ["proof (prove)\ngoal (1 subgoal):\n 1. forward_simulation Sinca.step Subx.step Sinca.final Subx.final\n     (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>))", "using match_final_forward forward_lockstep_simulation"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 \\<sim> ?s2.0; Sinca.final ?s1.0\\<rbrakk>\n  \\<Longrightarrow> Subx.final ?s2.0\n  \\<lbrakk>Sinca.step ?s1.0 ?s1'; ?s1.0 \\<sim> ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'. Subx.step ?s2.0 s2' \\<and> ?s1' \\<sim> s2'\n\ngoal (1 subgoal):\n 1. forward_simulation Sinca.step Subx.step Sinca.final Subx.final\n     (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>))", "using lockstep_to_plus_forward_simulation[of match Sinca.step _ Subx.step]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s1.0 \\<sim> ?s2.0; Sinca.final ?s1.0\\<rbrakk>\n  \\<Longrightarrow> Subx.final ?s2.0\n  \\<lbrakk>Sinca.step ?s1.0 ?s1'; ?s1.0 \\<sim> ?s2.0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'. Subx.step ?s2.0 s2' \\<and> ?s1' \\<sim> s2'\n  \\<lbrakk>\\<And>s1 s2 s2'.\n              \\<lbrakk>s1 \\<sim> s2; Sinca.step s1 ?s1'\\<rbrakk>\n              \\<Longrightarrow> \\<exists>s2'.\n                                   Subx.step s2 s2' \\<and> ?s1' \\<sim> s2';\n   ?s1.0 \\<sim> ?s2.0; Sinca.step ?s1.0 ?s1'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s2'.\n                       Subx.step\\<^sup>+\\<^sup>+ ?s2.0 s2' \\<and>\n                       ?s1' \\<sim> s2'\n\ngoal (1 subgoal):\n 1. forward_simulation Sinca.step Subx.step Sinca.final Subx.final\n     (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>))", "by unfold_locales auto"], ["", "section \\<open>Bisimulation\\<close>"], ["", "sublocale inca_ubx_bisimulation:\n  bisimulation Sinca.step Subx.step Sinca.final Subx.final \"\\<lambda>_ _. False\" \"\\<lambda>_. match\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimulation Sinca.step Subx.step Sinca.final Subx.final\n     (\\<lambda>_ _. False) (\\<lambda>_. (\\<sim>))", "by unfold_locales"], ["", "end"], ["", "end"]]}