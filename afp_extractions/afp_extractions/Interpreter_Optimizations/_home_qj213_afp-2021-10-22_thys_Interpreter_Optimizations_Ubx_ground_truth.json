{"file_name": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations/Ubx.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations", "problem_names": ["lemma generalize_instr_idempotent[simp]:\n  \"generalize_instr (generalize_instr x) = generalize_instr x\"", "lemma generalize_instr_idempotent_comp[simp]:\n  \"generalize_instr \\<circ> generalize_instr = generalize_instr\"", "lemma generalize_fundef_length[simp]: \"length (body (generalize_fundef fd)) = length (body fd)\"", "lemma body_generalize_fundef[simp]: \"body (generalize_fundef fd) = map generalize_instr (body fd)\"", "lemma arity_generalize_fundef[simp]: \"arity (generalize_fundef fd2) = arity fd2\"", "theorem step_deterministic: \"s1 \\<rightarrow> s2 \\<Longrightarrow> s1 \\<rightarrow> s3 \\<Longrightarrow> s2 = s3\"", "lemma final_finished: \"final s \\<Longrightarrow> finished step s\""], "translations": [["", "lemma generalize_instr_idempotent[simp]:\n  \"generalize_instr (generalize_instr x) = generalize_instr x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generalize_instr (generalize_instr x) = generalize_instr x", "by (cases x) simp_all"], ["", "lemma generalize_instr_idempotent_comp[simp]:\n  \"generalize_instr \\<circ> generalize_instr = generalize_instr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. generalize_instr \\<circ> generalize_instr = generalize_instr", "by fastforce"], ["", "lemma generalize_fundef_length[simp]: \"length (body (generalize_fundef fd)) = length (body fd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (body (generalize_fundef fd)) = length (body fd)", "by (cases fd) simp"], ["", "lemma body_generalize_fundef[simp]: \"body (generalize_fundef fd) = map generalize_instr (body fd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. body (generalize_fundef fd) = map generalize_instr (body fd)", "by (cases fd) simp"], ["", "lemma arity_generalize_fundef[simp]: \"arity (generalize_fundef fd2) = arity fd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity (generalize_fundef fd2) = arity fd2", "by (cases fd2) simp"], ["", "inductive final where\n  \"F_get F f = Some fd \\<Longrightarrow> pc = length (body fd) \\<Longrightarrow> final (State F H [Frame f pc \\<Sigma>])\""], ["", "subsection \\<open>Semantics\\<close>"], ["", "inductive step (infix \"\\<rightarrow>\" 55) where\n  step_push:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IPush d \\<Longrightarrow>\n    State F H (Frame f pc \\<Sigma> # st) \\<rightarrow> State F H (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st)\" |\n\n  step_push_ubx1:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IPushUbx1 n \\<Longrightarrow>\n    State F H (Frame f pc \\<Sigma> # st) \\<rightarrow> State F H (Frame f (Suc pc) (OpUbx1 n # \\<Sigma>) # st)\" |\n\n  step_push_ubx2:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IPushUbx2 b \\<Longrightarrow>\n    State F H (Frame f pc \\<Sigma> # st) \\<rightarrow> State F H (Frame f (Suc pc) (OpUbx2 b # \\<Sigma>) # st)\" |\n\n  step_pop:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IPop \\<Longrightarrow>\n    State F H (Frame f pc (x # \\<Sigma>) # st) \\<rightarrow> State F H (Frame f (Suc pc) \\<Sigma> # st)\" |\n\n  step_load:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = ILoad x \\<Longrightarrow>\n    cast_Dyn i = Some i' \\<Longrightarrow> heap_get H (x, i') = Some d \\<Longrightarrow>\n    State F H (Frame f pc (i # \\<Sigma>) # st) \\<rightarrow> State F H (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st)\" |\n\n  step_load_ubx_hit:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = ILoadUbx \\<tau> x \\<Longrightarrow>\n    cast_Dyn i = Some i' \\<Longrightarrow> heap_get H (x, i') = Some d \\<Longrightarrow> unbox \\<tau> d = Some blob \\<Longrightarrow>\n    State F H (Frame f pc (i # \\<Sigma>) # st) \\<rightarrow> State F H (Frame f (Suc pc) (blob # \\<Sigma>) # st)\" |\n\n  step_load_ubx_miss:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = ILoadUbx \\<tau> x \\<Longrightarrow>\n    cast_Dyn i = Some i' \\<Longrightarrow> heap_get H (x, i') = Some d \\<Longrightarrow> unbox \\<tau> d = None \\<Longrightarrow>\n    F_add F f (generalize_fundef fd) = F' \\<Longrightarrow>\n    State F H (Frame f pc (i # \\<Sigma>) # st) \\<rightarrow> State F' H (box_stack f (Frame f (Suc pc) (OpDyn d # \\<Sigma>) # st))\" |\n\n  step_store:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IStore x \\<Longrightarrow>\n    cast_Dyn i = Some i' \\<Longrightarrow> cast_Dyn y = Some d \\<Longrightarrow> heap_add H (x, i') d = H' \\<Longrightarrow>\n    State F H (Frame f pc (i # y # \\<Sigma>) # st) \\<rightarrow> State F H' (Frame f (Suc pc) \\<Sigma> # st)\" |\n\n  step_store_ubx:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IStoreUbx \\<tau> x \\<Longrightarrow>\n    cast_Dyn i = Some i' \\<Longrightarrow> cast_and_box \\<tau> blob = Some d \\<Longrightarrow> heap_add H (x, i') d = H' \\<Longrightarrow>\n    State F H (Frame f pc (i # blob # \\<Sigma>) # st) \\<rightarrow> State F H' (Frame f (Suc pc) \\<Sigma> # st)\" |\n\n  step_op:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IOp op \\<Longrightarrow>\n    \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar \\<Longrightarrow> ar \\<le> length \\<Sigma> \\<Longrightarrow>\n    traverse cast_Dyn (take ar \\<Sigma>) = Some \\<Sigma>' \\<Longrightarrow>\n    \\<II>\\<nn>\\<ll> op \\<Sigma>' = None \\<Longrightarrow> \\<OO>\\<pp> op \\<Sigma>' = x \\<Longrightarrow>\n    State F H (Frame f pc \\<Sigma> # st) \\<rightarrow> State F H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>) # st)\" |\n\n  step_op_inl:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IOp op \\<Longrightarrow>\n    \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar \\<Longrightarrow> ar \\<le> length \\<Sigma> \\<Longrightarrow>\n    traverse cast_Dyn (take ar \\<Sigma>) = Some \\<Sigma>' \\<Longrightarrow>\n    \\<II>\\<nn>\\<ll> op \\<Sigma>' = Some opinl \\<Longrightarrow> \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x \\<Longrightarrow>\n    F_add F f (rewrite_fundef_body fd pc (IOpInl opinl)) = F' \\<Longrightarrow>\n    State F H (Frame f pc \\<Sigma> # st) \\<rightarrow> State F' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>) # st)\" |\n\n  step_op_inl_hit:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IOpInl opinl \\<Longrightarrow>\n    \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar \\<Longrightarrow> ar \\<le> length \\<Sigma> \\<Longrightarrow>\n    traverse cast_Dyn (take ar \\<Sigma>) = Some \\<Sigma>' \\<Longrightarrow>\n    \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>' \\<Longrightarrow> \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x \\<Longrightarrow>\n    State F H (Frame f pc \\<Sigma> # st) \\<rightarrow> State F H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>) # st)\" |\n\n  step_op_inl_miss:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IOpInl opinl \\<Longrightarrow>\n    \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl) = ar \\<Longrightarrow> ar \\<le> length \\<Sigma> \\<Longrightarrow>\n    traverse cast_Dyn (take ar \\<Sigma>) = Some \\<Sigma>' \\<Longrightarrow>\n    \\<not> \\<II>\\<ss>\\<II>\\<nn>\\<ll> opinl \\<Sigma>' \\<Longrightarrow> \\<II>\\<nn>\\<ll>\\<OO>\\<pp> opinl \\<Sigma>' = x \\<Longrightarrow>\n    F_add F f (rewrite_fundef_body fd pc (IOp (\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl))) = F' \\<Longrightarrow>\n    State F H (Frame f pc \\<Sigma> # st) \\<rightarrow> State F' H (Frame f (Suc pc) (OpDyn x # drop ar \\<Sigma>) # st)\" |\n\n  step_op_ubx:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = IOpUbx opubx \\<Longrightarrow>\n    \\<DD>\\<ee>\\<II>\\<nn>\\<ll> (\\<BB>\\<oo>\\<xx> opubx) = op \\<Longrightarrow> \\<AA>\\<rr>\\<ii>\\<tt>\\<yy> op = ar \\<Longrightarrow> ar \\<le> length \\<Sigma> \\<Longrightarrow>\n    \\<UU>\\<bb>\\<xx>\\<OO>\\<pp> opubx (take ar \\<Sigma>) = Some x \\<Longrightarrow>\n    State F H (Frame f pc \\<Sigma> # st) \\<rightarrow> State F H (Frame f (Suc pc) (x # drop ar \\<Sigma>) # st)\" |\n\n  step_cjump_true:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = ICJump n \\<Longrightarrow>\n    cast_Dyn y = Some d \\<Longrightarrow> is_true d \\<Longrightarrow>\n    State F H (Frame f pc (y # \\<Sigma>) # st) \\<rightarrow> State F H (Frame f n \\<Sigma> # st)\" |\n\n  step_cjump_false:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = ICJump n \\<Longrightarrow>\n    cast_Dyn y = Some d \\<Longrightarrow> is_false d \\<Longrightarrow>\n    State F H (Frame f pc (y # \\<Sigma>) # st) \\<rightarrow> State F H (Frame f (Suc pc) \\<Sigma> # st)\" |\n\n  step_fun_call:\n    \"F_get F f = Some fd \\<Longrightarrow> pc < length (body fd) \\<Longrightarrow> body fd ! pc = ICall g \\<Longrightarrow>\n    F_get F g = Some gd \\<Longrightarrow> arity gd = ar \\<Longrightarrow> ar \\<le> length \\<Sigma> \\<Longrightarrow>\n    frame\\<^sub>f = Frame f pc \\<Sigma> \\<Longrightarrow> list_all is_dyn_operand (take ar \\<Sigma>) \\<Longrightarrow>\n    frame\\<^sub>g = Frame g 0 (take ar \\<Sigma>) \\<Longrightarrow>\n    State F H (frame\\<^sub>f # st) \\<rightarrow> State F H (frame\\<^sub>g # frame\\<^sub>f # st)\" |\n\n  step_fun_end:\n    \"F_get F g = Some gd \\<Longrightarrow> arity gd \\<le> length \\<Sigma>\\<^sub>f \\<Longrightarrow> pc\\<^sub>g = length (body gd) \\<Longrightarrow>\n    frame\\<^sub>g = Frame g pc\\<^sub>g \\<Sigma>\\<^sub>g \\<Longrightarrow> frame\\<^sub>f = Frame f pc\\<^sub>f \\<Sigma>\\<^sub>f \\<Longrightarrow>\n    frame\\<^sub>f' = Frame f (Suc pc\\<^sub>f) (\\<Sigma>\\<^sub>g @ drop (arity gd) \\<Sigma>\\<^sub>f) \\<Longrightarrow>\n    State F H (frame\\<^sub>g # frame\\<^sub>f # st) \\<rightarrow> State F H (frame\\<^sub>f' # st)\""], ["", "theorem step_deterministic: \"s1 \\<rightarrow> s2 \\<Longrightarrow> s1 \\<rightarrow> s3 \\<Longrightarrow> s2 = s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s1 \\<rightarrow> s2; s1 \\<rightarrow> s3\\<rbrakk>\n    \\<Longrightarrow> s2 = s3", "by (induction rule: step.induct;\n      erule step.cases; safe;\n      auto dest: is_true_and_is_false_implies_False)"], ["", "lemma final_finished: \"final s \\<Longrightarrow> finished step s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. final s \\<Longrightarrow> finished (\\<rightarrow>) s", "unfolding finished_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. final s \\<Longrightarrow> \\<not> Ex ((\\<rightarrow>) s)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>final s; Ex ((\\<rightarrow>) s)\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"final s\" and \"\\<exists>x. step s x\""], ["proof (state)\nthis:\n  final s\n  \\<exists>x. s \\<rightarrow> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>final s; Ex ((\\<rightarrow>) s)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  final s\n  \\<exists>x. s \\<rightarrow> x", "obtain s' where \"step s s'\""], ["proof (prove)\nusing this:\n  final s\n  \\<exists>x. s \\<rightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        s \\<rightarrow> s' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>final s; Ex ((\\<rightarrow>) s)\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  s \\<rightarrow> s'\n\ngoal (1 subgoal):\n 1. False", "using \\<open>final s\\<close>"], ["proof (prove)\nusing this:\n  s \\<rightarrow> s'\n  final s\n\ngoal (1 subgoal):\n 1. False", "by (auto elim!: step.cases final.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale ubx_sem: semantics step final"], ["proof (prove)\ngoal (1 subgoal):\n 1. semantics (\\<rightarrow>) final", "using final_finished step_deterministic"], ["proof (prove)\nusing this:\n  final ?s \\<Longrightarrow> finished (\\<rightarrow>) ?s\n  \\<lbrakk>?s1.0 \\<rightarrow> ?s2.0; ?s1.0 \\<rightarrow> ?s3.0\\<rbrakk>\n  \\<Longrightarrow> ?s2.0 = ?s3.0\n\ngoal (1 subgoal):\n 1. semantics (\\<rightarrow>) final", "by unfold_locales"], ["", "inductive load :: \"('fenv, 'a, 'fun) prog \\<Rightarrow> ('fenv, 'a, ('fun, 'b) frame) state \\<Rightarrow> bool\" where\n  \"F_get F main = Some fd \\<Longrightarrow> arity fd = 0 \\<Longrightarrow>\n  load (Prog F H main) (State F H [Frame main 0 []])\""], ["", "sublocale inca_lang: language step final load"], ["proof (prove)\ngoal (1 subgoal):\n 1. language (\\<rightarrow>) final", "by unfold_locales"], ["", "end"], ["", "end"]]}