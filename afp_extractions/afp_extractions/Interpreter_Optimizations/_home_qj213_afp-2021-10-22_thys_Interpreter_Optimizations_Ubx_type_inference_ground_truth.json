{"file_name": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations/Ubx_type_inference.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations", "problem_names": ["lemma sp_instr_no_jump: \"sp_instr F instr \\<Sigma> = Ok type \\<Longrightarrow> \\<not> is_jump instr\"", "lemma map_constant[simp]: \"\\<forall>x \\<in> set xs. x = y \\<Longrightarrow> map (\\<lambda>_. y) xs = xs\"", "lemma sp_generalize_instr:\n  assumes \"sp_instr F x \\<Sigma> = Ok \\<Sigma>'\"\n  shows \"sp_instr F (generalize_instr x) (map (\\<lambda>_. None) \\<Sigma>) = Ok (map (\\<lambda>_. None) \\<Sigma>')\"", "lemma map_typeof_box: \"map typeof (map box_operand \\<Sigma>) = replicate (length \\<Sigma>) None\"", "lemma sp_no_jump: \"sp F xs \\<Sigma> = Ok type \\<Longrightarrow> \\<forall>x \\<in> set xs. \\<not> is_jump x\"", "lemma sp_append: \"sp F (xs @ ys) \\<Sigma> = sp F xs \\<Sigma> \\<bind> sp F ys\"", "lemmas sp_eq_bind_take_drop =\n  sp_append[of _ \"take n xs\" \"drop n xs\" for n xs, unfolded append_take_drop_id]", "lemma sp_generalize:\n  assumes \"sp F xs \\<Sigma> = Ok \\<Sigma>'\"\n  shows \"sp F (map generalize_instr xs) (map (\\<lambda>_. None) \\<Sigma>) = Ok (map (\\<lambda>_. None) \\<Sigma>')\"", "lemma sp_generalize2:\n  assumes \"sp F xs (replicate n None) = Ok \\<Sigma>'\"\n  shows \"sp F (map generalize_instr xs) (replicate n None) = Ok (map (\\<lambda>_. None) \\<Sigma>')\"", "lemma comp_K[simp]: \"(\\<lambda>_. x) \\<circ> f = (\\<lambda>_. x)\"", "lemma is_ok_sp_generalize:\n  assumes \"is_ok (sp F xs (map (\\<lambda>_. None) \\<Sigma>))\"\n    shows \"is_ok (sp F (map generalize_instr xs) (map (\\<lambda>_. None) \\<Sigma>))\"", "lemma is_ok_sp_generalize2:\n  assumes \"is_ok (sp F xs (replicate n None))\"\n  shows \"is_ok (sp F (map generalize_instr xs) (replicate n None))\"", "lemma sp_instr_op:\n  assumes \"\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl = op\"\n  shows \"sp_instr F (IOp op) \\<Sigma> = sp_instr F (IOpInl opinl) \\<Sigma>\"", "lemma sp_list_update:\n  assumes\n    \"n < length xs\" and\n    \"\\<forall>\\<Sigma>. sp_instr F (xs ! n) \\<Sigma> = sp_instr F x \\<Sigma>\"\n  shows \"sp F (xs[n := x]) = sp F xs\"", "lemma sp_list_update_eq_Ok:\n  assumes\n    \"n < length xs\" and\n    \"\\<forall>\\<Sigma>. sp_instr F (xs ! n) \\<Sigma> = sp_instr F x \\<Sigma>\" and\n    \"sp F xs ys = Ok zs\"\n  shows \"sp F (xs[n := x]) ys = Ok zs\"", "lemma is_ok_sp_list_update:\n  assumes\n    \"is_ok (sp F xs types)\" and\n    \"pc < length xs\" and\n    \"\\<forall>\\<Sigma>. sp_instr F (xs ! pc) \\<Sigma> = sp_instr F instr \\<Sigma>\"\n  shows \"is_ok (sp F (xs[pc := instr]) types)\"", "lemmas sp_rewrite = sp_list_update[folded rewrite_def]", "lemmas sp_rewrite_eq_Ok = sp_list_update_eq_Ok[folded rewrite_def]", "lemmas is_ok_sp_rewrite = is_ok_sp_list_update[folded rewrite_def]"], "translations": [["", "lemma sp_instr_no_jump: \"sp_instr F instr \\<Sigma> = Ok type \\<Longrightarrow> \\<not> is_jump instr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_instr F instr \\<Sigma> = Ok type \\<Longrightarrow>\n    \\<not> is_jump instr", "by (induction instr \\<Sigma> rule: sp_instr.induct) simp_all"], ["", "lemma map_constant[simp]: \"\\<forall>x \\<in> set xs. x = y \\<Longrightarrow> map (\\<lambda>_. y) xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = y \\<Longrightarrow>\n    map (\\<lambda>_. y) xs = xs", "by (simp add: map_idI)"], ["", "lemma sp_generalize_instr:\n  assumes \"sp_instr F x \\<Sigma> = Ok \\<Sigma>'\"\n  shows \"sp_instr F (generalize_instr x) (map (\\<lambda>_. None) \\<Sigma>) = Ok (map (\\<lambda>_. None) \\<Sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_instr F (generalize_instr x) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "using assms"], ["proof (prove)\nusing this:\n  sp_instr F x \\<Sigma> = Ok \\<Sigma>'\n\ngoal (1 subgoal):\n 1. sp_instr F (generalize_instr x) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "apply (induction F x \\<Sigma> rule: sp_instr.induct;\n      (auto simp: Let_def take_map drop_map; fail)?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vm_ opubx \\<Sigma>.\n       sp_instr vm_ (IOpUbx opubx) \\<Sigma> = Ok \\<Sigma>' \\<Longrightarrow>\n       sp_instr vm_ (generalize_instr (IOpUbx opubx))\n        (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')", "subgoal for _ opubx"], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_instr vm_ (IOpUbx opubx) \\<Sigma>_ = Ok \\<Sigma>' \\<Longrightarrow>\n    sp_instr vm_ (generalize_instr (IOpUbx opubx))\n     (map Map.empty \\<Sigma>_) =\n    Ok (map Map.empty \\<Sigma>')", "apply (cases \"\\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>sp_instr vm_ (IOpUbx opubx) \\<Sigma>_ = Ok \\<Sigma>';\n        \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp> opubx = (a, b)\\<rbrakk>\n       \\<Longrightarrow> sp_instr vm_ (generalize_instr (IOpUbx opubx))\n                          (map Map.empty \\<Sigma>_) =\n                         Ok (map Map.empty \\<Sigma>')", "by (auto simp add: Let_def take_map drop_map map_replicate_const \\<TT>\\<yy>\\<pp>\\<ee>\\<OO>\\<ff>\\<OO>\\<pp>_\\<AA>\\<rr>\\<ii>\\<tt>\\<yy>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_typeof_box: \"map typeof (map box_operand \\<Sigma>) = replicate (length \\<Sigma>) None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map typeof (map box_operand \\<Sigma>) = replicate (length \\<Sigma>) None", "proof (induction \\<Sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. map typeof (map box_operand []) = replicate (length []) None\n 2. \\<And>a \\<Sigma>.\n       map typeof (map box_operand \\<Sigma>) =\n       replicate (length \\<Sigma>) None \\<Longrightarrow>\n       map typeof (map box_operand (a # \\<Sigma>)) =\n       replicate (length (a # \\<Sigma>)) None", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. map typeof (map box_operand []) = replicate (length []) None\n 2. \\<And>a \\<Sigma>.\n       map typeof (map box_operand \\<Sigma>) =\n       replicate (length \\<Sigma>) None \\<Longrightarrow>\n       map typeof (map box_operand (a # \\<Sigma>)) =\n       replicate (length (a # \\<Sigma>)) None", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map typeof (map box_operand []) = replicate (length []) None", "by simp"], ["proof (state)\nthis:\n  map typeof (map box_operand []) = replicate (length []) None\n\ngoal (1 subgoal):\n 1. \\<And>a \\<Sigma>.\n       map typeof (map box_operand \\<Sigma>) =\n       replicate (length \\<Sigma>) None \\<Longrightarrow>\n       map typeof (map box_operand (a # \\<Sigma>)) =\n       replicate (length (a # \\<Sigma>)) None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<Sigma>.\n       map typeof (map box_operand \\<Sigma>) =\n       replicate (length \\<Sigma>) None \\<Longrightarrow>\n       map typeof (map box_operand (a # \\<Sigma>)) =\n       replicate (length (a # \\<Sigma>)) None", "case (Cons x xs)"], ["proof (state)\nthis:\n  map typeof (map box_operand xs) = replicate (length xs) None\n\ngoal (1 subgoal):\n 1. \\<And>a \\<Sigma>.\n       map typeof (map box_operand \\<Sigma>) =\n       replicate (length \\<Sigma>) None \\<Longrightarrow>\n       map typeof (map box_operand (a # \\<Sigma>)) =\n       replicate (length (a # \\<Sigma>)) None", "then"], ["proof (chain)\npicking this:\n  map typeof (map box_operand xs) = replicate (length xs) None", "show ?case"], ["proof (prove)\nusing this:\n  map typeof (map box_operand xs) = replicate (length xs) None\n\ngoal (1 subgoal):\n 1. map typeof (map box_operand (x # xs)) = replicate (length (x # xs)) None", "by (cases x) simp_all"], ["proof (state)\nthis:\n  map typeof (map box_operand (x # xs)) = replicate (length (x # xs)) None\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Strongest postcondition of function definitions\\<close>"], ["", "fun sp :: \"('fun \\<Rightarrow> _ fundef option) \\<Rightarrow> _ list \\<Rightarrow> type option list \\<Rightarrow> (unit, type option list) result\" where\n  \"sp _ [] \\<Sigma> = Ok \\<Sigma>\" |\n  \"sp F (instr # p) \\<Sigma> = do {\n    \\<Sigma>' \\<leftarrow> sp_instr F instr \\<Sigma>;\n    sp F p \\<Sigma>'\n  }\""], ["", "lemma sp_no_jump: \"sp F xs \\<Sigma> = Ok type \\<Longrightarrow> \\<forall>x \\<in> set xs. \\<not> is_jump x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F xs \\<Sigma> = Ok type \\<Longrightarrow>\n    \\<forall>x\\<in>set xs. \\<not> is_jump x", "by (induction xs arbitrary: \\<Sigma>; auto dest: sp_instr_no_jump)"], ["", "lemma sp_append: \"sp F (xs @ ys) \\<Sigma> = sp F xs \\<Sigma> \\<bind> sp F ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F (xs @ ys) \\<Sigma> = sp F xs \\<Sigma> \\<bind> sp F ys", "proof (induction xs arbitrary: \\<Sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Sigma>.\n       sp F ([] @ ys) \\<Sigma> = sp F [] \\<Sigma> \\<bind> sp F ys\n 2. \\<And>a xs \\<Sigma>.\n       (\\<And>\\<Sigma>.\n           sp F (xs @ ys) \\<Sigma> =\n           sp F xs \\<Sigma> \\<bind> sp F ys) \\<Longrightarrow>\n       sp F ((a # xs) @ ys) \\<Sigma> =\n       sp F (a # xs) \\<Sigma> \\<bind> sp F ys", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>\\<Sigma>.\n       sp F ([] @ ys) \\<Sigma> = sp F [] \\<Sigma> \\<bind> sp F ys\n 2. \\<And>a xs \\<Sigma>.\n       (\\<And>\\<Sigma>.\n           sp F (xs @ ys) \\<Sigma> =\n           sp F xs \\<Sigma> \\<bind> sp F ys) \\<Longrightarrow>\n       sp F ((a # xs) @ ys) \\<Sigma> =\n       sp F (a # xs) \\<Sigma> \\<bind> sp F ys", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F ([] @ ys) \\<Sigma> = sp F [] \\<Sigma> \\<bind> sp F ys", "by simp"], ["proof (state)\nthis:\n  sp F ([] @ ys) \\<Sigma> = sp F [] \\<Sigma> \\<bind> sp F ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs \\<Sigma>.\n       (\\<And>\\<Sigma>.\n           sp F (xs @ ys) \\<Sigma> =\n           sp F xs \\<Sigma> \\<bind> sp F ys) \\<Longrightarrow>\n       sp F ((a # xs) @ ys) \\<Sigma> =\n       sp F (a # xs) \\<Sigma> \\<bind> sp F ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs \\<Sigma>.\n       (\\<And>\\<Sigma>.\n           sp F (xs @ ys) \\<Sigma> =\n           sp F xs \\<Sigma> \\<bind> sp F ys) \\<Longrightarrow>\n       sp F ((a # xs) @ ys) \\<Sigma> =\n       sp F (a # xs) \\<Sigma> \\<bind> sp F ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  sp F (xs @ ys) ?\\<Sigma>34 = sp F xs ?\\<Sigma>34 \\<bind> sp F ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs \\<Sigma>.\n       (\\<And>\\<Sigma>.\n           sp F (xs @ ys) \\<Sigma> =\n           sp F xs \\<Sigma> \\<bind> sp F ys) \\<Longrightarrow>\n       sp F ((a # xs) @ ys) \\<Sigma> =\n       sp F (a # xs) \\<Sigma> \\<bind> sp F ys", "then"], ["proof (chain)\npicking this:\n  sp F (xs @ ys) ?\\<Sigma>34 = sp F xs ?\\<Sigma>34 \\<bind> sp F ys", "show ?case"], ["proof (prove)\nusing this:\n  sp F (xs @ ys) ?\\<Sigma>34 = sp F xs ?\\<Sigma>34 \\<bind> sp F ys\n\ngoal (1 subgoal):\n 1. sp F ((x # xs) @ ys) \\<Sigma> = sp F (x # xs) \\<Sigma> \\<bind> sp F ys", "by (cases \"sp_instr F x \\<Sigma>\"; simp)"], ["proof (state)\nthis:\n  sp F ((x # xs) @ ys) \\<Sigma> = sp F (x # xs) \\<Sigma> \\<bind> sp F ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas sp_eq_bind_take_drop =\n  sp_append[of _ \"take n xs\" \"drop n xs\" for n xs, unfolded append_take_drop_id]"], ["", "lemma sp_generalize:\n  assumes \"sp F xs \\<Sigma> = Ok \\<Sigma>'\"\n  shows \"sp F (map generalize_instr xs) (map (\\<lambda>_. None) \\<Sigma>) = Ok (map (\\<lambda>_. None) \\<Sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F (map generalize_instr xs) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "using assms"], ["proof (prove)\nusing this:\n  sp F xs \\<Sigma> = Ok \\<Sigma>'\n\ngoal (1 subgoal):\n 1. sp F (map generalize_instr xs) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "proof (induction xs arbitrary: \\<Sigma> \\<Sigma>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Sigma> \\<Sigma>'.\n       sp F [] \\<Sigma> = Ok \\<Sigma>' \\<Longrightarrow>\n       sp F (map generalize_instr []) (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')\n 2. \\<And>a xs \\<Sigma> \\<Sigma>'.\n       \\<lbrakk>\\<And>\\<Sigma> \\<Sigma>'.\n                   sp F xs \\<Sigma> = Ok \\<Sigma>' \\<Longrightarrow>\n                   sp F (map generalize_instr xs) (map Map.empty \\<Sigma>) =\n                   Ok (map Map.empty \\<Sigma>');\n        sp F (a # xs) \\<Sigma> = Ok \\<Sigma>'\\<rbrakk>\n       \\<Longrightarrow> sp F (map generalize_instr (a # xs))\n                          (map Map.empty \\<Sigma>) =\n                         Ok (map Map.empty \\<Sigma>')", "case Nil"], ["proof (state)\nthis:\n  sp F [] \\<Sigma> = Ok \\<Sigma>'\n\ngoal (2 subgoals):\n 1. \\<And>\\<Sigma> \\<Sigma>'.\n       sp F [] \\<Sigma> = Ok \\<Sigma>' \\<Longrightarrow>\n       sp F (map generalize_instr []) (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')\n 2. \\<And>a xs \\<Sigma> \\<Sigma>'.\n       \\<lbrakk>\\<And>\\<Sigma> \\<Sigma>'.\n                   sp F xs \\<Sigma> = Ok \\<Sigma>' \\<Longrightarrow>\n                   sp F (map generalize_instr xs) (map Map.empty \\<Sigma>) =\n                   Ok (map Map.empty \\<Sigma>');\n        sp F (a # xs) \\<Sigma> = Ok \\<Sigma>'\\<rbrakk>\n       \\<Longrightarrow> sp F (map generalize_instr (a # xs))\n                          (map Map.empty \\<Sigma>) =\n                         Ok (map Map.empty \\<Sigma>')", "then"], ["proof (chain)\npicking this:\n  sp F [] \\<Sigma> = Ok \\<Sigma>'", "show ?case"], ["proof (prove)\nusing this:\n  sp F [] \\<Sigma> = Ok \\<Sigma>'\n\ngoal (1 subgoal):\n 1. sp F (map generalize_instr []) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "using assms(1)"], ["proof (prove)\nusing this:\n  sp F [] \\<Sigma> = Ok \\<Sigma>'\n  sp F xs \\<Sigma> = Ok \\<Sigma>'\n\ngoal (1 subgoal):\n 1. sp F (map generalize_instr []) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "by simp"], ["proof (state)\nthis:\n  sp F (map generalize_instr []) (map Map.empty \\<Sigma>) =\n  Ok (map Map.empty \\<Sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>a xs \\<Sigma> \\<Sigma>'.\n       \\<lbrakk>\\<And>\\<Sigma> \\<Sigma>'.\n                   sp F xs \\<Sigma> = Ok \\<Sigma>' \\<Longrightarrow>\n                   sp F (map generalize_instr xs) (map Map.empty \\<Sigma>) =\n                   Ok (map Map.empty \\<Sigma>');\n        sp F (a # xs) \\<Sigma> = Ok \\<Sigma>'\\<rbrakk>\n       \\<Longrightarrow> sp F (map generalize_instr (a # xs))\n                          (map Map.empty \\<Sigma>) =\n                         Ok (map Map.empty \\<Sigma>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs \\<Sigma> \\<Sigma>'.\n       \\<lbrakk>\\<And>\\<Sigma> \\<Sigma>'.\n                   sp F xs \\<Sigma> = Ok \\<Sigma>' \\<Longrightarrow>\n                   sp F (map generalize_instr xs) (map Map.empty \\<Sigma>) =\n                   Ok (map Map.empty \\<Sigma>');\n        sp F (a # xs) \\<Sigma> = Ok \\<Sigma>'\\<rbrakk>\n       \\<Longrightarrow> sp F (map generalize_instr (a # xs))\n                          (map Map.empty \\<Sigma>) =\n                         Ok (map Map.empty \\<Sigma>')", "case (Cons x xs)"], ["proof (state)\nthis:\n  sp F xs ?\\<Sigma>34 = Ok ?\\<Sigma>'34 \\<Longrightarrow>\n  sp F (map generalize_instr xs) (map Map.empty ?\\<Sigma>34) =\n  Ok (map Map.empty ?\\<Sigma>'34)\n  sp F (x # xs) \\<Sigma> = Ok \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>a xs \\<Sigma> \\<Sigma>'.\n       \\<lbrakk>\\<And>\\<Sigma> \\<Sigma>'.\n                   sp F xs \\<Sigma> = Ok \\<Sigma>' \\<Longrightarrow>\n                   sp F (map generalize_instr xs) (map Map.empty \\<Sigma>) =\n                   Ok (map Map.empty \\<Sigma>');\n        sp F (a # xs) \\<Sigma> = Ok \\<Sigma>'\\<rbrakk>\n       \\<Longrightarrow> sp F (map generalize_instr (a # xs))\n                          (map Map.empty \\<Sigma>) =\n                         Ok (map Map.empty \\<Sigma>')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "proof (cases \"sp_instr F x \\<Sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       sp_instr F x \\<Sigma> = Error x1 \\<Longrightarrow>\n       sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')\n 2. \\<And>x2.\n       sp_instr F x \\<Sigma> = Ok x2 \\<Longrightarrow>\n       sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')", "case (Error x1)"], ["proof (state)\nthis:\n  sp_instr F x \\<Sigma> = Error x1\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       sp_instr F x \\<Sigma> = Error x1 \\<Longrightarrow>\n       sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')\n 2. \\<And>x2.\n       sp_instr F x \\<Sigma> = Ok x2 \\<Longrightarrow>\n       sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')", "then"], ["proof (chain)\npicking this:\n  sp_instr F x \\<Sigma> = Error x1", "show ?thesis"], ["proof (prove)\nusing this:\n  sp_instr F x \\<Sigma> = Error x1\n\ngoal (1 subgoal):\n 1. sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "using Cons.prems"], ["proof (prove)\nusing this:\n  sp_instr F x \\<Sigma> = Error x1\n  sp F (x # xs) \\<Sigma> = Ok \\<Sigma>'\n\ngoal (1 subgoal):\n 1. sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "by auto"], ["proof (state)\nthis:\n  sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n  Ok (map Map.empty \\<Sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       sp_instr F x \\<Sigma> = Ok x2 \\<Longrightarrow>\n       sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       sp_instr F x \\<Sigma> = Ok x2 \\<Longrightarrow>\n       sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')", "case (Ok \\<Sigma>'')"], ["proof (state)\nthis:\n  sp_instr F x \\<Sigma> = Ok \\<Sigma>''\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       sp_instr F x \\<Sigma> = Ok x2 \\<Longrightarrow>\n       sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n       Ok (map Map.empty \\<Sigma>')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "using Cons sp_generalize_instr[OF Ok]"], ["proof (prove)\nusing this:\n  sp F xs ?\\<Sigma>34 = Ok ?\\<Sigma>'34 \\<Longrightarrow>\n  sp F (map generalize_instr xs) (map Map.empty ?\\<Sigma>34) =\n  Ok (map Map.empty ?\\<Sigma>'34)\n  sp F (x # xs) \\<Sigma> = Ok \\<Sigma>'\n  sp_instr F (generalize_instr x) (map Map.empty \\<Sigma>) =\n  Ok (map Map.empty \\<Sigma>'')\n\ngoal (1 subgoal):\n 1. sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n    Ok (map Map.empty \\<Sigma>')", "by (simp add: Ok)"], ["proof (state)\nthis:\n  sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n  Ok (map Map.empty \\<Sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sp F (map generalize_instr (x # xs)) (map Map.empty \\<Sigma>) =\n  Ok (map Map.empty \\<Sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sp_generalize2:\n  assumes \"sp F xs (replicate n None) = Ok \\<Sigma>'\"\n  shows \"sp F (map generalize_instr xs) (replicate n None) = Ok (map (\\<lambda>_. None) \\<Sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F (map generalize_instr xs) (replicate n None) =\n    Ok (map Map.empty \\<Sigma>')", "using assms"], ["proof (prove)\nusing this:\n  sp F xs (replicate n None) = Ok \\<Sigma>'\n\ngoal (1 subgoal):\n 1. sp F (map generalize_instr xs) (replicate n None) =\n    Ok (map Map.empty \\<Sigma>')", "using sp_generalize"], ["proof (prove)\nusing this:\n  sp F xs (replicate n None) = Ok \\<Sigma>'\n  sp ?F ?xs ?\\<Sigma> = Ok ?\\<Sigma>' \\<Longrightarrow>\n  sp ?F (map generalize_instr ?xs) (map Map.empty ?\\<Sigma>) =\n  Ok (map Map.empty ?\\<Sigma>')\n\ngoal (1 subgoal):\n 1. sp F (map generalize_instr xs) (replicate n None) =\n    Ok (map Map.empty \\<Sigma>')", "by fastforce"], ["", "lemma comp_K[simp]: \"(\\<lambda>_. x) \\<circ> f = (\\<lambda>_. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. x) \\<circ> f = (\\<lambda>_. x)", "by auto"], ["", "lemma is_ok_sp_generalize:\n  assumes \"is_ok (sp F xs (map (\\<lambda>_. None) \\<Sigma>))\"\n    shows \"is_ok (sp F (map generalize_instr xs) (map (\\<lambda>_. None) \\<Sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ok (sp F (map generalize_instr xs) (map Map.empty \\<Sigma>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_ok (sp F (map generalize_instr xs) (map Map.empty \\<Sigma>))", "from assms"], ["proof (chain)\npicking this:\n  is_ok (sp F xs (map Map.empty \\<Sigma>))", "obtain res where 0: \"sp F xs (map (\\<lambda>_. None) \\<Sigma>) = Ok res\""], ["proof (prove)\nusing this:\n  is_ok (sp F xs (map Map.empty \\<Sigma>))\n\ngoal (1 subgoal):\n 1. (\\<And>res.\n        sp F xs (map Map.empty \\<Sigma>) = Ok res \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: is_ok_def)"], ["proof (state)\nthis:\n  sp F xs (map Map.empty \\<Sigma>) = Ok res\n\ngoal (1 subgoal):\n 1. is_ok (sp F (map generalize_instr xs) (map Map.empty \\<Sigma>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ok (sp F (map generalize_instr xs) (map Map.empty \\<Sigma>))", "using sp_generalize[OF 0]"], ["proof (prove)\nusing this:\n  sp F (map generalize_instr xs) (map Map.empty (map Map.empty \\<Sigma>)) =\n  Ok (map Map.empty res)\n\ngoal (1 subgoal):\n 1. is_ok (sp F (map generalize_instr xs) (map Map.empty \\<Sigma>))", "by simp"], ["proof (state)\nthis:\n  is_ok (sp F (map generalize_instr xs) (map Map.empty \\<Sigma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_ok_sp_generalize2:\n  assumes \"is_ok (sp F xs (replicate n None))\"\n  shows \"is_ok (sp F (map generalize_instr xs) (replicate n None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ok (sp F (map generalize_instr xs) (replicate n None))", "using assms is_ok_sp_generalize"], ["proof (prove)\nusing this:\n  is_ok (sp F xs (replicate n None))\n  is_ok (sp ?F ?xs (map Map.empty ?\\<Sigma>)) \\<Longrightarrow>\n  is_ok (sp ?F (map generalize_instr ?xs) (map Map.empty ?\\<Sigma>))\n\ngoal (1 subgoal):\n 1. is_ok (sp F (map generalize_instr xs) (replicate n None))", "by (metis Ex_list_of_length map_replicate_const)"], ["", "lemma sp_instr_op:\n  assumes \"\\<DD>\\<ee>\\<II>\\<nn>\\<ll> opinl = op\"\n  shows \"sp_instr F (IOp op) \\<Sigma> = sp_instr F (IOpInl opinl) \\<Sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp_instr F (IOp op) \\<Sigma> = sp_instr F (IOpInl opinl) \\<Sigma>", "by (rule sp_instr.cases[of \"(F, (IOp op), \\<Sigma>)\"]; simp add: Let_def assms)"], ["", "lemma sp_list_update:\n  assumes\n    \"n < length xs\" and\n    \"\\<forall>\\<Sigma>. sp_instr F (xs ! n) \\<Sigma> = sp_instr F x \\<Sigma>\"\n  shows \"sp F (xs[n := x]) = sp F xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F (xs[n := x]) = sp F xs", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. sp F (xs[n := x]) xa = sp F xs xa", "fix ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. sp F (xs[n := x]) xa = sp F xs xa", "have \"sp F (take n xs @ x # drop (Suc n) xs) ys = sp F (take n xs @ xs ! n # drop (Suc n) xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F (take n xs @ x # drop (Suc n) xs) ys =\n    sp F (take n xs @ xs ! n # drop (Suc n) xs) ys", "unfolding sp_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F (take n xs) ys \\<bind> sp F (x # drop (Suc n) xs) =\n    sp F (take n xs) ys \\<bind> sp F (xs ! n # drop (Suc n) xs)", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>\\<Sigma>. sp_instr F (xs ! n) \\<Sigma> = sp_instr F x \\<Sigma>\n\ngoal (1 subgoal):\n 1. sp F (take n xs) ys \\<bind> sp F (x # drop (Suc n) xs) =\n    sp F (take n xs) ys \\<bind> sp F (xs ! n # drop (Suc n) xs)", "by (cases \"sp F (take n xs) ys\"; simp)"], ["proof (state)\nthis:\n  sp F (take n xs @ x # drop (Suc n) xs) ys =\n  sp F (take n xs @ xs ! n # drop (Suc n) xs) ys\n\ngoal (1 subgoal):\n 1. \\<And>xa. sp F (xs[n := x]) xa = sp F xs xa", "thus \"sp F (xs[n := x]) ys = sp F xs ys\""], ["proof (prove)\nusing this:\n  sp F (take n xs @ x # drop (Suc n) xs) ys =\n  sp F (take n xs @ xs ! n # drop (Suc n) xs) ys\n\ngoal (1 subgoal):\n 1. sp F (xs[n := x]) ys = sp F xs ys", "unfolding id_take_nth_drop[OF assms(1), symmetric]"], ["proof (prove)\nusing this:\n  sp F (take n xs @ x # drop (Suc n) xs) ys = sp F xs ys\n\ngoal (1 subgoal):\n 1. sp F (xs[n := x]) ys = sp F xs ys", "unfolding upd_conv_take_nth_drop[OF assms(1), symmetric]"], ["proof (prove)\nusing this:\n  sp F (xs[n := x]) ys = sp F xs ys\n\ngoal (1 subgoal):\n 1. sp F (xs[n := x]) ys = sp F xs ys", "by assumption"], ["proof (state)\nthis:\n  sp F (xs[n := x]) ys = sp F xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sp_list_update_eq_Ok:\n  assumes\n    \"n < length xs\" and\n    \"\\<forall>\\<Sigma>. sp_instr F (xs ! n) \\<Sigma> = sp_instr F x \\<Sigma>\" and\n    \"sp F xs ys = Ok zs\"\n  shows \"sp F (xs[n := x]) ys = Ok zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F (xs[n := x]) ys = Ok zs", "unfolding sp_list_update[OF assms(1,2)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sp F xs ys = Ok zs", "using assms(3)"], ["proof (prove)\nusing this:\n  sp F xs ys = Ok zs\n\ngoal (1 subgoal):\n 1. sp F xs ys = Ok zs", "by assumption"], ["", "lemma is_ok_sp_list_update:\n  assumes\n    \"is_ok (sp F xs types)\" and\n    \"pc < length xs\" and\n    \"\\<forall>\\<Sigma>. sp_instr F (xs ! pc) \\<Sigma> = sp_instr F instr \\<Sigma>\"\n  shows \"is_ok (sp F (xs[pc := instr]) types)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ok (sp F (xs[pc := instr]) types)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_ok (sp F (xs[pc := instr]) types)", "from assms(1)"], ["proof (chain)\npicking this:\n  is_ok (sp F xs types)", "obtain types' where \"sp F xs types = Ok types'\""], ["proof (prove)\nusing this:\n  is_ok (sp F xs types)\n\ngoal (1 subgoal):\n 1. (\\<And>types'.\n        sp F xs types = Ok types' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding is_ok_def"], ["proof (prove)\nusing this:\n  \\<exists>x2. sp F xs types = Ok x2\n\ngoal (1 subgoal):\n 1. (\\<And>types'.\n        sp F xs types = Ok types' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sp F xs types = Ok types'\n\ngoal (1 subgoal):\n 1. is_ok (sp F (xs[pc := instr]) types)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sp F xs types = Ok types'\n\ngoal (1 subgoal):\n 1. is_ok (sp F (xs[pc := instr]) types)", "using sp_list_update[OF assms(2,3)]"], ["proof (prove)\nusing this:\n  sp F xs types = Ok types'\n  sp F (xs[pc := instr]) = sp F xs\n\ngoal (1 subgoal):\n 1. is_ok (sp F (xs[pc := instr]) types)", "by simp"], ["proof (state)\nthis:\n  is_ok (sp F (xs[pc := instr]) types)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas sp_rewrite = sp_list_update[folded rewrite_def]"], ["", "lemmas sp_rewrite_eq_Ok = sp_list_update_eq_Ok[folded rewrite_def]"], ["", "lemmas is_ok_sp_rewrite = is_ok_sp_list_update[folded rewrite_def]"], ["", "end"], ["", "end"]]}