{"file_name": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations/Result.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations", "problem_names": ["lemma bind_Ok[simp]: \"x \\<bind> Ok = x\"", "lemma bind_eq_Ok_conv: \"(x \\<bind> f = Ok z) = (\\<exists>y. x = Ok y \\<and> f y = Ok z)\"", "lemmas bind_eq_OkD[dest!] = bind_eq_Ok_conv[THEN iffD1]", "lemmas bind_eq_OkE = bind_eq_OkD[THEN exE]", "lemmas bind_eq_OkI[intro] = conjI[THEN exI[THEN bind_eq_Ok_conv[THEN iffD2]]]", "lemma bind_eq_Error_conv:\n  \"x \\<bind> f = Error z \\<longleftrightarrow> x = Error z \\<or> (\\<exists>y. x = Ok y \\<and> f y = Error z)\"", "lemmas bind_eq_ErrorD[dest!] = bind_eq_Error_conv[THEN iffD1]", "lemmas bind_eq_ErrorE = bind_eq_ErrorD[THEN disjE]", "lemmas bind_eq_ErrorI =\n  disjI1[THEN bind_eq_Error_conv[THEN iffD2]]\n  conjI[THEN exI[THEN disjI2[THEN bind_eq_Error_conv[THEN iffD2]]]]", "lemma if_then_else_Ok[simp]:\n  \"(if a then b else Error c) = Ok d \\<longleftrightarrow> a \\<and> b = Ok d\"\n  \"(if a then Error c else b) = Ok d \\<longleftrightarrow> \\<not> a \\<and> b = Ok d\"", "lemma if_then_else_Error[simp]:\n  \"(if a then Ok b else c) = Error d \\<longleftrightarrow> \\<not> a \\<and> c = Error d\"\n  \"(if a then c else Ok b) = Error d \\<longleftrightarrow> a \\<and> c = Error d\"", "lemma map_eq_Ok_conv: \"map_result f g x = Ok y \\<longleftrightarrow> (\\<exists>x'. x = Ok x' \\<and> y = g x')\"", "lemma map_eq_Error_conv: \"map_result f g x = Error y \\<longleftrightarrow> (\\<exists>x'. x = Error x' \\<and> y = f x')\"", "lemmas map_eq_OkD[dest!] = iffD1[OF map_eq_Ok_conv]", "lemmas map_eq_ErrorD[dest!] = iffD1[OF map_eq_Error_conv]", "lemma of_option_injective[simp]: \"(of_option e x = of_option e y) = (x = y)\"", "lemma of_option_eq_Ok[simp]: \"(of_option x y = Ok z) = (y = Some z)\"", "lemma to_option_Some[simp]: \"(to_option r = Some x) = (r = Ok x)\"", "lemma those_Cons_OkD: \"those (x # xs) = Ok ys \\<Longrightarrow> \\<exists>y ys'. ys = y # ys' \\<and> x = Ok y \\<and> those xs = Ok ys'\""], "translations": [["", "lemma bind_Ok[simp]: \"x \\<bind> Ok = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bind> Ok = x", "by (cases x) simp_all"], ["", "qualified"], ["", "lemma bind_eq_Ok_conv: \"(x \\<bind> f = Ok z) = (\\<exists>y. x = Ok y \\<and> f y = Ok z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<bind> f = Ok z) = (\\<exists>y. x = Ok y \\<and> f y = Ok z)", "by (cases x) simp_all"], ["", "qualified"], ["", "lemmas bind_eq_OkD[dest!] = bind_eq_Ok_conv[THEN iffD1]"], ["", "qualified"], ["", "lemmas bind_eq_OkE = bind_eq_OkD[THEN exE]"], ["", "qualified"], ["", "lemmas bind_eq_OkI[intro] = conjI[THEN exI[THEN bind_eq_Ok_conv[THEN iffD2]]]"], ["", "qualified"], ["", "lemma bind_eq_Error_conv:\n  \"x \\<bind> f = Error z \\<longleftrightarrow> x = Error z \\<or> (\\<exists>y. x = Ok y \\<and> f y = Error z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<bind> f = Error z) =\n    (x = Error z \\<or> (\\<exists>y. x = Ok y \\<and> f y = Error z))", "by (cases x) simp_all"], ["", "qualified"], ["", "lemmas bind_eq_ErrorD[dest!] = bind_eq_Error_conv[THEN iffD1]"], ["", "qualified"], ["", "lemmas bind_eq_ErrorE = bind_eq_ErrorD[THEN disjE]"], ["", "qualified"], ["", "lemmas bind_eq_ErrorI =\n  disjI1[THEN bind_eq_Error_conv[THEN iffD2]]\n  conjI[THEN exI[THEN disjI2[THEN bind_eq_Error_conv[THEN iffD2]]]]"], ["", "lemma if_then_else_Ok[simp]:\n  \"(if a then b else Error c) = Ok d \\<longleftrightarrow> a \\<and> b = Ok d\"\n  \"(if a then Error c else b) = Ok d \\<longleftrightarrow> \\<not> a \\<and> b = Ok d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if a then b else Error c) = Ok d) = (a \\<and> b = Ok d) &&&\n    ((if a then Error c else b) = Ok d) = (\\<not> a \\<and> b = Ok d)", "by (cases a) simp_all"], ["", "qualified"], ["", "lemma if_then_else_Error[simp]:\n  \"(if a then Ok b else c) = Error d \\<longleftrightarrow> \\<not> a \\<and> c = Error d\"\n  \"(if a then c else Ok b) = Error d \\<longleftrightarrow> a \\<and> c = Error d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if a then Ok b else c) = Error d) = (\\<not> a \\<and> c = Error d) &&&\n    ((if a then c else Ok b) = Error d) = (a \\<and> c = Error d)", "by (cases a) simp_all"], ["", "qualified"], ["", "lemma map_eq_Ok_conv: \"map_result f g x = Ok y \\<longleftrightarrow> (\\<exists>x'. x = Ok x' \\<and> y = g x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_result f g x = Ok y) = (\\<exists>x'. x = Ok x' \\<and> y = g x')", "by (cases x; auto)"], ["", "qualified"], ["", "lemma map_eq_Error_conv: \"map_result f g x = Error y \\<longleftrightarrow> (\\<exists>x'. x = Error x' \\<and> y = f x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_result f g x = Error y) =\n    (\\<exists>x'. x = Error x' \\<and> y = f x')", "by (cases x; auto)"], ["", "qualified"], ["", "lemmas map_eq_OkD[dest!] = iffD1[OF map_eq_Ok_conv]"], ["", "qualified"], ["", "lemmas map_eq_ErrorD[dest!] = iffD1[OF map_eq_Error_conv]"], ["", "end"], ["", "section \\<open>Conversion functions\\<close>"], ["", "context begin"], ["", "qualified"], ["", "fun of_option where\n  \"of_option e None = Error e\" |\n  \"of_option e (Some x) = Ok x\""], ["", "qualified"], ["", "lemma of_option_injective[simp]: \"(of_option e x = of_option e y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_option e x = of_option e y) = (x = y)", "by (cases x; cases y; simp)"], ["", "qualified"], ["", "lemma of_option_eq_Ok[simp]: \"(of_option x y = Ok z) = (y = Some z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_option x y = Ok z) = (y = Some z)", "by (cases y) simp_all"], ["", "qualified"], ["", "fun to_option where\n  \"to_option (Error _) = None\" |\n  \"to_option (Ok x) = Some x\""], ["", "qualified"], ["", "lemma to_option_Some[simp]: \"(to_option r = Some x) = (r = Ok x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_option r = Some x) = (r = Ok x)", "by (cases r) simp_all"], ["", "qualified"], ["", "fun those :: \"('err, 'ok) result list \\<Rightarrow> ('err, 'ok list) result\" where\n  \"those [] = Ok []\" |\n  \"those (x # xs) = do {\n    y \\<leftarrow> x;\n    ys \\<leftarrow> those xs;\n    Ok (y # ys)\n  }\""], ["", "qualified"], ["", "lemma those_Cons_OkD: \"those (x # xs) = Ok ys \\<Longrightarrow> \\<exists>y ys'. ys = y # ys' \\<and> x = Ok y \\<and> those xs = Ok ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.those (x # xs) = Ok ys \\<Longrightarrow>\n    \\<exists>y ys'.\n       ys = y # ys' \\<and> x = Ok y \\<and> local.those xs = Ok ys'", "by auto"], ["", "end"], ["", "end"]]}