{"file_name": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations/Global.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Interpreter_Optimizations", "problem_names": ["lemma if_then_Some_else_None_eq[simp]:\n  \"(if a then Some b else None) = Some c \\<longleftrightarrow> a \\<and> b = c\"\n  \"(if a then Some b else None) = None \\<longleftrightarrow> \\<not> a\"", "lemma if_then_else_distributive: \"(if a then f b else f c) = f (if a then b else c)\"", "lemma traverse_length: \"traverse f xs = Some ys \\<Longrightarrow> length ys = length xs\"", "lemma rel_fundef_arities: \"rel_fundef r gd1 gd2 \\<Longrightarrow> arity gd1 = arity gd2\"", "lemma rel_fundef_body_length[simp]:\n  \"rel_fundef r fd1 fd2 \\<Longrightarrow> length (body fd1) = length (body fd2)\"", "lemmas length_rewrite[simp] = length_list_update[folded rewrite_def]", "lemmas nth_rewrite_eq[simp] = nth_list_update_eq[folded rewrite_def]", "lemmas nth_rewrite_neq[simp] = nth_list_update_neq[folded rewrite_def]", "lemmas take_rewrite[simp] = take_update_cancel[folded rewrite_def]", "lemmas take_rewrite_swap = take_update_swap[folded rewrite_def]", "lemmas map_rewrite = map_update[folded rewrite_def]", "lemmas list_all2_rewrite_cong[intro] = list_all2_update_cong[folded rewrite_def]", "lemma body_rewrite_fundef_body[simp]: \"body (rewrite_fundef_body fd n x) = rewrite (body fd) n x\"", "lemma arity_rewrite_fundef_body[simp]: \"arity (rewrite_fundef_body fd n x) = arity fd\"", "lemma if_eq_const_conv: \"(if x then y else z) = w \\<longleftrightarrow> x \\<and> y = w \\<or> \\<not>x \\<and> z = w\""], "translations": [["", "lemma if_then_Some_else_None_eq[simp]:\n  \"(if a then Some b else None) = Some c \\<longleftrightarrow> a \\<and> b = c\"\n  \"(if a then Some b else None) = None \\<longleftrightarrow> \\<not> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if a then Some b else None) = Some c) = (a \\<and> b = c) &&&\n    ((if a then Some b else None) = None) = (\\<not> a)", "by (cases a) simp_all"], ["", "lemma if_then_else_distributive: \"(if a then f b else f c) = f (if a then b else c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a then f b else f c) = f (if a then b else c)", "by simp"], ["", "fun traverse :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> 'a list \\<Rightarrow> 'b list option\" where\n  \"traverse f [] = Some []\" |\n  \"traverse f (x # xs) = do {\n    x' \\<leftarrow> f x;\n    xs' \\<leftarrow> traverse f xs;\n    Some (x' # xs')\n  }\""], ["", "lemma traverse_length: \"traverse f xs = Some ys \\<Longrightarrow> length ys = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. traverse f xs = Some ys \\<Longrightarrow> length ys = length xs", "proof (induction xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       traverse f [] = Some ys \\<Longrightarrow> length ys = length []\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse f xs = Some ys \\<Longrightarrow>\n                   length ys = length xs;\n        traverse f (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> length ys = length (a # xs)", "case Nil"], ["proof (state)\nthis:\n  traverse f [] = Some ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       traverse f [] = Some ys \\<Longrightarrow> length ys = length []\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse f xs = Some ys \\<Longrightarrow>\n                   length ys = length xs;\n        traverse f (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> length ys = length (a # xs)", "then"], ["proof (chain)\npicking this:\n  traverse f [] = Some ys", "show ?case"], ["proof (prove)\nusing this:\n  traverse f [] = Some ys\n\ngoal (1 subgoal):\n 1. length ys = length []", "by simp"], ["proof (state)\nthis:\n  length ys = length []\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse f xs = Some ys \\<Longrightarrow>\n                   length ys = length xs;\n        traverse f (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> length ys = length (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse f xs = Some ys \\<Longrightarrow>\n                   length ys = length xs;\n        traverse f (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> length ys = length (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  traverse f xs = Some ?ys \\<Longrightarrow> length ?ys = length xs\n  traverse f (x # xs) = Some ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   traverse f xs = Some ys \\<Longrightarrow>\n                   length ys = length xs;\n        traverse f (a # xs) = Some ys\\<rbrakk>\n       \\<Longrightarrow> length ys = length (a # xs)", "then"], ["proof (chain)\npicking this:\n  traverse f xs = Some ?ys \\<Longrightarrow> length ?ys = length xs\n  traverse f (x # xs) = Some ys", "show ?case"], ["proof (prove)\nusing this:\n  traverse f xs = Some ?ys \\<Longrightarrow> length ?ys = length xs\n  traverse f (x # xs) = Some ys\n\ngoal (1 subgoal):\n 1. length ys = length (x # xs)", "by (auto simp add: Option.bind_eq_Some_conv)"], ["proof (state)\nthis:\n  length ys = length (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "datatype 'instr fundef =\n  Fundef (body: \"'instr list\") (arity: nat)"], ["", "lemma rel_fundef_arities: \"rel_fundef r gd1 gd2 \\<Longrightarrow> arity gd1 = arity gd2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef r gd1 gd2 \\<Longrightarrow> arity gd1 = arity gd2", "by (simp add: fundef.rel_sel)"], ["", "lemma rel_fundef_body_length[simp]:\n  \"rel_fundef r fd1 fd2 \\<Longrightarrow> length (body fd1) = length (body fd2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fundef r fd1 fd2 \\<Longrightarrow>\n    length (body fd1) = length (body fd2)", "by (auto intro: list_all2_lengthD simp add: fundef.rel_sel)"], ["", "datatype ('fenv, 'henv, 'fun) prog =\n  Prog (fun_env: 'fenv) (heap: 'henv) (main_fun: 'fun)"], ["", "datatype ('fun, 'operand) frame =\n  Frame 'fun (prog_counter: nat) (operand_stack: \"'operand list\")"], ["", "datatype ('fenv, 'henv, 'frame) state =\n  State (fun_env: 'fenv) (heap: 'henv) (callstack: \"'frame list\")"], ["", "definition rewrite :: \"'instr list \\<Rightarrow> nat \\<Rightarrow> 'instr \\<Rightarrow> 'instr list\" where\n  \"rewrite p pc i = list_update p pc i\""], ["", "fun rewrite_fundef_body :: \"'instr fundef \\<Rightarrow> nat \\<Rightarrow> 'instr \\<Rightarrow> 'instr fundef\" where\n  \"rewrite_fundef_body (Fundef xs ar) n x = Fundef (rewrite xs n x) ar\""], ["", "lemmas length_rewrite[simp] = length_list_update[folded rewrite_def]"], ["", "lemmas nth_rewrite_eq[simp] = nth_list_update_eq[folded rewrite_def]"], ["", "lemmas nth_rewrite_neq[simp] = nth_list_update_neq[folded rewrite_def]"], ["", "lemmas take_rewrite[simp] = take_update_cancel[folded rewrite_def]"], ["", "lemmas take_rewrite_swap = take_update_swap[folded rewrite_def]"], ["", "lemmas map_rewrite = map_update[folded rewrite_def]"], ["", "lemmas list_all2_rewrite_cong[intro] = list_all2_update_cong[folded rewrite_def]"], ["", "lemma body_rewrite_fundef_body[simp]: \"body (rewrite_fundef_body fd n x) = rewrite (body fd) n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. body (rewrite_fundef_body fd n x) = rewrite (body fd) n x", "by (cases fd) simp"], ["", "lemma arity_rewrite_fundef_body[simp]: \"arity (rewrite_fundef_body fd n x) = arity fd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity (rewrite_fundef_body fd n x) = arity fd", "by (cases fd) simp"], ["", "lemma if_eq_const_conv: \"(if x then y else z) = w \\<longleftrightarrow> x \\<and> y = w \\<or> \\<not>x \\<and> z = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if x then y else z) = w) =\n    (x \\<and> y = w \\<or> \\<not> x \\<and> z = w)", "by simp"], ["", "end"]]}