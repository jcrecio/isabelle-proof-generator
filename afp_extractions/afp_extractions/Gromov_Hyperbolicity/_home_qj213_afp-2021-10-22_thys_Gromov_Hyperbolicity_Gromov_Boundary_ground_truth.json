{"file_name": "/home/qj213/afp-2021-10-22/thys/Gromov_Hyperbolicity/Gromov_Boundary.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gromov_Hyperbolicity", "problem_names": ["lemma bdd_below [simp]:\n  \"bdd_below {(\\<Sum> i = 0..<n. f (u i) (u (Suc i)))| u (n::nat). u 0 = x \\<and> u n = y}\"", "lemma nonempty:\n  \"{\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y} \\<noteq> {}\"", "lemma TID_nonneg:\n  \"turn_into_distance f x y \\<ge> 0\"", "lemma TID_sym:\n  \"turn_into_distance f x y = turn_into_distance f y x\"", "lemma upper:\n  \"turn_into_distance f x y \\<le> f x y\"", "lemma TID_self_zero:\n  \"turn_into_distance f x x = 0\"", "lemma triangle:\n  \"turn_into_distance f x z \\<le> turn_into_distance f x y + turn_into_distance f y z\"", "lemma lower:\n  \"f x y \\<le> 2 * turn_into_distance f x y\"", "lemma Gromov_converging_at_boundaryI:\n  assumes \"\\<And>M. \\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. Gromov_product_at a (u m) (u n) \\<ge> M\"\n  shows \"Gromov_converging_at_boundary u\"", "lemma Gromov_converging_at_boundary_imp_unbounded:\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"(\\<lambda>n. dist a (u n)) \\<longlonglongrightarrow> \\<infinity>\"", "lemma Gromov_converging_at_boundary_imp_not_constant:\n  \"\\<not>(Gromov_converging_at_boundary (\\<lambda>n. x))\"", "lemma Gromov_converging_at_boundary_imp_not_constant':\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"\\<not>(\\<forall>m n. u m = u n)\"", "lemma Gromov_completion_rel_const [simp]:\n  \"Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. x)\"", "lemma Gromov_completion_rel_to_const:\n  assumes \"Gromov_completion_rel u (\\<lambda>n. x)\"\n  shows \"u n = x\"", "lemma Gromov_completion_rel_to_const':\n  assumes \"Gromov_completion_rel (\\<lambda>n. x) u\"\n  shows \"u n = x\"", "lemma Gromov_product_tendsto_PInf_a_b:\n  assumes \"(\\<lambda>n. Gromov_product_at a (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\"\n  shows \"(\\<lambda>n. Gromov_product_at b (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\"", "lemma Gromov_converging_at_boundary_rel:\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"Gromov_completion_rel u u\"", "lemma part_equivp_Gromov_completion_rel:\n  \"part_equivp Gromov_completion_rel\"", "lemma to_Gromov_completion_inj:\n  \"inj to_Gromov_completion\"", "lemma from_to_Gromov_completion [simp]:\n  \"from_Gromov_completion (to_Gromov_completion x) = x\"", "lemma to_from_Gromov_completion:\n  assumes \"x \\<notin> Gromov_boundary\"\n  shows \"to_Gromov_completion (from_Gromov_completion x) = x\"", "lemma not_in_Gromov_boundary:\n  assumes \"x \\<notin> Gromov_boundary\"\n  shows \"\\<exists>a. x = to_Gromov_completion a\"", "lemma not_in_Gromov_boundary' [simp]:\n  \"to_Gromov_completion x \\<notin> Gromov_boundary\"", "lemma abs_Gromov_completion_in_Gromov_boundary [simp]:\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"abs_Gromov_completion u \\<in> Gromov_boundary\"", "lemma rep_Gromov_completion_to_Gromov_completion [simp]:\n  \"rep_Gromov_completion (to_Gromov_completion y) = (\\<lambda>n. y)\"", "lemma Gromov_completion_cases [case_names to_Gromov_completion boundary, cases type: Gromov_completion]:\n  \"(\\<And>x. z = to_Gromov_completion x \\<Longrightarrow> P) \\<Longrightarrow> (z \\<in> Gromov_boundary \\<Longrightarrow> P) \\<Longrightarrow> P\"", "lemma extended_Gromov_distance_commute:\n  \"extended_Gromov_distance x y = extended_Gromov_distance y x\"", "lemma extended_Gromov_product_nonneg [mono_intros, simp]:\n  \"0 \\<le> extended_Gromov_product_at e x y\"", "lemma extended_Gromov_distance_nonneg [mono_intros, simp]:\n  \"0 \\<le> extended_Gromov_distance x y\"", "lemma extended_Gromov_product_at_commute:\n  \"extended_Gromov_product_at e x y = extended_Gromov_product_at e y x\"", "lemma extended_Gromov_distance_inside [simp]:\n  \"extended_Gromov_distance (to_Gromov_completion x) (to_Gromov_completion y) = dist x y\"", "lemma extended_Gromov_product_inside [simp] :\n  \"extended_Gromov_product_at e (to_Gromov_completion x) (to_Gromov_completion y) = Gromov_product_at e x y\"", "lemma extended_Gromov_distance_PInf_boundary [simp]:\n  assumes \"x \\<in> Gromov_boundary\"\n  shows \"extended_Gromov_distance x y = \\<infinity>\" \"extended_Gromov_distance y x = \\<infinity>\"", "lemma extended_Gromov_distance_triangle [mono_intros]:\n  \"extended_Gromov_distance x z \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\"", "lemma extended_Gromov_product_le_dist [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_distance (to_Gromov_completion e) x\"", "lemma extended_Gromov_product_le_dist' [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_distance (to_Gromov_completion e) y\"", "lemma extended_Gromov_product_at_diff3 [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\"", "lemma extended_Gromov_product_at_diff2 [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_product_at e z y + extended_Gromov_distance x z\"", "lemma extended_Gromov_product_at_diff1 [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_product_at f x y + dist e f\"", "lemma Gromov_boundary_abs_converging:\n  assumes \"x \\<in> Gromov_boundary\" \"abs_Gromov_completion u = x\" \"Gromov_completion_rel u u\"\n  shows \"Gromov_converging_at_boundary u\"", "lemma Gromov_boundary_rep_converging:\n  assumes \"x \\<in> Gromov_boundary\"\n  shows \"Gromov_converging_at_boundary (rep_Gromov_completion x)\"", "lemma Gromov_boundary_extended_product_PInf [simp]:\n  \"extended_Gromov_product_at e x y = \\<infinity> \\<longleftrightarrow> (x \\<in> Gromov_boundary \\<and> y = x)\"", "lemma extended_Gromov_product_e_x_x [simp]:\n  \"extended_Gromov_product_at e x x = extended_Gromov_distance (to_Gromov_completion e) x\"", "lemma extended_hyperb_ineq [mono_intros]:\n  \"extended_Gromov_product_at (e::'a::Gromov_hyperbolic_space) x z \\<ge>\n      min (extended_Gromov_product_at e x y) (extended_Gromov_product_at e y z) - deltaG(TYPE('a))\"", "lemma extended_hyperb_ineq' [mono_intros]:\n  \"extended_Gromov_product_at (e::'a::Gromov_hyperbolic_space) x z + deltaG(TYPE('a)) \\<ge>\n      min (extended_Gromov_product_at e x y) (extended_Gromov_product_at e y z)\"", "lemma zero_le_ereal [mono_intros]:\n  assumes \"0 \\<le> z\"\n  shows \"0 \\<le> ereal z\"", "lemma extended_hyperb_ineq_4_points' [mono_intros]:\n  \"Min {extended_Gromov_product_at (e::'a::Gromov_hyperbolic_space) x y, extended_Gromov_product_at e y z, extended_Gromov_product_at e z t} \\<le> extended_Gromov_product_at e x t + 2 * deltaG(TYPE('a))\"", "lemma extended_hyperb_ineq_4_points [mono_intros]:\n  \"Min {extended_Gromov_product_at (e::'a::Gromov_hyperbolic_space) x y, extended_Gromov_product_at e y z, extended_Gromov_product_at e z t} - 2 * deltaG(TYPE('a)) \\<le> extended_Gromov_product_at e x t\"", "lemma constant_in_extended_predist_pos [simp, mono_intros]:\n  \"epsilonG(TYPE('a::Gromov_hyperbolic_space)) > 0\"\n  \"epsilonG(TYPE('a::Gromov_hyperbolic_space)) \\<ge> 0\"\n  \"ennreal (epsilonG(TYPE('a))) * top = top\"", "lemma extended_predist_ereal:\n  \"ereal (extended_predist x (y::('a::Gromov_hyperbolic_space) Gromov_completion)) = min (esqrt (extended_Gromov_distance x y))\n          (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y))\"", "lemma extended_predist_nonneg [simp, mono_intros]:\n  \"extended_predist x y \\<ge> 0\"", "lemma extended_predist_commute:\n  \"extended_predist x y = extended_predist y x\"", "lemma extended_predist_self0 [simp]:\n  \"extended_predist x y = 0 \\<longleftrightarrow> x = y\"", "lemma extended_predist_le1 [simp, mono_intros]:\n  \"extended_predist x y \\<le> 1\"", "lemma extended_predist_weak_triangle:\n  \"extended_predist x z \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)\"", "theorem Gromov_completion_dist_comparison [mono_intros]:\n  fixes x y::\"('a::Gromov_hyperbolic_space) Gromov_completion\"\n  shows \"ereal(dist x y) \\<le> esqrt(extended_Gromov_distance x y)\"\n        \"ereal(dist x y) \\<le> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)\"\n        \"min (esqrt(extended_Gromov_distance x y)) (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)) \\<le> 2 * ereal(dist x y)\"", "lemma Gromov_completion_dist_le_1 [simp, mono_intros]:\n  fixes x y::\"('a::Gromov_hyperbolic_space) Gromov_completion\"\n  shows \"dist x y \\<le> 1\"", "lemma large_Gromov_product_approx:\n  assumes \"(M::ereal) < \\<infinity>\"\n  shows \"\\<exists>e D. e > 0 \\<and> D < \\<infinity> \\<and> (\\<forall>x y. dist x y \\<le> e \\<longrightarrow> extended_Gromov_distance x (to_Gromov_completion basepoint) \\<ge> D \\<longrightarrow> extended_Gromov_product_at basepoint x y \\<ge> M)\"", "lemma inside_Gromov_distance_approx:\n  assumes \"C < (\\<infinity>::ereal)\"\n  shows \"\\<exists>e > 0. \\<forall>x y. extended_Gromov_distance (to_Gromov_completion basepoint) x \\<le> C \\<longrightarrow> dist x y \\<le> e\n          \\<longrightarrow> esqrt(extended_Gromov_distance x y) \\<le> 2 * ereal(dist x y)\"", "lemma Gromov_completion_boundary_limit:\n  assumes \"x \\<in> Gromov_boundary\"\n  shows \"(u \\<longlongrightarrow> x) F \\<longleftrightarrow> ((\\<lambda>n. extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow> \\<infinity>) F\"", "lemma extended_Gromov_product_tendsto_PInf_a_b:\n  assumes \"((\\<lambda>n. extended_Gromov_product_at a (u n) (v n)) \\<longlongrightarrow> \\<infinity>) F\"\n  shows \"((\\<lambda>n. extended_Gromov_product_at b (u n) (v n)) \\<longlongrightarrow> \\<infinity>) F\"", "lemma Gromov_completion_inside_limit:\n  assumes \"x \\<notin> Gromov_boundary\"\n  shows \"(u \\<longlongrightarrow> x) F \\<longleftrightarrow> ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0) F\"", "lemma to_Gromov_completion_lim [simp, tendsto_intros]:\n  \"((\\<lambda>n. to_Gromov_completion (u n)) \\<longlongrightarrow> to_Gromov_completion a) F \\<longleftrightarrow> (u \\<longlongrightarrow> a) F\"", "lemma Gromov_completion_converge_to_boundary_aux:\n  assumes \"x \\<in> Gromov_boundary\" \"abs_Gromov_completion v = x\" \"Gromov_completion_rel v v\"\n  shows \"(\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x) \\<longlonglongrightarrow> \\<infinity>\"", "lemma Gromov_completion_converge_to_boundary:\n  assumes \"x \\<in> Gromov_boundary\"\n  shows \"((\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x) \\<longleftrightarrow> (Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x)\"", "lemma Gromov_converging_at_boundary_converges:\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"\\<exists>x \\<in> Gromov_boundary. (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\"", "lemma Gromov_converging_at_boundary_converges':\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"convergent (\\<lambda>n. to_Gromov_completion (u n))\"", "lemma lim_imp_Gromov_converging_at_boundary:\n  fixes u::\"nat \\<Rightarrow> 'a::Gromov_hyperbolic_space\"\n  assumes \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\" \"x \\<in> Gromov_boundary\"\n  shows \"Gromov_converging_at_boundary u\"", "lemma same_limit_imp_Gromov_product_tendsto_infinity:\n  assumes \"z \\<in> Gromov_boundary\"\n          \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> z\"\n          \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> z\"\n  shows \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. Gromov_product_at a (u n) (v m) \\<ge> C\"", "lemma abs_Gromov_completion_limit:\n  assumes \"Gromov_completion_rel u u\"\n  shows \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> abs_Gromov_completion u\"", "lemma rep_Gromov_completion_limit:\n  \"(\\<lambda>n. to_Gromov_completion (rep_Gromov_completion x n)) \\<longlonglongrightarrow> x\"", "lemma extended_Gromov_product_inside_boundary_aux:\n  assumes \"y \\<in> Gromov_boundary\"\n  shows \"extended_Gromov_product_at e (to_Gromov_completion x) y = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e x (v n))) |v. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\"", "lemma extended_Gromov_product_boundary_inside_aux:\n  assumes \"y \\<in> Gromov_boundary\"\n  shows \"extended_Gromov_product_at e y (to_Gromov_completion x) = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e (v n) x)) |v. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\"", "lemma extended_Gromov_product_at_topological:\n  \"extended_Gromov_product_at e x y = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (v n))) |u v. (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x \\<and> (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\"", "lemma extended_Gromov_product_inside_boundary:\n  \"extended_Gromov_product_at e (to_Gromov_completion x) y = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e x (v n))) |v. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\"", "lemma extended_Gromov_product_boundary_inside:\n  \"extended_Gromov_product_at e y (to_Gromov_completion x) = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e (v n) x)) |v. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\"", "lemma extended_Gromov_product_le_liminf:\n  assumes \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> xi\"\n          \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> eta\"\n  shows \"liminf (\\<lambda>n. Gromov_product_at e (u n) (v n)) \\<ge> extended_Gromov_product_at e xi eta\"", "lemma limsup_le_extended_Gromov_product_inside:\n  assumes \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> (eta::('a::Gromov_hyperbolic_space) Gromov_completion)\"\n  shows \"limsup (\\<lambda>n. Gromov_product_at e x (v n)) \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta + deltaG(TYPE('a))\"", "lemma limsup_le_extended_Gromov_product_inside':\n  assumes \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> (eta::('a::Gromov_hyperbolic_space) Gromov_completion)\"\n  shows \"limsup (\\<lambda>n. Gromov_product_at e (v n) x) \\<le> extended_Gromov_product_at e eta (to_Gromov_completion x) + deltaG(TYPE('a))\"", "lemma limsup_le_extended_Gromov_product:\n  assumes \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> (xi::('a::Gromov_hyperbolic_space) Gromov_completion)\"\n          \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> eta\"\n  shows \"limsup (\\<lambda>n. Gromov_product_at e (u n) (v n)) \\<le> extended_Gromov_product_at e xi eta + 2 * deltaG(TYPE('a))\"", "lemma extended_Gromov_product_add_le:\n  \"extended_Gromov_product_at x xi (to_Gromov_completion y) + extended_Gromov_product_at y xi (to_Gromov_completion x) \\<le> dist x y\"", "lemma extended_Gromov_product_add_ge:\n  \"extended_Gromov_product_at (x::'a::Gromov_hyperbolic_space) xi (to_Gromov_completion y) + extended_Gromov_product_at y xi (to_Gromov_completion x) \\<ge> dist x y - deltaG(TYPE('a))\"", "lemma Gromov_converging_at_boundary_bounded_perturbation:\n  assumes \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\"\n          \"x \\<in> Gromov_boundary\"\n          \"\\<And>n. dist (u n) (v n) \\<le> C\"\n  shows \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> x\"", "lemma extended_Gromov_distance_continuous:\n  \"continuous_on UNIV (\\<lambda>y. extended_Gromov_distance x y)\"", "lemma extended_Gromov_distance_continuous':\n  \"continuous_on UNIV (\\<lambda>x. extended_Gromov_distance x y)\"", "lemma to_Gromov_completion_range_open:\n  \"open (range to_Gromov_completion)\"", "lemma Gromov_boundary_closed:\n  \"closed Gromov_boundary\"", "lemma to_Gromov_completion_range_dense [simp]:\n  \"closure (range to_Gromov_completion) = UNIV\"", "lemma to_Gromov_completion_homeomorphism:\n  \"homeomorphism_on UNIV to_Gromov_completion\"", "lemma to_Gromov_completion_continuous:\n  \"continuous_on UNIV to_Gromov_completion\"", "lemma from_Gromov_completion_continuous:\n  \"homeomorphism_on (range to_Gromov_completion) from_Gromov_completion\"\n  \"continuous_on (range to_Gromov_completion) from_Gromov_completion\"\n  \"\\<And>x::('a::Gromov_hyperbolic_space) Gromov_completion. x \\<in> range to_Gromov_completion \\<Longrightarrow> continuous (at x) from_Gromov_completion\"", "theorem Gromov_completion_compact:\n  assumes \"proper (UNIV::'a::Gromov_hyperbolic_space_geodesic set)\"\n  shows \"compact (UNIV::'a Gromov_completion set)\"", "lemma real_Gromov_converging_to_boundary:\n  fixes u::\"nat \\<Rightarrow> real\"\n  shows \"Gromov_converging_at_boundary u \\<longleftrightarrow> ((u \\<longlonglongrightarrow> \\<infinity>) \\<or> (u \\<longlonglongrightarrow> - \\<infinity>))\"", "lemma real_Gromov_completion_rel_PInf:\n  fixes u v::\"nat \\<Rightarrow> real\"\n  assumes \"u \\<longlonglongrightarrow> \\<infinity>\" \"v \\<longlonglongrightarrow> \\<infinity>\"\n  shows \"Gromov_completion_rel u v\"", "lemma real_Gromov_completion_rel_MInf:\n  fixes u v::\"nat \\<Rightarrow> real\"\n  assumes \"u \\<longlonglongrightarrow> -\\<infinity>\" \"v \\<longlonglongrightarrow> -\\<infinity>\"\n  shows \"Gromov_completion_rel u v\"", "lemma bij_to_real_Gromov_completion:\n  \"bij to_real_Gromov_completion\""], "translations": [["", "lemma bdd_below [simp]:\n  \"bdd_below {(\\<Sum> i = 0..<n. f (u i) (u (Suc i)))| u (n::nat). u 0 = x \\<and> u n = y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_below\n     {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}", "apply (rule bdd_belowI[of _ 0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n                 u 0 = x \\<and> u n = y} \\<Longrightarrow>\n       0 \\<le> xa", "using nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> f ?x ?y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n                 u 0 = x \\<and> u n = y} \\<Longrightarrow>\n       0 \\<le> xa", "by (auto simp add: sum_nonneg)"], ["", "lemma nonempty:\n  \"{\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n     u 0 = x \\<and> u n = y} \\<noteq>\n    {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n     u 0 = x \\<and> u n = y} \\<noteq>\n    {}", "define u::\"nat \\<Rightarrow> 'a\" where \"u = (\\<lambda>n. if n = 0 then x else y)\""], ["proof (state)\nthis:\n  u = (\\<lambda>n. if n = 0 then x else y)\n\ngoal (1 subgoal):\n 1. {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n     u 0 = x \\<and> u n = y} \\<noteq>\n    {}", "define n::nat where \"n = 1\""], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n     u 0 = x \\<and> u n = y} \\<noteq>\n    {}", "have \"u 0 = x \\<and> u n = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u 0 = x \\<and> u n = y", "unfolding u_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 = 0 then x else y) = x \\<and> (if 1 = 0 then x else y) = y", "by auto"], ["proof (state)\nthis:\n  u 0 = x \\<and> u n = y\n\ngoal (1 subgoal):\n 1. {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n     u 0 = x \\<and> u n = y} \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  u 0 = x \\<and> u n = y", "have \"(\\<Sum>i = 0..<n. f (u i) (u (Suc i))) \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\""], ["proof (prove)\nusing this:\n  u 0 = x \\<and> u n = y\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n    \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n           u 0 = x \\<and> u n = y}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n  \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n\ngoal (1 subgoal):\n 1. {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n     u 0 = x \\<and> u n = y} \\<noteq>\n    {}", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n  \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n  \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n\ngoal (1 subgoal):\n 1. {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n     u 0 = x \\<and> u n = y} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n   u 0 = x \\<and> u n = y} \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can now prove that \\verb+turn_into_distance f+ satisfies all the properties of a distance.\nFirst, it is nonnegative.\\<close>"], ["", "lemma TID_nonneg:\n  \"turn_into_distance f x y \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> turn_into_distance f x y", "unfolding turn_into_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n                 u 0 = x \\<and> u n = y}", "apply (rule cInf_greatest[OF nonempty])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n                 u 0 = x \\<and> u n = y} \\<Longrightarrow>\n       0 \\<le> xa", "using nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> f ?x ?y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n                 u 0 = x \\<and> u n = y} \\<Longrightarrow>\n       0 \\<le> xa", "by (auto simp add: sum_nonneg)"], ["", "text \\<open>For the symmetry, we use the symmetry of $f$, and go backwards along a chain of points,\nreplacing a sequence from $x$ to $y$ with a sequence from $y$ to $x$.\\<close>"], ["", "lemma TID_sym:\n  \"turn_into_distance f x y = turn_into_distance f y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance f x y = turn_into_distance f y x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. turn_into_distance f x y = turn_into_distance f y x", "have \"turn_into_distance f x y \\<le> Inf {(\\<Sum> i \\<in> {0..<n}. f (u i) (u (Suc i)))| u (n::nat). u 0 = y \\<and> u n = x}\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance f x y\n    \\<le> Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n               u 0 = y \\<and> u n = x}", "proof (rule cInf_greatest[OF nonempty], auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "fix u::\"nat \\<Rightarrow> 'a\" and n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "assume U: \"y = u 0\" \"x = u n\""], ["proof (state)\nthis:\n  y = u 0\n  x = u n\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "define v::\"nat \\<Rightarrow>'a\" where \"v = (\\<lambda>i. u (n-i))\""], ["proof (state)\nthis:\n  v = (\\<lambda>i. u (n - i))\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "have V: \"v 0 = x\" \"v n = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v 0 = x &&& v n = y", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u (n - 0) = x &&& u (n - n) = y", "using U"], ["proof (prove)\nusing this:\n  y = u 0\n  x = u n\n\ngoal (1 subgoal):\n 1. u (n - 0) = x &&& u (n - n) = y", "by auto"], ["proof (state)\nthis:\n  v 0 = x\n  v n = y\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "have \"(\\<Sum>i = 0..<n. f (u i) (u (Suc i))) = (\\<Sum>i = 0..<n. (\\<lambda>i. f (u i) (u (Suc i))) (n-1-i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) =\n    (\\<Sum>i = 0..<n. f (u (n - 1 - i)) (u (Suc (n - 1 - i))))", "apply (rule sum.reindex_bij_betw[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ((-) (n - 1)) {0..<n} {0..<n}", "by (rule bij_betw_byWitness[of _ \"\\<lambda>i. n-1-i\"], auto)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) =\n  (\\<Sum>i = 0..<n. f (u (n - 1 - i)) (u (Suc (n - 1 - i))))\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) =\n  (\\<Sum>i = 0..<n. f (u (n - 1 - i)) (u (Suc (n - 1 - i))))\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "have \"... = (\\<Sum> i = 0..<n. f (v (Suc i)) (v i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (u (n - 1 - i)) (u (Suc (n - 1 - i)))) =\n    (\\<Sum>i = 0..<n. f (v (Suc i)) (v i))", "apply (rule sum.cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       f (u (n - 1 - x)) (u (Suc (n - 1 - x))) = f (v (Suc x)) (v x)", "unfolding v_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..<n} = {0..<n}\n 2. \\<And>x.\n       x \\<in> {0..<n} \\<Longrightarrow>\n       f (u (n - 1 - x)) (u (Suc (n - 1 - x))) =\n       f (u (n - Suc x)) (u (n - x))", "by (auto simp add: Suc_diff_Suc)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (u (n - 1 - i)) (u (Suc (n - 1 - i)))) =\n  (\\<Sum>i = 0..<n. f (v (Suc i)) (v i))\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (u (n - 1 - i)) (u (Suc (n - 1 - i)))) =\n  (\\<Sum>i = 0..<n. f (v (Suc i)) (v i))\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "have \"... = (\\<Sum> i = 0..<n. f (v i) (v (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (v (Suc i)) (v i)) =\n    (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))", "using sym"], ["proof (prove)\nusing this:\n  f ?x ?y = f ?y ?x\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (v (Suc i)) (v i)) =\n    (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (v (Suc i)) (v i)) =\n  (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) =\n  (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))", "have \"(\\<Sum>i = 0..<n. f (u i) (u (Suc i))) = (\\<Sum> i = 0..<n. f (v i) (v (Suc i)))\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) =\n  (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) =\n    (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) =\n  (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) =\n  (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "have \"turn_into_distance f x y \\<le> (\\<Sum> i = 0..<n. f (v i) (v (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance f x y \\<le> (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))", "unfolding turn_into_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n    \\<le> (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))", "apply (rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))\n    \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n           u 0 = x \\<and> u n = y}\n 2. bdd_below\n     {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}", "using V"], ["proof (prove)\nusing this:\n  v 0 = x\n  v n = y\n\ngoal (2 subgoals):\n 1. (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))\n    \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n           u 0 = x \\<and> u n = y}\n 2. bdd_below\n     {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}", "by auto"], ["proof (state)\nthis:\n  turn_into_distance f x y \\<le> (\\<Sum>i = 0..<n. f (v i) (v (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<And>u n.\n       \\<lbrakk>y = u 0; x = u n\\<rbrakk>\n       \\<Longrightarrow> turn_into_distance f (u n) (u 0)\n                         \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "finally"], ["proof (chain)\npicking this:\n  turn_into_distance f x y \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "show \"turn_into_distance f (u n) (u 0) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\""], ["proof (prove)\nusing this:\n  turn_into_distance f x y \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. turn_into_distance f (u n) (u 0)\n    \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "using U"], ["proof (prove)\nusing this:\n  turn_into_distance f x y \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n  y = u 0\n  x = u n\n\ngoal (1 subgoal):\n 1. turn_into_distance f (u n) (u 0)\n    \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "by auto"], ["proof (state)\nthis:\n  turn_into_distance f (u n) (u 0)\n  \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  turn_into_distance f ?x ?y\n  \\<le> Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n             u 0 = ?y \\<and> u n = ?x}\n\ngoal (1 subgoal):\n 1. turn_into_distance f x y = turn_into_distance f y x", "then"], ["proof (chain)\npicking this:\n  turn_into_distance f ?x ?y\n  \\<le> Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n             u 0 = ?y \\<and> u n = ?x}", "have *: \"turn_into_distance f x y \\<le> turn_into_distance f y x\" for x y"], ["proof (prove)\nusing this:\n  turn_into_distance f ?x ?y\n  \\<le> Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n             u 0 = ?y \\<and> u n = ?x}\n\ngoal (1 subgoal):\n 1. turn_into_distance f x y \\<le> turn_into_distance f y x", "unfolding turn_into_distance_def"], ["proof (prove)\nusing this:\n  Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = ?x \\<and> u n = ?y}\n  \\<le> Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n             u 0 = ?y \\<and> u n = ?x}\n\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n    \\<le> Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n               u 0 = y \\<and> u n = x}", "by auto"], ["proof (state)\nthis:\n  turn_into_distance f ?x ?y \\<le> turn_into_distance f ?y ?x\n\ngoal (1 subgoal):\n 1. turn_into_distance f x y = turn_into_distance f y x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance f x y = turn_into_distance f y x", "using *[of x y] *[of y x]"], ["proof (prove)\nusing this:\n  turn_into_distance f x y \\<le> turn_into_distance f y x\n  turn_into_distance f y x \\<le> turn_into_distance f x y\n\ngoal (1 subgoal):\n 1. turn_into_distance f x y = turn_into_distance f y x", "by simp"], ["proof (state)\nthis:\n  turn_into_distance f x y = turn_into_distance f y x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>There is a trivial upper bound by $f$, using the single chain $x, y$.\\<close>"], ["", "lemma upper:\n  \"turn_into_distance f x y \\<le> f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance f x y \\<le> f x y", "unfolding turn_into_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n    \\<le> f x y", "proof (rule cInf_lower, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u n.\n       f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) \\<and>\n       u 0 = x \\<and> u n = y", "define u::\"nat \\<Rightarrow> 'a\" where \"u = (\\<lambda>n. if n = 0 then x else y)\""], ["proof (state)\nthis:\n  u = (\\<lambda>n. if n = 0 then x else y)\n\ngoal (1 subgoal):\n 1. \\<exists>u n.\n       f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) \\<and>\n       u 0 = x \\<and> u n = y", "define n::nat where \"n = 1\""], ["proof (state)\nthis:\n  n = 1\n\ngoal (1 subgoal):\n 1. \\<exists>u n.\n       f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) \\<and>\n       u 0 = x \\<and> u n = y", "have \"u 0 = x \\<and> u n = y \\<and> f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u 0 = x \\<and>\n    u n = y \\<and> f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "unfolding u_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 = 0 then x else y) = x \\<and>\n    (if 1 = 0 then x else y) = y \\<and>\n    f x y =\n    (\\<Sum>i = 0..<1.\n        f (if i = 0 then x else y) (if Suc i = 0 then x else y))", "by auto"], ["proof (state)\nthis:\n  u 0 = x \\<and>\n  u n = y \\<and> f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<exists>u n.\n       f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) \\<and>\n       u 0 = x \\<and> u n = y", "then"], ["proof (chain)\npicking this:\n  u 0 = x \\<and>\n  u n = y \\<and> f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "show \"\\<exists>u n. f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) \\<and> u 0 = x \\<and> u n = y\""], ["proof (prove)\nusing this:\n  u 0 = x \\<and>\n  u n = y \\<and> f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<exists>u n.\n       f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) \\<and>\n       u 0 = x \\<and> u n = y", "by auto"], ["proof (state)\nthis:\n  \\<exists>u n.\n     f x y = (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) \\<and>\n     u 0 = x \\<and> u n = y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The new distance vanishes on a pair of equal points, as this is already the case for $f$.\\<close>"], ["", "lemma TID_self_zero:\n  \"turn_into_distance f x x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance f x x = 0", "using upper[of x x] TID_nonneg[of x x] self_zero[of x]"], ["proof (prove)\nusing this:\n  turn_into_distance f x x \\<le> f x x\n  0 \\<le> turn_into_distance f x x\n  f x x = 0\n\ngoal (1 subgoal):\n 1. turn_into_distance f x x = 0", "by auto"], ["", "text \\<open>For the triangular inequality, we concatenate a sequence from $x$ to $y$ almost realizing the\ninfimum, and a sequence from $y$ to $z$ almost realizing the infimum, to obtain a sequence from\n$x$ to $z$ along which the sums of $f$ is almost bounded by\n\\verb|turn_into_distance f x y + turn_into_distance f y z|.\n\\<close>"], ["", "lemma triangle:\n  \"turn_into_distance f x z \\<le> turn_into_distance f x y + turn_into_distance f y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z", "have \"turn_into_distance f x z \\<le> turn_into_distance f x y + turn_into_distance f y z + e\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "have \"Inf {(\\<Sum> i \\<in> {0..<n}. f (u i) (u (Suc i)))| u (n::nat). u 0 = x \\<and> u n = y} < turn_into_distance f x y + e/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n    < turn_into_distance f x y + e / 2", "unfolding turn_into_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n    < Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n           u 0 = x \\<and> u n = y} +\n      e / 2", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n    < Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n           u 0 = x \\<and> u n = y} +\n      e / 2", "by auto"], ["proof (state)\nthis:\n  Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n  < turn_into_distance f x y + e / 2\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "then"], ["proof (chain)\npicking this:\n  Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n  < turn_into_distance f x y + e / 2", "have \"\\<exists>a \\<in> {(\\<Sum> i \\<in> {0..<n}. f (u i) (u (Suc i)))| u (n::nat). u 0 = x \\<and> u n = y}. a < turn_into_distance f x y + e/2\""], ["proof (prove)\nusing this:\n  Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = y}\n  < turn_into_distance f x y + e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>{\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n                    u 0 = x \\<and> u n = y}.\n       a < turn_into_distance f x y + e / 2", "by (rule cInf_lessD[OF nonempty])"], ["proof (state)\nthis:\n  \\<exists>a\\<in>{\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n                  u 0 = x \\<and> u n = y}.\n     a < turn_into_distance f x y + e / 2\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "then"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>{\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n                  u 0 = x \\<and> u n = y}.\n     a < turn_into_distance f x y + e / 2", "obtain u n where U: \"u 0 = x\" \"u n = y\" \"(\\<Sum> i \\<in> {0..<n}. f (u i) (u (Suc i))) < turn_into_distance f x y + e/2\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>{\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n                  u 0 = x \\<and> u n = y}.\n     a < turn_into_distance f x y + e / 2\n\ngoal (1 subgoal):\n 1. (\\<And>u n.\n        \\<lbrakk>u 0 = x; u n = y;\n         (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n         < turn_into_distance f x y + e / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u 0 = x\n  u n = y\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) < turn_into_distance f x y + e / 2\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "have \"Inf {(\\<Sum> i \\<in> {0..<m}. f (v i) (v (Suc i)))| v (m::nat). v 0 = y \\<and> v m = z} < turn_into_distance f y z + e/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m. v 0 = y \\<and> v m = z}\n    < turn_into_distance f y z + e / 2", "unfolding turn_into_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m. v 0 = y \\<and> v m = z}\n    < Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n           u 0 = y \\<and> u n = z} +\n      e / 2", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m. v 0 = y \\<and> v m = z}\n    < Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n           u 0 = y \\<and> u n = z} +\n      e / 2", "by auto"], ["proof (state)\nthis:\n  Inf {\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m. v 0 = y \\<and> v m = z}\n  < turn_into_distance f y z + e / 2\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "then"], ["proof (chain)\npicking this:\n  Inf {\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m. v 0 = y \\<and> v m = z}\n  < turn_into_distance f y z + e / 2", "have \"\\<exists>a \\<in> {(\\<Sum> i \\<in> {0..<m}. f (v i) (v (Suc i)))| v (m::nat). v 0 = y \\<and> v m = z}. a < turn_into_distance f y z + e/2\""], ["proof (prove)\nusing this:\n  Inf {\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m. v 0 = y \\<and> v m = z}\n  < turn_into_distance f y z + e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>a\\<in>{\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m.\n                    v 0 = y \\<and> v m = z}.\n       a < turn_into_distance f y z + e / 2", "by (rule cInf_lessD[OF nonempty])"], ["proof (state)\nthis:\n  \\<exists>a\\<in>{\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m.\n                  v 0 = y \\<and> v m = z}.\n     a < turn_into_distance f y z + e / 2\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "then"], ["proof (chain)\npicking this:\n  \\<exists>a\\<in>{\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m.\n                  v 0 = y \\<and> v m = z}.\n     a < turn_into_distance f y z + e / 2", "obtain v m where V: \"v 0 = y\" \"v m = z\" \"(\\<Sum> i \\<in> {0..<m}. f (v i) (v (Suc i))) < turn_into_distance f y z + e/2\""], ["proof (prove)\nusing this:\n  \\<exists>a\\<in>{\\<Sum>i = 0..<m. f (v i) (v (Suc i)) |v m.\n                  v 0 = y \\<and> v m = z}.\n     a < turn_into_distance f y z + e / 2\n\ngoal (1 subgoal):\n 1. (\\<And>v m.\n        \\<lbrakk>v 0 = y; v m = z;\n         (\\<Sum>i = 0..<m. f (v i) (v (Suc i)))\n         < turn_into_distance f y z + e / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v 0 = y\n  v m = z\n  (\\<Sum>i = 0..<m. f (v i) (v (Suc i))) < turn_into_distance f y z + e / 2\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "define w where \"w = (\\<lambda>i. if i < n then u i else v (i-n))\""], ["proof (state)\nthis:\n  w = (\\<lambda>i. if i < n then u i else v (i - n))\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "have *: \"w 0 = x\" \"w (n+m) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w 0 = x &&& w (n + m) = z", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 < n then u 0 else v (0 - n)) = x &&&\n    (if n + m < n then u (n + m) else v (n + m - n)) = z", "using U V"], ["proof (prove)\nusing this:\n  u 0 = x\n  u n = y\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) < turn_into_distance f x y + e / 2\n  v 0 = y\n  v m = z\n  (\\<Sum>i = 0..<m. f (v i) (v (Suc i))) < turn_into_distance f y z + e / 2\n\ngoal (1 subgoal):\n 1. (if 0 < n then u 0 else v (0 - n)) = x &&&\n    (if n + m < n then u (n + m) else v (n + m - n)) = z", "by auto"], ["proof (state)\nthis:\n  w 0 = x\n  w (n + m) = z\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "have \"turn_into_distance f x z \\<le> (\\<Sum>i = 0..<n+m. f (w i) (w (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> (\\<Sum>i = 0..<n + m. f (w i) (w (Suc i)))", "unfolding turn_into_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = z}\n    \\<le> (\\<Sum>i = 0..<n + m. f (w i) (w (Suc i)))", "apply (rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Sum>i = 0..<n + m. f (w i) (w (Suc i)))\n    \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n           u 0 = x \\<and> u n = z}\n 2. bdd_below\n     {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = z}", "using *"], ["proof (prove)\nusing this:\n  w 0 = x\n  w (n + m) = z\n\ngoal (2 subgoals):\n 1. (\\<Sum>i = 0..<n + m. f (w i) (w (Suc i)))\n    \\<in> {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n           u 0 = x \\<and> u n = z}\n 2. bdd_below\n     {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n. u 0 = x \\<and> u n = z}", "by auto"], ["proof (state)\nthis:\n  turn_into_distance f x z \\<le> (\\<Sum>i = 0..<n + m. f (w i) (w (Suc i)))\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "also"], ["proof (state)\nthis:\n  turn_into_distance f x z \\<le> (\\<Sum>i = 0..<n + m. f (w i) (w (Suc i)))\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "have \"... = (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) + (\\<Sum>i = n..<n+m. f (w i) (w (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n + m. f (w i) (w (Suc i))) =\n    (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n    (\\<Sum>i = n..<n + m. f (w i) (w (Suc i)))", "by (simp add: sum.atLeastLessThan_concat)"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n + m. f (w i) (w (Suc i))) =\n  (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n  (\\<Sum>i = n..<n + m. f (w i) (w (Suc i)))\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n + m. f (w i) (w (Suc i))) =\n  (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n  (\\<Sum>i = n..<n + m. f (w i) (w (Suc i)))\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "have \"... = (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) + (\\<Sum>i = 0..<m. f (w (i+n)) (w (Suc (i+n))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n    (\\<Sum>i = n..<n + m. f (w i) (w (Suc i))) =\n    (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n    (\\<Sum>i = 0..<m. f (w (i + n)) (w (Suc (i + n))))", "by (auto intro!: sum.reindex_bij_betw[symmetric] bij_betw_byWitness[of _ \"\\<lambda>i. i-n\"])"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n  (\\<Sum>i = n..<n + m. f (w i) (w (Suc i))) =\n  (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n  (\\<Sum>i = 0..<m. f (w (i + n)) (w (Suc (i + n))))\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n  (\\<Sum>i = n..<n + m. f (w i) (w (Suc i))) =\n  (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n  (\\<Sum>i = 0..<m. f (w (i + n)) (w (Suc (i + n))))\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "have \"... = (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) + (\\<Sum>i = 0..<m. f (v i) (v (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n    (\\<Sum>i = 0..<m. f (w (i + n)) (w (Suc (i + n)))) =\n    (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) +\n    (\\<Sum>i = 0..<m. f (v i) (v (Suc i)))", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n.\n        f (if i < n then u i else v (i - n))\n         (if Suc i < n then u (Suc i) else v (Suc i - n))) +\n    (\\<Sum>i = 0..<m.\n        f (if i + n < n then u (i + n) else v (i + n - n))\n         (if Suc (i + n) < n then u (Suc (i + n))\n          else v (Suc (i + n) - n))) =\n    (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) +\n    (\\<Sum>i = 0..<m. f (v i) (v (Suc i)))", "apply (auto intro!: sum.cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<not> Suc x < n\\<rbrakk>\n       \\<Longrightarrow> f (u x) (v 0) = f (u x) (u (Suc x))", "using U(2) V(1) Suc_lessI"], ["proof (prove)\nusing this:\n  u n = y\n  v 0 = y\n  \\<lbrakk>?m < ?n; Suc ?m \\<noteq> ?n\\<rbrakk>\n  \\<Longrightarrow> Suc ?m < ?n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x < n; \\<not> Suc x < n\\<rbrakk>\n       \\<Longrightarrow> f (u x) (v 0) = f (u x) (u (Suc x))", "by fastforce"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n  (\\<Sum>i = 0..<m. f (w (i + n)) (w (Suc (i + n)))) =\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) +\n  (\\<Sum>i = 0..<m. f (v i) (v (Suc i)))\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (w i) (w (Suc i))) +\n  (\\<Sum>i = 0..<m. f (w (i + n)) (w (Suc (i + n)))) =\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) +\n  (\\<Sum>i = 0..<m. f (v i) (v (Suc i)))\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "have \"... < turn_into_distance f x y + e/2 + turn_into_distance f y z + e/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) +\n    (\\<Sum>i = 0..<m. f (v i) (v (Suc i)))\n    < turn_into_distance f x y + e / 2 + turn_into_distance f y z + e / 2", "using U(3) V(3)"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) < turn_into_distance f x y + e / 2\n  (\\<Sum>i = 0..<m. f (v i) (v (Suc i))) < turn_into_distance f y z + e / 2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) +\n    (\\<Sum>i = 0..<m. f (v i) (v (Suc i)))\n    < turn_into_distance f x y + e / 2 + turn_into_distance f y z + e / 2", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) +\n  (\\<Sum>i = 0..<m. f (v i) (v (Suc i)))\n  < turn_into_distance f x y + e / 2 + turn_into_distance f y z + e / 2\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "finally"], ["proof (chain)\npicking this:\n  turn_into_distance f x z\n  < turn_into_distance f x y + e / 2 + turn_into_distance f y z + e / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  turn_into_distance f x z\n  < turn_into_distance f x y + e / 2 + turn_into_distance f y z + e / 2\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z + e", "by auto"], ["proof (state)\nthis:\n  turn_into_distance f x z\n  \\<le> turn_into_distance f x y + turn_into_distance f y z + e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow>\n  turn_into_distance f x z\n  \\<le> turn_into_distance f x y + turn_into_distance f y z + ?e\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow>\n  turn_into_distance f x z\n  \\<le> turn_into_distance f x y + turn_into_distance f y z + ?e", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  turn_into_distance f x z\n  \\<le> turn_into_distance f x y + turn_into_distance f y z + ?e\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z", "using field_le_epsilon"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  turn_into_distance f x z\n  \\<le> turn_into_distance f x y + turn_into_distance f y z + ?e\n  (\\<And>e.\n      (0::?'a) < e \\<Longrightarrow> ?x \\<le> ?y + e) \\<Longrightarrow>\n  ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. turn_into_distance f x z\n    \\<le> turn_into_distance f x y + turn_into_distance f y z", "by blast"], ["proof (state)\nthis:\n  turn_into_distance f x z\n  \\<le> turn_into_distance f x y + turn_into_distance f y z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now comes the only nontrivial statement of the construction, the fact that the new\ndistance is bounded from below by $f/2$.\n\nHere is the mathematical proof. We show by induction that all chains from $x$ to\n$y$ satisfy this bound. Assume this is done for all chains of length $ < n$, we do it for a\nchain of length $n$. Write $S = \\sum f(u_i, u_{i+1})$ for the sum along the chain. Introduce $p$\nthe last index where the sum is $\\leq S/2$. Then the sum from $0$ to $p$ is $\\leq S/2$, and the sum\nfrom $p+1$ to $n$ is also $\\leq S/2$ (by maximality of $p$). The induction assumption\ngives that $f (x, u_p)$ is bounded by twice the sum from $0$ to $p$, which is at most $S$. Same\nthing for $f(u_{p+1}, y)$. With the weird triangle inequality applied two times, we get\n$f (x, y) \\leq 2 \\max(f(x,u_p), f(u_p, u_{p+1}), f(u_{p+1}, y)) \\leq 2S$, as claimed.\n\nThe formalization presents no difficulty.\n\\<close>"], ["", "lemma lower:\n  \"f x y \\<le> 2 * turn_into_distance f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y \\<le> 2 * turn_into_distance f x y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f x y \\<le> 2 * turn_into_distance f x y", "have I: \"f (u 0) (u n) \\<le> (\\<Sum> i \\<in> {0..<n}. f (u i) (u (Suc i))) * 2\" for n u"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "proof (induction n arbitrary: u rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x u.\n       (\\<And>y u.\n           y < x \\<Longrightarrow>\n           f (u 0) (u y)\n           \\<le> (\\<Sum>i = 0..<y. f (u i) (u (Suc i))) *\n                 2) \\<Longrightarrow>\n       f (u 0) (u x) \\<le> (\\<Sum>i = 0..<x. f (u i) (u (Suc i))) * 2", "case (less n)"], ["proof (state)\nthis:\n  ?y < n \\<Longrightarrow>\n  f (?u 0) (?u ?y) \\<le> (\\<Sum>i = 0..<?y. f (?u i) (?u (Suc i))) * 2\n\ngoal (1 subgoal):\n 1. \\<And>x u.\n       (\\<And>y u.\n           y < x \\<Longrightarrow>\n           f (u 0) (u y)\n           \\<le> (\\<Sum>i = 0..<y. f (u i) (u (Suc i))) *\n                 2) \\<Longrightarrow>\n       f (u 0) (u x) \\<le> (\\<Sum>i = 0..<x. f (u i) (u (Suc i))) * 2", "show \"f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "then"], ["proof (chain)\npicking this:\n  n = 0", "have \"f (u 0) (u n) = 0\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. f (u 0) (u n) = 0", "using self_zero"], ["proof (prove)\nusing this:\n  n = 0\n  f ?x ?x = 0\n\ngoal (1 subgoal):\n 1. f (u 0) (u n) = 0", "by auto"], ["proof (state)\nthis:\n  f (u 0) (u n) = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "then"], ["proof (chain)\npicking this:\n  f (u 0) (u n) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  f (u 0) (u n) = 0\n\ngoal (1 subgoal):\n 1. f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "using True"], ["proof (prove)\nusing this:\n  f (u 0) (u n) = 0\n  n = 0\n\ngoal (1 subgoal):\n 1. f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "by auto"], ["proof (state)\nthis:\n  f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have \"n > 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "define S where \"S = (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\""], ["proof (state)\nthis:\n  S = (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"S \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "using nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> f ?x ?y\n\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))", "by (auto simp add: sum_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> S\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"\\<exists>p. p < n \\<and> (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S/2 \\<and> (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "proof (cases \"S = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. S = 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n 2. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "case True"], ["proof (state)\nthis:\n  S = 0\n\ngoal (2 subgoals):\n 1. S = 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n 2. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"(\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) = (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) - f(u 0) (u (Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) =\n    (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) - f (u 0) (u (Suc 0))", "using sum.atLeast_Suc_lessThan[OF \\<open>n > 0\\<close>, of \"\\<lambda>i. f (u i) (u (Suc i))\"]"], ["proof (prove)\nusing this:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) =\n  f (u 0) (u (Suc 0)) + (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) =\n    (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) - f (u 0) (u (Suc 0))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) =\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) - f (u 0) (u (Suc 0))\n\ngoal (2 subgoals):\n 1. S = 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n 2. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) =\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) - f (u 0) (u (Suc 0))\n\ngoal (2 subgoals):\n 1. S = 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n 2. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"... \\<le> S/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) - f (u 0) (u (Suc 0)) \\<le> S / 2", "using True S_def nonneg"], ["proof (prove)\nusing this:\n  S = 0\n  S = (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n  0 \\<le> f ?x ?y\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) - f (u 0) (u (Suc 0)) \\<le> S / 2", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) - f (u 0) (u (Suc 0)) \\<le> S / 2\n\ngoal (2 subgoals):\n 1. S = 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n 2. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"0 < n \\<and> (\\<Sum>i = 0..<0. f (u i) (u (Suc i))) \\<le> S/2 \\<and> (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) \\<le> S/2\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. 0 < n \\<and>\n    (\\<Sum>i = 0..<0. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n    (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) \\<le> S / 2", "using \\<open>n > 0\\<close> \\<open>S = 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) \\<le> S / 2\n  0 < n\n  S = 0\n\ngoal (1 subgoal):\n 1. 0 < n \\<and>\n    (\\<Sum>i = 0..<0. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n    (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) \\<le> S / 2", "by auto"], ["proof (state)\nthis:\n  0 < n \\<and>\n  (\\<Sum>i = 0..<0. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n  (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (2 subgoals):\n 1. S = 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n 2. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "then"], ["proof (chain)\npicking this:\n  0 < n \\<and>\n  (\\<Sum>i = 0..<0. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n  (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) \\<le> S / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < n \\<and>\n  (\\<Sum>i = 0..<0. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n  (\\<Sum>i = Suc 0..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "by auto"], ["proof (state)\nthis:\n  \\<exists>p<n.\n     (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n     (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "case False"], ["proof (state)\nthis:\n  S \\<noteq> 0\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "then"], ["proof (chain)\npicking this:\n  S \\<noteq> 0", "have \"S > 0\""], ["proof (prove)\nusing this:\n  S \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < S", "using \\<open>S \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  S \\<noteq> 0\n  0 \\<le> S\n\ngoal (1 subgoal):\n 1. 0 < S", "by simp"], ["proof (state)\nthis:\n  0 < S\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "define A where \"A = {q. q \\<le> n \\<and> (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S/2}\""], ["proof (state)\nthis:\n  A =\n  {q. q \\<le> n \\<and> (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"0 \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {q. q \\<le> n \\<and>\n                (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}", "using \\<open>S > 0\\<close> \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < S\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 \\<in> {q. q \\<le> n \\<and>\n                (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}", "by auto"], ["proof (state)\nthis:\n  0 \\<in> A\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"n \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> {q. q \\<le> n \\<and>\n                   (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}", "using \\<open>S > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < S\n\ngoal (1 subgoal):\n 1. n \\<notin> {q. q \\<le> n \\<and>\n                   (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}", "unfolding S_def"], ["proof (prove)\nusing this:\n  0 < (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. n \\<notin> {q. q \\<le> n \\<and>\n                   (\\<Sum>i = 0..<q. f (u i) (u (Suc i)))\n                   \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) / 2}", "by auto"], ["proof (state)\nthis:\n  n \\<notin> A\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "define p where \"p = Max A\""], ["proof (state)\nthis:\n  p = Max A\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"p \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> A", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max A \\<in> A", "apply (rule Max_in)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite A\n 2. A \\<noteq> {}", "using \\<open>0 \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  0 \\<in> A\n\ngoal (2 subgoals):\n 1. finite A\n 2. A \\<noteq> {}", "unfolding A_def"], ["proof (prove)\nusing this:\n  0 \\<in> {q. q \\<le> n \\<and>\n              (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}\n\ngoal (2 subgoals):\n 1. finite\n     {q. q \\<le> n \\<and>\n         (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}\n 2. {q. q \\<le> n \\<and>\n        (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  p \\<in> A\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "then"], ["proof (chain)\npicking this:\n  p \\<in> A", "have L: \"p \\<le> n\" \"(\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S/2\""], ["proof (prove)\nusing this:\n  p \\<in> A\n\ngoal (1 subgoal):\n 1. p \\<le> n &&& (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2", "unfolding A_def"], ["proof (prove)\nusing this:\n  p \\<in> {q. q \\<le> n \\<and>\n              (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}\n\ngoal (1 subgoal):\n 1. p \\<le> n &&& (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2", "by auto"], ["proof (state)\nthis:\n  p \\<le> n\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "then"], ["proof (chain)\npicking this:\n  p \\<le> n\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2", "have \"p < n\""], ["proof (prove)\nusing this:\n  p \\<le> n\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. p < n", "using \\<open>n \\<notin> A\\<close> \\<open>p \\<in> A\\<close> le_neq_trans"], ["proof (prove)\nusing this:\n  p \\<le> n\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2\n  n \\<notin> A\n  p \\<in> A\n  \\<lbrakk>?a \\<le> ?b; ?a \\<noteq> ?b\\<rbrakk> \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. p < n", "by blast"], ["proof (state)\nthis:\n  p < n\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"Suc p \\<notin> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc p \\<notin> A", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (Max A) \\<notin> A", "by (metis (no_types, lifting) A_def Max_ge Suc_n_not_le_n infinite_nat_iff_unbounded mem_Collect_eq not_le p_def)"], ["proof (state)\nthis:\n  Suc p \\<notin> A\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "then"], ["proof (chain)\npicking this:\n  Suc p \\<notin> A", "have *: \"(\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i))) > S/2\""], ["proof (prove)\nusing this:\n  Suc p \\<notin> A\n\ngoal (1 subgoal):\n 1. S / 2 < (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))", "unfolding A_def"], ["proof (prove)\nusing this:\n  Suc p\n  \\<notin> {q. q \\<le> n \\<and>\n               (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}\n\ngoal (1 subgoal):\n 1. S / 2 < (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))", "using \\<open>p < n\\<close>"], ["proof (prove)\nusing this:\n  Suc p\n  \\<notin> {q. q \\<le> n \\<and>\n               (\\<Sum>i = 0..<q. f (u i) (u (Suc i))) \\<le> S / 2}\n  p < n\n\ngoal (1 subgoal):\n 1. S / 2 < (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))", "by auto"], ["proof (state)\nthis:\n  S / 2 < (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"(\\<Sum> i = Suc p..<n. f (u i) (u (Suc i))) = S - (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) =\n    S - (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) =\n    (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) -\n    (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))", "using \\<open>p < n\\<close>"], ["proof (prove)\nusing this:\n  p < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) =\n    (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) -\n    (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))", "by (metis (full_types) Suc_le_eq sum_diff_nat_ivl zero_le)"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) =\n  S - (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) =\n  S - (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"... \\<le> S/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S - (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i))) \\<le> S / 2", "using *"], ["proof (prove)\nusing this:\n  S / 2 < (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. S - (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i))) \\<le> S / 2", "by auto"], ["proof (state)\nthis:\n  S - (\\<Sum>i = 0..<Suc p. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "have \"p < n \\<and> (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S/2 \\<and> (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S/2\""], ["proof (prove)\nusing this:\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. p < n \\<and>\n    (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n    (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "using \\<open>p < n\\<close> L(2)"], ["proof (prove)\nusing this:\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n  p < n\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. p < n \\<and>\n    (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n    (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "by auto"], ["proof (state)\nthis:\n  p < n \\<and>\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. S \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "then"], ["proof (chain)\npicking this:\n  p < n \\<and>\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  p < n \\<and>\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. \\<exists>p<n.\n       (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n       (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "by auto"], ["proof (state)\nthis:\n  \\<exists>p<n.\n     (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n     (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p<n.\n     (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n     (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "then"], ["proof (chain)\npicking this:\n  \\<exists>p<n.\n     (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n     (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2", "obtain p where P: \"p < n\" \"(\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S/2\" \"(\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S/2\""], ["proof (prove)\nusing this:\n  \\<exists>p<n.\n     (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2 \\<and>\n     (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p < n; (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2;\n         (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p < n\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"f (u 0) (u p) \\<le> (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) * 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (u 0) (u p) \\<le> (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) * 2", "apply (rule less.IH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p < n", "using \\<open>p < n\\<close>"], ["proof (prove)\nusing this:\n  p < n\n\ngoal (1 subgoal):\n 1. p < n", "by auto"], ["proof (state)\nthis:\n  f (u 0) (u p) \\<le> (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) * 2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "then"], ["proof (chain)\npicking this:\n  f (u 0) (u p) \\<le> (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) * 2", "have A: \"f (u 0) (u p) \\<le> S\""], ["proof (prove)\nusing this:\n  f (u 0) (u p) \\<le> (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) * 2\n\ngoal (1 subgoal):\n 1. f (u 0) (u p) \\<le> S", "using P(2)"], ["proof (prove)\nusing this:\n  f (u 0) (u p) \\<le> (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) * 2\n  (\\<Sum>i = 0..<p. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. f (u 0) (u p) \\<le> S", "by auto"], ["proof (state)\nthis:\n  f (u 0) (u p) \\<le> S\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have B: \"f (u p) (u (Suc p)) \\<le> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (u p) (u (Suc p)) \\<le> S", "apply (rule sum_nonneg_leq_bound[of \"{0..<n}\" \"\\<lambda>i. f (u i) (u (Suc i))\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite {0..<n}\n 2. \\<And>i. i \\<in> {0..<n} \\<Longrightarrow> 0 \\<le> f (u i) (u (Suc i))\n 3. (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) = S\n 4. p \\<in> {0..<n}", "using nonneg S_def \\<open>p < n\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> f ?x ?y\n  S = (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n  p < n\n\ngoal (4 subgoals):\n 1. finite {0..<n}\n 2. \\<And>i. i \\<in> {0..<n} \\<Longrightarrow> 0 \\<le> f (u i) (u (Suc i))\n 3. (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) = S\n 4. p \\<in> {0..<n}", "by auto"], ["proof (state)\nthis:\n  f (u p) (u (Suc p)) \\<le> S\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"f (u (0 + Suc p)) (u ((n-Suc p) + Suc p)) \\<le> (\\<Sum>i = 0..<n-Suc p. f (u (i + Suc p)) (u (Suc i + Suc p))) * 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (u (0 + Suc p)) (u (n - Suc p + Suc p))\n    \\<le> (\\<Sum>i = 0..<n - Suc p. f (u (i + Suc p)) (u (Suc i + Suc p))) *\n          2", "apply (rule less.IH)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n - Suc p < n", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. n - Suc p < n", "by auto"], ["proof (state)\nthis:\n  f (u (0 + Suc p)) (u (n - Suc p + Suc p))\n  \\<le> (\\<Sum>i = 0..<n - Suc p. f (u (i + Suc p)) (u (Suc i + Suc p))) * 2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "also"], ["proof (state)\nthis:\n  f (u (0 + Suc p)) (u (n - Suc p + Suc p))\n  \\<le> (\\<Sum>i = 0..<n - Suc p. f (u (i + Suc p)) (u (Suc i + Suc p))) * 2\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"... = 2 * (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i = 0..<n - Suc p. f (u (i + Suc p)) (u (Suc i + Suc p))) * 2 =\n    2 * (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i)))", "by (auto intro!: sum.reindex_bij_betw bij_betw_byWitness[of _ \"\\<lambda>i. i - Suc p\"])"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - Suc p. f (u (i + Suc p)) (u (Suc i + Suc p))) * 2 =\n  2 * (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "also"], ["proof (state)\nthis:\n  (\\<Sum>i = 0..<n - Suc p. f (u (i + Suc p)) (u (Suc i + Suc p))) * 2 =\n  2 * (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"... \\<le> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S", "using P(3)"], ["proof (prove)\nusing this:\n  (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S / 2\n\ngoal (1 subgoal):\n 1. 2 * (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S", "by simp"], ["proof (state)\nthis:\n  2 * (\\<Sum>i = Suc p..<n. f (u i) (u (Suc i))) \\<le> S\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "finally"], ["proof (chain)\npicking this:\n  f (u (0 + Suc p)) (u (n - Suc p + Suc p)) \\<le> S", "have C: \"f (u (Suc p)) (u n) \\<le> S\""], ["proof (prove)\nusing this:\n  f (u (0 + Suc p)) (u (n - Suc p + Suc p)) \\<le> S\n\ngoal (1 subgoal):\n 1. f (u (Suc p)) (u n) \\<le> S", "using \\<open>p < n\\<close>"], ["proof (prove)\nusing this:\n  f (u (0 + Suc p)) (u (n - Suc p + Suc p)) \\<le> S\n  p < n\n\ngoal (1 subgoal):\n 1. f (u (Suc p)) (u n) \\<le> S", "by auto"], ["proof (state)\nthis:\n  f (u (Suc p)) (u n) \\<le> S\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"f (u 0) (u n) \\<le> sqrt 2 * max (f (u 0) (u p)) (f (u p) (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (u 0) (u n) \\<le> sqrt 2 * max (f (u 0) (u p)) (f (u p) (u n))", "using weak_triangle"], ["proof (prove)\nusing this:\n  f ?x ?z \\<le> sqrt 2 * max (f ?x ?y) (f ?y ?z)\n\ngoal (1 subgoal):\n 1. f (u 0) (u n) \\<le> sqrt 2 * max (f (u 0) (u p)) (f (u p) (u n))", "by simp"], ["proof (state)\nthis:\n  f (u 0) (u n) \\<le> sqrt 2 * max (f (u 0) (u p)) (f (u p) (u n))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "also"], ["proof (state)\nthis:\n  f (u 0) (u n) \\<le> sqrt 2 * max (f (u 0) (u p)) (f (u p) (u n))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"... \\<le> sqrt 2* max (f (u 0) (u p)) (sqrt 2 * max (f (u p) (u (Suc p))) (f (u (Suc p)) (u n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt 2 * max (f (u 0) (u p)) (f (u p) (u n))\n    \\<le> sqrt 2 *\n          max (f (u 0) (u p))\n           (sqrt 2 * max (f (u p) (u (Suc p))) (f (u (Suc p)) (u n)))", "using weak_triangle"], ["proof (prove)\nusing this:\n  f ?x ?z \\<le> sqrt 2 * max (f ?x ?y) (f ?y ?z)\n\ngoal (1 subgoal):\n 1. sqrt 2 * max (f (u 0) (u p)) (f (u p) (u n))\n    \\<le> sqrt 2 *\n          max (f (u 0) (u p))\n           (sqrt 2 * max (f (u p) (u (Suc p))) (f (u (Suc p)) (u n)))", "by simp (meson max.cobounded2 order_trans)"], ["proof (state)\nthis:\n  sqrt 2 * max (f (u 0) (u p)) (f (u p) (u n))\n  \\<le> sqrt 2 *\n        max (f (u 0) (u p))\n         (sqrt 2 * max (f (u p) (u (Suc p))) (f (u (Suc p)) (u n)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "also"], ["proof (state)\nthis:\n  sqrt 2 * max (f (u 0) (u p)) (f (u p) (u n))\n  \\<le> sqrt 2 *\n        max (f (u 0) (u p))\n         (sqrt 2 * max (f (u p) (u (Suc p))) (f (u (Suc p)) (u n)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"... \\<le> sqrt 2 * max S (sqrt 2 * max S S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt 2 *\n    max (f (u 0) (u p))\n     (sqrt 2 * max (f (u p) (u (Suc p))) (f (u (Suc p)) (u n)))\n    \\<le> sqrt 2 * max S (sqrt 2 * max S S)", "using A B C"], ["proof (prove)\nusing this:\n  f (u 0) (u p) \\<le> S\n  f (u p) (u (Suc p)) \\<le> S\n  f (u (Suc p)) (u n) \\<le> S\n\ngoal (1 subgoal):\n 1. sqrt 2 *\n    max (f (u 0) (u p))\n     (sqrt 2 * max (f (u p) (u (Suc p))) (f (u (Suc p)) (u n)))\n    \\<le> sqrt 2 * max S (sqrt 2 * max S S)", "by auto (simp add: le_max_iff_disj)"], ["proof (state)\nthis:\n  sqrt 2 *\n  max (f (u 0) (u p))\n   (sqrt 2 * max (f (u p) (u (Suc p))) (f (u (Suc p)) (u n)))\n  \\<le> sqrt 2 * max S (sqrt 2 * max S S)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "also"], ["proof (state)\nthis:\n  sqrt 2 *\n  max (f (u 0) (u p))\n   (sqrt 2 * max (f (u p) (u (Suc p))) (f (u (Suc p)) (u n)))\n  \\<le> sqrt 2 * max S (sqrt 2 * max S S)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"... \\<le> sqrt 2 * max (sqrt 2 * S) (sqrt 2 * max S S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt 2 * max S (sqrt 2 * max S S)\n    \\<le> sqrt 2 * max (sqrt 2 * S) (sqrt 2 * max S S)", "apply (intro mult_left_mono max.mono)"], ["proof (prove)\ngoal (5 subgoals):\n 1. S \\<le> sqrt 2 * S\n 2. S \\<le> S\n 3. S \\<le> S\n 4. 0 \\<le> sqrt 2\n 5. 0 \\<le> sqrt 2", "using \\<open>S \\<ge> 0\\<close> less_eq_real_def"], ["proof (prove)\nusing this:\n  0 \\<le> S\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (5 subgoals):\n 1. S \\<le> sqrt 2 * S\n 2. S \\<le> S\n 3. S \\<le> S\n 4. 0 \\<le> sqrt 2\n 5. 0 \\<le> sqrt 2", "by auto"], ["proof (state)\nthis:\n  sqrt 2 * max S (sqrt 2 * max S S)\n  \\<le> sqrt 2 * max (sqrt 2 * S) (sqrt 2 * max S S)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "also"], ["proof (state)\nthis:\n  sqrt 2 * max S (sqrt 2 * max S S)\n  \\<le> sqrt 2 * max (sqrt 2 * S) (sqrt 2 * max S S)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "have \"... = 2 * S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt 2 * max (sqrt 2 * S) (sqrt 2 * max S S) = 2 * S", "by auto"], ["proof (state)\nthis:\n  sqrt 2 * max (sqrt 2 * S) (sqrt 2 * max S S) = 2 * S\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "finally"], ["proof (chain)\npicking this:\n  f (u 0) (u n) \\<le> 2 * S", "show ?thesis"], ["proof (prove)\nusing this:\n  f (u 0) (u n) \\<le> 2 * S\n\ngoal (1 subgoal):\n 1. f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "unfolding S_def"], ["proof (prove)\nusing this:\n  f (u 0) (u n) \\<le> 2 * (\\<Sum>i = 0..<n. f (u i) (u (Suc i)))\n\ngoal (1 subgoal):\n 1. f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2", "by simp"], ["proof (state)\nthis:\n  f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (u 0) (u n) \\<le> (\\<Sum>i = 0..<n. f (u i) (u (Suc i))) * 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (?u 0) (?u ?n) \\<le> (\\<Sum>i = 0..<?n. f (?u i) (?u (Suc i))) * 2\n\ngoal (1 subgoal):\n 1. f x y \\<le> 2 * turn_into_distance f x y", "have \"f x y/2 \\<le> turn_into_distance f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y / 2 \\<le> turn_into_distance f x y", "unfolding turn_into_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y / 2\n    \\<le> Inf {\\<Sum>i = 0..<n. f (u i) (u (Suc i)) |u n.\n               u 0 = x \\<and> u n = y}", "by (rule cInf_greatest[OF nonempty], auto simp add: I)"], ["proof (state)\nthis:\n  f x y / 2 \\<le> turn_into_distance f x y\n\ngoal (1 subgoal):\n 1. f x y \\<le> 2 * turn_into_distance f x y", "then"], ["proof (chain)\npicking this:\n  f x y / 2 \\<le> turn_into_distance f x y", "show ?thesis"], ["proof (prove)\nusing this:\n  f x y / 2 \\<le> turn_into_distance f x y\n\ngoal (1 subgoal):\n 1. f x y \\<le> 2 * turn_into_distance f x y", "by simp"], ["proof (state)\nthis:\n  f x y \\<le> 2 * turn_into_distance f x y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*of locale Turn_into_distance*)"], ["", "section \\<open>The Gromov completion of a hyperbolic space\\<close>"], ["", "subsection \\<open>The Gromov boundary as a set\\<close>"], ["", "text \\<open>A sequence in a Gromov hyperbolic space converges to a point in the boundary if\nthe Gromov product $(u_n, u_m)_e$ tends to infinity when $m,n \\to _infty$. The point at infinity\nis defined as the equivalence class of such sequences, for the relation $u \\sim v$ iff\n$(u_n, v_n)_e \\to \\infty$ (or, equivalently, $(u_n, v_m)_e \\to \\infty$ when $m, n\\to \\infty$, or\none could also change basepoints). Hence, the Gromov boundary is naturally defined as a quotient\ntype. There is a difficulty: it can be empty in general, hence defining it as a type is not always\npossible. One could introduce a new typeclass of Gromov hyperbolic spaces for which the boundary\nis not empty (unboundedness is not enough, think of infinitely many segments $[0,n]$ all joined at\n$0$), and then only define the boundary of such spaces. However, this is tedious. Rather, we\nwork with the Gromov completion (containing the space and its boundary), this is always not empty.\nThe price to pay is that, in the definition of the completion, we have to distinguish between\nsequences converging to the boundary and sequences converging inside the space. This is more natural\nto proceed in this way as the interesting features of the boundary come from the fact that its sits\nat infinity of the initial space, so their relations (and the topology of $X \\cup \\partial X$) are\ncentral.\\<close>"], ["", "definition Gromov_converging_at_boundary::\"(nat \\<Rightarrow> ('a::Gromov_hyperbolic_space)) \\<Rightarrow> bool\"\n  where \"Gromov_converging_at_boundary u = (\\<forall>a. \\<forall>(M::real). \\<exists>N. \\<forall>n \\<ge> N. \\<forall> m \\<ge> N. Gromov_product_at a (u m) (u n) \\<ge> M)\""], ["", "lemma Gromov_converging_at_boundaryI:\n  assumes \"\\<And>M. \\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. Gromov_product_at a (u m) (u n) \\<ge> M\"\n  shows \"Gromov_converging_at_boundary u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "unfolding Gromov_converging_at_boundary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "fix b::'a and M::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "obtain N where *: \"\\<And>m n. n \\<ge> N \\<Longrightarrow> m \\<ge> N \\<Longrightarrow> Gromov_product_at a (u m) (u n) \\<ge> M + dist a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> n; N \\<le> m\\<rbrakk>\n            \\<Longrightarrow> M + dist a b\n                              \\<le> Gromov_product_at a (u m)\n                                     (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms[of \"M + dist a b\"]"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. M + dist a b \\<le> Gromov_product_at a (u m) (u n)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> n; N \\<le> m\\<rbrakk>\n            \\<Longrightarrow> M + dist a b\n                              \\<le> Gromov_product_at a (u m)\n                                     (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M + dist a b \\<le> Gromov_product_at a (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "have \"Gromov_product_at b (u m) (u n) \\<ge> M\" if \"m \\<ge> N\" \"n \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at b (u m) (u n)", "using *[OF that] Gromov_product_at_diff1[of a \"u m\" \"u n\" b]"], ["proof (prove)\nusing this:\n  M + dist a b \\<le> Gromov_product_at a (u n) (u m)\n  \\<bar>Gromov_product_at a (u m) (u n) -\n        Gromov_product_at b (u m) (u n)\\<bar>\n  \\<le> dist a b\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at b (u m) (u n)", "by (smt Gromov_product_commute)"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at b (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<And>a M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at b (u ?m) (u ?n)", "show \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. M \\<le> Gromov_product_at b (u m) (u n)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at b (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at b (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. M \\<le> Gromov_product_at b (u m) (u n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gromov_converging_at_boundary_imp_unbounded:\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"(\\<lambda>n. dist a (u n)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (dist a (u x))) \\<longlonglongrightarrow> \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (dist a (u x))) \\<longlonglongrightarrow> \\<infinity>", "have \"\\<exists>N. \\<forall>n \\<ge> N. dist a (u n) \\<ge> M\" for M::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. M \\<le> dist a (u n)", "using assms"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. M \\<le> dist a (u n)", "unfolding Gromov_converging_at_boundary_def Gromov_product_e_x_x[symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>a M.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. M \\<le> Gromov_product_at a (u n) (u n)", "by meson"], ["proof (state)\nthis:\n  \\<exists>N. \\<forall>n\\<ge>N. ?M \\<le> dist a (u n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (dist a (u x))) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  \\<exists>N. \\<forall>n\\<ge>N. ?M \\<le> dist a (u n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. ?M \\<le> dist a (u n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (dist a (u x))) \\<longlonglongrightarrow> \\<infinity>", "unfolding tendsto_PInfty eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. ?M \\<le> dist a (u n)\n\ngoal (1 subgoal):\n 1. \\<forall>r. \\<exists>N. \\<forall>n\\<ge>N. ereal r < ereal (dist a (u n))", "by (meson dual_order.strict_trans1 gt_ex less_ereal.simps(1))"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (dist a (u x))) \\<longlonglongrightarrow> \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gromov_converging_at_boundary_imp_not_constant:\n  \"\\<not>(Gromov_converging_at_boundary (\\<lambda>n. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Gromov_converging_at_boundary (\\<lambda>n. x)", "using Gromov_converging_at_boundary_imp_unbounded[of \"(\\<lambda>n. x)\" \"x\"] Lim_bounded_PInfty"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary (\\<lambda>n. x) \\<Longrightarrow>\n  (\\<lambda>xa. ereal (dist x x)) \\<longlonglongrightarrow> \\<infinity>\n  \\<lbrakk>?f \\<longlonglongrightarrow> ?l;\n   \\<And>n. ?f n \\<le> ereal ?B\\<rbrakk>\n  \\<Longrightarrow> ?l \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_converging_at_boundary (\\<lambda>n. x)", "by auto"], ["", "lemma Gromov_converging_at_boundary_imp_not_constant':\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"\\<not>(\\<forall>m n. u m = u n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m n. u m = u n)", "using Gromov_converging_at_boundary_imp_not_constant"], ["proof (prove)\nusing this:\n  \\<not> Gromov_converging_at_boundary (\\<lambda>n. ?x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m n. u m = u n)", "by (metis (no_types) Gromov_converging_at_boundary_def assms order_refl)"], ["", "text \\<open>We introduce a partial equivalence relation, defined over the sequences that converge to\ninfinity, and the constant sequences. Quotienting the space of admissible sequences by this\nequivalence relation will give rise to the Gromov completion.\\<close>"], ["", "definition Gromov_completion_rel::\"(nat \\<Rightarrow> 'a::Gromov_hyperbolic_space) \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> bool\"\n  where \"Gromov_completion_rel u v =\n            (((Gromov_converging_at_boundary u \\<and> Gromov_converging_at_boundary v \\<and> (\\<forall>a. (\\<lambda>n. Gromov_product_at a (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>)))\n            \\<or> (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m))\""], ["", "text \\<open>We need some basic lemmas to work separately with sequences tending to the boundary\nand with constant sequences, as follows.\\<close>"], ["", "lemma Gromov_completion_rel_const [simp]:\n  \"Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. x)", "unfolding Gromov_completion_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary (\\<lambda>n. x) \\<and>\n    Gromov_converging_at_boundary (\\<lambda>n. x) \\<and>\n    (\\<forall>a.\n        (\\<lambda>xa. ereal (Gromov_product_at a x x))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. x = x \\<and> x = x \\<and> x = x)", "by auto"], ["", "lemma Gromov_completion_rel_to_const:\n  assumes \"Gromov_completion_rel u (\\<lambda>n. x)\"\n  shows \"u n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u n = x", "using assms"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u (\\<lambda>n. x)\n\ngoal (1 subgoal):\n 1. u n = x", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u \\<and>\n  Gromov_converging_at_boundary (\\<lambda>n. x) \\<and>\n  (\\<forall>a.\n      (\\<lambda>xa. ereal (Gromov_product_at a (u xa) x))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. u n = x \\<and> u n = u m \\<and> x = x)\n\ngoal (1 subgoal):\n 1. u n = x", "using Gromov_converging_at_boundary_imp_not_constant[of x]"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u \\<and>\n  Gromov_converging_at_boundary (\\<lambda>n. x) \\<and>\n  (\\<forall>a.\n      (\\<lambda>xa. ereal (Gromov_product_at a (u xa) x))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. u n = x \\<and> u n = u m \\<and> x = x)\n  \\<not> Gromov_converging_at_boundary (\\<lambda>n. x)\n\ngoal (1 subgoal):\n 1. u n = x", "by auto"], ["", "lemma Gromov_completion_rel_to_const':\n  assumes \"Gromov_completion_rel (\\<lambda>n. x) u\"\n  shows \"u n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u n = x", "using assms"], ["proof (prove)\nusing this:\n  Gromov_completion_rel (\\<lambda>n. x) u\n\ngoal (1 subgoal):\n 1. u n = x", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary (\\<lambda>n. x) \\<and>\n  Gromov_converging_at_boundary u \\<and>\n  (\\<forall>a.\n      (\\<lambda>xa. ereal (Gromov_product_at a x (u xa)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. x = u m \\<and> x = x \\<and> u n = u m)\n\ngoal (1 subgoal):\n 1. u n = x", "using Gromov_converging_at_boundary_imp_not_constant[of x]"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary (\\<lambda>n. x) \\<and>\n  Gromov_converging_at_boundary u \\<and>\n  (\\<forall>a.\n      (\\<lambda>xa. ereal (Gromov_product_at a x (u xa)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. x = u m \\<and> x = x \\<and> u n = u m)\n  \\<not> Gromov_converging_at_boundary (\\<lambda>n. x)\n\ngoal (1 subgoal):\n 1. u n = x", "by auto"], ["", "lemma Gromov_product_tendsto_PInf_a_b:\n  assumes \"(\\<lambda>n. Gromov_product_at a (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\"\n  shows \"(\\<lambda>n. Gromov_product_at b (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at b (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "proof (rule tendsto_sandwich[of \"\\<lambda>n. ereal(Gromov_product_at a (u n) (v n)) + (- dist a b)\" _ _ \"\\<lambda>n. \\<infinity>\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b)\n       \\<le> ereal (Gromov_product_at b (u n) (v n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at b (u n) (v n)) \\<le> \\<infinity>\n 3. (\\<lambda>n.\n        ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "have \"ereal(Gromov_product_at b (u n) (v n)) \\<ge> ereal(Gromov_product_at a (u n) (v n)) + (- dist a b)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b)\n    \\<le> ereal (Gromov_product_at b (u n) (v n))", "using Gromov_product_at_diff1[of a \"u n\" \"v n\" b]"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at a (u n) (v n) -\n        Gromov_product_at b (u n) (v n)\\<bar>\n  \\<le> dist a b\n\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b)\n    \\<le> ereal (Gromov_product_at b (u n) (v n))", "by auto"], ["proof (state)\nthis:\n  ereal (Gromov_product_at a (u ?n) (v ?n)) + ereal (- dist a b)\n  \\<le> ereal (Gromov_product_at b (u ?n) (v ?n))\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b)\n       \\<le> ereal (Gromov_product_at b (u n) (v n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at b (u n) (v n)) \\<le> \\<infinity>\n 3. (\\<lambda>n.\n        ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  ereal (Gromov_product_at a (u ?n) (v ?n)) + ereal (- dist a b)\n  \\<le> ereal (Gromov_product_at b (u ?n) (v ?n))", "show \"\\<forall>\\<^sub>F n in sequentially. ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b) \\<le> ereal (Gromov_product_at b (u n) (v n))\""], ["proof (prove)\nusing this:\n  ereal (Gromov_product_at a (u ?n) (v ?n)) + ereal (- dist a b)\n  \\<le> ereal (Gromov_product_at b (u ?n) (v ?n))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b)\n       \\<le> ereal (Gromov_product_at b (u n) (v n))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b)\n     \\<le> ereal (Gromov_product_at b (u n) (v n))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at b (u n) (v n)) \\<le> \\<infinity>\n 2. (\\<lambda>n.\n        ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "have \"(\\<lambda>n. ereal(Gromov_product_at a (u n) (v n)) + (- dist a b)) \\<longlonglongrightarrow> \\<infinity> + (- dist a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n    \\<longlonglongrightarrow> \\<infinity> + ereal (- dist a b)", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ereal (- dist a b) \\<noteq> - \\<infinity>\n 2. \\<infinity> \\<noteq> - \\<infinity>\n 3. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (3 subgoals):\n 1. ereal (- dist a b) \\<noteq> - \\<infinity>\n 2. \\<infinity> \\<noteq> - \\<infinity>\n 3. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n  \\<longlonglongrightarrow> \\<infinity> + ereal (- dist a b)\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at b (u n) (v n)) \\<le> \\<infinity>\n 2. (\\<lambda>n.\n        ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n  \\<longlonglongrightarrow> \\<infinity> + ereal (- dist a b)", "show \"(\\<lambda>n. ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n  \\<longlonglongrightarrow> \\<infinity> + ereal (- dist a b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n    \\<longlonglongrightarrow> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. ereal (Gromov_product_at a (u n) (v n)) + ereal (- dist a b))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at b (u n) (v n)) \\<le> \\<infinity>\n 2. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "qed (auto)"], ["", "lemma Gromov_converging_at_boundary_rel:\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"Gromov_completion_rel u u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u", "unfolding Gromov_completion_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary u \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (u x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = u m \\<and> u n = u m \\<and> u n = u m)", "using Gromov_converging_at_boundary_imp_unbounded[OF assms] assms"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (dist ?a (u x))) \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary u\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary u \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (u x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = u m \\<and> u n = u m \\<and> u n = u m)", "by auto"], ["", "text \\<open>We can now prove that we indeed have an equivalence relation.\\<close>"], ["", "lemma part_equivp_Gromov_completion_rel:\n  \"part_equivp Gromov_completion_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_equivp Gromov_completion_rel", "proof (rule part_equivpI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>x. Gromov_completion_rel x x\n 2. symp Gromov_completion_rel\n 3. transp Gromov_completion_rel", "show \"\\<exists>x::(nat \\<Rightarrow> 'a). Gromov_completion_rel x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. Gromov_completion_rel x x", "apply (rule exI[of _ \"\\<lambda>n. (SOME a::'a. True)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. SOME a. True)\n     (\\<lambda>n. SOME a. True)", "unfolding Gromov_completion_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary (\\<lambda>n. SOME a. True) \\<and>\n    Gromov_converging_at_boundary (\\<lambda>n. SOME a. True) \\<and>\n    (\\<forall>a.\n        (\\<lambda>x.\n            ereal (Gromov_product_at a (SOME a. True) (SOME a. True)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m.\n        (SOME a. True) = (SOME a. True) \\<and>\n        (SOME a. True) = (SOME a. True) \\<and>\n        (SOME a. True) = (SOME a. True))", "by (auto simp add: convergent_const)"], ["proof (state)\nthis:\n  \\<exists>x. Gromov_completion_rel x x\n\ngoal (2 subgoals):\n 1. symp Gromov_completion_rel\n 2. transp Gromov_completion_rel", "show \"symp Gromov_completion_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symp Gromov_completion_rel", "unfolding symp_def Gromov_completion_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       Gromov_converging_at_boundary x \\<and>\n       Gromov_converging_at_boundary y \\<and>\n       (\\<forall>a.\n           (\\<lambda>xa. ereal (Gromov_product_at a (x xa) (y xa)))\n           \\<longlonglongrightarrow> \\<infinity>) \\<or>\n       (\\<forall>n m.\n           x n = y m \\<and> x n = x m \\<and> y n = y m) \\<longrightarrow>\n       Gromov_converging_at_boundary y \\<and>\n       Gromov_converging_at_boundary x \\<and>\n       (\\<forall>a.\n           (\\<lambda>xa. ereal (Gromov_product_at a (y xa) (x xa)))\n           \\<longlonglongrightarrow> \\<infinity>) \\<or>\n       (\\<forall>n m. y n = x m \\<and> y n = y m \\<and> x n = x m)", "by (auto simp add: Gromov_product_commute) metis+"], ["proof (state)\nthis:\n  symp Gromov_completion_rel\n\ngoal (1 subgoal):\n 1. transp Gromov_completion_rel", "show \"transp (Gromov_completion_rel::(nat \\<Rightarrow> 'a) \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> bool)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp Gromov_completion_rel", "unfolding transp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y z.\n       Gromov_completion_rel x y \\<longrightarrow>\n       Gromov_completion_rel y z \\<longrightarrow> Gromov_completion_rel x z", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>Gromov_completion_rel x y;\n        Gromov_completion_rel y z\\<rbrakk>\n       \\<Longrightarrow> Gromov_completion_rel x z", "fix u v w::\"nat\\<Rightarrow>'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>Gromov_completion_rel x y;\n        Gromov_completion_rel y z\\<rbrakk>\n       \\<Longrightarrow> Gromov_completion_rel x z", "assume UV: \"Gromov_completion_rel u v\"\n       and VW: \"Gromov_completion_rel v w\""], ["proof (state)\nthis:\n  Gromov_completion_rel u v\n  Gromov_completion_rel v w\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>Gromov_completion_rel x y;\n        Gromov_completion_rel y z\\<rbrakk>\n       \\<Longrightarrow> Gromov_completion_rel x z", "show \"Gromov_completion_rel u w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u w", "proof (cases \"\\<forall>n m. v n = v m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>n m. v n = v m \\<Longrightarrow> Gromov_completion_rel u w\n 2. \\<not> (\\<forall>n m. v n = v m) \\<Longrightarrow>\n    Gromov_completion_rel u w", "case True"], ["proof (state)\nthis:\n  \\<forall>n m. v n = v m\n\ngoal (2 subgoals):\n 1. \\<forall>n m. v n = v m \\<Longrightarrow> Gromov_completion_rel u w\n 2. \\<not> (\\<forall>n m. v n = v m) \\<Longrightarrow>\n    Gromov_completion_rel u w", "define a where \"a = v 0\""], ["proof (state)\nthis:\n  a = v 0\n\ngoal (2 subgoals):\n 1. \\<forall>n m. v n = v m \\<Longrightarrow> Gromov_completion_rel u w\n 2. \\<not> (\\<forall>n m. v n = v m) \\<Longrightarrow>\n    Gromov_completion_rel u w", "have *: \"v = (\\<lambda>n. a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = (\\<lambda>n. a)", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = (\\<lambda>n. v 0)", "using True"], ["proof (prove)\nusing this:\n  \\<forall>n m. v n = v m\n\ngoal (1 subgoal):\n 1. v = (\\<lambda>n. v 0)", "by auto"], ["proof (state)\nthis:\n  v = (\\<lambda>n. a)\n\ngoal (2 subgoals):\n 1. \\<forall>n m. v n = v m \\<Longrightarrow> Gromov_completion_rel u w\n 2. \\<not> (\\<forall>n m. v n = v m) \\<Longrightarrow>\n    Gromov_completion_rel u w", "then"], ["proof (chain)\npicking this:\n  v = (\\<lambda>n. a)", "have \"u n = v 0\" \"w n = v 0\" for n"], ["proof (prove)\nusing this:\n  v = (\\<lambda>n. a)\n\ngoal (1 subgoal):\n 1. u n = v 0 &&& w n = v 0", "using Gromov_completion_rel_to_const' Gromov_completion_rel_to_const UV VW"], ["proof (prove)\nusing this:\n  v = (\\<lambda>n. a)\n  Gromov_completion_rel (\\<lambda>n. ?x) ?u \\<Longrightarrow> ?u ?n = ?x\n  Gromov_completion_rel ?u (\\<lambda>n. ?x) \\<Longrightarrow> ?u ?n = ?x\n  Gromov_completion_rel u v\n  Gromov_completion_rel v w\n\ngoal (1 subgoal):\n 1. u n = v 0 &&& w n = v 0", "unfolding *"], ["proof (prove)\nusing this:\n  (\\<lambda>n. a) = (\\<lambda>n. a)\n  Gromov_completion_rel (\\<lambda>n. ?x) ?u \\<Longrightarrow> ?u ?n = ?x\n  Gromov_completion_rel ?u (\\<lambda>n. ?x) \\<Longrightarrow> ?u ?n = ?x\n  Gromov_completion_rel u (\\<lambda>n. a)\n  Gromov_completion_rel (\\<lambda>n. a) w\n\ngoal (1 subgoal):\n 1. u n = a &&& w n = a", "by auto force"], ["proof (state)\nthis:\n  u ?n1 = v 0\n  w ?n1 = v 0\n\ngoal (2 subgoals):\n 1. \\<forall>n m. v n = v m \\<Longrightarrow> Gromov_completion_rel u w\n 2. \\<not> (\\<forall>n m. v n = v m) \\<Longrightarrow>\n    Gromov_completion_rel u w", "then"], ["proof (chain)\npicking this:\n  u ?n1 = v 0\n  w ?n1 = v 0", "show ?thesis"], ["proof (prove)\nusing this:\n  u ?n1 = v 0\n  w ?n1 = v 0\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u w", "using UV VW"], ["proof (prove)\nusing this:\n  u ?n1 = v 0\n  w ?n1 = v 0\n  Gromov_completion_rel u v\n  Gromov_completion_rel v w\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u w", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  u ?n1 = v 0\n  w ?n1 = v 0\n  Gromov_converging_at_boundary u \\<and>\n  Gromov_converging_at_boundary v \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)\n  Gromov_converging_at_boundary v \\<and>\n  Gromov_converging_at_boundary w \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (v x) (w x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. v n = w m \\<and> v n = v m \\<and> w n = w m)\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary w \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (w x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = w m \\<and> u n = u m \\<and> w n = w m)", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u w\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n m. v n = v m) \\<Longrightarrow>\n    Gromov_completion_rel u w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n m. v n = v m) \\<Longrightarrow>\n    Gromov_completion_rel u w", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>n m. v n = v m)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n m. v n = v m) \\<Longrightarrow>\n    Gromov_completion_rel u w", "have \"(\\<lambda>n. Gromov_product_at a (u n) (w n)) \\<longlonglongrightarrow> \\<infinity>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at a (u x) (w x)))\n    \\<longlonglongrightarrow> \\<infinity>", "proof (rule tendsto_sandwich[of \"\\<lambda>n. min (ereal (Gromov_product_at a (u n) (v n))) (ereal (Gromov_product_at a (v n) (w n))) + (- deltaG(TYPE('a)))\" _ _ \"\\<lambda>n. \\<infinity>\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       min (ereal (Gromov_product_at a (u n) (v n)))\n        (ereal (Gromov_product_at a (v n) (w n))) +\n       ereal (- deltaG TYPE('a))\n       \\<le> ereal (Gromov_product_at a (u n) (w n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (w n)) \\<le> \\<infinity>\n 3. (\\<lambda>n.\n        min (ereal (Gromov_product_at a (u n) (v n)))\n         (ereal (Gromov_product_at a (v n) (w n))) +\n        ereal (- deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "have \"min (Gromov_product_at a (u n) (v n)) (Gromov_product_at a (v n) (w n)) - deltaG(TYPE('a)) \\<le> Gromov_product_at a (u n) (w n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at a (u n) (v n))\n     (Gromov_product_at a (v n) (w n)) -\n    deltaG TYPE('a)\n    \\<le> Gromov_product_at a (u n) (w n)", "by (rule hyperb_ineq)"], ["proof (state)\nthis:\n  min (Gromov_product_at a (u ?n1) (v ?n1))\n   (Gromov_product_at a (v ?n1) (w ?n1)) -\n  deltaG TYPE('a)\n  \\<le> Gromov_product_at a (u ?n1) (w ?n1)\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       min (ereal (Gromov_product_at a (u n) (v n)))\n        (ereal (Gromov_product_at a (v n) (w n))) +\n       ereal (- deltaG TYPE('a))\n       \\<le> ereal (Gromov_product_at a (u n) (w n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (w n)) \\<le> \\<infinity>\n 3. (\\<lambda>n.\n        min (ereal (Gromov_product_at a (u n) (v n)))\n         (ereal (Gromov_product_at a (v n) (w n))) +\n        ereal (- deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  min (Gromov_product_at a (u ?n1) (v ?n1))\n   (Gromov_product_at a (v ?n1) (w ?n1)) -\n  deltaG TYPE('a)\n  \\<le> Gromov_product_at a (u ?n1) (w ?n1)", "have \"min (ereal (Gromov_product_at a (u n) (v n))) (ereal (Gromov_product_at a (v n) (w n))) + ereal (- deltaG TYPE('a)) \\<le> ereal (Gromov_product_at a (u n) (w n))\" for n"], ["proof (prove)\nusing this:\n  min (Gromov_product_at a (u ?n1) (v ?n1))\n   (Gromov_product_at a (v ?n1) (w ?n1)) -\n  deltaG TYPE('a)\n  \\<le> Gromov_product_at a (u ?n1) (w ?n1)\n\ngoal (1 subgoal):\n 1. min (ereal (Gromov_product_at a (u n) (v n)))\n     (ereal (Gromov_product_at a (v n) (w n))) +\n    ereal (- deltaG TYPE('a))\n    \\<le> ereal (Gromov_product_at a (u n) (w n))", "by (auto simp del: ereal_min simp add: ereal_min[symmetric])"], ["proof (state)\nthis:\n  min (ereal (Gromov_product_at a (u ?n1) (v ?n1)))\n   (ereal (Gromov_product_at a (v ?n1) (w ?n1))) +\n  ereal (- deltaG TYPE('a))\n  \\<le> ereal (Gromov_product_at a (u ?n1) (w ?n1))\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       min (ereal (Gromov_product_at a (u n) (v n)))\n        (ereal (Gromov_product_at a (v n) (w n))) +\n       ereal (- deltaG TYPE('a))\n       \\<le> ereal (Gromov_product_at a (u n) (w n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (w n)) \\<le> \\<infinity>\n 3. (\\<lambda>n.\n        min (ereal (Gromov_product_at a (u n) (v n)))\n         (ereal (Gromov_product_at a (v n) (w n))) +\n        ereal (- deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  min (ereal (Gromov_product_at a (u ?n1) (v ?n1)))\n   (ereal (Gromov_product_at a (v ?n1) (w ?n1))) +\n  ereal (- deltaG TYPE('a))\n  \\<le> ereal (Gromov_product_at a (u ?n1) (w ?n1))", "show \"\\<forall>\\<^sub>F n in sequentially. min (ereal (Gromov_product_at a (u n) (v n))) (ereal (Gromov_product_at a (v n) (w n)))\n                    + ereal (- deltaG TYPE('a)) \\<le> ereal (Gromov_product_at a (u n) (w n))\""], ["proof (prove)\nusing this:\n  min (ereal (Gromov_product_at a (u ?n1) (v ?n1)))\n   (ereal (Gromov_product_at a (v ?n1) (w ?n1))) +\n  ereal (- deltaG TYPE('a))\n  \\<le> ereal (Gromov_product_at a (u ?n1) (w ?n1))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       min (ereal (Gromov_product_at a (u n) (v n)))\n        (ereal (Gromov_product_at a (v n) (w n))) +\n       ereal (- deltaG TYPE('a))\n       \\<le> ereal (Gromov_product_at a (u n) (w n))", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  min (ereal (Gromov_product_at a (u ?n1) (v ?n1)))\n   (ereal (Gromov_product_at a (v ?n1) (w ?n1))) +\n  ereal (- deltaG TYPE('a))\n  \\<le> ereal (Gromov_product_at a (u ?n1) (w ?n1))\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          min (ereal (Gromov_product_at a (u n) (v n)))\n           (ereal (Gromov_product_at a (v n) (w n))) +\n          ereal (- deltaG TYPE('a))\n          \\<le> ereal (Gromov_product_at a (u n) (w n))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     min (ereal (Gromov_product_at a (u n) (v n)))\n      (ereal (Gromov_product_at a (v n) (w n))) +\n     ereal (- deltaG TYPE('a))\n     \\<le> ereal (Gromov_product_at a (u n) (w n))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (w n)) \\<le> \\<infinity>\n 2. (\\<lambda>n.\n        min (ereal (Gromov_product_at a (u n) (v n)))\n         (ereal (Gromov_product_at a (v n) (w n))) +\n        ereal (- deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "have \"(\\<lambda>n. min (ereal (Gromov_product_at a (u n) (v n))) (ereal (Gromov_product_at a (v n) (w n))) + (- deltaG(TYPE('a)))) \\<longlonglongrightarrow> min \\<infinity> \\<infinity> + (- deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        min (ereal (Gromov_product_at a (u n) (v n)))\n         (ereal (Gromov_product_at a (v n) (w n))) +\n        ereal (- deltaG TYPE('a)))\n    \\<longlonglongrightarrow> min \\<infinity> \\<infinity> +\n                              ereal (- deltaG TYPE('a))", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. ereal (- deltaG TYPE('a)) \\<noteq> - \\<infinity>\n 2. min \\<infinity> \\<infinity> \\<noteq> - \\<infinity>\n 3. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>x. ereal (Gromov_product_at a (v x) (w x)))\n    \\<longlonglongrightarrow> \\<infinity>", "using UV VW False"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u v\n  Gromov_completion_rel v w\n  \\<not> (\\<forall>n m. v n = v m)\n\ngoal (4 subgoals):\n 1. ereal (- deltaG TYPE('a)) \\<noteq> - \\<infinity>\n 2. min \\<infinity> \\<infinity> \\<noteq> - \\<infinity>\n 3. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>x. ereal (Gromov_product_at a (v x) (w x)))\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u \\<and>\n  Gromov_converging_at_boundary v \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)\n  Gromov_converging_at_boundary v \\<and>\n  Gromov_converging_at_boundary w \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (v x) (w x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. v n = w m \\<and> v n = v m \\<and> w n = w m)\n  \\<not> (\\<forall>n m. v n = v m)\n\ngoal (4 subgoals):\n 1. ereal (- deltaG TYPE('a)) \\<noteq> - \\<infinity>\n 2. min \\<infinity> \\<infinity> \\<noteq> - \\<infinity>\n 3. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>x. ereal (Gromov_product_at a (v x) (w x)))\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      min (ereal (Gromov_product_at a (u n) (v n)))\n       (ereal (Gromov_product_at a (v n) (w n))) +\n      ereal (- deltaG TYPE('a)))\n  \\<longlonglongrightarrow> min \\<infinity> \\<infinity> +\n                            ereal (- deltaG TYPE('a))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (w n)) \\<le> \\<infinity>\n 2. (\\<lambda>n.\n        min (ereal (Gromov_product_at a (u n) (v n)))\n         (ereal (Gromov_product_at a (v n) (w n))) +\n        ereal (- deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n.\n      min (ereal (Gromov_product_at a (u n) (v n)))\n       (ereal (Gromov_product_at a (v n) (w n))) +\n      ereal (- deltaG TYPE('a)))\n  \\<longlonglongrightarrow> min \\<infinity> \\<infinity> +\n                            ereal (- deltaG TYPE('a))", "show \"(\\<lambda>n. min (ereal (Gromov_product_at a (u n) (v n))) (ereal (Gromov_product_at a (v n) (w n))) + (- deltaG(TYPE('a)))) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      min (ereal (Gromov_product_at a (u n) (v n)))\n       (ereal (Gromov_product_at a (v n) (w n))) +\n      ereal (- deltaG TYPE('a)))\n  \\<longlonglongrightarrow> min \\<infinity> \\<infinity> +\n                            ereal (- deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        min (ereal (Gromov_product_at a (u n) (v n)))\n         (ereal (Gromov_product_at a (v n) (w n))) +\n        ereal (- deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      min (ereal (Gromov_product_at a (u n) (v n)))\n       (ereal (Gromov_product_at a (v n) (w n))) +\n      ereal (- deltaG TYPE('a)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (w n)) \\<le> \\<infinity>\n 2. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "qed (auto)"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at ?a1 (u x) (w x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n m. v n = v m) \\<Longrightarrow>\n    Gromov_completion_rel u w", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a1 (u x) (w x)))\n  \\<longlonglongrightarrow> \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a1 (u x) (w x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u w", "using False UV VW"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a1 (u x) (w x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  \\<not> (\\<forall>n m. v n = v m)\n  Gromov_completion_rel u v\n  Gromov_completion_rel v w\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u w", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a1 (u x) (w x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  \\<not> (\\<forall>n m. v n = v m)\n  Gromov_converging_at_boundary u \\<and>\n  Gromov_converging_at_boundary v \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)\n  Gromov_converging_at_boundary v \\<and>\n  Gromov_converging_at_boundary w \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (v x) (w x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. v n = w m \\<and> v n = v m \\<and> w n = w m)\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary w \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (w x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = w m \\<and> u n = u m \\<and> w n = w m)", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_completion_rel u w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  transp Gromov_completion_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can now define the Gromov completion of a Gromov hyperbolic space, considering either\nsequences converging to a point on the boundary, or sequences converging inside the space, and\nquotienting by the natural equivalence relation.\\<close>"], ["", "quotient_type (overloaded) 'a Gromov_completion =\n  \"nat \\<Rightarrow> ('a::Gromov_hyperbolic_space)\"\n  / partial: \"Gromov_completion_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. part_equivp Gromov_completion_rel", "by (rule part_equivp_Gromov_completion_rel)"], ["", "text \\<open>The Gromov completion contains is made of a copy of the original space, and new points\nforming the Gromov boundary.\\<close>"], ["", "definition to_Gromov_completion::\"('a::Gromov_hyperbolic_space) \\<Rightarrow> 'a Gromov_completion\"\n  where \"to_Gromov_completion x = abs_Gromov_completion (\\<lambda>n. x)\""], ["", "definition from_Gromov_completion::\"('a::Gromov_hyperbolic_space) Gromov_completion \\<Rightarrow> 'a\"\n  where \"from_Gromov_completion = inv to_Gromov_completion\""], ["", "definition Gromov_boundary::\"('a::Gromov_hyperbolic_space) Gromov_completion set\"\n  where \"Gromov_boundary = UNIV - range to_Gromov_completion\""], ["", "lemma to_Gromov_completion_inj:\n  \"inj to_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj to_Gromov_completion", "proof (rule injI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n       x = y", "fix x y::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n       x = y", "assume H: \"to_Gromov_completion x = to_Gromov_completion y\""], ["proof (state)\nthis:\n  to_Gromov_completion x = to_Gromov_completion y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n       x = y", "have \"Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. y)", "apply (subst Quotient3_rel[OF Quotient3_Gromov_completion, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. x) \\<and>\n    Gromov_completion_rel (\\<lambda>n. y) (\\<lambda>n. y) \\<and>\n    abs_Gromov_completion (\\<lambda>n. x) =\n    abs_Gromov_completion (\\<lambda>n. y)", "using H"], ["proof (prove)\nusing this:\n  to_Gromov_completion x = to_Gromov_completion y\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. x) \\<and>\n    Gromov_completion_rel (\\<lambda>n. y) (\\<lambda>n. y) \\<and>\n    abs_Gromov_completion (\\<lambda>n. x) =\n    abs_Gromov_completion (\\<lambda>n. y)", "unfolding to_Gromov_completion_def"], ["proof (prove)\nusing this:\n  abs_Gromov_completion (\\<lambda>n. x) =\n  abs_Gromov_completion (\\<lambda>n. y)\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. x) \\<and>\n    Gromov_completion_rel (\\<lambda>n. y) (\\<lambda>n. y) \\<and>\n    abs_Gromov_completion (\\<lambda>n. x) =\n    abs_Gromov_completion (\\<lambda>n. y)", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n       x = y", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. y)", "show \"x = y\""], ["proof (prove)\nusing this:\n  Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. y)\n\ngoal (1 subgoal):\n 1. x = y", "using Gromov_completion_rel_to_const"], ["proof (prove)\nusing this:\n  Gromov_completion_rel (\\<lambda>n. x) (\\<lambda>n. y)\n  Gromov_completion_rel ?u (\\<lambda>n. ?x) \\<Longrightarrow> ?u ?n = ?x\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma from_to_Gromov_completion [simp]:\n  \"from_Gromov_completion (to_Gromov_completion x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. from_Gromov_completion (to_Gromov_completion x) = x", "unfolding from_Gromov_completion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv to_Gromov_completion (to_Gromov_completion x) = x", "by (simp add: to_Gromov_completion_inj)"], ["", "lemma to_from_Gromov_completion:\n  assumes \"x \\<notin> Gromov_boundary\"\n  shows \"to_Gromov_completion (from_Gromov_completion x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_Gromov_completion (from_Gromov_completion x) = x", "using assms to_Gromov_completion_inj"], ["proof (prove)\nusing this:\n  x \\<notin> Gromov_boundary\n  inj to_Gromov_completion\n\ngoal (1 subgoal):\n 1. to_Gromov_completion (from_Gromov_completion x) = x", "unfolding Gromov_boundary_def from_Gromov_completion_def"], ["proof (prove)\nusing this:\n  x \\<notin> UNIV - range to_Gromov_completion\n  inj to_Gromov_completion\n\ngoal (1 subgoal):\n 1. to_Gromov_completion (inv to_Gromov_completion x) = x", "by (simp add: f_inv_into_f)"], ["", "lemma not_in_Gromov_boundary:\n  assumes \"x \\<notin> Gromov_boundary\"\n  shows \"\\<exists>a. x = to_Gromov_completion a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. x = to_Gromov_completion a", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> Gromov_boundary\n\ngoal (1 subgoal):\n 1. \\<exists>a. x = to_Gromov_completion a", "unfolding Gromov_boundary_def"], ["proof (prove)\nusing this:\n  x \\<notin> UNIV - range to_Gromov_completion\n\ngoal (1 subgoal):\n 1. \\<exists>a. x = to_Gromov_completion a", "by auto"], ["", "lemma not_in_Gromov_boundary' [simp]:\n  \"to_Gromov_completion x \\<notin> Gromov_boundary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_Gromov_completion x \\<notin> Gromov_boundary", "unfolding Gromov_boundary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_Gromov_completion x \\<notin> UNIV - range to_Gromov_completion", "by auto"], ["", "lemma abs_Gromov_completion_in_Gromov_boundary [simp]:\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"abs_Gromov_completion u \\<in> Gromov_boundary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion u \\<in> Gromov_boundary", "using Gromov_completion_rel_to_const Gromov_converging_at_boundary_imp_not_constant'\n  Gromov_converging_at_boundary_rel[OF assms]\n  Quotient3_rel[OF Quotient3_Gromov_completion] assms not_in_Gromov_boundary to_Gromov_completion_def"], ["proof (prove)\nusing this:\n  Gromov_completion_rel ?u (\\<lambda>n. ?x) \\<Longrightarrow> ?u ?n = ?x\n  Gromov_converging_at_boundary ?u \\<Longrightarrow>\n  \\<not> (\\<forall>m n. ?u m = ?u n)\n  Gromov_completion_rel u u\n  (Gromov_completion_rel ?r ?r \\<and>\n   Gromov_completion_rel ?s ?s \\<and>\n   abs_Gromov_completion ?r = abs_Gromov_completion ?s) =\n  Gromov_completion_rel ?r ?s\n  Gromov_converging_at_boundary u\n  ?x \\<notin> Gromov_boundary \\<Longrightarrow>\n  \\<exists>a. ?x = to_Gromov_completion a\n  to_Gromov_completion ?x = abs_Gromov_completion (\\<lambda>n. ?x)\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion u \\<in> Gromov_boundary", "by fastforce"], ["", "lemma rep_Gromov_completion_to_Gromov_completion [simp]:\n  \"rep_Gromov_completion (to_Gromov_completion y) = (\\<lambda>n. y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rep_Gromov_completion (to_Gromov_completion y) = (\\<lambda>n. y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rep_Gromov_completion (to_Gromov_completion y) = (\\<lambda>n. y)", "have \"Gromov_completion_rel (\\<lambda>n. y) (rep_Gromov_completion (abs_Gromov_completion (\\<lambda>n. y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. y)\n     (rep_Gromov_completion (abs_Gromov_completion (\\<lambda>n. y)))", "by (metis Gromov_completion_rel_const Quotient3_Gromov_completion rep_abs_rsp)"], ["proof (state)\nthis:\n  Gromov_completion_rel (\\<lambda>n. y)\n   (rep_Gromov_completion (abs_Gromov_completion (\\<lambda>n. y)))\n\ngoal (1 subgoal):\n 1. rep_Gromov_completion (to_Gromov_completion y) = (\\<lambda>n. y)", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel (\\<lambda>n. y)\n   (rep_Gromov_completion (abs_Gromov_completion (\\<lambda>n. y)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_completion_rel (\\<lambda>n. y)\n   (rep_Gromov_completion (abs_Gromov_completion (\\<lambda>n. y)))\n\ngoal (1 subgoal):\n 1. rep_Gromov_completion (to_Gromov_completion y) = (\\<lambda>n. y)", "unfolding to_Gromov_completion_def"], ["proof (prove)\nusing this:\n  Gromov_completion_rel (\\<lambda>n. y)\n   (rep_Gromov_completion (abs_Gromov_completion (\\<lambda>n. y)))\n\ngoal (1 subgoal):\n 1. rep_Gromov_completion (abs_Gromov_completion (\\<lambda>n. y)) =\n    (\\<lambda>n. y)", "using Gromov_completion_rel_to_const'"], ["proof (prove)\nusing this:\n  Gromov_completion_rel (\\<lambda>n. y)\n   (rep_Gromov_completion (abs_Gromov_completion (\\<lambda>n. y)))\n  Gromov_completion_rel (\\<lambda>n. ?x) ?u \\<Longrightarrow> ?u ?n = ?x\n\ngoal (1 subgoal):\n 1. rep_Gromov_completion (abs_Gromov_completion (\\<lambda>n. y)) =\n    (\\<lambda>n. y)", "by blast"], ["proof (state)\nthis:\n  rep_Gromov_completion (to_Gromov_completion y) = (\\<lambda>n. y)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>To distinguish the case of points inside the space or in the boundary, we introduce the\nfollowing case distinction.\\<close>"], ["", "lemma Gromov_completion_cases [case_names to_Gromov_completion boundary, cases type: Gromov_completion]:\n  \"(\\<And>x. z = to_Gromov_completion x \\<Longrightarrow> P) \\<Longrightarrow> (z \\<in> Gromov_boundary \\<Longrightarrow> P) \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. z = to_Gromov_completion x \\<Longrightarrow> P;\n     z \\<in> Gromov_boundary \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (cases \"z \\<in> Gromov_boundary\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. z = to_Gromov_completion x \\<Longrightarrow> P;\n     z \\<in> Gromov_boundary \\<Longrightarrow> P;\n     z \\<in> Gromov_boundary\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>\\<And>x. z = to_Gromov_completion x \\<Longrightarrow> P;\n     z \\<in> Gromov_boundary \\<Longrightarrow> P;\n     z \\<notin> Gromov_boundary\\<rbrakk>\n    \\<Longrightarrow> P", "using not_in_Gromov_boundary"], ["proof (prove)\nusing this:\n  ?x \\<notin> Gromov_boundary \\<Longrightarrow>\n  \\<exists>a. ?x = to_Gromov_completion a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. z = to_Gromov_completion x \\<Longrightarrow> P;\n     z \\<in> Gromov_boundary \\<Longrightarrow> P;\n     z \\<in> Gromov_boundary\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>\\<And>x. z = to_Gromov_completion x \\<Longrightarrow> P;\n     z \\<in> Gromov_boundary \\<Longrightarrow> P;\n     z \\<notin> Gromov_boundary\\<rbrakk>\n    \\<Longrightarrow> P", "by auto"], ["", "subsection \\<open>Extending the original distance and the original Gromov product to the completion\\<close>"], ["", "text \\<open>In this subsection, we extend the Gromov product to the boundary, by taking limits along\nsequences tending to the point in the boundary. This does not converge, but it does up to $\\delta$,\nso for definiteness we use a $\\liminf$ over all sequences tending to the boundary point -- one\ninterest of this definition is that the extended Gromov product still satisfies the hyperbolicity\ninequality. One difficulty is that this extended Gromov product can take infinite values (it does\nso exactly on the pair $(x,x)$ where $x$ is in the boundary), so we should define this product\nin extended nonnegative reals.\n\nWe also extend the original distance, by $+\\infty$ on the boundary. This is not a really interesting\nfunction, but it will be instrumental below. Again, this extended Gromov distance (not to be mistaken\nfor the genuine distance we will construct later on on the completion) takes values in extended\nnonnegative reals.\n\nSince the extended Gromov product and the extension of the original distance both take values in\n$[0,+\\infty]$, it may seem natural to define them in ennreal. This is the choice that was made in\na previous implementation, but it turns out that one keeps computing with these numbers, writing\ndown inequalities and subtractions. ennreal is ill suited for this kind of computations, as it only\nworks well with additions. Hence, the implementation was switched to ereal, where proofs are indeed\nmuch smoother.\n\nTo define the extended Gromov product, one takes a limit of the Gromov product along any\nsequence, as it does not depend up to $\\delta$ on the chosen sequence. However, if one wants to\nkeep the exact inequality that defines hyperbolicity, but at all points, then using an infimum\nis the best choice.\\<close>"], ["", "definition extended_Gromov_product_at::\"('a::Gromov_hyperbolic_space) \\<Rightarrow> 'a Gromov_completion \\<Rightarrow> 'a Gromov_completion \\<Rightarrow> ereal\"\n  where \"extended_Gromov_product_at e x y = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (v n))) |u v. abs_Gromov_completion u = x \\<and> abs_Gromov_completion v = y \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\""], ["", "definition extended_Gromov_distance::\"('a::Gromov_hyperbolic_space) Gromov_completion \\<Rightarrow> 'a Gromov_completion \\<Rightarrow> ereal\"\n  where \"extended_Gromov_distance x y =\n              (if x \\<in> Gromov_boundary \\<or> y \\<in> Gromov_boundary then \\<infinity>\n              else ereal (dist (inv to_Gromov_completion x) (inv to_Gromov_completion y)))\""], ["", "text \\<open>The extended distance and the extended Gromov product are invariant under exchange\nof the points, readily from the definition.\\<close>"], ["", "lemma extended_Gromov_distance_commute:\n  \"extended_Gromov_distance x y = extended_Gromov_distance y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y = extended_Gromov_distance y x", "unfolding extended_Gromov_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<in> Gromov_boundary \\<or> y \\<in> Gromov_boundary\n     then \\<infinity>\n     else ereal\n           (dist (inv to_Gromov_completion x)\n             (inv to_Gromov_completion y))) =\n    (if y \\<in> Gromov_boundary \\<or> x \\<in> Gromov_boundary\n     then \\<infinity>\n     else ereal\n           (dist (inv to_Gromov_completion y) (inv to_Gromov_completion x)))", "by (simp add: dist_commute)"], ["", "lemma extended_Gromov_product_nonneg [mono_intros, simp]:\n  \"0 \\<le> extended_Gromov_product_at e x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> extended_Gromov_product_at e x y", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Inf {liminf\n                  (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |\n                 u v.\n                 abs_Gromov_completion u = x \\<and>\n                 abs_Gromov_completion v = y \\<and>\n                 Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "by (rule Inf_greatest, auto intro: Liminf_bounded always_eventually)"], ["", "lemma extended_Gromov_distance_nonneg [mono_intros, simp]:\n  \"0 \\<le> extended_Gromov_distance x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> extended_Gromov_distance x y", "unfolding extended_Gromov_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (if x \\<in> Gromov_boundary \\<or> y \\<in> Gromov_boundary\n             then \\<infinity>\n             else ereal\n                   (dist (inv to_Gromov_completion x)\n                     (inv to_Gromov_completion y)))", "by auto"], ["", "lemma extended_Gromov_product_at_commute:\n  \"extended_Gromov_product_at e x y = extended_Gromov_product_at e y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = extended_Gromov_product_at e y x", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion v = y \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = y \\<and>\n         abs_Gromov_completion v = x \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "proof (rule arg_cong[of _ _ Inf])"], ["proof (state)\ngoal (1 subgoal):\n 1. {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n     abs_Gromov_completion u = x \\<and>\n     abs_Gromov_completion v = y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n     abs_Gromov_completion u = y \\<and>\n     abs_Gromov_completion v = x \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "have \"{liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n          abs_Gromov_completion u = x \\<and> abs_Gromov_completion v = y \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n        {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (u n))) |u v.\n          abs_Gromov_completion v = y \\<and> abs_Gromov_completion u = x \\<and> Gromov_completion_rel v v \\<and> Gromov_completion_rel u u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n     abs_Gromov_completion u = x \\<and>\n     abs_Gromov_completion v = y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (u n))) |u v.\n     abs_Gromov_completion v = y \\<and>\n     abs_Gromov_completion u = x \\<and>\n     Gromov_completion_rel v v \\<and> Gromov_completion_rel u u}", "by (auto simp add: Gromov_product_commute)"], ["proof (state)\nthis:\n  {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n   abs_Gromov_completion u = x \\<and>\n   abs_Gromov_completion v = y \\<and>\n   Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n  {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (u n))) |u v.\n   abs_Gromov_completion v = y \\<and>\n   abs_Gromov_completion u = x \\<and>\n   Gromov_completion_rel v v \\<and> Gromov_completion_rel u u}\n\ngoal (1 subgoal):\n 1. {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n     abs_Gromov_completion u = x \\<and>\n     abs_Gromov_completion v = y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n     abs_Gromov_completion u = y \\<and>\n     abs_Gromov_completion v = x \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "then"], ["proof (chain)\npicking this:\n  {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n   abs_Gromov_completion u = x \\<and>\n   abs_Gromov_completion v = y \\<and>\n   Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n  {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (u n))) |u v.\n   abs_Gromov_completion v = y \\<and>\n   abs_Gromov_completion u = x \\<and>\n   Gromov_completion_rel v v \\<and> Gromov_completion_rel u u}", "show \"{liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n      abs_Gromov_completion u = x \\<and> abs_Gromov_completion v = y \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n      {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n      abs_Gromov_completion u = y \\<and> abs_Gromov_completion v = x \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\""], ["proof (prove)\nusing this:\n  {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n   abs_Gromov_completion u = x \\<and>\n   abs_Gromov_completion v = y \\<and>\n   Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n  {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (u n))) |u v.\n   abs_Gromov_completion v = y \\<and>\n   abs_Gromov_completion u = x \\<and>\n   Gromov_completion_rel v v \\<and> Gromov_completion_rel u u}\n\ngoal (1 subgoal):\n 1. {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n     abs_Gromov_completion u = x \\<and>\n     abs_Gromov_completion v = y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n     abs_Gromov_completion u = y \\<and>\n     abs_Gromov_completion v = x \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "by auto"], ["proof (state)\nthis:\n  {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n   abs_Gromov_completion u = x \\<and>\n   abs_Gromov_completion v = y \\<and>\n   Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n  {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n   abs_Gromov_completion u = y \\<and>\n   abs_Gromov_completion v = x \\<and>\n   Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Inside the space, the extended distance and the extended Gromov product coincide with the\noriginal ones.\\<close>"], ["", "lemma extended_Gromov_distance_inside [simp]:\n  \"extended_Gromov_distance (to_Gromov_completion x) (to_Gromov_completion y) = dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (dist x y)", "unfolding extended_Gromov_distance_def Gromov_boundary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if to_Gromov_completion x \\<in> UNIV - range to_Gromov_completion \\<or>\n        to_Gromov_completion y \\<in> UNIV - range to_Gromov_completion\n     then \\<infinity>\n     else ereal\n           (dist (inv to_Gromov_completion (to_Gromov_completion x))\n             (inv to_Gromov_completion (to_Gromov_completion y)))) =\n    ereal (dist x y)", "by (auto simp add: to_Gromov_completion_inj)"], ["", "lemma extended_Gromov_product_inside [simp] :\n  \"extended_Gromov_product_at e (to_Gromov_completion x) (to_Gromov_completion y) = Gromov_product_at e x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (Gromov_product_at e x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (Gromov_product_at e x y)", "have A: \"u = (\\<lambda>n. z)\" if H: \"abs_Gromov_completion u = abs_Gromov_completion (\\<lambda>n. z)\" \"Gromov_completion_rel u u\" for u and z::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. u = (\\<lambda>n. z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u = (\\<lambda>n. z)", "have \"Gromov_completion_rel u (\\<lambda>n. z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u (\\<lambda>n. z)", "apply (subst Quotient3_rel[OF Quotient3_Gromov_completion, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u \\<and>\n    Gromov_completion_rel (\\<lambda>n. z) (\\<lambda>n. z) \\<and>\n    abs_Gromov_completion u = abs_Gromov_completion (\\<lambda>n. z)", "using H uniformity_dist_class_def"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = abs_Gromov_completion (\\<lambda>n. z)\n  Gromov_completion_rel u u\n  OFCLASS(?'a, uniformity_dist_class) \\<equiv>\n  (OFCLASS(?'a, dist_class) &&&\n   OFCLASS(?'a, uniformity_class) &&& class.uniformity_dist dist uniformity)\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u \\<and>\n    Gromov_completion_rel (\\<lambda>n. z) (\\<lambda>n. z) \\<and>\n    abs_Gromov_completion u = abs_Gromov_completion (\\<lambda>n. z)", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u (\\<lambda>n. z)\n\ngoal (1 subgoal):\n 1. u = (\\<lambda>n. z)", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel u (\\<lambda>n. z)", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u (\\<lambda>n. z)\n\ngoal (1 subgoal):\n 1. u = (\\<lambda>n. z)", "using Gromov_completion_rel_to_const"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u (\\<lambda>n. z)\n  Gromov_completion_rel ?u (\\<lambda>n. ?x) \\<Longrightarrow> ?u ?n = ?x\n\ngoal (1 subgoal):\n 1. u = (\\<lambda>n. z)", "by auto"], ["proof (state)\nthis:\n  u = (\\<lambda>n. z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>abs_Gromov_completion ?u =\n           abs_Gromov_completion (\\<lambda>n. ?z);\n   Gromov_completion_rel ?u ?u\\<rbrakk>\n  \\<Longrightarrow> ?u = (\\<lambda>n. ?z)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (Gromov_product_at e x y)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>abs_Gromov_completion ?u =\n           abs_Gromov_completion (\\<lambda>n. ?z);\n   Gromov_completion_rel ?u ?u\\<rbrakk>\n  \\<Longrightarrow> ?u = (\\<lambda>n. ?z)", "have *: \"{u. abs_Gromov_completion u = to_Gromov_completion z \\<and> Gromov_completion_rel u u} = {(\\<lambda>n. z)}\" for z::'a"], ["proof (prove)\nusing this:\n  \\<lbrakk>abs_Gromov_completion ?u =\n           abs_Gromov_completion (\\<lambda>n. ?z);\n   Gromov_completion_rel ?u ?u\\<rbrakk>\n  \\<Longrightarrow> ?u = (\\<lambda>n. ?z)\n\ngoal (1 subgoal):\n 1. {u. abs_Gromov_completion u = to_Gromov_completion z \\<and>\n        Gromov_completion_rel u u} =\n    {\\<lambda>n. z}", "unfolding to_Gromov_completion_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>abs_Gromov_completion ?u =\n           abs_Gromov_completion (\\<lambda>n. ?z);\n   Gromov_completion_rel ?u ?u\\<rbrakk>\n  \\<Longrightarrow> ?u = (\\<lambda>n. ?z)\n\ngoal (1 subgoal):\n 1. {u. abs_Gromov_completion u =\n        abs_Gromov_completion (\\<lambda>n. z) \\<and>\n        Gromov_completion_rel u u} =\n    {\\<lambda>n. z}", "by auto"], ["proof (state)\nthis:\n  {u. abs_Gromov_completion u = to_Gromov_completion ?z \\<and>\n      Gromov_completion_rel u u} =\n  {\\<lambda>n. ?z}\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (Gromov_product_at e x y)", "have **: \"{F u v |u v. abs_Gromov_completion u = to_Gromov_completion x \\<and> abs_Gromov_completion v = to_Gromov_completion y \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n      = {F (\\<lambda>n. x) (\\<lambda>n. y)}\" for F::\"(nat \\<Rightarrow> 'a) \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> ereal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {F u v |u v.\n     abs_Gromov_completion u = to_Gromov_completion x \\<and>\n     abs_Gromov_completion v = to_Gromov_completion y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {F (\\<lambda>n. x) (\\<lambda>n. y)}", "using *[of x] *[of y]"], ["proof (prove)\nusing this:\n  {u. abs_Gromov_completion u = to_Gromov_completion x \\<and>\n      Gromov_completion_rel u u} =\n  {\\<lambda>n. x}\n  {u. abs_Gromov_completion u = to_Gromov_completion y \\<and>\n      Gromov_completion_rel u u} =\n  {\\<lambda>n. y}\n\ngoal (1 subgoal):\n 1. {F u v |u v.\n     abs_Gromov_completion u = to_Gromov_completion x \\<and>\n     abs_Gromov_completion v = to_Gromov_completion y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {F (\\<lambda>n. x) (\\<lambda>n. y)}", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\nusing this:\n  {u. abs_Gromov_completion u = to_Gromov_completion x \\<and>\n      Gromov_completion_rel u u} =\n  {\\<lambda>n. x}\n  {u. abs_Gromov_completion u = to_Gromov_completion y \\<and>\n      Gromov_completion_rel u u} =\n  {\\<lambda>n. y}\n\ngoal (1 subgoal):\n 1. {F u v |u v.\n     abs_Gromov_completion u = to_Gromov_completion x \\<and>\n     abs_Gromov_completion v = to_Gromov_completion y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {F (\\<lambda>n. x) (\\<lambda>n. y)}", "by (auto, smt mem_Collect_eq singletonD)"], ["proof (state)\nthis:\n  {?F u v |u v.\n   abs_Gromov_completion u = to_Gromov_completion x \\<and>\n   abs_Gromov_completion v = to_Gromov_completion y \\<and>\n   Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n  {?F (\\<lambda>n. x) (\\<lambda>n. y)}\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (Gromov_product_at e x y)", "have \"extended_Gromov_product_at e (to_Gromov_completion x) (to_Gromov_completion y) = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e ((\\<lambda>n. x) n) ((\\<lambda>n. y) n)))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x y))}", "unfolding extended_Gromov_product_at_def **"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x y))} =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x y))}", "by simp"], ["proof (state)\nthis:\n  extended_Gromov_product_at e (to_Gromov_completion x)\n   (to_Gromov_completion y) =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x y))}\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (Gromov_product_at e x y)", "also"], ["proof (state)\nthis:\n  extended_Gromov_product_at e (to_Gromov_completion x)\n   (to_Gromov_completion y) =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x y))}\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (Gromov_product_at e x y)", "have \"... = ereal(Gromov_product_at e x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x y))} =\n    ereal (Gromov_product_at e x y)", "by (auto simp add: Liminf_const)"], ["proof (state)\nthis:\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x y))} =\n  ereal (Gromov_product_at e x y)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (Gromov_product_at e x y)", "finally"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at e (to_Gromov_completion x)\n   (to_Gromov_completion y) =\n  ereal (Gromov_product_at e x y)", "show \"extended_Gromov_product_at e (to_Gromov_completion x) (to_Gromov_completion y) = Gromov_product_at e x y\""], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e (to_Gromov_completion x)\n   (to_Gromov_completion y) =\n  ereal (Gromov_product_at e x y)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x)\n     (to_Gromov_completion y) =\n    ereal (Gromov_product_at e x y)", "by simp"], ["proof (state)\nthis:\n  extended_Gromov_product_at e (to_Gromov_completion x)\n   (to_Gromov_completion y) =\n  ereal (Gromov_product_at e x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A point in the boundary is at infinite extended distance of everyone, including itself:\nthe extended distance is obtained by taking the supremum along all sequences tending to this point,\nso even for one single point one can take two sequences tending to it at different speeds, which\nresults in an infinite extended distance.\\<close>"], ["", "lemma extended_Gromov_distance_PInf_boundary [simp]:\n  assumes \"x \\<in> Gromov_boundary\"\n  shows \"extended_Gromov_distance x y = \\<infinity>\" \"extended_Gromov_distance y x = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y = \\<infinity> &&&\n    extended_Gromov_distance y x = \\<infinity>", "unfolding extended_Gromov_distance_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x \\<in> Gromov_boundary \\<or> y \\<in> Gromov_boundary\n     then \\<infinity>\n     else ereal\n           (dist (inv to_Gromov_completion x)\n             (inv to_Gromov_completion y))) =\n    \\<infinity> &&&\n    (if y \\<in> Gromov_boundary \\<or> x \\<in> Gromov_boundary\n     then \\<infinity>\n     else ereal\n           (dist (inv to_Gromov_completion y)\n             (inv to_Gromov_completion x))) =\n    \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. (if x \\<in> Gromov_boundary \\<or> y \\<in> Gromov_boundary\n     then \\<infinity>\n     else ereal\n           (dist (inv to_Gromov_completion x)\n             (inv to_Gromov_completion y))) =\n    \\<infinity> &&&\n    (if y \\<in> Gromov_boundary \\<or> x \\<in> Gromov_boundary\n     then \\<infinity>\n     else ereal\n           (dist (inv to_Gromov_completion y)\n             (inv to_Gromov_completion x))) =\n    \\<infinity>", "by auto"], ["", "text \\<open>By construction, the extended distance still satisfies the triangle inequality.\\<close>"], ["", "lemma extended_Gromov_distance_triangle [mono_intros]:\n  \"extended_Gromov_distance x z \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "proof (cases \"x \\<in> Gromov_boundary \\<or> y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> Gromov_boundary \\<or>\n    y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\n 2. \\<not> (x \\<in> Gromov_boundary \\<or>\n            y \\<in> Gromov_boundary \\<or>\n            z \\<in> Gromov_boundary) \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "case True"], ["proof (state)\nthis:\n  x \\<in> Gromov_boundary \\<or>\n  y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. x \\<in> Gromov_boundary \\<or>\n    y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\n 2. \\<not> (x \\<in> Gromov_boundary \\<or>\n            y \\<in> Gromov_boundary \\<or>\n            z \\<in> Gromov_boundary) \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "then"], ["proof (chain)\npicking this:\n  x \\<in> Gromov_boundary \\<or>\n  y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary", "have *: \"extended_Gromov_distance x y + extended_Gromov_distance y z = \\<infinity>\""], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary \\<or>\n  y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y + extended_Gromov_distance y z =\n    \\<infinity>", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_distance x y + extended_Gromov_distance y z = \\<infinity>\n\ngoal (2 subgoals):\n 1. x \\<in> Gromov_boundary \\<or>\n    y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\n 2. \\<not> (x \\<in> Gromov_boundary \\<or>\n            y \\<in> Gromov_boundary \\<or>\n            z \\<in> Gromov_boundary) \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "by (simp add: *)"], ["proof (state)\nthis:\n  extended_Gromov_distance x z\n  \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> Gromov_boundary \\<or>\n            y \\<in> Gromov_boundary \\<or>\n            z \\<in> Gromov_boundary) \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> Gromov_boundary \\<or>\n            y \\<in> Gromov_boundary \\<or>\n            z \\<in> Gromov_boundary) \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "case False"], ["proof (state)\nthis:\n  \\<not> (x \\<in> Gromov_boundary \\<or>\n          y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> Gromov_boundary \\<or>\n            y \\<in> Gromov_boundary \\<or>\n            z \\<in> Gromov_boundary) \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "then"], ["proof (chain)\npicking this:\n  \\<not> (x \\<in> Gromov_boundary \\<or>\n          y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary)", "obtain a b c where abc: \"x = to_Gromov_completion a\" \"y = to_Gromov_completion b\" \"z = to_Gromov_completion c\""], ["proof (prove)\nusing this:\n  \\<not> (x \\<in> Gromov_boundary \\<or>\n          y \\<in> Gromov_boundary \\<or> z \\<in> Gromov_boundary)\n\ngoal (1 subgoal):\n 1. (\\<And>a b c.\n        \\<lbrakk>x = to_Gromov_completion a; y = to_Gromov_completion b;\n         z = to_Gromov_completion c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Gromov_boundary_def"], ["proof (prove)\nusing this:\n  \\<not> (x \\<in> UNIV - range to_Gromov_completion \\<or>\n          y \\<in> UNIV - range to_Gromov_completion \\<or>\n          z \\<in> UNIV - range to_Gromov_completion)\n\ngoal (1 subgoal):\n 1. (\\<And>a b c.\n        \\<lbrakk>x = to_Gromov_completion a; y = to_Gromov_completion b;\n         z = to_Gromov_completion c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = to_Gromov_completion a\n  y = to_Gromov_completion b\n  z = to_Gromov_completion c\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> Gromov_boundary \\<or>\n            y \\<in> Gromov_boundary \\<or>\n            z \\<in> Gromov_boundary) \\<Longrightarrow>\n    extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "unfolding abc"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion a)\n     (to_Gromov_completion c)\n    \\<le> extended_Gromov_distance (to_Gromov_completion a)\n           (to_Gromov_completion b) +\n          extended_Gromov_distance (to_Gromov_completion b)\n           (to_Gromov_completion c)", "using dist_triangle[of a c b] ennreal_leI"], ["proof (prove)\nusing this:\n  dist a c \\<le> dist a b + dist b c\n  ?x \\<le> ?y \\<Longrightarrow> ennreal ?x \\<le> ennreal ?y\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion a)\n     (to_Gromov_completion c)\n    \\<le> extended_Gromov_distance (to_Gromov_completion a)\n           (to_Gromov_completion b) +\n          extended_Gromov_distance (to_Gromov_completion b)\n           (to_Gromov_completion c)", "by fastforce"], ["proof (state)\nthis:\n  extended_Gromov_distance x z\n  \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The extended Gromov product can be bounded by the extended distance, just like inside\nthe space.\\<close>"], ["", "lemma extended_Gromov_product_le_dist [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_distance (to_Gromov_completion e) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "case boundary"], ["proof (state)\nthis:\n  x \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "then"], ["proof (chain)\npicking this:\n  x \\<in> Gromov_boundary", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "by simp"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_distance (to_Gromov_completion e) x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "case (to_Gromov_completion a)"], ["proof (state)\nthis:\n  x = to_Gromov_completion a\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "define v where \"v = rep_Gromov_completion y\""], ["proof (state)\nthis:\n  v = rep_Gromov_completion y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "have *: \"abs_Gromov_completion (\\<lambda>n. a) = x \\<and> abs_Gromov_completion v = y \\<and> Gromov_completion_rel (\\<lambda>n. a) (\\<lambda>n. a) \\<and> Gromov_completion_rel v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion (\\<lambda>n. a) = x \\<and>\n    abs_Gromov_completion v = y \\<and>\n    Gromov_completion_rel (\\<lambda>n. a) (\\<lambda>n. a) \\<and>\n    Gromov_completion_rel v v", "unfolding v_def to_Gromov_completion to_Gromov_completion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion (\\<lambda>n. a) =\n    abs_Gromov_completion (\\<lambda>n. a) \\<and>\n    abs_Gromov_completion (rep_Gromov_completion y) = y \\<and>\n    Gromov_completion_rel (\\<lambda>n. a) (\\<lambda>n. a) \\<and>\n    Gromov_completion_rel (rep_Gromov_completion y)\n     (rep_Gromov_completion y)", "by (auto simp add: Quotient3_rep_reflp[OF Quotient3_Gromov_completion] Quotient3_abs_rep[OF Quotient3_Gromov_completion])"], ["proof (state)\nthis:\n  abs_Gromov_completion (\\<lambda>n. a) = x \\<and>\n  abs_Gromov_completion v = y \\<and>\n  Gromov_completion_rel (\\<lambda>n. a) (\\<lambda>n. a) \\<and>\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "have \"extended_Gromov_product_at e x y \\<le> liminf (\\<lambda>n. ereal(Gromov_product_at e a (v n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion v = y \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))", "apply (rule Inf_lower)"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))\n    \\<in> {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n           v. abs_Gromov_completion u = x \\<and>\n              abs_Gromov_completion v = y \\<and>\n              Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "using *"], ["proof (prove)\nusing this:\n  abs_Gromov_completion (\\<lambda>n. a) = x \\<and>\n  abs_Gromov_completion v = y \\<and>\n  Gromov_completion_rel (\\<lambda>n. a) (\\<lambda>n. a) \\<and>\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))\n    \\<in> {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n           v. abs_Gromov_completion u = x \\<and>\n              abs_Gromov_completion v = y \\<and>\n              Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "by force"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "also"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "have \"... \\<le> liminf (\\<lambda>n. ereal(dist e a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))\n    \\<le> liminf (\\<lambda>n. ereal (dist e a))", "using Gromov_product_le_dist(1)[of e a]"], ["proof (prove)\nusing this:\n  Gromov_product_at e a ?y \\<le> dist e a\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))\n    \\<le> liminf (\\<lambda>n. ereal (dist e a))", "by (auto intro!: Liminf_mono)"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))\n  \\<le> liminf (\\<lambda>n. ereal (dist e a))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "also"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e a (v n)))\n  \\<le> liminf (\\<lambda>n. ereal (dist e a))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "have \"... = ereal(dist e a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (dist e a)) = ereal (dist e a)", "by (simp add: Liminf_const)"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (dist e a)) = ereal (dist e a)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "also"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (dist e a)) = ereal (dist e a)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "have \"... = extended_Gromov_distance (to_Gromov_completion e) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist e a) = extended_Gromov_distance (to_Gromov_completion e) x", "unfolding to_Gromov_completion"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist e a) =\n    extended_Gromov_distance (to_Gromov_completion e)\n     (to_Gromov_completion a)", "by auto"], ["proof (state)\nthis:\n  ereal (dist e a) = extended_Gromov_distance (to_Gromov_completion e) x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y\n       \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "finally"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "show ?thesis"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_distance (to_Gromov_completion e) x\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_distance (to_Gromov_completion e) x", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_distance (to_Gromov_completion e) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_Gromov_product_le_dist' [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_distance (to_Gromov_completion e) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_distance (to_Gromov_completion e) y", "using extended_Gromov_product_le_dist[of e y x]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e y x\n  \\<le> extended_Gromov_distance (to_Gromov_completion e) y\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_distance (to_Gromov_completion e) y", "by (simp add: extended_Gromov_product_at_commute)"], ["", "text \\<open>The Gromov product inside the space varies by at most the distance when one varies one of\nthe points. We will need the same statement for the extended Gromov product. The proof is done\nusing this inequality inside the space, and passing to the limit.\\<close>"], ["", "lemma extended_Gromov_product_at_diff3 [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "proof (cases \"(extended_Gromov_distance y z = \\<infinity>) \\<or> (extended_Gromov_product_at e x z = \\<infinity>)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. extended_Gromov_distance y z = \\<infinity> \\<or>\n    extended_Gromov_product_at e x z = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\n 2. \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n            extended_Gromov_product_at e x z =\n            \\<infinity>) \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "case False"], ["proof (state)\nthis:\n  \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n          extended_Gromov_product_at e x z = \\<infinity>)\n\ngoal (2 subgoals):\n 1. extended_Gromov_distance y z = \\<infinity> \\<or>\n    extended_Gromov_product_at e x z = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\n 2. \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n            extended_Gromov_product_at e x z =\n            \\<infinity>) \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "then"], ["proof (chain)\npicking this:\n  \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n          extended_Gromov_product_at e x z = \\<infinity>)", "have \"y \\<notin> Gromov_boundary\" \"z \\<notin> Gromov_boundary\""], ["proof (prove)\nusing this:\n  \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n          extended_Gromov_product_at e x z = \\<infinity>)\n\ngoal (1 subgoal):\n 1. y \\<notin> Gromov_boundary &&& z \\<notin> Gromov_boundary", "using extended_Gromov_distance_PInf_boundary"], ["proof (prove)\nusing this:\n  \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n          extended_Gromov_product_at e x z = \\<infinity>)\n  ?x \\<in> Gromov_boundary \\<Longrightarrow>\n  extended_Gromov_distance ?x ?y = \\<infinity>\n  ?x \\<in> Gromov_boundary \\<Longrightarrow>\n  extended_Gromov_distance ?y ?x = \\<infinity>\n\ngoal (1 subgoal):\n 1. y \\<notin> Gromov_boundary &&& z \\<notin> Gromov_boundary", "by auto"], ["proof (state)\nthis:\n  y \\<notin> Gromov_boundary\n  z \\<notin> Gromov_boundary\n\ngoal (2 subgoals):\n 1. extended_Gromov_distance y z = \\<infinity> \\<or>\n    extended_Gromov_product_at e x z = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\n 2. \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n            extended_Gromov_product_at e x z =\n            \\<infinity>) \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "then"], ["proof (chain)\npicking this:\n  y \\<notin> Gromov_boundary\n  z \\<notin> Gromov_boundary", "obtain b c where b: \"y = to_Gromov_completion b\" and c: \"z = to_Gromov_completion c\""], ["proof (prove)\nusing this:\n  y \\<notin> Gromov_boundary\n  z \\<notin> Gromov_boundary\n\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>y = to_Gromov_completion b;\n         z = to_Gromov_completion c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Gromov_boundary_def"], ["proof (prove)\nusing this:\n  y \\<notin> UNIV - range to_Gromov_completion\n  z \\<notin> UNIV - range to_Gromov_completion\n\ngoal (1 subgoal):\n 1. (\\<And>b c.\n        \\<lbrakk>y = to_Gromov_completion b;\n         z = to_Gromov_completion c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y = to_Gromov_completion b\n  z = to_Gromov_completion c\n\ngoal (2 subgoals):\n 1. extended_Gromov_distance y z = \\<infinity> \\<or>\n    extended_Gromov_product_at e x z = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\n 2. \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n            extended_Gromov_product_at e x z =\n            \\<infinity>) \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "have \"extended_Gromov_distance y z = ereal(dist b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance y z = ereal (dist b c)", "unfolding b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion b)\n     (to_Gromov_completion c) =\n    ereal (dist b c)", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_distance y z = ereal (dist b c)\n\ngoal (2 subgoals):\n 1. extended_Gromov_distance y z = \\<infinity> \\<or>\n    extended_Gromov_product_at e x z = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\n 2. \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n            extended_Gromov_product_at e x z =\n            \\<infinity>) \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "have \"extended_Gromov_product_at e x y \\<le> (extended_Gromov_product_at e x z + extended_Gromov_distance y z) + h\" if \"h>0\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "have \"\\<exists>t\\<in>{liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (w n))) |u w. abs_Gromov_completion u = x\n                  \\<and> abs_Gromov_completion w = z \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel w w}.\n          t < extended_Gromov_product_at e x z + h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{liminf\n                     (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) |\n                    u w.\n                    abs_Gromov_completion u = x \\<and>\n                    abs_Gromov_completion w = z \\<and>\n                    Gromov_completion_rel u u \\<and>\n                    Gromov_completion_rel w w}.\n       t < extended_Gromov_product_at e x z + h", "apply (subst Inf_less_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) |u w.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion w = z \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel w w}\n    < extended_Gromov_product_at e x z + h", "using False \\<open>h > 0\\<close> extended_Gromov_product_nonneg[of e x z]"], ["proof (prove)\nusing this:\n  \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n          extended_Gromov_product_at e x z = \\<infinity>)\n  0 < h\n  0 \\<le> extended_Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) |u w.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion w = z \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel w w}\n    < extended_Gromov_product_at e x z + h", "unfolding extended_Gromov_product_at_def[symmetric]"], ["proof (prove)\nusing this:\n  \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n          extended_Gromov_product_at e x z = \\<infinity>)\n  0 < h\n  0 \\<le> extended_Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x z < extended_Gromov_product_at e x z + h", "by (metis add.right_neutral ereal_add_left_cancel_less order_refl)"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{liminf\n                   (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) |\n                  u w.\n                  abs_Gromov_completion u = x \\<and>\n                  abs_Gromov_completion w = z \\<and>\n                  Gromov_completion_rel u u \\<and>\n                  Gromov_completion_rel w w}.\n     t < extended_Gromov_product_at e x z + h\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "then"], ["proof (chain)\npicking this:\n  \\<exists>t\\<in>{liminf\n                   (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) |\n                  u w.\n                  abs_Gromov_completion u = x \\<and>\n                  abs_Gromov_completion w = z \\<and>\n                  Gromov_completion_rel u u \\<and>\n                  Gromov_completion_rel w w}.\n     t < extended_Gromov_product_at e x z + h", "obtain u w where H: \"abs_Gromov_completion u = x\" \"abs_Gromov_completion w = z\"\n                          \"Gromov_completion_rel u u\" \"Gromov_completion_rel w w\"\n                          \"liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (w n))) < extended_Gromov_product_at e x z + h\""], ["proof (prove)\nusing this:\n  \\<exists>t\\<in>{liminf\n                   (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) |\n                  u w.\n                  abs_Gromov_completion u = x \\<and>\n                  abs_Gromov_completion w = z \\<and>\n                  Gromov_completion_rel u u \\<and>\n                  Gromov_completion_rel w w}.\n     t < extended_Gromov_product_at e x z + h\n\ngoal (1 subgoal):\n 1. (\\<And>u w.\n        \\<lbrakk>abs_Gromov_completion u = x; abs_Gromov_completion w = z;\n         Gromov_completion_rel u u; Gromov_completion_rel w w;\n         liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n)))\n         < extended_Gromov_product_at e x z + h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  abs_Gromov_completion u = x\n  abs_Gromov_completion w = z\n  Gromov_completion_rel u u\n  Gromov_completion_rel w w\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n)))\n  < extended_Gromov_product_at e x z + h\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion u = x\n  abs_Gromov_completion w = z\n  Gromov_completion_rel u u\n  Gromov_completion_rel w w\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n)))\n  < extended_Gromov_product_at e x z + h", "have w: \"w n = c\" for n"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = x\n  abs_Gromov_completion w = z\n  Gromov_completion_rel u u\n  Gromov_completion_rel w w\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n)))\n  < extended_Gromov_product_at e x z + h\n\ngoal (1 subgoal):\n 1. w n = c", "using c Gromov_completion_rel_to_const Quotient3_Gromov_completion Quotient3_rel to_Gromov_completion_def"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = x\n  abs_Gromov_completion w = z\n  Gromov_completion_rel u u\n  Gromov_completion_rel w w\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n)))\n  < extended_Gromov_product_at e x z + h\n  z = to_Gromov_completion c\n  Gromov_completion_rel ?u (\\<lambda>n. ?x) \\<Longrightarrow> ?u ?n = ?x\n  Quotient3 Gromov_completion_rel abs_Gromov_completion\n   rep_Gromov_completion\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow>\n  (?R ?r ?r \\<and> ?R ?s ?s \\<and> ?Abs ?r = ?Abs ?s) = ?R ?r ?s\n  to_Gromov_completion ?x = abs_Gromov_completion (\\<lambda>n. ?x)\n\ngoal (1 subgoal):\n 1. w n = c", "by fastforce"], ["proof (state)\nthis:\n  w ?n = c\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "define v where v: \"v = (\\<lambda>n::nat. b)\""], ["proof (state)\nthis:\n  v = (\\<lambda>n. b)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "have \"abs_Gromov_completion v = y\" \"Gromov_completion_rel v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion v = y &&& Gromov_completion_rel v v", "unfolding v"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion (\\<lambda>n. b) = y &&&\n    Gromov_completion_rel (\\<lambda>n. b) (\\<lambda>n. b)", "by (auto simp add: b to_Gromov_completion_def)"], ["proof (state)\nthis:\n  abs_Gromov_completion v = y\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "have \"Gromov_product_at e (u n) (v n) \\<le> Gromov_product_at e (u n) (w n) + dist b c\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at e (u n) (v n)\n    \\<le> Gromov_product_at e (u n) (w n) + dist b c", "unfolding v w"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at e (u n) b \\<le> Gromov_product_at e (u n) c + dist b c", "using Gromov_product_at_diff3[of e \"u n\" b c]"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e (u n) b - Gromov_product_at e (u n) c\\<bar>\n  \\<le> dist b c\n\ngoal (1 subgoal):\n 1. Gromov_product_at e (u n) b \\<le> Gromov_product_at e (u n) c + dist b c", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at e (u ?n) (v ?n)\n  \\<le> Gromov_product_at e (u ?n) (w ?n) + dist b c\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "then"], ["proof (chain)\npicking this:\n  Gromov_product_at e (u ?n) (v ?n)\n  \\<le> Gromov_product_at e (u ?n) (w ?n) + dist b c", "have *: \"ereal(Gromov_product_at e (u n) (v n)) \\<le> ereal(Gromov_product_at e (u n) (w n)) + extended_Gromov_distance y z\" for n"], ["proof (prove)\nusing this:\n  Gromov_product_at e (u ?n) (v ?n)\n  \\<le> Gromov_product_at e (u ?n) (w ?n) + dist b c\n\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n))\n    \\<le> ereal (Gromov_product_at e (u n) (w n)) +\n          extended_Gromov_distance y z", "unfolding \\<open>extended_Gromov_distance y z = ereal(dist b c)\\<close>"], ["proof (prove)\nusing this:\n  Gromov_product_at e (u ?n) (v ?n)\n  \\<le> Gromov_product_at e (u ?n) (w ?n) + dist b c\n\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n))\n    \\<le> ereal (Gromov_product_at e (u n) (w n)) + ereal (dist b c)", "by fastforce"], ["proof (state)\nthis:\n  ereal (Gromov_product_at e (u ?n) (v ?n))\n  \\<le> ereal (Gromov_product_at e (u ?n) (w ?n)) +\n        extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "have \"extended_Gromov_product_at e x y \\<le> liminf(\\<lambda>n. ereal(Gromov_product_at e (u n) (v n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion v = y \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "by (rule Inf_lower, auto, rule exI[of _ u], rule exI[of _ v], auto, fact+)"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "also"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "have \"... \\<le> liminf(\\<lambda>n. ereal(Gromov_product_at e (u n) (w n)) + extended_Gromov_distance y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n    \\<le> liminf\n           (\\<lambda>n.\n               ereal (Gromov_product_at e (u n) (w n)) +\n               extended_Gromov_distance y z)", "apply (rule Liminf_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       ereal (Gromov_product_at e (u x) (v x))\n       \\<le> ereal (Gromov_product_at e (u x) (w x)) +\n             extended_Gromov_distance y z", "using *"], ["proof (prove)\nusing this:\n  ereal (Gromov_product_at e (u ?n) (v ?n))\n  \\<le> ereal (Gromov_product_at e (u ?n) (w ?n)) +\n        extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       ereal (Gromov_product_at e (u x) (v x))\n       \\<le> ereal (Gromov_product_at e (u x) (w x)) +\n             extended_Gromov_distance y z", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  ereal (Gromov_product_at e (u ?n) (v ?n))\n  \\<le> ereal (Gromov_product_at e (u ?n) (w ?n)) +\n        extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          ereal (Gromov_product_at e (u n) (v n))\n          \\<le> ereal (Gromov_product_at e (u n) (w n)) +\n                extended_Gromov_distance y z", "by auto"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  \\<le> liminf\n         (\\<lambda>n.\n             ereal (Gromov_product_at e (u n) (w n)) +\n             extended_Gromov_distance y z)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "also"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  \\<le> liminf\n         (\\<lambda>n.\n             ereal (Gromov_product_at e (u n) (w n)) +\n             extended_Gromov_distance y z)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "have \"... = liminf(\\<lambda>n. ereal(Gromov_product_at e (u n) (w n))) + extended_Gromov_distance y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf\n     (\\<lambda>n.\n         ereal (Gromov_product_at e (u n) (w n)) +\n         extended_Gromov_distance y z) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n    extended_Gromov_distance y z", "apply (rule Liminf_add_ereal_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sequentially \\<noteq> bot\n 2. \\<bar>extended_Gromov_distance y z\\<bar> \\<noteq> \\<infinity>", "using False"], ["proof (prove)\nusing this:\n  \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n          extended_Gromov_product_at e x z = \\<infinity>)\n\ngoal (2 subgoals):\n 1. sequentially \\<noteq> bot\n 2. \\<bar>extended_Gromov_distance y z\\<bar> \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at e (u n) (w n)) +\n       extended_Gromov_distance y z) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n  extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "also"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at e (u n) (w n)) +\n       extended_Gromov_distance y z) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n  extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "have \"... \\<le> extended_Gromov_product_at e x z + h + extended_Gromov_distance y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n    extended_Gromov_distance y z\n    \\<le> extended_Gromov_product_at e x z + h +\n          extended_Gromov_distance y z", "using less_imp_le[OF H(5)]"], ["proof (prove)\nusing this:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n)))\n  \\<le> extended_Gromov_product_at e x z + h\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n    extended_Gromov_distance y z\n    \\<le> extended_Gromov_product_at e x z + h +\n          extended_Gromov_distance y z", "by (auto intro: mono_intros)"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n  extended_Gromov_distance y z\n  \\<le> extended_Gromov_product_at e x z + h + extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "finally"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at e x z + h + extended_Gromov_distance y z", "show ?thesis"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at e x z + h + extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z +\n          h", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z + h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?h \\<Longrightarrow>\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z + ?h\n\ngoal (2 subgoals):\n 1. extended_Gromov_distance y z = \\<infinity> \\<or>\n    extended_Gromov_product_at e x z = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\n 2. \\<not> (extended_Gromov_distance y z = \\<infinity> \\<or>\n            extended_Gromov_product_at e x z =\n            \\<infinity>) \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "then"], ["proof (chain)\npicking this:\n  0 < ?h \\<Longrightarrow>\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z + ?h", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < ?h \\<Longrightarrow>\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z + ?h\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "using ereal_le_epsilon"], ["proof (prove)\nusing this:\n  0 < ?h \\<Longrightarrow>\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z + ?h\n  (\\<And>e. 0 < e \\<Longrightarrow> ?x \\<le> ?y + e) \\<Longrightarrow>\n  ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "by blast"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance y z = \\<infinity> \\<or>\n    extended_Gromov_product_at e x z = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_distance y z = \\<infinity> \\<or>\n    extended_Gromov_product_at e x z = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "case True"], ["proof (state)\nthis:\n  extended_Gromov_distance y z = \\<infinity> \\<or>\n  extended_Gromov_product_at e x z = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance y z = \\<infinity> \\<or>\n    extended_Gromov_product_at e x z = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_distance y z = \\<infinity> \\<or>\n  extended_Gromov_product_at e x z = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  extended_Gromov_distance y z = \\<infinity> \\<or>\n  extended_Gromov_product_at e x z = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at e x z + extended_Gromov_distance y z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_Gromov_product_at_diff2 [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_product_at e z y + extended_Gromov_distance x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e z y + extended_Gromov_distance x z", "using extended_Gromov_product_at_diff3[of e y x z]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e y x\n  \\<le> extended_Gromov_product_at e y z + extended_Gromov_distance x z\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at e z y + extended_Gromov_distance x z", "by (simp add: extended_Gromov_product_at_commute)"], ["", "lemma extended_Gromov_product_at_diff1 [mono_intros]:\n  \"extended_Gromov_product_at e x y \\<le> extended_Gromov_product_at f x y + dist e f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "proof (cases \"extended_Gromov_product_at f x y = \\<infinity>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. extended_Gromov_product_at f x y = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)\n 2. extended_Gromov_product_at f x y \\<noteq> \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "case False"], ["proof (state)\nthis:\n  extended_Gromov_product_at f x y \\<noteq> \\<infinity>\n\ngoal (2 subgoals):\n 1. extended_Gromov_product_at f x y = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)\n 2. extended_Gromov_product_at f x y \\<noteq> \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "have \"extended_Gromov_product_at e x y \\<le> (extended_Gromov_product_at f x y + dist e f) + h\" if \"h > 0\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "have \"\\<exists>t\\<in>{liminf (\\<lambda>n. ereal(Gromov_product_at f (u n) (v n))) |u v. abs_Gromov_completion u = x\n                \\<and> abs_Gromov_completion v = y \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}.\n          t < extended_Gromov_product_at f x y + h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{liminf\n                     (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) |\n                    u v.\n                    abs_Gromov_completion u = x \\<and>\n                    abs_Gromov_completion v = y \\<and>\n                    Gromov_completion_rel u u \\<and>\n                    Gromov_completion_rel v v}.\n       t < extended_Gromov_product_at f x y + h", "apply (subst Inf_less_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) |u v.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion v = y \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n    < extended_Gromov_product_at f x y + h", "using False \\<open>h > 0\\<close> extended_Gromov_product_nonneg[of f x y]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at f x y \\<noteq> \\<infinity>\n  0 < h\n  0 \\<le> extended_Gromov_product_at f x y\n\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) |u v.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion v = y \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n    < extended_Gromov_product_at f x y + h", "unfolding extended_Gromov_product_at_def[symmetric]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at f x y \\<noteq> \\<infinity>\n  0 < h\n  0 \\<le> extended_Gromov_product_at f x y\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at f x y < extended_Gromov_product_at f x y + h", "by (metis add.right_neutral ereal_add_left_cancel_less order_refl)"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{liminf\n                   (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) |\n                  u v.\n                  abs_Gromov_completion u = x \\<and>\n                  abs_Gromov_completion v = y \\<and>\n                  Gromov_completion_rel u u \\<and>\n                  Gromov_completion_rel v v}.\n     t < extended_Gromov_product_at f x y + h\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "then"], ["proof (chain)\npicking this:\n  \\<exists>t\\<in>{liminf\n                   (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) |\n                  u v.\n                  abs_Gromov_completion u = x \\<and>\n                  abs_Gromov_completion v = y \\<and>\n                  Gromov_completion_rel u u \\<and>\n                  Gromov_completion_rel v v}.\n     t < extended_Gromov_product_at f x y + h", "obtain u v where H: \"abs_Gromov_completion u = x\" \"abs_Gromov_completion v = y\"\n                          \"Gromov_completion_rel u u\" \"Gromov_completion_rel v v\"\n                          \"liminf (\\<lambda>n. ereal(Gromov_product_at f (u n) (v n))) < extended_Gromov_product_at f x y + h\""], ["proof (prove)\nusing this:\n  \\<exists>t\\<in>{liminf\n                   (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) |\n                  u v.\n                  abs_Gromov_completion u = x \\<and>\n                  abs_Gromov_completion v = y \\<and>\n                  Gromov_completion_rel u u \\<and>\n                  Gromov_completion_rel v v}.\n     t < extended_Gromov_product_at f x y + h\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>abs_Gromov_completion u = x; abs_Gromov_completion v = y;\n         Gromov_completion_rel u u; Gromov_completion_rel v v;\n         liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n)))\n         < extended_Gromov_product_at f x y + h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  abs_Gromov_completion u = x\n  abs_Gromov_completion v = y\n  Gromov_completion_rel u u\n  Gromov_completion_rel v v\n  liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n)))\n  < extended_Gromov_product_at f x y + h\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "have \"Gromov_product_at e (u n) (v n) \\<le> Gromov_product_at f (u n) (v n) + dist e f\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at e (u n) (v n)\n    \\<le> Gromov_product_at f (u n) (v n) + dist e f", "using Gromov_product_at_diff1[of e \"u n\" \"v n\" f]"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e (u n) (v n) -\n        Gromov_product_at f (u n) (v n)\\<bar>\n  \\<le> dist e f\n\ngoal (1 subgoal):\n 1. Gromov_product_at e (u n) (v n)\n    \\<le> Gromov_product_at f (u n) (v n) + dist e f", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at e (u ?n) (v ?n)\n  \\<le> Gromov_product_at f (u ?n) (v ?n) + dist e f\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "then"], ["proof (chain)\npicking this:\n  Gromov_product_at e (u ?n) (v ?n)\n  \\<le> Gromov_product_at f (u ?n) (v ?n) + dist e f", "have *: \"ereal(Gromov_product_at e (u n) (v n)) \\<le> ereal(Gromov_product_at f (u n) (v n)) + dist e f\" for n"], ["proof (prove)\nusing this:\n  Gromov_product_at e (u ?n) (v ?n)\n  \\<le> Gromov_product_at f (u ?n) (v ?n) + dist e f\n\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n))\n    \\<le> ereal (Gromov_product_at f (u n) (v n)) + ereal (dist e f)", "by fastforce"], ["proof (state)\nthis:\n  ereal (Gromov_product_at e (u ?n) (v ?n))\n  \\<le> ereal (Gromov_product_at f (u ?n) (v ?n)) + ereal (dist e f)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "have \"extended_Gromov_product_at e x y \\<le> liminf(\\<lambda>n. ereal(Gromov_product_at e (u n) (v n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion v = y \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "by (rule Inf_lower, auto, rule exI[of _ u], rule exI[of _ v], auto, fact+)"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "also"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "have \"... \\<le> liminf(\\<lambda>n. ereal(Gromov_product_at f (u n) (v n)) + dist e f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n    \\<le> liminf\n           (\\<lambda>n.\n               ereal (Gromov_product_at f (u n) (v n)) + ereal (dist e f))", "apply (rule Liminf_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       ereal (Gromov_product_at e (u x) (v x))\n       \\<le> ereal (Gromov_product_at f (u x) (v x)) + ereal (dist e f)", "using *"], ["proof (prove)\nusing this:\n  ereal (Gromov_product_at e (u ?n) (v ?n))\n  \\<le> ereal (Gromov_product_at f (u ?n) (v ?n)) + ereal (dist e f)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       ereal (Gromov_product_at e (u x) (v x))\n       \\<le> ereal (Gromov_product_at f (u x) (v x)) + ereal (dist e f)", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  ereal (Gromov_product_at e (u ?n) (v ?n))\n  \\<le> ereal (Gromov_product_at f (u ?n) (v ?n)) + ereal (dist e f)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          ereal (Gromov_product_at e (u n) (v n))\n          \\<le> ereal (Gromov_product_at f (u n) (v n)) + ereal (dist e f)", "by auto"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  \\<le> liminf\n         (\\<lambda>n.\n             ereal (Gromov_product_at f (u n) (v n)) + ereal (dist e f))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "also"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  \\<le> liminf\n         (\\<lambda>n.\n             ereal (Gromov_product_at f (u n) (v n)) + ereal (dist e f))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "have \"... = liminf(\\<lambda>n. ereal(Gromov_product_at f (u n) (v n))) + dist e f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf\n     (\\<lambda>n.\n         ereal (Gromov_product_at f (u n) (v n)) + ereal (dist e f)) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) +\n    ereal (dist e f)", "apply (rule Liminf_add_ereal_right)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sequentially \\<noteq> bot\n 2. \\<bar>ereal (dist e f)\\<bar> \\<noteq> \\<infinity>", "using False"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at f x y \\<noteq> \\<infinity>\n\ngoal (2 subgoals):\n 1. sequentially \\<noteq> bot\n 2. \\<bar>ereal (dist e f)\\<bar> \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at f (u n) (v n)) + ereal (dist e f)) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) +\n  ereal (dist e f)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "also"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at f (u n) (v n)) + ereal (dist e f)) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) +\n  ereal (dist e f)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "have \"... \\<le> extended_Gromov_product_at f x y + h + dist e f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) +\n    ereal (dist e f)\n    \\<le> extended_Gromov_product_at f x y + h + ereal (dist e f)", "using less_imp_le[OF H(5)]"], ["proof (prove)\nusing this:\n  liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n)))\n  \\<le> extended_Gromov_product_at f x y + h\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) +\n    ereal (dist e f)\n    \\<le> extended_Gromov_product_at f x y + h + ereal (dist e f)", "by (auto intro: mono_intros)"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at f (u n) (v n))) +\n  ereal (dist e f)\n  \\<le> extended_Gromov_product_at f x y + h + ereal (dist e f)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "finally"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at f x y + h + ereal (dist e f)", "show ?thesis"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at f x y + h + ereal (dist e f)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?h \\<Longrightarrow>\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + ?h\n\ngoal (2 subgoals):\n 1. extended_Gromov_product_at f x y = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)\n 2. extended_Gromov_product_at f x y \\<noteq> \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "then"], ["proof (chain)\npicking this:\n  0 < ?h \\<Longrightarrow>\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + ?h", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < ?h \\<Longrightarrow>\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + ?h\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "using ereal_le_epsilon"], ["proof (prove)\nusing this:\n  0 < ?h \\<Longrightarrow>\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at f x y + ereal (dist e f) + ?h\n  (\\<And>e. 0 < e \\<Longrightarrow> ?x \\<le> ?y + e) \\<Longrightarrow>\n  ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "by blast"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at f x y + ereal (dist e f)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at f x y = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at f x y = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "case True"], ["proof (state)\nthis:\n  extended_Gromov_product_at f x y = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at f x y = \\<infinity> \\<Longrightarrow>\n    extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at f x y = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at f x y = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> extended_Gromov_product_at f x y + ereal (dist e f)", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_product_at f x y + ereal (dist e f)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A point in the Gromov boundary is represented by a sequence tending to infinity and\nconverging in the Gromov boundary, essentially by definition.\\<close>"], ["", "lemma Gromov_boundary_abs_converging:\n  assumes \"x \\<in> Gromov_boundary\" \"abs_Gromov_completion u = x\" \"Gromov_completion_rel u u\"\n  shows \"Gromov_converging_at_boundary u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "have \"Gromov_converging_at_boundary u \\<or> (\\<forall>m n. u n = u m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<or> (\\<forall>m n. u n = u m)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary\n  abs_Gromov_completion u = x\n  Gromov_completion_rel u u\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<or> (\\<forall>m n. u n = u m)", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary\n  abs_Gromov_completion u = x\n  Gromov_converging_at_boundary u \\<and>\n  Gromov_converging_at_boundary u \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (u x) (u x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. u n = u m \\<and> u n = u m \\<and> u n = u m)\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<or> (\\<forall>m n. u n = u m)", "by auto"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u \\<or> (\\<forall>m n. u n = u m)\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "moreover"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u \\<or> (\\<forall>m n. u n = u m)\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "have \"\\<not>(\\<forall>m n. u n = u m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>m n. u n = u m)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>m n. u n = u m \\<Longrightarrow> False", "assume *: \"\\<forall>m n. u n = u m\""], ["proof (state)\nthis:\n  \\<forall>m n. u n = u m\n\ngoal (1 subgoal):\n 1. \\<forall>m n. u n = u m \\<Longrightarrow> False", "define z where \"z = u 0\""], ["proof (state)\nthis:\n  z = u 0\n\ngoal (1 subgoal):\n 1. \\<forall>m n. u n = u m \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  z = u 0", "have z: \"u = (\\<lambda>n. z)\""], ["proof (prove)\nusing this:\n  z = u 0\n\ngoal (1 subgoal):\n 1. u = (\\<lambda>n. z)", "using *"], ["proof (prove)\nusing this:\n  z = u 0\n  \\<forall>m n. u n = u m\n\ngoal (1 subgoal):\n 1. u = (\\<lambda>n. z)", "by auto"], ["proof (state)\nthis:\n  u = (\\<lambda>n. z)\n\ngoal (1 subgoal):\n 1. \\<forall>m n. u n = u m \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  u = (\\<lambda>n. z)", "have \"x = to_Gromov_completion z\""], ["proof (prove)\nusing this:\n  u = (\\<lambda>n. z)\n\ngoal (1 subgoal):\n 1. x = to_Gromov_completion z", "using assms"], ["proof (prove)\nusing this:\n  u = (\\<lambda>n. z)\n  x \\<in> Gromov_boundary\n  abs_Gromov_completion u = x\n  Gromov_completion_rel u u\n\ngoal (1 subgoal):\n 1. x = to_Gromov_completion z", "unfolding z to_Gromov_completion_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n. z) = (\\<lambda>n. z)\n  x \\<in> Gromov_boundary\n  abs_Gromov_completion (\\<lambda>n. z) = x\n  Gromov_completion_rel (\\<lambda>n. z) (\\<lambda>n. z)\n\ngoal (1 subgoal):\n 1. x = abs_Gromov_completion (\\<lambda>n. z)", "by auto"], ["proof (state)\nthis:\n  x = to_Gromov_completion z\n\ngoal (1 subgoal):\n 1. \\<forall>m n. u n = u m \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x = to_Gromov_completion z", "show False"], ["proof (prove)\nusing this:\n  x = to_Gromov_completion z\n\ngoal (1 subgoal):\n 1. False", "using \\<open>x \\<in> Gromov_boundary\\<close>"], ["proof (prove)\nusing this:\n  x = to_Gromov_completion z\n  x \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. False", "unfolding Gromov_boundary_def"], ["proof (prove)\nusing this:\n  x = to_Gromov_completion z\n  x \\<in> UNIV - range to_Gromov_completion\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<forall>m n. u n = u m)\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "ultimately"], ["proof (chain)\npicking this:\n  Gromov_converging_at_boundary u \\<or> (\\<forall>m n. u n = u m)\n  \\<not> (\\<forall>m n. u n = u m)", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u \\<or> (\\<forall>m n. u n = u m)\n  \\<not> (\\<forall>m n. u n = u m)\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "by auto"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gromov_boundary_rep_converging:\n  assumes \"x \\<in> Gromov_boundary\"\n  shows \"Gromov_converging_at_boundary (rep_Gromov_completion x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary (rep_Gromov_completion x)", "apply (rule Gromov_boundary_abs_converging[OF assms])"], ["proof (prove)\ngoal (2 subgoals):\n 1. abs_Gromov_completion (rep_Gromov_completion x) = x\n 2. Gromov_completion_rel (rep_Gromov_completion x)\n     (rep_Gromov_completion x)", "using Quotient3_Gromov_completion Quotient3_abs_rep Quotient3_rep_reflp"], ["proof (prove)\nusing this:\n  Quotient3 Gromov_completion_rel abs_Gromov_completion\n   rep_Gromov_completion\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow> ?Abs (?Rep ?a) = ?a\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow> ?R (?Rep ?a) (?Rep ?a)\n\ngoal (2 subgoals):\n 1. abs_Gromov_completion (rep_Gromov_completion x) = x\n 2. Gromov_completion_rel (rep_Gromov_completion x)\n     (rep_Gromov_completion x)", "by fastforce+"], ["", "text \\<open>We can characterize the points for which the Gromov product is infinite: they have to be\nthe same point, at infinity. This is essentially equivalent to the definition of the Gromov\ncompletion, but there is some boilerplate to get the proof working.\\<close>"], ["", "lemma Gromov_boundary_extended_product_PInf [simp]:\n  \"extended_Gromov_product_at e x y = \\<infinity> \\<longleftrightarrow> (x \\<in> Gromov_boundary \\<and> y = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (extended_Gromov_product_at e x y = \\<infinity>) =\n    (x \\<in> Gromov_boundary \\<and> y = x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x\n 2. x \\<in> Gromov_boundary \\<and> y = x \\<Longrightarrow>\n    extended_Gromov_product_at e x y = \\<infinity>", "fix x y::\"'a Gromov_completion\""], ["proof (state)\ngoal (2 subgoals):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x\n 2. x \\<in> Gromov_boundary \\<and> y = x \\<Longrightarrow>\n    extended_Gromov_product_at e x y = \\<infinity>", "assume \"x \\<in> Gromov_boundary \\<and> y = x\""], ["proof (state)\nthis:\n  x \\<in> Gromov_boundary \\<and> y = x\n\ngoal (2 subgoals):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x\n 2. x \\<in> Gromov_boundary \\<and> y = x \\<Longrightarrow>\n    extended_Gromov_product_at e x y = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  x \\<in> Gromov_boundary \\<and> y = x", "have H: \"y = x\" \"x \\<in> Gromov_boundary\""], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary \\<and> y = x\n\ngoal (1 subgoal):\n 1. y = x &&& x \\<in> Gromov_boundary", "by auto"], ["proof (state)\nthis:\n  y = x\n  x \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x\n 2. x \\<in> Gromov_boundary \\<and> y = x \\<Longrightarrow>\n    extended_Gromov_product_at e x y = \\<infinity>", "have *: \"liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = \\<infinity>\" if\n                  \"abs_Gromov_completion u = x\" \"abs_Gromov_completion v = y\"\n                  \"Gromov_completion_rel u u\" \"Gromov_completion_rel v v\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    \\<infinity>", "have \"Gromov_converging_at_boundary u\" \"Gromov_converging_at_boundary v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u &&& Gromov_converging_at_boundary v", "using Gromov_boundary_abs_converging that H"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> Gromov_boundary; abs_Gromov_completion ?u = ?x;\n   Gromov_completion_rel ?u ?u\\<rbrakk>\n  \\<Longrightarrow> Gromov_converging_at_boundary ?u\n  abs_Gromov_completion u = x\n  abs_Gromov_completion v = y\n  Gromov_completion_rel u u\n  Gromov_completion_rel v v\n  y = x\n  x \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u &&& Gromov_converging_at_boundary v", "by auto"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    \\<infinity>", "have \"Gromov_completion_rel u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "using that \\<open>y = x\\<close>"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = x\n  abs_Gromov_completion v = y\n  Gromov_completion_rel u u\n  Gromov_completion_rel v v\n  y = x\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "using Quotient3_rel[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = x\n  abs_Gromov_completion v = y\n  Gromov_completion_rel u u\n  Gromov_completion_rel v v\n  y = x\n  (Gromov_completion_rel ?r ?r \\<and>\n   Gromov_completion_rel ?s ?s \\<and>\n   abs_Gromov_completion ?r = abs_Gromov_completion ?s) =\n  Gromov_completion_rel ?r ?s\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "by fastforce"], ["proof (state)\nthis:\n  Gromov_completion_rel u v\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    \\<infinity>", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel u v", "have \"(\\<lambda>n. Gromov_product_at e (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  Gromov_completion_rel u v\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u \\<and>\n  Gromov_converging_at_boundary v \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "using Gromov_converging_at_boundary_imp_not_constant'[OF \\<open>Gromov_converging_at_boundary u\\<close>]"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u \\<and>\n  Gromov_converging_at_boundary v \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)\n  \\<not> (\\<forall>m n. u m = u n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    \\<infinity>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    \\<infinity>", "by (simp add: tendsto_iff_Liminf_eq_Limsup)"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>abs_Gromov_completion ?u = x; abs_Gromov_completion ?v = y;\n   Gromov_completion_rel ?u ?u; Gromov_completion_rel ?v ?v\\<rbrakk>\n  \\<Longrightarrow> liminf\n                     (\\<lambda>n.\n                         ereal (Gromov_product_at e (?u n) (?v n))) =\n                    \\<infinity>\n\ngoal (2 subgoals):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x\n 2. x \\<in> Gromov_boundary \\<and> y = x \\<Longrightarrow>\n    extended_Gromov_product_at e x y = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>abs_Gromov_completion ?u = x; abs_Gromov_completion ?v = y;\n   Gromov_completion_rel ?u ?u; Gromov_completion_rel ?v ?v\\<rbrakk>\n  \\<Longrightarrow> liminf\n                     (\\<lambda>n.\n                         ereal (Gromov_product_at e (?u n) (?v n))) =\n                    \\<infinity>", "show \"extended_Gromov_product_at e x y = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>abs_Gromov_completion ?u = x; abs_Gromov_completion ?v = y;\n   Gromov_completion_rel ?u ?u; Gromov_completion_rel ?v ?v\\<rbrakk>\n  \\<Longrightarrow> liminf\n                     (\\<lambda>n.\n                         ereal (Gromov_product_at e (?u n) (?v n))) =\n                    \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity>", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>abs_Gromov_completion ?u = x; abs_Gromov_completion ?v = y;\n   Gromov_completion_rel ?u ?u; Gromov_completion_rel ?v ?v\\<rbrakk>\n  \\<Longrightarrow> liminf\n                     (\\<lambda>n.\n                         ereal (Gromov_product_at e (?u n) (?v n))) =\n                    \\<infinity>\n\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion v = y \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    \\<infinity>", "by (auto intro: Inf_eqI)"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "fix x y::\"'a Gromov_completion\""], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "assume H: \"extended_Gromov_product_at e x y = \\<infinity>\""], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at e x y = \\<infinity>", "have \"extended_Gromov_distance (to_Gromov_completion e) x = \\<infinity>\""], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e x y = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion e) x = \\<infinity>", "using extended_Gromov_product_le_dist[of e x y] neq_top_trans"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e x y = \\<infinity>\n  extended_Gromov_product_at e x y\n  \\<le> extended_Gromov_distance (to_Gromov_completion e) x\n  \\<lbrakk>?y \\<noteq> top; ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<noteq> top\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion e) x = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_distance (to_Gromov_completion e) x = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_distance (to_Gromov_completion e) x = \\<infinity>", "have \"x \\<in> Gromov_boundary\""], ["proof (prove)\nusing this:\n  extended_Gromov_distance (to_Gromov_completion e) x = \\<infinity>\n\ngoal (1 subgoal):\n 1. x \\<in> Gromov_boundary", "by (metis ereal.distinct(1) extended_Gromov_distance_def infinity_ereal_def not_in_Gromov_boundary')"], ["proof (state)\nthis:\n  x \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "have \"extended_Gromov_distance (to_Gromov_completion e) y = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion e) y = \\<infinity>", "using extended_Gromov_product_le_dist[of e y x] neq_top_trans H"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e y x\n  \\<le> extended_Gromov_distance (to_Gromov_completion e) y\n  \\<lbrakk>?y \\<noteq> top; ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<noteq> top\n  extended_Gromov_product_at e x y = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion e) y = \\<infinity>", "by (auto simp add: extended_Gromov_product_at_commute)"], ["proof (state)\nthis:\n  extended_Gromov_distance (to_Gromov_completion e) y = \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_distance (to_Gromov_completion e) y = \\<infinity>", "have \"y \\<in> Gromov_boundary\""], ["proof (prove)\nusing this:\n  extended_Gromov_distance (to_Gromov_completion e) y = \\<infinity>\n\ngoal (1 subgoal):\n 1. y \\<in> Gromov_boundary", "by (metis ereal.distinct(1) extended_Gromov_distance_def infinity_ereal_def not_in_Gromov_boundary')"], ["proof (state)\nthis:\n  y \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "define u where \"u = rep_Gromov_completion x\""], ["proof (state)\nthis:\n  u = rep_Gromov_completion x\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "define v where \"v = rep_Gromov_completion y\""], ["proof (state)\nthis:\n  v = rep_Gromov_completion y\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "have A: \"Gromov_converging_at_boundary u\" \"Gromov_converging_at_boundary v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u &&& Gromov_converging_at_boundary v", "unfolding u_def v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary (rep_Gromov_completion x) &&&\n    Gromov_converging_at_boundary (rep_Gromov_completion y)", "using \\<open>x \\<in> Gromov_boundary\\<close> \\<open>y \\<in> Gromov_boundary\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary\n  y \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary (rep_Gromov_completion x) &&&\n    Gromov_converging_at_boundary (rep_Gromov_completion y)", "by (auto simp add: Gromov_boundary_rep_converging)"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "have \"abs_Gromov_completion u = x \\<and> abs_Gromov_completion v = y \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion u = x \\<and>\n    abs_Gromov_completion v = y \\<and>\n    Gromov_completion_rel u u \\<and> Gromov_completion_rel v v", "unfolding u_def v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion (rep_Gromov_completion x) = x \\<and>\n    abs_Gromov_completion (rep_Gromov_completion y) = y \\<and>\n    Gromov_completion_rel (rep_Gromov_completion x)\n     (rep_Gromov_completion x) \\<and>\n    Gromov_completion_rel (rep_Gromov_completion y)\n     (rep_Gromov_completion y)", "using Quotient3_abs_rep[OF Quotient3_Gromov_completion] Quotient3_rep_reflp[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  abs_Gromov_completion (rep_Gromov_completion ?a) = ?a\n  Gromov_completion_rel (rep_Gromov_completion ?a)\n   (rep_Gromov_completion ?a)\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion (rep_Gromov_completion x) = x \\<and>\n    abs_Gromov_completion (rep_Gromov_completion y) = y \\<and>\n    Gromov_completion_rel (rep_Gromov_completion x)\n     (rep_Gromov_completion x) \\<and>\n    Gromov_completion_rel (rep_Gromov_completion y)\n     (rep_Gromov_completion y)", "by auto"], ["proof (state)\nthis:\n  abs_Gromov_completion u = x \\<and>\n  abs_Gromov_completion v = y \\<and>\n  Gromov_completion_rel u u \\<and> Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion u = x \\<and>\n  abs_Gromov_completion v = y \\<and>\n  Gromov_completion_rel u u \\<and> Gromov_completion_rel v v", "have \"extended_Gromov_product_at e x y \\<le> liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (v n)))\""], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = x \\<and>\n  abs_Gromov_completion v = y \\<and>\n  Gromov_completion_rel u u \\<and> Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = x \\<and>\n  abs_Gromov_completion v = y \\<and>\n  Gromov_completion_rel u u \\<and> Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion v = y \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "by (auto intro!: Inf_lower)"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at e x y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "have \"(\\<lambda>n. ereal(Gromov_product_at e (u n) (v n))) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e x y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding H"], ["proof (prove)\nusing this:\n  \\<infinity>\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n    \\<longlonglongrightarrow> \\<infinity>", "by (simp add: liminf_PInfty)"], ["proof (state)\nthis:\n  (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  \\<longlonglongrightarrow> \\<infinity>", "have \"(\\<lambda>n. ereal(Gromov_product_at a (u n) (v n))) \\<longlonglongrightarrow> \\<infinity>\" for a"], ["proof (prove)\nusing this:\n  (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (Gromov_product_at a (u n) (v n)))\n    \\<longlonglongrightarrow> \\<infinity>", "using Gromov_product_tendsto_PInf_a_b"], ["proof (prove)\nusing this:\n  (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  \\<longlonglongrightarrow> \\<infinity>\n  (\\<lambda>x. ereal (Gromov_product_at ?a (?u x) (?v x)))\n  \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n  (\\<lambda>x. ereal (Gromov_product_at ?b (?u x) (?v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (Gromov_product_at a (u n) (v n)))\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. ereal (Gromov_product_at ?a (u n) (v n)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. ereal (Gromov_product_at ?a (u n) (v n)))\n  \\<longlonglongrightarrow> \\<infinity>", "have \"Gromov_completion_rel u v\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. ereal (Gromov_product_at ?a (u n) (v n)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n. ereal (Gromov_product_at ?a (u n) (v n)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary v \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)", "using A"], ["proof (prove)\nusing this:\n  (\\<lambda>n. ereal (Gromov_product_at ?a (u n) (v n)))\n  \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary v \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u v\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel u v", "have \"abs_Gromov_completion u = abs_Gromov_completion v\""], ["proof (prove)\nusing this:\n  Gromov_completion_rel u v\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion u = abs_Gromov_completion v", "using Quotient3_rel_abs[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u v\n  Gromov_completion_rel ?r ?s \\<Longrightarrow>\n  abs_Gromov_completion ?r = abs_Gromov_completion ?s\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion u = abs_Gromov_completion v", "by auto"], ["proof (state)\nthis:\n  abs_Gromov_completion u = abs_Gromov_completion v\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion u = abs_Gromov_completion v", "have \"x = y\""], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = abs_Gromov_completion v\n\ngoal (1 subgoal):\n 1. x = y", "unfolding u_def v_def Quotient3_abs_rep[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y = \\<infinity> \\<Longrightarrow>\n    x \\<in> Gromov_boundary \\<and> y = x", "then"], ["proof (chain)\npicking this:\n  x = y", "show \"x \\<in> Gromov_boundary \\<and> y = x\""], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<in> Gromov_boundary \\<and> y = x", "using \\<open>x \\<in> Gromov_boundary\\<close>"], ["proof (prove)\nusing this:\n  x = y\n  x \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. x \\<in> Gromov_boundary \\<and> y = x", "by auto"], ["proof (state)\nthis:\n  x \\<in> Gromov_boundary \\<and> y = x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As for points inside the space, we deduce that the extended Gromov product between $x$ and $x$\nis just the extended distance to the basepoint.\\<close>"], ["", "lemma extended_Gromov_product_e_x_x [simp]:\n  \"extended_Gromov_product_at e x x = extended_Gromov_distance (to_Gromov_completion e) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x x =\n    extended_Gromov_distance (to_Gromov_completion e) x", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x x =\n       extended_Gromov_distance (to_Gromov_completion e) x\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x x =\n    extended_Gromov_distance (to_Gromov_completion e) x", "case boundary"], ["proof (state)\nthis:\n  x \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x x =\n       extended_Gromov_distance (to_Gromov_completion e) x\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x x =\n    extended_Gromov_distance (to_Gromov_completion e) x", "then"], ["proof (chain)\npicking this:\n  x \\<in> Gromov_boundary", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x x =\n    extended_Gromov_distance (to_Gromov_completion e) x", "using Gromov_boundary_extended_product_PInf"], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary\n  (extended_Gromov_product_at ?e ?x ?y = \\<infinity>) =\n  (?x \\<in> Gromov_boundary \\<and> ?y = ?x)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x x =\n    extended_Gromov_distance (to_Gromov_completion e) x", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x x =\n  extended_Gromov_distance (to_Gromov_completion e) x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x x =\n       extended_Gromov_distance (to_Gromov_completion e) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x x =\n       extended_Gromov_distance (to_Gromov_completion e) x", "case (to_Gromov_completion a)"], ["proof (state)\nthis:\n  x = to_Gromov_completion a\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x x =\n       extended_Gromov_distance (to_Gromov_completion e) x", "then"], ["proof (chain)\npicking this:\n  x = to_Gromov_completion a", "show ?thesis"], ["proof (prove)\nusing this:\n  x = to_Gromov_completion a\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x x =\n    extended_Gromov_distance (to_Gromov_completion e) x", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x x =\n  extended_Gromov_distance (to_Gromov_completion e) x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The inequality in terms of Gromov products characterizing hyperbolicity extends in the\nsame form to the Gromov completion, by taking limits of this inequality in the space.\\<close>"], ["", "lemma extended_hyperb_ineq [mono_intros]:\n  \"extended_Gromov_product_at (e::'a::Gromov_hyperbolic_space) x z \\<ge>\n      min (extended_Gromov_product_at e x y) (extended_Gromov_product_at e y z) - deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y z) -\n    ereal (deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at e x z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y z) -\n    ereal (deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at e x z", "have \"min (extended_Gromov_product_at e x y) (extended_Gromov_product_at e y z) - deltaG(TYPE('a)) \\<le>\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n            abs_Gromov_completion u = x \\<and> abs_Gromov_completion v = z \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y z) -\n    ereal (deltaG TYPE('a))\n    \\<le> Inf {liminf\n                (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |\n               u v.\n               abs_Gromov_completion u = x \\<and>\n               abs_Gromov_completion v = z \\<and>\n               Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "proof (rule cInf_greatest, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>xa u.\n       Gromov_completion_rel u u \\<and>\n       (\\<exists>v.\n           abs_Gromov_completion v = z \\<and>\n           abs_Gromov_completion u = x \\<and>\n           xa =\n           liminf\n            (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) \\<and>\n           Gromov_completion_rel v v)\n 2. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "define u where \"u = rep_Gromov_completion x\""], ["proof (state)\nthis:\n  u = rep_Gromov_completion x\n\ngoal (2 subgoals):\n 1. \\<exists>xa u.\n       Gromov_completion_rel u u \\<and>\n       (\\<exists>v.\n           abs_Gromov_completion v = z \\<and>\n           abs_Gromov_completion u = x \\<and>\n           xa =\n           liminf\n            (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) \\<and>\n           Gromov_completion_rel v v)\n 2. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "define w where \"w = rep_Gromov_completion z\""], ["proof (state)\nthis:\n  w = rep_Gromov_completion z\n\ngoal (2 subgoals):\n 1. \\<exists>xa u.\n       Gromov_completion_rel u u \\<and>\n       (\\<exists>v.\n           abs_Gromov_completion v = z \\<and>\n           abs_Gromov_completion u = x \\<and>\n           xa =\n           liminf\n            (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) \\<and>\n           Gromov_completion_rel v v)\n 2. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "have \"abs_Gromov_completion u = x \\<and> abs_Gromov_completion w = z \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel w w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion u = x \\<and>\n    abs_Gromov_completion w = z \\<and>\n    Gromov_completion_rel u u \\<and> Gromov_completion_rel w w", "unfolding u_def w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion (rep_Gromov_completion x) = x \\<and>\n    abs_Gromov_completion (rep_Gromov_completion z) = z \\<and>\n    Gromov_completion_rel (rep_Gromov_completion x)\n     (rep_Gromov_completion x) \\<and>\n    Gromov_completion_rel (rep_Gromov_completion z)\n     (rep_Gromov_completion z)", "using Quotient3_abs_rep[OF Quotient3_Gromov_completion] Quotient3_rep_reflp[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  abs_Gromov_completion (rep_Gromov_completion ?a) = ?a\n  Gromov_completion_rel (rep_Gromov_completion ?a)\n   (rep_Gromov_completion ?a)\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion (rep_Gromov_completion x) = x \\<and>\n    abs_Gromov_completion (rep_Gromov_completion z) = z \\<and>\n    Gromov_completion_rel (rep_Gromov_completion x)\n     (rep_Gromov_completion x) \\<and>\n    Gromov_completion_rel (rep_Gromov_completion z)\n     (rep_Gromov_completion z)", "by auto"], ["proof (state)\nthis:\n  abs_Gromov_completion u = x \\<and>\n  abs_Gromov_completion w = z \\<and>\n  Gromov_completion_rel u u \\<and> Gromov_completion_rel w w\n\ngoal (2 subgoals):\n 1. \\<exists>xa u.\n       Gromov_completion_rel u u \\<and>\n       (\\<exists>v.\n           abs_Gromov_completion v = z \\<and>\n           abs_Gromov_completion u = x \\<and>\n           xa =\n           liminf\n            (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) \\<and>\n           Gromov_completion_rel v v)\n 2. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion u = x \\<and>\n  abs_Gromov_completion w = z \\<and>\n  Gromov_completion_rel u u \\<and> Gromov_completion_rel w w", "show \"\\<exists>t u. Gromov_completion_rel u u \\<and>\n            (\\<exists>v. abs_Gromov_completion v = z \\<and> abs_Gromov_completion u = x \\<and> t = liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) \\<and> Gromov_completion_rel v v)\""], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = x \\<and>\n  abs_Gromov_completion w = z \\<and>\n  Gromov_completion_rel u u \\<and> Gromov_completion_rel w w\n\ngoal (1 subgoal):\n 1. \\<exists>t u.\n       Gromov_completion_rel u u \\<and>\n       (\\<exists>v.\n           abs_Gromov_completion v = z \\<and>\n           abs_Gromov_completion u = x \\<and>\n           t =\n           liminf\n            (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) \\<and>\n           Gromov_completion_rel v v)", "by auto"], ["proof (state)\nthis:\n  \\<exists>t u.\n     Gromov_completion_rel u u \\<and>\n     (\\<exists>v.\n         abs_Gromov_completion v = z \\<and>\n         abs_Gromov_completion u = x \\<and>\n         t =\n         liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) \\<and>\n         Gromov_completion_rel v v)\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "fix u w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "assume H: \"x = abs_Gromov_completion u\" \"z = abs_Gromov_completion w\"\n                      \"Gromov_completion_rel u u\" \"Gromov_completion_rel w w\""], ["proof (state)\nthis:\n  x = abs_Gromov_completion u\n  z = abs_Gromov_completion w\n  Gromov_completion_rel u u\n  Gromov_completion_rel w w\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "define v where \"v = rep_Gromov_completion y\""], ["proof (state)\nthis:\n  v = rep_Gromov_completion y\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "have Y: \"y = abs_Gromov_completion v\" \"Gromov_completion_rel v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = abs_Gromov_completion v &&& Gromov_completion_rel v v", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = abs_Gromov_completion (rep_Gromov_completion y) &&&\n    Gromov_completion_rel (rep_Gromov_completion y)\n     (rep_Gromov_completion y)", "by (auto simp add: Quotient3_abs_rep[OF Quotient3_Gromov_completion] Quotient3_rep_reflp[OF Quotient3_Gromov_completion])"], ["proof (state)\nthis:\n  y = abs_Gromov_completion v\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "have *: \"min (ereal(Gromov_product_at e (u n) (v n))) (ereal(Gromov_product_at e (v n) (w n))) \\<le> ereal(Gromov_product_at e (u n) (w n)) + deltaG(TYPE('a))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (ereal (Gromov_product_at e (u n) (v n)))\n     (ereal (Gromov_product_at e (v n) (w n)))\n    \\<le> ereal (Gromov_product_at e (u n) (w n)) + ereal (deltaG TYPE('a))", "by (subst ereal_min[symmetric], subst plus_ereal.simps(1), intro mono_intros)"], ["proof (state)\nthis:\n  min (ereal (Gromov_product_at e (u ?n) (v ?n)))\n   (ereal (Gromov_product_at e (v ?n) (w ?n)))\n  \\<le> ereal (Gromov_product_at e (u ?n) (w ?n)) + ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "have \"extended_Gromov_product_at e (abs_Gromov_completion u) y \\<le> liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (v n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (abs_Gromov_completion u) y\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (ua n) (v n))) |ua\n         v. abs_Gromov_completion ua = abs_Gromov_completion u \\<and>\n            abs_Gromov_completion v = y \\<and>\n            Gromov_completion_rel ua ua \\<and> Gromov_completion_rel v v}\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "using Y H"], ["proof (prove)\nusing this:\n  y = abs_Gromov_completion v\n  Gromov_completion_rel v v\n  x = abs_Gromov_completion u\n  z = abs_Gromov_completion w\n  Gromov_completion_rel u u\n  Gromov_completion_rel w w\n\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (ua n) (v n))) |ua\n         v. abs_Gromov_completion ua = abs_Gromov_completion u \\<and>\n            abs_Gromov_completion v = y \\<and>\n            Gromov_completion_rel ua ua \\<and> Gromov_completion_rel v v}\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))", "by (auto intro!: Inf_lower)"], ["proof (state)\nthis:\n  extended_Gromov_product_at e (abs_Gromov_completion u) y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "moreover"], ["proof (state)\nthis:\n  extended_Gromov_product_at e (abs_Gromov_completion u) y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "have \"extended_Gromov_product_at e y (abs_Gromov_completion w) \\<le> liminf (\\<lambda>n. ereal(Gromov_product_at e (v n) (w n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e y (abs_Gromov_completion w)\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n)))", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = y \\<and>\n         abs_Gromov_completion v = abs_Gromov_completion w \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n)))", "using Y H"], ["proof (prove)\nusing this:\n  y = abs_Gromov_completion v\n  Gromov_completion_rel v v\n  x = abs_Gromov_completion u\n  z = abs_Gromov_completion w\n  Gromov_completion_rel u u\n  Gromov_completion_rel w w\n\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = y \\<and>\n         abs_Gromov_completion v = abs_Gromov_completion w \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n)))", "by (auto intro!: Inf_lower)"], ["proof (state)\nthis:\n  extended_Gromov_product_at e y (abs_Gromov_completion w)\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n)))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "ultimately"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at e (abs_Gromov_completion u) y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  extended_Gromov_product_at e y (abs_Gromov_completion w)\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n)))", "have \"min (extended_Gromov_product_at e (abs_Gromov_completion u) y) (extended_Gromov_product_at e y (abs_Gromov_completion w))\n      \\<le> min (liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (v n)))) (liminf (\\<lambda>n. ereal(Gromov_product_at e (v n) (w n))))\""], ["proof (prove)\nusing this:\n  extended_Gromov_product_at e (abs_Gromov_completion u) y\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n)))\n  extended_Gromov_product_at e y (abs_Gromov_completion w)\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n)))\n\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e (abs_Gromov_completion u) y)\n     (extended_Gromov_product_at e y (abs_Gromov_completion w))\n    \\<le> min (liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))))\n           (liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n))))", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e (abs_Gromov_completion u) y)\n   (extended_Gromov_product_at e y (abs_Gromov_completion w))\n  \\<le> min (liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))))\n         (liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n))))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e (abs_Gromov_completion u) y)\n   (extended_Gromov_product_at e y (abs_Gromov_completion w))\n  \\<le> min (liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))))\n         (liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n))))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "have \"... = liminf (\\<lambda>n. min (ereal(Gromov_product_at e (u n) (v n))) (ereal(Gromov_product_at e (v n) (w n))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))))\n     (liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n)))) =\n    liminf\n     (\\<lambda>n.\n         min (ereal (Gromov_product_at e (u n) (v n)))\n          (ereal (Gromov_product_at e (v n) (w n))))", "by (rule Liminf_min_eq_min_Liminf[symmetric])"], ["proof (state)\nthis:\n  min (liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))))\n   (liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n)))) =\n  liminf\n   (\\<lambda>n.\n       min (ereal (Gromov_product_at e (u n) (v n)))\n        (ereal (Gromov_product_at e (v n) (w n))))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  min (liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))))\n   (liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) (w n)))) =\n  liminf\n   (\\<lambda>n.\n       min (ereal (Gromov_product_at e (u n) (v n)))\n        (ereal (Gromov_product_at e (v n) (w n))))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "have \"... \\<le> liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (w n)) + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf\n     (\\<lambda>n.\n         min (ereal (Gromov_product_at e (u n) (v n)))\n          (ereal (Gromov_product_at e (v n) (w n))))\n    \\<le> liminf\n           (\\<lambda>n.\n               ereal (Gromov_product_at e (u n) (w n)) +\n               ereal (deltaG TYPE('a)))", "using *"], ["proof (prove)\nusing this:\n  min (ereal (Gromov_product_at e (u ?n) (v ?n)))\n   (ereal (Gromov_product_at e (v ?n) (w ?n)))\n  \\<le> ereal (Gromov_product_at e (u ?n) (w ?n)) + ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. liminf\n     (\\<lambda>n.\n         min (ereal (Gromov_product_at e (u n) (v n)))\n          (ereal (Gromov_product_at e (v n) (w n))))\n    \\<le> liminf\n           (\\<lambda>n.\n               ereal (Gromov_product_at e (u n) (w n)) +\n               ereal (deltaG TYPE('a)))", "by (auto intro!: Liminf_mono)"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       min (ereal (Gromov_product_at e (u n) (v n)))\n        (ereal (Gromov_product_at e (v n) (w n))))\n  \\<le> liminf\n         (\\<lambda>n.\n             ereal (Gromov_product_at e (u n) (w n)) +\n             ereal (deltaG TYPE('a)))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       min (ereal (Gromov_product_at e (u n) (v n)))\n        (ereal (Gromov_product_at e (v n) (w n))))\n  \\<le> liminf\n         (\\<lambda>n.\n             ereal (Gromov_product_at e (u n) (w n)) +\n             ereal (deltaG TYPE('a)))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "have \"... = liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (w n))) + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf\n     (\\<lambda>n.\n         ereal (Gromov_product_at e (u n) (w n)) +\n         ereal (deltaG TYPE('a))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n    ereal (deltaG TYPE('a))", "by (intro Liminf_add_ereal_right, auto)"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at e (u n) (w n)) + ereal (deltaG TYPE('a))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n  ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>u v.\n       \\<lbrakk>x = abs_Gromov_completion u; z = abs_Gromov_completion v;\n        Gromov_completion_rel u u; Gromov_completion_rel v v\\<rbrakk>\n       \\<Longrightarrow> min (extended_Gromov_product_at e\n                               (abs_Gromov_completion u) y)\n                          (extended_Gromov_product_at e y\n                            (abs_Gromov_completion v))\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at e (u n) (v n))) +\n                               ereal (deltaG TYPE('a))", "finally"], ["proof (chain)\npicking this:\n  min (extended_Gromov_product_at e (abs_Gromov_completion u) y)\n   (extended_Gromov_product_at e y (abs_Gromov_completion w))\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n        ereal (deltaG TYPE('a))", "show \"min (extended_Gromov_product_at e (abs_Gromov_completion u) y) (extended_Gromov_product_at e y (abs_Gromov_completion w))\n                  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) + ereal (deltaG TYPE('a))\""], ["proof (prove)\nusing this:\n  min (extended_Gromov_product_at e (abs_Gromov_completion u) y)\n   (extended_Gromov_product_at e y (abs_Gromov_completion w))\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e (abs_Gromov_completion u) y)\n     (extended_Gromov_product_at e y (abs_Gromov_completion w))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n          ereal (deltaG TYPE('a))", "by simp"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e (abs_Gromov_completion u) y)\n   (extended_Gromov_product_at e y (abs_Gromov_completion w))\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (w n))) +\n        ereal (deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e x y)\n   (extended_Gromov_product_at e y z) -\n  ereal (deltaG TYPE('a))\n  \\<le> Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n             v. abs_Gromov_completion u = x \\<and>\n                abs_Gromov_completion v = z \\<and>\n                Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y z) -\n    ereal (deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at e x z", "then"], ["proof (chain)\npicking this:\n  min (extended_Gromov_product_at e x y)\n   (extended_Gromov_product_at e y z) -\n  ereal (deltaG TYPE('a))\n  \\<le> Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n             v. abs_Gromov_completion u = x \\<and>\n                abs_Gromov_completion v = z \\<and>\n                Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "show ?thesis"], ["proof (prove)\nusing this:\n  min (extended_Gromov_product_at e x y)\n   (extended_Gromov_product_at e y z) -\n  ereal (deltaG TYPE('a))\n  \\<le> Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n             v. abs_Gromov_completion u = x \\<and>\n                abs_Gromov_completion v = z \\<and>\n                Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y z) -\n    ereal (deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at e x z", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\nusing this:\n  min (Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. abs_Gromov_completion u = x \\<and>\n               abs_Gromov_completion v = y \\<and>\n               Gromov_completion_rel u u \\<and> Gromov_completion_rel v v})\n   (Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = y \\<and>\n         abs_Gromov_completion v = z \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}) -\n  ereal (deltaG TYPE('a))\n  \\<le> Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n             v. abs_Gromov_completion u = x \\<and>\n                abs_Gromov_completion v = z \\<and>\n                Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n\ngoal (1 subgoal):\n 1. min (Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |\n              u v.\n              abs_Gromov_completion u = x \\<and>\n              abs_Gromov_completion v = y \\<and>\n              Gromov_completion_rel u u \\<and> Gromov_completion_rel v v})\n     (Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n           v. abs_Gromov_completion u = y \\<and>\n              abs_Gromov_completion v = z \\<and>\n              Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}) -\n    ereal (deltaG TYPE('a))\n    \\<le> Inf {liminf\n                (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |\n               u v.\n               abs_Gromov_completion u = x \\<and>\n               abs_Gromov_completion v = z \\<and>\n               Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}", "by auto"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e x y)\n   (extended_Gromov_product_at e y z) -\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at e x z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_hyperb_ineq' [mono_intros]:\n  \"extended_Gromov_product_at (e::'a::Gromov_hyperbolic_space) x z + deltaG(TYPE('a)) \\<ge>\n      min (extended_Gromov_product_at e x y) (extended_Gromov_product_at e y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y z)\n    \\<le> extended_Gromov_product_at e x z + ereal (deltaG TYPE('a))", "using extended_hyperb_ineq[of e x y z]"], ["proof (prove)\nusing this:\n  min (extended_Gromov_product_at e x y)\n   (extended_Gromov_product_at e y z) -\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y z)\n    \\<le> extended_Gromov_product_at e x z + ereal (deltaG TYPE('a))", "unfolding ereal_minus_le_iff"], ["proof (prove)\nusing this:\n  (ereal (deltaG TYPE('a)) = - \\<infinity> \\<longrightarrow>\n   extended_Gromov_product_at e x z = \\<infinity>) \\<and>\n  (ereal (deltaG TYPE('a)) = \\<infinity> \\<longrightarrow>\n   min (extended_Gromov_product_at e x y)\n    (extended_Gromov_product_at e y z) =\n   \\<infinity> \\<longrightarrow>\n   extended_Gromov_product_at e x z = \\<infinity>) \\<and>\n  (\\<bar>ereal (deltaG TYPE('a))\\<bar> \\<noteq>\n   \\<infinity> \\<longrightarrow>\n   min (extended_Gromov_product_at e x y) (extended_Gromov_product_at e y z)\n   \\<le> extended_Gromov_product_at e x z + ereal (deltaG TYPE('a)))\n\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y z)\n    \\<le> extended_Gromov_product_at e x z + ereal (deltaG TYPE('a))", "by (simp add: add.commute)"], ["", "lemma zero_le_ereal [mono_intros]:\n  assumes \"0 \\<le> z\"\n  shows \"0 \\<le> ereal z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> ereal z", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> z\n\ngoal (1 subgoal):\n 1. 0 \\<le> ereal z", "by auto"], ["", "lemma extended_hyperb_ineq_4_points' [mono_intros]:\n  \"Min {extended_Gromov_product_at (e::'a::Gromov_hyperbolic_space) x y, extended_Gromov_product_at e y z, extended_Gromov_product_at e z t} \\<le> extended_Gromov_product_at e x t + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t}\n    \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t}\n    \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a))", "have \"min (extended_Gromov_product_at e x y + 0) (min (extended_Gromov_product_at e y z) (extended_Gromov_product_at e z t))\n        \\<le> min (extended_Gromov_product_at e x y + deltaG(TYPE('a))) (extended_Gromov_product_at e y t + deltaG(TYPE('a))) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y + 0)\n     (min (extended_Gromov_product_at e y z)\n       (extended_Gromov_product_at e z t))\n    \\<le> min (extended_Gromov_product_at e x y + ereal (deltaG TYPE('a)))\n           (extended_Gromov_product_at e y t + ereal (deltaG TYPE('a)))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e x y + 0)\n   (min (extended_Gromov_product_at e y z)\n     (extended_Gromov_product_at e z t))\n  \\<le> min (extended_Gromov_product_at e x y + ereal (deltaG TYPE('a)))\n         (extended_Gromov_product_at e y t + ereal (deltaG TYPE('a)))\n\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t}\n    \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e x y + 0)\n   (min (extended_Gromov_product_at e y z)\n     (extended_Gromov_product_at e z t))\n  \\<le> min (extended_Gromov_product_at e x y + ereal (deltaG TYPE('a)))\n         (extended_Gromov_product_at e y t + ereal (deltaG TYPE('a)))\n\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t}\n    \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a))", "have \"... = min (extended_Gromov_product_at e x y) (extended_Gromov_product_at e y t) + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y + ereal (deltaG TYPE('a)))\n     (extended_Gromov_product_at e y t + ereal (deltaG TYPE('a))) =\n    min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y t) +\n    ereal (deltaG TYPE('a))", "by (simp add: add_mono_thms_linordered_semiring(3) dual_order.antisym min_def)"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e x y + ereal (deltaG TYPE('a)))\n   (extended_Gromov_product_at e y t + ereal (deltaG TYPE('a))) =\n  min (extended_Gromov_product_at e x y)\n   (extended_Gromov_product_at e y t) +\n  ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t}\n    \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e x y + ereal (deltaG TYPE('a)))\n   (extended_Gromov_product_at e y t + ereal (deltaG TYPE('a))) =\n  min (extended_Gromov_product_at e x y)\n   (extended_Gromov_product_at e y t) +\n  ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t}\n    \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a))", "have \"... \\<le> (extended_Gromov_product_at e x t + deltaG(TYPE('a))) + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (extended_Gromov_product_at e y t) +\n    ereal (deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at e x t + ereal (deltaG TYPE('a)) +\n          ereal (deltaG TYPE('a))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at e x y)\n   (extended_Gromov_product_at e y t) +\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at e x t + ereal (deltaG TYPE('a)) +\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t}\n    \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a))", "finally"], ["proof (chain)\npicking this:\n  min (extended_Gromov_product_at e x y + 0)\n   (min (extended_Gromov_product_at e y z)\n     (extended_Gromov_product_at e z t))\n  \\<le> extended_Gromov_product_at e x t + ereal (deltaG TYPE('a)) +\n        ereal (deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\nusing this:\n  min (extended_Gromov_product_at e x y + 0)\n   (min (extended_Gromov_product_at e y z)\n     (extended_Gromov_product_at e z t))\n  \\<le> extended_Gromov_product_at e x t + ereal (deltaG TYPE('a)) +\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t}\n    \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a))", "apply (auto simp add: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at e x y)\n     (min (extended_Gromov_product_at e y z)\n       (extended_Gromov_product_at e z t))\n    \\<le> ereal (deltaG TYPE('a)) +\n          (ereal (deltaG TYPE('a)) +\n           extended_Gromov_product_at e x t) \\<Longrightarrow>\n    min (extended_Gromov_product_at e x y)\n     (min (extended_Gromov_product_at e y z)\n       (extended_Gromov_product_at e z t))\n    \\<le> extended_Gromov_product_at e x t + ereal (deltaG TYPE('a) * 2)", "by (metis (no_types, hide_lams) add.commute add.left_commute mult_2_right plus_ereal.simps(1))"], ["proof (state)\nthis:\n  Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n       extended_Gromov_product_at e z t}\n  \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_hyperb_ineq_4_points [mono_intros]:\n  \"Min {extended_Gromov_product_at (e::'a::Gromov_hyperbolic_space) x y, extended_Gromov_product_at e y z, extended_Gromov_product_at e z t} - 2 * deltaG(TYPE('a)) \\<le> extended_Gromov_product_at e x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t} -\n    ereal (2 * deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at e x t", "using extended_hyperb_ineq_4_points'[of e x y z]"], ["proof (prove)\nusing this:\n  Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n       extended_Gromov_product_at e z ?t}\n  \\<le> extended_Gromov_product_at e x ?t + ereal (2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n         extended_Gromov_product_at e z t} -\n    ereal (2 * deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at e x t", "unfolding ereal_minus_le_iff"], ["proof (prove)\nusing this:\n  Min {extended_Gromov_product_at e x y, extended_Gromov_product_at e y z,\n       extended_Gromov_product_at e z ?t}\n  \\<le> extended_Gromov_product_at e x ?t + ereal (2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. (ereal (2 * deltaG TYPE('a)) = - \\<infinity> \\<longrightarrow>\n     extended_Gromov_product_at e x t = \\<infinity>) \\<and>\n    (ereal (2 * deltaG TYPE('a)) = \\<infinity> \\<longrightarrow>\n     Min {extended_Gromov_product_at e x y,\n          extended_Gromov_product_at e y z,\n          extended_Gromov_product_at e z t} =\n     \\<infinity> \\<longrightarrow>\n     extended_Gromov_product_at e x t = \\<infinity>) \\<and>\n    (\\<bar>ereal (2 * deltaG TYPE('a))\\<bar> \\<noteq>\n     \\<infinity> \\<longrightarrow>\n     Min {extended_Gromov_product_at e x y,\n          extended_Gromov_product_at e y z,\n          extended_Gromov_product_at e z t}\n     \\<le> extended_Gromov_product_at e x t + ereal (2 * deltaG TYPE('a)))", "by (simp add: add.commute)"], ["", "subsection \\<open>Construction of the distance on the Gromov completion\\<close>"], ["", "text \\<open>We want now to define the natural topology of the Gromov completion. Most textbooks\nfirst define a topology on $\\partial X$, or sometimes on\n$X \\cup \\partial X$, and then much later a distance on $\\partial X$ (but they never do the tedious\nverification that the distance defines the same topology as the topology defined before). I have\nnot seen one textbook defining a distance on $X \\cup \\partial X$. It turns out that one can in fact\ndefine a distance on $X \\cup \\partial X$, whose restriction to $\\partial X$ is the usual distance\non the Gromov boundary, and define the topology of $X \\cup \\partial X$ using it. For formalization\npurposes, this is very convenient as topologies defined with distances are automatically nice and\ntractable (no need to check separation axioms, for instance). The price to pay is that, once\nwe have defined the distance, we have to check that it defines the right notion of convergence\none expects.\n\nWhat we would like to take for the distance is\n$d(x,y) = e^{-(x,y)_o}$, where $o$ is some fixed basepoint in the space. However, this\ndoes not behave like a distance at small scales (but it is essentially the right thing at large\nscales), and it does not really satisfy the triangle inequality. However, $e^{-\\epsilon (x,y)_o}$\nalmost satisfies the triangle inequality if $\\epsilon$ is small enough, i.e., it is equivalent\nto a function satisfying the triangle inequality. This gives a genuine distance on the boundary,\nbut not inside the space as it does not vanish on pairs $(x,x)$.\n\nA third try would be to take $d(x,y) = \\min(\\tilde d(x,y), e^{-\\epsilon (x,y)_o})$ where\n$\\tilde d$ is the natural extension of $d$ to the Gromov completion (it is infinite if $x$ or $y$\nbelongs to the boundary). However, we can not prove that it is equivalent to a distance.\n\nFinally, it works with $d(x,y) \\asymp \\min(\\tilde d(x,y)^{1/2}, e^{-\\epsilon (x,y)_o}$. This is\nwhat we will prove below. To construct the distance, we use the results proved in\nthe locale \\verb+Turn_into_distance+. For this, we need to check that our quasi-distance\nsatisfies a weird version of the triangular inequality.\n\nAll this construction depends on a basepoint, that we fix arbitrarily once and for all.\n\\<close>"], ["", "definition epsilonG::\"('a::Gromov_hyperbolic_space) itself \\<Rightarrow> real\"\n  where \"epsilonG _ = ln 2 / (2+2*deltaG(TYPE('a)))\""], ["", "definition basepoint::\"'a\"\n  where \"basepoint = (SOME a. True)\""], ["", "lemma constant_in_extended_predist_pos [simp, mono_intros]:\n  \"epsilonG(TYPE('a::Gromov_hyperbolic_space)) > 0\"\n  \"epsilonG(TYPE('a::Gromov_hyperbolic_space)) \\<ge> 0\"\n  \"ennreal (epsilonG(TYPE('a))) * top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < epsilonG TYPE('a) &&&\n    0 \\<le> epsilonG TYPE('a) &&& ennreal (epsilonG TYPE('a)) * top = top", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < epsilonG TYPE('a)\n 2. 0 \\<le> epsilonG TYPE('a)\n 3. ennreal (epsilonG TYPE('a)) * top = top", "have *: \"2+2*deltaG(TYPE('a)) \\<ge> 2 + 2 * 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + 2 * 0 \\<le> 2 + 2 * deltaG TYPE('a)", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  2 + 2 * 0 \\<le> 2 + 2 * deltaG TYPE('a)\n\ngoal (3 subgoals):\n 1. 0 < epsilonG TYPE('a)\n 2. 0 \\<le> epsilonG TYPE('a)\n 3. ennreal (epsilonG TYPE('a)) * top = top", "show **: \"epsilonG(TYPE('a)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < epsilonG TYPE('a)", "unfolding epsilonG_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ln 2 / (2 + 2 * deltaG TYPE('a))", "apply (auto simp add: divide_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 2 + 2 * deltaG TYPE('a) < 0 \\<Longrightarrow> False\n 2. 2 + 2 * deltaG TYPE('a) = 0 \\<Longrightarrow> False", "using *"], ["proof (prove)\nusing this:\n  2 + 2 * 0 \\<le> 2 + 2 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. 2 + 2 * deltaG TYPE('a) < 0 \\<Longrightarrow> False\n 2. 2 + 2 * deltaG TYPE('a) = 0 \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  0 < epsilonG TYPE('a)\n\ngoal (2 subgoals):\n 1. 0 \\<le> epsilonG TYPE('a)\n 2. ennreal (epsilonG TYPE('a)) * top = top", "then"], ["proof (chain)\npicking this:\n  0 < epsilonG TYPE('a)", "show \"ennreal (epsilonG(TYPE('a))) * top = top\""], ["proof (prove)\nusing this:\n  0 < epsilonG TYPE('a)\n\ngoal (1 subgoal):\n 1. ennreal (epsilonG TYPE('a)) * top = top", "using ennreal_mult_top"], ["proof (prove)\nusing this:\n  0 < epsilonG TYPE('a)\n  ?a * top = (if ?a = 0 then 0 else top)\n\ngoal (1 subgoal):\n 1. ennreal (epsilonG TYPE('a)) * top = top", "by auto"], ["proof (state)\nthis:\n  ennreal (epsilonG TYPE('a)) * top = top\n\ngoal (1 subgoal):\n 1. 0 \\<le> epsilonG TYPE('a)", "show \"epsilonG(TYPE('a::Gromov_hyperbolic_space)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> epsilonG TYPE('a)", "using **"], ["proof (prove)\nusing this:\n  0 < epsilonG TYPE('a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> epsilonG TYPE('a)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> epsilonG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition extended_predist::\"('a::Gromov_hyperbolic_space) Gromov_completion \\<Rightarrow> 'a Gromov_completion \\<Rightarrow> real\"\n  where \"extended_predist x y = real_of_ereal (min (esqrt (extended_Gromov_distance x y))\n          (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)))\""], ["", "lemma extended_predist_ereal:\n  \"ereal (extended_predist x (y::('a::Gromov_hyperbolic_space) Gromov_completion)) = min (esqrt (extended_Gromov_distance x y))\n          (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (extended_predist x y) =\n    min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ereal (extended_predist x y) =\n    min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))", "have \"eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y) \\<le> eexp (0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y)\n    \\<le> eexp 0", "by (intro mono_intros, simp add: ereal_mult_le_0_iff)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0\n\ngoal (1 subgoal):\n 1. ereal (extended_predist x y) =\n    min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))", "then"], ["proof (chain)\npicking this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0", "have A: \"min (esqrt (extended_Gromov_distance x y)) (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)) \\<le> 1\""], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0\n\ngoal (1 subgoal):\n 1. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 1", "unfolding min_def"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0\n\ngoal (1 subgoal):\n 1. (if esqrt (extended_Gromov_distance x y)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x y)\n     then esqrt (extended_Gromov_distance x y)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y))\n    \\<le> 1", "using order_trans"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. (if esqrt (extended_Gromov_distance x y)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x y)\n     then esqrt (extended_Gromov_distance x y)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y))\n    \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. ereal (extended_predist x y) =\n    min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (extended_predist x y) =\n    min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))", "unfolding extended_predist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal\n     (real_of_ereal\n       (min (esqrt (extended_Gromov_distance x y))\n         (eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y)))) =\n    min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))", "apply (rule ereal_real')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>min (esqrt (extended_Gromov_distance x y))\n           (eexp\n             (ereal (- epsilonG TYPE('a)) *\n              extended_Gromov_product_at basepoint x y))\\<bar> \\<noteq>\n    \\<infinity>", "using A"], ["proof (prove)\nusing this:\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<bar>min (esqrt (extended_Gromov_distance x y))\n           (eexp\n             (ereal (- epsilonG TYPE('a)) *\n              extended_Gromov_product_at basepoint x y))\\<bar> \\<noteq>\n    \\<infinity>", "by auto"], ["proof (state)\nthis:\n  ereal (extended_predist x y) =\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_predist_nonneg [simp, mono_intros]:\n  \"extended_predist x y \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> extended_predist x y", "unfolding extended_predist_def min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_ereal\n             (if esqrt (extended_Gromov_distance x y)\n                 \\<le> eexp\n                        (ereal (- epsilonG TYPE('a)) *\n                         extended_Gromov_product_at basepoint x y)\n              then esqrt (extended_Gromov_distance x y)\n              else eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y))", "by (auto intro: real_of_ereal_pos)"], ["", "lemma extended_predist_commute:\n  \"extended_predist x y = extended_predist y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_predist x y = extended_predist y x", "unfolding extended_predist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_ereal\n     (min (esqrt (extended_Gromov_distance x y))\n       (eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y))) =\n    real_of_ereal\n     (min (esqrt (extended_Gromov_distance y x))\n       (eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y x)))", "by (simp add: extended_Gromov_distance_commute extended_Gromov_product_at_commute)"], ["", "lemma extended_predist_self0 [simp]:\n  \"extended_predist x y = 0 \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (extended_predist x y = 0) = (x = y)", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. extended_predist x y = 0 \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> extended_predist y y = 0", "show \"extended_predist y y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_predist y y = 0", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       y = to_Gromov_completion x \\<Longrightarrow> extended_predist y y = 0\n 2. y \\<in> Gromov_boundary \\<Longrightarrow> extended_predist y y = 0", "case boundary"], ["proof (state)\nthis:\n  y \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       y = to_Gromov_completion x \\<Longrightarrow> extended_predist y y = 0\n 2. y \\<in> Gromov_boundary \\<Longrightarrow> extended_predist y y = 0", "then"], ["proof (chain)\npicking this:\n  y \\<in> Gromov_boundary", "have *: \"extended_Gromov_product_at basepoint y y = \\<infinity>\""], ["proof (prove)\nusing this:\n  y \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint y y = \\<infinity>", "using Gromov_boundary_extended_product_PInf"], ["proof (prove)\nusing this:\n  y \\<in> Gromov_boundary\n  (extended_Gromov_product_at ?e ?x ?y = \\<infinity>) =\n  (?x \\<in> Gromov_boundary \\<and> ?y = ?x)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint y y = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint y y = \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       y = to_Gromov_completion x \\<Longrightarrow> extended_predist y y = 0\n 2. y \\<in> Gromov_boundary \\<Longrightarrow> extended_predist y y = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_predist y y = 0", "unfolding extended_predist_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_ereal\n     (min (esqrt (extended_Gromov_distance y y))\n       (eexp (ereal (- epsilonG TYPE('a)) * \\<infinity>))) =\n    0", "apply (auto simp add: min_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. epsilonG TYPE('a) < 0 \\<Longrightarrow>\n    real_of_ereal (esqrt (extended_Gromov_distance y y)) = 0\n 2. \\<lbrakk>epsilonG TYPE('a) = 0;\n     esqrt (extended_Gromov_distance y y) \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> real_of_ereal (esqrt (extended_Gromov_distance y y)) =\n                      0\n 3. epsilonG TYPE('a) = 0 \\<Longrightarrow>\n    esqrt (extended_Gromov_distance y y) \\<le> 1\n 4. \\<lbrakk>\\<not> epsilonG TYPE('a) < 0; epsilonG TYPE('a) \\<noteq> 0;\n     esqrt (extended_Gromov_distance y y) \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> real_of_ereal (esqrt (extended_Gromov_distance y y)) =\n                      0", "using constant_in_extended_predist_pos(1)[where ?'a = 'a] boundary"], ["proof (prove)\nusing this:\n  0 < epsilonG TYPE('a)\n  y \\<in> Gromov_boundary\n\ngoal (4 subgoals):\n 1. epsilonG TYPE('a) < 0 \\<Longrightarrow>\n    real_of_ereal (esqrt (extended_Gromov_distance y y)) = 0\n 2. \\<lbrakk>epsilonG TYPE('a) = 0;\n     esqrt (extended_Gromov_distance y y) \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> real_of_ereal (esqrt (extended_Gromov_distance y y)) =\n                      0\n 3. epsilonG TYPE('a) = 0 \\<Longrightarrow>\n    esqrt (extended_Gromov_distance y y) \\<le> 1\n 4. \\<lbrakk>\\<not> epsilonG TYPE('a) < 0; epsilonG TYPE('a) \\<noteq> 0;\n     esqrt (extended_Gromov_distance y y) \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> real_of_ereal (esqrt (extended_Gromov_distance y y)) =\n                      0", "by auto"], ["proof (state)\nthis:\n  extended_predist y y = 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       y = to_Gromov_completion x \\<Longrightarrow> extended_predist y y = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       y = to_Gromov_completion x \\<Longrightarrow> extended_predist y y = 0", "case (to_Gromov_completion a)"], ["proof (state)\nthis:\n  y = to_Gromov_completion a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       y = to_Gromov_completion x \\<Longrightarrow> extended_predist y y = 0", "then"], ["proof (chain)\npicking this:\n  y = to_Gromov_completion a", "show ?thesis"], ["proof (prove)\nusing this:\n  y = to_Gromov_completion a\n\ngoal (1 subgoal):\n 1. extended_predist y y = 0", "unfolding extended_predist_def"], ["proof (prove)\nusing this:\n  y = to_Gromov_completion a\n\ngoal (1 subgoal):\n 1. real_of_ereal\n     (min (esqrt (extended_Gromov_distance y y))\n       (eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y y))) =\n    0", "by (auto simp add: min_def)"], ["proof (state)\nthis:\n  extended_predist y y = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  extended_predist y y = 0\n\ngoal (1 subgoal):\n 1. extended_predist x y = 0 \\<Longrightarrow> x = y", "assume \"extended_predist x y = 0\""], ["proof (state)\nthis:\n  extended_predist x y = 0\n\ngoal (1 subgoal):\n 1. extended_predist x y = 0 \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  extended_predist x y = 0", "have \"esqrt (extended_Gromov_distance x y) = 0 \\<or> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y) = 0\""], ["proof (prove)\nusing this:\n  extended_predist x y = 0\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) = 0 \\<or>\n    eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0", "by (metis extended_predist_ereal min_def zero_ereal_def)"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x y) = 0 \\<or>\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) =\n  0\n\ngoal (1 subgoal):\n 1. extended_predist x y = 0 \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  esqrt (extended_Gromov_distance x y) = 0 \\<or>\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) =\n  0", "show \"x = y\""], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x y) = 0 \\<or>\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) =\n  0\n\ngoal (1 subgoal):\n 1. x = y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y) = 0 \\<Longrightarrow> x = y\n 2. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "assume \"esqrt (extended_Gromov_distance x y) = 0\""], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x y) = 0\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y) = 0 \\<Longrightarrow> x = y\n 2. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "then"], ["proof (chain)\npicking this:\n  esqrt (extended_Gromov_distance x y) = 0", "have *: \"extended_Gromov_distance x y = 0\""], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x y) = 0\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y = 0", "using extended_Gromov_distance_nonneg"], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x y) = 0\n  0 \\<le> extended_Gromov_distance ?x ?y\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y = 0", "by (metis ereal_zero_mult esqrt_square)"], ["proof (state)\nthis:\n  extended_Gromov_distance x y = 0\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y) = 0 \\<Longrightarrow> x = y\n 2. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_distance x y = 0", "have \"\\<not>(x \\<in> Gromov_boundary)\" \"\\<not>(y \\<in> Gromov_boundary)\""], ["proof (prove)\nusing this:\n  extended_Gromov_distance x y = 0\n\ngoal (1 subgoal):\n 1. x \\<notin> Gromov_boundary &&& y \\<notin> Gromov_boundary", "by auto"], ["proof (state)\nthis:\n  x \\<notin> Gromov_boundary\n  y \\<notin> Gromov_boundary\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y) = 0 \\<Longrightarrow> x = y\n 2. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "then"], ["proof (chain)\npicking this:\n  x \\<notin> Gromov_boundary\n  y \\<notin> Gromov_boundary", "obtain a b where ab: \"x = to_Gromov_completion a\" \"y = to_Gromov_completion b\""], ["proof (prove)\nusing this:\n  x \\<notin> Gromov_boundary\n  y \\<notin> Gromov_boundary\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = to_Gromov_completion a;\n         y = to_Gromov_completion b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Gromov_boundary_def"], ["proof (prove)\nusing this:\n  x \\<notin> UNIV - range to_Gromov_completion\n  y \\<notin> UNIV - range to_Gromov_completion\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>x = to_Gromov_completion a;\n         y = to_Gromov_completion b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = to_Gromov_completion a\n  y = to_Gromov_completion b\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y) = 0 \\<Longrightarrow> x = y\n 2. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "have \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "using *"], ["proof (prove)\nusing this:\n  extended_Gromov_distance x y = 0\n\ngoal (1 subgoal):\n 1. a = b", "unfolding ab"], ["proof (prove)\nusing this:\n  extended_Gromov_distance (to_Gromov_completion a)\n   (to_Gromov_completion b) =\n  0\n\ngoal (1 subgoal):\n 1. a = b", "by auto"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y) = 0 \\<Longrightarrow> x = y\n 2. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "then"], ["proof (chain)\npicking this:\n  a = b", "show \"x = y\""], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. x = y", "using ab"], ["proof (prove)\nusing this:\n  a = b\n  x = to_Gromov_completion a\n  y = to_Gromov_completion b\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "assume \"eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y) = 0\""], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) =\n  0\n\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "then"], ["proof (chain)\npicking this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) =\n  0", "have \"extended_Gromov_product_at basepoint x y = \\<infinity>\""], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) =\n  0\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint x y = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint x y = \\<infinity>\n\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) =\n    0 \\<Longrightarrow>\n    x = y", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at basepoint x y = \\<infinity>", "show \"x = y\""], ["proof (prove)\nusing this:\n  extended_Gromov_product_at basepoint x y = \\<infinity>\n\ngoal (1 subgoal):\n 1. x = y", "using Gromov_boundary_extended_product_PInf[of basepoint x y]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at basepoint x y = \\<infinity>\n  (extended_Gromov_product_at basepoint x y = \\<infinity>) =\n  (x \\<in> Gromov_boundary \\<and> y = x)\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_predist_le1 [simp, mono_intros]:\n  \"extended_predist x y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_predist x y \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_predist x y \\<le> 1", "have \"eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y) \\<le> eexp (0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y)\n    \\<le> eexp 0", "by (intro mono_intros, simp add: ereal_mult_le_0_iff)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0\n\ngoal (1 subgoal):\n 1. extended_predist x y \\<le> 1", "then"], ["proof (chain)\npicking this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0", "have \"min (esqrt (extended_Gromov_distance x y)) (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)) \\<le> 1\""], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0\n\ngoal (1 subgoal):\n 1. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 1", "unfolding min_def"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0\n\ngoal (1 subgoal):\n 1. (if esqrt (extended_Gromov_distance x y)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x y)\n     then esqrt (extended_Gromov_distance x y)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y))\n    \\<le> 1", "using order_trans"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp 0\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. (if esqrt (extended_Gromov_distance x y)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x y)\n     then esqrt (extended_Gromov_distance x y)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y))\n    \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. extended_predist x y \\<le> 1", "then"], ["proof (chain)\npicking this:\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. extended_predist x y \\<le> 1", "unfolding extended_predist_def"], ["proof (prove)\nusing this:\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 1\n\ngoal (1 subgoal):\n 1. real_of_ereal\n     (min (esqrt (extended_Gromov_distance x y))\n       (eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)))\n    \\<le> 1", "by (simp add: real_of_ereal_le_1)"], ["proof (state)\nthis:\n  extended_predist x y \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_predist_weak_triangle:\n  \"extended_predist x z \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_predist x z\n    \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_predist x z\n    \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)", "have Z: \"esqrt 2 = eexp (ereal(ln 2/2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt 2 = eexp (ereal (ln 2 / 2))", "by (subst esqrt_eq_iff_square, auto simp add: exp_add[symmetric])"], ["proof (state)\nthis:\n  esqrt 2 = eexp (ereal (ln 2 / 2))\n\ngoal (1 subgoal):\n 1. extended_predist x z\n    \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)", "have A: \"eexp(ereal(epsilonG TYPE('a)) * 1) \\<le> esqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (ereal (epsilonG TYPE('a)) * 1) \\<le> esqrt 2", "unfolding Z epsilonG_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (ereal (ln 2 / (2 + 2 * deltaG TYPE('a))) * 1)\n    \\<le> eexp (ereal (ln 2 / 2))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. ln 2 * 2 / (2 + 2 * deltaG TYPE('a)) \\<le> ln 2", "apply (auto simp add: algebra_simps divide_simps intro!: mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + deltaG TYPE('a) * 2 < 0 \\<Longrightarrow>\n    deltaG TYPE('a) * ln 2 \\<le> 0", "using delta_nonneg[where ?'a = 'a]"], ["proof (prove)\nusing this:\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. 2 + deltaG TYPE('a) * 2 < 0 \\<Longrightarrow>\n    deltaG TYPE('a) * ln 2 \\<le> 0", "by auto"], ["proof (state)\nthis:\n  eexp (ereal (epsilonG TYPE('a)) * 1) \\<le> esqrt 2\n\ngoal (1 subgoal):\n 1. extended_predist x z\n    \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)", "text \\<open>We have to show an inequality $d(x, z) \\leq \\sqrt{2} \\max(d(x,y), d(y,z))$. Each of $d(x,y)$\n  and $d(y,z)$ is either the extended distance, or the exponential of minus the Gromov product,\n  depending on which is smaller. We split according to the four cases.\\<close>"], ["proof (state)\nthis:\n  eexp (ereal (epsilonG TYPE('a)) * 1) \\<le> esqrt 2\n\ngoal (1 subgoal):\n 1. extended_predist x z\n    \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)", "have \"(esqrt (extended_Gromov_distance x y) \\<le> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)\n        \\<or> esqrt (extended_Gromov_distance x y) \\<ge> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y))\n        \\<and>\n      ((esqrt (extended_Gromov_distance y z) \\<le> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint y z)\n        \\<or> esqrt (extended_Gromov_distance y z) \\<ge> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint y z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (esqrt (extended_Gromov_distance x y)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint x y) \\<or>\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint x y)\n     \\<le> esqrt (extended_Gromov_distance x y)) \\<and>\n    (esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z) \\<or>\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z))", "by auto"], ["proof (state)\nthis:\n  (esqrt (extended_Gromov_distance x y)\n   \\<le> eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y) \\<or>\n   eexp\n    (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n   \\<le> esqrt (extended_Gromov_distance x y)) \\<and>\n  (esqrt (extended_Gromov_distance y z)\n   \\<le> eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint y z) \\<or>\n   eexp\n    (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n   \\<le> esqrt (extended_Gromov_distance y z))\n\ngoal (1 subgoal):\n 1. extended_predist x z\n    \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)", "then"], ["proof (chain)\npicking this:\n  (esqrt (extended_Gromov_distance x y)\n   \\<le> eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y) \\<or>\n   eexp\n    (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n   \\<le> esqrt (extended_Gromov_distance x y)) \\<and>\n  (esqrt (extended_Gromov_distance y z)\n   \\<le> eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint y z) \\<or>\n   eexp\n    (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n   \\<le> esqrt (extended_Gromov_distance y z))", "have \"ereal(extended_predist x z) \\<le> ereal (sqrt 2) * max (ereal(extended_predist x y)) (ereal (extended_predist y z))\""], ["proof (prove)\nusing this:\n  (esqrt (extended_Gromov_distance x y)\n   \\<le> eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y) \\<or>\n   eexp\n    (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n   \\<le> esqrt (extended_Gromov_distance x y)) \\<and>\n  (esqrt (extended_Gromov_distance y z)\n   \\<le> eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint y z) \\<or>\n   eexp\n    (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n   \\<le> esqrt (extended_Gromov_distance y z))\n\ngoal (1 subgoal):\n 1. ereal (extended_predist x z)\n    \\<le> ereal (sqrt 2) *\n          max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "proof (auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 4. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>First, consider the case where the minimum is the extended distance for both cases.\n    Then $ed(x,z) \\leq ed(x,y) + ed(y,z) \\leq 2 \\max(ed(x,y), ed(y,z))$. Therefore, $ed(x,z)^{1/2}\n    \\leq \\sqrt{2} \\max(ed(x,y)^{1/2}, ed(y,z)^{1/2})$. As predist is defined using\n    the square root of $ed$, this readily gives the result.\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 4. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "assume H: \"esqrt (extended_Gromov_distance x y) \\<le> eexp (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\"\n              \"esqrt (extended_Gromov_distance y z) \\<le> eexp (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\""], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n  esqrt (extended_Gromov_distance y z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 4. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"extended_Gromov_distance x z \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance x z\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z", "by (rule extended_Gromov_distance_triangle)"], ["proof (state)\nthis:\n  extended_Gromov_distance x z\n  \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\n\ngoal (4 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 4. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  extended_Gromov_distance x z\n  \\<le> extended_Gromov_distance x y + extended_Gromov_distance y z\n\ngoal (4 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 4. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> 2 * max (extended_Gromov_distance x y) (extended_Gromov_distance y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y + extended_Gromov_distance y z\n    \\<le> 2 *\n          max (extended_Gromov_distance x y) (extended_Gromov_distance y z)", "by (simp add: add_mono add_mono_thms_linordered_semiring(1) mult_2_ereal)"], ["proof (state)\nthis:\n  extended_Gromov_distance x y + extended_Gromov_distance y z\n  \\<le> 2 *\n        max (extended_Gromov_distance x y) (extended_Gromov_distance y z)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 4. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "finally"], ["proof (chain)\npicking this:\n  extended_Gromov_distance x z\n  \\<le> 2 *\n        max (extended_Gromov_distance x y) (extended_Gromov_distance y z)", "have \"esqrt (extended_Gromov_distance x z) \\<le> esqrt (2 * max (extended_Gromov_distance x y) (extended_Gromov_distance y z))\""], ["proof (prove)\nusing this:\n  extended_Gromov_distance x z\n  \\<le> 2 *\n        max (extended_Gromov_distance x y) (extended_Gromov_distance y z)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x z)\n    \\<le> esqrt\n           (2 *\n            max (extended_Gromov_distance x y)\n             (extended_Gromov_distance y z))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x z)\n  \\<le> esqrt\n         (2 *\n          max (extended_Gromov_distance x y) (extended_Gromov_distance y z))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 4. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x z)\n  \\<le> esqrt\n         (2 *\n          max (extended_Gromov_distance x y) (extended_Gromov_distance y z))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 4. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... = esqrt 2 * max (esqrt (extended_Gromov_distance x y)) (esqrt (extended_Gromov_distance y z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt\n     (2 *\n      max (extended_Gromov_distance x y) (extended_Gromov_distance y z)) =\n    esqrt 2 *\n    max (esqrt (extended_Gromov_distance x y))\n     (esqrt (extended_Gromov_distance y z))", "by (auto simp add: esqrt_mult max_of_mono[OF esqrt_mono])"], ["proof (state)\nthis:\n  esqrt\n   (2 * max (extended_Gromov_distance x y) (extended_Gromov_distance y z)) =\n  esqrt 2 *\n  max (esqrt (extended_Gromov_distance x y))\n   (esqrt (extended_Gromov_distance y z))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 4. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "finally"], ["proof (chain)\npicking this:\n  esqrt (extended_Gromov_distance x z)\n  \\<le> esqrt 2 *\n        max (esqrt (extended_Gromov_distance x y))\n         (esqrt (extended_Gromov_distance y z))", "show ?thesis"], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x z)\n  \\<le> esqrt 2 *\n        max (esqrt (extended_Gromov_distance x y))\n         (esqrt (extended_Gromov_distance y z))\n\ngoal (1 subgoal):\n 1. ereal (extended_predist x z)\n    \\<le> ereal (sqrt 2) *\n          max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "unfolding extended_predist_ereal min_def"], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x z)\n  \\<le> esqrt 2 *\n        max (esqrt (extended_Gromov_distance x y))\n         (esqrt (extended_Gromov_distance y z))\n\ngoal (1 subgoal):\n 1. (if esqrt (extended_Gromov_distance x z)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x z)\n     then esqrt (extended_Gromov_distance x z)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x z))\n    \\<le> ereal (sqrt 2) *\n          max (if esqrt (extended_Gromov_distance x y)\n                  \\<le> eexp\n                         (ereal (- epsilonG TYPE('a)) *\n                          extended_Gromov_product_at basepoint x y)\n               then esqrt (extended_Gromov_distance x y)\n               else eexp\n                     (ereal (- epsilonG TYPE('a)) *\n                      extended_Gromov_product_at basepoint x y))\n           (if esqrt (extended_Gromov_distance y z)\n               \\<le> eexp\n                      (ereal (- epsilonG TYPE('a)) *\n                       extended_Gromov_product_at basepoint y z)\n            then esqrt (extended_Gromov_distance y z)\n            else eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint y z))", "using H"], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x z)\n  \\<le> esqrt 2 *\n        max (esqrt (extended_Gromov_distance x y))\n         (esqrt (extended_Gromov_distance y z))\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n  esqrt (extended_Gromov_distance y z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z)\n\ngoal (1 subgoal):\n 1. (if esqrt (extended_Gromov_distance x z)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x z)\n     then esqrt (extended_Gromov_distance x z)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x z))\n    \\<le> ereal (sqrt 2) *\n          max (if esqrt (extended_Gromov_distance x y)\n                  \\<le> eexp\n                         (ereal (- epsilonG TYPE('a)) *\n                          extended_Gromov_product_at basepoint x y)\n               then esqrt (extended_Gromov_distance x y)\n               else eexp\n                     (ereal (- epsilonG TYPE('a)) *\n                      extended_Gromov_product_at basepoint x y))\n           (if esqrt (extended_Gromov_distance y z)\n               \\<le> eexp\n                      (ereal (- epsilonG TYPE('a)) *\n                       extended_Gromov_product_at basepoint y z)\n            then esqrt (extended_Gromov_distance y z)\n            else eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint y z))", "by auto"], ["proof (state)\nthis:\n  ereal (extended_predist x z)\n  \\<le> ereal (sqrt 2) *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>Next, consider the case where the minimum comes from the Gromov product for both cases.\n    Then, the conclusion will come for the hyperbolicity inequality (which is valid in the Gromov\n    completion as well). There is an additive loss of $\\delta$ in this inequality, which is converted\n    to a multiplicative loss after taking the exponential to get the distance. Since, in the formula\n    for the distance, the Gromov product is multiplied by a constant $\\epsilon$ by design, the loss\n    we get in the end is $\\exp(\\delta \\epsilon)$. The precise value of $\\epsilon$ we have taken is\n    designed so that this is at most $\\sqrt{2}$, giving the desired conclusion.\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "assume H: \"eexp (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y) \\<le> esqrt (extended_Gromov_distance x y)\"\n              \"eexp (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z) \\<le> esqrt (extended_Gromov_distance y z)\""], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> esqrt (extended_Gromov_distance x y)\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n  \\<le> esqrt (extended_Gromov_distance y z)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>First, check that $\\epsilon$ and $\\delta$ satisfy the required inequality\n    $\\exp(\\epsilon \\delta) \\leq \\sqrt{2}$ (but in the extended reals as this is what we will use.\\<close>"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> esqrt (extended_Gromov_distance x y)\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n  \\<le> esqrt (extended_Gromov_distance y z)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have B: \"eexp (epsilonG(TYPE('a)) * deltaG(TYPE('a))) \\<le> esqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) \\<le> esqrt 2", "unfolding epsilonG_def \\<open>esqrt 2 = eexp (ereal(ln 2/2))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (ereal (ln 2 / (2 + 2 * deltaG TYPE('a)) * deltaG TYPE('a)))\n    \\<le> eexp (ereal (ln 2 / 2))", "apply (auto simp add: algebra_simps divide_simps intro!: mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + deltaG TYPE('a) * 2 < 0 \\<Longrightarrow> False", "using delta_nonneg[where ?'a = 'a]"], ["proof (prove)\nusing this:\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. 2 + deltaG TYPE('a) * 2 < 0 \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) \\<le> esqrt 2\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>We start the computation. First, use the hyperbolicity inequality.\\<close>"], ["proof (state)\nthis:\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) \\<le> esqrt 2\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"eexp (- epsilonG TYPE('a) * extended_Gromov_product_at basepoint x z)\n      \\<le> eexp (- epsilonG TYPE('a) * ((min (extended_Gromov_product_at basepoint x y) (extended_Gromov_product_at basepoint y z) - deltaG(TYPE('a)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x z)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            (min (extended_Gromov_product_at basepoint x y)\n              (extended_Gromov_product_at basepoint y z) -\n             ereal (deltaG TYPE('a))))", "apply (subst uminus_ereal.simps(1)[symmetric], subst ereal_mult_minus_left)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (- (ereal (epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint x z))\n    \\<le> eexp\n           (- (ereal (epsilonG TYPE('a)) *\n               (min (extended_Gromov_product_at basepoint x y)\n                 (extended_Gromov_product_at basepoint y z) -\n                ereal (deltaG TYPE('a)))))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          (min (extended_Gromov_product_at basepoint x y)\n            (extended_Gromov_product_at basepoint y z) -\n           ereal (deltaG TYPE('a))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>Use distributivity to isolate the term $\\epsilon \\delta$. This requires some care\n    as multiplication is not distributive in general in ereal.\\<close>"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          (min (extended_Gromov_product_at basepoint x y)\n            (extended_Gromov_product_at basepoint y z) -\n           ereal (deltaG TYPE('a))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          (min (extended_Gromov_product_at basepoint x y)\n            (extended_Gromov_product_at basepoint y z) -\n           ereal (deltaG TYPE('a))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... = eexp (- epsilonG TYPE('a) * min (extended_Gromov_product_at basepoint x y) (extended_Gromov_product_at basepoint y z)\n            + epsilonG TYPE('a) * deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      (min (extended_Gromov_product_at basepoint x y)\n        (extended_Gromov_product_at basepoint y z) -\n       ereal (deltaG TYPE('a)))) =\n    eexp\n     (ereal (- epsilonG TYPE('a)) *\n      min (extended_Gromov_product_at basepoint x y)\n       (extended_Gromov_product_at basepoint y z) +\n      ereal (epsilonG TYPE('a) * deltaG TYPE('a)))", "apply (rule cong[of eexp], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (- epsilonG TYPE('a)) *\n    (min (extended_Gromov_product_at basepoint x y)\n      (extended_Gromov_product_at basepoint y z) -\n     ereal (deltaG TYPE('a))) =\n    ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a))", "apply (subst times_ereal.simps(1)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (- epsilonG TYPE('a)) *\n    (min (extended_Gromov_product_at basepoint x y)\n      (extended_Gromov_product_at basepoint y z) -\n     ereal (deltaG TYPE('a))) =\n    ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a)) * ereal (deltaG TYPE('a))", "apply (subst ereal_distrib_minus_left, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) -\n    ereal (- (epsilonG TYPE('a) * deltaG TYPE('a))) =\n    ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a))", "apply (subst uminus_ereal.simps(1)[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. - ereal (epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) -\n    - ereal (epsilonG TYPE('a) * deltaG TYPE('a)) =\n    - ereal (epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a))", "apply (subst ereal_minus(6))"], ["proof (prove)\ngoal (1 subgoal):\n 1. - ereal (epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a)) =\n    - ereal (epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a))", "by simp"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    (min (extended_Gromov_product_at basepoint x y)\n      (extended_Gromov_product_at basepoint y z) -\n     ereal (deltaG TYPE('a)))) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>Use multiplicativity of exponential to extract the multiplicative error factor.\\<close>"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    (min (extended_Gromov_product_at basepoint x y)\n      (extended_Gromov_product_at basepoint y z) -\n     ereal (deltaG TYPE('a)))) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    (min (extended_Gromov_product_at basepoint x y)\n      (extended_Gromov_product_at basepoint y z) -\n     ereal (deltaG TYPE('a)))) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... = eexp(- epsilonG TYPE('a) * (min (extended_Gromov_product_at basepoint x y) (extended_Gromov_product_at basepoint y z)))\n                    * eexp(epsilonG(TYPE('a))* deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      min (extended_Gromov_product_at basepoint x y)\n       (extended_Gromov_product_at basepoint y z) +\n      ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n    eexp\n     (ereal (- epsilonG TYPE('a)) *\n      min (extended_Gromov_product_at basepoint x y)\n       (extended_Gromov_product_at basepoint y z)) *\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a)))", "by (rule eexp_add_mult, auto)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z)) *\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>Extract the min outside of the exponential, using that all functions are monotonic.\\<close>"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z)) *\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z) +\n    ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z)) *\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... = eexp(epsilonG(TYPE('a))* deltaG(TYPE('a)))\n                    * (max (eexp(- epsilonG TYPE('a) * extended_Gromov_product_at basepoint x y))\n                            (eexp(- epsilonG TYPE('a) * extended_Gromov_product_at basepoint y z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      min (extended_Gromov_product_at basepoint x y)\n       (extended_Gromov_product_at basepoint y z)) *\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z))", "apply (subst max_of_antimono[of \"\\<lambda> (t::ereal). -epsilonG TYPE('a) * t\", symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. antimono ((*) (ereal (- epsilonG TYPE('a))))\n 2. eexp\n     (max (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y)\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z)) *\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z))", "apply (metis antimonoI constant_in_extended_predist_pos(2) enn2ereal_ennreal enn2ereal_nonneg ereal_minus_le_minus ereal_mult_left_mono ereal_mult_minus_left uminus_ereal.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (max (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y)\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z)) *\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z))", "apply (subst max_of_mono[OF eexp_mono])"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (max (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y)\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z)) *\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    eexp\n     (max (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y)\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z))", "apply (simp add: mult.commute)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z)) *\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n  max (eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>We recognize the distance of $x$ to $y$ and the distance from $y$ to $z$ on the right.\\<close>"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z)) *\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n  max (eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    min (extended_Gromov_product_at basepoint x y)\n     (extended_Gromov_product_at basepoint y z)) *\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) =\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n  max (eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... = eexp(epsilonG(TYPE('a)) * deltaG(TYPE('a))) * (max (ereal (extended_predist x y)) (extended_predist y z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z)) =\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "unfolding extended_predist_ereal min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z)) =\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (if esqrt (extended_Gromov_distance x y)\n            \\<le> eexp\n                   (ereal (- epsilonG TYPE('a)) *\n                    extended_Gromov_product_at basepoint x y)\n         then esqrt (extended_Gromov_distance x y)\n         else eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x y))\n     (if esqrt (extended_Gromov_distance y z)\n         \\<le> eexp\n                (ereal (- epsilonG TYPE('a)) *\n                 extended_Gromov_product_at basepoint y z)\n      then esqrt (extended_Gromov_distance y z)\n      else eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z))", "using H"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> esqrt (extended_Gromov_distance x y)\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n  \\<le> esqrt (extended_Gromov_distance y z)\n\ngoal (1 subgoal):\n 1. eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint y z)) =\n    eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (if esqrt (extended_Gromov_distance x y)\n            \\<le> eexp\n                   (ereal (- epsilonG TYPE('a)) *\n                    extended_Gromov_product_at basepoint x y)\n         then esqrt (extended_Gromov_distance x y)\n         else eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x y))\n     (if esqrt (extended_Gromov_distance y z)\n         \\<le> eexp\n                (ereal (- epsilonG TYPE('a)) *\n                 extended_Gromov_product_at basepoint y z)\n      then esqrt (extended_Gromov_distance y z)\n      else eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z))", "by auto"], ["proof (state)\nthis:\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n  max (eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z)) =\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n  max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n  max (eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z)) =\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n  max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> esqrt 2 * max (ereal(extended_predist x y)) (ereal(extended_predist y z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n    max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n    \\<le> esqrt 2 *\n          max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "apply (intro mono_intros B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> max (ereal (extended_predist x y))\n             (ereal (extended_predist y z))", "using extended_predist_nonneg[of x y]"], ["proof (prove)\nusing this:\n  0 \\<le> extended_predist x y\n\ngoal (1 subgoal):\n 1. 0 \\<le> max (ereal (extended_predist x y))\n             (ereal (extended_predist y z))", "by (simp add: max_def)"], ["proof (state)\nthis:\n  eexp (ereal (epsilonG TYPE('a) * deltaG TYPE('a))) *\n  max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n  \\<le> esqrt 2 *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 3. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "finally"], ["proof (chain)\npicking this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> esqrt 2 *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "show ?thesis"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> esqrt 2 *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (1 subgoal):\n 1. ereal (extended_predist x z)\n    \\<le> ereal (sqrt 2) *\n          max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "unfolding extended_predist_ereal min_def"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> esqrt 2 *\n        max (if esqrt (extended_Gromov_distance x y)\n                \\<le> eexp\n                       (ereal (- epsilonG TYPE('a)) *\n                        extended_Gromov_product_at basepoint x y)\n             then esqrt (extended_Gromov_distance x y)\n             else eexp\n                   (ereal (- epsilonG TYPE('a)) *\n                    extended_Gromov_product_at basepoint x y))\n         (if esqrt (extended_Gromov_distance y z)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint y z)\n          then esqrt (extended_Gromov_distance y z)\n          else eexp\n                (ereal (- epsilonG TYPE('a)) *\n                 extended_Gromov_product_at basepoint y z))\n\ngoal (1 subgoal):\n 1. (if esqrt (extended_Gromov_distance x z)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x z)\n     then esqrt (extended_Gromov_distance x z)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x z))\n    \\<le> ereal (sqrt 2) *\n          max (if esqrt (extended_Gromov_distance x y)\n                  \\<le> eexp\n                         (ereal (- epsilonG TYPE('a)) *\n                          extended_Gromov_product_at basepoint x y)\n               then esqrt (extended_Gromov_distance x y)\n               else eexp\n                     (ereal (- epsilonG TYPE('a)) *\n                      extended_Gromov_product_at basepoint x y))\n           (if esqrt (extended_Gromov_distance y z)\n               \\<le> eexp\n                      (ereal (- epsilonG TYPE('a)) *\n                       extended_Gromov_product_at basepoint y z)\n            then esqrt (extended_Gromov_distance y z)\n            else eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint y z))", "by auto"], ["proof (state)\nthis:\n  ereal (extended_predist x z)\n  \\<le> ereal (sqrt 2) *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>Next consider the case where $d(x,y)$ comes from the exponential of minus the Gromov product,\n    but $d(y,z)$ comes from their extended distance. Then $d(y,z) \\leq 1$ (as $d(y,z)$ is smaller\n    then the exponential of minus the Gromov distance, which is at most $1$), and this is all we use:\n    the Gromov product between $x$ and $y$ or $x$ and $z$ differ by at most the distance from $y$ to $z$,\n    i.e., $1$. Then the result follows directly as $\\exp(\\epsilon) \\leq \\sqrt{2}$, by the choice of\n    $\\epsilon$.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "assume H: \"eexp (- epsilonG TYPE('a) * extended_Gromov_product_at basepoint x y) \\<le> esqrt (extended_Gromov_distance x y)\"\n              \"esqrt (extended_Gromov_distance y z) \\<le> eexp (- epsilonG TYPE('a) * extended_Gromov_product_at basepoint y z)\""], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> esqrt (extended_Gromov_distance x y)\n  esqrt (extended_Gromov_distance y z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "then"], ["proof (chain)\npicking this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> esqrt (extended_Gromov_distance x y)\n  esqrt (extended_Gromov_distance y z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z)", "have \"esqrt(extended_Gromov_distance y z) \\<le> 1\""], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> esqrt (extended_Gromov_distance x y)\n  esqrt (extended_Gromov_distance y z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance y z) \\<le> 1", "by (auto intro!: order_trans[OF H(2)] simp add: ereal_mult_le_0_iff)"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance y z) \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "then"], ["proof (chain)\npicking this:\n  esqrt (extended_Gromov_distance y z) \\<le> 1", "have \"extended_Gromov_distance y z \\<le> 1\""], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance y z) \\<le> 1\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance y z \\<le> 1", "by (metis eq_iff esqrt_mono2 esqrt_simps(2) esqrt_square extended_Gromov_distance_nonneg le_cases zero_less_one_ereal)"], ["proof (state)\nthis:\n  extended_Gromov_distance y z \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"ereal(extended_predist x z) \\<le> eexp(- epsilonG TYPE('a) * extended_Gromov_product_at basepoint x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (extended_predist x z)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x z)", "unfolding extended_predist_ereal min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if esqrt (extended_Gromov_distance x z)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x z)\n     then esqrt (extended_Gromov_distance x z)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x z))\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x z)", "by auto"], ["proof (state)\nthis:\n  ereal (extended_predist x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x z)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  ereal (extended_predist x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x z)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> eexp(- epsilonG TYPE('a) * extended_Gromov_product_at basepoint x y\n                          + epsilonG TYPE('a) * extended_Gromov_distance y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x z)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y +\n            ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z\n    \\<le> ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z", "apply (subst uminus_ereal.simps(1)[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. - ereal (epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z\n    \\<le> - ereal (epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z", "apply (subst ereal_mult_minus_left)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (ereal (epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n    \\<le> - (ereal (epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint x y) +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y\n    \\<le> ereal (epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x z +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z", "using extended_Gromov_product_at_diff3[of basepoint x y z]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at basepoint x y\n  \\<le> extended_Gromov_product_at basepoint x z +\n        extended_Gromov_distance y z\n\ngoal (1 subgoal):\n 1. ereal (epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y\n    \\<le> ereal (epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x z +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z", "by (meson constant_in_extended_predist_pos(2) ereal_le_distrib ereal_mult_left_mono order_trans zero_le_ereal)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> eexp(-epsilonG TYPE('a) * extended_Gromov_product_at basepoint x y + ereal(epsilonG TYPE('a)) * 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y +\n      ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y +\n            ereal (epsilonG TYPE('a)) * 1)", "by (intro mono_intros, fact)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y +\n    ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y +\n          ereal (epsilonG TYPE('a)) * 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y +\n    ereal (epsilonG TYPE('a)) * extended_Gromov_distance y z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y +\n          ereal (epsilonG TYPE('a)) * 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... = eexp(-epsilonG TYPE('a) * extended_Gromov_product_at basepoint x y) * eexp(ereal(epsilonG TYPE('a)) * 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y +\n      ereal (epsilonG TYPE('a)) * 1) =\n    eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) *\n    eexp (ereal (epsilonG TYPE('a)) * 1)", "by (rule eexp_add_mult, auto)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y +\n    ereal (epsilonG TYPE('a)) * 1) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) *\n  eexp (ereal (epsilonG TYPE('a)) * 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y +\n    ereal (epsilonG TYPE('a)) * 1) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) *\n  eexp (ereal (epsilonG TYPE('a)) * 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> eexp(-epsilonG TYPE('a) * extended_Gromov_product_at basepoint x y) * esqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) *\n    eexp (ereal (epsilonG TYPE('a)) * 1)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) *\n          esqrt 2", "by (intro mono_intros A)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) *\n  eexp (ereal (epsilonG TYPE('a)) * 1)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y) *\n        esqrt 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) *\n  eexp (ereal (epsilonG TYPE('a)) * 1)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y) *\n        esqrt 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... = esqrt 2 * ereal(extended_predist x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) *\n    esqrt 2 =\n    esqrt 2 * ereal (extended_predist x y)", "unfolding extended_predist_ereal min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) *\n    esqrt 2 =\n    esqrt 2 *\n    (if esqrt (extended_Gromov_distance x y)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x y)\n     then esqrt (extended_Gromov_distance x y)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y))", "using H"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> esqrt (extended_Gromov_distance x y)\n  esqrt (extended_Gromov_distance y z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z)\n\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y) *\n    esqrt 2 =\n    esqrt 2 *\n    (if esqrt (extended_Gromov_distance x y)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x y)\n     then esqrt (extended_Gromov_distance x y)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y))", "by (auto simp add: mult.commute)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) *\n  esqrt 2 =\n  esqrt 2 * ereal (extended_predist x y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint x y) *\n  esqrt 2 =\n  esqrt 2 * ereal (extended_predist x y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> esqrt 2 * max (ereal(extended_predist x y)) (ereal(extended_predist y z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt 2 * ereal (extended_predist x y)\n    \\<le> esqrt 2 *\n          max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "unfolding max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt 2 * ereal (extended_predist x y)\n    \\<le> esqrt 2 *\n          (if ereal (extended_predist x y)\n              \\<le> ereal (extended_predist y z)\n           then ereal (extended_predist y z)\n           else ereal (extended_predist x y))", "by (auto intro!: mono_intros)"], ["proof (state)\nthis:\n  esqrt 2 * ereal (extended_predist x y)\n  \\<le> esqrt 2 *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))\n 2. \\<lbrakk>eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y)\n             \\<le> esqrt (extended_Gromov_distance x y);\n     esqrt (extended_Gromov_distance y z)\n     \\<le> eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "finally"], ["proof (chain)\npicking this:\n  ereal (extended_predist x z)\n  \\<le> esqrt 2 *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal (extended_predist x z)\n  \\<le> esqrt 2 *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (1 subgoal):\n 1. ereal (extended_predist x z)\n    \\<le> ereal (sqrt 2) *\n          max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "by auto"], ["proof (state)\nthis:\n  ereal (extended_predist x z)\n  \\<le> ereal (sqrt 2) *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "text \\<open>The last case is the symmetric of the previous one, and is proved similarly.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "assume H: \"eexp (- epsilonG TYPE('a) * extended_Gromov_product_at basepoint y z) \\<le> esqrt (extended_Gromov_distance y z)\"\n              \"esqrt (extended_Gromov_distance x y) \\<le> eexp (- epsilonG TYPE('a) * extended_Gromov_product_at basepoint x y)\""], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n  \\<le> esqrt (extended_Gromov_distance y z)\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "then"], ["proof (chain)\npicking this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n  \\<le> esqrt (extended_Gromov_distance y z)\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)", "have \"esqrt(extended_Gromov_distance x y) \\<le> 1\""], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n  \\<le> esqrt (extended_Gromov_distance y z)\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 1", "by (auto intro!: order_trans[OF H(2)] simp add: ereal_mult_le_0_iff)"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x y) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "then"], ["proof (chain)\npicking this:\n  esqrt (extended_Gromov_distance x y) \\<le> 1", "have \"extended_Gromov_distance x y \\<le> 1\""], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x y) \\<le> 1\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y \\<le> 1", "by (metis eq_iff esqrt_mono2 esqrt_simps(2) esqrt_square extended_Gromov_distance_nonneg le_cases zero_less_one_ereal)"], ["proof (state)\nthis:\n  extended_Gromov_distance x y \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"ereal(extended_predist x z) \\<le> eexp(- epsilonG TYPE('a) * extended_Gromov_product_at basepoint x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (extended_predist x z)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x z)", "unfolding extended_predist_ereal min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if esqrt (extended_Gromov_distance x z)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint x z)\n     then esqrt (extended_Gromov_distance x z)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x z))\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x z)", "by auto"], ["proof (state)\nthis:\n  ereal (extended_predist x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  ereal (extended_predist x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> eexp(- epsilonG TYPE('a) * extended_Gromov_product_at basepoint y z\n                          + epsilonG TYPE('a) * extended_Gromov_distance x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x z)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint y z +\n            ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z\n    \\<le> ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y", "apply (subst uminus_ereal.simps(1)[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. - ereal (epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z\n    \\<le> - ereal (epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y", "apply (subst ereal_mult_minus_left)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (ereal (epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n    \\<le> - (ereal (epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint y z) +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z\n    \\<le> ereal (epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x z +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y", "using extended_Gromov_product_at_diff3[of basepoint z y x]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at basepoint z y\n  \\<le> extended_Gromov_product_at basepoint z x +\n        extended_Gromov_distance y x\n\ngoal (1 subgoal):\n 1. ereal (epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z\n    \\<le> ereal (epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x z +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y", "apply (simp add: extended_Gromov_product_at_commute extended_Gromov_distance_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint y z\n    \\<le> extended_Gromov_product_at basepoint x z +\n          extended_Gromov_distance x y \\<Longrightarrow>\n    ereal (epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z\n    \\<le> ereal (epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x z +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y", "by (meson constant_in_extended_predist_pos(2) ereal_le_distrib ereal_mult_left_mono order_trans zero_le_ereal)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x z)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z +\n          ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> eexp(-epsilonG TYPE('a) * extended_Gromov_product_at basepoint y z + ereal(epsilonG TYPE('a)) * 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z +\n      ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint y z +\n            ereal (epsilonG TYPE('a)) * 1)", "by (intro mono_intros, fact)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z +\n    ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z +\n          ereal (epsilonG TYPE('a)) * 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z +\n    ereal (epsilonG TYPE('a)) * extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z +\n          ereal (epsilonG TYPE('a)) * 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... = eexp(-epsilonG TYPE('a) * extended_Gromov_product_at basepoint y z) * eexp(ereal(epsilonG TYPE('a)) * 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z +\n      ereal (epsilonG TYPE('a)) * 1) =\n    eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z) *\n    eexp (ereal (epsilonG TYPE('a)) * 1)", "by (rule eexp_add_mult, auto)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z +\n    ereal (epsilonG TYPE('a)) * 1) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint y z) *\n  eexp (ereal (epsilonG TYPE('a)) * 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z +\n    ereal (epsilonG TYPE('a)) * 1) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint y z) *\n  eexp (ereal (epsilonG TYPE('a)) * 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> eexp(-epsilonG TYPE('a) * extended_Gromov_product_at basepoint y z) * esqrt 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z) *\n    eexp (ereal (epsilonG TYPE('a)) * 1)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint y z) *\n          esqrt 2", "by (intro mono_intros A)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint y z) *\n  eexp (ereal (epsilonG TYPE('a)) * 1)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z) *\n        esqrt 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint y z) *\n  eexp (ereal (epsilonG TYPE('a)) * 1)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint y z) *\n        esqrt 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... = esqrt 2 * ereal(extended_predist y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z) *\n    esqrt 2 =\n    esqrt 2 * ereal (extended_predist y z)", "unfolding extended_predist_ereal min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z) *\n    esqrt 2 =\n    esqrt 2 *\n    (if esqrt (extended_Gromov_distance y z)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint y z)\n     then esqrt (extended_Gromov_distance y z)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint y z))", "using H"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint y z)\n  \\<le> esqrt (extended_Gromov_distance y z)\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint y z) *\n    esqrt 2 =\n    esqrt 2 *\n    (if esqrt (extended_Gromov_distance y z)\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint y z)\n     then esqrt (extended_Gromov_distance y z)\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint y z))", "by (auto simp add: mult.commute)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint y z) *\n  esqrt 2 =\n  esqrt 2 * ereal (extended_predist y z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint y z) *\n  esqrt 2 =\n  esqrt 2 * ereal (extended_predist y z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "have \"... \\<le> esqrt 2 * max (ereal(extended_predist x y)) (ereal(extended_predist y z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt 2 * ereal (extended_predist y z)\n    \\<le> esqrt 2 *\n          max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "unfolding max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt 2 * ereal (extended_predist y z)\n    \\<le> esqrt 2 *\n          (if ereal (extended_predist x y)\n              \\<le> ereal (extended_predist y z)\n           then ereal (extended_predist y z)\n           else ereal (extended_predist x y))", "by (auto intro!: mono_intros)"], ["proof (state)\nthis:\n  esqrt 2 * ereal (extended_predist y z)\n  \\<le> esqrt 2 *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>esqrt (extended_Gromov_distance x y)\n             \\<le> eexp\n                    (ereal (- epsilonG TYPE('a)) *\n                     extended_Gromov_product_at basepoint x y);\n     eexp\n      (ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint y z)\n     \\<le> esqrt (extended_Gromov_distance y z)\\<rbrakk>\n    \\<Longrightarrow> ereal (extended_predist x z)\n                      \\<le> ereal (sqrt 2) *\n                            max (ereal (extended_predist x y))\n                             (ereal (extended_predist y z))", "finally"], ["proof (chain)\npicking this:\n  ereal (extended_predist x z)\n  \\<le> esqrt 2 *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal (extended_predist x z)\n  \\<le> esqrt 2 *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (1 subgoal):\n 1. ereal (extended_predist x z)\n    \\<le> ereal (sqrt 2) *\n          max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "by auto"], ["proof (state)\nthis:\n  ereal (extended_predist x z)\n  \\<le> ereal (sqrt 2) *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ereal (extended_predist x z)\n  \\<le> ereal (sqrt 2) *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (1 subgoal):\n 1. extended_predist x z\n    \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)", "then"], ["proof (chain)\npicking this:\n  ereal (extended_predist x z)\n  \\<le> ereal (sqrt 2) *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))", "show \"extended_predist x z \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)\""], ["proof (prove)\nusing this:\n  ereal (extended_predist x z)\n  \\<le> ereal (sqrt 2) *\n        max (ereal (extended_predist x y)) (ereal (extended_predist y z))\n\ngoal (1 subgoal):\n 1. extended_predist x z\n    \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)", "unfolding ereal_sqrt2[symmetric] max_of_mono[OF ereal_mono] times_ereal.simps(1)"], ["proof (prove)\nusing this:\n  ereal (extended_predist x z)\n  \\<le> ereal (sqrt 2 * max (extended_predist x y) (extended_predist y z))\n\ngoal (1 subgoal):\n 1. extended_predist x z\n    \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)", "by auto"], ["proof (state)\nthis:\n  extended_predist x z\n  \\<le> sqrt 2 * max (extended_predist x y) (extended_predist y z)\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation Gromov_completion :: (Gromov_hyperbolic_space) metric_space\nbegin"], ["", "definition dist_Gromov_completion::\"('a::Gromov_hyperbolic_space) Gromov_completion \\<Rightarrow> 'a Gromov_completion \\<Rightarrow> real\"\n  where \"dist_Gromov_completion = turn_into_distance extended_predist\""], ["", "text \\<open>To define a metric space in the current library of Isabelle/HOL, one should also introduce\na uniformity structure and a topology, as follows (they are prescribed by the distance):\\<close>"], ["", "definition uniformity_Gromov_completion::\"(('a Gromov_completion) \\<times> ('a Gromov_completion)) filter\"\n  where \"uniformity_Gromov_completion = (INF e\\<in>{0 <..}. principal {(x, y). dist x y < e})\""], ["", "definition open_Gromov_completion :: \"'a Gromov_completion set \\<Rightarrow> bool\"\n  where \"open_Gromov_completion U = (\\<forall>x\\<in>U. eventually (\\<lambda>(x', y). x' = x \\<longrightarrow> y \\<in> U) uniformity)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Gromov_completion, metric_space_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y. (dist x y = 0) = (x = y)\n 4. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "interpret Turn_into_distance extended_predist"], ["proof (prove)\ngoal (1 subgoal):\n 1. Turn_into_distance extended_predist", "by (standard, auto intro: extended_predist_weak_triangle extended_predist_commute)"], ["proof (state)\ngoal (4 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y. (dist x y = 0) = (x = y)\n 4. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "fix x y z::\"'a Gromov_completion\""], ["proof (state)\ngoal (4 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y. (dist x y = 0) = (x = y)\n 4. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "show \"(dist x y = 0) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist x y = 0) = (x = y)", "using TID_nonneg[of x y] lower[of x y] TID_self_zero upper[of x y] extended_predist_self0[of x y]"], ["proof (prove)\nusing this:\n  0 \\<le> turn_into_distance extended_predist x y\n  extended_predist x y \\<le> 2 * turn_into_distance extended_predist x y\n  turn_into_distance extended_predist ?x ?x = 0\n  turn_into_distance extended_predist x y \\<le> extended_predist x y\n  (extended_predist x y = 0) = (x = y)\n\ngoal (1 subgoal):\n 1. (dist x y = 0) = (x = y)", "unfolding dist_Gromov_completion_def"], ["proof (prove)\nusing this:\n  0 \\<le> turn_into_distance extended_predist x y\n  extended_predist x y \\<le> 2 * turn_into_distance extended_predist x y\n  turn_into_distance extended_predist ?x ?x = 0\n  turn_into_distance extended_predist x y \\<le> extended_predist x y\n  (extended_predist x y = 0) = (x = y)\n\ngoal (1 subgoal):\n 1. (turn_into_distance extended_predist x y = 0) = (x = y)", "by (auto, linarith)"], ["proof (state)\nthis:\n  (dist x y = 0) = (x = y)\n\ngoal (3 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 3. \\<And>x y z. dist x y \\<le> dist x z + dist y z", "show \"dist x y \\<le> dist x z + dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y \\<le> dist x z + dist y z", "unfolding dist_Gromov_completion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. turn_into_distance extended_predist x y\n    \\<le> turn_into_distance extended_predist x z +\n          turn_into_distance extended_predist y z", "using triangle"], ["proof (prove)\nusing this:\n  turn_into_distance extended_predist ?x ?z\n  \\<le> turn_into_distance extended_predist ?x ?y +\n        turn_into_distance extended_predist ?y ?z\n\ngoal (1 subgoal):\n 1. turn_into_distance extended_predist x y\n    \\<le> turn_into_distance extended_predist x z +\n          turn_into_distance extended_predist y z", "by (simp add: TID_sym)"], ["proof (state)\nthis:\n  dist x y \\<le> dist x z + dist y z\n\ngoal (2 subgoals):\n 1. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 2. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)", "qed (auto simp add: uniformity_Gromov_completion_def open_Gromov_completion_def)"], ["", "end"], ["", "text \\<open>The only relevant property of the distance on the Gromov completion is that it is comparable\nto the minimum of (the square root of) the extended distance, and the exponential of minus the Gromov\nproduct. The precise formula we use to define it is just an implementation detail, in a sense.\nWe summarize these properties in the next theorem.\nFrom this point on, we will only use this, and never come back to the definition based on\n\\verb+extended_predist+ and \\verb+turn_into_distance+.\\<close>"], ["", "theorem Gromov_completion_dist_comparison [mono_intros]:\n  fixes x y::\"('a::Gromov_hyperbolic_space) Gromov_completion\"\n  shows \"ereal(dist x y) \\<le> esqrt(extended_Gromov_distance x y)\"\n        \"ereal(dist x y) \\<le> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)\"\n        \"min (esqrt(extended_Gromov_distance x y)) (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)) \\<le> 2 * ereal(dist x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y) \\<le> esqrt (extended_Gromov_distance x y) &&&\n    ereal (dist x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) &&&\n    min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. ereal (dist x y) \\<le> esqrt (extended_Gromov_distance x y)\n 2. ereal (dist x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y)\n 3. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "interpret Turn_into_distance extended_predist"], ["proof (prove)\ngoal (1 subgoal):\n 1. Turn_into_distance extended_predist", "by (standard, auto intro: extended_predist_weak_triangle extended_predist_commute)"], ["proof (state)\ngoal (3 subgoals):\n 1. ereal (dist x y) \\<le> esqrt (extended_Gromov_distance x y)\n 2. ereal (dist x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y)\n 3. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "have \"ereal(dist x y) \\<le> ereal(extended_predist x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y) \\<le> ereal (extended_predist x y)", "unfolding dist_Gromov_completion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (turn_into_distance extended_predist x y)\n    \\<le> ereal (extended_predist x y)", "by (auto intro!: upper mono_intros)"], ["proof (state)\nthis:\n  ereal (dist x y) \\<le> ereal (extended_predist x y)\n\ngoal (3 subgoals):\n 1. ereal (dist x y) \\<le> esqrt (extended_Gromov_distance x y)\n 2. ereal (dist x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y)\n 3. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "then"], ["proof (chain)\npicking this:\n  ereal (dist x y) \\<le> ereal (extended_predist x y)", "show \"ereal(dist x y) \\<le> esqrt(extended_Gromov_distance x y)\"\n            \"ereal(dist x y) \\<le> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)\""], ["proof (prove)\nusing this:\n  ereal (dist x y) \\<le> ereal (extended_predist x y)\n\ngoal (1 subgoal):\n 1. ereal (dist x y) \\<le> esqrt (extended_Gromov_distance x y) &&&\n    ereal (dist x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y)", "unfolding extended_predist_ereal"], ["proof (prove)\nusing this:\n  ereal (dist x y)\n  \\<le> min (esqrt (extended_Gromov_distance x y))\n         (eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y))\n\ngoal (1 subgoal):\n 1. ereal (dist x y) \\<le> esqrt (extended_Gromov_distance x y) &&&\n    ereal (dist x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y)", "by auto"], ["proof (state)\nthis:\n  ereal (dist x y) \\<le> esqrt (extended_Gromov_distance x y)\n  ereal (dist x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "have \"ereal(extended_predist x y) \\<le> ereal(2 * dist x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (extended_predist x y) \\<le> ereal (2 * dist x y)", "unfolding dist_Gromov_completion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (extended_predist x y)\n    \\<le> ereal (2 * turn_into_distance extended_predist x y)", "by (auto intro!: lower mono_intros)"], ["proof (state)\nthis:\n  ereal (extended_predist x y) \\<le> ereal (2 * dist x y)\n\ngoal (1 subgoal):\n 1. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "also"], ["proof (state)\nthis:\n  ereal (extended_predist x y) \\<le> ereal (2 * dist x y)\n\ngoal (1 subgoal):\n 1. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "have \"... = 2 * ereal (dist x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (2 * dist x y) = 2 * ereal (dist x y)", "by simp"], ["proof (state)\nthis:\n  ereal (2 * dist x y) = 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "finally"], ["proof (chain)\npicking this:\n  ereal (extended_predist x y) \\<le> 2 * ereal (dist x y)", "show \"min (esqrt(extended_Gromov_distance x y)) (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)) \\<le> 2 * ereal(dist x y)\""], ["proof (prove)\nusing this:\n  ereal (extended_predist x y) \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "unfolding extended_predist_ereal"], ["proof (prove)\nusing this:\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. min (esqrt (extended_Gromov_distance x y))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint x y))\n    \\<le> 2 * ereal (dist x y)", "by auto"], ["proof (state)\nthis:\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 2 * ereal (dist x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gromov_completion_dist_le_1 [simp, mono_intros]:\n  fixes x y::\"('a::Gromov_hyperbolic_space) Gromov_completion\"\n  shows \"dist x y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist x y \\<le> 1", "have \"ereal(dist x y) \\<le> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y)", "using Gromov_completion_dist_comparison(2)[of x y]"], ["proof (prove)\nusing this:\n  ereal (dist x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. ereal (dist x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y)", "by simp"], ["proof (state)\nthis:\n  ereal (dist x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. dist x y \\<le> 1", "also"], ["proof (state)\nthis:\n  ereal (dist x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. dist x y \\<le> 1", "have \"... \\<le> eexp(-0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y)\n    \\<le> eexp (- 0)", "by (intro mono_intros) (simp add: ereal_mult_le_0_iff)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp (- 0)\n\ngoal (1 subgoal):\n 1. dist x y \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  ereal (dist x y) \\<le> eexp (- 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal (dist x y) \\<le> eexp (- 0)\n\ngoal (1 subgoal):\n 1. dist x y \\<le> 1", "by auto"], ["proof (state)\nthis:\n  dist x y \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>To avoid computations with exponentials, the following lemma is very convenient. It asserts\nthat if $x$ is close enough to infinity, and $y$ is close enough to $x$, then the Gromov product\nbetween $x$ and $y$ is large.\\<close>"], ["", "lemma large_Gromov_product_approx:\n  assumes \"(M::ereal) < \\<infinity>\"\n  shows \"\\<exists>e D. e > 0 \\<and> D < \\<infinity> \\<and> (\\<forall>x y. dist x y \\<le> e \\<longrightarrow> extended_Gromov_distance x (to_Gromov_completion basepoint) \\<ge> D \\<longrightarrow> extended_Gromov_product_at basepoint x y \\<ge> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "obtain M0::real where \"M \\<le> ereal M0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M0. M \\<le> ereal M0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  M < \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>M0. M \\<le> ereal M0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases M, auto)"], ["proof (state)\nthis:\n  M \\<le> ereal M0\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "define e::real where \"e = exp(-epsilonG(TYPE('a)) * M0)/2\""], ["proof (state)\nthis:\n  e = exp (- epsilonG TYPE('a) * M0) / 2\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "define D::ereal where \"D = ereal M0 + 4\""], ["proof (state)\nthis:\n  D = ereal M0 + 4\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "have \"e > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < exp (- epsilonG TYPE('a) * M0) / 2", "by auto"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "moreover"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "have \"D < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D < \\<infinity>", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M0 + 4 < \\<infinity>", "by auto"], ["proof (state)\nthis:\n  D < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "moreover"], ["proof (state)\nthis:\n  D < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "have \"extended_Gromov_product_at basepoint x y \\<ge> M0\"\n    if \"dist x y \\<le> e\" \"extended_Gromov_distance x (to_Gromov_completion basepoint) \\<ge> D\" for x y::\"'a Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "proof (cases \"esqrt(extended_Gromov_distance x y) \\<le> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n 2. \\<not> esqrt (extended_Gromov_distance x y)\n           \\<le> eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint x\n                    y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "case False"], ["proof (state)\nthis:\n  \\<not> esqrt (extended_Gromov_distance x y)\n         \\<le> eexp\n                (ereal (- epsilonG TYPE('a)) *\n                 extended_Gromov_product_at basepoint x y)\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n 2. \\<not> esqrt (extended_Gromov_distance x y)\n           \\<le> eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint x\n                    y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "then"], ["proof (chain)\npicking this:\n  \\<not> esqrt (extended_Gromov_distance x y)\n         \\<le> eexp\n                (ereal (- epsilonG TYPE('a)) *\n                 extended_Gromov_product_at basepoint x y)", "have \"eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y) \\<le> 2 * ereal(dist x y)\""], ["proof (prove)\nusing this:\n  \\<not> esqrt (extended_Gromov_distance x y)\n         \\<le> eexp\n                (ereal (- epsilonG TYPE('a)) *\n                 extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y)\n    \\<le> 2 * ereal (dist x y)", "using Gromov_completion_dist_comparison(3)[of x y]"], ["proof (prove)\nusing this:\n  \\<not> esqrt (extended_Gromov_distance x y)\n         \\<le> eexp\n                (ereal (- epsilonG TYPE('a)) *\n                 extended_Gromov_product_at basepoint x y)\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y)\n    \\<le> 2 * ereal (dist x y)", "unfolding min_def"], ["proof (prove)\nusing this:\n  \\<not> esqrt (extended_Gromov_distance x y)\n         \\<le> eexp\n                (ereal (- epsilonG TYPE('a)) *\n                 extended_Gromov_product_at basepoint x y)\n  (if esqrt (extended_Gromov_distance x y)\n      \\<le> eexp\n             (ereal (- epsilonG TYPE('a)) *\n              extended_Gromov_product_at basepoint x y)\n   then esqrt (extended_Gromov_distance x y)\n   else eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y))\n  \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y)\n    \\<le> 2 * ereal (dist x y)", "by auto"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> 2 * ereal (dist x y)\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n 2. \\<not> esqrt (extended_Gromov_distance x y)\n           \\<le> eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint x\n                    y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> 2 * ereal (dist x y)\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n 2. \\<not> esqrt (extended_Gromov_distance x y)\n           \\<le> eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint x\n                    y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "have \"... \\<le> exp(-epsilonG(TYPE('a)) * M0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ereal (dist x y) \\<le> ereal (exp (- epsilonG TYPE('a) * M0))", "using \\<open>dist x y \\<le> e\\<close>"], ["proof (prove)\nusing this:\n  dist x y \\<le> e\n\ngoal (1 subgoal):\n 1. 2 * ereal (dist x y) \\<le> ereal (exp (- epsilonG TYPE('a) * M0))", "unfolding e_def"], ["proof (prove)\nusing this:\n  dist x y \\<le> exp (- epsilonG TYPE('a) * M0) / 2\n\ngoal (1 subgoal):\n 1. 2 * ereal (dist x y) \\<le> ereal (exp (- epsilonG TYPE('a) * M0))", "by (auto simp add: numeral_mult_ennreal)"], ["proof (state)\nthis:\n  2 * ereal (dist x y) \\<le> ereal (exp (- epsilonG TYPE('a) * M0))\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n 2. \\<not> esqrt (extended_Gromov_distance x y)\n           \\<le> eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint x\n                    y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "finally"], ["proof (chain)\npicking this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> ereal (exp (- epsilonG TYPE('a) * M0))", "have \"ereal M0 \\<le> extended_Gromov_product_at basepoint x y\""], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> ereal (exp (- epsilonG TYPE('a) * M0))\n\ngoal (1 subgoal):\n 1. ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "unfolding eexp_ereal[symmetric]"], ["proof (prove)\nusing this:\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> eexp (ereal (- epsilonG TYPE('a) * M0))\n\ngoal (1 subgoal):\n 1. ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "apply (simp only: eexp_le_eexp_iff_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y\n    \\<le> ereal (- epsilonG TYPE('a) * M0) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "unfolding times_ereal.simps(1)[symmetric] uminus_ereal.simps(1)[symmetric] ereal_mult_minus_left ereal_minus_le_minus"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (epsilonG TYPE('a)) * ereal M0\n    \\<le> ereal (epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "using ereal_mult_le_mult_iff[of \"ereal (epsilonG TYPE('a))\"]"], ["proof (prove)\nusing this:\n  \\<bar>ereal (epsilonG TYPE('a))\\<bar> \\<noteq>\n  \\<infinity> \\<Longrightarrow>\n  (ereal (epsilonG TYPE('a)) * ?a \\<le> ereal (epsilonG TYPE('a)) * ?b) =\n  ((0 < ereal (epsilonG TYPE('a)) \\<longrightarrow> ?a \\<le> ?b) \\<and>\n   (ereal (epsilonG TYPE('a)) < 0 \\<longrightarrow> ?b \\<le> ?a))\n\ngoal (1 subgoal):\n 1. ereal (epsilonG TYPE('a)) * ereal M0\n    \\<le> ereal (epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ereal (epsilonG TYPE('a) * M0)\n             \\<le> ereal (epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint x y;\n     \\<And>a b.\n        (ereal (epsilonG TYPE('a)) * a\n         \\<le> ereal (epsilonG TYPE('a)) * b) =\n        (a \\<le> b \\<and>\n         (epsilonG TYPE('a) < 0 \\<longrightarrow> b \\<le> a))\\<rbrakk>\n    \\<Longrightarrow> ereal M0\n                      \\<le> extended_Gromov_product_at basepoint x y", "by (metis \\<open>\\<And>r p. ereal (r * p) = ereal r * ereal p\\<close>)"], ["proof (state)\nthis:\n  ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n\ngoal (2 subgoals):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n 2. \\<not> esqrt (extended_Gromov_distance x y)\n           \\<le> eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint x\n                    y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "then"], ["proof (chain)\npicking this:\n  ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "show \"M0 \\<le> extended_Gromov_product_at basepoint x y\""], ["proof (prove)\nusing this:\n  ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n\ngoal (1 subgoal):\n 1. ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "by auto"], ["proof (state)\nthis:\n  ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "case True"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "then"], ["proof (chain)\npicking this:\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)", "have \"esqrt(extended_Gromov_distance x y) \\<le> 2 * ereal(dist x y)\""], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "using Gromov_completion_dist_comparison(3)[of x y]"], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n  min (esqrt (extended_Gromov_distance x y))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y))\n  \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "unfolding min_def"], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x y)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n  (if esqrt (extended_Gromov_distance x y)\n      \\<le> eexp\n             (ereal (- epsilonG TYPE('a)) *\n              extended_Gromov_product_at basepoint x y)\n   then esqrt (extended_Gromov_distance x y)\n   else eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y))\n  \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "by auto"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "also"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "have \"... \\<le> esqrt 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ereal (dist x y) \\<le> esqrt 4", "by simp"], ["proof (state)\nthis:\n  2 * ereal (dist x y) \\<le> esqrt 4\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "finally"], ["proof (chain)\npicking this:\n  esqrt (extended_Gromov_distance x y) \\<le> esqrt 4", "have *: \"extended_Gromov_distance x y \\<le> 4\""], ["proof (prove)\nusing this:\n  esqrt (extended_Gromov_distance x y) \\<le> esqrt 4\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y \\<le> 4", "unfolding esqrt_le"], ["proof (prove)\nusing this:\n  extended_Gromov_distance x y \\<le> 0 \\<or>\n  extended_Gromov_distance x y \\<le> 4\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y \\<le> 4", "using antisym"], ["proof (prove)\nusing this:\n  extended_Gromov_distance x y \\<le> 0 \\<or>\n  extended_Gromov_distance x y \\<le> 4\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y \\<le> 4", "by fastforce"], ["proof (state)\nthis:\n  extended_Gromov_distance x y \\<le> 4\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "have \"ereal M0+4 \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M0 + 4 \\<le> D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M0 + 4 \\<le> ereal M0 + 4", "by auto"], ["proof (state)\nthis:\n  ereal M0 + 4 \\<le> D\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "also"], ["proof (state)\nthis:\n  ereal M0 + 4 \\<le> D\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "have \"... \\<le> extended_Gromov_product_at basepoint x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> extended_Gromov_product_at basepoint x x", "using that"], ["proof (prove)\nusing this:\n  dist x y \\<le> e\n  D \\<le> extended_Gromov_distance x (to_Gromov_completion basepoint)\n\ngoal (1 subgoal):\n 1. D \\<le> extended_Gromov_product_at basepoint x x", "by (auto simp add: extended_Gromov_distance_commute)"], ["proof (state)\nthis:\n  D \\<le> extended_Gromov_product_at basepoint x x\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "also"], ["proof (state)\nthis:\n  D \\<le> extended_Gromov_product_at basepoint x x\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "have \"... \\<le> extended_Gromov_product_at basepoint x y + extended_Gromov_distance x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint x x\n    \\<le> extended_Gromov_product_at basepoint x y +\n          extended_Gromov_distance x y", "by (rule extended_Gromov_product_at_diff3[of basepoint x x y])"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint x x\n  \\<le> extended_Gromov_product_at basepoint x y +\n        extended_Gromov_distance x y\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "also"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint x x\n  \\<le> extended_Gromov_product_at basepoint x y +\n        extended_Gromov_distance x y\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "have \"... \\<le> extended_Gromov_product_at basepoint x y + 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint x y + extended_Gromov_distance x y\n    \\<le> extended_Gromov_product_at basepoint x y + 4", "by (intro mono_intros *)"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint x y + extended_Gromov_distance x y\n  \\<le> extended_Gromov_product_at basepoint x y + 4\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y) \\<Longrightarrow>\n    ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "finally"], ["proof (chain)\npicking this:\n  ereal M0 + 4 \\<le> extended_Gromov_product_at basepoint x y + 4", "show \"M0 \\<le> extended_Gromov_product_at basepoint x y\""], ["proof (prove)\nusing this:\n  ereal M0 + 4 \\<le> extended_Gromov_product_at basepoint x y + 4\n\ngoal (1 subgoal):\n 1. ereal M0 \\<le> extended_Gromov_product_at basepoint x y", "by (metis (no_types, lifting) PInfty_neq_ereal(1) add.commute add_nonneg_nonneg ereal_add_strict_mono ereal_le_distrib mult_2_ereal not_le numeral_Bit0 numeral_eq_ereal one_add_one zero_less_one_ereal)"], ["proof (state)\nthis:\n  ereal M0 \\<le> extended_Gromov_product_at basepoint x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>dist ?x ?y \\<le> e;\n   D \\<le> extended_Gromov_distance ?x\n            (to_Gromov_completion basepoint)\\<rbrakk>\n  \\<Longrightarrow> ereal M0\n                    \\<le> extended_Gromov_product_at basepoint ?x ?y\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "ultimately"], ["proof (chain)\npicking this:\n  0 < e\n  D < \\<infinity>\n  \\<lbrakk>dist ?x ?y \\<le> e;\n   D \\<le> extended_Gromov_distance ?x\n            (to_Gromov_completion basepoint)\\<rbrakk>\n  \\<Longrightarrow> ereal M0\n                    \\<le> extended_Gromov_product_at basepoint ?x ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < e\n  D < \\<infinity>\n  \\<lbrakk>dist ?x ?y \\<le> e;\n   D \\<le> extended_Gromov_distance ?x\n            (to_Gromov_completion basepoint)\\<rbrakk>\n  \\<Longrightarrow> ereal M0\n                    \\<le> extended_Gromov_product_at basepoint ?x ?y\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "using order_trans[OF \\<open>M \\<le> ereal M0\\<close>]"], ["proof (prove)\nusing this:\n  0 < e\n  D < \\<infinity>\n  \\<lbrakk>dist ?x ?y \\<le> e;\n   D \\<le> extended_Gromov_distance ?x\n            (to_Gromov_completion basepoint)\\<rbrakk>\n  \\<Longrightarrow> ereal M0\n                    \\<le> extended_Gromov_product_at basepoint ?x ?y\n  ereal M0 \\<le> ?z \\<Longrightarrow> M \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<exists>e D.\n       0 < e \\<and>\n       D < \\<infinity> \\<and>\n       (\\<forall>x y.\n           dist x y \\<le> e \\<longrightarrow>\n           D \\<le> extended_Gromov_distance x\n                    (to_Gromov_completion basepoint) \\<longrightarrow>\n           M \\<le> extended_Gromov_product_at basepoint x y)", "by force"], ["proof (state)\nthis:\n  \\<exists>e D.\n     0 < e \\<and>\n     D < \\<infinity> \\<and>\n     (\\<forall>x y.\n         dist x y \\<le> e \\<longrightarrow>\n         D \\<le> extended_Gromov_distance x\n                  (to_Gromov_completion basepoint) \\<longrightarrow>\n         M \\<le> extended_Gromov_product_at basepoint x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>On the other hand, far away from infinity, it is equivalent to control the extended Gromov\ndistance or the new distance on the space.\\<close>"], ["", "lemma inside_Gromov_distance_approx:\n  assumes \"C < (\\<infinity>::ereal)\"\n  shows \"\\<exists>e > 0. \\<forall>x y. extended_Gromov_distance (to_Gromov_completion basepoint) x \\<le> C \\<longrightarrow> dist x y \\<le> e\n          \\<longrightarrow> esqrt(extended_Gromov_distance x y) \\<le> 2 * ereal(dist x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "obtain C0 where \"C \\<le> ereal C0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C0. C \\<le> ereal C0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  C < \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>C0. C \\<le> ereal C0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases C, auto)"], ["proof (state)\nthis:\n  C \\<le> ereal C0\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "define e0 where \"e0 = exp(-epsilonG(TYPE('a)) * C0)\""], ["proof (state)\nthis:\n  e0 = exp (- epsilonG TYPE('a) * C0)\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "have \"e0 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e0", "unfolding e0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < exp (- epsilonG TYPE('a) * C0)", "using assms"], ["proof (prove)\nusing this:\n  C < \\<infinity>\n\ngoal (1 subgoal):\n 1. 0 < exp (- epsilonG TYPE('a) * C0)", "by auto"], ["proof (state)\nthis:\n  0 < e0\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "define e where \"e = e0/4\""], ["proof (state)\nthis:\n  e = e0 / 4\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "have \"e > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e0 / 4", "using \\<open>e0 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e0\n\ngoal (1 subgoal):\n 1. 0 < e0 / 4", "by auto"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "moreover"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "have \"esqrt(extended_Gromov_distance x y) \\<le> 2 * ereal(dist x y)\"\n    if \"extended_Gromov_distance (to_Gromov_completion basepoint) x \\<le> C0\" \"dist x y \\<le> e\" for x y::\"'a Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "have R: \"min a b \\<le> c \\<Longrightarrow> a \\<le> c \\<or> b \\<le> c\" for a b c::ereal"], ["proof (prove)\ngoal (1 subgoal):\n 1. min a b \\<le> c \\<Longrightarrow> a \\<le> c \\<or> b \\<le> c", "unfolding min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if a \\<le> b then a else b) \\<le> c \\<Longrightarrow>\n    a \\<le> c \\<or> b \\<le> c", "by presburger"], ["proof (state)\nthis:\n  min ?a ?b \\<le> ?c \\<Longrightarrow> ?a \\<le> ?c \\<or> ?b \\<le> ?c\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "have \"2 * ereal (dist x y) \\<le> 2 * ereal e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ereal (dist x y) \\<le> 2 * ereal e", "using that"], ["proof (prove)\nusing this:\n  extended_Gromov_distance (to_Gromov_completion basepoint) x \\<le> ereal C0\n  dist x y \\<le> e\n\ngoal (1 subgoal):\n 1. 2 * ereal (dist x y) \\<le> 2 * ereal e", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  2 * ereal (dist x y) \\<le> 2 * ereal e\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "also"], ["proof (state)\nthis:\n  2 * ereal (dist x y) \\<le> 2 * ereal e\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "have \"... = ereal(e0/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ereal e = ereal (e0 / 2)", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ereal (e0 / 4) = ereal (e0 / 2)", "by auto"], ["proof (state)\nthis:\n  2 * ereal e = ereal (e0 / 2)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "also"], ["proof (state)\nthis:\n  2 * ereal e = ereal (e0 / 2)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "have \"... < ereal e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (e0 / 2) < ereal e0", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. e0 / 2 < e0", "using \\<open>e0 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e0\n\ngoal (1 subgoal):\n 1. e0 / 2 < e0", "by auto"], ["proof (state)\nthis:\n  ereal (e0 / 2) < ereal e0\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "also"], ["proof (state)\nthis:\n  ereal (e0 / 2) < ereal e0\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "have \"... \\<le> eexp(-epsilonG(TYPE('a)) * extended_Gromov_distance (to_Gromov_completion basepoint) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal e0\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_distance (to_Gromov_completion basepoint) x)", "unfolding e0_def eexp_ereal[symmetric] ereal_mult_minus_left mult_minus_left uminus_ereal.simps(1)[symmetric] times_ereal.simps(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (- (ereal (epsilonG TYPE('a)) * ereal C0))\n    \\<le> eexp\n           (- (ereal (epsilonG TYPE('a)) *\n               extended_Gromov_distance (to_Gromov_completion basepoint) x))", "by (intro mono_intros that)"], ["proof (state)\nthis:\n  ereal e0\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_distance (to_Gromov_completion basepoint) x)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "also"], ["proof (state)\nthis:\n  ereal e0\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_distance (to_Gromov_completion basepoint) x)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "have \"... \\<le> eexp(-epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_distance (to_Gromov_completion basepoint) x)\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint x y)", "unfolding ereal_mult_minus_left mult_minus_left uminus_ereal.simps(1)[symmetric] times_ereal.simps(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (- (ereal (epsilonG TYPE('a)) *\n         extended_Gromov_distance (to_Gromov_completion basepoint) x))\n    \\<le> eexp\n           (- (ereal (epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint x y))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_distance (to_Gromov_completion basepoint) x)\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "finally"], ["proof (chain)\npicking this:\n  2 * ereal (dist x y)\n  < eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * ereal (dist x y)\n  < eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "using R[OF Gromov_completion_dist_comparison(3)[of x y]]"], ["proof (prove)\nusing this:\n  2 * ereal (dist x y)\n  < eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint x y)\n  esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y) \\<or>\n  eexp\n   (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint x y)\n  \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "by auto"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>extended_Gromov_distance (to_Gromov_completion basepoint) ?x\n           \\<le> ereal C0;\n   dist ?x ?y \\<le> e\\<rbrakk>\n  \\<Longrightarrow> esqrt (extended_Gromov_distance ?x ?y)\n                    \\<le> 2 * ereal (dist ?x ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "ultimately"], ["proof (chain)\npicking this:\n  0 < e\n  \\<lbrakk>extended_Gromov_distance (to_Gromov_completion basepoint) ?x\n           \\<le> ereal C0;\n   dist ?x ?y \\<le> e\\<rbrakk>\n  \\<Longrightarrow> esqrt (extended_Gromov_distance ?x ?y)\n                    \\<le> 2 * ereal (dist ?x ?y)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < e\n  \\<lbrakk>extended_Gromov_distance (to_Gromov_completion basepoint) ?x\n           \\<le> ereal C0;\n   dist ?x ?y \\<le> e\\<rbrakk>\n  \\<Longrightarrow> esqrt (extended_Gromov_distance ?x ?y)\n                    \\<le> 2 * ereal (dist ?x ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "using order_trans[OF _ \\<open>C \\<le> ereal C0\\<close>]"], ["proof (prove)\nusing this:\n  0 < e\n  \\<lbrakk>extended_Gromov_distance (to_Gromov_completion basepoint) ?x\n           \\<le> ereal C0;\n   dist ?x ?y \\<le> e\\<rbrakk>\n  \\<Longrightarrow> esqrt (extended_Gromov_distance ?x ?y)\n                    \\<le> 2 * ereal (dist ?x ?y)\n  ?x \\<le> C \\<Longrightarrow> ?x \\<le> ereal C0\n\ngoal (1 subgoal):\n 1. \\<exists>e>0.\n       \\<forall>x y.\n          extended_Gromov_distance (to_Gromov_completion basepoint) x\n          \\<le> C \\<longrightarrow>\n          dist x y \\<le> e \\<longrightarrow>\n          esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)", "by auto"], ["proof (state)\nthis:\n  \\<exists>e>0.\n     \\<forall>x y.\n        extended_Gromov_distance (to_Gromov_completion basepoint) x\n        \\<le> C \\<longrightarrow>\n        dist x y \\<le> e \\<longrightarrow>\n        esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Characterizing convergence in the Gromov boundary\\<close>"], ["", "text \\<open>The convergence of sequences in the Gromov boundary can be characterized, essentially\nby definition: sequences tend to a point at infinity iff the Gromov product with this point tends\nto infinity, while sequences tend to a point inside iff the extended distance tends to $0$. In both\ncases, it is just a matter of unfolding the definition of the distance, and see which one of the two\nterms (exponential of minus the Gromov product, or extended distance) realizes the minimum. We have\nconstructed the distance essentially so that this property is satisfied.\n\nWe could also have defined first the topology, satisfying these conditions, but then we would have\nhad to check that it coincides with the topology that the distance defines, so it seems more\neconomical to proceed in this way.\\<close>"], ["", "lemma Gromov_completion_boundary_limit:\n  assumes \"x \\<in> Gromov_boundary\"\n  shows \"(u \\<longlongrightarrow> x) F \\<longleftrightarrow> ((\\<lambda>n. extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow> \\<infinity>) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F =\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F\n 2. ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> x) F", "assume *: \"((\\<lambda>n. extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow> \\<infinity>) F\""], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n   \\<infinity>)\n   F\n\ngoal (2 subgoals):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F\n 2. ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> x) F", "have \"((\\<lambda>n. ereal(dist (u n) x)) \\<longlongrightarrow> 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "proof (rule tendsto_sandwich[of \"\\<lambda>_. 0\" _ _ \"(\\<lambda>n. eexp (-epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (u n) x))\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F. 0 \\<le> ereal (dist (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       ereal (dist (u n) x)\n       \\<le> eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 4. ((\\<lambda>n.\n         eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n)\n            x)) \\<longlongrightarrow>\n     0)\n     F", "have \"((\\<lambda>n. eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (u n) x)) \\<longlongrightarrow> eexp (- epsilonG(TYPE('a)) * (\\<infinity>::ereal))) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n)\n            x)) \\<longlongrightarrow>\n     eexp (ereal (- epsilonG TYPE('a)) * \\<infinity>))\n     F", "apply (intro tendsto_intros *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>ereal (- epsilonG TYPE('a))\\<bar> \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n)\n          x)) \\<longlongrightarrow>\n   eexp (ereal (- epsilonG TYPE('a)) * \\<infinity>))\n   F\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F. 0 \\<le> ereal (dist (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       ereal (dist (u n) x)\n       \\<le> eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 4. ((\\<lambda>n.\n         eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n)\n            x)) \\<longlongrightarrow>\n     0)\n     F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n.\n       eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n)\n          x)) \\<longlongrightarrow>\n   eexp (ereal (- epsilonG TYPE('a)) * \\<infinity>))\n   F", "show \"((\\<lambda>n. eexp (-epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (u n) x)) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n)\n          x)) \\<longlongrightarrow>\n   eexp (ereal (- epsilonG TYPE('a)) * \\<infinity>))\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n)\n            x)) \\<longlongrightarrow>\n     0)\n     F", "using constant_in_extended_predist_pos(1)[where ?'a = 'a]"], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n)\n          x)) \\<longlongrightarrow>\n   eexp (ereal (- epsilonG TYPE('a)) * \\<infinity>))\n   F\n  0 < epsilonG TYPE('a)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n)\n            x)) \\<longlongrightarrow>\n     0)\n     F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n)\n          x)) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in F. 0 \\<le> ereal (dist (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       ereal (dist (u n) x)\n       \\<le> eexp\n              (ereal (- epsilonG TYPE('a)) *\n               extended_Gromov_product_at basepoint (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F", "qed (auto simp add: Gromov_completion_dist_comparison)"], ["proof (state)\nthis:\n  ((\\<lambda>n. ereal (dist (u n) x)) \\<longlongrightarrow> 0) F\n\ngoal (2 subgoals):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F\n 2. ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> x) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n. ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "have \"((\\<lambda>n. real_of_ereal(ereal(dist (u n) x))) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n. ereal (dist (u n) x)) \\<longlongrightarrow> 0) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         real_of_ereal (ereal (dist (u n) x))) \\<longlongrightarrow>\n     0)\n     F", "by (simp add: zero_ereal_def)"], ["proof (state)\nthis:\n  ((\\<lambda>n. real_of_ereal (ereal (dist (u n) x))) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (2 subgoals):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F\n 2. ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> x) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n. real_of_ereal (ereal (dist (u n) x))) \\<longlongrightarrow>\n   0)\n   F", "show \"(u \\<longlongrightarrow> x) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n. real_of_ereal (ereal (dist (u n) x))) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F", "by (subst tendsto_dist_iff, auto)"], ["proof (state)\nthis:\n  (u \\<longlongrightarrow> x) F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "assume *: \"(u \\<longlongrightarrow> x) F\""], ["proof (state)\nthis:\n  (u \\<longlongrightarrow> x) F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "have A: \"1 / ereal (- epsilonG TYPE('a)) * (ereal (- epsilonG TYPE('a))) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / ereal (- epsilonG TYPE('a)) * ereal (- epsilonG TYPE('a)) = 1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. epsilonG TYPE('a) = 0 \\<Longrightarrow> False", "using constant_in_extended_predist_pos(1)[where ?'a = 'a]"], ["proof (prove)\nusing this:\n  0 < epsilonG TYPE('a)\n\ngoal (1 subgoal):\n 1. epsilonG TYPE('a) = 0 \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  1 / ereal (- epsilonG TYPE('a)) * ereal (- epsilonG TYPE('a)) = 1\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "have a: \"esqrt(extended_Gromov_distance (u n) x) = \\<infinity>\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance (u n) x) = \\<infinity>", "unfolding extended_Gromov_distance_PInf_boundary(2)[OF assms, of \"u n\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt \\<infinity> = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance (u ?n) x) = \\<infinity>\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "have \"min (esqrt(extended_Gromov_distance (u n) x)) (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (u n) x))\n        = eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (u n) x)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (esqrt (extended_Gromov_distance (u n) x))\n     (eexp\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint (u n) x)) =\n    eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint (u n) x)", "unfolding a min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<infinity>\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint (u n) x)\n     then \\<infinity>\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint (u n) x)) =\n    eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint (u n) x)", "using neq_top_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<noteq> top; ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<noteq> top\n\ngoal (1 subgoal):\n 1. (if \\<infinity>\n        \\<le> eexp\n               (ereal (- epsilonG TYPE('a)) *\n                extended_Gromov_product_at basepoint (u n) x)\n     then \\<infinity>\n     else eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint (u n) x)) =\n    eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint (u n) x)", "by force"], ["proof (state)\nthis:\n  min (esqrt (extended_Gromov_distance (u ?n) x))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint (u ?n) x)) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint (u ?n) x)\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "moreover"], ["proof (state)\nthis:\n  min (esqrt (extended_Gromov_distance (u ?n) x))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint (u ?n) x)) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint (u ?n) x)\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "have \"((\\<lambda>n. min (esqrt(extended_Gromov_distance (u n) x)) (eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (u n) x))) \\<longlongrightarrow> 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         min (esqrt (extended_Gromov_distance (u n) x))\n          (eexp\n            (ereal (- epsilonG TYPE('a)) *\n             extended_Gromov_product_at basepoint (u n)\n              x))) \\<longlongrightarrow>\n     0)\n     F", "proof (rule tendsto_sandwich[of \"\\<lambda>_. 0\" _ _ \"\\<lambda>n. 2 * ereal(dist (u n) x)\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> min (esqrt (extended_Gromov_distance (u n) x))\n                (eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint (u n) x))\n 2. \\<forall>\\<^sub>F n in F.\n       min (esqrt (extended_Gromov_distance (u n) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n) x))\n       \\<le> 2 * ereal (dist (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 4. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "have \"((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 2 * ereal 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow>\n     2 * ereal 0)\n     F", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bar>2\\<bar> \\<noteq> \\<infinity>\n 2. ((\\<lambda>xa. dist (u xa) x) \\<longlongrightarrow> 0) F", "using * tendsto_dist_iff"], ["proof (prove)\nusing this:\n  (u \\<longlongrightarrow> x) F\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n\ngoal (2 subgoals):\n 1. \\<bar>2\\<bar> \\<noteq> \\<infinity>\n 2. ((\\<lambda>xa. dist (u xa) x) \\<longlongrightarrow> 0) F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 2 * ereal 0)\n   F\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> min (esqrt (extended_Gromov_distance (u n) x))\n                (eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint (u n) x))\n 2. \\<forall>\\<^sub>F n in F.\n       min (esqrt (extended_Gromov_distance (u n) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n) x))\n       \\<le> 2 * ereal (dist (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 4. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 2 * ereal 0)\n   F", "show \"((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 2 * ereal 0)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "by (simp add: zero_ereal_def)"], ["proof (state)\nthis:\n  ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> min (esqrt (extended_Gromov_distance (u n) x))\n                (eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint (u n) x))\n 2. \\<forall>\\<^sub>F n in F.\n       min (esqrt (extended_Gromov_distance (u n) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n) x))\n       \\<le> 2 * ereal (dist (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F", "show \"\\<forall>\\<^sub>F n in F. 0 \\<le> min (esqrt (extended_Gromov_distance (u n) x)) (eexp (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint (u n) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> min (esqrt (extended_Gromov_distance (u n) x))\n                (eexp\n                  (ereal (- epsilonG TYPE('a)) *\n                   extended_Gromov_product_at basepoint (u n) x))", "by (rule always_eventually, auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F.\n     0 \\<le> min (esqrt (extended_Gromov_distance (u n) x))\n              (eexp\n                (ereal (- epsilonG TYPE('a)) *\n                 extended_Gromov_product_at basepoint (u n) x))\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       min (esqrt (extended_Gromov_distance (u n) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n) x))\n       \\<le> 2 * ereal (dist (u n) x)\n 2. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F", "show \"\\<forall>\\<^sub>F n in F.\n        min (esqrt (extended_Gromov_distance (u n) x)) (eexp (ereal (- epsilonG TYPE('a)) * extended_Gromov_product_at basepoint (u n) x)) \\<le> 2 * ereal (dist (u n) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F.\n       min (esqrt (extended_Gromov_distance (u n) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n) x))\n       \\<le> 2 * ereal (dist (u n) x)", "apply (rule always_eventually)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       min (esqrt (extended_Gromov_distance (u xa) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u xa) x))\n       \\<le> 2 * ereal (dist (u xa) x)", "using Gromov_completion_dist_comparison(3)"], ["proof (prove)\nusing this:\n  min (esqrt (extended_Gromov_distance ?x ?y))\n   (eexp\n     (ereal (- epsilonG TYPE(?'a)) *\n      extended_Gromov_product_at basepoint ?x ?y))\n  \\<le> 2 * ereal (dist ?x ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       min (esqrt (extended_Gromov_distance (u xa) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u xa) x))\n       \\<le> 2 * ereal (dist (u xa) x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F.\n     min (esqrt (extended_Gromov_distance (u n) x))\n      (eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n) x))\n     \\<le> 2 * ereal (dist (u n) x)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F", "qed (auto)"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       min (esqrt (extended_Gromov_distance (u n) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n)\n            x))) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "ultimately"], ["proof (chain)\npicking this:\n  min (esqrt (extended_Gromov_distance (u ?n) x))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint (u ?n) x)) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint (u ?n) x)\n  ((\\<lambda>n.\n       min (esqrt (extended_Gromov_distance (u n) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n)\n            x))) \\<longlongrightarrow>\n   0)\n   F", "have \"((\\<lambda>n. eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (u n) x)) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  min (esqrt (extended_Gromov_distance (u ?n) x))\n   (eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint (u ?n) x)) =\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint (u ?n) x)\n  ((\\<lambda>n.\n       min (esqrt (extended_Gromov_distance (u n) x))\n        (eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n)\n            x))) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         eexp\n          (ereal (- epsilonG TYPE('a)) *\n           extended_Gromov_product_at basepoint (u n)\n            x)) \\<longlongrightarrow>\n     0)\n     F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n)\n          x)) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n.\n       eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n)\n          x)) \\<longlongrightarrow>\n   0)\n   F", "have \"((\\<lambda>n. - epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow> -\\<infinity>) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       eexp\n        (ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n)\n          x)) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     - \\<infinity>)\n     F", "unfolding eexp_special_values(3)[symmetric] eexp_tendsto'"], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n   - \\<infinity>)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         ereal (- epsilonG TYPE('a)) *\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     - \\<infinity>)\n     F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n   - \\<infinity>)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n.\n       ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n   - \\<infinity>)\n   F", "have \"((\\<lambda>n. 1/ereal(-epsilonG(TYPE('a))) * (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (u n) x)) \\<longlongrightarrow> 1/ereal(-epsilonG(TYPE('a))) * (-\\<infinity>)) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       ereal (- epsilonG TYPE('a)) *\n       extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n   - \\<infinity>)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         1 / ereal (- epsilonG TYPE('a)) *\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint (u n)\n           x)) \\<longlongrightarrow>\n     1 / ereal (- epsilonG TYPE('a)) * - \\<infinity>)\n     F", "by (intro tendsto_intros, auto)"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       1 / ereal (- epsilonG TYPE('a)) *\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint (u n) x)) \\<longlongrightarrow>\n   1 / ereal (- epsilonG TYPE('a)) * - \\<infinity>)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       1 / ereal (- epsilonG TYPE('a)) *\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint (u n) x)) \\<longlongrightarrow>\n   1 / ereal (- epsilonG TYPE('a)) * - \\<infinity>)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "have \"1/ereal(-epsilonG(TYPE('a))) * (-\\<infinity>) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / ereal (- epsilonG TYPE('a)) * - \\<infinity> = \\<infinity>", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. epsilonG TYPE('a) < 0 \\<Longrightarrow> False\n 2. epsilonG TYPE('a) = 0 \\<Longrightarrow> False", "using constant_in_extended_predist_pos(1)[where ?'a = 'a]"], ["proof (prove)\nusing this:\n  0 < epsilonG TYPE('a)\n\ngoal (2 subgoals):\n 1. epsilonG TYPE('a) < 0 \\<Longrightarrow> False\n 2. epsilonG TYPE('a) = 0 \\<Longrightarrow> False", "by auto"], ["proof (state)\nthis:\n  1 / ereal (- epsilonG TYPE('a)) * - \\<infinity> = \\<infinity>\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<lambda>n.\n       1 / ereal (- epsilonG TYPE('a)) *\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint (u n) x)) \\<longlongrightarrow>\n   1 / ereal (- epsilonG TYPE('a)) * - \\<infinity>)\n   F\n  1 / ereal (- epsilonG TYPE('a)) * - \\<infinity> = \\<infinity>", "show \"((\\<lambda>n. extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow> \\<infinity>) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       1 / ereal (- epsilonG TYPE('a)) *\n       (ereal (- epsilonG TYPE('a)) *\n        extended_Gromov_product_at basepoint (u n) x)) \\<longlongrightarrow>\n   1 / ereal (- epsilonG TYPE('a)) * - \\<infinity>)\n   F\n  1 / ereal (- epsilonG TYPE('a)) * - \\<infinity> = \\<infinity>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "unfolding ab_semigroup_mult_class.mult_ac(1)[symmetric] A"], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       1 *\n       extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n   1 / ereal (- epsilonG TYPE('a)) * - \\<infinity>)\n   F\n  1 / ereal (- epsilonG TYPE('a)) * - \\<infinity> = \\<infinity>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       extended_Gromov_product_at basepoint (u n) x) \\<longlongrightarrow>\n   \\<infinity>)\n   F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_Gromov_product_tendsto_PInf_a_b:\n  assumes \"((\\<lambda>n. extended_Gromov_product_at a (u n) (v n)) \\<longlongrightarrow> \\<infinity>) F\"\n  shows \"((\\<lambda>n. extended_Gromov_product_at b (u n) (v n)) \\<longlongrightarrow> \\<infinity>) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         extended_Gromov_product_at b (u n) (v n)) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "proof (rule tendsto_sandwich[of \"\\<lambda>n. extended_Gromov_product_at a (u n) (v n) - dist a b\" _ _ \"\\<lambda>_. \\<infinity>\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       extended_Gromov_product_at a (u n) (v n) - ereal (dist a b)\n       \\<le> extended_Gromov_product_at b (u n) (v n)\n 2. \\<forall>\\<^sub>F n in F.\n       extended_Gromov_product_at b (u n) (v n) \\<le> \\<infinity>\n 3. ((\\<lambda>n.\n         extended_Gromov_product_at a (u n) (v n) -\n         ereal (dist a b)) \\<longlongrightarrow>\n     \\<infinity>)\n     F\n 4. ((\\<lambda>_. \\<infinity>) \\<longlongrightarrow> \\<infinity>) F", "have \"extended_Gromov_product_at a (u n) (v n) - ereal (dist a b) \\<le> extended_Gromov_product_at b (u n) (v n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at a (u n) (v n) - ereal (dist a b)\n    \\<le> extended_Gromov_product_at b (u n) (v n)", "using extended_Gromov_product_at_diff1[of a \"u n\" \"v n\" b]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at a (u n) (v n)\n  \\<le> extended_Gromov_product_at b (u n) (v n) + ereal (dist a b)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at a (u n) (v n) - ereal (dist a b)\n    \\<le> extended_Gromov_product_at b (u n) (v n)", "by (simp add: add.commute ereal_minus_le_iff)"], ["proof (state)\nthis:\n  extended_Gromov_product_at a (u ?n) (v ?n) - ereal (dist a b)\n  \\<le> extended_Gromov_product_at b (u ?n) (v ?n)\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       extended_Gromov_product_at a (u n) (v n) - ereal (dist a b)\n       \\<le> extended_Gromov_product_at b (u n) (v n)\n 2. \\<forall>\\<^sub>F n in F.\n       extended_Gromov_product_at b (u n) (v n) \\<le> \\<infinity>\n 3. ((\\<lambda>n.\n         extended_Gromov_product_at a (u n) (v n) -\n         ereal (dist a b)) \\<longlongrightarrow>\n     \\<infinity>)\n     F\n 4. ((\\<lambda>_. \\<infinity>) \\<longlongrightarrow> \\<infinity>) F", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at a (u ?n) (v ?n) - ereal (dist a b)\n  \\<le> extended_Gromov_product_at b (u ?n) (v ?n)", "show \"\\<forall>\\<^sub>F n in F. extended_Gromov_product_at a (u n) (v n) - ereal (dist a b) \\<le> extended_Gromov_product_at b (u n) (v n)\""], ["proof (prove)\nusing this:\n  extended_Gromov_product_at a (u ?n) (v ?n) - ereal (dist a b)\n  \\<le> extended_Gromov_product_at b (u ?n) (v ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F.\n       extended_Gromov_product_at a (u n) (v n) - ereal (dist a b)\n       \\<le> extended_Gromov_product_at b (u n) (v n)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F.\n     extended_Gromov_product_at a (u n) (v n) - ereal (dist a b)\n     \\<le> extended_Gromov_product_at b (u n) (v n)\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       extended_Gromov_product_at b (u n) (v n) \\<le> \\<infinity>\n 2. ((\\<lambda>n.\n         extended_Gromov_product_at a (u n) (v n) -\n         ereal (dist a b)) \\<longlongrightarrow>\n     \\<infinity>)\n     F\n 3. ((\\<lambda>_. \\<infinity>) \\<longlongrightarrow> \\<infinity>) F", "have \"((\\<lambda>n. extended_Gromov_product_at a (u n) (v n) - ereal (dist a b)) \\<longlongrightarrow> \\<infinity> - ereal (dist a b)) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         extended_Gromov_product_at a (u n) (v n) -\n         ereal (dist a b)) \\<longlongrightarrow>\n     \\<infinity> - ereal (dist a b))\n     F", "by (intro tendsto_intros assms) auto"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       extended_Gromov_product_at a (u n) (v n) -\n       ereal (dist a b)) \\<longlongrightarrow>\n   \\<infinity> - ereal (dist a b))\n   F\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       extended_Gromov_product_at b (u n) (v n) \\<le> \\<infinity>\n 2. ((\\<lambda>n.\n         extended_Gromov_product_at a (u n) (v n) -\n         ereal (dist a b)) \\<longlongrightarrow>\n     \\<infinity>)\n     F\n 3. ((\\<lambda>_. \\<infinity>) \\<longlongrightarrow> \\<infinity>) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n.\n       extended_Gromov_product_at a (u n) (v n) -\n       ereal (dist a b)) \\<longlongrightarrow>\n   \\<infinity> - ereal (dist a b))\n   F", "show \"((\\<lambda>n. extended_Gromov_product_at a (u n) (v n) - ereal (dist a b)) \\<longlongrightarrow> \\<infinity>) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       extended_Gromov_product_at a (u n) (v n) -\n       ereal (dist a b)) \\<longlongrightarrow>\n   \\<infinity> - ereal (dist a b))\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         extended_Gromov_product_at a (u n) (v n) -\n         ereal (dist a b)) \\<longlongrightarrow>\n     \\<infinity>)\n     F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       extended_Gromov_product_at a (u n) (v n) -\n       ereal (dist a b)) \\<longlongrightarrow>\n   \\<infinity>)\n   F\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       extended_Gromov_product_at b (u n) (v n) \\<le> \\<infinity>\n 2. ((\\<lambda>_. \\<infinity>) \\<longlongrightarrow> \\<infinity>) F", "qed (auto)"], ["", "lemma Gromov_completion_inside_limit:\n  assumes \"x \\<notin> Gromov_boundary\"\n  shows \"(u \\<longlongrightarrow> x) F \\<longleftrightarrow> ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F =\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F\n 2. ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> x) F", "assume *: \"((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0) F\""], ["proof (state)\nthis:\n  ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0) F\n\ngoal (2 subgoals):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F\n 2. ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> x) F", "have \"((\\<lambda>n. ereal(dist (u n) x)) \\<longlongrightarrow> ereal 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. ereal (dist (u n) x)) \\<longlongrightarrow> ereal 0) F", "proof (rule tendsto_sandwich[of \"\\<lambda>_. 0\" _ _ \"\\<lambda>n. esqrt (extended_Gromov_distance (u n) x)\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F. 0 \\<le> ereal (dist (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       ereal (dist (u n) x) \\<le> esqrt (extended_Gromov_distance (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> ereal 0) F\n 4. ((\\<lambda>n.\n         esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n     ereal 0)\n     F", "have \"((\\<lambda>n. esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow> esqrt 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n     esqrt 0)\n     F", "by (intro tendsto_intros *)"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   esqrt 0)\n   F\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F. 0 \\<le> ereal (dist (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       ereal (dist (u n) x) \\<le> esqrt (extended_Gromov_distance (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> ereal 0) F\n 4. ((\\<lambda>n.\n         esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n     ereal 0)\n     F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   esqrt 0)\n   F", "show \"((\\<lambda>n. esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow> ereal 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   esqrt 0)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n     ereal 0)\n     F", "by (simp add: zero_ereal_def)"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   ereal 0)\n   F\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in F. 0 \\<le> ereal (dist (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       ereal (dist (u n) x) \\<le> esqrt (extended_Gromov_distance (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> ereal 0) F", "qed (auto simp add: Gromov_completion_dist_comparison zero_ereal_def)"], ["proof (state)\nthis:\n  ((\\<lambda>n. ereal (dist (u n) x)) \\<longlongrightarrow> ereal 0) F\n\ngoal (2 subgoals):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F\n 2. ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> x) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n. ereal (dist (u n) x)) \\<longlongrightarrow> ereal 0) F", "have \"((\\<lambda>n. real_of_ereal(ereal(dist (u n) x))) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n. ereal (dist (u n) x)) \\<longlongrightarrow> ereal 0) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         real_of_ereal (ereal (dist (u n) x))) \\<longlongrightarrow>\n     0)\n     F", "by (intro lim_real_of_ereal)"], ["proof (state)\nthis:\n  ((\\<lambda>n. real_of_ereal (ereal (dist (u n) x))) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (2 subgoals):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F\n 2. ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> x) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n. real_of_ereal (ereal (dist (u n) x))) \\<longlongrightarrow>\n   0)\n   F", "show \"(u \\<longlongrightarrow> x) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n. real_of_ereal (ereal (dist (u n) x))) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F", "by (subst tendsto_dist_iff, auto)"], ["proof (state)\nthis:\n  (u \\<longlongrightarrow> x) F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F", "assume *: \"(u \\<longlongrightarrow> x) F\""], ["proof (state)\nthis:\n  (u \\<longlongrightarrow> x) F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F", "have \"x \\<in> range to_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range to_Gromov_completion", "using assms"], ["proof (prove)\nusing this:\n  x \\<notin> Gromov_boundary\n\ngoal (1 subgoal):\n 1. x \\<in> range to_Gromov_completion", "unfolding Gromov_boundary_def"], ["proof (prove)\nusing this:\n  x \\<notin> UNIV - range to_Gromov_completion\n\ngoal (1 subgoal):\n 1. x \\<in> range to_Gromov_completion", "by auto"], ["proof (state)\nthis:\n  x \\<in> range to_Gromov_completion\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F", "have \"((\\<lambda>n. esqrt(extended_Gromov_distance (u n) x)) \\<longlongrightarrow> 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n     0)\n     F", "proof (rule tendsto_sandwich[of \"\\<lambda>_. 0\" _ _ \"\\<lambda>n. 2 * ereal(dist (u n) x)\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> esqrt (extended_Gromov_distance (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       esqrt (extended_Gromov_distance (u n) x)\n       \\<le> 2 * ereal (dist (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 4. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "have A: \"extended_Gromov_distance (to_Gromov_completion basepoint) x < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion basepoint) x\n    < \\<infinity>", "by (simp add: assms extended_Gromov_distance_def)"], ["proof (state)\nthis:\n  extended_Gromov_distance (to_Gromov_completion basepoint) x < \\<infinity>\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> esqrt (extended_Gromov_distance (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       esqrt (extended_Gromov_distance (u n) x)\n       \\<le> 2 * ereal (dist (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 4. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "obtain e where e: \"e > 0\" \"\\<And>y. dist x y \\<le> e \\<Longrightarrow> esqrt(extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>0 < e;\n         \\<And>y.\n            dist x y \\<le> e \\<Longrightarrow>\n            esqrt (extended_Gromov_distance x y)\n            \\<le> 2 * ereal (dist x y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inside_Gromov_distance_approx[OF A]"], ["proof (prove)\nusing this:\n  \\<exists>e>0.\n     \\<forall>xa y.\n        extended_Gromov_distance (to_Gromov_completion basepoint) xa\n        \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n               x \\<longrightarrow>\n        dist xa y \\<le> e \\<longrightarrow>\n        esqrt (extended_Gromov_distance xa y) \\<le> 2 * ereal (dist xa y)\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>0 < e;\n         \\<And>y.\n            dist x y \\<le> e \\<Longrightarrow>\n            esqrt (extended_Gromov_distance x y)\n            \\<le> 2 * ereal (dist x y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < e\n  dist x ?y \\<le> e \\<Longrightarrow>\n  esqrt (extended_Gromov_distance x ?y) \\<le> 2 * ereal (dist x ?y)\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> esqrt (extended_Gromov_distance (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       esqrt (extended_Gromov_distance (u n) x)\n       \\<le> 2 * ereal (dist (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 4. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "have B: \"eventually (\\<lambda>n. dist x (u n) < e) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F. dist x (u n) < e", "using order_tendstoD(2)[OF iffD1[OF tendsto_dist_iff *] \\<open>e > 0\\<close>]"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F xa in F. dist (u xa) x < e\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F. dist x (u n) < e", "by (simp add: dist_commute)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F. dist x (u n) < e\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> esqrt (extended_Gromov_distance (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       esqrt (extended_Gromov_distance (u n) x)\n       \\<le> 2 * ereal (dist (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 4. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in F. dist x (u n) < e", "have \"eventually (\\<lambda>n. esqrt(extended_Gromov_distance x (u n)) \\<le> 2 * ereal (dist x (u n))) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in F. dist x (u n) < e\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F.\n       esqrt (extended_Gromov_distance x (u n))\n       \\<le> 2 * ereal (dist x (u n))", "using eventually_mono[OF _ e(2)] less_imp_le"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in F. dist x (u n) < e\n  \\<lbrakk>eventually ?P ?F;\n   \\<And>xa. ?P xa \\<Longrightarrow> dist x (?y1 xa) \\<le> e\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F xa in ?F.\n                       esqrt (extended_Gromov_distance x (?y1 xa))\n                       \\<le> 2 * ereal (dist x (?y1 xa))\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F.\n       esqrt (extended_Gromov_distance x (u n))\n       \\<le> 2 * ereal (dist x (u n))", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F.\n     esqrt (extended_Gromov_distance x (u n)) \\<le> 2 * ereal (dist x (u n))\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> esqrt (extended_Gromov_distance (u n) x)\n 2. \\<forall>\\<^sub>F n in F.\n       esqrt (extended_Gromov_distance (u n) x)\n       \\<le> 2 * ereal (dist (u n) x)\n 3. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 4. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in F.\n     esqrt (extended_Gromov_distance x (u n)) \\<le> 2 * ereal (dist x (u n))", "show \"eventually (\\<lambda>n. esqrt(extended_Gromov_distance (u n) x) \\<le> 2 * ereal (dist (u n) x)) F\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in F.\n     esqrt (extended_Gromov_distance x (u n)) \\<le> 2 * ereal (dist x (u n))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in F.\n       esqrt (extended_Gromov_distance (u n) x)\n       \\<le> 2 * ereal (dist (u n) x)", "by (simp add: dist_commute extended_Gromov_distance_commute)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in F.\n     esqrt (extended_Gromov_distance (u n) x) \\<le> 2 * ereal (dist (u n) x)\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> esqrt (extended_Gromov_distance (u n) x)\n 2. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 3. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "have \"((\\<lambda>n. 2 * ereal(dist (u n) x)) \\<longlongrightarrow> 2 * ereal 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow>\n     2 * ereal 0)\n     F", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bar>2\\<bar> \\<noteq> \\<infinity>\n 2. ((\\<lambda>xa. dist (u xa) x) \\<longlongrightarrow> 0) F", "using tendsto_dist_iff *"], ["proof (prove)\nusing this:\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n  (u \\<longlongrightarrow> x) F\n\ngoal (2 subgoals):\n 1. \\<bar>2\\<bar> \\<noteq> \\<infinity>\n 2. ((\\<lambda>xa. dist (u xa) x) \\<longlongrightarrow> 0) F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 2 * ereal 0)\n   F\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> esqrt (extended_Gromov_distance (u n) x)\n 2. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F\n 3. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 2 * ereal 0)\n   F", "show \"((\\<lambda>n. 2 * ereal(dist (u n) x)) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 2 * ereal 0)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F", "by (simp add: zero_ereal_def)"], ["proof (state)\nthis:\n  ((\\<lambda>n. 2 * ereal (dist (u n) x)) \\<longlongrightarrow> 0) F\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in F.\n       0 \\<le> esqrt (extended_Gromov_distance (u n) x)\n 2. ((\\<lambda>_. 0) \\<longlongrightarrow> 0) F", "qed (auto)"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   0)\n   F", "have \"((\\<lambda>n. esqrt(extended_Gromov_distance (u n) x) * esqrt(extended_Gromov_distance (u n) x)) \\<longlongrightarrow> 0 * 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         esqrt (extended_Gromov_distance (u n) x) *\n         esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n     0 * 0)\n     F", "by (intro tendsto_intros, auto)"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x) *\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   0 * 0)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> x) F \\<Longrightarrow>\n    ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x) *\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   0 * 0)\n   F", "show \"((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       esqrt (extended_Gromov_distance (u n) x) *\n       esqrt (extended_Gromov_distance (u n) x)) \\<longlongrightarrow>\n   0 * 0)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0)\n     F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n. extended_Gromov_distance (u n) x) \\<longlongrightarrow> 0) F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_Gromov_completion_lim [simp, tendsto_intros]:\n  \"((\\<lambda>n. to_Gromov_completion (u n)) \\<longlongrightarrow> to_Gromov_completion a) F \\<longleftrightarrow> (u \\<longlongrightarrow> a) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. to_Gromov_completion (u n)) \\<longlongrightarrow>\n     to_Gromov_completion a)\n     F =\n    (u \\<longlongrightarrow> a) F", "proof (subst Gromov_completion_inside_limit, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> a) F\n 2. (u \\<longlongrightarrow> a) F \\<Longrightarrow>\n    ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F", "assume \"((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F\""], ["proof (state)\nthis:\n  ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F\n\ngoal (2 subgoals):\n 1. ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> a) F\n 2. (u \\<longlongrightarrow> a) F \\<Longrightarrow>\n    ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F", "have \"((\\<lambda>n. real_of_ereal(ereal (dist (u n) a))) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         real_of_ereal (ereal (dist (u n) a))) \\<longlongrightarrow>\n     0)\n     F", "unfolding zero_ereal_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> ereal 0) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         real_of_ereal (ereal (dist (u n) a))) \\<longlongrightarrow>\n     0)\n     F", "by (rule lim_real_of_ereal)"], ["proof (state)\nthis:\n  ((\\<lambda>n. real_of_ereal (ereal (dist (u n) a))) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (2 subgoals):\n 1. ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0)\n     F \\<Longrightarrow>\n    (u \\<longlongrightarrow> a) F\n 2. (u \\<longlongrightarrow> a) F \\<Longrightarrow>\n    ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n. real_of_ereal (ereal (dist (u n) a))) \\<longlongrightarrow>\n   0)\n   F", "show \"(u \\<longlongrightarrow> a) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n. real_of_ereal (ereal (dist (u n) a))) \\<longlongrightarrow>\n   0)\n   F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> a) F", "by (subst tendsto_dist_iff, auto)"], ["proof (state)\nthis:\n  (u \\<longlongrightarrow> a) F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> a) F \\<Longrightarrow>\n    ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> a) F \\<Longrightarrow>\n    ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F", "assume \"(u \\<longlongrightarrow> a) F\""], ["proof (state)\nthis:\n  (u \\<longlongrightarrow> a) F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> a) F \\<Longrightarrow>\n    ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F", "then"], ["proof (chain)\npicking this:\n  (u \\<longlongrightarrow> a) F", "have \"((\\<lambda>n. dist (u n) a) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  (u \\<longlongrightarrow> a) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. dist (u n) a) \\<longlongrightarrow> 0) F", "using tendsto_dist_iff"], ["proof (prove)\nusing this:\n  (u \\<longlongrightarrow> a) F\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. dist (u n) a) \\<longlongrightarrow> 0) F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n. dist (u n) a) \\<longlongrightarrow> 0) F\n\ngoal (1 subgoal):\n 1. (u \\<longlongrightarrow> a) F \\<Longrightarrow>\n    ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n. dist (u n) a) \\<longlongrightarrow> 0) F", "show \"((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F\""], ["proof (prove)\nusing this:\n  ((\\<lambda>n. dist (u n) a) \\<longlongrightarrow> 0) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F", "unfolding zero_ereal_def"], ["proof (prove)\nusing this:\n  ((\\<lambda>n. dist (u n) a) \\<longlongrightarrow> 0) F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> ereal 0) F", "by (intro tendsto_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>n. ereal (dist (u n) a)) \\<longlongrightarrow> 0) F\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now, we can also come back to our original definition of the completion, where points on the\nboundary correspond to equivalence classes of sequences whose mutual Gromov product tends to\ninfinity. We show that this is compatible with our topology: the sequences that are in the equivalence\nclass of a point on the boundary are exactly the sequences that converge to this point. This is also\na direct consequence of the definitions, although the proof requires some unfolding (and playing\nwith the hyperbolicity inequality several times).\\<close>"], ["", "text \\<open>First, we show that a sequence in the equivalence class of $x$ converges to $x$.\\<close>"], ["", "lemma Gromov_completion_converge_to_boundary_aux:\n  assumes \"x \\<in> Gromov_boundary\" \"abs_Gromov_completion v = x\" \"Gromov_completion_rel v v\"\n  shows \"(\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "have A: \"eventually (\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x \\<ge> ereal M) sequentially\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal M\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v n)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal M\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v n)) x", "have \"Gromov_converging_at_boundary v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary v", "using Gromov_boundary_abs_converging assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> Gromov_boundary; abs_Gromov_completion ?u = ?x;\n   Gromov_completion_rel ?u ?u\\<rbrakk>\n  \\<Longrightarrow> Gromov_converging_at_boundary ?u\n  x \\<in> Gromov_boundary\n  abs_Gromov_completion v = x\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary v", "by blast"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal M\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v n)) x", "then"], ["proof (chain)\npicking this:\n  Gromov_converging_at_boundary v", "obtain N where N: \"\\<And>m n. m \\<ge> N \\<Longrightarrow> n \\<ge> N \\<Longrightarrow> Gromov_product_at basepoint (v m) (v n) \\<ge> M + deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> m; N \\<le> n\\<rbrakk>\n            \\<Longrightarrow> M + deltaG TYPE('a)\n                              \\<le> Gromov_product_at basepoint (v m)\n                                     (v n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Gromov_converging_at_boundary_def"], ["proof (prove)\nusing this:\n  \\<forall>a M.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (v m) (v n)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> m; N \\<le> n\\<rbrakk>\n            \\<Longrightarrow> M + deltaG TYPE('a)\n                              \\<le> Gromov_product_at basepoint (v m)\n                                     (v n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> M + deltaG TYPE('a)\n                    \\<le> Gromov_product_at basepoint (v ?m) (v ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal M\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v n)) x", "have \"extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x \\<ge> ereal M\" if \"n \\<ge> N\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n           x", "unfolding extended_Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M\n    \\<le> Inf {liminf\n                (\\<lambda>n.\n                    ereal (Gromov_product_at basepoint (u n) (va n))) |\n               u va.\n               abs_Gromov_completion u = to_Gromov_completion (v n) \\<and>\n               abs_Gromov_completion va = x \\<and>\n               Gromov_completion_rel u u \\<and> Gromov_completion_rel va va}", "proof (rule Inf_greatest, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "fix wv wx"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "assume H: \"abs_Gromov_completion wv = to_Gromov_completion (v n)\"\n                          \"x = abs_Gromov_completion wx\"\n                          \"Gromov_completion_rel wv wv\" \"Gromov_completion_rel wx wx\""], ["proof (state)\nthis:\n  abs_Gromov_completion wv = to_Gromov_completion (v n)\n  x = abs_Gromov_completion wx\n  Gromov_completion_rel wv wv\n  Gromov_completion_rel wx wx\n\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion wv = to_Gromov_completion (v n)\n  x = abs_Gromov_completion wx\n  Gromov_completion_rel wv wv\n  Gromov_completion_rel wx wx", "have wv: \"wv p = v n\" for p"], ["proof (prove)\nusing this:\n  abs_Gromov_completion wv = to_Gromov_completion (v n)\n  x = abs_Gromov_completion wx\n  Gromov_completion_rel wv wv\n  Gromov_completion_rel wx wx\n\ngoal (1 subgoal):\n 1. wv p = v n", "using Gromov_completion_rel_to_const Quotient3_Gromov_completion Quotient3_rel to_Gromov_completion_def"], ["proof (prove)\nusing this:\n  abs_Gromov_completion wv = to_Gromov_completion (v n)\n  x = abs_Gromov_completion wx\n  Gromov_completion_rel wv wv\n  Gromov_completion_rel wx wx\n  Gromov_completion_rel ?u (\\<lambda>n. ?x) \\<Longrightarrow> ?u ?n = ?x\n  Quotient3 Gromov_completion_rel abs_Gromov_completion\n   rep_Gromov_completion\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow>\n  (?R ?r ?r \\<and> ?R ?s ?s \\<and> ?Abs ?r = ?Abs ?s) = ?R ?r ?s\n  to_Gromov_completion ?x = abs_Gromov_completion (\\<lambda>n. ?x)\n\ngoal (1 subgoal):\n 1. wv p = v n", "by fastforce"], ["proof (state)\nthis:\n  wv ?p = v n\n\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "have \"Gromov_completion_rel v wx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel v wx", "using assms H Quotient3_rel[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary\n  abs_Gromov_completion v = x\n  Gromov_completion_rel v v\n  abs_Gromov_completion wv = to_Gromov_completion (v n)\n  x = abs_Gromov_completion wx\n  Gromov_completion_rel wv wv\n  Gromov_completion_rel wx wx\n  (Gromov_completion_rel ?r ?r \\<and>\n   Gromov_completion_rel ?s ?s \\<and>\n   abs_Gromov_completion ?r = abs_Gromov_completion ?s) =\n  Gromov_completion_rel ?r ?s\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel v wx", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel v wx\n\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel v wx", "have *: \"(\\<lambda>p. Gromov_product_at basepoint (v p) (wx p)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  Gromov_completion_rel v wx\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at basepoint (v x) (wx x)))\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary v \\<and>\n  Gromov_converging_at_boundary wx \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (v x) (wx x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. v n = wx m \\<and> v n = v m \\<and> wx n = wx m)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at basepoint (v x) (wx x)))\n    \\<longlonglongrightarrow> \\<infinity>", "using Gromov_converging_at_boundary_imp_not_constant' \\<open>Gromov_converging_at_boundary v\\<close>"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary v \\<and>\n  Gromov_converging_at_boundary wx \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (v x) (wx x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. v n = wx m \\<and> v n = v m \\<and> wx n = wx m)\n  Gromov_converging_at_boundary ?u \\<Longrightarrow>\n  \\<not> (\\<forall>m n. ?u m = ?u n)\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at basepoint (v x) (wx x)))\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at basepoint (v x) (wx x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "have \"eventually (\\<lambda>p. ereal(Gromov_product_at basepoint (v p) (wx p)) > M + deltaG(TYPE('a))) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially.\n       ereal (M + deltaG TYPE('a))\n       < ereal (Gromov_product_at basepoint (v p) (wx p))", "using order_tendstoD[OF *, of \"ereal (M + deltaG TYPE('a))\"]"], ["proof (prove)\nusing this:\n  ereal (M + deltaG TYPE('a)) < \\<infinity> \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in sequentially.\n     ereal (M + deltaG TYPE('a))\n     < ereal (Gromov_product_at basepoint (v x) (wx x))\n  \\<infinity> < ereal (M + deltaG TYPE('a)) \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in sequentially.\n     ereal (Gromov_product_at basepoint (v x) (wx x))\n     < ereal (M + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially.\n       ereal (M + deltaG TYPE('a))\n       < ereal (Gromov_product_at basepoint (v p) (wx p))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially.\n     ereal (M + deltaG TYPE('a))\n     < ereal (Gromov_product_at basepoint (v p) (wx p))\n\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F p in sequentially.\n     ereal (M + deltaG TYPE('a))\n     < ereal (Gromov_product_at basepoint (v p) (wx p))", "obtain P where P: \"\\<And>p. p \\<ge> P \\<Longrightarrow> ereal(Gromov_product_at basepoint (v p) (wx p)) > M + deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially.\n     ereal (M + deltaG TYPE('a))\n     < ereal (Gromov_product_at basepoint (v p) (wx p))\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        (\\<And>p.\n            P \\<le> p \\<Longrightarrow>\n            ereal (M + deltaG TYPE('a))\n            < ereal\n               (Gromov_product_at basepoint (v p) (wx p))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        ereal (M + deltaG TYPE('a))\n        < ereal (Gromov_product_at basepoint (v n) (wx n))\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        (\\<And>p.\n            P \\<le> p \\<Longrightarrow>\n            ereal (M + deltaG TYPE('a))\n            < ereal\n               (Gromov_product_at basepoint (v p) (wx p))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P \\<le> ?p \\<Longrightarrow>\n  ereal (M + deltaG TYPE('a))\n  < ereal (Gromov_product_at basepoint (v ?p) (wx ?p))\n\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "have *: \"ereal (Gromov_product_at basepoint (v n) (wx p)) \\<ge> ereal M\" if \"p \\<ge> max P N\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx p))", "proof (intro mono_intros)"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v n) (wx p)", "have \"M \\<le> min (M + deltaG(TYPE('a))) (M + deltaG(TYPE('a))) - deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> min (M + deltaG TYPE('a)) (M + deltaG TYPE('a)) -\n            deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  M \\<le> min (M + deltaG TYPE('a)) (M + deltaG TYPE('a)) - deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v n) (wx p)", "also"], ["proof (state)\nthis:\n  M \\<le> min (M + deltaG TYPE('a)) (M + deltaG TYPE('a)) - deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v n) (wx p)", "have \"... \\<le> min (Gromov_product_at basepoint (v n) (v p)) (Gromov_product_at basepoint (v p) (wx p)) - deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (M + deltaG TYPE('a)) (M + deltaG TYPE('a)) - deltaG TYPE('a)\n    \\<le> min (Gromov_product_at basepoint (v n) (v p))\n           (Gromov_product_at basepoint (v p) (wx p)) -\n          deltaG TYPE('a)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. M + deltaG TYPE('a) \\<le> Gromov_product_at basepoint (v n) (v p)\n 2. M + deltaG TYPE('a) \\<le> Gromov_product_at basepoint (v p) (wx p)", "using N[OF \\<open>n \\<ge> N\\<close>, of p] \\<open>p \\<ge> max P N\\<close> P[of p] \\<open>p \\<ge> max P N\\<close>"], ["proof (prove)\nusing this:\n  N \\<le> p \\<Longrightarrow>\n  M + deltaG TYPE('a) \\<le> Gromov_product_at basepoint (v n) (v p)\n  max P N \\<le> p\n  P \\<le> p \\<Longrightarrow>\n  ereal (M + deltaG TYPE('a))\n  < ereal (Gromov_product_at basepoint (v p) (wx p))\n  max P N \\<le> p\n\ngoal (2 subgoals):\n 1. M + deltaG TYPE('a) \\<le> Gromov_product_at basepoint (v n) (v p)\n 2. M + deltaG TYPE('a) \\<le> Gromov_product_at basepoint (v p) (wx p)", "by auto"], ["proof (state)\nthis:\n  min (M + deltaG TYPE('a)) (M + deltaG TYPE('a)) - deltaG TYPE('a)\n  \\<le> min (Gromov_product_at basepoint (v n) (v p))\n         (Gromov_product_at basepoint (v p) (wx p)) -\n        deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v n) (wx p)", "also"], ["proof (state)\nthis:\n  min (M + deltaG TYPE('a)) (M + deltaG TYPE('a)) - deltaG TYPE('a)\n  \\<le> min (Gromov_product_at basepoint (v n) (v p))\n         (Gromov_product_at basepoint (v p) (wx p)) -\n        deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v n) (wx p)", "have \"... \\<le> Gromov_product_at basepoint (v n) (wx p) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at basepoint (v n) (v p))\n     (Gromov_product_at basepoint (v p) (wx p)) -\n    deltaG TYPE('a)\n    \\<le> Gromov_product_at basepoint (v n) (wx p)", "by (rule hyperb_ineq)"], ["proof (state)\nthis:\n  min (Gromov_product_at basepoint (v n) (v p))\n   (Gromov_product_at basepoint (v p) (wx p)) -\n  deltaG TYPE('a)\n  \\<le> Gromov_product_at basepoint (v n) (wx p)\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v n) (wx p)", "finally"], ["proof (chain)\npicking this:\n  M \\<le> Gromov_product_at basepoint (v n) (wx p)", "show \"M \\<le> Gromov_product_at basepoint (v n) (wx p) \""], ["proof (prove)\nusing this:\n  M \\<le> Gromov_product_at basepoint (v n) (wx p)\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v n) (wx p)", "by simp"], ["proof (state)\nthis:\n  M \\<le> Gromov_product_at basepoint (v n) (wx p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max P N \\<le> ?p \\<Longrightarrow>\n  ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx ?p))\n\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "then"], ["proof (chain)\npicking this:\n  max P N \\<le> ?p \\<Longrightarrow>\n  ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx ?p))", "have \"eventually (\\<lambda>p. ereal (Gromov_product_at basepoint (v n) (wx p)) \\<ge> ereal M) sequentially\""], ["proof (prove)\nusing this:\n  max P N \\<le> ?p \\<Longrightarrow>\n  ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx ?p))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially.\n       ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx p))", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  max P N \\<le> ?p \\<Longrightarrow>\n  ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx ?p))\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>na\\<ge>N.\n          ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx na))", "by metis"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially.\n     ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx p))\n\ngoal (1 subgoal):\n 1. \\<And>u va.\n       \\<lbrakk>abs_Gromov_completion u = to_Gromov_completion (v n);\n        x = abs_Gromov_completion va; Gromov_completion_rel u u;\n        Gromov_completion_rel va va\\<rbrakk>\n       \\<Longrightarrow> ereal M\n                         \\<le> liminf\n                                (\\<lambda>n.\n                                    ereal\n                                     (Gromov_product_at basepoint (u n)\n (va n)))", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F p in sequentially.\n     ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx p))", "show \"ereal M \\<le> liminf (\\<lambda>p. ereal (Gromov_product_at basepoint (wv p) (wx p)))\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially.\n     ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx p))\n\ngoal (1 subgoal):\n 1. ereal M\n    \\<le> liminf\n           (\\<lambda>p. ereal (Gromov_product_at basepoint (wv p) (wx p)))", "unfolding wv"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially.\n     ereal M \\<le> ereal (Gromov_product_at basepoint (v n) (wx p))\n\ngoal (1 subgoal):\n 1. ereal M\n    \\<le> liminf\n           (\\<lambda>p. ereal (Gromov_product_at basepoint (v n) (wx p)))", "by (simp add: Liminf_bounded)"], ["proof (state)\nthis:\n  ereal M\n  \\<le> liminf\n         (\\<lambda>p. ereal (Gromov_product_at basepoint (wv p) (wx p)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N \\<le> ?n \\<Longrightarrow>\n  ereal M\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v ?n)) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal M\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v n)) x", "then"], ["proof (chain)\npicking this:\n  N \\<le> ?n \\<Longrightarrow>\n  ereal M\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v ?n)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  N \\<le> ?n \\<Longrightarrow>\n  ereal M\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v ?n)) x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal M\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v n)) x", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  N \\<le> ?n \\<Longrightarrow>\n  ereal M\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v ?n)) x\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          ereal M\n          \\<le> extended_Gromov_product_at basepoint\n                 (to_Gromov_completion (v n)) x", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     ereal M\n     \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     ereal ?M\n     \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "have B: \"eventually (\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x > M) sequentially\" if \"M < \\<infinity>\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x", "obtain N where \"ereal N > M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N. M < ereal N \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>M < \\<infinity>\\<close> ereal_dense2"], ["proof (prove)\nusing this:\n  M < \\<infinity>\n  ?x < ?y \\<Longrightarrow> \\<exists>z. ?x < ereal z \\<and> ereal z < ?y\n\ngoal (1 subgoal):\n 1. (\\<And>N. M < ereal N \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  M < ereal N\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x", "then"], ["proof (chain)\npicking this:\n  M < ereal N", "have \"a \\<ge> ereal N \\<Longrightarrow> a > M\" for a"], ["proof (prove)\nusing this:\n  M < ereal N\n\ngoal (1 subgoal):\n 1. ereal N \\<le> a \\<Longrightarrow> M < a", "by auto"], ["proof (state)\nthis:\n  ereal N \\<le> ?a \\<Longrightarrow> M < ?a\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x", "then"], ["proof (chain)\npicking this:\n  ereal N \\<le> ?a \\<Longrightarrow> M < ?a", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal N \\<le> ?a \\<Longrightarrow> M < ?a\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x", "using A[of N] eventually_elim2"], ["proof (prove)\nusing this:\n  ereal N \\<le> ?a \\<Longrightarrow> M < ?a\n  \\<forall>\\<^sub>F n in sequentially.\n     ereal N\n     \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x\n  \\<lbrakk>eventually ?P ?F; eventually ?Q ?F;\n   \\<And>i. \\<lbrakk>?P i; ?Q i\\<rbrakk> \\<Longrightarrow> ?R i\\<rbrakk>\n  \\<Longrightarrow> eventually ?R ?F\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x", "by force"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?M < \\<infinity> \\<Longrightarrow>\n  \\<forall>\\<^sub>F n in sequentially.\n     ?M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n           x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  ?M < \\<infinity> \\<Longrightarrow>\n  \\<forall>\\<^sub>F n in sequentially.\n     ?M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n           x", "show ?thesis"], ["proof (prove)\nusing this:\n  ?M < \\<infinity> \\<Longrightarrow>\n  \\<forall>\\<^sub>F n in sequentially.\n     ?M < extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n           x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "by (rule order_tendstoI, auto)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Then, we prove the converse and therefore the equivalence.\\<close>"], ["", "lemma Gromov_completion_converge_to_boundary:\n  assumes \"x \\<in> Gromov_boundary\"\n  shows \"((\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x) \\<longleftrightarrow> (Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x =\n    (Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x\n 2. Gromov_completion_rel u u \\<and>\n    abs_Gromov_completion u = x \\<Longrightarrow>\n    (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x", "assume \"Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x\""], ["proof (state)\nthis:\n  Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x\n 2. Gromov_completion_rel u u \\<and>\n    abs_Gromov_completion u = x \\<Longrightarrow>\n    (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "show \"((\\<lambda>n. to_Gromov_completion(u n)) \\<longlonglongrightarrow> x)\""], ["proof (prove)\nusing this:\n  Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x", "using Gromov_completion_converge_to_boundary_aux[OF assms, of u]"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x\n  \\<lbrakk>abs_Gromov_completion u = x; Gromov_completion_rel u u\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>n.\n                        extended_Gromov_product_at basepoint\n                         (to_Gromov_completion (u n)) x)\n                    \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x", "unfolding Gromov_completion_boundary_limit[OF assms]"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x\n  \\<lbrakk>abs_Gromov_completion u = x; Gromov_completion_rel u u\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>n.\n                        extended_Gromov_product_at basepoint\n                         (to_Gromov_completion (u n)) x)\n                    \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "assume H: \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\""], ["proof (state)\nthis:\n  (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "have Lu: \"(\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "using iffD1[OF Gromov_completion_boundary_limit[OF assms] H]"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "have A: \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall> m \\<ge> N. Gromov_product_at basepoint (u m) (u n) \\<ge> M\" for M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (u m) (u n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (u m) (u n)", "have \"eventually (\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x > M + deltaG(TYPE('a))) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (M + deltaG TYPE('a))\n       < extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x", "by (rule order_tendstoD[OF Lu], auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     ereal (M + deltaG TYPE('a))\n     < extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     ereal (M + deltaG TYPE('a))\n     < extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x", "obtain N where N: \"\\<And>n. n \\<ge> N \\<Longrightarrow> extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x > M + deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     ereal (M + deltaG TYPE('a))\n     < extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            ereal (M + deltaG TYPE('a))\n            < extended_Gromov_product_at basepoint\n               (to_Gromov_completion (u n)) x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        ereal (M + deltaG TYPE('a))\n        < extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n           x\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            ereal (M + deltaG TYPE('a))\n            < extended_Gromov_product_at basepoint\n               (to_Gromov_completion (u n)) x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<le> ?n \\<Longrightarrow>\n  ereal (M + deltaG TYPE('a))\n  < extended_Gromov_product_at basepoint (to_Gromov_completion (u ?n)) x\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (u m) (u n)", "have \"Gromov_product_at basepoint (u m) (u n) \\<ge> M\" if \"n \\<ge> N\" \"m \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (u m) (u n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (u m) (u n)", "have \"ereal M \\<le> min (ereal (M + deltaG(TYPE('a)))) (ereal (M + deltaG(TYPE('a)))) - ereal(deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M\n    \\<le> min (ereal (M + deltaG TYPE('a))) (ereal (M + deltaG TYPE('a))) -\n          ereal (deltaG TYPE('a))", "by simp"], ["proof (state)\nthis:\n  ereal M\n  \\<le> min (ereal (M + deltaG TYPE('a))) (ereal (M + deltaG TYPE('a))) -\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (u m) (u n)", "also"], ["proof (state)\nthis:\n  ereal M\n  \\<le> min (ereal (M + deltaG TYPE('a))) (ereal (M + deltaG TYPE('a))) -\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (u m) (u n)", "have \"... \\<le> min (extended_Gromov_product_at basepoint (to_Gromov_completion (u m)) x) (extended_Gromov_product_at basepoint x (to_Gromov_completion (u n))) - deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (ereal (M + deltaG TYPE('a))) (ereal (M + deltaG TYPE('a))) -\n    ereal (deltaG TYPE('a))\n    \\<le> min (extended_Gromov_product_at basepoint\n                (to_Gromov_completion (u m)) x)\n           (extended_Gromov_product_at basepoint x\n             (to_Gromov_completion (u n))) -\n          ereal (deltaG TYPE('a))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ereal (M + deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (u m))\n           x\n 2. ereal (M + deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at basepoint x\n           (to_Gromov_completion (u n))\n 3. deltaG TYPE('a) \\<le> deltaG TYPE('a)", "using N[OF \\<open>n \\<ge> N\\<close>] N[OF \\<open>m \\<ge> N\\<close>]"], ["proof (prove)\nusing this:\n  ereal (M + deltaG TYPE('a))\n  < extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n  ereal (M + deltaG TYPE('a))\n  < extended_Gromov_product_at basepoint (to_Gromov_completion (u m)) x\n\ngoal (3 subgoals):\n 1. ereal (M + deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (u m))\n           x\n 2. ereal (M + deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at basepoint x\n           (to_Gromov_completion (u n))\n 3. deltaG TYPE('a) \\<le> deltaG TYPE('a)", "by (auto simp add: extended_Gromov_product_at_commute)"], ["proof (state)\nthis:\n  min (ereal (M + deltaG TYPE('a))) (ereal (M + deltaG TYPE('a))) -\n  ereal (deltaG TYPE('a))\n  \\<le> min (extended_Gromov_product_at basepoint\n              (to_Gromov_completion (u m)) x)\n         (extended_Gromov_product_at basepoint x\n           (to_Gromov_completion (u n))) -\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (u m) (u n)", "also"], ["proof (state)\nthis:\n  min (ereal (M + deltaG TYPE('a))) (ereal (M + deltaG TYPE('a))) -\n  ereal (deltaG TYPE('a))\n  \\<le> min (extended_Gromov_product_at basepoint\n              (to_Gromov_completion (u m)) x)\n         (extended_Gromov_product_at basepoint x\n           (to_Gromov_completion (u n))) -\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (u m) (u n)", "have \"... \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (u m)) (to_Gromov_completion (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (extended_Gromov_product_at basepoint (to_Gromov_completion (u m))\n          x)\n     (extended_Gromov_product_at basepoint x (to_Gromov_completion (u n))) -\n    ereal (deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (u m))\n           (to_Gromov_completion (u n))", "by (rule extended_hyperb_ineq)"], ["proof (state)\nthis:\n  min (extended_Gromov_product_at basepoint (to_Gromov_completion (u m)) x)\n   (extended_Gromov_product_at basepoint x (to_Gromov_completion (u n))) -\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (u m))\n         (to_Gromov_completion (u n))\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (u m) (u n)", "finally"], ["proof (chain)\npicking this:\n  ereal M\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (u m))\n         (to_Gromov_completion (u n))", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal M\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (u m))\n         (to_Gromov_completion (u n))\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  M \\<le> Gromov_product_at basepoint (u m) (u n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at basepoint (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at basepoint (u ?m) (u ?n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at basepoint (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (u m) (u n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. ?M \\<le> Gromov_product_at basepoint (u m) (u n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "have \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall> m \\<ge> N. Gromov_product_at a (u m) (u n) \\<ge> M\" for M a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "obtain N where N: \"\\<And>m n. m \\<ge> N \\<Longrightarrow> n \\<ge> N \\<Longrightarrow> Gromov_product_at basepoint (u m) (u n) \\<ge> M + dist a basepoint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> m; N \\<le> n\\<rbrakk>\n            \\<Longrightarrow> M + dist a basepoint\n                              \\<le> Gromov_product_at basepoint (u m)\n                                     (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using A[of \"M + dist a basepoint\"]"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N.\n           M + dist a basepoint\n           \\<le> Gromov_product_at basepoint (u m) (u n)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> m; N \\<le> n\\<rbrakk>\n            \\<Longrightarrow> M + dist a basepoint\n                              \\<le> Gromov_product_at basepoint (u m)\n                                     (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> M + dist a basepoint\n                    \\<le> Gromov_product_at basepoint (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "have \"Gromov_product_at a (u m) (u n) \\<ge> M\" if \"m \\<ge> N\" \"n \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at a (u m) (u n)", "using N[OF that] Gromov_product_at_diff1[of a \"u m\" \"u n\" basepoint]"], ["proof (prove)\nusing this:\n  M + dist a basepoint \\<le> Gromov_product_at basepoint (u m) (u n)\n  \\<bar>Gromov_product_at a (u m) (u n) -\n        Gromov_product_at basepoint (u m) (u n)\\<bar>\n  \\<le> dist a basepoint\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at a (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at a (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at a (u ?m) (u ?n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at a (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. ?M \\<le> Gromov_product_at ?a (u m) (u n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. ?M \\<le> Gromov_product_at ?a (u m) (u n)", "have \"Gromov_converging_at_boundary u\""], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. ?M \\<le> Gromov_product_at ?a (u m) (u n)\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "unfolding Gromov_converging_at_boundary_def"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. ?M \\<le> Gromov_product_at ?a (u m) (u n)\n\ngoal (1 subgoal):\n 1. \\<forall>a M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  Gromov_converging_at_boundary u", "have \"Gromov_completion_rel u u\""], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u", "using Gromov_converging_at_boundary_rel"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary ?u \\<Longrightarrow>\n  Gromov_completion_rel ?u ?u\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u u\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "define v where \"v = rep_Gromov_completion x\""], ["proof (state)\nthis:\n  v = rep_Gromov_completion x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  v = rep_Gromov_completion x", "have \"Gromov_converging_at_boundary v\""], ["proof (prove)\nusing this:\n  v = rep_Gromov_completion x\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary v", "using Gromov_boundary_rep_converging[OF assms]"], ["proof (prove)\nusing this:\n  v = rep_Gromov_completion x\n  Gromov_converging_at_boundary (rep_Gromov_completion x)\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary v", "by auto"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "have v: \"abs_Gromov_completion v = x\" \"Gromov_completion_rel v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion v = x &&& Gromov_completion_rel v v", "using Quotient3_abs_rep[OF Quotient3_Gromov_completion] Quotient3_rep_reflp[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  abs_Gromov_completion (rep_Gromov_completion ?a) = ?a\n  Gromov_completion_rel (rep_Gromov_completion ?a)\n   (rep_Gromov_completion ?a)\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion v = x &&& Gromov_completion_rel v v", "unfolding v_def"], ["proof (prove)\nusing this:\n  abs_Gromov_completion (rep_Gromov_completion ?a) = ?a\n  Gromov_completion_rel (rep_Gromov_completion ?a)\n   (rep_Gromov_completion ?a)\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion (rep_Gromov_completion x) = x &&&\n    Gromov_completion_rel (rep_Gromov_completion x)\n     (rep_Gromov_completion x)", "by auto"], ["proof (state)\nthis:\n  abs_Gromov_completion v = x\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion v = x\n  Gromov_completion_rel v v", "have Lv: \"(\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  abs_Gromov_completion v = x\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "using Gromov_completion_converge_to_boundary_aux[OF assms]"], ["proof (prove)\nusing this:\n  abs_Gromov_completion v = x\n  Gromov_completion_rel v v\n  \\<lbrakk>abs_Gromov_completion ?v = x;\n   Gromov_completion_rel ?v ?v\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>n.\n                        extended_Gromov_product_at basepoint\n                         (to_Gromov_completion (?v n)) x)\n                    \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "have *: \"(\\<lambda>n. min (extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x) (extended_Gromov_product_at basepoint x (to_Gromov_completion (v n))) -\n          ereal (deltaG TYPE('a))) \\<longlonglongrightarrow> min \\<infinity> \\<infinity> - ereal (deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        min (extended_Gromov_product_at basepoint\n              (to_Gromov_completion (u n)) x)\n         (extended_Gromov_product_at basepoint x\n           (to_Gromov_completion (v n))) -\n        ereal (deltaG TYPE('a)))\n    \\<longlonglongrightarrow> min \\<infinity> \\<infinity> -\n                              ereal (deltaG TYPE('a))", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>xa.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u xa))\n         x)\n    \\<longlonglongrightarrow> \\<infinity>\n 2. (\\<lambda>xa.\n        extended_Gromov_product_at basepoint x\n         (to_Gromov_completion (v xa)))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. \\<not> (min \\<infinity> \\<infinity> = \\<infinity> \\<and>\n            ereal (deltaG TYPE('a)) = \\<infinity> \\<or>\n            min \\<infinity> \\<infinity> = - \\<infinity> \\<and>\n            ereal (deltaG TYPE('a)) = - \\<infinity>)", "using Lu Lv"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x)\n  \\<longlonglongrightarrow> \\<infinity>\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (3 subgoals):\n 1. (\\<lambda>xa.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u xa))\n         x)\n    \\<longlonglongrightarrow> \\<infinity>\n 2. (\\<lambda>xa.\n        extended_Gromov_product_at basepoint x\n         (to_Gromov_completion (v xa)))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. \\<not> (min \\<infinity> \\<infinity> = \\<infinity> \\<and>\n            ereal (deltaG TYPE('a)) = \\<infinity> \\<or>\n            min \\<infinity> \\<infinity> = - \\<infinity> \\<and>\n            ereal (deltaG TYPE('a)) = - \\<infinity>)", "by (auto simp add: extended_Gromov_product_at_commute)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      min (extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n            x)\n       (extended_Gromov_product_at basepoint x\n         (to_Gromov_completion (v n))) -\n      ereal (deltaG TYPE('a)))\n  \\<longlonglongrightarrow> min \\<infinity> \\<infinity> -\n                            ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "have \"(\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) (to_Gromov_completion (v n))) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n         (to_Gromov_completion (v n)))\n    \\<longlonglongrightarrow> \\<infinity>", "apply (rule tendsto_sandwich[of \"\\<lambda>n. min (extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x)\n                                              (extended_Gromov_product_at basepoint x (to_Gromov_completion (v n))) - deltaG(TYPE('a))\" _ _ \"\\<lambda>_. \\<infinity>\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       min (extended_Gromov_product_at basepoint\n             (to_Gromov_completion (u n)) x)\n        (extended_Gromov_product_at basepoint x\n          (to_Gromov_completion (v n))) -\n       ereal (deltaG TYPE('a))\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (u n)) (to_Gromov_completion (v n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n        (to_Gromov_completion (v n))\n       \\<le> \\<infinity>\n 3. (\\<lambda>n.\n        min (extended_Gromov_product_at basepoint\n              (to_Gromov_completion (u n)) x)\n         (extended_Gromov_product_at basepoint x\n           (to_Gromov_completion (v n))) -\n        ereal (deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>_. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "using extended_hyperb_ineq not_eventuallyD"], ["proof (prove)\nusing this:\n  min (extended_Gromov_product_at ?e ?x ?y)\n   (extended_Gromov_product_at ?e ?y ?z) -\n  ereal (deltaG TYPE(?'a))\n  \\<le> extended_Gromov_product_at ?e ?x ?z\n  \\<not> eventually ?P ?F \\<Longrightarrow> \\<exists>x. \\<not> ?P x\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       min (extended_Gromov_product_at basepoint\n             (to_Gromov_completion (u n)) x)\n        (extended_Gromov_product_at basepoint x\n          (to_Gromov_completion (v n))) -\n       ereal (deltaG TYPE('a))\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (u n)) (to_Gromov_completion (v n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n        (to_Gromov_completion (v n))\n       \\<le> \\<infinity>\n 3. (\\<lambda>n.\n        min (extended_Gromov_product_at basepoint\n              (to_Gromov_completion (u n)) x)\n         (extended_Gromov_product_at basepoint x\n           (to_Gromov_completion (v n))) -\n        ereal (deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>_. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n        (to_Gromov_completion (v n))\n       \\<le> \\<infinity>\n 2. (\\<lambda>n.\n        min (extended_Gromov_product_at basepoint\n              (to_Gromov_completion (u n)) x)\n         (extended_Gromov_product_at basepoint x\n           (to_Gromov_completion (v n))) -\n        ereal (deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>_. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "using *"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      min (extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n            x)\n       (extended_Gromov_product_at basepoint x\n         (to_Gromov_completion (v n))) -\n      ereal (deltaG TYPE('a)))\n  \\<longlonglongrightarrow> min \\<infinity> \\<infinity> -\n                            ereal (deltaG TYPE('a))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n        (to_Gromov_completion (v n))\n       \\<le> \\<infinity>\n 2. (\\<lambda>n.\n        min (extended_Gromov_product_at basepoint\n              (to_Gromov_completion (u n)) x)\n         (extended_Gromov_product_at basepoint x\n           (to_Gromov_completion (v n))) -\n        ereal (deltaG TYPE('a)))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>_. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n       (to_Gromov_completion (v n)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n       (to_Gromov_completion (v n)))\n  \\<longlonglongrightarrow> \\<infinity>", "have \"(\\<lambda>n. Gromov_product_at basepoint (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n       (to_Gromov_completion (v n)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at basepoint (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at basepoint (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. ereal (Gromov_product_at basepoint (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>", "have \"(\\<lambda>n. Gromov_product_at a (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\" for a"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at basepoint (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "using Gromov_product_tendsto_PInf_a_b"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at basepoint (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  (\\<lambda>x. ereal (Gromov_product_at ?a (?u x) (?v x)))\n  \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n  (\\<lambda>x. ereal (Gromov_product_at ?b (?u x) (?v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>", "have \"Gromov_completion_rel u v\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary v \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)", "using \\<open>Gromov_converging_at_boundary u\\<close> \\<open>Gromov_converging_at_boundary v\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary v \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u v\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel u v", "have \"abs_Gromov_completion u = abs_Gromov_completion v\""], ["proof (prove)\nusing this:\n  Gromov_completion_rel u v\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion u = abs_Gromov_completion v", "using Quotient3_rel[OF Quotient3_Gromov_completion] v(2) \\<open>Gromov_completion_rel u u\\<close>"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u v\n  (Gromov_completion_rel ?r ?r \\<and>\n   Gromov_completion_rel ?s ?s \\<and>\n   abs_Gromov_completion ?r = abs_Gromov_completion ?s) =\n  Gromov_completion_rel ?r ?s\n  Gromov_completion_rel v v\n  Gromov_completion_rel u u\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion u = abs_Gromov_completion v", "by auto"], ["proof (state)\nthis:\n  abs_Gromov_completion u = abs_Gromov_completion v\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion u = abs_Gromov_completion v", "have \"abs_Gromov_completion u = x\""], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = abs_Gromov_completion v\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion u = x", "using v(1)"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = abs_Gromov_completion v\n  abs_Gromov_completion v = x\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion u = x", "by auto"], ["proof (state)\nthis:\n  abs_Gromov_completion u = x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> x \\<Longrightarrow>\n    Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion u = x", "show \"Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x\""], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = x\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "using \\<open>Gromov_completion_rel u u\\<close>"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = x\n  Gromov_completion_rel u u\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u u \\<and> abs_Gromov_completion u = x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In particular, it follows that a sequence which is \\verb+Gromov_converging_at_boundary+ is\nindeed converging to a point on the boundary, the equivalence class of this sequence.\\<close>"], ["", "lemma Gromov_converging_at_boundary_converges:\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"\\<exists>x \\<in> Gromov_boundary. (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>Gromov_boundary.\n       (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x", "apply (rule bexI[of _ \"abs_Gromov_completion u\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u\n 2. abs_Gromov_completion u \\<in> Gromov_boundary", "apply (subst Gromov_completion_converge_to_boundary)"], ["proof (prove)\ngoal (3 subgoals):\n 1. abs_Gromov_completion u \\<in> Gromov_boundary\n 2. Gromov_completion_rel u u \\<and>\n    abs_Gromov_completion u = abs_Gromov_completion u\n 3. abs_Gromov_completion u \\<in> Gromov_boundary", "using assms"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u\n\ngoal (3 subgoals):\n 1. abs_Gromov_completion u \\<in> Gromov_boundary\n 2. Gromov_completion_rel u u \\<and>\n    abs_Gromov_completion u = abs_Gromov_completion u\n 3. abs_Gromov_completion u \\<in> Gromov_boundary", "by (auto simp add: Gromov_converging_at_boundary_rel)"], ["", "lemma Gromov_converging_at_boundary_converges':\n  assumes \"Gromov_converging_at_boundary u\"\n  shows \"convergent (\\<lambda>n. to_Gromov_completion (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. to_Gromov_completion (u n))", "unfolding convergent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L.\n       (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> L", "using Gromov_converging_at_boundary_converges[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>Gromov_boundary.\n     (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. \\<exists>L.\n       (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> L", "by auto"], ["", "lemma lim_imp_Gromov_converging_at_boundary:\n  fixes u::\"nat \\<Rightarrow> 'a::Gromov_hyperbolic_space\"\n  assumes \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\" \"x \\<in> Gromov_boundary\"\n  shows \"Gromov_converging_at_boundary u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "using Gromov_boundary_abs_converging Gromov_completion_converge_to_boundary assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> Gromov_boundary; abs_Gromov_completion ?u = ?x;\n   Gromov_completion_rel ?u ?u\\<rbrakk>\n  \\<Longrightarrow> Gromov_converging_at_boundary ?u\n  ?x \\<in> Gromov_boundary \\<Longrightarrow>\n  (\\<lambda>n. to_Gromov_completion (?u n)) \\<longlonglongrightarrow> ?x =\n  (Gromov_completion_rel ?u ?u \\<and> abs_Gromov_completion ?u = ?x)\n  (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\n  x \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "by blast"], ["", "text \\<open>If two sequences tend to the same point at infinity, then their Gromov product tends to\ninfinity.\\<close>"], ["", "lemma same_limit_imp_Gromov_product_tendsto_infinity:\n  assumes \"z \\<in> Gromov_boundary\"\n          \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> z\"\n          \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> z\"\n  shows \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. Gromov_product_at a (u n) (v m) \\<ge> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "have \"Gromov_completion_rel u u\" \"Gromov_completion_rel v v\" \"abs_Gromov_completion u = abs_Gromov_completion v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u &&&\n    Gromov_completion_rel v v &&&\n    abs_Gromov_completion u = abs_Gromov_completion v", "using iffD1[OF Gromov_completion_converge_to_boundary[OF assms(1)]] assms"], ["proof (prove)\nusing this:\n  (\\<lambda>n. to_Gromov_completion (?u1 n))\n  \\<longlonglongrightarrow> z \\<Longrightarrow>\n  Gromov_completion_rel ?u1 ?u1 \\<and> abs_Gromov_completion ?u1 = z\n  z \\<in> Gromov_boundary\n  (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> z\n  (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> z\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u &&&\n    Gromov_completion_rel v v &&&\n    abs_Gromov_completion u = abs_Gromov_completion v", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u u\n  Gromov_completion_rel v v\n  abs_Gromov_completion u = abs_Gromov_completion v\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel u u\n  Gromov_completion_rel v v\n  abs_Gromov_completion u = abs_Gromov_completion v", "have *: \"Gromov_completion_rel u v\""], ["proof (prove)\nusing this:\n  Gromov_completion_rel u u\n  Gromov_completion_rel v v\n  abs_Gromov_completion u = abs_Gromov_completion v\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "using Quotient3_Gromov_completion Quotient3_rel"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u u\n  Gromov_completion_rel v v\n  abs_Gromov_completion u = abs_Gromov_completion v\n  Quotient3 Gromov_completion_rel abs_Gromov_completion\n   rep_Gromov_completion\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow>\n  (?R ?r ?r \\<and> ?R ?s ?s \\<and> ?Abs ?r = ?Abs ?s) = ?R ?r ?s\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "by fastforce"], ["proof (state)\nthis:\n  Gromov_completion_rel u v\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "have **: \"Gromov_converging_at_boundary u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "using assms lim_imp_Gromov_converging_at_boundary"], ["proof (prove)\nusing this:\n  z \\<in> Gromov_boundary\n  (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> z\n  (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> z\n  \\<lbrakk>(\\<lambda>n. to_Gromov_completion (?u n))\n           \\<longlonglongrightarrow> ?x;\n   ?x \\<in> Gromov_boundary\\<rbrakk>\n  \\<Longrightarrow> Gromov_converging_at_boundary ?u\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "by blast"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "then"], ["proof (chain)\npicking this:\n  Gromov_converging_at_boundary u", "obtain M where M: \"\\<And>m n. m \\<ge> M \\<Longrightarrow> n \\<ge> M \\<Longrightarrow> Gromov_product_at a (u m) (u n) \\<ge> C + deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>m n.\n            \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n            \\<Longrightarrow> C + deltaG TYPE('a)\n                              \\<le> Gromov_product_at a (u m)\n                                     (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Gromov_converging_at_boundary_def"], ["proof (prove)\nusing this:\n  \\<forall>a M.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        (\\<And>m n.\n            \\<lbrakk>M \\<le> m; M \\<le> n\\<rbrakk>\n            \\<Longrightarrow> C + deltaG TYPE('a)\n                              \\<le> Gromov_product_at a (u m)\n                                     (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> ?m; M \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> C + deltaG TYPE('a)\n                    \\<le> Gromov_product_at a (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "have \"(\\<lambda>n. Gromov_product_at a (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "using * Gromov_converging_at_boundary_imp_not_constant'[OF **]"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u v\n  \\<not> (\\<forall>m n. u m = u n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u \\<and>\n  Gromov_converging_at_boundary v \\<and>\n  (\\<forall>a.\n      (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n      \\<longlonglongrightarrow> \\<infinity>) \\<or>\n  (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)\n  \\<not> (\\<forall>m n. u m = u n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>", "have \"eventually (\\<lambda>n. Gromov_product_at a (u n) (v n) \\<ge> C + deltaG(TYPE('a))) sequentially\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       C + deltaG TYPE('a) \\<le> Gromov_product_at a (u n) (v n)", "by (meson Lim_PInfty ereal_less_eq(3) eventually_sequentiallyI)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     C + deltaG TYPE('a) \\<le> Gromov_product_at a (u n) (v n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     C + deltaG TYPE('a) \\<le> Gromov_product_at a (u n) (v n)", "obtain N where N: \"\\<And>n. n \\<ge> N \\<Longrightarrow> Gromov_product_at a (u n) (v n) \\<ge> C + deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     C + deltaG TYPE('a) \\<le> Gromov_product_at a (u n) (v n)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            C + deltaG TYPE('a)\n            \\<le> Gromov_product_at a (u n) (v n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        C + deltaG TYPE('a) \\<le> Gromov_product_at a (u n) (v n)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            C + deltaG TYPE('a)\n            \\<le> Gromov_product_at a (u n) (v n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<le> ?n \\<Longrightarrow>\n  C + deltaG TYPE('a) \\<le> Gromov_product_at a (u ?n) (v ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "have \"Gromov_product_at a (u n) (v m) \\<ge> C\" if \"n \\<ge> max M N\" \"m \\<ge> max M N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<le> Gromov_product_at a (u n) (v m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<le> Gromov_product_at a (u n) (v m)", "have \"C + deltaG(TYPE('a)) \\<le> min (Gromov_product_at a (u n) (u m)) (Gromov_product_at a (u m) (v m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C + deltaG TYPE('a)\n    \\<le> min (Gromov_product_at a (u n) (u m))\n           (Gromov_product_at a (u m) (v m))", "using M N that"], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<le> ?m; M \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> C + deltaG TYPE('a)\n                    \\<le> Gromov_product_at a (u ?m) (u ?n)\n  N \\<le> ?n \\<Longrightarrow>\n  C + deltaG TYPE('a) \\<le> Gromov_product_at a (u ?n) (v ?n)\n  max M N \\<le> n\n  max M N \\<le> m\n\ngoal (1 subgoal):\n 1. C + deltaG TYPE('a)\n    \\<le> min (Gromov_product_at a (u n) (u m))\n           (Gromov_product_at a (u m) (v m))", "by auto"], ["proof (state)\nthis:\n  C + deltaG TYPE('a)\n  \\<le> min (Gromov_product_at a (u n) (u m))\n         (Gromov_product_at a (u m) (v m))\n\ngoal (1 subgoal):\n 1. C \\<le> Gromov_product_at a (u n) (v m)", "also"], ["proof (state)\nthis:\n  C + deltaG TYPE('a)\n  \\<le> min (Gromov_product_at a (u n) (u m))\n         (Gromov_product_at a (u m) (v m))\n\ngoal (1 subgoal):\n 1. C \\<le> Gromov_product_at a (u n) (v m)", "have \"... \\<le> Gromov_product_at a (u n) (v m) + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at a (u n) (u m)) (Gromov_product_at a (u m) (v m))\n    \\<le> Gromov_product_at a (u n) (v m) + deltaG TYPE('a)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  min (Gromov_product_at a (u n) (u m)) (Gromov_product_at a (u m) (v m))\n  \\<le> Gromov_product_at a (u n) (v m) + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. C \\<le> Gromov_product_at a (u n) (v m)", "finally"], ["proof (chain)\npicking this:\n  C + deltaG TYPE('a)\n  \\<le> Gromov_product_at a (u n) (v m) + deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  C + deltaG TYPE('a)\n  \\<le> Gromov_product_at a (u n) (v m) + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. C \\<le> Gromov_product_at a (u n) (v m)", "by simp"], ["proof (state)\nthis:\n  C \\<le> Gromov_product_at a (u n) (v m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>max M N \\<le> ?n; max M N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> C \\<le> Gromov_product_at a (u ?n) (v ?m)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>max M N \\<le> ?n; max M N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> C \\<le> Gromov_product_at a (u ?n) (v ?m)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>max M N \\<le> ?n; max M N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> C \\<le> Gromov_product_at a (u ?n) (v ?m)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)", "by blast"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. C \\<le> Gromov_product_at a (u n) (v m)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>An admissible sequence converges in the Gromov boundary, to the point it defines. This\nfollows from the definition of the topology in the two cases, inner and boundary.\\<close>"], ["", "lemma abs_Gromov_completion_limit:\n  assumes \"Gromov_completion_rel u u\"\n  shows \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> abs_Gromov_completion u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u", "proof (cases \"abs_Gromov_completion u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       abs_Gromov_completion u = to_Gromov_completion x \\<Longrightarrow>\n       (\\<lambda>n. to_Gromov_completion (u n))\n       \\<longlonglongrightarrow> abs_Gromov_completion u\n 2. abs_Gromov_completion u \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u", "case (to_Gromov_completion x)"], ["proof (state)\nthis:\n  abs_Gromov_completion u = to_Gromov_completion x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       abs_Gromov_completion u = to_Gromov_completion x \\<Longrightarrow>\n       (\\<lambda>n. to_Gromov_completion (u n))\n       \\<longlonglongrightarrow> abs_Gromov_completion u\n 2. abs_Gromov_completion u \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion u = to_Gromov_completion x", "show ?thesis"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = to_Gromov_completion x\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u", "using Gromov_completion_rel_to_const Quotient3_Gromov_completion Quotient3_rel assms to_Gromov_completion_def"], ["proof (prove)\nusing this:\n  abs_Gromov_completion u = to_Gromov_completion x\n  Gromov_completion_rel ?u (\\<lambda>n. ?x) \\<Longrightarrow> ?u ?n = ?x\n  Quotient3 Gromov_completion_rel abs_Gromov_completion\n   rep_Gromov_completion\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow>\n  (?R ?r ?r \\<and> ?R ?s ?s \\<and> ?Abs ?r = ?Abs ?s) = ?R ?r ?s\n  Gromov_completion_rel u u\n  to_Gromov_completion ?x = abs_Gromov_completion (\\<lambda>n. ?x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>n. to_Gromov_completion (u n))\n  \\<longlonglongrightarrow> abs_Gromov_completion u\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion u \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. abs_Gromov_completion u \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u", "case boundary"], ["proof (state)\nthis:\n  abs_Gromov_completion u \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion u \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (u n))\n    \\<longlonglongrightarrow> abs_Gromov_completion u", "unfolding Gromov_completion_converge_to_boundary[OF boundary]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u \\<and>\n    abs_Gromov_completion u = abs_Gromov_completion u", "using assms Gromov_boundary_rep_converging Gromov_converging_at_boundary_rel Quotient3_Gromov_completion Quotient3_abs_rep boundary"], ["proof (prove)\nusing this:\n  Gromov_completion_rel u u\n  ?x \\<in> Gromov_boundary \\<Longrightarrow>\n  Gromov_converging_at_boundary (rep_Gromov_completion ?x)\n  Gromov_converging_at_boundary ?u \\<Longrightarrow>\n  Gromov_completion_rel ?u ?u\n  Quotient3 Gromov_completion_rel abs_Gromov_completion\n   rep_Gromov_completion\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow> ?Abs (?Rep ?a) = ?a\n  abs_Gromov_completion u \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u u \\<and>\n    abs_Gromov_completion u = abs_Gromov_completion u", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>n. to_Gromov_completion (u n))\n  \\<longlonglongrightarrow> abs_Gromov_completion u\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In particular, a point in the Gromov boundary is the limit of\nits representative sequence in the space.\\<close>"], ["", "lemma rep_Gromov_completion_limit:\n  \"(\\<lambda>n. to_Gromov_completion (rep_Gromov_completion x n)) \\<longlonglongrightarrow> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (rep_Gromov_completion x n))\n    \\<longlonglongrightarrow> x", "using abs_Gromov_completion_limit[of \"rep_Gromov_completion x\"] Quotient3_Gromov_completion Quotient3_abs_rep Quotient3_rep_reflp"], ["proof (prove)\nusing this:\n  Gromov_completion_rel (rep_Gromov_completion x)\n   (rep_Gromov_completion x) \\<Longrightarrow>\n  (\\<lambda>n. to_Gromov_completion (rep_Gromov_completion x n))\n  \\<longlonglongrightarrow> abs_Gromov_completion (rep_Gromov_completion x)\n  Quotient3 Gromov_completion_rel abs_Gromov_completion\n   rep_Gromov_completion\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow> ?Abs (?Rep ?a) = ?a\n  Quotient3 ?R ?Abs ?Rep \\<Longrightarrow> ?R (?Rep ?a) (?Rep ?a)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (rep_Gromov_completion x n))\n    \\<longlonglongrightarrow> x", "by fastforce"], ["", "subsection \\<open>Continuity properties of the extended Gromov product and distance\\<close>"], ["", "text \\<open>We have defined our extended Gromov product in terms of sequences satisfying the equivalence\nrelation. However, we would like to avoid this definition as much as possible, and express things\nin terms of the topology of the space. Hence, we reformulate this definition in topological terms,\nfirst when one of the two points is inside and the other one is on the boundary, then for all\ncases, and then we come back to the case where one point is inside, removing the assumption that\nthe other one is on the boundary.\\<close>"], ["", "lemma extended_Gromov_product_inside_boundary_aux:\n  assumes \"y \\<in> Gromov_boundary\"\n  shows \"extended_Gromov_product_at e (to_Gromov_completion x) y = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e x (v n))) |v. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x) y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x) y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "have A: \"abs_Gromov_completion v = to_Gromov_completion x \\<and> Gromov_completion_rel v v \\<longleftrightarrow> (v = (\\<lambda>n. x))\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. (abs_Gromov_completion v = to_Gromov_completion x \\<and>\n     Gromov_completion_rel v v) =\n    (v = (\\<lambda>n. x))", "apply (auto simp add: to_Gromov_completion_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_Gromov_completion v =\n             abs_Gromov_completion (\\<lambda>n. x);\n     Gromov_completion_rel v v\\<rbrakk>\n    \\<Longrightarrow> v = (\\<lambda>n. x)", "by (metis (mono_tags) Gromov_completion_rel_def Quotient3_Gromov_completion abs_Gromov_completion_in_Gromov_boundary not_in_Gromov_boundary' rep_Gromov_completion_to_Gromov_completion rep_abs_rsp to_Gromov_completion_def)"], ["proof (state)\nthis:\n  (abs_Gromov_completion ?v = to_Gromov_completion x \\<and>\n   Gromov_completion_rel ?v ?v) =\n  (?v = (\\<lambda>n. x))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x) y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "have *: \"{F u v |u v. abs_Gromov_completion u = to_Gromov_completion x \\<and> abs_Gromov_completion v = y \\<and> Gromov_completion_rel u u \\<and> Gromov_completion_rel v v}\n      = {F (\\<lambda>n. x) v |v. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\" for F::\"(nat \\<Rightarrow> 'a) \\<Rightarrow> (nat \\<Rightarrow> 'a) \\<Rightarrow> ereal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {F u v |u v.\n     abs_Gromov_completion u = to_Gromov_completion x \\<and>\n     abs_Gromov_completion v = y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {F (\\<lambda>n. x) v |v.\n     (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}", "unfolding Gromov_completion_converge_to_boundary[OF \\<open>y \\<in> Gromov_boundary\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {F u v |u v.\n     abs_Gromov_completion u = to_Gromov_completion x \\<and>\n     abs_Gromov_completion v = y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {F (\\<lambda>n. x) v |v.\n     Gromov_completion_rel v v \\<and> abs_Gromov_completion v = y}", "using A"], ["proof (prove)\nusing this:\n  (abs_Gromov_completion ?v = to_Gromov_completion x \\<and>\n   Gromov_completion_rel ?v ?v) =\n  (?v = (\\<lambda>n. x))\n\ngoal (1 subgoal):\n 1. {F u v |u v.\n     abs_Gromov_completion u = to_Gromov_completion x \\<and>\n     abs_Gromov_completion v = y \\<and>\n     Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    {F (\\<lambda>n. x) v |v.\n     Gromov_completion_rel v v \\<and> abs_Gromov_completion v = y}", "by force"], ["proof (state)\nthis:\n  {?F u v |u v.\n   abs_Gromov_completion u = to_Gromov_completion x \\<and>\n   abs_Gromov_completion v = y \\<and>\n   Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n  {?F (\\<lambda>n. x) v |v.\n   (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x) y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x) y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "unfolding extended_Gromov_product_at_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y} =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "by simp"], ["proof (state)\nthis:\n  extended_Gromov_product_at e (to_Gromov_completion x) y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n       (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_Gromov_product_boundary_inside_aux:\n  assumes \"y \\<in> Gromov_boundary\"\n  shows \"extended_Gromov_product_at e y (to_Gromov_completion x) = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e (v n) x)) |v. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e y (to_Gromov_completion x) =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) x)) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "using extended_Gromov_product_inside_boundary_aux[OF assms]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at ?e (to_Gromov_completion ?x) y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at ?e ?x (v n))) |v.\n       (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e y (to_Gromov_completion x) =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) x)) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "by (simp add: extended_Gromov_product_at_commute Gromov_product_commute)"], ["", "lemma extended_Gromov_product_at_topological:\n  \"extended_Gromov_product_at e x y = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e (u n) (v n))) |u v. (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x \\<and> (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "case boundary"], ["proof (state)\nthis:\n  x \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "case boundary"], ["proof (state)\nthis:\n  y \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "then"], ["proof (chain)\npicking this:\n  y \\<in> Gromov_boundary", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "unfolding extended_Gromov_product_at_def Gromov_completion_converge_to_boundary[OF \\<open>x \\<in> Gromov_boundary\\<close>] Gromov_completion_converge_to_boundary[OF \\<open>y \\<in> Gromov_boundary\\<close>]"], ["proof (prove)\nusing this:\n  y \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         abs_Gromov_completion u = x \\<and>\n         abs_Gromov_completion v = y \\<and>\n         Gromov_completion_rel u u \\<and> Gromov_completion_rel v v} =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (Gromov_completion_rel u u \\<and>\n          abs_Gromov_completion u = x) \\<and>\n         Gromov_completion_rel v v \\<and> abs_Gromov_completion v = y}", "by meson"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n       (\\<lambda>n. to_Gromov_completion (u n))\n       \\<longlonglongrightarrow> x \\<and>\n       (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "case (to_Gromov_completion yi)"], ["proof (state)\nthis:\n  y = to_Gromov_completion yi\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "have A: \"liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))\" if \"v \\<longlonglongrightarrow> yi\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "define h where \"h = (\\<lambda>n. Gromov_product_at e (u n) (v n) - Gromov_product_at e (u n) yi)\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>n.\n      Gromov_product_at e (u n) (v n) - Gromov_product_at e (u n) yi)\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "have h: \"h \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<longlonglongrightarrow> 0", "apply (rule tendsto_rabs_zero_cancel, rule tendsto_sandwich[of \"\\<lambda>n. 0\" _ _ \"\\<lambda>n. dist (v n) yi\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> \\<bar>h n\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially. \\<bar>h n\\<bar> \\<le> dist (v n) yi\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (v n) yi) \\<longlonglongrightarrow> 0", "unfolding h_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e (u n) yi\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e (u n) yi\\<bar>\n       \\<le> dist (v n) yi\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (v n) yi) \\<longlonglongrightarrow> 0", "using Gromov_product_at_diff3[of e _ _ yi] that"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e ?x ?y - Gromov_product_at e ?x yi\\<bar>\n  \\<le> dist ?y yi\n  v \\<longlonglongrightarrow> yi\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e (u n) yi\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e (u n) yi\\<bar>\n       \\<le> dist (v n) yi\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (v n) yi) \\<longlonglongrightarrow> 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                \\<bar>Gromov_product_at e x y -\n                      Gromov_product_at e x yi\\<bar>\n                \\<le> dist y yi;\n     v \\<longlonglongrightarrow> yi\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (v n) yi)\n                      \\<longlonglongrightarrow> 0", "using tendsto_dist_iff"], ["proof (prove)\nusing this:\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x y.\n                \\<bar>Gromov_product_at e x y -\n                      Gromov_product_at e x yi\\<bar>\n                \\<le> dist y yi;\n     v \\<longlonglongrightarrow> yi\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (v n) yi)\n                      \\<longlonglongrightarrow> 0", "by blast"], ["proof (state)\nthis:\n  h \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "have *: \"ereal (Gromov_product_at e (u n) (v n)) = h n + ereal (Gromov_product_at e (u n) yi)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (h n) + ereal (Gromov_product_at e (u n) yi)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (Gromov_product_at e (u n) (v n) - Gromov_product_at e (u n) yi) +\n    ereal (Gromov_product_at e (u n) yi)", "by auto"], ["proof (state)\nthis:\n  ereal (Gromov_product_at e (u ?n) (v ?n)) =\n  ereal (h ?n) + ereal (Gromov_product_at e (u ?n) yi)\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "have \"liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = 0 + liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    0 + liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf\n     (\\<lambda>n. ereal (h n) + ereal (Gromov_product_at e (u n) yi)) =\n    0 + liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "apply (rule ereal_liminf_lim_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "using h"], ["proof (prove)\nusing this:\n  h \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "by (auto simp add: zero_ereal_def)"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "then"], ["proof (chain)\npicking this:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "show ?thesis"], ["proof (prove)\nusing this:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))", "by simp"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) yi))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v \\<longlonglongrightarrow> yi \\<Longrightarrow>\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (?u n) (?v n))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (?u n) yi))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "unfolding to_Gromov_completion extended_Gromov_product_boundary_inside_aux[OF \\<open>x \\<in> Gromov_boundary\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) yi)) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> x} =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> to_Gromov_completion yi}", "apply (rule cong[of Inf Inf], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       (\\<lambda>n. to_Gromov_completion (v n))\n       \\<longlonglongrightarrow> x \\<Longrightarrow>\n       \\<exists>u va.\n          liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) yi)) =\n          liminf\n           (\\<lambda>n. ereal (Gromov_product_at e (u n) (va n))) \\<and>\n          (\\<lambda>n. to_Gromov_completion (u n))\n          \\<longlonglongrightarrow> x \\<and>\n          va \\<longlonglongrightarrow> yi\n 2. \\<And>u v.\n       \\<lbrakk>(\\<lambda>n. to_Gromov_completion (u n))\n                \\<longlonglongrightarrow> x;\n        v \\<longlonglongrightarrow> yi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            liminf\n                             (\\<lambda>n.\n                                 ereal (Gromov_product_at e (u n) (v n))) =\n                            liminf\n                             (\\<lambda>n.\n                                 ereal\n                                  (Gromov_product_at e (va n) yi)) \\<and>\n                            (\\<lambda>n. to_Gromov_completion (va n))\n                            \\<longlonglongrightarrow> x", "using A"], ["proof (prove)\nusing this:\n  ?v \\<longlonglongrightarrow> yi \\<Longrightarrow>\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (?u n) (?v n))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (?u n) yi))\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       (\\<lambda>n. to_Gromov_completion (v n))\n       \\<longlonglongrightarrow> x \\<Longrightarrow>\n       \\<exists>u va.\n          liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) yi)) =\n          liminf\n           (\\<lambda>n. ereal (Gromov_product_at e (u n) (va n))) \\<and>\n          (\\<lambda>n. to_Gromov_completion (u n))\n          \\<longlonglongrightarrow> x \\<and>\n          va \\<longlonglongrightarrow> yi\n 2. \\<And>u v.\n       \\<lbrakk>(\\<lambda>n. to_Gromov_completion (u n))\n                \\<longlonglongrightarrow> x;\n        v \\<longlonglongrightarrow> yi\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            liminf\n                             (\\<lambda>n.\n                                 ereal (Gromov_product_at e (u n) (v n))) =\n                            liminf\n                             (\\<lambda>n.\n                                 ereal\n                                  (Gromov_product_at e (va n) yi)) \\<and>\n                            (\\<lambda>n. to_Gromov_completion (va n))\n                            \\<longlonglongrightarrow> x", "by fast+"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n       (\\<lambda>n. to_Gromov_completion (u n))\n       \\<longlonglongrightarrow> x \\<and>\n       (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n       (\\<lambda>n. to_Gromov_completion (u n))\n       \\<longlonglongrightarrow> x \\<and>\n       (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "case (to_Gromov_completion xi)"], ["proof (state)\nthis:\n  x = to_Gromov_completion xi\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "case boundary"], ["proof (state)\nthis:\n  y \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "have A: \"liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))\" if \"u \\<longlonglongrightarrow> xi\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "define h where \"h = (\\<lambda>n. Gromov_product_at e (u n) (v n) - Gromov_product_at e xi (v n))\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>n.\n      Gromov_product_at e (u n) (v n) - Gromov_product_at e xi (v n))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "have h: \"h \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<longlonglongrightarrow> 0", "apply (rule tendsto_rabs_zero_cancel, rule tendsto_sandwich[of \"\\<lambda>n. 0\" _ _ \"\\<lambda>n. dist (u n) xi\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> \\<bar>h n\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially. \\<bar>h n\\<bar> \\<le> dist (u n) xi\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) xi) \\<longlonglongrightarrow> 0", "unfolding h_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e xi (v n)\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e xi (v n)\\<bar>\n       \\<le> dist (u n) xi\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) xi) \\<longlonglongrightarrow> 0", "using Gromov_product_at_diff2[of e _ _ xi] that"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e ?x ?z - Gromov_product_at e xi ?z\\<bar>\n  \\<le> dist ?x xi\n  u \\<longlonglongrightarrow> xi\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e xi (v n)\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e xi (v n)\\<bar>\n       \\<le> dist (u n) xi\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) xi) \\<longlonglongrightarrow> 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x z.\n                \\<bar>Gromov_product_at e x z -\n                      Gromov_product_at e xi z\\<bar>\n                \\<le> dist x xi;\n     u \\<longlonglongrightarrow> xi\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (u n) xi)\n                      \\<longlonglongrightarrow> 0", "using tendsto_dist_iff"], ["proof (prove)\nusing this:\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x z.\n                \\<bar>Gromov_product_at e x z -\n                      Gromov_product_at e xi z\\<bar>\n                \\<le> dist x xi;\n     u \\<longlonglongrightarrow> xi\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (u n) xi)\n                      \\<longlonglongrightarrow> 0", "by blast"], ["proof (state)\nthis:\n  h \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "have *: \"ereal (Gromov_product_at e (u n) (v n)) = h n + ereal (Gromov_product_at e xi (v n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (h n) + ereal (Gromov_product_at e xi (v n))", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (Gromov_product_at e (u n) (v n) - Gromov_product_at e xi (v n)) +\n    ereal (Gromov_product_at e xi (v n))", "by auto"], ["proof (state)\nthis:\n  ereal (Gromov_product_at e (u ?n) (v ?n)) =\n  ereal (h ?n) + ereal (Gromov_product_at e xi (v ?n))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "have \"liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = 0 + liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    0 + liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf\n     (\\<lambda>n. ereal (h n) + ereal (Gromov_product_at e xi (v n))) =\n    0 + liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "apply (rule ereal_liminf_lim_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "using h"], ["proof (prove)\nusing this:\n  h \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "by (auto simp add: zero_ereal_def)"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "then"], ["proof (chain)\npicking this:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "show ?thesis"], ["proof (prove)\nusing this:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))", "by simp"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<longlonglongrightarrow> xi \\<Longrightarrow>\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (?u n) (?v n))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e xi (?v n)))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "unfolding to_Gromov_completion extended_Gromov_product_inside_boundary_aux[OF \\<open>y \\<in> Gromov_boundary\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y} =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> to_Gromov_completion xi \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "apply (rule cong[of Inf Inf], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v.\n       (\\<lambda>n. to_Gromov_completion (v n))\n       \\<longlonglongrightarrow> y \\<Longrightarrow>\n       \\<exists>u va.\n          liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n))) =\n          liminf\n           (\\<lambda>n. ereal (Gromov_product_at e (u n) (va n))) \\<and>\n          u \\<longlonglongrightarrow> xi \\<and>\n          (\\<lambda>n. to_Gromov_completion (va n))\n          \\<longlonglongrightarrow> y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<longlonglongrightarrow> xi;\n        (\\<lambda>n. to_Gromov_completion (v n))\n        \\<longlonglongrightarrow> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            liminf\n                             (\\<lambda>n.\n                                 ereal (Gromov_product_at e (u n) (v n))) =\n                            liminf\n                             (\\<lambda>n.\n                                 ereal\n                                  (Gromov_product_at e xi (va n))) \\<and>\n                            (\\<lambda>n. to_Gromov_completion (va n))\n                            \\<longlonglongrightarrow> y", "using A"], ["proof (prove)\nusing this:\n  ?u \\<longlonglongrightarrow> xi \\<Longrightarrow>\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (?u n) (?v n))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e xi (?v n)))\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       (\\<lambda>n. to_Gromov_completion (v n))\n       \\<longlonglongrightarrow> y \\<Longrightarrow>\n       \\<exists>u va.\n          liminf (\\<lambda>n. ereal (Gromov_product_at e xi (v n))) =\n          liminf\n           (\\<lambda>n. ereal (Gromov_product_at e (u n) (va n))) \\<and>\n          u \\<longlonglongrightarrow> xi \\<and>\n          (\\<lambda>n. to_Gromov_completion (va n))\n          \\<longlonglongrightarrow> y\n 2. \\<And>u v.\n       \\<lbrakk>u \\<longlonglongrightarrow> xi;\n        (\\<lambda>n. to_Gromov_completion (v n))\n        \\<longlonglongrightarrow> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            liminf\n                             (\\<lambda>n.\n                                 ereal (Gromov_product_at e (u n) (v n))) =\n                            liminf\n                             (\\<lambda>n.\n                                 ereal\n                                  (Gromov_product_at e xi (va n))) \\<and>\n                            (\\<lambda>n. to_Gromov_completion (va n))\n                            \\<longlonglongrightarrow> y", "by fast+"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n       (\\<lambda>n. to_Gromov_completion (u n))\n       \\<longlonglongrightarrow> x \\<and>\n       (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "case (to_Gromov_completion yi)"], ["proof (state)\nthis:\n  y = to_Gromov_completion yi\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "have B: \"liminf (\\<lambda>n. Gromov_product_at e (u n) (v n)) = Gromov_product_at e xi yi\" if \"u \\<longlonglongrightarrow> xi\" \"v \\<longlonglongrightarrow> yi\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) =\n    ereal (Gromov_product_at e xi yi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) =\n    ereal (Gromov_product_at e xi yi)", "have \"(\\<lambda>n. Gromov_product_at e (u n) (v n)) \\<longlonglongrightarrow> Gromov_product_at e xi yi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. Gromov_product_at e (u n) (v n))\n    \\<longlonglongrightarrow> Gromov_product_at e xi yi", "apply (rule Gromov_product_at_continuous)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>n. e) \\<longlonglongrightarrow> e\n 2. u \\<longlonglongrightarrow> xi\n 3. v \\<longlonglongrightarrow> yi", "using that"], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> xi\n  v \\<longlonglongrightarrow> yi\n\ngoal (3 subgoals):\n 1. (\\<lambda>n. e) \\<longlonglongrightarrow> e\n 2. u \\<longlonglongrightarrow> xi\n 3. v \\<longlonglongrightarrow> yi", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. Gromov_product_at e (u n) (v n))\n  \\<longlonglongrightarrow> Gromov_product_at e xi yi\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) =\n    ereal (Gromov_product_at e xi yi)", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. Gromov_product_at e (u n) (v n))\n  \\<longlonglongrightarrow> Gromov_product_at e xi yi", "show \"liminf (\\<lambda>n. Gromov_product_at e (u n) (v n)) = Gromov_product_at e xi yi\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. Gromov_product_at e (u n) (v n))\n  \\<longlonglongrightarrow> Gromov_product_at e xi yi\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) =\n    ereal (Gromov_product_at e xi yi)", "by (simp add: lim_imp_Liminf)"], ["proof (state)\nthis:\n  liminf (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) =\n  ereal (Gromov_product_at e xi yi)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?u \\<longlonglongrightarrow> xi;\n   ?v \\<longlonglongrightarrow> yi\\<rbrakk>\n  \\<Longrightarrow> liminf\n                     (\\<lambda>x.\n                         ereal (Gromov_product_at e (?u x) (?v x))) =\n                    ereal (Gromov_product_at e xi yi)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "have *: \"{liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v. u \\<longlonglongrightarrow> xi \\<and> v \\<longlonglongrightarrow> yi} = {ereal (Gromov_product_at e xi yi)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n     u \\<longlonglongrightarrow> xi \\<and> v \\<longlonglongrightarrow> yi} =\n    {ereal (Gromov_product_at e xi yi)}", "using B"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<longlonglongrightarrow> xi;\n   ?v \\<longlonglongrightarrow> yi\\<rbrakk>\n  \\<Longrightarrow> liminf\n                     (\\<lambda>x.\n                         ereal (Gromov_product_at e (?u x) (?v x))) =\n                    ereal (Gromov_product_at e xi yi)\n\ngoal (1 subgoal):\n 1. {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n     u \\<longlonglongrightarrow> xi \\<and> v \\<longlonglongrightarrow> yi} =\n    {ereal (Gromov_product_at e xi yi)}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<longlonglongrightarrow> xi;\n         v \\<longlonglongrightarrow> yi\\<rbrakk>\n        \\<Longrightarrow> liminf\n                           (\\<lambda>x.\n                               ereal (Gromov_product_at e (u x) (v x))) =\n                          ereal\n                           (Gromov_product_at e xi yi)) \\<Longrightarrow>\n    \\<exists>u v.\n       ereal (Gromov_product_at e xi yi) =\n       liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) \\<and>\n       u \\<longlonglongrightarrow> xi \\<and> v \\<longlonglongrightarrow> yi", "by (rule exI[of _ \"\\<lambda>n. xi\"], rule exI[of _ \"\\<lambda>n. yi\"], auto)"], ["proof (state)\nthis:\n  {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n   u \\<longlonglongrightarrow> xi \\<and> v \\<longlonglongrightarrow> yi} =\n  {ereal (Gromov_product_at e xi yi)}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       extended_Gromov_product_at e x y =\n       Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u\n            v. (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> x \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e x y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "unfolding \\<open>x = to_Gromov_completion xi\\<close> \\<open>y = to_Gromov_completion yi\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion xi)\n     (to_Gromov_completion yi) =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> to_Gromov_completion xi \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> to_Gromov_completion yi}", "by (auto simp add: *)"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n       (\\<lambda>n. to_Gromov_completion (u n))\n       \\<longlonglongrightarrow> x \\<and>\n       (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  extended_Gromov_product_at e x y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n       (\\<lambda>n. to_Gromov_completion (u n))\n       \\<longlonglongrightarrow> x \\<and>\n       (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_Gromov_product_inside_boundary:\n  \"extended_Gromov_product_at e (to_Gromov_completion x) y = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e x (v n))) |v. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x) y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x) y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "have A: \"liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\" if \"u \\<longlonglongrightarrow> x\" for u v"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "define h where \"h = (\\<lambda>n. Gromov_product_at e (u n) (v n) - Gromov_product_at e x (v n))\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>n.\n      Gromov_product_at e (u n) (v n) - Gromov_product_at e x (v n))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "have h: \"h \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<longlonglongrightarrow> 0", "apply (rule tendsto_rabs_zero_cancel, rule tendsto_sandwich[of \"\\<lambda>n. 0\" _ _ \"\\<lambda>n. dist (u n) x\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> \\<bar>h n\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially. \\<bar>h n\\<bar> \\<le> dist (u n) x\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "unfolding h_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e x (v n)\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e x (v n)\\<bar>\n       \\<le> dist (u n) x\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "using Gromov_product_at_diff2[of e _ _ x] that"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e ?x ?z - Gromov_product_at e x ?z\\<bar>\n  \\<le> dist ?x x\n  u \\<longlonglongrightarrow> x\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e x (v n)\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e x (v n)\\<bar>\n       \\<le> dist (u n) x\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xa z.\n                \\<bar>Gromov_product_at e xa z -\n                      Gromov_product_at e x z\\<bar>\n                \\<le> dist xa x;\n     u \\<longlonglongrightarrow> x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "using tendsto_dist_iff"], ["proof (prove)\nusing this:\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xa z.\n                \\<bar>Gromov_product_at e xa z -\n                      Gromov_product_at e x z\\<bar>\n                \\<le> dist xa x;\n     u \\<longlonglongrightarrow> x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "by blast"], ["proof (state)\nthis:\n  h \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "have *: \"ereal (Gromov_product_at e (u n) (v n)) = h n + ereal (Gromov_product_at e x (v n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (h n) + ereal (Gromov_product_at e x (v n))", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (Gromov_product_at e (u n) (v n) - Gromov_product_at e x (v n)) +\n    ereal (Gromov_product_at e x (v n))", "by auto"], ["proof (state)\nthis:\n  ereal (Gromov_product_at e (u ?n) (v ?n)) =\n  ereal (h ?n) + ereal (Gromov_product_at e x (v ?n))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "have \"liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = 0 + liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    0 + liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (h n) + ereal (Gromov_product_at e x (v n))) =\n    0 + liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "apply (rule ereal_liminf_lim_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "using h"], ["proof (prove)\nusing this:\n  h \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "by (auto simp add: zero_ereal_def)"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "then"], ["proof (chain)\npicking this:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "show ?thesis"], ["proof (prove)\nusing this:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "by simp"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<longlonglongrightarrow> x \\<Longrightarrow>\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (?u n) (?v n))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e x (?v n)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x) y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e (to_Gromov_completion x) y =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "unfolding extended_Gromov_product_at_topological"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> to_Gromov_completion x \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y} =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "apply (rule cong[of Inf Inf], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<longlonglongrightarrow> x;\n        (\\<lambda>n. to_Gromov_completion (v n))\n        \\<longlonglongrightarrow> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            liminf\n                             (\\<lambda>n.\n                                 ereal (Gromov_product_at e (u n) (v n))) =\n                            liminf\n                             (\\<lambda>n.\n                                 ereal\n                                  (Gromov_product_at e x (va n))) \\<and>\n                            (\\<lambda>n. to_Gromov_completion (va n))\n                            \\<longlonglongrightarrow> y\n 2. \\<And>v.\n       (\\<lambda>n. to_Gromov_completion (v n))\n       \\<longlonglongrightarrow> y \\<Longrightarrow>\n       \\<exists>u va.\n          liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) =\n          liminf\n           (\\<lambda>n. ereal (Gromov_product_at e (u n) (va n))) \\<and>\n          u \\<longlonglongrightarrow> x \\<and>\n          (\\<lambda>n. to_Gromov_completion (va n))\n          \\<longlonglongrightarrow> y", "using A"], ["proof (prove)\nusing this:\n  ?u \\<longlonglongrightarrow> x \\<Longrightarrow>\n  liminf (\\<lambda>n. ereal (Gromov_product_at e (?u n) (?v n))) =\n  liminf (\\<lambda>n. ereal (Gromov_product_at e x (?v n)))\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<longlonglongrightarrow> x;\n        (\\<lambda>n. to_Gromov_completion (v n))\n        \\<longlonglongrightarrow> y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>va.\n                            liminf\n                             (\\<lambda>n.\n                                 ereal (Gromov_product_at e (u n) (v n))) =\n                            liminf\n                             (\\<lambda>n.\n                                 ereal\n                                  (Gromov_product_at e x (va n))) \\<and>\n                            (\\<lambda>n. to_Gromov_completion (va n))\n                            \\<longlonglongrightarrow> y\n 2. \\<And>v.\n       (\\<lambda>n. to_Gromov_completion (v n))\n       \\<longlonglongrightarrow> y \\<Longrightarrow>\n       \\<exists>u va.\n          liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) =\n          liminf\n           (\\<lambda>n. ereal (Gromov_product_at e (u n) (va n))) \\<and>\n          u \\<longlonglongrightarrow> x \\<and>\n          (\\<lambda>n. to_Gromov_completion (va n))\n          \\<longlonglongrightarrow> y", "by fast+"], ["proof (state)\nthis:\n  extended_Gromov_product_at e (to_Gromov_completion x) y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n       (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_Gromov_product_boundary_inside:\n  \"extended_Gromov_product_at e y (to_Gromov_completion x) = Inf {liminf (\\<lambda>n. ereal(Gromov_product_at e (v n) x)) |v. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e y (to_Gromov_completion x) =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) x)) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "using extended_Gromov_product_inside_boundary"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at ?e (to_Gromov_completion ?x) ?y =\n  Inf {liminf (\\<lambda>n. ereal (Gromov_product_at ?e ?x (v n))) |v.\n       (\\<lambda>n. to_Gromov_completion (v n))\n       \\<longlonglongrightarrow> ?y}\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e y (to_Gromov_completion x) =\n    Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (v n) x)) |v.\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> y}", "by (simp add: extended_Gromov_product_at_commute Gromov_product_commute)"], ["", "text \\<open>Now, we compare the extended Gromov product to a sequence of Gromov products for converging\nsequences. As the extended Gromov product is defined as an Inf of limings, it is clearly smaller\nthan the liminf. More interestingly, it is also of the order of magnitude of the limsup, for\nwhatever sequence one uses. In other words, it is canonically defined, up to $2 \\delta$.\\<close>"], ["", "lemma extended_Gromov_product_le_liminf:\n  assumes \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> xi\"\n          \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> eta\"\n  shows \"liminf (\\<lambda>n. Gromov_product_at e (u n) (v n)) \\<ge> extended_Gromov_product_at e xi eta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at e xi eta\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))", "unfolding extended_Gromov_product_at_topological"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> xi \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> eta}\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))", "using assms"], ["proof (prove)\nusing this:\n  (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> xi\n  (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> eta\n\ngoal (1 subgoal):\n 1. Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |u v.\n         (\\<lambda>n. to_Gromov_completion (u n))\n         \\<longlonglongrightarrow> xi \\<and>\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> eta}\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))", "by (auto intro!: Inf_lower)"], ["", "lemma limsup_le_extended_Gromov_product_inside:\n  assumes \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> (eta::('a::Gromov_hyperbolic_space) Gromov_completion)\"\n  shows \"limsup (\\<lambda>n. Gromov_product_at e x (v n)) \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n          ereal (deltaG TYPE('a))", "proof (cases eta)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       eta = to_Gromov_completion xa \\<Longrightarrow>\n       limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n       \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n             ereal (deltaG TYPE('a))\n 2. eta \\<in> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n          ereal (deltaG TYPE('a))", "case boundary"], ["proof (state)\nthis:\n  eta \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       eta = to_Gromov_completion xa \\<Longrightarrow>\n       limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n       \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n             ereal (deltaG TYPE('a))\n 2. eta \\<in> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n          ereal (deltaG TYPE('a))", "have A: \"limsup (\\<lambda>n. Gromov_product_at e x (v n)) \\<le> liminf (\\<lambda>n. Gromov_product_at e x (v' n)) + deltaG(TYPE('a))\"\n    if H: \"(\\<lambda>n. to_Gromov_completion (v' n)) \\<longlonglongrightarrow> eta\" for v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "have \"ereal a \\<le> liminf (\\<lambda>n. Gromov_product_at e x (v' n)) + deltaG(TYPE('a))\" if L: \"ereal a < limsup (\\<lambda>n. Gromov_product_at e x (v n))\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "obtain Nv where Nv: \"\\<And>m n. m \\<ge> Nv \\<Longrightarrow> n \\<ge> Nv \\<Longrightarrow> Gromov_product_at e (v m) (v' n) \\<ge> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Nv.\n        (\\<And>m n.\n            \\<lbrakk>Nv \\<le> m; Nv \\<le> n\\<rbrakk>\n            \\<Longrightarrow> a \\<le> Gromov_product_at e (v m)\n (v' n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using same_limit_imp_Gromov_product_tendsto_infinity[OF \\<open>eta \\<in> Gromov_boundary\\<close> assms H]"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. ?C \\<le> Gromov_product_at ?a (v n) (v' m)\n\ngoal (1 subgoal):\n 1. (\\<And>Nv.\n        (\\<And>m n.\n            \\<lbrakk>Nv \\<le> m; Nv \\<le> n\\<rbrakk>\n            \\<Longrightarrow> a \\<le> Gromov_product_at e (v m)\n (v' n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>Nv \\<le> ?m; Nv \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> a \\<le> Gromov_product_at e (v ?m) (v' ?n)\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "obtain N where N: \"ereal a < Gromov_product_at e x (v N)\" \"N \\<ge> Nv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>ereal a < ereal (Gromov_product_at e x (v N));\n         Nv \\<le> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using limsup_obtain[OF L]"], ["proof (prove)\nusing this:\n  \\<exists>n\\<ge>?N. ereal a < ereal (Gromov_product_at e x (v n))\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>ereal a < ereal (Gromov_product_at e x (v N));\n         Nv \\<le> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ereal a < ereal (Gromov_product_at e x (v N))\n  Nv \\<le> N\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "have *: \"a - deltaG(TYPE('a)) \\<le> Gromov_product_at e x (v' n)\" if \"n \\<ge> Nv\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. a - deltaG TYPE('a) \\<le> Gromov_product_at e x (v' n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a - deltaG TYPE('a) \\<le> Gromov_product_at e x (v' n)", "have \"a \\<le> min (Gromov_product_at e x (v N)) (Gromov_product_at e (v N) (v' n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> min (Gromov_product_at e x (v N))\n             (Gromov_product_at e (v N) (v' n))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<le> Gromov_product_at e x (v N)\n 2. a \\<le> Gromov_product_at e (v N) (v' n)", "using N(1) Nv[OF \\<open>N \\<ge> Nv\\<close> \\<open>n \\<ge> Nv\\<close>]"], ["proof (prove)\nusing this:\n  ereal a < ereal (Gromov_product_at e x (v N))\n  a \\<le> Gromov_product_at e (v N) (v' n)\n\ngoal (2 subgoals):\n 1. a \\<le> Gromov_product_at e x (v N)\n 2. a \\<le> Gromov_product_at e (v N) (v' n)", "by auto"], ["proof (state)\nthis:\n  a \\<le> min (Gromov_product_at e x (v N))\n           (Gromov_product_at e (v N) (v' n))\n\ngoal (1 subgoal):\n 1. a - deltaG TYPE('a) \\<le> Gromov_product_at e x (v' n)", "also"], ["proof (state)\nthis:\n  a \\<le> min (Gromov_product_at e x (v N))\n           (Gromov_product_at e (v N) (v' n))\n\ngoal (1 subgoal):\n 1. a - deltaG TYPE('a) \\<le> Gromov_product_at e x (v' n)", "have \"... \\<le> Gromov_product_at e x (v' n) + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at e x (v N)) (Gromov_product_at e (v N) (v' n))\n    \\<le> Gromov_product_at e x (v' n) + deltaG TYPE('a)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  min (Gromov_product_at e x (v N)) (Gromov_product_at e (v N) (v' n))\n  \\<le> Gromov_product_at e x (v' n) + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. a - deltaG TYPE('a) \\<le> Gromov_product_at e x (v' n)", "finally"], ["proof (chain)\npicking this:\n  a \\<le> Gromov_product_at e x (v' n) + deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> Gromov_product_at e x (v' n) + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. a - deltaG TYPE('a) \\<le> Gromov_product_at e x (v' n)", "by auto"], ["proof (state)\nthis:\n  a - deltaG TYPE('a) \\<le> Gromov_product_at e x (v' n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Nv \\<le> ?n \\<Longrightarrow>\n  a - deltaG TYPE('a) \\<le> Gromov_product_at e x (v' ?n)\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "have \"a - deltaG(TYPE('a)) \\<le> liminf (\\<lambda>n. Gromov_product_at e x (v' n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (a - deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa)))", "apply (rule Liminf_bounded)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (a - deltaG TYPE('a))\n       \\<le> ereal (Gromov_product_at e x (v' n))", "unfolding eventually_sequentially"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          ereal (a - deltaG TYPE('a))\n          \\<le> ereal (Gromov_product_at e x (v' n))", "using *"], ["proof (prove)\nusing this:\n  Nv \\<le> ?n \\<Longrightarrow>\n  a - deltaG TYPE('a) \\<le> Gromov_product_at e x (v' ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          ereal (a - deltaG TYPE('a))\n          \\<le> ereal (Gromov_product_at e x (v' n))", "by fastforce"], ["proof (state)\nthis:\n  ereal (a - deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa)))\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  ereal (a - deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal (a - deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa)))\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "unfolding ereal_minus(1)[symmetric]"], ["proof (prove)\nusing this:\n  ereal a - ereal (deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa)))\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "by (subst ereal_minus_le[symmetric], auto)"], ["proof (state)\nthis:\n  ereal a\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n        ereal (deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ereal ?a\n  < limsup\n     (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) \\<Longrightarrow>\n  ereal ?a\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  ereal ?a\n  < limsup\n     (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) \\<Longrightarrow>\n  ereal ?a\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n        ereal (deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal ?a\n  < limsup\n     (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) \\<Longrightarrow>\n  ereal ?a\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "using ereal_dense2 not_less"], ["proof (prove)\nusing this:\n  ereal ?a\n  < limsup\n     (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) \\<Longrightarrow>\n  ereal ?a\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n        ereal (deltaG TYPE('a))\n  ?x < ?y \\<Longrightarrow> \\<exists>z. ?x < ereal z \\<and> ereal z < ?y\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n          ereal (deltaG TYPE('a))", "by blast"], ["proof (state)\nthis:\n  limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (v' xa))) +\n        ereal (deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n. to_Gromov_completion (?v' n))\n  \\<longlonglongrightarrow> eta \\<Longrightarrow>\n  limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at e x (?v' xa))) +\n        ereal (deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       eta = to_Gromov_completion xa \\<Longrightarrow>\n       limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n       \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n             ereal (deltaG TYPE('a))\n 2. eta \\<in> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n          ereal (deltaG TYPE('a))", "have \"limsup (\\<lambda>n. Gromov_product_at e x (v n)) - deltaG(TYPE('a)) \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) -\n    ereal (deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta", "unfolding extended_Gromov_product_inside_boundary"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) -\n    ereal (deltaG TYPE('a))\n    \\<le> Inf {liminf (\\<lambda>n. ereal (Gromov_product_at e x (v n))) |v.\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> eta}", "by (rule Inf_greatest, auto simp add: A)"], ["proof (state)\nthis:\n  limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) -\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       eta = to_Gromov_completion xa \\<Longrightarrow>\n       limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n       \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n             ereal (deltaG TYPE('a))\n 2. eta \\<in> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n          ereal (deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) -\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta", "show ?thesis"], ["proof (prove)\nusing this:\n  limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) -\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n          ereal (deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n  \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       eta = to_Gromov_completion xa \\<Longrightarrow>\n       limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n       \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n             ereal (deltaG TYPE('a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       eta = to_Gromov_completion xa \\<Longrightarrow>\n       limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n       \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n             ereal (deltaG TYPE('a))", "case (to_Gromov_completion y)"], ["proof (state)\nthis:\n  eta = to_Gromov_completion y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       eta = to_Gromov_completion xa \\<Longrightarrow>\n       limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n       \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n             ereal (deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  eta = to_Gromov_completion y", "have \"v \\<longlonglongrightarrow> y\""], ["proof (prove)\nusing this:\n  eta = to_Gromov_completion y\n\ngoal (1 subgoal):\n 1. v \\<longlonglongrightarrow> y", "using assms"], ["proof (prove)\nusing this:\n  eta = to_Gromov_completion y\n  (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> eta\n\ngoal (1 subgoal):\n 1. v \\<longlonglongrightarrow> y", "by auto"], ["proof (state)\nthis:\n  v \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       eta = to_Gromov_completion xa \\<Longrightarrow>\n       limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n       \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n             ereal (deltaG TYPE('a))", "have L: \"(\\<lambda>n. Gromov_product_at e x (v n)) \\<longlonglongrightarrow> ereal(Gromov_product_at e x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<longlonglongrightarrow> ereal (Gromov_product_at e x y)", "using Gromov_product_at_continuous[OF _ _ \\<open>v \\<longlonglongrightarrow> y\\<close>, of \"\\<lambda>n. e\" e \"\\<lambda>n. x\" x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<lambda>n. e) \\<longlonglongrightarrow> e;\n   (\\<lambda>n. x) \\<longlonglongrightarrow> x\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>n. Gromov_product_at e x (v n))\n                    \\<longlonglongrightarrow> Gromov_product_at e x y\n\ngoal (1 subgoal):\n 1. (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<longlonglongrightarrow> ereal (Gromov_product_at e x y)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n  \\<longlonglongrightarrow> ereal (Gromov_product_at e x y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       eta = to_Gromov_completion xa \\<Longrightarrow>\n       limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n       \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n             ereal (deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n          ereal (deltaG TYPE('a))", "unfolding to_Gromov_completion"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x)\n           (to_Gromov_completion y) +\n          ereal (deltaG TYPE('a))", "using lim_imp_Limsup[OF _ L]"], ["proof (prove)\nusing this:\n  sequentially \\<noteq> bot \\<Longrightarrow>\n  limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa))) =\n  ereal (Gromov_product_at e x y)\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x)\n           (to_Gromov_completion y) +\n          ereal (deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n  \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n        ereal (deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma limsup_le_extended_Gromov_product_inside':\n  assumes \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> (eta::('a::Gromov_hyperbolic_space) Gromov_completion)\"\n  shows \"limsup (\\<lambda>n. Gromov_product_at e (v n) x) \\<le> extended_Gromov_product_at e eta (to_Gromov_completion x) + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e (v xa) x))\n    \\<le> extended_Gromov_product_at e eta (to_Gromov_completion x) +\n          ereal (deltaG TYPE('a))", "using limsup_le_extended_Gromov_product_inside[OF assms]"], ["proof (prove)\nusing this:\n  limsup (\\<lambda>x. ereal (Gromov_product_at ?e ?x (v x)))\n  \\<le> extended_Gromov_product_at ?e (to_Gromov_completion ?x) eta +\n        ereal (deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e (v xa) x))\n    \\<le> extended_Gromov_product_at e eta (to_Gromov_completion x) +\n          ereal (deltaG TYPE('a))", "by (simp add: Gromov_product_commute extended_Gromov_product_at_commute)"], ["", "lemma limsup_le_extended_Gromov_product:\n  assumes \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> (xi::('a::Gromov_hyperbolic_space) Gromov_completion)\"\n          \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> eta\"\n  shows \"limsup (\\<lambda>n. Gromov_product_at e (u n) (v n)) \\<le> extended_Gromov_product_at e xi eta + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "consider \"xi \\<in> Gromov_boundary \\<and> eta \\<in> Gromov_boundary\" | \"xi \\<notin> Gromov_boundary\" | \"eta \\<notin> Gromov_boundary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xi \\<in> Gromov_boundary \\<and>\n             eta \\<in> Gromov_boundary \\<Longrightarrow>\n             thesis;\n     xi \\<notin> Gromov_boundary \\<Longrightarrow> thesis;\n     eta \\<notin> Gromov_boundary \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>xi \\<in> Gromov_boundary \\<and>\n           eta \\<in> Gromov_boundary \\<Longrightarrow>\n           ?thesis;\n   xi \\<notin> Gromov_boundary \\<Longrightarrow> ?thesis;\n   eta \\<notin> Gromov_boundary \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>xi \\<in> Gromov_boundary \\<and>\n           eta \\<in> Gromov_boundary \\<Longrightarrow>\n           ?thesis;\n   xi \\<notin> Gromov_boundary \\<Longrightarrow> ?thesis;\n   eta \\<notin> Gromov_boundary \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>xi \\<in> Gromov_boundary \\<and>\n           eta \\<in> Gromov_boundary \\<Longrightarrow>\n           ?thesis;\n   xi \\<notin> Gromov_boundary \\<Longrightarrow> ?thesis;\n   eta \\<notin> Gromov_boundary \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. xi \\<in> Gromov_boundary \\<and>\n    eta \\<in> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 3. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "case 1"], ["proof (state)\nthis:\n  xi \\<in> Gromov_boundary \\<and> eta \\<in> Gromov_boundary\n\ngoal (3 subgoals):\n 1. xi \\<in> Gromov_boundary \\<and>\n    eta \\<in> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 3. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  xi \\<in> Gromov_boundary \\<and> eta \\<in> Gromov_boundary", "have B: \"xi \\<in> Gromov_boundary\" \"eta \\<in> Gromov_boundary\""], ["proof (prove)\nusing this:\n  xi \\<in> Gromov_boundary \\<and> eta \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. xi \\<in> Gromov_boundary &&& eta \\<in> Gromov_boundary", "by auto"], ["proof (state)\nthis:\n  xi \\<in> Gromov_boundary\n  eta \\<in> Gromov_boundary\n\ngoal (3 subgoals):\n 1. xi \\<in> Gromov_boundary \\<and>\n    eta \\<in> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 3. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "have A: \"limsup (\\<lambda>n. Gromov_product_at e (u n) (v n)) \\<le> liminf (\\<lambda>n. Gromov_product_at e (u' n) (v' n)) + 2 * deltaG(TYPE('a))\"\n      if H: \"(\\<lambda>n. to_Gromov_completion (u' n)) \\<longlonglongrightarrow> xi\" \"(\\<lambda>n. to_Gromov_completion (v' n)) \\<longlonglongrightarrow> eta\" for u' v'"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "have \"ereal a \\<le> liminf (\\<lambda>n. Gromov_product_at e (u' n) (v' n)) + 2 * deltaG(TYPE('a))\" if L: \"ereal a < limsup (\\<lambda>n. Gromov_product_at e (u n) (v n))\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "obtain Nu where Nu: \"\\<And>m n. m \\<ge> Nu \\<Longrightarrow> n \\<ge> Nu \\<Longrightarrow> Gromov_product_at e (u' m) (u n) \\<ge> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Nu.\n        (\\<And>m n.\n            \\<lbrakk>Nu \\<le> m; Nu \\<le> n\\<rbrakk>\n            \\<Longrightarrow> a \\<le> Gromov_product_at e (u' m)\n (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using same_limit_imp_Gromov_product_tendsto_infinity[OF \\<open>xi \\<in> Gromov_boundary\\<close> H(1) assms(1)]"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. ?C \\<le> Gromov_product_at ?a (u' n) (u m)\n\ngoal (1 subgoal):\n 1. (\\<And>Nu.\n        (\\<And>m n.\n            \\<lbrakk>Nu \\<le> m; Nu \\<le> n\\<rbrakk>\n            \\<Longrightarrow> a \\<le> Gromov_product_at e (u' m)\n (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>Nu \\<le> ?m; Nu \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> a \\<le> Gromov_product_at e (u' ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "obtain Nv where Nv: \"\\<And>m n. m \\<ge> Nv \\<Longrightarrow> n \\<ge> Nv \\<Longrightarrow> Gromov_product_at e (v m) (v' n) \\<ge> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Nv.\n        (\\<And>m n.\n            \\<lbrakk>Nv \\<le> m; Nv \\<le> n\\<rbrakk>\n            \\<Longrightarrow> a \\<le> Gromov_product_at e (v m)\n (v' n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using same_limit_imp_Gromov_product_tendsto_infinity[OF \\<open>eta \\<in> Gromov_boundary\\<close> assms(2) H(2)]"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. ?C \\<le> Gromov_product_at ?a (v n) (v' m)\n\ngoal (1 subgoal):\n 1. (\\<And>Nv.\n        (\\<And>m n.\n            \\<lbrakk>Nv \\<le> m; Nv \\<le> n\\<rbrakk>\n            \\<Longrightarrow> a \\<le> Gromov_product_at e (v m)\n (v' n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>Nv \\<le> ?m; Nv \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> a \\<le> Gromov_product_at e (v ?m) (v' ?n)\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "obtain N where N: \"ereal a < Gromov_product_at e (u N) (v N)\" \"N \\<ge> max Nu Nv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>ereal a < ereal (Gromov_product_at e (u N) (v N));\n         max Nu Nv \\<le> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using limsup_obtain[OF L]"], ["proof (prove)\nusing this:\n  \\<exists>n\\<ge>?N. ereal a < ereal (Gromov_product_at e (u n) (v n))\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>ereal a < ereal (Gromov_product_at e (u N) (v N));\n         max Nu Nv \\<le> N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ereal a < ereal (Gromov_product_at e (u N) (v N))\n  max Nu Nv \\<le> N\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  ereal a < ereal (Gromov_product_at e (u N) (v N))\n  max Nu Nv \\<le> N", "have \"N \\<ge> Nu\" \"N \\<ge> Nv\""], ["proof (prove)\nusing this:\n  ereal a < ereal (Gromov_product_at e (u N) (v N))\n  max Nu Nv \\<le> N\n\ngoal (1 subgoal):\n 1. Nu \\<le> N &&& Nv \\<le> N", "by auto"], ["proof (state)\nthis:\n  Nu \\<le> N\n  Nv \\<le> N\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "have *: \"a - 2 * deltaG(TYPE('a)) \\<le> Gromov_product_at e (u' n) (v' n)\" if \"n \\<ge> max Nu Nv\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' n) (v' n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' n) (v' n)", "have n: \"n \\<ge> Nu\" \"n \\<ge> Nv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Nu \\<le> n &&& Nv \\<le> n", "using that"], ["proof (prove)\nusing this:\n  max Nu Nv \\<le> n\n\ngoal (1 subgoal):\n 1. Nu \\<le> n &&& Nv \\<le> n", "by auto"], ["proof (state)\nthis:\n  Nu \\<le> n\n  Nv \\<le> n\n\ngoal (1 subgoal):\n 1. a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' n) (v' n)", "have \"a \\<le> Min {Gromov_product_at e (u' n) (u N), Gromov_product_at e (u N) (v N), Gromov_product_at e (v N) (v' n)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> Min {Gromov_product_at e (u' n) (u N),\n                 Gromov_product_at e (u N) (v N),\n                 Gromov_product_at e (v N) (v' n)}", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. a \\<le> Gromov_product_at e (u' n) (u N)\n 2. a \\<le> Gromov_product_at e (u N) (v N)\n 3. a \\<le> Gromov_product_at e (v N) (v' n)", "using N(1) Nu[OF n(1) \\<open>N \\<ge> Nu\\<close>] Nv[OF \\<open>N \\<ge> Nv\\<close> n(2)]"], ["proof (prove)\nusing this:\n  ereal a < ereal (Gromov_product_at e (u N) (v N))\n  a \\<le> Gromov_product_at e (u' n) (u N)\n  a \\<le> Gromov_product_at e (v N) (v' n)\n\ngoal (3 subgoals):\n 1. a \\<le> Gromov_product_at e (u' n) (u N)\n 2. a \\<le> Gromov_product_at e (u N) (v N)\n 3. a \\<le> Gromov_product_at e (v N) (v' n)", "by auto"], ["proof (state)\nthis:\n  a \\<le> Min {Gromov_product_at e (u' n) (u N),\n               Gromov_product_at e (u N) (v N),\n               Gromov_product_at e (v N) (v' n)}\n\ngoal (1 subgoal):\n 1. a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' n) (v' n)", "also"], ["proof (state)\nthis:\n  a \\<le> Min {Gromov_product_at e (u' n) (u N),\n               Gromov_product_at e (u N) (v N),\n               Gromov_product_at e (v N) (v' n)}\n\ngoal (1 subgoal):\n 1. a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' n) (v' n)", "have \"... \\<le> Gromov_product_at e (u' n) (v' n) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {Gromov_product_at e (u' n) (u N), Gromov_product_at e (u N) (v N),\n         Gromov_product_at e (v N) (v' n)}\n    \\<le> Gromov_product_at e (u' n) (v' n) + 2 * deltaG TYPE('a)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  Min {Gromov_product_at e (u' n) (u N), Gromov_product_at e (u N) (v N),\n       Gromov_product_at e (v N) (v' n)}\n  \\<le> Gromov_product_at e (u' n) (v' n) + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' n) (v' n)", "finally"], ["proof (chain)\npicking this:\n  a \\<le> Gromov_product_at e (u' n) (v' n) + 2 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le> Gromov_product_at e (u' n) (v' n) + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' n) (v' n)", "by auto"], ["proof (state)\nthis:\n  a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' n) (v' n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max Nu Nv \\<le> ?n \\<Longrightarrow>\n  a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' ?n) (v' ?n)\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "have \"a - 2 * deltaG(TYPE('a)) \\<le> liminf (\\<lambda>n. Gromov_product_at e (u' n) (v' n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (a - 2 * deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x)))", "apply (rule Liminf_bounded)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (a - 2 * deltaG TYPE('a))\n       \\<le> ereal (Gromov_product_at e (u' n) (v' n))", "unfolding eventually_sequentially"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          ereal (a - 2 * deltaG TYPE('a))\n          \\<le> ereal (Gromov_product_at e (u' n) (v' n))", "using *"], ["proof (prove)\nusing this:\n  max Nu Nv \\<le> ?n \\<Longrightarrow>\n  a - 2 * deltaG TYPE('a) \\<le> Gromov_product_at e (u' ?n) (v' ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          ereal (a - 2 * deltaG TYPE('a))\n          \\<le> ereal (Gromov_product_at e (u' n) (v' n))", "by fastforce"], ["proof (state)\nthis:\n  ereal (a - 2 * deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x)))\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  ereal (a - 2 * deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal (a - 2 * deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x)))\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "unfolding ereal_minus(1)[symmetric]"], ["proof (prove)\nusing this:\n  ereal a - ereal (2 * deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x)))\n\ngoal (1 subgoal):\n 1. ereal a\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "by (subst ereal_minus_le[symmetric], auto)"], ["proof (state)\nthis:\n  ereal a\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n        ereal (2 * deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ereal ?a\n  < limsup\n     (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) \\<Longrightarrow>\n  ereal ?a\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n        ereal (2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  ereal ?a\n  < limsup\n     (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) \\<Longrightarrow>\n  ereal ?a\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n        ereal (2 * deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal ?a\n  < limsup\n     (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) \\<Longrightarrow>\n  ereal ?a\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n        ereal (2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "using ereal_dense2 not_less"], ["proof (prove)\nusing this:\n  ereal ?a\n  < limsup\n     (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) \\<Longrightarrow>\n  ereal ?a\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n        ereal (2 * deltaG TYPE('a))\n  ?x < ?y \\<Longrightarrow> \\<exists>z. ?x < ereal z \\<and> ereal z < ?y\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n          ereal (2 * deltaG TYPE('a))", "by blast"], ["proof (state)\nthis:\n  limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n  \\<le> liminf (\\<lambda>x. ereal (Gromov_product_at e (u' x) (v' x))) +\n        ereal (2 * deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<lambda>n. to_Gromov_completion (?u' n))\n           \\<longlonglongrightarrow> xi;\n   (\\<lambda>n. to_Gromov_completion (?v' n))\n   \\<longlonglongrightarrow> eta\\<rbrakk>\n  \\<Longrightarrow> limsup\n                     (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n                    \\<le> liminf\n                           (\\<lambda>x.\n                               ereal\n                                (Gromov_product_at e (?u' x) (?v' x))) +\n                          ereal (2 * deltaG TYPE('a))\n\ngoal (3 subgoals):\n 1. xi \\<in> Gromov_boundary \\<and>\n    eta \\<in> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 3. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "have \"limsup (\\<lambda>n. Gromov_product_at e (u n) (v n)) - 2 * deltaG(TYPE('a)) \\<le> extended_Gromov_product_at e xi eta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) -\n    ereal (2 * deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at e xi eta", "unfolding extended_Gromov_product_at_topological"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) -\n    ereal (2 * deltaG TYPE('a))\n    \\<le> Inf {liminf\n                (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) |\n               u v.\n               (\\<lambda>n. to_Gromov_completion (u n))\n               \\<longlonglongrightarrow> xi \\<and>\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> eta}", "by (rule Inf_greatest, auto simp add: A)"], ["proof (state)\nthis:\n  limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) -\n  ereal (2 * deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at e xi eta\n\ngoal (3 subgoals):\n 1. xi \\<in> Gromov_boundary \\<and>\n    eta \\<in> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 3. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) -\n  ereal (2 * deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at e xi eta", "show ?thesis"], ["proof (prove)\nusing this:\n  limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x))) -\n  ereal (2 * deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at e xi eta\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n  \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "case 2"], ["proof (state)\nthis:\n  xi \\<notin> Gromov_boundary\n\ngoal (2 subgoals):\n 1. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  xi \\<notin> Gromov_boundary", "obtain x where x: \"xi = to_Gromov_completion x\""], ["proof (prove)\nusing this:\n  xi \\<notin> Gromov_boundary\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        xi = to_Gromov_completion x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases xi, auto)"], ["proof (state)\nthis:\n  xi = to_Gromov_completion x\n\ngoal (2 subgoals):\n 1. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "have A: \"limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "define h where \"h = (\\<lambda>n. Gromov_product_at e (u n) (v n) - Gromov_product_at e x (v n))\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>n.\n      Gromov_product_at e (u n) (v n) - Gromov_product_at e x (v n))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "have h: \"h \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<longlonglongrightarrow> 0", "apply (rule tendsto_rabs_zero_cancel, rule tendsto_sandwich[of \"\\<lambda>n. 0\" _ _ \"\\<lambda>n. dist (u n) x\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> \\<bar>h n\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially. \\<bar>h n\\<bar> \\<le> dist (u n) x\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "unfolding h_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e x (v n)\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e x (v n)\\<bar>\n       \\<le> dist (u n) x\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "using Gromov_product_at_diff2[of e _ _ x] assms(1)"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e ?x ?z - Gromov_product_at e x ?z\\<bar>\n  \\<le> dist ?x x\n  (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> xi\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e x (v n)\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e x (v n)\\<bar>\n       \\<le> dist (u n) x\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "unfolding x"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e ?x ?z - Gromov_product_at e x ?z\\<bar>\n  \\<le> dist ?x x\n  (\\<lambda>n. to_Gromov_completion (u n))\n  \\<longlonglongrightarrow> to_Gromov_completion x\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e x (v n)\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e x (v n)\\<bar>\n       \\<le> dist (u n) x\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xa z.\n                \\<bar>Gromov_product_at e xa z -\n                      Gromov_product_at e x z\\<bar>\n                \\<le> dist xa x;\n     u \\<longlonglongrightarrow> x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "using tendsto_dist_iff"], ["proof (prove)\nusing this:\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xa z.\n                \\<bar>Gromov_product_at e xa z -\n                      Gromov_product_at e x z\\<bar>\n                \\<le> dist xa x;\n     u \\<longlonglongrightarrow> x\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (u n) x) \\<longlonglongrightarrow> 0", "by blast"], ["proof (state)\nthis:\n  h \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "have *: \"ereal (Gromov_product_at e (u n) (v n)) = h n + ereal (Gromov_product_at e x (v n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (h n) + ereal (Gromov_product_at e x (v n))", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (Gromov_product_at e (u n) (v n) - Gromov_product_at e x (v n)) +\n    ereal (Gromov_product_at e x (v n))", "by auto"], ["proof (state)\nthis:\n  ereal (Gromov_product_at e (u ?n) (v ?n)) =\n  ereal (h ?n) + ereal (Gromov_product_at e x (v ?n))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "have \"limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = 0 + limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    0 + limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (h n) + ereal (Gromov_product_at e x (v n))) =\n    0 + limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "apply (rule ereal_limsup_lim_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "using h"], ["proof (prove)\nusing this:\n  h \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "by (auto simp add: zero_ereal_def)"], ["proof (state)\nthis:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "then"], ["proof (chain)\npicking this:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "show ?thesis"], ["proof (prove)\nusing this:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))", "by simp"], ["proof (state)\nthis:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  limsup (\\<lambda>n. ereal (Gromov_product_at e x (v n)))\n\ngoal (2 subgoals):\n 1. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "have *: \"ereal (deltaG TYPE('a)) \\<le> ereal (2 * deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (deltaG TYPE('a)) \\<le> ereal (2 * deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  ereal (deltaG TYPE('a)) \\<le> ereal (2 * deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. xi \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n 2. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "unfolding A x"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n          ereal (2 * deltaG TYPE('a))", "using limsup_le_extended_Gromov_product_inside[OF assms(2), of e x] *"], ["proof (prove)\nusing this:\n  limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n  \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n        ereal (deltaG TYPE('a))\n  ereal (deltaG TYPE('a)) \\<le> ereal (2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>xa. ereal (Gromov_product_at e x (v xa)))\n    \\<le> extended_Gromov_product_at e (to_Gromov_completion x) eta +\n          ereal (2 * deltaG TYPE('a))", "by (meson add_left_mono order.trans)"], ["proof (state)\nthis:\n  limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n  \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "case 3"], ["proof (state)\nthis:\n  eta \\<notin> Gromov_boundary\n\ngoal (1 subgoal):\n 1. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  eta \\<notin> Gromov_boundary", "obtain y where y: \"eta = to_Gromov_completion y\""], ["proof (prove)\nusing this:\n  eta \\<notin> Gromov_boundary\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        eta = to_Gromov_completion y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases eta, auto)"], ["proof (state)\nthis:\n  eta = to_Gromov_completion y\n\ngoal (1 subgoal):\n 1. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "have A: \"limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "define h where \"h = (\\<lambda>n. Gromov_product_at e (u n) (v n) - Gromov_product_at e (u n) y)\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>n.\n      Gromov_product_at e (u n) (v n) - Gromov_product_at e (u n) y)\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "have h: \"h \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<longlonglongrightarrow> 0", "apply (rule tendsto_rabs_zero_cancel, rule tendsto_sandwich[of \"\\<lambda>n. 0\" _ _ \"\\<lambda>n. dist (v n) y\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> \\<bar>h n\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially. \\<bar>h n\\<bar> \\<le> dist (v n) y\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (v n) y) \\<longlonglongrightarrow> 0", "unfolding h_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e (u n) y\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e (u n) y\\<bar>\n       \\<le> dist (v n) y\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (v n) y) \\<longlonglongrightarrow> 0", "using Gromov_product_at_diff3[of e _ _ y] assms(2)"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e ?x ?y - Gromov_product_at e ?x y\\<bar>\n  \\<le> dist ?y y\n  (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> eta\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e (u n) y\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e (u n) y\\<bar>\n       \\<le> dist (v n) y\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (v n) y) \\<longlonglongrightarrow> 0", "unfolding y"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e ?x ?y - Gromov_product_at e ?x y\\<bar>\n  \\<le> dist ?y y\n  (\\<lambda>n. to_Gromov_completion (v n))\n  \\<longlonglongrightarrow> to_Gromov_completion y\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> \\<bar>Gromov_product_at e (u n) (v n) -\n                     Gromov_product_at e (u n) y\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       \\<bar>Gromov_product_at e (u n) (v n) -\n             Gromov_product_at e (u n) y\\<bar>\n       \\<le> dist (v n) y\n 3. (\\<lambda>n. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. dist (v n) y) \\<longlonglongrightarrow> 0", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x ya.\n                \\<bar>Gromov_product_at e x ya -\n                      Gromov_product_at e x y\\<bar>\n                \\<le> dist ya y;\n     v \\<longlonglongrightarrow> y\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (v n) y) \\<longlonglongrightarrow> 0", "using tendsto_dist_iff"], ["proof (prove)\nusing this:\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x ya.\n                \\<bar>Gromov_product_at e x ya -\n                      Gromov_product_at e x y\\<bar>\n                \\<le> dist ya y;\n     v \\<longlonglongrightarrow> y\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. dist (v n) y) \\<longlonglongrightarrow> 0", "by blast"], ["proof (state)\nthis:\n  h \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "have *: \"ereal (Gromov_product_at e (u n) (v n)) = h n + ereal (Gromov_product_at e (u n) y)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (h n) + ereal (Gromov_product_at e (u n) y)", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (Gromov_product_at e (u n) (v n)) =\n    ereal (Gromov_product_at e (u n) (v n) - Gromov_product_at e (u n) y) +\n    ereal (Gromov_product_at e (u n) y)", "by auto"], ["proof (state)\nthis:\n  ereal (Gromov_product_at e (u ?n) (v ?n)) =\n  ereal (h ?n) + ereal (Gromov_product_at e (u ?n) y)\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "have \"limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) = 0 + limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    0 + limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (h n) + ereal (Gromov_product_at e (u n) y)) =\n    0 + limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "apply (rule ereal_limsup_lim_add)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "using h"], ["proof (prove)\nusing this:\n  h \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. ereal (h n)) \\<longlonglongrightarrow> 0\n 2. \\<bar>0\\<bar> \\<noteq> \\<infinity>", "by (auto simp add: zero_ereal_def)"], ["proof (state)\nthis:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "then"], ["proof (chain)\npicking this:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "show ?thesis"], ["proof (prove)\nusing this:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  0 + limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n    limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))", "by simp"], ["proof (state)\nthis:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) (v n))) =\n  limsup (\\<lambda>n. ereal (Gromov_product_at e (u n) y))\n\ngoal (1 subgoal):\n 1. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "have *: \"ereal (deltaG TYPE('a)) \\<le> ereal (2 * deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (deltaG TYPE('a)) \\<le> ereal (2 * deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  ereal (deltaG TYPE('a)) \\<le> ereal (2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. eta \\<notin> Gromov_boundary \\<Longrightarrow>\n    limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n    \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))", "unfolding A y"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) y))\n    \\<le> extended_Gromov_product_at e xi (to_Gromov_completion y) +\n          ereal (2 * deltaG TYPE('a))", "using limsup_le_extended_Gromov_product_inside'[OF assms(1), of e y] *"], ["proof (prove)\nusing this:\n  limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) y))\n  \\<le> extended_Gromov_product_at e xi (to_Gromov_completion y) +\n        ereal (deltaG TYPE('a))\n  ereal (deltaG TYPE('a)) \\<le> ereal (2 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) y))\n    \\<le> extended_Gromov_product_at e xi (to_Gromov_completion y) +\n          ereal (2 * deltaG TYPE('a))", "by (meson add_left_mono order.trans)"], ["proof (state)\nthis:\n  limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n  \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  limsup (\\<lambda>x. ereal (Gromov_product_at e (u x) (v x)))\n  \\<le> extended_Gromov_product_at e xi eta + ereal (2 * deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>One can then extend to the boundary the fact that $(y,z)_x + (x,z)_y = d(x,y)$, up to a\nconstant $\\delta$, by taking this identity inside and passing to the limit.\\<close>"], ["", "lemma extended_Gromov_product_add_le:\n  \"extended_Gromov_product_at x xi (to_Gromov_completion y) + extended_Gromov_product_at y xi (to_Gromov_completion x) \\<le> dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "obtain u where u: \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u.\n        (\\<lambda>n. to_Gromov_completion (u n))\n        \\<longlonglongrightarrow> xi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using rep_Gromov_completion_limit"], ["proof (prove)\nusing this:\n  (\\<lambda>n. to_Gromov_completion (rep_Gromov_completion ?x n))\n  \\<longlonglongrightarrow> ?x\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        (\\<lambda>n. to_Gromov_completion (u n))\n        \\<longlonglongrightarrow> xi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> xi\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "have \"liminf (\\<lambda>n. ereal (Gromov_product_at a b (u n))) \\<ge> 0\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at a b (u n)))", "by (rule Liminf_bounded[OF always_eventually], auto)"], ["proof (state)\nthis:\n  0 \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at ?a ?b (u n)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at ?a ?b (u n)))", "have *: \"liminf (\\<lambda>n. ereal (Gromov_product_at a b (u n))) \\<noteq> -\\<infinity>\" for a b"], ["proof (prove)\nusing this:\n  0 \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at ?a ?b (u n)))\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at a b (u n))) \\<noteq>\n    - \\<infinity>", "by auto"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at ?a ?b (u n))) \\<noteq>\n  - \\<infinity>\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "have \"extended_Gromov_product_at x xi (to_Gromov_completion y) + extended_Gromov_product_at y xi (to_Gromov_completion x)\n      \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) + liminf (\\<lambda>n. Gromov_product_at y x (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n          liminf (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y)\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))\n 2. extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))", "using extended_Gromov_product_le_liminf [OF u, of \"\\<lambda>n. y\" \"to_Gromov_completion y\" x]\n      extended_Gromov_product_le_liminf [OF u, of \"\\<lambda>n. x\" \"to_Gromov_completion x\" y]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. to_Gromov_completion y)\n  \\<longlonglongrightarrow> to_Gromov_completion y \\<Longrightarrow>\n  extended_Gromov_product_at x xi (to_Gromov_completion y)\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at x (u xa) y))\n  (\\<lambda>n. to_Gromov_completion x)\n  \\<longlonglongrightarrow> to_Gromov_completion x \\<Longrightarrow>\n  extended_Gromov_product_at y xi (to_Gromov_completion x)\n  \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at y (u xa) x))\n\ngoal (2 subgoals):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y)\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))\n 2. extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> liminf (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))", "by (auto simp add: Gromov_product_commute)"], ["proof (state)\nthis:\n  extended_Gromov_product_at x xi (to_Gromov_completion y) +\n  extended_Gromov_product_at y xi (to_Gromov_completion x)\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n        liminf (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "also"], ["proof (state)\nthis:\n  extended_Gromov_product_at x xi (to_Gromov_completion y) +\n  extended_Gromov_product_at y xi (to_Gromov_completion x)\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n        liminf (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "have \"... \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)) + Gromov_product_at y x (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n    liminf (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))\n    \\<le> liminf\n           (\\<lambda>n.\n               ereal (Gromov_product_at x y (u n)) +\n               ereal (Gromov_product_at y x (u n)))", "by (rule ereal_liminf_add_mono, auto simp add: *)"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n  liminf (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))\n  \\<le> liminf\n         (\\<lambda>n.\n             ereal (Gromov_product_at x y (u n)) +\n             ereal (Gromov_product_at y x (u n)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "also"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n  liminf (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))\n  \\<le> liminf\n         (\\<lambda>n.\n             ereal (Gromov_product_at x y (u n)) +\n             ereal (Gromov_product_at y x (u n)))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "have \"... = dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf\n     (\\<lambda>n.\n         ereal (Gromov_product_at x y (u n)) +\n         ereal (Gromov_product_at y x (u n))) =\n    ereal (dist x y)", "apply (simp add: Gromov_product_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (dist x y)) = ereal (dist x y)", "by (metis lim_imp_Liminf sequentially_bot tendsto_const)"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at x y (u n)) +\n       ereal (Gromov_product_at y x (u n))) =\n  ereal (dist x y)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "finally"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at x xi (to_Gromov_completion y) +\n  extended_Gromov_product_at y xi (to_Gromov_completion x)\n  \\<le> ereal (dist x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at x xi (to_Gromov_completion y) +\n  extended_Gromov_product_at y xi (to_Gromov_completion x)\n  \\<le> ereal (dist x y)\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at x xi (to_Gromov_completion y) +\n    extended_Gromov_product_at y xi (to_Gromov_completion x)\n    \\<le> ereal (dist x y)", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_product_at x xi (to_Gromov_completion y) +\n  extended_Gromov_product_at y xi (to_Gromov_completion x)\n  \\<le> ereal (dist x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_Gromov_product_add_ge:\n  \"extended_Gromov_product_at (x::'a::Gromov_hyperbolic_space) xi (to_Gromov_completion y) + extended_Gromov_product_at y xi (to_Gromov_completion x) \\<ge> dist x y - deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y - deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at x xi (to_Gromov_completion y) +\n          extended_Gromov_product_at y xi (to_Gromov_completion x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ereal (dist x y - deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at x xi (to_Gromov_completion y) +\n          extended_Gromov_product_at y xi (to_Gromov_completion x)", "have A: \"dist x y - extended_Gromov_product_at y (to_Gromov_completion x) xi - deltaG(TYPE('a)) \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))\"\n    if \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> xi\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))", "have \"dist x y = liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)) + Gromov_product_at y x (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y) =\n    liminf\n     (\\<lambda>n.\n         ereal (Gromov_product_at x y (u n)) +\n         ereal (Gromov_product_at y x (u n)))", "apply (simp add: Gromov_product_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y) = liminf (\\<lambda>n. ereal (dist x y))", "by (metis lim_imp_Liminf sequentially_bot tendsto_const)"], ["proof (state)\nthis:\n  ereal (dist x y) =\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at x y (u n)) +\n       ereal (Gromov_product_at y x (u n)))\n\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))", "also"], ["proof (state)\nthis:\n  ereal (dist x y) =\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at x y (u n)) +\n       ereal (Gromov_product_at y x (u n)))\n\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))", "have \"... \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) + limsup (\\<lambda>n. Gromov_product_at y x (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf\n     (\\<lambda>n.\n         ereal (Gromov_product_at x y (u n)) +\n         ereal (Gromov_product_at y x (u n)))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n          limsup (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))", "by (rule ereal_liminf_limsup_add)"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at x y (u n)) +\n       ereal (Gromov_product_at y x (u n)))\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n        limsup (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))\n\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))", "also"], ["proof (state)\nthis:\n  liminf\n   (\\<lambda>n.\n       ereal (Gromov_product_at x y (u n)) +\n       ereal (Gromov_product_at y x (u n)))\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n        limsup (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))\n\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))", "have \"... \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) + (extended_Gromov_product_at y (to_Gromov_completion x) xi + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n    limsup (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n          (extended_Gromov_product_at y (to_Gromov_completion x) xi +\n           ereal (deltaG TYPE('a)))", "by (intro mono_intros limsup_le_extended_Gromov_product_inside[OF that])"], ["proof (state)\nthis:\n  liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n  limsup (\\<lambda>xa. ereal (Gromov_product_at y x (u xa)))\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n        (extended_Gromov_product_at y (to_Gromov_completion x) xi +\n         ereal (deltaG TYPE('a)))\n\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))", "finally"], ["proof (chain)\npicking this:\n  ereal (dist x y)\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n        (extended_Gromov_product_at y (to_Gromov_completion x) xi +\n         ereal (deltaG TYPE('a)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal (dist x y)\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n))) +\n        (extended_Gromov_product_at y (to_Gromov_completion x) xi +\n         ereal (deltaG TYPE('a)))\n\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  ereal (dist x y) -\n  extended_Gromov_product_at y (to_Gromov_completion x) xi -\n  ereal (deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (u n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n. to_Gromov_completion (?u n))\n  \\<longlonglongrightarrow> xi \\<Longrightarrow>\n  ereal (dist x y) -\n  extended_Gromov_product_at y (to_Gromov_completion x) xi -\n  ereal (deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (?u n)))\n\ngoal (1 subgoal):\n 1. ereal (dist x y - deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at x xi (to_Gromov_completion y) +\n          extended_Gromov_product_at y xi (to_Gromov_completion x)", "have \"dist x y - extended_Gromov_product_at y (to_Gromov_completion x) xi - deltaG(TYPE('a)) \\<le> extended_Gromov_product_at x (to_Gromov_completion y) xi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at x (to_Gromov_completion y) xi", "unfolding extended_Gromov_product_inside_boundary[of x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y) -\n    extended_Gromov_product_at y (to_Gromov_completion x) xi -\n    ereal (deltaG TYPE('a))\n    \\<le> Inf {liminf (\\<lambda>n. ereal (Gromov_product_at x y (v n))) |v.\n               (\\<lambda>n. to_Gromov_completion (v n))\n               \\<longlonglongrightarrow> xi}", "apply (rule Inf_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {liminf (\\<lambda>n. ereal (Gromov_product_at x y (v n))) |\n                 v. (\\<lambda>n. to_Gromov_completion (v n))\n                    \\<longlonglongrightarrow> xi} \\<Longrightarrow>\n       ereal (dist x y) -\n       extended_Gromov_product_at y (to_Gromov_completion x) xi -\n       ereal (deltaG TYPE('a))\n       \\<le> xa", "using A"], ["proof (prove)\nusing this:\n  (\\<lambda>n. to_Gromov_completion (?u n))\n  \\<longlonglongrightarrow> xi \\<Longrightarrow>\n  ereal (dist x y) -\n  extended_Gromov_product_at y (to_Gromov_completion x) xi -\n  ereal (deltaG TYPE('a))\n  \\<le> liminf (\\<lambda>n. ereal (Gromov_product_at x y (?u n)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {liminf (\\<lambda>n. ereal (Gromov_product_at x y (v n))) |\n                 v. (\\<lambda>n. to_Gromov_completion (v n))\n                    \\<longlonglongrightarrow> xi} \\<Longrightarrow>\n       ereal (dist x y) -\n       extended_Gromov_product_at y (to_Gromov_completion x) xi -\n       ereal (deltaG TYPE('a))\n       \\<le> xa", "by auto"], ["proof (state)\nthis:\n  ereal (dist x y) -\n  extended_Gromov_product_at y (to_Gromov_completion x) xi -\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at x (to_Gromov_completion y) xi\n\ngoal (1 subgoal):\n 1. ereal (dist x y - deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at x xi (to_Gromov_completion y) +\n          extended_Gromov_product_at y xi (to_Gromov_completion x)", "then"], ["proof (chain)\npicking this:\n  ereal (dist x y) -\n  extended_Gromov_product_at y (to_Gromov_completion x) xi -\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at x (to_Gromov_completion y) xi", "show ?thesis"], ["proof (prove)\nusing this:\n  ereal (dist x y) -\n  extended_Gromov_product_at y (to_Gromov_completion x) xi -\n  ereal (deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at x (to_Gromov_completion y) xi\n\ngoal (1 subgoal):\n 1. ereal (dist x y - deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at x xi (to_Gromov_completion y) +\n          extended_Gromov_product_at y xi (to_Gromov_completion x)", "apply (auto simp add: algebra_simps extended_Gromov_product_at_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y)\n    \\<le> ereal (deltaG TYPE('a)) +\n          (extended_Gromov_product_at x xi (to_Gromov_completion y) +\n           extended_Gromov_product_at y xi\n            (to_Gromov_completion x)) \\<Longrightarrow>\n    ereal (dist x y - deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at x xi (to_Gromov_completion y) +\n          extended_Gromov_product_at y xi (to_Gromov_completion x)", "unfolding ereal_minus(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist x y)\n    \\<le> ereal (deltaG TYPE('a)) +\n          (extended_Gromov_product_at x xi (to_Gromov_completion y) +\n           extended_Gromov_product_at y xi\n            (to_Gromov_completion x)) \\<Longrightarrow>\n    ereal (dist x y) - ereal (deltaG TYPE('a))\n    \\<le> extended_Gromov_product_at x xi (to_Gromov_completion y) +\n          extended_Gromov_product_at y xi (to_Gromov_completion x)", "by (subst ereal_minus_le, auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  ereal (dist x y - deltaG TYPE('a))\n  \\<le> extended_Gromov_product_at x xi (to_Gromov_completion y) +\n        extended_Gromov_product_at y xi (to_Gromov_completion x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If one perturbs a sequence inside the space by a bounded distance, one does not change the\nlimit on the boundary.\\<close>"], ["", "lemma Gromov_converging_at_boundary_bounded_perturbation:\n  assumes \"(\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\"\n          \"x \\<in> Gromov_boundary\"\n          \"\\<And>n. dist (u n) (v n) \\<le> C\"\n  shows \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> x", "have \"(\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "proof (rule tendsto_sandwich[of \"\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x - C\" _ _ \"\\<lambda>n. \\<infinity>\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x -\n       ereal C\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v n)) x\n 2. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x\n       \\<le> \\<infinity>\n 3. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n         x -\n        ereal C)\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "show \"\\<forall>\\<^sub>F n in sequentially. extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x - ereal C \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x -\n       ereal C\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v n)) x", "proof (rule always_eventually, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u xa)) x\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v xa)) x +\n             ereal C", "fix n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u xa)) x\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v xa)) x +\n             ereal C", "have \"extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x\n                  + extended_Gromov_distance (to_Gromov_completion (u n)) (to_Gromov_completion (v n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n           x +\n          extended_Gromov_distance (to_Gromov_completion (u n))\n           (to_Gromov_completion (v n))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n         x +\n        extended_Gromov_distance (to_Gromov_completion (u n))\n         (to_Gromov_completion (v n))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u xa)) x\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v xa)) x +\n             ereal C", "also"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n         x +\n        extended_Gromov_distance (to_Gromov_completion (u n))\n         (to_Gromov_completion (v n))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u xa)) x\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v xa)) x +\n             ereal C", "have \"... \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x +\n    extended_Gromov_distance (to_Gromov_completion (u n))\n     (to_Gromov_completion (v n))\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n           x +\n          ereal C", "using assms(3)[of n]"], ["proof (prove)\nusing this:\n  dist (u n) (v n) \\<le> C\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x +\n    extended_Gromov_distance (to_Gromov_completion (u n))\n     (to_Gromov_completion (v n))\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n           x +\n          ereal C", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x +\n  extended_Gromov_distance (to_Gromov_completion (u n))\n   (to_Gromov_completion (v n))\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n         x +\n        ereal C\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (u xa)) x\n       \\<le> extended_Gromov_product_at basepoint\n              (to_Gromov_completion (v xa)) x +\n             ereal C", "finally"], ["proof (chain)\npicking this:\n  extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n         x +\n        ereal C", "show \"extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x + ereal C\""], ["proof (prove)\nusing this:\n  extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n         x +\n        ereal C\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n           x +\n          ereal C", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x\n  \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n         x +\n        ereal C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x -\n     ereal C\n     \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v n))\n            x\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x\n       \\<le> \\<infinity>\n 2. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n         x -\n        ereal C)\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "have \"(\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x - ereal C) \\<longlonglongrightarrow> \\<infinity> - ereal C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n         x -\n        ereal C)\n    \\<longlonglongrightarrow> \\<infinity> - ereal C", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x)\n    \\<longlonglongrightarrow> \\<infinity>\n 2. \\<not> (\\<infinity> = \\<infinity> \\<and> ereal C = \\<infinity> \\<or>\n            \\<infinity> = - \\<infinity> \\<and> ereal C = - \\<infinity>)", "unfolding Gromov_completion_boundary_limit[OF \\<open>x \\<in> Gromov_boundary\\<close>, symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\n 2. \\<not> (\\<infinity> = \\<infinity> \\<and> ereal C = \\<infinity> \\<or>\n            \\<infinity> = - \\<infinity> \\<and> ereal C = - \\<infinity>)", "using assms(1)"], ["proof (prove)\nusing this:\n  (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. to_Gromov_completion (u n)) \\<longlonglongrightarrow> x\n 2. \\<not> (\\<infinity> = \\<infinity> \\<and> ereal C = \\<infinity> \\<or>\n            \\<infinity> = - \\<infinity> \\<and> ereal C = - \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x -\n      ereal C)\n  \\<longlonglongrightarrow> \\<infinity> - ereal C\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x\n       \\<le> \\<infinity>\n 2. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n         x -\n        ereal C)\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x -\n      ereal C)\n  \\<longlonglongrightarrow> \\<infinity> - ereal C", "show \"(\\<lambda>n. extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x - ereal C) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x -\n      ereal C)\n  \\<longlonglongrightarrow> \\<infinity> - ereal C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (u n))\n         x -\n        ereal C)\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (u n)) x -\n      ereal C)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x\n       \\<le> \\<infinity>\n 2. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "qed (auto)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> x", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n  \\<longlonglongrightarrow> \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> x", "unfolding Gromov_completion_boundary_limit[OF \\<open>x \\<in> Gromov_boundary\\<close>]"], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_product_at basepoint (to_Gromov_completion (v n)) x)\n    \\<longlonglongrightarrow> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We prove that the extended Gromov distance is a continuous function of one variable,\nby separating the different cases at infinity and inside the space. Note that it is not a\ncontinuous function of both variables: if $u_n$ is inside the space but tends to a point $x$ in the\nboundary, then the extended Gromov distance between $u_n$ and $u_n$ is $0$, but for the limit it is\n$\\infty$.\\<close>"], ["", "lemma extended_Gromov_distance_continuous:\n  \"continuous_on UNIV (\\<lambda>y. extended_Gromov_distance x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (extended_Gromov_distance x)", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       continuous_on UNIV (extended_Gromov_distance x)\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    continuous_on UNIV (extended_Gromov_distance x)", "text \\<open>First, if $x$ is in the boundary, then all distances to $x$ are infinite, and the statement\n  is trivial.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       continuous_on UNIV (extended_Gromov_distance x)\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    continuous_on UNIV (extended_Gromov_distance x)", "case boundary"], ["proof (state)\nthis:\n  x \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       continuous_on UNIV (extended_Gromov_distance x)\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    continuous_on UNIV (extended_Gromov_distance x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> Gromov_boundary", "have *: \"extended_Gromov_distance x y = \\<infinity>\" for y"], ["proof (prove)\nusing this:\n  x \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  extended_Gromov_distance x ?y = \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       continuous_on UNIV (extended_Gromov_distance x)\n 2. x \\<in> Gromov_boundary \\<Longrightarrow>\n    continuous_on UNIV (extended_Gromov_distance x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (extended_Gromov_distance x)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>y. \\<infinity>)", "using continuous_on_topological"], ["proof (prove)\nusing this:\n  continuous_on ?s ?f =\n  (\\<forall>x\\<in>?s.\n      \\<forall>B.\n         open B \\<longrightarrow>\n         ?f x \\<in> B \\<longrightarrow>\n         (\\<exists>A.\n             open A \\<and>\n             x \\<in> A \\<and>\n             (\\<forall>y\\<in>?s. y \\<in> A \\<longrightarrow> ?f y \\<in> B)))\n\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>y. \\<infinity>)", "by blast"], ["proof (state)\nthis:\n  continuous_on UNIV (extended_Gromov_distance x)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       continuous_on UNIV (extended_Gromov_distance x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       continuous_on UNIV (extended_Gromov_distance x)", "text \\<open>Next, consider the case where $x$ is inside the space. We split according to whether $y$ is\n  inside the space or at infinity.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       continuous_on UNIV (extended_Gromov_distance x)", "case (to_Gromov_completion a)"], ["proof (state)\nthis:\n  x = to_Gromov_completion a\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       continuous_on UNIV (extended_Gromov_distance x)", "have \"(\\<lambda>n. extended_Gromov_distance x (u n)) \\<longlonglongrightarrow> extended_Gromov_distance x y\" if \"u \\<longlonglongrightarrow> y\" for u y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "text \\<open>If $y$ is at infinity, then we know that the Gromov product of $u_n$ and $y$ tends to\n    infinity. Therefore, the extended distance from $u_n$ to any fixed point also tends to infinity\n    (as the Gromov product is bounded from below by the extended distance).\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "case boundary"], ["proof (state)\nthis:\n  y \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "have *: \"(\\<lambda>n. extended_Gromov_product_at a (u n) y) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_Gromov_product_at a (u n) y)\n    \\<longlonglongrightarrow> \\<infinity>", "by (rule extended_Gromov_product_tendsto_PInf_a_b[OF iffD1[OF Gromov_completion_boundary_limit, OF boundary \\<open>u \\<longlonglongrightarrow> y\\<close>]])"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_Gromov_product_at a (u n) y)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "have \"(\\<lambda>n. extended_Gromov_distance x (u n)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> \\<infinity>", "apply (rule tendsto_sandwich[of \"\\<lambda>n. extended_Gromov_product_at a (u n) y\" _ _ \"\\<lambda>_. \\<infinity>\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at a (u n) y\n       \\<le> extended_Gromov_distance x (u n)\n 2. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance x (u n) \\<le> \\<infinity>\n 3. (\\<lambda>n. extended_Gromov_product_at a (u n) y)\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>_. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "unfolding to_Gromov_completion"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at a (u n) y\n       \\<le> extended_Gromov_distance (to_Gromov_completion a) (u n)\n 2. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance (to_Gromov_completion a) (u n)\n       \\<le> \\<infinity>\n 3. (\\<lambda>n. extended_Gromov_product_at a (u n) y)\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>_. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "using extended_Gromov_product_le_dist[of a \"u _\" y] *"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at a (u ?uu3) y\n  \\<le> extended_Gromov_distance (to_Gromov_completion a) (u ?uu3)\n  (\\<lambda>n. extended_Gromov_product_at a (u n) y)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_product_at a (u n) y\n       \\<le> extended_Gromov_distance (to_Gromov_completion a) (u n)\n 2. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance (to_Gromov_completion a) (u n)\n       \\<le> \\<infinity>\n 3. (\\<lambda>n. extended_Gromov_product_at a (u n) y)\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>_. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_Gromov_distance x (u n))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. extended_Gromov_distance x (u n))\n  \\<longlonglongrightarrow> \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. extended_Gromov_distance x (u n))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "using boundary"], ["proof (prove)\nusing this:\n  (\\<lambda>n. extended_Gromov_distance x (u n))\n  \\<longlonglongrightarrow> \\<infinity>\n  y \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_Gromov_distance x (u n))\n  \\<longlonglongrightarrow> extended_Gromov_distance x y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y", "text \\<open>If $y$ is inside the space, then we use the triangular inequality for the extended Gromov\n    distance to conclure.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y", "case (to_Gromov_completion b)"], ["proof (state)\nthis:\n  y = to_Gromov_completion b\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y", "then"], ["proof (chain)\npicking this:\n  y = to_Gromov_completion b", "have F: \"y \\<notin> Gromov_boundary\""], ["proof (prove)\nusing this:\n  y = to_Gromov_completion b\n\ngoal (1 subgoal):\n 1. y \\<notin> Gromov_boundary", "by auto"], ["proof (state)\nthis:\n  y \\<notin> Gromov_boundary\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y", "have *: \"(\\<lambda>n. extended_Gromov_distance (u n) y) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> 0", "by (rule iffD1[OF Gromov_completion_inside_limit[OF F] \\<open>u \\<longlonglongrightarrow> y\\<close>])"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_Gromov_distance (u n) y) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       y = to_Gromov_completion xa \\<Longrightarrow>\n       (\\<lambda>n. extended_Gromov_distance x (u n))\n       \\<longlonglongrightarrow> extended_Gromov_distance x y", "show \"(\\<lambda>n. extended_Gromov_distance x (u n)) \\<longlonglongrightarrow> extended_Gromov_distance x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. extended_Gromov_distance x (u n))\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "proof (rule tendsto_sandwich[of \"\\<lambda>n. extended_Gromov_distance x y - extended_Gromov_distance (u n) y\" _ _\n                                    \"\\<lambda>n. extended_Gromov_distance x y + extended_Gromov_distance (u n) y\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance x y - extended_Gromov_distance (u n) y\n       \\<le> extended_Gromov_distance x (u n)\n 2. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance x (u n)\n       \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y\n 3. (\\<lambda>n.\n        extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y\n 4. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "have \"extended_Gromov_distance x y - extended_Gromov_distance (u n) y \\<le> extended_Gromov_distance x (u n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y - extended_Gromov_distance (u n) y\n    \\<le> extended_Gromov_distance x (u n)", "using extended_Gromov_distance_triangle[of y x \"u n\"]"], ["proof (prove)\nusing this:\n  extended_Gromov_distance y x\n  \\<le> extended_Gromov_distance y (u n) + extended_Gromov_distance (u n) x\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x y - extended_Gromov_distance (u n) y\n    \\<le> extended_Gromov_distance x (u n)", "by (auto simp add: extended_Gromov_distance_commute F ennreal_minus_le_iff extended_Gromov_distance_def)"], ["proof (state)\nthis:\n  extended_Gromov_distance x y - extended_Gromov_distance (u ?n) y\n  \\<le> extended_Gromov_distance x (u ?n)\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance x y - extended_Gromov_distance (u n) y\n       \\<le> extended_Gromov_distance x (u n)\n 2. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance x (u n)\n       \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y\n 3. (\\<lambda>n.\n        extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y\n 4. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_distance x y - extended_Gromov_distance (u ?n) y\n  \\<le> extended_Gromov_distance x (u ?n)", "show \"\\<forall>\\<^sub>F n in sequentially. extended_Gromov_distance x y - extended_Gromov_distance (u n) y \\<le> extended_Gromov_distance x (u n)\""], ["proof (prove)\nusing this:\n  extended_Gromov_distance x y - extended_Gromov_distance (u ?n) y\n  \\<le> extended_Gromov_distance x (u ?n)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance x y - extended_Gromov_distance (u n) y\n       \\<le> extended_Gromov_distance x (u n)", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     extended_Gromov_distance x y - extended_Gromov_distance (u n) y\n     \\<le> extended_Gromov_distance x (u n)\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance x (u n)\n       \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y\n 2. (\\<lambda>n.\n        extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y\n 3. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "have \"extended_Gromov_distance x (u n) \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance x (u n)\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y", "using extended_Gromov_distance_triangle[of x \"u n\" y]"], ["proof (prove)\nusing this:\n  extended_Gromov_distance x (u n)\n  \\<le> extended_Gromov_distance x y + extended_Gromov_distance y (u n)\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance x (u n)\n    \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y", "by (auto simp add: extended_Gromov_distance_commute)"], ["proof (state)\nthis:\n  extended_Gromov_distance x (u ?n)\n  \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u ?n) y\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance x (u n)\n       \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y\n 2. (\\<lambda>n.\n        extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y\n 3. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "then"], ["proof (chain)\npicking this:\n  extended_Gromov_distance x (u ?n)\n  \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u ?n) y", "show \"\\<forall>\\<^sub>F n in sequentially. extended_Gromov_distance x (u n) \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y\""], ["proof (prove)\nusing this:\n  extended_Gromov_distance x (u ?n)\n  \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u ?n) y\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance x (u n)\n       \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     extended_Gromov_distance x (u n)\n     \\<le> extended_Gromov_distance x y + extended_Gromov_distance (u n) y\n\ngoal (2 subgoals):\n 1. (\\<lambda>n.\n        extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y\n 2. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "have \"(\\<lambda>n. extended_Gromov_distance x y - extended_Gromov_distance (u n) y) \\<longlonglongrightarrow> extended_Gromov_distance x y - 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y - 0", "by (intro tendsto_intros *, auto)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n  \\<longlonglongrightarrow> extended_Gromov_distance x y - 0\n\ngoal (2 subgoals):\n 1. (\\<lambda>n.\n        extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y\n 2. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n.\n      extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n  \\<longlonglongrightarrow> extended_Gromov_distance x y - 0", "show \"(\\<lambda>n. extended_Gromov_distance x y - extended_Gromov_distance (u n) y) \\<longlonglongrightarrow> extended_Gromov_distance x y\""], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n  \\<longlonglongrightarrow> extended_Gromov_distance x y - 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_distance x y - extended_Gromov_distance (u n) y)\n  \\<longlonglongrightarrow> extended_Gromov_distance x y\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "have \"(\\<lambda>n. extended_Gromov_distance x y + extended_Gromov_distance (u n) y) \\<longlonglongrightarrow> extended_Gromov_distance x y + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y + 0", "by (intro tendsto_intros *, auto)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n  \\<longlonglongrightarrow> extended_Gromov_distance x y + 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n.\n      extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n  \\<longlonglongrightarrow> extended_Gromov_distance x y + 0", "show \"(\\<lambda>n. extended_Gromov_distance x y + extended_Gromov_distance (u n) y) \\<longlonglongrightarrow> extended_Gromov_distance x y\""], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n  \\<longlonglongrightarrow> extended_Gromov_distance x y + 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n    \\<longlonglongrightarrow> extended_Gromov_distance x y", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_distance x y + extended_Gromov_distance (u n) y)\n  \\<longlonglongrightarrow> extended_Gromov_distance x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n. extended_Gromov_distance x (u n))\n  \\<longlonglongrightarrow> extended_Gromov_distance x y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<longlonglongrightarrow> ?y \\<Longrightarrow>\n  (\\<lambda>n. extended_Gromov_distance x (?u n))\n  \\<longlonglongrightarrow> extended_Gromov_distance x ?y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       x = to_Gromov_completion xa \\<Longrightarrow>\n       continuous_on UNIV (extended_Gromov_distance x)", "then"], ["proof (chain)\npicking this:\n  ?u \\<longlonglongrightarrow> ?y \\<Longrightarrow>\n  (\\<lambda>n. extended_Gromov_distance x (?u n))\n  \\<longlonglongrightarrow> extended_Gromov_distance x ?y", "show ?thesis"], ["proof (prove)\nusing this:\n  ?u \\<longlonglongrightarrow> ?y \\<Longrightarrow>\n  (\\<lambda>n. extended_Gromov_distance x (?u n))\n  \\<longlonglongrightarrow> extended_Gromov_distance x ?y\n\ngoal (1 subgoal):\n 1. continuous_on UNIV (extended_Gromov_distance x)", "unfolding continuous_on_sequentially comp_def"], ["proof (prove)\nusing this:\n  ?u \\<longlonglongrightarrow> ?y \\<Longrightarrow>\n  (\\<lambda>n. extended_Gromov_distance x (?u n))\n  \\<longlonglongrightarrow> extended_Gromov_distance x ?y\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       \\<forall>a\\<in>UNIV.\n          (\\<forall>n. xa n \\<in> UNIV) \\<and>\n          xa \\<longlonglongrightarrow> a \\<longrightarrow>\n          (\\<lambda>xb. extended_Gromov_distance x (xa xb))\n          \\<longlonglongrightarrow> extended_Gromov_distance x a", "by auto"], ["proof (state)\nthis:\n  continuous_on UNIV (extended_Gromov_distance x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extended_Gromov_distance_continuous':\n  \"continuous_on UNIV (\\<lambda>x. extended_Gromov_distance x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. extended_Gromov_distance x y)", "using extended_Gromov_distance_continuous[of y] extended_Gromov_distance_commute[of _ y]"], ["proof (prove)\nusing this:\n  continuous_on UNIV (extended_Gromov_distance y)\n  extended_Gromov_distance ?x y = extended_Gromov_distance y ?x\n\ngoal (1 subgoal):\n 1. continuous_on UNIV (\\<lambda>x. extended_Gromov_distance x y)", "by auto"], ["", "subsection \\<open>Topology of the Gromov boundary\\<close>"], ["", "text \\<open>We deduce the basic fact that the original space is open in the Gromov completion from the\ncontinuity of the extended distance.\\<close>"], ["", "lemma to_Gromov_completion_range_open:\n  \"open (range to_Gromov_completion)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. open (range to_Gromov_completion)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. open (range to_Gromov_completion)", "have *: \"range to_Gromov_completion = (\\<lambda>x. extended_Gromov_distance (to_Gromov_completion basepoint) x)-`{..<\\<infinity>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range to_Gromov_completion =\n    extended_Gromov_distance (to_Gromov_completion basepoint) -`\n    {..<\\<infinity>}", "using Gromov_boundary_def extended_Gromov_distance_PInf_boundary(2)"], ["proof (prove)\nusing this:\n  Gromov_boundary = UNIV - range to_Gromov_completion\n  ?x \\<in> Gromov_boundary \\<Longrightarrow>\n  extended_Gromov_distance ?y ?x = \\<infinity>\n\ngoal (1 subgoal):\n 1. range to_Gromov_completion =\n    extended_Gromov_distance (to_Gromov_completion basepoint) -`\n    {..<\\<infinity>}", "by fastforce"], ["proof (state)\nthis:\n  range to_Gromov_completion =\n  extended_Gromov_distance (to_Gromov_completion basepoint) -`\n  {..<\\<infinity>}\n\ngoal (1 subgoal):\n 1. open (range to_Gromov_completion)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. open (range to_Gromov_completion)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. open\n     (extended_Gromov_distance (to_Gromov_completion basepoint) -`\n      {..<\\<infinity>})", "using extended_Gromov_distance_continuous open_lessThan open_vimage"], ["proof (prove)\nusing this:\n  continuous_on UNIV (extended_Gromov_distance ?x)\n  open {..<?a}\n  \\<lbrakk>open ?s; continuous_on UNIV ?f\\<rbrakk>\n  \\<Longrightarrow> open (?f -` ?s)\n\ngoal (1 subgoal):\n 1. open\n     (extended_Gromov_distance (to_Gromov_completion basepoint) -`\n      {..<\\<infinity>})", "by blast"], ["proof (state)\nthis:\n  open (range to_Gromov_completion)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gromov_boundary_closed:\n  \"closed Gromov_boundary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed Gromov_boundary", "unfolding Gromov_boundary_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (UNIV - range to_Gromov_completion)", "using to_Gromov_completion_range_open"], ["proof (prove)\nusing this:\n  open (range to_Gromov_completion)\n\ngoal (1 subgoal):\n 1. closed (UNIV - range to_Gromov_completion)", "by auto"], ["", "text \\<open>The original space is also dense in its Gromov completion, as all points at infinity are\nby definition limits of some sequence in the space.\\<close>"], ["", "lemma to_Gromov_completion_range_dense [simp]:\n  \"closure (range to_Gromov_completion) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closure (range to_Gromov_completion) = UNIV", "apply (auto simp add: closure_sequential)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          (\\<forall>n. xa n \\<in> range to_Gromov_completion) \\<and>\n          xa \\<longlonglongrightarrow> x", "using rep_Gromov_completion_limit"], ["proof (prove)\nusing this:\n  (\\<lambda>n. to_Gromov_completion (rep_Gromov_completion ?x n))\n  \\<longlonglongrightarrow> ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<exists>xa.\n          (\\<forall>n. xa n \\<in> range to_Gromov_completion) \\<and>\n          xa \\<longlonglongrightarrow> x", "by force"], ["", "lemma to_Gromov_completion_homeomorphism:\n  \"homeomorphism_on UNIV to_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism_on UNIV to_Gromov_completion", "by (rule homeomorphism_on_sequentially, auto)"], ["", "lemma to_Gromov_completion_continuous:\n  \"continuous_on UNIV to_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV to_Gromov_completion", "by (rule homeomorphism_on_continuous[OF to_Gromov_completion_homeomorphism])"], ["", "lemma from_Gromov_completion_continuous:\n  \"homeomorphism_on (range to_Gromov_completion) from_Gromov_completion\"\n  \"continuous_on (range to_Gromov_completion) from_Gromov_completion\"\n  \"\\<And>x::('a::Gromov_hyperbolic_space) Gromov_completion. x \\<in> range to_Gromov_completion \\<Longrightarrow> continuous (at x) from_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism_on (range to_Gromov_completion) from_Gromov_completion &&&\n    continuous_on (range to_Gromov_completion) from_Gromov_completion &&&\n    (\\<And>x.\n        x \\<in> range to_Gromov_completion \\<Longrightarrow>\n        isCont from_Gromov_completion x)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. homeomorphism_on (range to_Gromov_completion) from_Gromov_completion\n 2. continuous_on (range to_Gromov_completion) from_Gromov_completion\n 3. \\<And>x.\n       x \\<in> range to_Gromov_completion \\<Longrightarrow>\n       isCont from_Gromov_completion x", "show *: \"homeomorphism_on (range to_Gromov_completion) from_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism_on (range to_Gromov_completion) from_Gromov_completion", "using homeomorphism_on_inverse[OF to_Gromov_completion_homeomorphism]"], ["proof (prove)\nusing this:\n  homeomorphism_on (range to_Gromov_completion) (inv to_Gromov_completion)\n\ngoal (1 subgoal):\n 1. homeomorphism_on (range to_Gromov_completion) from_Gromov_completion", "unfolding from_Gromov_completion_def[symmetric]"], ["proof (prove)\nusing this:\n  homeomorphism_on (range to_Gromov_completion) from_Gromov_completion\n\ngoal (1 subgoal):\n 1. homeomorphism_on (range to_Gromov_completion) from_Gromov_completion", "by simp"], ["proof (state)\nthis:\n  homeomorphism_on (range to_Gromov_completion) from_Gromov_completion\n\ngoal (2 subgoals):\n 1. continuous_on (range to_Gromov_completion) from_Gromov_completion\n 2. \\<And>x.\n       x \\<in> range to_Gromov_completion \\<Longrightarrow>\n       isCont from_Gromov_completion x", "show \"continuous_on (range to_Gromov_completion) from_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on (range to_Gromov_completion) from_Gromov_completion", "by (simp add: * homeomorphism_on_continuous)"], ["proof (state)\nthis:\n  continuous_on (range to_Gromov_completion) from_Gromov_completion\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> range to_Gromov_completion \\<Longrightarrow>\n       isCont from_Gromov_completion x", "then"], ["proof (chain)\npicking this:\n  continuous_on (range to_Gromov_completion) from_Gromov_completion", "show \"continuous (at x) from_Gromov_completion\" if \"x \\<in> range to_Gromov_completion\" for x::\"'a Gromov_completion\""], ["proof (prove)\nusing this:\n  continuous_on (range to_Gromov_completion) from_Gromov_completion\n\ngoal (1 subgoal):\n 1. isCont from_Gromov_completion x", "using continuous_on_eq_continuous_at that to_Gromov_completion_range_open"], ["proof (prove)\nusing this:\n  continuous_on (range to_Gromov_completion) from_Gromov_completion\n  open ?s \\<Longrightarrow>\n  continuous_on ?s ?f = (\\<forall>x\\<in>?s. isCont ?f x)\n  x \\<in> range to_Gromov_completion\n  open (range to_Gromov_completion)\n\ngoal (1 subgoal):\n 1. isCont from_Gromov_completion x", "by auto"], ["proof (state)\nthis:\n  ?x2 \\<in> range to_Gromov_completion \\<Longrightarrow>\n  isCont from_Gromov_completion ?x2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The Gromov boundary is always complete. Indeed, consider a Cauchy sequence $u_n$ in the\nboundary, and approximate well enough $u_n$ by a point $v_n$ inside. Then the sequence $v_n$\nis Gromov converging at infinity (the respective Gromov products tend to infinity essentially\nby definition), and its limit point is the limit of the original sequence $u$.\\<close>"], ["", "proposition Gromov_boundary_complete:\n  \"complete Gromov_boundary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete Gromov_boundary", "proof (rule completeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "fix u::\"nat \\<Rightarrow> 'a Gromov_completion\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "assume \"\\<forall>n. u n \\<in> Gromov_boundary\" \"Cauchy u\""], ["proof (state)\nthis:\n  \\<forall>n. u n \\<in> Gromov_boundary\n  Cauchy u\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  \\<forall>n. u n \\<in> Gromov_boundary\n  Cauchy u", "have u: \"\\<And>n. u n \\<in> Gromov_boundary\""], ["proof (prove)\nusing this:\n  \\<forall>n. u n \\<in> Gromov_boundary\n  Cauchy u\n\ngoal (1 subgoal):\n 1. \\<And>n. u n \\<in> Gromov_boundary", "by auto"], ["proof (state)\nthis:\n  u ?n \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "have *: \"\\<exists>x \\<in> range to_Gromov_completion. dist (u n) x < 1/real(n+1)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>range to_Gromov_completion.\n       dist (u n) x < 1 / real (n + 1)", "by (rule closure_approachableD, auto simp add: to_Gromov_completion_range_dense)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>range to_Gromov_completion.\n     dist (u ?n) x < 1 / real (?n + 1)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "have \"\\<exists>v. \\<forall>n. dist (to_Gromov_completion (v n)) (u n) < 1/real(n+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n.\n          dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)", "using of_nat_less_top"], ["proof (prove)\nusing this:\n  of_nat ?i < top\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n.\n          dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)", "apply (intro choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. of_nat i < top) \\<Longrightarrow>\n    \\<forall>n.\n       \\<exists>y. dist (to_Gromov_completion y) (u n) < 1 / real (n + 1)", "using *"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>range to_Gromov_completion.\n     dist (u ?n) x < 1 / real (?n + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>i. of_nat i < top) \\<Longrightarrow>\n    \\<forall>n.\n       \\<exists>y. dist (to_Gromov_completion y) (u n) < 1 / real (n + 1)", "by (auto simp add: dist_commute)"], ["proof (state)\nthis:\n  \\<exists>v.\n     \\<forall>n. dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     \\<forall>n. dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)", "obtain v where v: \"\\<And>n. dist (to_Gromov_completion (v n)) (u n) < 1/real(n+1)\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     \\<forall>n. dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>n.\n            dist (to_Gromov_completion (v n)) (u n)\n            < 1 / real (n + 1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v ?n)) (u ?n) < 1 / real (?n + 1)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "have \"(\\<lambda>n. dist (to_Gromov_completion (v n)) (u n)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist (to_Gromov_completion (v n)) (u n))\n    \\<longlonglongrightarrow> 0", "apply (rule tendsto_sandwich[of \"\\<lambda>_. 0\" _ _ \"\\<lambda>n. 1/real(n+1)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> dist (to_Gromov_completion (v n)) (u n)\n 2. \\<forall>\\<^sub>F n in sequentially.\n       dist (to_Gromov_completion (v n)) (u n) \\<le> 1 / real (n + 1)\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0", "using v LIMSEQ_ignore_initial_segment[OF lim_1_over_n, of 1]"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion (v ?n)) (u ?n) < 1 / real (?n + 1)\n  (\\<lambda>n. (1::?'a1) / of_nat (n + 1))\n  \\<longlonglongrightarrow> (0::?'a1)\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> dist (to_Gromov_completion (v n)) (u n)\n 2. \\<forall>\\<^sub>F n in sequentially.\n       dist (to_Gromov_completion (v n)) (u n) \\<le> 1 / real (n + 1)\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion (v ?n)) (u ?n) < 1 / real (?n + 1)\n  (\\<lambda>n. (1::?'a1) / of_nat (n + 1))\n  \\<longlonglongrightarrow> (0::?'a1)\n\ngoal (4 subgoals):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N. 0 \\<le> dist (to_Gromov_completion (v n)) (u n)\n 2. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          dist (to_Gromov_completion (v n)) (u n) \\<le> 1 / real (n + 1)\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0", "by (auto simp add: less_imp_le)"], ["proof (state)\nthis:\n  (\\<lambda>n. dist (to_Gromov_completion (v n)) (u n))\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "have \"Gromov_converging_at_boundary v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary v", "proof (rule Gromov_converging_at_boundaryI[of basepoint])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "fix M::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "obtain D1 e1 where D1: \"e1 > 0\" \"D1 < \\<infinity>\" \"\\<And>x y::'a Gromov_completion. dist x y \\<le> e1 \\<Longrightarrow> extended_Gromov_distance x (to_Gromov_completion basepoint) \\<ge> D1 \\<Longrightarrow> extended_Gromov_product_at basepoint x y \\<ge> ereal M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e1 D1.\n        \\<lbrakk>0 < e1; D1 < \\<infinity>;\n         \\<And>x y.\n            \\<lbrakk>dist x y \\<le> e1;\n             D1 \\<le> extended_Gromov_distance x\n                       (to_Gromov_completion basepoint)\\<rbrakk>\n            \\<Longrightarrow> ereal M\n                              \\<le> extended_Gromov_product_at basepoint x\n                                     y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using large_Gromov_product_approx[of \"ereal M\"]"], ["proof (prove)\nusing this:\n  ereal M < \\<infinity> \\<Longrightarrow>\n  \\<exists>e D.\n     0 < e \\<and>\n     D < \\<infinity> \\<and>\n     (\\<forall>x y.\n         dist x y \\<le> e \\<longrightarrow>\n         D \\<le> extended_Gromov_distance x\n                  (to_Gromov_completion basepoint) \\<longrightarrow>\n         ereal M \\<le> extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. (\\<And>e1 D1.\n        \\<lbrakk>0 < e1; D1 < \\<infinity>;\n         \\<And>x y.\n            \\<lbrakk>dist x y \\<le> e1;\n             D1 \\<le> extended_Gromov_distance x\n                       (to_Gromov_completion basepoint)\\<rbrakk>\n            \\<Longrightarrow> ereal M\n                              \\<le> extended_Gromov_product_at basepoint x\n                                     y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < e1\n  D1 < \\<infinity>\n  \\<lbrakk>dist ?x ?y \\<le> e1;\n   D1 \\<le> extended_Gromov_distance ?x\n             (to_Gromov_completion basepoint)\\<rbrakk>\n  \\<Longrightarrow> ereal M \\<le> extended_Gromov_product_at basepoint ?x ?y\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "obtain D2 e2 where D2: \"e2 > 0\" \"D2 < \\<infinity>\" \"\\<And>x y::'a Gromov_completion. dist x y \\<le> e2 \\<Longrightarrow> extended_Gromov_distance x (to_Gromov_completion basepoint) \\<ge> D2 \\<Longrightarrow> extended_Gromov_product_at basepoint x y \\<ge> D1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e2 D2.\n        \\<lbrakk>0 < e2; D2 < \\<infinity>;\n         \\<And>x y.\n            \\<lbrakk>dist x y \\<le> e2;\n             D2 \\<le> extended_Gromov_distance x\n                       (to_Gromov_completion basepoint)\\<rbrakk>\n            \\<Longrightarrow> D1 \\<le> extended_Gromov_product_at basepoint\n  x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using large_Gromov_product_approx[OF \\<open>D1 < \\<infinity>\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>e D.\n     0 < e \\<and>\n     D < \\<infinity> \\<and>\n     (\\<forall>x y.\n         dist x y \\<le> e \\<longrightarrow>\n         D \\<le> extended_Gromov_distance x\n                  (to_Gromov_completion basepoint) \\<longrightarrow>\n         D1 \\<le> extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. (\\<And>e2 D2.\n        \\<lbrakk>0 < e2; D2 < \\<infinity>;\n         \\<And>x y.\n            \\<lbrakk>dist x y \\<le> e2;\n             D2 \\<le> extended_Gromov_distance x\n                       (to_Gromov_completion basepoint)\\<rbrakk>\n            \\<Longrightarrow> D1 \\<le> extended_Gromov_product_at basepoint\n  x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < e2\n  D2 < \\<infinity>\n  \\<lbrakk>dist ?x ?y \\<le> e2;\n   D2 \\<le> extended_Gromov_distance ?x\n             (to_Gromov_completion basepoint)\\<rbrakk>\n  \\<Longrightarrow> D1 \\<le> extended_Gromov_product_at basepoint ?x ?y\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "define e where \"e = (min e1 e2)/3\""], ["proof (state)\nthis:\n  e = min e1 e2 / 3\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "have \"e > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < min e1 e2 / 3", "using \\<open>e1 > 0\\<close> \\<open>e2 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e1\n  0 < e2\n\ngoal (1 subgoal):\n 1. 0 < min e1 e2 / 3", "by auto"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "then"], ["proof (chain)\npicking this:\n  0 < e", "obtain N1 where N1: \"\\<And>n m. n \\<ge> N1 \\<Longrightarrow> m \\<ge> N1 \\<Longrightarrow> dist (u n) (u m) < e\""], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>N1.\n        (\\<And>n m.\n            \\<lbrakk>N1 \\<le> n; N1 \\<le> m\\<rbrakk>\n            \\<Longrightarrow> dist (u n) (u m) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Cauchy u\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  Cauchy u\n\ngoal (1 subgoal):\n 1. (\\<And>N1.\n        (\\<And>n m.\n            \\<lbrakk>N1 \\<le> n; N1 \\<le> m\\<rbrakk>\n            \\<Longrightarrow> dist (u n) (u m) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Cauchy_def"], ["proof (prove)\nusing this:\n  0 < e\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (u m) (u n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>N1.\n        (\\<And>n m.\n            \\<lbrakk>N1 \\<le> n; N1 \\<le> m\\<rbrakk>\n            \\<Longrightarrow> dist (u n) (u m) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>N1 \\<le> ?n; N1 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> dist (u ?n) (u ?m) < e\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "have \"eventually (\\<lambda>n. dist (to_Gromov_completion (v n)) (u n) < e) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       dist (to_Gromov_completion (v n)) (u n) < e", "by (rule order_tendstoD[OF \\<open>(\\<lambda>n. dist (to_Gromov_completion (v n)) (u n)) \\<longlonglongrightarrow> 0\\<close>], fact)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     dist (to_Gromov_completion (v n)) (u n) < e\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     dist (to_Gromov_completion (v n)) (u n) < e", "obtain N2 where N2: \"\\<And>n. n \\<ge> N2 \\<Longrightarrow> dist (to_Gromov_completion (v n)) (u n) < e\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     dist (to_Gromov_completion (v n)) (u n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>N2.\n        (\\<And>n.\n            N2 \\<le> n \\<Longrightarrow>\n            dist (to_Gromov_completion (v n)) (u n) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. dist (to_Gromov_completion (v n)) (u n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>N2.\n        (\\<And>n.\n            N2 \\<le> n \\<Longrightarrow>\n            dist (to_Gromov_completion (v n)) (u n) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N2 \\<le> ?n \\<Longrightarrow>\n  dist (to_Gromov_completion (v ?n)) (u ?n) < e\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "have \"ereal M \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\"\n      if \"n \\<ge> max N1 N2\" \"m \\<ge> max N1 N2\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v m))\n           (to_Gromov_completion (v n))", "proof (rule D1(3))"], ["proof (state)\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\n        \\<le> dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) + dist (u n) (to_Gromov_completion (v n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\n    \\<le> dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n          dist (u n) (to_Gromov_completion (v n))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\n  \\<le> dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n        dist (u n) (to_Gromov_completion (v n))\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "also"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\n  \\<le> dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n        dist (u n) (to_Gromov_completion (v n))\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"... \\<le> e + e + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n    dist (u n) (to_Gromov_completion (v n))\n    \\<le> e + e + e", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. dist (to_Gromov_completion (v m)) (u m) \\<le> e\n 2. dist (u m) (u n) \\<le> e\n 3. dist (u n) (to_Gromov_completion (v n)) \\<le> e", "using N1[of m n] N2[of n] N2[of m] that"], ["proof (prove)\nusing this:\n  \\<lbrakk>N1 \\<le> m; N1 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> dist (u m) (u n) < e\n  N2 \\<le> n \\<Longrightarrow> dist (to_Gromov_completion (v n)) (u n) < e\n  N2 \\<le> m \\<Longrightarrow> dist (to_Gromov_completion (v m)) (u m) < e\n  max N1 N2 \\<le> n\n  max N1 N2 \\<le> m\n\ngoal (3 subgoals):\n 1. dist (to_Gromov_completion (v m)) (u m) \\<le> e\n 2. dist (u m) (u n) \\<le> e\n 3. dist (u n) (to_Gromov_completion (v n)) \\<le> e", "by (auto simp add: dist_commute)"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n  dist (u n) (to_Gromov_completion (v n))\n  \\<le> e + e + e\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "also"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n  dist (u n) (to_Gromov_completion (v n))\n  \\<le> e + e + e\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"... \\<le> e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e + e + e \\<le> e1", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min e1 e2 / 3 + min e1 e2 / 3 + min e1 e2 / 3 \\<le> e1", "by auto"], ["proof (state)\nthis:\n  e + e + e \\<le> e1\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "finally"], ["proof (chain)\npicking this:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1", "show \"dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\""], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1", "by simp"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"e \\<le> e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<le> e2", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min e1 e2 / 3 \\<le> e2", "using \\<open>e2 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e2\n\ngoal (1 subgoal):\n 1. min e1 e2 / 3 \\<le> e2", "by auto"], ["proof (state)\nthis:\n  e \\<le> e2\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"D1 \\<le> extended_Gromov_product_at basepoint (u m) (to_Gromov_completion (v m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_product_at basepoint (u m)\n              (to_Gromov_completion (v m))", "apply (rule D2(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist (u m) (to_Gromov_completion (v m)) \\<le> e2\n 2. D2 \\<le> extended_Gromov_distance (u m) (to_Gromov_completion basepoint)", "using N2[of m] that \\<open>e \\<le> e2\\<close> u[of m]"], ["proof (prove)\nusing this:\n  N2 \\<le> m \\<Longrightarrow> dist (to_Gromov_completion (v m)) (u m) < e\n  max N1 N2 \\<le> n\n  max N1 N2 \\<le> m\n  e \\<le> e2\n  u m \\<in> Gromov_boundary\n\ngoal (2 subgoals):\n 1. dist (u m) (to_Gromov_completion (v m)) \\<le> e2\n 2. D2 \\<le> extended_Gromov_distance (u m) (to_Gromov_completion basepoint)", "by (auto simp add: dist_commute)"], ["proof (state)\nthis:\n  D1 \\<le> extended_Gromov_product_at basepoint (u m)\n            (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "also"], ["proof (state)\nthis:\n  D1 \\<le> extended_Gromov_product_at basepoint (u m)\n            (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"... \\<le> extended_Gromov_distance (to_Gromov_completion basepoint) (to_Gromov_completion (v m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint (u m) (to_Gromov_completion (v m))\n    \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n           (to_Gromov_completion (v m))", "using extended_Gromov_product_le_dist[of basepoint \"to_Gromov_completion (v m)\" \"u m\"]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at basepoint (to_Gromov_completion (v m)) (u m)\n  \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n         (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint (u m) (to_Gromov_completion (v m))\n    \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n           (to_Gromov_completion (v m))", "by (simp add: extended_Gromov_product_at_commute)"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint (u m) (to_Gromov_completion (v m))\n  \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n         (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "finally"], ["proof (chain)\npicking this:\n  D1 \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n            (to_Gromov_completion (v m))", "show \"D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m)) (to_Gromov_completion basepoint)\""], ["proof (prove)\nusing this:\n  D1 \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n            (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "by (simp add: extended_Gromov_distance_commute)"], ["proof (state)\nthis:\n  D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n            (to_Gromov_completion basepoint)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>max N1 N2 \\<le> ?n; max N1 N2 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> ereal M\n                    \\<le> extended_Gromov_product_at basepoint\n                           (to_Gromov_completion (v ?m))\n                           (to_Gromov_completion (v ?n))\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>max N1 N2 \\<le> ?n; max N1 N2 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> ereal M\n                    \\<le> extended_Gromov_product_at basepoint\n                           (to_Gromov_completion (v ?m))\n                           (to_Gromov_completion (v ?n))", "have \"M \\<le> Gromov_product_at basepoint (v m) (v n)\" if \"n \\<ge> max N1 N2\" \"m \\<ge> max N1 N2\" for m n"], ["proof (prove)\nusing this:\n  \\<lbrakk>max N1 N2 \\<le> ?n; max N1 N2 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> ereal M\n                    \\<le> extended_Gromov_product_at basepoint\n                           (to_Gromov_completion (v ?m))\n                           (to_Gromov_completion (v ?n))\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v m) (v n)", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>max N1 N2 \\<le> ?n; max N1 N2 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> ereal M\n                    \\<le> extended_Gromov_product_at basepoint\n                           (to_Gromov_completion (v ?m))\n                           (to_Gromov_completion (v ?n))\n  max N1 N2 \\<le> n\n  max N1 N2 \\<le> m\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v m) (v n)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>max N1 N2 \\<le> ?n; max N1 N2 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at basepoint (v ?m) (v ?n)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>max N1 N2 \\<le> ?n; max N1 N2 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at basepoint (v ?m) (v ?n)", "show \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. M \\<le> Gromov_product_at basepoint (v m) (v n)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>max N1 N2 \\<le> ?n; max N1 N2 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at basepoint (v ?m) (v ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (v m) (v n)", "by blast"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (v m) (v n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  Gromov_converging_at_boundary v", "obtain l where l: \"l \\<in> Gromov_boundary\" \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> Gromov_boundary;\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Gromov_converging_at_boundary_converges"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary v\n  Gromov_converging_at_boundary ?u \\<Longrightarrow>\n  \\<exists>x\\<in>Gromov_boundary.\n     (\\<lambda>n. to_Gromov_completion (?u n)) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> Gromov_boundary;\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l \\<in> Gromov_boundary\n  (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "have \"(\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0+0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0", "proof (rule tendsto_sandwich[of \"\\<lambda>_. 0\" _ _ \"\\<lambda>n. dist (u n) (to_Gromov_completion (v n)) + dist (to_Gromov_completion (v n)) l\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> dist (u n) l\n 2. \\<forall>\\<^sub>F n in sequentially.\n       dist (u n) l\n       \\<le> dist (u n) (to_Gromov_completion (v n)) +\n             dist (to_Gromov_completion (v n)) l\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0 + 0\n 4. (\\<lambda>n.\n        dist (u n) (to_Gromov_completion (v n)) +\n        dist (to_Gromov_completion (v n)) l)\n    \\<longlonglongrightarrow> 0 + 0", "show \"(\\<lambda>n. dist (u n) (to_Gromov_completion (v n)) + dist (to_Gromov_completion (v n)) l) \\<longlonglongrightarrow> 0 + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        dist (u n) (to_Gromov_completion (v n)) +\n        dist (to_Gromov_completion (v n)) l)\n    \\<longlonglongrightarrow> 0 + 0", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. dist (u x) (to_Gromov_completion (v x)))\n    \\<longlonglongrightarrow> 0\n 2. (\\<lambda>x. dist (to_Gromov_completion (v x)) l)\n    \\<longlonglongrightarrow> 0", "using iffD1[OF tendsto_dist_iff l(2)] \\<open>(\\<lambda>n. dist (to_Gromov_completion (v n)) (u n)) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>x. dist (to_Gromov_completion (v x)) l)\n  \\<longlonglongrightarrow> 0\n  (\\<lambda>n. dist (to_Gromov_completion (v n)) (u n))\n  \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. dist (u x) (to_Gromov_completion (v x)))\n    \\<longlonglongrightarrow> 0\n 2. (\\<lambda>x. dist (to_Gromov_completion (v x)) l)\n    \\<longlonglongrightarrow> 0", "by (auto simp add: dist_commute)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      dist (u n) (to_Gromov_completion (v n)) +\n      dist (to_Gromov_completion (v n)) l)\n  \\<longlonglongrightarrow> 0 + 0\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> dist (u n) l\n 2. \\<forall>\\<^sub>F n in sequentially.\n       dist (u n) l\n       \\<le> dist (u n) (to_Gromov_completion (v n)) +\n             dist (to_Gromov_completion (v n)) l\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0 + 0", "qed (auto simp add: dist_triangle)"], ["proof (state)\nthis:\n  (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0", "have \"u \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0\n\ngoal (1 subgoal):\n 1. u \\<longlonglongrightarrow> l", "using iffD2[OF tendsto_dist_iff]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0\n  ((\\<lambda>x. dist (?f1 x) ?l1) \\<longlongrightarrow> 0)\n   ?F1 \\<Longrightarrow>\n  (?f1 \\<longlongrightarrow> ?l1) ?F1\n\ngoal (1 subgoal):\n 1. u \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  u \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>n. f n \\<in> Gromov_boundary; Cauchy f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l\\<in>Gromov_boundary.\n                            f \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  u \\<longlonglongrightarrow> l", "show \"\\<exists>l\\<in>Gromov_boundary. u \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>Gromov_boundary. u \\<longlonglongrightarrow> l", "using l(1)"], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> l\n  l \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. \\<exists>l\\<in>Gromov_boundary. u \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  \\<exists>l\\<in>Gromov_boundary. u \\<longlonglongrightarrow> l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>When the initial space is complete, then the whole Gromov completion is also complete:\nfor Cauchy sequences tending to the Gromov boundary, then the convergence is proved as in the\ncompleteness of the boundary above. For Cauchy sequences that remain bounded, the convergence\nis reduced to the convergence inside the original space, which holds by assumption.\\<close>"], ["", "proposition Gromov_completion_complete:\n  assumes \"complete (UNIV::'a::Gromov_hyperbolic_space set)\"\n  shows \"complete (UNIV::'a Gromov_completion set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complete UNIV", "proof (rule completeI, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       Cauchy f \\<Longrightarrow> \\<exists>l. f \\<longlonglongrightarrow> l", "fix u0::\"nat \\<Rightarrow> 'a Gromov_completion\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       Cauchy f \\<Longrightarrow> \\<exists>l. f \\<longlonglongrightarrow> l", "assume \"Cauchy u0\""], ["proof (state)\nthis:\n  Cauchy u0\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       Cauchy f \\<Longrightarrow> \\<exists>l. f \\<longlonglongrightarrow> l", "show \"\\<exists>l. u0 \\<longlonglongrightarrow> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. u0 \\<longlonglongrightarrow> l", "proof (cases \"limsup (\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) = \\<infinity>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "case True"], ["proof (state)\nthis:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n  \\<infinity>\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n  \\<infinity>", "obtain r where r: \"strict_mono r\" \"(\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u0 (r n))) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         (\\<lambda>n.\n             extended_Gromov_distance (to_Gromov_completion basepoint)\n              (u0 (r n)))\n         \\<longlonglongrightarrow> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using limsup_subseq_lim[of \"(\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n))\"]"], ["proof (prove)\nusing this:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n  \\<infinity>\n  \\<exists>r.\n     strict_mono r \\<and>\n     ((\\<lambda>n.\n          extended_Gromov_distance (to_Gromov_completion basepoint)\n           (u0 n)) \\<circ>\n      r)\n     \\<longlonglongrightarrow> limsup\n                                (\\<lambda>n.\n                                    extended_Gromov_distance\n                                     (to_Gromov_completion basepoint)\n                                     (u0 n))\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         (\\<lambda>n.\n             extended_Gromov_distance (to_Gromov_completion basepoint)\n              (u0 (r n)))\n         \\<longlonglongrightarrow> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding comp_def"], ["proof (prove)\nusing this:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n  \\<infinity>\n  \\<exists>r.\n     strict_mono r \\<and>\n     (\\<lambda>x.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 (r x)))\n     \\<longlonglongrightarrow> limsup\n                                (\\<lambda>n.\n                                    extended_Gromov_distance\n                                     (to_Gromov_completion basepoint)\n                                     (u0 n))\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         (\\<lambda>n.\n             extended_Gromov_distance (to_Gromov_completion basepoint)\n              (u0 (r n)))\n         \\<longlonglongrightarrow> \\<infinity>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  strict_mono r\n  (\\<lambda>n.\n      extended_Gromov_distance (to_Gromov_completion basepoint) (u0 (r n)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "define u where \"u = u0 o r\""], ["proof (state)\nthis:\n  u = u0 \\<circ> r\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  u = u0 \\<circ> r", "have \"(\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u n)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  u = u0 \\<circ> r\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_distance (to_Gromov_completion basepoint) (u n))\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding comp_def"], ["proof (prove)\nusing this:\n  u = (\\<lambda>x. u0 (r x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_distance (to_Gromov_completion basepoint) (u n))\n    \\<longlonglongrightarrow> \\<infinity>", "using r(2)"], ["proof (prove)\nusing this:\n  u = (\\<lambda>x. u0 (r x))\n  (\\<lambda>n.\n      extended_Gromov_distance (to_Gromov_completion basepoint) (u0 (r n)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        extended_Gromov_distance (to_Gromov_completion basepoint) (u n))\n    \\<longlonglongrightarrow> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      extended_Gromov_distance (to_Gromov_completion basepoint) (u n))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have \"Cauchy u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy u", "using \\<open>Cauchy u0\\<close> r(1) u_def"], ["proof (prove)\nusing this:\n  Cauchy u0\n  strict_mono r\n  u = u0 \\<circ> r\n\ngoal (1 subgoal):\n 1. Cauchy u", "by (simp add: Cauchy_subseq_Cauchy)"], ["proof (state)\nthis:\n  Cauchy u\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have *: \"\\<exists>x \\<in> range to_Gromov_completion. dist (u n) x < 1/real(n+1)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>range to_Gromov_completion.\n       dist (u n) x < 1 / real (n + 1)", "by (rule closure_approachableD, auto)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>range to_Gromov_completion.\n     dist (u ?n) x < 1 / real (?n + 1)\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have \"\\<exists>v. \\<forall>n. dist (to_Gromov_completion (v n)) (u n) < 1/real(n+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n.\n          dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)", "using of_nat_less_top"], ["proof (prove)\nusing this:\n  of_nat ?i < top\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n.\n          dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)", "apply (intro choice)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. of_nat i < top) \\<Longrightarrow>\n    \\<forall>n.\n       \\<exists>y. dist (to_Gromov_completion y) (u n) < 1 / real (n + 1)", "using *"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>range to_Gromov_completion.\n     dist (u ?n) x < 1 / real (?n + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>i. of_nat i < top) \\<Longrightarrow>\n    \\<forall>n.\n       \\<exists>y. dist (to_Gromov_completion y) (u n) < 1 / real (n + 1)", "by (auto simp add: dist_commute)"], ["proof (state)\nthis:\n  \\<exists>v.\n     \\<forall>n. dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     \\<forall>n. dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)", "obtain v where v: \"\\<And>n. dist (to_Gromov_completion (v n)) (u n) < 1/real(n+1)\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     \\<forall>n. dist (to_Gromov_completion (v n)) (u n) < 1 / real (n + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (\\<And>n.\n            dist (to_Gromov_completion (v n)) (u n)\n            < 1 / real (n + 1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v ?n)) (u ?n) < 1 / real (?n + 1)\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have \"(\\<lambda>n. dist (to_Gromov_completion (v n)) (u n)) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist (to_Gromov_completion (v n)) (u n))\n    \\<longlonglongrightarrow> 0", "apply (rule tendsto_sandwich[of \"\\<lambda>_. 0\" _ _ \"\\<lambda>n. 1/real(n+1)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> dist (to_Gromov_completion (v n)) (u n)\n 2. \\<forall>\\<^sub>F n in sequentially.\n       dist (to_Gromov_completion (v n)) (u n) \\<le> 1 / real (n + 1)\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0", "using v LIMSEQ_ignore_initial_segment[OF lim_1_over_n, of 1]"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion (v ?n)) (u ?n) < 1 / real (?n + 1)\n  (\\<lambda>n. (1::?'a1) / of_nat (n + 1))\n  \\<longlonglongrightarrow> (0::?'a1)\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> dist (to_Gromov_completion (v n)) (u n)\n 2. \\<forall>\\<^sub>F n in sequentially.\n       dist (to_Gromov_completion (v n)) (u n) \\<le> 1 / real (n + 1)\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion (v ?n)) (u ?n) < 1 / real (?n + 1)\n  (\\<lambda>n. (1::?'a1) / of_nat (n + 1))\n  \\<longlonglongrightarrow> (0::?'a1)\n\ngoal (4 subgoals):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N. 0 \\<le> dist (to_Gromov_completion (v n)) (u n)\n 2. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          dist (to_Gromov_completion (v n)) (u n) \\<le> 1 / real (n + 1)\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0\n 4. (\\<lambda>n. 1 / real (n + 1)) \\<longlonglongrightarrow> 0", "by (auto simp add: less_imp_le)"], ["proof (state)\nthis:\n  (\\<lambda>n. dist (to_Gromov_completion (v n)) (u n))\n  \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have \"Gromov_converging_at_boundary v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary v", "proof (rule Gromov_converging_at_boundaryI[of basepoint])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "fix M::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "obtain D1 e1 where D1: \"e1 > 0\" \"D1 < \\<infinity>\" \"\\<And>x y::'a Gromov_completion. dist x y \\<le> e1 \\<Longrightarrow> extended_Gromov_distance x (to_Gromov_completion basepoint) \\<ge> D1 \\<Longrightarrow> extended_Gromov_product_at basepoint x y \\<ge> ereal M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e1 D1.\n        \\<lbrakk>0 < e1; D1 < \\<infinity>;\n         \\<And>x y.\n            \\<lbrakk>dist x y \\<le> e1;\n             D1 \\<le> extended_Gromov_distance x\n                       (to_Gromov_completion basepoint)\\<rbrakk>\n            \\<Longrightarrow> ereal M\n                              \\<le> extended_Gromov_product_at basepoint x\n                                     y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using large_Gromov_product_approx[of \"ereal M\"]"], ["proof (prove)\nusing this:\n  ereal M < \\<infinity> \\<Longrightarrow>\n  \\<exists>e D.\n     0 < e \\<and>\n     D < \\<infinity> \\<and>\n     (\\<forall>x y.\n         dist x y \\<le> e \\<longrightarrow>\n         D \\<le> extended_Gromov_distance x\n                  (to_Gromov_completion basepoint) \\<longrightarrow>\n         ereal M \\<le> extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. (\\<And>e1 D1.\n        \\<lbrakk>0 < e1; D1 < \\<infinity>;\n         \\<And>x y.\n            \\<lbrakk>dist x y \\<le> e1;\n             D1 \\<le> extended_Gromov_distance x\n                       (to_Gromov_completion basepoint)\\<rbrakk>\n            \\<Longrightarrow> ereal M\n                              \\<le> extended_Gromov_product_at basepoint x\n                                     y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < e1\n  D1 < \\<infinity>\n  \\<lbrakk>dist ?x ?y \\<le> e1;\n   D1 \\<le> extended_Gromov_distance ?x\n             (to_Gromov_completion basepoint)\\<rbrakk>\n  \\<Longrightarrow> ereal M \\<le> extended_Gromov_product_at basepoint ?x ?y\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "obtain D2 e2 where D2: \"e2 > 0\" \"D2 < \\<infinity>\" \"\\<And>x y::'a Gromov_completion. dist x y \\<le> e2 \\<Longrightarrow> extended_Gromov_distance x (to_Gromov_completion basepoint) \\<ge> D2 \\<Longrightarrow> extended_Gromov_product_at basepoint x y \\<ge> D1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e2 D2.\n        \\<lbrakk>0 < e2; D2 < \\<infinity>;\n         \\<And>x y.\n            \\<lbrakk>dist x y \\<le> e2;\n             D2 \\<le> extended_Gromov_distance x\n                       (to_Gromov_completion basepoint)\\<rbrakk>\n            \\<Longrightarrow> D1 \\<le> extended_Gromov_product_at basepoint\n  x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using large_Gromov_product_approx[OF \\<open>D1 < \\<infinity>\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>e D.\n     0 < e \\<and>\n     D < \\<infinity> \\<and>\n     (\\<forall>x y.\n         dist x y \\<le> e \\<longrightarrow>\n         D \\<le> extended_Gromov_distance x\n                  (to_Gromov_completion basepoint) \\<longrightarrow>\n         D1 \\<le> extended_Gromov_product_at basepoint x y)\n\ngoal (1 subgoal):\n 1. (\\<And>e2 D2.\n        \\<lbrakk>0 < e2; D2 < \\<infinity>;\n         \\<And>x y.\n            \\<lbrakk>dist x y \\<le> e2;\n             D2 \\<le> extended_Gromov_distance x\n                       (to_Gromov_completion basepoint)\\<rbrakk>\n            \\<Longrightarrow> D1 \\<le> extended_Gromov_product_at basepoint\n  x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < e2\n  D2 < \\<infinity>\n  \\<lbrakk>dist ?x ?y \\<le> e2;\n   D2 \\<le> extended_Gromov_distance ?x\n             (to_Gromov_completion basepoint)\\<rbrakk>\n  \\<Longrightarrow> D1 \\<le> extended_Gromov_product_at basepoint ?x ?y\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "define e where \"e = (min e1 e2)/3\""], ["proof (state)\nthis:\n  e = min e1 e2 / 3\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "have \"e > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < min e1 e2 / 3", "using \\<open>e1 > 0\\<close> \\<open>e2 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e1\n  0 < e2\n\ngoal (1 subgoal):\n 1. 0 < min e1 e2 / 3", "by auto"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "then"], ["proof (chain)\npicking this:\n  0 < e", "obtain N1 where N1: \"\\<And>n m. n \\<ge> N1 \\<Longrightarrow> m \\<ge> N1 \\<Longrightarrow> dist (u n) (u m) < e\""], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>N1.\n        (\\<And>n m.\n            \\<lbrakk>N1 \\<le> n; N1 \\<le> m\\<rbrakk>\n            \\<Longrightarrow> dist (u n) (u m) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Cauchy u\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  Cauchy u\n\ngoal (1 subgoal):\n 1. (\\<And>N1.\n        (\\<And>n m.\n            \\<lbrakk>N1 \\<le> n; N1 \\<le> m\\<rbrakk>\n            \\<Longrightarrow> dist (u n) (u m) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Cauchy_def"], ["proof (prove)\nusing this:\n  0 < e\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (u m) (u n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>N1.\n        (\\<And>n m.\n            \\<lbrakk>N1 \\<le> n; N1 \\<le> m\\<rbrakk>\n            \\<Longrightarrow> dist (u n) (u m) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>N1 \\<le> ?n; N1 \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> dist (u ?n) (u ?m) < e\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "have \"eventually (\\<lambda>n. dist (to_Gromov_completion (v n)) (u n) < e) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       dist (to_Gromov_completion (v n)) (u n) < e", "by (rule order_tendstoD[OF \\<open>(\\<lambda>n. dist (to_Gromov_completion (v n)) (u n)) \\<longlonglongrightarrow> 0\\<close>], fact)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     dist (to_Gromov_completion (v n)) (u n) < e\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     dist (to_Gromov_completion (v n)) (u n) < e", "obtain N2 where N2: \"\\<And>n. n \\<ge> N2 \\<Longrightarrow> dist (to_Gromov_completion (v n)) (u n) < e\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     dist (to_Gromov_completion (v n)) (u n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>N2.\n        (\\<And>n.\n            N2 \\<le> n \\<Longrightarrow>\n            dist (to_Gromov_completion (v n)) (u n) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. dist (to_Gromov_completion (v n)) (u n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>N2.\n        (\\<And>n.\n            N2 \\<le> n \\<Longrightarrow>\n            dist (to_Gromov_completion (v n)) (u n) < e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N2 \\<le> ?n \\<Longrightarrow>\n  dist (to_Gromov_completion (v ?n)) (u ?n) < e\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "have \"eventually (\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u n) > D2) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       D2 < extended_Gromov_distance (to_Gromov_completion basepoint) (u n)", "by (rule order_tendstoD[OF \\<open>(\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u n)) \\<longlonglongrightarrow> \\<infinity>\\<close>], fact)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     D2 < extended_Gromov_distance (to_Gromov_completion basepoint) (u n)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     D2 < extended_Gromov_distance (to_Gromov_completion basepoint) (u n)", "obtain N3 where N3: \"\\<And>n. n \\<ge> N3 \\<Longrightarrow> extended_Gromov_distance (to_Gromov_completion basepoint) (u n) > D2\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     D2 < extended_Gromov_distance (to_Gromov_completion basepoint) (u n)\n\ngoal (1 subgoal):\n 1. (\\<And>N3.\n        (\\<And>n.\n            N3 \\<le> n \\<Longrightarrow>\n            D2 < extended_Gromov_distance (to_Gromov_completion basepoint)\n                  (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        D2 < extended_Gromov_distance (to_Gromov_completion basepoint) (u n)\n\ngoal (1 subgoal):\n 1. (\\<And>N3.\n        (\\<And>n.\n            N3 \\<le> n \\<Longrightarrow>\n            D2 < extended_Gromov_distance (to_Gromov_completion basepoint)\n                  (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N3 \\<le> ?n \\<Longrightarrow>\n  D2 < extended_Gromov_distance (to_Gromov_completion basepoint) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "define N where \"N = N1+N2+N3\""], ["proof (state)\nthis:\n  N = N1 + N2 + N3\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "have N: \"N \\<ge> N1\" \"N \\<ge> N2\" \"N \\<ge> N3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<le> N &&& N2 \\<le> N &&& N3 \\<le> N", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<le> N1 + N2 + N3 &&&\n    N2 \\<le> N1 + N2 + N3 &&& N3 \\<le> N1 + N2 + N3", "by auto"], ["proof (state)\nthis:\n  N1 \\<le> N\n  N2 \\<le> N\n  N3 \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "have \"ereal M \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\"\n        if \"n \\<ge> N\" \"m \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal M\n    \\<le> extended_Gromov_product_at basepoint (to_Gromov_completion (v m))\n           (to_Gromov_completion (v n))", "proof (rule D1(3))"], ["proof (state)\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\n          \\<le> dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) + dist (u n) (to_Gromov_completion (v n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\n    \\<le> dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n          dist (u n) (to_Gromov_completion (v n))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\n  \\<le> dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n        dist (u n) (to_Gromov_completion (v n))\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "also"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n))\n  \\<le> dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n        dist (u n) (to_Gromov_completion (v n))\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"... \\<le> e + e + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n    dist (u n) (to_Gromov_completion (v n))\n    \\<le> e + e + e", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. dist (to_Gromov_completion (v m)) (u m) \\<le> e\n 2. dist (u m) (u n) \\<le> e\n 3. dist (u n) (to_Gromov_completion (v n)) \\<le> e", "using N1[of m n] N2[of n] N2[of m] that N"], ["proof (prove)\nusing this:\n  \\<lbrakk>N1 \\<le> m; N1 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> dist (u m) (u n) < e\n  N2 \\<le> n \\<Longrightarrow> dist (to_Gromov_completion (v n)) (u n) < e\n  N2 \\<le> m \\<Longrightarrow> dist (to_Gromov_completion (v m)) (u m) < e\n  N \\<le> n\n  N \\<le> m\n  N1 \\<le> N\n  N2 \\<le> N\n  N3 \\<le> N\n\ngoal (3 subgoals):\n 1. dist (to_Gromov_completion (v m)) (u m) \\<le> e\n 2. dist (u m) (u n) \\<le> e\n 3. dist (u n) (to_Gromov_completion (v n)) \\<le> e", "by (auto simp add: dist_commute)"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n  dist (u n) (to_Gromov_completion (v n))\n  \\<le> e + e + e\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "also"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (u m) + dist (u m) (u n) +\n  dist (u n) (to_Gromov_completion (v n))\n  \\<le> e + e + e\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"... \\<le> e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e + e + e \\<le> e1", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min e1 e2 / 3 + min e1 e2 / 3 + min e1 e2 / 3 \\<le> e1", "by auto"], ["proof (state)\nthis:\n  e + e + e \\<le> e1\n\ngoal (2 subgoals):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n 2. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "finally"], ["proof (chain)\npicking this:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1", "show \"dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\""], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1", "by simp"], ["proof (state)\nthis:\n  dist (to_Gromov_completion (v m)) (to_Gromov_completion (v n)) \\<le> e1\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"e \\<le> e2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<le> e2", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min e1 e2 / 3 \\<le> e2", "using \\<open>e2 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e2\n\ngoal (1 subgoal):\n 1. min e1 e2 / 3 \\<le> e2", "by auto"], ["proof (state)\nthis:\n  e \\<le> e2\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"D1 \\<le> extended_Gromov_product_at basepoint (u m) (to_Gromov_completion (v m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_product_at basepoint (u m)\n              (to_Gromov_completion (v m))", "apply (rule D2(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist (u m) (to_Gromov_completion (v m)) \\<le> e2\n 2. D2 \\<le> extended_Gromov_distance (u m) (to_Gromov_completion basepoint)", "using N2[of m] N3[of m] that N \\<open>e \\<le> e2\\<close>"], ["proof (prove)\nusing this:\n  N2 \\<le> m \\<Longrightarrow> dist (to_Gromov_completion (v m)) (u m) < e\n  N3 \\<le> m \\<Longrightarrow>\n  D2 < extended_Gromov_distance (to_Gromov_completion basepoint) (u m)\n  N \\<le> n\n  N \\<le> m\n  N1 \\<le> N\n  N2 \\<le> N\n  N3 \\<le> N\n  e \\<le> e2\n\ngoal (2 subgoals):\n 1. dist (u m) (to_Gromov_completion (v m)) \\<le> e2\n 2. D2 \\<le> extended_Gromov_distance (u m) (to_Gromov_completion basepoint)", "by (auto simp add: dist_commute extended_Gromov_distance_commute)"], ["proof (state)\nthis:\n  D1 \\<le> extended_Gromov_product_at basepoint (u m)\n            (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "also"], ["proof (state)\nthis:\n  D1 \\<le> extended_Gromov_product_at basepoint (u m)\n            (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "have \"... \\<le> extended_Gromov_distance (to_Gromov_completion basepoint) (to_Gromov_completion (v m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint (u m) (to_Gromov_completion (v m))\n    \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n           (to_Gromov_completion (v m))", "using extended_Gromov_product_le_dist[of basepoint \"to_Gromov_completion (v m)\" \"u m\"]"], ["proof (prove)\nusing this:\n  extended_Gromov_product_at basepoint (to_Gromov_completion (v m)) (u m)\n  \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n         (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. extended_Gromov_product_at basepoint (u m) (to_Gromov_completion (v m))\n    \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n           (to_Gromov_completion (v m))", "by (simp add: extended_Gromov_product_at_commute)"], ["proof (state)\nthis:\n  extended_Gromov_product_at basepoint (u m) (to_Gromov_completion (v m))\n  \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n         (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "finally"], ["proof (chain)\npicking this:\n  D1 \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n            (to_Gromov_completion (v m))", "show \"D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m)) (to_Gromov_completion basepoint)\""], ["proof (prove)\nusing this:\n  D1 \\<le> extended_Gromov_distance (to_Gromov_completion basepoint)\n            (to_Gromov_completion (v m))\n\ngoal (1 subgoal):\n 1. D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n              (to_Gromov_completion basepoint)", "by (simp add: extended_Gromov_distance_commute)"], ["proof (state)\nthis:\n  D1 \\<le> extended_Gromov_distance (to_Gromov_completion (v m))\n            (to_Gromov_completion basepoint)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> ereal M\n                    \\<le> extended_Gromov_product_at basepoint\n                           (to_Gromov_completion (v ?m))\n                           (to_Gromov_completion (v ?n))\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> ereal M\n                    \\<le> extended_Gromov_product_at basepoint\n                           (to_Gromov_completion (v ?m))\n                           (to_Gromov_completion (v ?n))", "have \"M \\<le> Gromov_product_at basepoint (v m) (v n)\" if \"n \\<ge> N\" \"m \\<ge> N\" for m n"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> ereal M\n                    \\<le> extended_Gromov_product_at basepoint\n                           (to_Gromov_completion (v ?m))\n                           (to_Gromov_completion (v ?n))\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v m) (v n)", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> ereal M\n                    \\<le> extended_Gromov_product_at basepoint\n                           (to_Gromov_completion (v ?m))\n                           (to_Gromov_completion (v ?n))\n  N \\<le> n\n  N \\<le> m\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at basepoint (v m) (v n)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at basepoint (v ?m) (v ?n)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N.\n                M \\<le> Gromov_product_at basepoint (v m) (v n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at basepoint (v ?m) (v ?n)", "show \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. M \\<le> Gromov_product_at basepoint (v m) (v n)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at basepoint (v ?m) (v ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (v m) (v n)", "by blast"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. M \\<le> Gromov_product_at basepoint (v m) (v n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary v\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  Gromov_converging_at_boundary v", "obtain l where l: \"l \\<in> Gromov_boundary\" \"(\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> Gromov_boundary;\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Gromov_converging_at_boundary_converges"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary v\n  Gromov_converging_at_boundary ?u \\<Longrightarrow>\n  \\<exists>x\\<in>Gromov_boundary.\n     (\\<lambda>n. to_Gromov_completion (?u n)) \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> Gromov_boundary;\n         (\\<lambda>n. to_Gromov_completion (v n))\n         \\<longlonglongrightarrow> l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l \\<in> Gromov_boundary\n  (\\<lambda>n. to_Gromov_completion (v n)) \\<longlonglongrightarrow> l\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have \"(\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0+0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0", "proof (rule tendsto_sandwich[of \"\\<lambda>_. 0\" _ _ \"\\<lambda>n. dist (u n) (to_Gromov_completion (v n)) + dist (to_Gromov_completion (v n)) l\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> dist (u n) l\n 2. \\<forall>\\<^sub>F n in sequentially.\n       dist (u n) l\n       \\<le> dist (u n) (to_Gromov_completion (v n)) +\n             dist (to_Gromov_completion (v n)) l\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0 + 0\n 4. (\\<lambda>n.\n        dist (u n) (to_Gromov_completion (v n)) +\n        dist (to_Gromov_completion (v n)) l)\n    \\<longlonglongrightarrow> 0 + 0", "show \"(\\<lambda>n. dist (u n) (to_Gromov_completion (v n)) + dist (to_Gromov_completion (v n)) l) \\<longlonglongrightarrow> 0 + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        dist (u n) (to_Gromov_completion (v n)) +\n        dist (to_Gromov_completion (v n)) l)\n    \\<longlonglongrightarrow> 0 + 0", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. dist (u x) (to_Gromov_completion (v x)))\n    \\<longlonglongrightarrow> 0\n 2. (\\<lambda>x. dist (to_Gromov_completion (v x)) l)\n    \\<longlonglongrightarrow> 0", "using iffD1[OF tendsto_dist_iff l(2)] \\<open>(\\<lambda>n. dist (to_Gromov_completion (v n)) (u n)) \\<longlonglongrightarrow> 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>x. dist (to_Gromov_completion (v x)) l)\n  \\<longlonglongrightarrow> 0\n  (\\<lambda>n. dist (to_Gromov_completion (v n)) (u n))\n  \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. dist (u x) (to_Gromov_completion (v x)))\n    \\<longlonglongrightarrow> 0\n 2. (\\<lambda>x. dist (to_Gromov_completion (v x)) l)\n    \\<longlonglongrightarrow> 0", "by (auto simp add: dist_commute)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      dist (u n) (to_Gromov_completion (v n)) +\n      dist (to_Gromov_completion (v n)) l)\n  \\<longlonglongrightarrow> 0 + 0\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> dist (u n) l\n 2. \\<forall>\\<^sub>F n in sequentially.\n       dist (u n) l\n       \\<le> dist (u n) (to_Gromov_completion (v n)) +\n             dist (to_Gromov_completion (v n)) l\n 3. (\\<lambda>_. 0) \\<longlonglongrightarrow> 0 + 0", "qed (auto simp add: dist_triangle)"], ["proof (state)\nthis:\n  (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0", "have \"u \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0\n\ngoal (1 subgoal):\n 1. u \\<longlonglongrightarrow> l", "using iffD2[OF tendsto_dist_iff]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. dist (u n) l) \\<longlonglongrightarrow> 0 + 0\n  ((\\<lambda>x. dist (?f1 x) ?l1) \\<longlongrightarrow> 0)\n   ?F1 \\<Longrightarrow>\n  (?f1 \\<longlongrightarrow> ?l1) ?F1\n\ngoal (1 subgoal):\n 1. u \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  u \\<longlonglongrightarrow> l\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  u \\<longlonglongrightarrow> l", "have \"u0 \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. u0 \\<longlonglongrightarrow> l", "unfolding u_def"], ["proof (prove)\nusing this:\n  (u0 \\<circ> r) \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. u0 \\<longlonglongrightarrow> l", "using r(1) \\<open>Cauchy u0\\<close> Cauchy_converges_subseq"], ["proof (prove)\nusing this:\n  (u0 \\<circ> r) \\<longlonglongrightarrow> l\n  strict_mono r\n  Cauchy u0\n  \\<lbrakk>Cauchy ?u; strict_mono ?r;\n   (?u \\<circ> ?r) \\<longlonglongrightarrow> ?l\\<rbrakk>\n  \\<Longrightarrow> ?u \\<longlonglongrightarrow> ?l\n\ngoal (1 subgoal):\n 1. u0 \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  u0 \\<longlonglongrightarrow> l\n\ngoal (2 subgoals):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) =\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l\n 2. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  u0 \\<longlonglongrightarrow> l", "show \"\\<exists>l. u0 \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  u0 \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. \\<exists>l. u0 \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  \\<exists>l. u0 \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "case False"], ["proof (state)\nthis:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint)\n        (u0 n)) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "define C where \"C = limsup (\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) + 1\""], ["proof (state)\nthis:\n  C =\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) +\n  1\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have \"C < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C < \\<infinity>", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) +\n    1\n    < \\<infinity>", "using False less_top"], ["proof (prove)\nusing this:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint)\n        (u0 n)) \\<noteq>\n  \\<infinity>\n  (?a \\<noteq> top) = (?a < top)\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) +\n    1\n    < \\<infinity>", "by fastforce"], ["proof (state)\nthis:\n  C < \\<infinity>\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have *: \"limsup (\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> limsup\n             (\\<lambda>n.\n                 extended_Gromov_distance (to_Gromov_completion basepoint)\n                  (u0 n))", "by (intro le_Limsup always_eventually, auto)"], ["proof (state)\nthis:\n  0 \\<le> limsup\n           (\\<lambda>n.\n               extended_Gromov_distance (to_Gromov_completion basepoint)\n                (u0 n))\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have \"limsup (\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)) < C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n))\n    < C", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n))\n    < limsup\n       (\\<lambda>n.\n           extended_Gromov_distance (to_Gromov_completion basepoint)\n            (u0 n)) +\n      1", "using False * ereal_add_left_cancel_less"], ["proof (prove)\nusing this:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint)\n        (u0 n)) \\<noteq>\n  \\<infinity>\n  0 \\<le> limsup\n           (\\<lambda>n.\n               extended_Gromov_distance (to_Gromov_completion basepoint)\n                (u0 n))\n  \\<lbrakk>0 \\<le> ?a; 0 \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (?a + ?b < ?a + ?c) =\n                    (?a \\<noteq> \\<infinity> \\<and> ?b < ?c)\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n))\n    < limsup\n       (\\<lambda>n.\n           extended_Gromov_distance (to_Gromov_completion basepoint)\n            (u0 n)) +\n      1", "by force"], ["proof (state)\nthis:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n))\n  < C\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n))\n  < C", "have \"eventually (\\<lambda>n. extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n) < C) sequentially\""], ["proof (prove)\nusing this:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n))\n  < C\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n) < C", "using Limsup_lessD"], ["proof (prove)\nusing this:\n  limsup\n   (\\<lambda>n.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n))\n  < C\n  Limsup ?F ?f < ?y \\<Longrightarrow> \\<forall>\\<^sub>F x in ?F. ?f x < ?y\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n) < C", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n) < C\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially.\n     extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n) < C", "obtain N where N: \"\\<And>n. n \\<ge> N \\<Longrightarrow> extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n) < C\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n) < C\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)\n            < C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n) < C\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            extended_Gromov_distance (to_Gromov_completion basepoint) (u0 n)\n            < C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<le> ?n \\<Longrightarrow>\n  extended_Gromov_distance (to_Gromov_completion basepoint) (u0 ?n) < C\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "define r where \"r = (\\<lambda>n. n + N)\""], ["proof (state)\nthis:\n  r = (\\<lambda>n. n + N)\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have r: \"strict_mono r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono r", "unfolding r_def strict_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. x < y \\<longrightarrow> x + N < y + N", "by auto"], ["proof (state)\nthis:\n  strict_mono r\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "define u where \"u = (u0 o r)\""], ["proof (state)\nthis:\n  u = u0 \\<circ> r\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have \"Cauchy u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy u", "using \\<open>Cauchy u0\\<close> r(1) u_def"], ["proof (prove)\nusing this:\n  Cauchy u0\n  strict_mono r\n  u = u0 \\<circ> r\n\ngoal (1 subgoal):\n 1. Cauchy u", "by (simp add: Cauchy_subseq_Cauchy)"], ["proof (state)\nthis:\n  Cauchy u\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have u: \"extended_Gromov_distance (to_Gromov_completion basepoint) (u n) \\<le> C\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion basepoint) (u n) \\<le> C", "unfolding u_def comp_def r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion basepoint) (u0 (n + N))\n    \\<le> C", "using N"], ["proof (prove)\nusing this:\n  N \\<le> ?n \\<Longrightarrow>\n  extended_Gromov_distance (to_Gromov_completion basepoint) (u0 ?n) < C\n\ngoal (1 subgoal):\n 1. extended_Gromov_distance (to_Gromov_completion basepoint) (u0 (n + N))\n    \\<le> C", "by (auto simp add: less_imp_le)"], ["proof (state)\nthis:\n  extended_Gromov_distance (to_Gromov_completion basepoint) (u ?n) \\<le> C\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "define v where \"v = (\\<lambda>n. from_Gromov_completion (u n))\""], ["proof (state)\nthis:\n  v = (\\<lambda>n. from_Gromov_completion (u n))\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have uv: \"u n = to_Gromov_completion (v n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. u n = to_Gromov_completion (v n)", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u n = to_Gromov_completion (from_Gromov_completion (u n))", "apply (rule to_from_Gromov_completion[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. u n \\<notin> Gromov_boundary", "using u[of n] \\<open>C < \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  extended_Gromov_distance (to_Gromov_completion basepoint) (u n) \\<le> C\n  C < \\<infinity>\n\ngoal (1 subgoal):\n 1. u n \\<notin> Gromov_boundary", "by auto"], ["proof (state)\nthis:\n  u ?n = to_Gromov_completion (v ?n)\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "have \"Cauchy v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy v", "proof (rule metric_CauchyI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e", "obtain a::real where a: \"a > 0\" \"\\<And>x y::'a Gromov_completion. extended_Gromov_distance (to_Gromov_completion basepoint) x \\<le> C \\<Longrightarrow> dist x y \\<le> a\n          \\<Longrightarrow> esqrt(extended_Gromov_distance x y) \\<le> 2 * ereal(dist x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>0 < a;\n         \\<And>x y.\n            \\<lbrakk>extended_Gromov_distance\n                      (to_Gromov_completion basepoint) x\n                     \\<le> C;\n             dist x y \\<le> a\\<rbrakk>\n            \\<Longrightarrow> esqrt (extended_Gromov_distance x y)\n                              \\<le> 2 * ereal (dist x y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using inside_Gromov_distance_approx[OF \\<open>C < \\<infinity>\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>e>0.\n     \\<forall>x y.\n        extended_Gromov_distance (to_Gromov_completion basepoint) x\n        \\<le> C \\<longrightarrow>\n        dist x y \\<le> e \\<longrightarrow>\n        esqrt (extended_Gromov_distance x y) \\<le> 2 * ereal (dist x y)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>0 < a;\n         \\<And>x y.\n            \\<lbrakk>extended_Gromov_distance\n                      (to_Gromov_completion basepoint) x\n                     \\<le> C;\n             dist x y \\<le> a\\<rbrakk>\n            \\<Longrightarrow> esqrt (extended_Gromov_distance x y)\n                              \\<le> 2 * ereal (dist x y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < a\n  \\<lbrakk>extended_Gromov_distance (to_Gromov_completion basepoint) ?x\n           \\<le> C;\n   dist ?x ?y \\<le> a\\<rbrakk>\n  \\<Longrightarrow> esqrt (extended_Gromov_distance ?x ?y)\n                    \\<le> 2 * ereal (dist ?x ?y)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e", "fix e::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e", "assume \"e > 0\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e", "define e2 where \"e2 = min (sqrt (e/2) /2) a\""], ["proof (state)\nthis:\n  e2 = min (sqrt (e / 2) / 2) a\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e", "have \"e2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e2", "unfolding e2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < min (sqrt (e / 2) / 2) a", "using \\<open>e > 0\\<close> \\<open>a > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  0 < a\n\ngoal (1 subgoal):\n 1. 0 < min (sqrt (e / 2) / 2) a", "by auto"], ["proof (state)\nthis:\n  0 < e2\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e", "then"], ["proof (chain)\npicking this:\n  0 < e2", "obtain N where N: \"\\<And>m n. m \\<ge> N \\<Longrightarrow> n \\<ge> N \\<Longrightarrow> dist (u m) (u n) < e2\""], ["proof (prove)\nusing this:\n  0 < e2\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> m; N \\<le> n\\<rbrakk>\n            \\<Longrightarrow> dist (u m) (u n) < e2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Cauchy u\\<close>"], ["proof (prove)\nusing this:\n  0 < e2\n  Cauchy u\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> m; N \\<le> n\\<rbrakk>\n            \\<Longrightarrow> dist (u m) (u n) < e2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Cauchy_def"], ["proof (prove)\nusing this:\n  0 < e2\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (u m) (u n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> m; N \\<le> n\\<rbrakk>\n            \\<Longrightarrow> dist (u m) (u n) < e2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> dist (u ?m) (u ?n) < e2\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e", "have \"dist (v m) (v n) < e\" if \"n \\<ge> N\" \"m \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "have \"ereal(sqrt(dist (v m) (v n))) = esqrt(extended_Gromov_distance (u m) (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (sqrt (dist (v m) (v n))) =\n    esqrt (extended_Gromov_distance (u m) (u n))", "unfolding uv"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (sqrt (dist (v m) (v n))) =\n    esqrt\n     (extended_Gromov_distance (to_Gromov_completion (v m))\n       (to_Gromov_completion (v n)))", "by (auto simp add: esqrt_ereal_ereal_sqrt)"], ["proof (state)\nthis:\n  ereal (sqrt (dist (v m) (v n))) =\n  esqrt (extended_Gromov_distance (u m) (u n))\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "also"], ["proof (state)\nthis:\n  ereal (sqrt (dist (v m) (v n))) =\n  esqrt (extended_Gromov_distance (u m) (u n))\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "have \"... \\<le> 2 * ereal(dist (u m) (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt (extended_Gromov_distance (u m) (u n))\n    \\<le> 2 * ereal (dist (u m) (u n))", "apply (rule a(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. extended_Gromov_distance (to_Gromov_completion basepoint) (u m) \\<le> C\n 2. dist (u m) (u n) \\<le> a", "using u[of m] N[OF \\<open>m \\<ge> N\\<close> \\<open>n \\<ge> N\\<close>]"], ["proof (prove)\nusing this:\n  extended_Gromov_distance (to_Gromov_completion basepoint) (u m) \\<le> C\n  dist (u m) (u n) < e2\n\ngoal (2 subgoals):\n 1. extended_Gromov_distance (to_Gromov_completion basepoint) (u m) \\<le> C\n 2. dist (u m) (u n) \\<le> a", "unfolding e2_def"], ["proof (prove)\nusing this:\n  extended_Gromov_distance (to_Gromov_completion basepoint) (u m) \\<le> C\n  dist (u m) (u n) < min (sqrt (e / 2) / 2) a\n\ngoal (2 subgoals):\n 1. extended_Gromov_distance (to_Gromov_completion basepoint) (u m) \\<le> C\n 2. dist (u m) (u n) \\<le> a", "by auto"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance (u m) (u n))\n  \\<le> 2 * ereal (dist (u m) (u n))\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "also"], ["proof (state)\nthis:\n  esqrt (extended_Gromov_distance (u m) (u n))\n  \\<le> 2 * ereal (dist (u m) (u n))\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "have \"... = ereal(2 * dist (u m) (u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ereal (dist (u m) (u n)) = ereal (2 * dist (u m) (u n))", "by simp"], ["proof (state)\nthis:\n  2 * ereal (dist (u m) (u n)) = ereal (2 * dist (u m) (u n))\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "also"], ["proof (state)\nthis:\n  2 * ereal (dist (u m) (u n)) = ereal (2 * dist (u m) (u n))\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "have \"... \\<le> ereal(2 * e2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (2 * dist (u m) (u n)) \\<le> ereal (2 * e2)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist (u m) (u n) \\<le> e2\n 2. 0 \\<le> 2", "using N[OF \\<open>m \\<ge> N\\<close> \\<open>n \\<ge> N\\<close>] less_imp_le"], ["proof (prove)\nusing this:\n  dist (u m) (u n) < e2\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (2 subgoals):\n 1. dist (u m) (u n) \\<le> e2\n 2. 0 \\<le> 2", "by auto"], ["proof (state)\nthis:\n  ereal (2 * dist (u m) (u n)) \\<le> ereal (2 * e2)\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "finally"], ["proof (chain)\npicking this:\n  ereal (sqrt (dist (v m) (v n))) \\<le> ereal (2 * e2)", "have \"sqrt(dist (v m) (v n)) \\<le> 2 * e2\""], ["proof (prove)\nusing this:\n  ereal (sqrt (dist (v m) (v n))) \\<le> ereal (2 * e2)\n\ngoal (1 subgoal):\n 1. sqrt (dist (v m) (v n)) \\<le> 2 * e2", "using \\<open>e2 > 0\\<close>"], ["proof (prove)\nusing this:\n  ereal (sqrt (dist (v m) (v n))) \\<le> ereal (2 * e2)\n  0 < e2\n\ngoal (1 subgoal):\n 1. sqrt (dist (v m) (v n)) \\<le> 2 * e2", "by auto"], ["proof (state)\nthis:\n  sqrt (dist (v m) (v n)) \\<le> 2 * e2\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "also"], ["proof (state)\nthis:\n  sqrt (dist (v m) (v n)) \\<le> 2 * e2\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "have \"... \\<le> sqrt (e/2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * e2 \\<le> sqrt (e / 2)", "unfolding e2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * min (sqrt (e / 2) / 2) a \\<le> sqrt (e / 2)", "by auto"], ["proof (state)\nthis:\n  2 * e2 \\<le> sqrt (e / 2)\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "finally"], ["proof (chain)\npicking this:\n  sqrt (dist (v m) (v n)) \\<le> sqrt (e / 2)", "have \"dist (v m) (v n) \\<le> e/2\""], ["proof (prove)\nusing this:\n  sqrt (dist (v m) (v n)) \\<le> sqrt (e / 2)\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) \\<le> e / 2", "by auto"], ["proof (state)\nthis:\n  dist (v m) (v n) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "then"], ["proof (chain)\npicking this:\n  dist (v m) (v n) \\<le> e / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (v m) (v n) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  dist (v m) (v n) \\<le> e / 2\n  0 < e\n\ngoal (1 subgoal):\n 1. dist (v m) (v n) < e", "by auto"], ["proof (state)\nthis:\n  dist (v m) (v n) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> dist (v ?m) (v ?n) < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> dist (v ?m) (v ?n) < e", "show \"\\<exists>M. \\<forall>m \\<ge> M. \\<forall>n \\<ge> M. dist (v m) (v n) < e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> dist (v ?m) (v ?n) < e\n\ngoal (1 subgoal):\n 1. \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (v m) (v n) < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cauchy v\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  Cauchy v", "obtain l where \"v \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  Cauchy v\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        v \\<longlonglongrightarrow> l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>complete (UNIV::'a set)\\<close> complete_def"], ["proof (prove)\nusing this:\n  Cauchy v\n  complete UNIV\n  complete ?S =\n  (\\<forall>f.\n      (\\<forall>n. f n \\<in> ?S) \\<and> Cauchy f \\<longrightarrow>\n      (\\<exists>l\\<in>?S. f \\<longlonglongrightarrow> l))\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        v \\<longlonglongrightarrow> l \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  v \\<longlonglongrightarrow> l", "have \"u \\<longlonglongrightarrow> (to_Gromov_completion l)\""], ["proof (prove)\nusing this:\n  v \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. u \\<longlonglongrightarrow> to_Gromov_completion l", "unfolding uv"], ["proof (prove)\nusing this:\n  v \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_Gromov_completion (v n))\n    \\<longlonglongrightarrow> to_Gromov_completion l", "by auto"], ["proof (state)\nthis:\n  u \\<longlonglongrightarrow> to_Gromov_completion l\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  u \\<longlonglongrightarrow> to_Gromov_completion l", "have \"u0 \\<longlonglongrightarrow> (to_Gromov_completion l)\""], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> to_Gromov_completion l\n\ngoal (1 subgoal):\n 1. u0 \\<longlonglongrightarrow> to_Gromov_completion l", "unfolding u_def"], ["proof (prove)\nusing this:\n  (u0 \\<circ> r) \\<longlonglongrightarrow> to_Gromov_completion l\n\ngoal (1 subgoal):\n 1. u0 \\<longlonglongrightarrow> to_Gromov_completion l", "using r(1) \\<open>Cauchy u0\\<close> Cauchy_converges_subseq"], ["proof (prove)\nusing this:\n  (u0 \\<circ> r) \\<longlonglongrightarrow> to_Gromov_completion l\n  strict_mono r\n  Cauchy u0\n  \\<lbrakk>Cauchy ?u; strict_mono ?r;\n   (?u \\<circ> ?r) \\<longlonglongrightarrow> ?l\\<rbrakk>\n  \\<Longrightarrow> ?u \\<longlonglongrightarrow> ?l\n\ngoal (1 subgoal):\n 1. u0 \\<longlonglongrightarrow> to_Gromov_completion l", "by auto"], ["proof (state)\nthis:\n  u0 \\<longlonglongrightarrow> to_Gromov_completion l\n\ngoal (1 subgoal):\n 1. limsup\n     (\\<lambda>n.\n         extended_Gromov_distance (to_Gromov_completion basepoint)\n          (u0 n)) \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    \\<exists>l. u0 \\<longlonglongrightarrow> l", "then"], ["proof (chain)\npicking this:\n  u0 \\<longlonglongrightarrow> to_Gromov_completion l", "show \"\\<exists>l. u0 \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  u0 \\<longlonglongrightarrow> to_Gromov_completion l\n\ngoal (1 subgoal):\n 1. \\<exists>l. u0 \\<longlonglongrightarrow> l", "by auto"], ["proof (state)\nthis:\n  \\<exists>l. u0 \\<longlonglongrightarrow> l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>l. u0 \\<longlonglongrightarrow> l\n\ngoal:\nNo subgoals!", "qed"], ["", "instance Gromov_completion::(\"{Gromov_hyperbolic_space, complete_space}\") complete_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Gromov_completion, complete_space_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "using Gromov_completion_complete complete_def convergent_def complete_UNIV"], ["proof (prove)\nusing this:\n  complete UNIV \\<Longrightarrow> complete UNIV\n  complete ?S =\n  (\\<forall>f.\n      (\\<forall>n. f n \\<in> ?S) \\<and> Cauchy f \\<longrightarrow>\n      (\\<exists>l\\<in>?S. f \\<longlonglongrightarrow> l))\n  convergent ?X = (\\<exists>L. ?X \\<longlonglongrightarrow> L)\n  complete UNIV\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "by auto"], ["", "text \\<open>When the original space is proper, i.e., closed balls are compact, and geodesic, then the\nGromov completion (and therefore the Gromov boundary) are compact. The idea to extract a convergent\nsubsequence of a sequence $u_n$ in the boundary is to take the point $v_n$ at distance $T$ along\na geodesic tending to the point $u_n$ on the boundary, where $T$ is fixed and large. The points\n$v_n$ live in a bounded subset of the space, hence they have a convergent subsequence $v_{j(n)}$.\nIt follows that $u_{j(n)}$ is almost converging, up to an error that tends to $0$ when $T$ tends\nto infinity. By a diagonal argument, we obtain a convergent subsequence of $u_n$.\n\nAs we have already proved that the space is complete, there is a shortcut to the above argument,\navoiding subsequences and diagonal argument altogether. Indeed, in a complete space it suffices\nto show that for any $\\epsilon > 0$ it is covered by finitely many balls of radius $\\epsilon$ to get\nthe compactness. This is what we do in the following proof, although the argument is precisely\nmodelled on the first proof we have explained.\\<close>"], ["", "theorem Gromov_completion_compact:\n  assumes \"proper (UNIV::'a::Gromov_hyperbolic_space_geodesic set)\"\n  shows \"compact (UNIV::'a Gromov_completion set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. compact UNIV", "have \"\\<exists>k. finite k \\<and> (UNIV::'a Gromov_completion set) \\<subseteq> (\\<Union>x\\<in>k. ball x e)\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "define D::real where \"D = max 0 (-ln(e/4)/epsilonG(TYPE('a)))\""], ["proof (state)\nthis:\n  D = max 0 (- ln (e / 4) / epsilonG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "have \"D \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> max 0 (- ln (e / 4) / epsilonG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "have \"exp(-epsilonG(TYPE('a)) * D) \\<le> exp(ln (e / 4))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- epsilonG TYPE('a) * D) \\<le> exp (ln (e / 4))", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- epsilonG TYPE('a) * max 0 (- ln (e / 4) / epsilonG TYPE('a)))\n    \\<le> exp (ln (e / 4))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - epsilonG TYPE('a) * max 0 (- ln (e / 4) / epsilonG TYPE('a))\n    \\<le> ln (e / 4)", "unfolding max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - epsilonG TYPE('a) *\n    (if 0 \\<le> - ln (e / 4) / epsilonG TYPE('a)\n     then - ln (e / 4) / epsilonG TYPE('a) else 0)\n    \\<le> ln (e / 4)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. epsilonG TYPE('a) = 0 \\<Longrightarrow> 0 \\<le> ln (e / 4)\n 2. \\<lbrakk>epsilonG TYPE('a) \\<noteq> 0;\n     \\<not> ln (e / 4) / epsilonG TYPE('a) \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> ln (e / 4)", "using constant_in_extended_predist_pos(1)[where ?'a = 'a]"], ["proof (prove)\nusing this:\n  0 < epsilonG TYPE('a)\n\ngoal (2 subgoals):\n 1. epsilonG TYPE('a) = 0 \\<Longrightarrow> 0 \\<le> ln (e / 4)\n 2. \\<lbrakk>epsilonG TYPE('a) \\<noteq> 0;\n     \\<not> ln (e / 4) / epsilonG TYPE('a) \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> ln (e / 4)", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  exp (- epsilonG TYPE('a) * D) \\<le> exp (ln (e / 4))\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "then"], ["proof (chain)\npicking this:\n  exp (- epsilonG TYPE('a) * D) \\<le> exp (ln (e / 4))", "have \"exp(-epsilonG(TYPE('a)) * D) \\<le> e/4\""], ["proof (prove)\nusing this:\n  exp (- epsilonG TYPE('a) * D) \\<le> exp (ln (e / 4))\n\ngoal (1 subgoal):\n 1. exp (- epsilonG TYPE('a) * D) \\<le> e / 4", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  exp (- epsilonG TYPE('a) * D) \\<le> exp (ln (e / 4))\n  0 < e\n\ngoal (1 subgoal):\n 1. exp (- epsilonG TYPE('a) * D) \\<le> e / 4", "by auto"], ["proof (state)\nthis:\n  exp (- epsilonG TYPE('a) * D) \\<le> e / 4\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "define e0::real where \"e0 = e * e / 16\""], ["proof (state)\nthis:\n  e0 = e * e / 16\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "have \"e0 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e0", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. 0 < e0", "unfolding e0_def"], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. 0 < e * e / 16", "by auto"], ["proof (state)\nthis:\n  0 < e0\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "obtain k::\"'a set\" where k: \"finite k\" \"cball basepoint D \\<subseteq> (\\<Union>x\\<in>k. ball x e0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>finite k;\n         cball basepoint D \\<subseteq> (\\<Union>x\\<in>k. ball x e0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using compact_eq_totally_bounded[of \"cball (basepoint::'a) D\"] assms \\<open>e0 > 0\\<close>"], ["proof (prove)\nusing this:\n  compact (cball basepoint D) =\n  (complete (cball basepoint D) \\<and>\n   (\\<forall>e>0.\n       \\<exists>k.\n          finite k \\<and>\n          cball basepoint D \\<subseteq> (\\<Union>x\\<in>k. ball x e)))\n  proper UNIV\n  0 < e0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>finite k;\n         cball basepoint D \\<subseteq> (\\<Union>x\\<in>k. ball x e0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding proper_def"], ["proof (prove)\nusing this:\n  compact (cball basepoint D) =\n  (complete (cball basepoint D) \\<and>\n   (\\<forall>e>0.\n       \\<exists>k.\n          finite k \\<and>\n          cball basepoint D \\<subseteq> (\\<Union>x\\<in>k. ball x e)))\n  \\<forall>x r. compact (cball x r \\<inter> UNIV)\n  0 < e0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>finite k;\n         cball basepoint D \\<subseteq> (\\<Union>x\\<in>k. ball x e0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite k\n  cball basepoint D \\<subseteq> (\\<Union>x\\<in>k. ball x e0)\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "have A: \"\\<exists>y \\<in> k. dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e/4\" if \"dist basepoint x \\<le> D\" for x::'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "obtain z where z: \"z \\<in> k\" \"dist z x < e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> k; dist z x < e0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>dist basepoint x \\<le> D\\<close> k(2)"], ["proof (prove)\nusing this:\n  dist basepoint x \\<le> D\n  cball basepoint D \\<subseteq> (\\<Union>x\\<in>k. ball x e0)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> k; dist z x < e0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> k\n  dist z x < e0\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "have \"ereal(dist (to_Gromov_completion z) (to_Gromov_completion x)) \\<le> esqrt(extended_Gromov_distance (to_Gromov_completion z) (to_Gromov_completion x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist (to_Gromov_completion z) (to_Gromov_completion x))\n    \\<le> esqrt\n           (extended_Gromov_distance (to_Gromov_completion z)\n             (to_Gromov_completion x))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  ereal (dist (to_Gromov_completion z) (to_Gromov_completion x))\n  \\<le> esqrt\n         (extended_Gromov_distance (to_Gromov_completion z)\n           (to_Gromov_completion x))\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "also"], ["proof (state)\nthis:\n  ereal (dist (to_Gromov_completion z) (to_Gromov_completion x))\n  \\<le> esqrt\n         (extended_Gromov_distance (to_Gromov_completion z)\n           (to_Gromov_completion x))\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "have \"... = ereal(sqrt (dist z x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. esqrt\n     (extended_Gromov_distance (to_Gromov_completion z)\n       (to_Gromov_completion x)) =\n    ereal (sqrt (dist z x))", "by auto"], ["proof (state)\nthis:\n  esqrt\n   (extended_Gromov_distance (to_Gromov_completion z)\n     (to_Gromov_completion x)) =\n  ereal (sqrt (dist z x))\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "finally"], ["proof (chain)\npicking this:\n  ereal (dist (to_Gromov_completion z) (to_Gromov_completion x))\n  \\<le> ereal (sqrt (dist z x))", "have \"dist (to_Gromov_completion z) (to_Gromov_completion x) \\<le> sqrt (dist z x)\""], ["proof (prove)\nusing this:\n  ereal (dist (to_Gromov_completion z) (to_Gromov_completion x))\n  \\<le> ereal (sqrt (dist z x))\n\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion z) (to_Gromov_completion x)\n    \\<le> sqrt (dist z x)", "by auto"], ["proof (state)\nthis:\n  dist (to_Gromov_completion z) (to_Gromov_completion x)\n  \\<le> sqrt (dist z x)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "also"], ["proof (state)\nthis:\n  dist (to_Gromov_completion z) (to_Gromov_completion x)\n  \\<le> sqrt (dist z x)\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "have \"... \\<le> sqrt e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (dist z x) \\<le> sqrt e0", "using z(2)"], ["proof (prove)\nusing this:\n  dist z x < e0\n\ngoal (1 subgoal):\n 1. sqrt (dist z x) \\<le> sqrt e0", "by auto"], ["proof (state)\nthis:\n  sqrt (dist z x) \\<le> sqrt e0\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "also"], ["proof (state)\nthis:\n  sqrt (dist z x) \\<le> sqrt e0\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "have \"... \\<le> e/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt e0 \\<le> e / 4", "unfolding e0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (e * e / 16) \\<le> e / 4", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. sqrt (e * e / 16) \\<le> e / 4", "by (auto simp add: less_imp_le real_sqrt_divide)"], ["proof (state)\nthis:\n  sqrt e0 \\<le> e / 4\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "finally"], ["proof (chain)\npicking this:\n  dist (to_Gromov_completion z) (to_Gromov_completion x) \\<le> e / 4", "have \"dist (to_Gromov_completion z) (to_Gromov_completion x) \\<le> e/4\""], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion z) (to_Gromov_completion x) \\<le> e / 4\n\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion z) (to_Gromov_completion x) \\<le> e / 4", "by auto"], ["proof (state)\nthis:\n  dist (to_Gromov_completion z) (to_Gromov_completion x) \\<le> e / 4\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "then"], ["proof (chain)\npicking this:\n  dist (to_Gromov_completion z) (to_Gromov_completion x) \\<le> e / 4", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion z) (to_Gromov_completion x) \\<le> e / 4\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "using \\<open>z \\<in> k\\<close>"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion z) (to_Gromov_completion x) \\<le> e / 4\n  z \\<in> k\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>k.\n     dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist basepoint ?x \\<le> D \\<Longrightarrow>\n  \\<exists>y\\<in>k.\n     dist (to_Gromov_completion y) (to_Gromov_completion ?x) \\<le> e / 4\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "have B: \"\\<exists>y \\<in> k. dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e/2\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "proof (cases \"dist basepoint x \\<le> D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2\n 2. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "case True"], ["proof (state)\nthis:\n  dist basepoint x \\<le> D\n\ngoal (2 subgoals):\n 1. dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2\n 2. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have \"e/4 \\<le> e/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e / 4 \\<le> e / 2", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. e / 4 \\<le> e / 2", "by auto"], ["proof (state)\nthis:\n  e / 4 \\<le> e / 2\n\ngoal (2 subgoals):\n 1. dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2\n 2. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "then"], ["proof (chain)\npicking this:\n  e / 4 \\<le> e / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  e / 4 \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "using A[OF True]"], ["proof (prove)\nusing this:\n  e / 4 \\<le> e / 2\n  \\<exists>y\\<in>k.\n     dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 4\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "by force"], ["proof (state)\nthis:\n  \\<exists>y\\<in>k.\n     dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "case False"], ["proof (state)\nthis:\n  \\<not> dist basepoint x \\<le> D\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "define x2 where \"x2 = geodesic_segment_param {basepoint--x} basepoint D\""], ["proof (state)\nthis:\n  x2 = geodesic_segment_param {basepoint--x} basepoint D\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have *: \"Gromov_product_at basepoint x x2 = D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at basepoint x x2 = D", "unfolding x2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at basepoint x\n     (geodesic_segment_param {basepoint--x} basepoint D) =\n    D", "apply (rule Gromov_product_geodesic_segment)"], ["proof (prove)\ngoal (2 subgoals):\n 1. geodesic_segment_between {basepoint--x} basepoint x\n 2. D \\<in> {0..dist basepoint x}", "using False \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> dist basepoint x \\<le> D\n  0 \\<le> D\n\ngoal (2 subgoals):\n 1. geodesic_segment_between {basepoint--x} basepoint x\n 2. D \\<in> {0..dist basepoint x}", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at basepoint x x2 = D\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have \"ereal(dist (to_Gromov_completion x) (to_Gromov_completion x2))\n            \\<le> eexp (- epsilonG(TYPE('a)) * extended_Gromov_product_at basepoint (to_Gromov_completion x) (to_Gromov_completion x2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (dist (to_Gromov_completion x) (to_Gromov_completion x2))\n    \\<le> eexp\n           (ereal (- epsilonG TYPE('a)) *\n            extended_Gromov_product_at basepoint (to_Gromov_completion x)\n             (to_Gromov_completion x2))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  ereal (dist (to_Gromov_completion x) (to_Gromov_completion x2))\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint (to_Gromov_completion x)\n           (to_Gromov_completion x2))\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "also"], ["proof (state)\nthis:\n  ereal (dist (to_Gromov_completion x) (to_Gromov_completion x2))\n  \\<le> eexp\n         (ereal (- epsilonG TYPE('a)) *\n          extended_Gromov_product_at basepoint (to_Gromov_completion x)\n           (to_Gromov_completion x2))\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have \"... = eexp (- epsilonG(TYPE('a)) * ereal D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint (to_Gromov_completion x)\n       (to_Gromov_completion x2)) =\n    eexp (ereal (- epsilonG TYPE('a)) * ereal D)", "using *"], ["proof (prove)\nusing this:\n  Gromov_product_at basepoint x x2 = D\n\ngoal (1 subgoal):\n 1. eexp\n     (ereal (- epsilonG TYPE('a)) *\n      extended_Gromov_product_at basepoint (to_Gromov_completion x)\n       (to_Gromov_completion x2)) =\n    eexp (ereal (- epsilonG TYPE('a)) * ereal D)", "by auto"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint (to_Gromov_completion x)\n     (to_Gromov_completion x2)) =\n  eexp (ereal (- epsilonG TYPE('a)) * ereal D)\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "also"], ["proof (state)\nthis:\n  eexp\n   (ereal (- epsilonG TYPE('a)) *\n    extended_Gromov_product_at basepoint (to_Gromov_completion x)\n     (to_Gromov_completion x2)) =\n  eexp (ereal (- epsilonG TYPE('a)) * ereal D)\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have \"... = ereal(exp(-epsilonG(TYPE('a)) * D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (ereal (- epsilonG TYPE('a)) * ereal D) =\n    ereal (exp (- epsilonG TYPE('a) * D))", "by auto"], ["proof (state)\nthis:\n  eexp (ereal (- epsilonG TYPE('a)) * ereal D) =\n  ereal (exp (- epsilonG TYPE('a) * D))\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "also"], ["proof (state)\nthis:\n  eexp (ereal (- epsilonG TYPE('a)) * ereal D) =\n  ereal (exp (- epsilonG TYPE('a) * D))\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have \"... \\<le> ereal(e/4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (exp (- epsilonG TYPE('a) * D)) \\<le> ereal (e / 4)", "by (intro mono_intros, fact)"], ["proof (state)\nthis:\n  ereal (exp (- epsilonG TYPE('a) * D)) \\<le> ereal (e / 4)\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "finally"], ["proof (chain)\npicking this:\n  ereal (dist (to_Gromov_completion x) (to_Gromov_completion x2))\n  \\<le> ereal (e / 4)", "have \"dist (to_Gromov_completion x) (to_Gromov_completion x2) \\<le> e/4\""], ["proof (prove)\nusing this:\n  ereal (dist (to_Gromov_completion x) (to_Gromov_completion x2))\n  \\<le> ereal (e / 4)\n\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion x) (to_Gromov_completion x2) \\<le> e / 4", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  ereal (dist (to_Gromov_completion x) (to_Gromov_completion x2))\n  \\<le> ereal (e / 4)\n  0 < e\n\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion x) (to_Gromov_completion x2) \\<le> e / 4", "by auto"], ["proof (state)\nthis:\n  dist (to_Gromov_completion x) (to_Gromov_completion x2) \\<le> e / 4\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have \"dist basepoint x2 \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist basepoint x2 \\<le> D", "unfolding x2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist basepoint (geodesic_segment_param {basepoint--x} basepoint D)\n    \\<le> D", "using False \\<open>0 \\<le> D\\<close>"], ["proof (prove)\nusing this:\n  \\<not> dist basepoint x \\<le> D\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. dist basepoint (geodesic_segment_param {basepoint--x} basepoint D)\n    \\<le> D", "by auto"], ["proof (state)\nthis:\n  dist basepoint x2 \\<le> D\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "then"], ["proof (chain)\npicking this:\n  dist basepoint x2 \\<le> D", "obtain y where \"y \\<in> k\" \"dist (to_Gromov_completion y) (to_Gromov_completion x2) \\<le> e/4\""], ["proof (prove)\nusing this:\n  dist basepoint x2 \\<le> D\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> k;\n         dist (to_Gromov_completion y) (to_Gromov_completion x2)\n         \\<le> e / 4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using A"], ["proof (prove)\nusing this:\n  dist basepoint x2 \\<le> D\n  dist basepoint ?x \\<le> D \\<Longrightarrow>\n  \\<exists>y\\<in>k.\n     dist (to_Gromov_completion y) (to_Gromov_completion ?x) \\<le> e / 4\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> k;\n         dist (to_Gromov_completion y) (to_Gromov_completion x2)\n         \\<le> e / 4\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> k\n  dist (to_Gromov_completion y) (to_Gromov_completion x2) \\<le> e / 4\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have \"dist (to_Gromov_completion y) (to_Gromov_completion x)\n            \\<le> dist (to_Gromov_completion y) (to_Gromov_completion x2) + dist (to_Gromov_completion x) (to_Gromov_completion x2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion y) (to_Gromov_completion x)\n    \\<le> dist (to_Gromov_completion y) (to_Gromov_completion x2) +\n          dist (to_Gromov_completion x) (to_Gromov_completion x2)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (to_Gromov_completion y) (to_Gromov_completion x)\n  \\<le> dist (to_Gromov_completion y) (to_Gromov_completion x2) +\n        dist (to_Gromov_completion x) (to_Gromov_completion x2)\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "also"], ["proof (state)\nthis:\n  dist (to_Gromov_completion y) (to_Gromov_completion x)\n  \\<le> dist (to_Gromov_completion y) (to_Gromov_completion x2) +\n        dist (to_Gromov_completion x) (to_Gromov_completion x2)\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have \"... \\<le> e/4 + e/4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion y) (to_Gromov_completion x2) +\n    dist (to_Gromov_completion x) (to_Gromov_completion x2)\n    \\<le> e / 4 + e / 4", "by (intro mono_intros, fact, fact)"], ["proof (state)\nthis:\n  dist (to_Gromov_completion y) (to_Gromov_completion x2) +\n  dist (to_Gromov_completion x) (to_Gromov_completion x2)\n  \\<le> e / 4 + e / 4\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "also"], ["proof (state)\nthis:\n  dist (to_Gromov_completion y) (to_Gromov_completion x2) +\n  dist (to_Gromov_completion x) (to_Gromov_completion x2)\n  \\<le> e / 4 + e / 4\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "have \"... = e/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e / 4 + e / 4 = e / 2", "by simp"], ["proof (state)\nthis:\n  e / 4 + e / 4 = e / 2\n\ngoal (1 subgoal):\n 1. \\<not> dist basepoint x \\<le> D \\<Longrightarrow>\n    \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "finally"], ["proof (chain)\npicking this:\n  dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "using \\<open>y \\<in> k\\<close>"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2\n  y \\<in> k\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k.\n       dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>k.\n     dist (to_Gromov_completion y) (to_Gromov_completion x) \\<le> e / 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y\\<in>k.\n     dist (to_Gromov_completion y) (to_Gromov_completion ?x) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "have C: \"\\<exists>y \\<in> k. dist (to_Gromov_completion y) x < e\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "obtain x1 where x1: \"dist x x1 < e/2\" \"x1 \\<in> range to_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>dist x x1 < e / 2;\n         x1 \\<in> range to_Gromov_completion\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using to_Gromov_completion_range_dense \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  closure (range to_Gromov_completion) = UNIV\n  0 < e\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>dist x x1 < e / 2;\n         x1 \\<in> range to_Gromov_completion\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, hide_lams) UNIV_I closure_approachableD divide_pos_pos zero_less_numeral)"], ["proof (state)\nthis:\n  dist x x1 < e / 2\n  x1 \\<in> range to_Gromov_completion\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "then"], ["proof (chain)\npicking this:\n  dist x x1 < e / 2\n  x1 \\<in> range to_Gromov_completion", "obtain z where z: \"x1 = to_Gromov_completion z\""], ["proof (prove)\nusing this:\n  dist x x1 < e / 2\n  x1 \\<in> range to_Gromov_completion\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        x1 = to_Gromov_completion z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x1 = to_Gromov_completion z\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "then"], ["proof (chain)\npicking this:\n  x1 = to_Gromov_completion z", "obtain y where y: \"y \\<in> k\" \"dist (to_Gromov_completion y) (to_Gromov_completion z) \\<le> e/2\""], ["proof (prove)\nusing this:\n  x1 = to_Gromov_completion z\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> k;\n         dist (to_Gromov_completion y) (to_Gromov_completion z)\n         \\<le> e / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using B"], ["proof (prove)\nusing this:\n  x1 = to_Gromov_completion z\n  \\<exists>y\\<in>k.\n     dist (to_Gromov_completion y) (to_Gromov_completion ?x) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> k;\n         dist (to_Gromov_completion y) (to_Gromov_completion z)\n         \\<le> e / 2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> k\n  dist (to_Gromov_completion y) (to_Gromov_completion z) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "have \"dist (to_Gromov_completion y) x \\<le>\n              dist (to_Gromov_completion y) (to_Gromov_completion z) + dist x x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion y) x\n    \\<le> dist (to_Gromov_completion y) (to_Gromov_completion z) + dist x x1", "unfolding z"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion y) x\n    \\<le> dist (to_Gromov_completion y) (to_Gromov_completion z) +\n          dist x (to_Gromov_completion z)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (to_Gromov_completion y) x\n  \\<le> dist (to_Gromov_completion y) (to_Gromov_completion z) + dist x x1\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "also"], ["proof (state)\nthis:\n  dist (to_Gromov_completion y) x\n  \\<le> dist (to_Gromov_completion y) (to_Gromov_completion z) + dist x x1\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "have \"... < e/2 + e/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion y) (to_Gromov_completion z) + dist x x1\n    < e / 2 + e / 2", "using x1(1) y(2)"], ["proof (prove)\nusing this:\n  dist x x1 < e / 2\n  dist (to_Gromov_completion y) (to_Gromov_completion z) \\<le> e / 2\n\ngoal (1 subgoal):\n 1. dist (to_Gromov_completion y) (to_Gromov_completion z) + dist x x1\n    < e / 2 + e / 2", "by auto"], ["proof (state)\nthis:\n  dist (to_Gromov_completion y) (to_Gromov_completion z) + dist x x1\n  < e / 2 + e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "also"], ["proof (state)\nthis:\n  dist (to_Gromov_completion y) (to_Gromov_completion z) + dist x x1\n  < e / 2 + e / 2\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "have \"... = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e / 2 + e / 2 = e", "by auto"], ["proof (state)\nthis:\n  e / 2 + e / 2 = e\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "finally"], ["proof (chain)\npicking this:\n  dist (to_Gromov_completion y) x < e", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion y) x < e\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "using \\<open>y \\<in> k\\<close>"], ["proof (prove)\nusing this:\n  dist (to_Gromov_completion y) x < e\n  y \\<in> k\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>k. dist (to_Gromov_completion y) x < e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y\\<in>k. dist (to_Gromov_completion y) ?x < e\n\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)", "apply (rule exI[of _ \"to_Gromov_completion`k\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (to_Gromov_completion ` k) \\<and>\n    UNIV \\<subseteq> (\\<Union>x\\<in>to_Gromov_completion ` k. ball x e)", "using C \\<open>finite k\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>y\\<in>k. dist (to_Gromov_completion y) ?x < e\n  finite k\n\ngoal (1 subgoal):\n 1. finite (to_Gromov_completion ` k) \\<and>\n    UNIV \\<subseteq> (\\<Union>x\\<in>to_Gromov_completion ` k. ball x e)", "by auto"], ["proof (state)\nthis:\n  \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x ?e)\n\ngoal (1 subgoal):\n 1. compact UNIV", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x ?e)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x ?e)\n\ngoal (1 subgoal):\n 1. compact UNIV", "unfolding compact_eq_totally_bounded"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x ?e)\n\ngoal (1 subgoal):\n 1. complete UNIV \\<and>\n    (\\<forall>e>0.\n        \\<exists>k.\n           finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e))", "using Gromov_completion_complete[OF complete_of_proper[OF assms]]"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow>\n  \\<exists>k. finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x ?e)\n  complete UNIV\n\ngoal (1 subgoal):\n 1. complete UNIV \\<and>\n    (\\<forall>e>0.\n        \\<exists>k.\n           finite k \\<and> UNIV \\<subseteq> (\\<Union>x\\<in>k. ball x e))", "by auto"], ["proof (state)\nthis:\n  compact UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If the inner space is second countable, so is its completion, as the former is dense in the\nlatter.\\<close>"], ["", "instance Gromov_completion::(\"{Gromov_hyperbolic_space, second_countable_topology}\") second_countable_topology"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Gromov_completion, second_countable_topology_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "obtain A::\"'a set\" where \"countable A\" \"closure A = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>countable A; closure A = UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using second_countable_metric_dense_subset"], ["proof (prove)\nusing this:\n  \\<exists>A. countable A \\<and> closure A = UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>countable A; closure A = UNIV\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  countable A\n  closure A = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "define Ab where \"Ab = to_Gromov_completion`A\""], ["proof (state)\nthis:\n  Ab = to_Gromov_completion ` A\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "have \"range to_Gromov_completion \\<subseteq> closure Ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range to_Gromov_completion \\<subseteq> closure Ab", "unfolding Ab_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range to_Gromov_completion\n    \\<subseteq> closure (to_Gromov_completion ` A)", "by (metis \\<open>closure A = UNIV\\<close> closed_closure closure_subset image_closure_subset to_Gromov_completion_continuous)"], ["proof (state)\nthis:\n  range to_Gromov_completion \\<subseteq> closure Ab\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "then"], ["proof (chain)\npicking this:\n  range to_Gromov_completion \\<subseteq> closure Ab", "have \"closure Ab = UNIV\""], ["proof (prove)\nusing this:\n  range to_Gromov_completion \\<subseteq> closure Ab\n\ngoal (1 subgoal):\n 1. closure Ab = UNIV", "by (metis closed_closure closure_minimal dual_order.antisym to_Gromov_completion_range_dense top_greatest)"], ["proof (state)\nthis:\n  closure Ab = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "moreover"], ["proof (state)\nthis:\n  closure Ab = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "have \"countable Ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable Ab", "unfolding Ab_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (to_Gromov_completion ` A)", "using \\<open>countable A\\<close>"], ["proof (prove)\nusing this:\n  countable A\n\ngoal (1 subgoal):\n 1. countable (to_Gromov_completion ` A)", "by auto"], ["proof (state)\nthis:\n  countable Ab\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "ultimately"], ["proof (chain)\npicking this:\n  closure Ab = UNIV\n  countable Ab", "have \"\\<exists>Ab::'a Gromov_completion set. countable Ab \\<and> closure Ab = UNIV\""], ["proof (prove)\nusing this:\n  closure Ab = UNIV\n  countable Ab\n\ngoal (1 subgoal):\n 1. \\<exists>Ab. countable Ab \\<and> closure Ab = UNIV", "by auto"], ["proof (state)\nthis:\n  \\<exists>Ab. countable Ab \\<and> closure Ab = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "then"], ["proof (chain)\npicking this:\n  \\<exists>Ab. countable Ab \\<and> closure Ab = UNIV", "show \"\\<exists>B::'a Gromov_completion set set. countable B \\<and> open = generate_topology B\""], ["proof (prove)\nusing this:\n  \\<exists>Ab. countable Ab \\<and> closure Ab = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "using second_countable_iff_dense_countable_subset topological_basis_imp_subbasis"], ["proof (prove)\nusing this:\n  \\<exists>Ab. countable Ab \\<and> closure Ab = UNIV\n  (\\<exists>B. countable B \\<and> topological_basis B) =\n  (\\<exists>A. countable A \\<and> closure A = UNIV)\n  topological_basis ?B \\<Longrightarrow> open = generate_topology ?B\n\ngoal (1 subgoal):\n 1. \\<exists>B. countable B \\<and> open = generate_topology B", "by auto"], ["proof (state)\nthis:\n  \\<exists>B. countable B \\<and> open = generate_topology B\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The same follows readily for the Polish space property.\\<close>"], ["", "instance metric_completion::(\"{Gromov_hyperbolic_space, polish_space}\") polish_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a metric_completion, polish_space_class)", "by standard"], ["", "subsection \\<open>The Gromov completion of the real line.\\<close>"], ["", "text \\<open>We show in the paragraph that the Gromov completion of the real line is obtained by adding\none point at $+\\infty$ and one point at $-\\infty$. In other words, it coincides with ereal.\n\nTo show this, we have to understand which sequences of reals are Gromov-converging to the\nboundary. We show in the next lemma that they are exactly the sequences that converge to $-\\infty$\nor to $+\\infty$.\\<close>"], ["", "lemma real_Gromov_converging_to_boundary:\n  fixes u::\"nat \\<Rightarrow> real\"\n  shows \"Gromov_converging_at_boundary u \\<longleftrightarrow> ((u \\<longlonglongrightarrow> \\<infinity>) \\<or> (u \\<longlonglongrightarrow> - \\<infinity>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u =\n    ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n     (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u =\n    ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n     (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)", "have *: \"Gromov_product_at 0 m n \\<ge> min m n\" for m n::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. min m n \\<le> Gromov_product_at 0 m n", "unfolding Gromov_product_at_def dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min m n\n    \\<le> (\\<bar>0 - m\\<bar> + \\<bar>0 - n\\<bar> - \\<bar>m - n\\<bar>) / 2", "by auto"], ["proof (state)\nthis:\n  min ?m ?n \\<le> Gromov_product_at 0 ?m ?n\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u =\n    ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n     (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)", "have A: \"Gromov_converging_at_boundary u\" if \"u \\<longlonglongrightarrow> \\<infinity>\" for u::\"nat \\<Rightarrow> real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "proof (rule Gromov_converging_at_boundaryI[of 0])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "fix M::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "have \"eventually (\\<lambda>n. ereal (u n) > M) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. ereal M < ereal (u n)", "by (rule order_tendstoD(1)[OF \\<open>u \\<longlonglongrightarrow> \\<infinity>\\<close>, of \"ereal M\"], auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. ereal M < ereal (u n)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially. ereal M < ereal (u n)", "obtain N where \"\\<And>n. n \\<ge> N \\<Longrightarrow> ereal (u n) > M\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. ereal M < ereal (u n)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            ereal M < ereal (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. ereal M < ereal (u n)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            ereal M < ereal (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<le> ?n \\<Longrightarrow> ereal M < ereal (u ?n)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  N \\<le> ?n \\<Longrightarrow> ereal M < ereal (u ?n)", "have A: \"u n \\<ge> M\" if \"n \\<ge> N\" for n"], ["proof (prove)\nusing this:\n  N \\<le> ?n \\<Longrightarrow> ereal M < ereal (u ?n)\n\ngoal (1 subgoal):\n 1. M \\<le> u n", "by (simp add: less_imp_le that)"], ["proof (state)\nthis:\n  N \\<le> ?n \\<Longrightarrow> M \\<le> u ?n\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "have \"M \\<le> Gromov_product_at 0 (u m) (u n)\" if \"n \\<ge> N\" \"m \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at 0 (u m) (u n)", "using A[OF \\<open>m \\<ge> N\\<close>] A[OF \\<open>n \\<ge> N\\<close>] *[of \"u m\" \"u n\"]"], ["proof (prove)\nusing this:\n  M \\<le> u m\n  M \\<le> u n\n  min (u m) (u n) \\<le> Gromov_product_at 0 (u m) (u n)\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at 0 (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at 0 (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at 0 (u ?m) (u ?n)", "show \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. M \\<le> Gromov_product_at 0 (u m) (u n)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at 0 (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (?u x))\n  \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n  Gromov_converging_at_boundary ?u\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u =\n    ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n     (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)", "have *: \"Gromov_product_at 0 m n \\<ge> - max m n\" for m n::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. - max m n \\<le> Gromov_product_at 0 m n", "unfolding Gromov_product_at_def dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - max m n\n    \\<le> (\\<bar>0 - m\\<bar> + \\<bar>0 - n\\<bar> - \\<bar>m - n\\<bar>) / 2", "by auto"], ["proof (state)\nthis:\n  - max ?m ?n \\<le> Gromov_product_at 0 ?m ?n\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u =\n    ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n     (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)", "have B: \"Gromov_converging_at_boundary u\" if \"u \\<longlonglongrightarrow> -\\<infinity>\" for u::\"nat \\<Rightarrow> real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "proof (rule Gromov_converging_at_boundaryI[of 0])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "fix M::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "have \"eventually (\\<lambda>n. ereal (u n) < - M) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. ereal (u n) < ereal (- M)", "by (rule order_tendstoD(2)[OF \\<open>u \\<longlonglongrightarrow> -\\<infinity>\\<close>, of \"ereal (-M)\"], auto)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. ereal (u n) < ereal (- M)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F n in sequentially. ereal (u n) < ereal (- M)", "obtain N where \"\\<And>n. n \\<ge> N \\<Longrightarrow> ereal (u n) < - M\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. ereal (u n) < ereal (- M)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            ereal (u n) < ereal (- M)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N. \\<forall>n\\<ge>N. ereal (u n) < ereal (- M)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>n.\n            N \\<le> n \\<Longrightarrow>\n            ereal (u n) < ereal (- M)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<le> ?n \\<Longrightarrow> ereal (u ?n) < ereal (- M)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  N \\<le> ?n \\<Longrightarrow> ereal (u ?n) < ereal (- M)", "have A: \"u n \\<le> - M\" if \"n \\<ge> N\" for n"], ["proof (prove)\nusing this:\n  N \\<le> ?n \\<Longrightarrow> ereal (u ?n) < ereal (- M)\n\ngoal (1 subgoal):\n 1. u n \\<le> - M", "by (simp add: less_imp_le that)"], ["proof (state)\nthis:\n  N \\<le> ?n \\<Longrightarrow> u ?n \\<le> - M\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "have \"M \\<le> Gromov_product_at 0 (u m) (u n)\" if \"n \\<ge> N\" \"m \\<ge> N\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at 0 (u m) (u n)", "using A[OF \\<open>m \\<ge> N\\<close>] A[OF \\<open>n \\<ge> N\\<close>] *[of \"u m\" \"u n\"]"], ["proof (prove)\nusing this:\n  u m \\<le> - M\n  u n \\<le> - M\n  - max (u m) (u n) \\<le> Gromov_product_at 0 (u m) (u n)\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at 0 (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at 0 (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at 0 (u ?m) (u ?n)", "show \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. M \\<le> Gromov_product_at 0 (u m) (u n)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>N \\<le> ?n; N \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> M \\<le> Gromov_product_at 0 (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)", "by auto"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. M \\<le> Gromov_product_at 0 (u m) (u n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (?u x))\n  \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n  Gromov_converging_at_boundary ?u\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u =\n    ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n     (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)", "have L: \"(u \\<longlonglongrightarrow> \\<infinity>) \\<or> (u \\<longlonglongrightarrow> - \\<infinity>)\" if \"Gromov_converging_at_boundary u\" for u::\"nat \\<Rightarrow> real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "have \"(\\<lambda>n. abs(u n)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal \\<bar>u x\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "using Gromov_converging_at_boundary_imp_unbounded[OF that, of 0]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (dist 0 (u x))) \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal \\<bar>u x\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal \\<bar>0 - u x\\<bar>)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal \\<bar>u x\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal \\<bar>u x\\<bar>) \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "obtain r where r: \"strict_mono r\" \"(\\<lambda>n. ereal (u (r n))) \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal(u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         (\\<lambda>n. ereal (u (r n)))\n         \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal (u n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using liminf_subseq_lim[of \"\\<lambda>n. ereal(u n)\"]"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     strict_mono r \\<and>\n     ((\\<lambda>n. ereal (u n)) \\<circ> r)\n     \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal (u n))\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         (\\<lambda>n. ereal (u (r n)))\n         \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal (u n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding comp_def"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     strict_mono r \\<and>\n     (\\<lambda>x. ereal (u (r x)))\n     \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal (u n))\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         (\\<lambda>n. ereal (u (r n)))\n         \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal (u n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  strict_mono r\n  (\\<lambda>n. ereal (u (r n)))\n  \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "have \"(\\<lambda>n. abs(ereal (u (r n)))) \\<longlonglongrightarrow> abs(liminf (\\<lambda>n. ereal(u n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n    \\<longlonglongrightarrow> \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar>", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (u (r n)))\n    \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal (u n))", "using r(2)"], ["proof (prove)\nusing this:\n  (\\<lambda>n. ereal (u (r n)))\n  \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (u (r n)))\n    \\<longlonglongrightarrow> liminf (\\<lambda>n. ereal (u n))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "have \"(\\<lambda>n. abs(ereal (u (r n)))) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "using \\<open>(\\<lambda>n. abs(u n)) \\<longlonglongrightarrow> \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal \\<bar>u x\\<bar>) \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal \\<bar>u x\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. ereal \\<bar>u (r n)\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "using filterlim_compose filterlim_subseq[OF r(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>filterlim ?g ?F3.0 ?F2.0; filterlim ?f ?F2.0 ?F1.0\\<rbrakk>\n  \\<Longrightarrow> LIM x ?F1.0. ?g (?f x) :> ?F3.0\n  filterlim r sequentially sequentially\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal \\<bar>u x\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. ereal \\<bar>u (r n)\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar>\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<infinity>", "have A: \"abs(liminf (\\<lambda>n. ereal(u n))) = \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar>\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar> = \\<infinity>", "using LIMSEQ_unique"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar>\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<infinity>\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?a;\n   ?X \\<longlonglongrightarrow> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar> = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar> = \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "obtain r where r: \"strict_mono r\" \"(\\<lambda>n. ereal (u (r n))) \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal(u n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         (\\<lambda>n. ereal (u (r n)))\n         \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal (u n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using limsup_subseq_lim[of \"\\<lambda>n. ereal(u n)\"]"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     strict_mono r \\<and>\n     ((\\<lambda>n. ereal (u n)) \\<circ> r)\n     \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal (u n))\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         (\\<lambda>n. ereal (u (r n)))\n         \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal (u n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding comp_def"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     strict_mono r \\<and>\n     (\\<lambda>x. ereal (u (r x)))\n     \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal (u n))\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_mono r;\n         (\\<lambda>n. ereal (u (r n)))\n         \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal (u n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  strict_mono r\n  (\\<lambda>n. ereal (u (r n)))\n  \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "have \"(\\<lambda>n. abs(ereal (u (r n)))) \\<longlonglongrightarrow> abs(limsup (\\<lambda>n. ereal(u n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n    \\<longlonglongrightarrow> \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar>", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (u (r n)))\n    \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal (u n))", "using r(2)"], ["proof (prove)\nusing this:\n  (\\<lambda>n. ereal (u (r n)))\n  \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal (u n))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (u (r n)))\n    \\<longlonglongrightarrow> limsup (\\<lambda>n. ereal (u n))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "have \"(\\<lambda>n. abs(ereal (u (r n)))) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "using \\<open>(\\<lambda>n. abs(u n)) \\<longlonglongrightarrow> \\<infinity>\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal \\<bar>u x\\<bar>) \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal \\<bar>u x\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. ereal \\<bar>u (r n)\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "using filterlim_compose filterlim_subseq[OF r(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>filterlim ?g ?F3.0 ?F2.0; filterlim ?f ?F2.0 ?F1.0\\<rbrakk>\n  \\<Longrightarrow> LIM x ?F1.0. ?g (?f x) :> ?F3.0\n  filterlim r sequentially sequentially\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal \\<bar>u x\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. ereal \\<bar>u (r n)\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar>\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<infinity>", "have B: \"abs(limsup (\\<lambda>n. ereal(u n))) = \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar>\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar> = \\<infinity>", "using LIMSEQ_unique"], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar>\n  (\\<lambda>n. \\<bar>ereal (u (r n))\\<bar>)\n  \\<longlonglongrightarrow> \\<infinity>\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?a;\n   ?X \\<longlonglongrightarrow> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar> = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar> = \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "have \"\\<not>(liminf u = - \\<infinity> \\<and> limsup u = \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (liminf (\\<lambda>x. ereal (u x)) = - \\<infinity> \\<and>\n            limsup (\\<lambda>x. ereal (u x)) = \\<infinity>)", "proof (rule ccontr, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>;\n     limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"liminf u = -\\<infinity>\" \"limsup u = \\<infinity>\""], ["proof (state)\nthis:\n  liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>\n  limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>;\n     limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<exists>N. \\<forall>n \\<ge> N. \\<forall>m \\<ge> N. Gromov_product_at 0 (u m) (u n) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. 1 \\<le> Gromov_product_at 0 (u m) (u n)", "using that"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. 1 \\<le> Gromov_product_at 0 (u m) (u n)", "unfolding Gromov_converging_at_boundary_def"], ["proof (prove)\nusing this:\n  \\<forall>a M.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<forall>m\\<ge>N. M \\<le> Gromov_product_at a (u m) (u n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          \\<forall>m\\<ge>N. 1 \\<le> Gromov_product_at 0 (u m) (u n)", "by blast"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. 1 \\<le> Gromov_product_at 0 (u m) (u n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>;\n     limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. 1 \\<le> Gromov_product_at 0 (u m) (u n)", "obtain N where N: \"\\<And>m n. m \\<ge> N \\<Longrightarrow> n \\<ge> N \\<Longrightarrow> Gromov_product_at 0 (u m) (u n) \\<ge> 1\""], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        \\<forall>m\\<ge>N. 1 \\<le> Gromov_product_at 0 (u m) (u n)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>m n.\n            \\<lbrakk>N \\<le> m; N \\<le> n\\<rbrakk>\n            \\<Longrightarrow> 1 \\<le> Gromov_product_at 0 (u m)\n (u n)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>N \\<le> ?m; N \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> Gromov_product_at 0 (u ?m) (u ?n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>;\n     limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<exists>n \\<ge> N. ereal(u n) > ereal 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>N. ereal 0 < ereal (u n)", "apply (rule limsup_obtain)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal 0 < limsup (\\<lambda>n. ereal (u n))", "unfolding \\<open>limsup u = \\<infinity>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal 0 < \\<infinity>", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<ge>N. ereal 0 < ereal (u n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>;\n     limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>n\\<ge>N. ereal 0 < ereal (u n)", "obtain n where n: \"n \\<ge> N\" \"u n > 0\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<ge>N. ereal 0 < ereal (u n)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>N \\<le> n; 0 < u n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<le> n\n  0 < u n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>;\n     limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<exists>n \\<ge> N. ereal(u n) < ereal 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>N. ereal (u n) < ereal 0", "apply (rule liminf_obtain)"], ["proof (prove)\ngoal (1 subgoal):\n 1. liminf (\\<lambda>n. ereal (u n)) < ereal 0", "unfolding \\<open>liminf u = -\\<infinity>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<infinity> < ereal 0", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<ge>N. ereal (u n) < ereal 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>;\n     limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>n\\<ge>N. ereal (u n) < ereal 0", "obtain m where m: \"m \\<ge> N\" \"u m < 0\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<ge>N. ereal (u n) < ereal 0\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>N \\<le> m; u m < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<le> m\n  u m < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>;\n     limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"Gromov_product_at 0 (u m) (u n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at 0 (u m) (u n) = 0", "unfolding Gromov_product_at_def dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>0 - u m\\<bar> + \\<bar>0 - u n\\<bar> - \\<bar>u m - u n\\<bar>) /\n    2 =\n    0", "using m n"], ["proof (prove)\nusing this:\n  N \\<le> m\n  u m < 0\n  N \\<le> n\n  0 < u n\n\ngoal (1 subgoal):\n 1. (\\<bar>0 - u m\\<bar> + \\<bar>0 - u n\\<bar> - \\<bar>u m - u n\\<bar>) /\n    2 =\n    0", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at 0 (u m) (u n) = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>liminf (\\<lambda>x. ereal (u x)) = - \\<infinity>;\n     limsup (\\<lambda>x. ereal (u x)) = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Gromov_product_at 0 (u m) (u n) = 0", "show False"], ["proof (prove)\nusing this:\n  Gromov_product_at 0 (u m) (u n) = 0\n\ngoal (1 subgoal):\n 1. False", "using N[OF m(1) n(1)]"], ["proof (prove)\nusing this:\n  Gromov_product_at 0 (u m) (u n) = 0\n  1 \\<le> Gromov_product_at 0 (u m) (u n)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (liminf (\\<lambda>x. ereal (u x)) = - \\<infinity> \\<and>\n          limsup (\\<lambda>x. ereal (u x)) = \\<infinity>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "then"], ["proof (chain)\npicking this:\n  \\<not> (liminf (\\<lambda>x. ereal (u x)) = - \\<infinity> \\<and>\n          limsup (\\<lambda>x. ereal (u x)) = \\<infinity>)", "have \"liminf u = \\<infinity> \\<or> limsup u = - \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<not> (liminf (\\<lambda>x. ereal (u x)) = - \\<infinity> \\<and>\n          limsup (\\<lambda>x. ereal (u x)) = \\<infinity>)\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>x. ereal (u x)) = \\<infinity> \\<or>\n    limsup (\\<lambda>x. ereal (u x)) = - \\<infinity>", "using A B"], ["proof (prove)\nusing this:\n  \\<not> (liminf (\\<lambda>x. ereal (u x)) = - \\<infinity> \\<and>\n          limsup (\\<lambda>x. ereal (u x)) = \\<infinity>)\n  \\<bar>liminf (\\<lambda>n. ereal (u n))\\<bar> = \\<infinity>\n  \\<bar>limsup (\\<lambda>n. ereal (u n))\\<bar> = \\<infinity>\n\ngoal (1 subgoal):\n 1. liminf (\\<lambda>x. ereal (u x)) = \\<infinity> \\<or>\n    limsup (\\<lambda>x. ereal (u x)) = - \\<infinity>", "by auto"], ["proof (state)\nthis:\n  liminf (\\<lambda>x. ereal (u x)) = \\<infinity> \\<or>\n  limsup (\\<lambda>x. ereal (u x)) = - \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "then"], ["proof (chain)\npicking this:\n  liminf (\\<lambda>x. ereal (u x)) = \\<infinity> \\<or>\n  limsup (\\<lambda>x. ereal (u x)) = - \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  liminf (\\<lambda>x. ereal (u x)) = \\<infinity> \\<or>\n  limsup (\\<lambda>x. ereal (u x)) = - \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "by (simp add: Liminf_PInfty Limsup_MInfty)"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary ?u \\<Longrightarrow>\n  (\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n  (\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> - \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u =\n    ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n     (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u =\n    ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n     (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)", "using L A B"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary ?u \\<Longrightarrow>\n  (\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n  (\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> - \\<infinity>\n  (\\<lambda>x. ereal (?u x))\n  \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n  Gromov_converging_at_boundary ?u\n  (\\<lambda>x. ereal (?u x))\n  \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n  Gromov_converging_at_boundary ?u\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u =\n    ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n     (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u =\n  ((\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n   (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>There is one single point at infinity in the Gromov completion of reals, i.e., two\nsequences tending to infinity are equivalent.\\<close>"], ["", "lemma real_Gromov_completion_rel_PInf:\n  fixes u v::\"nat \\<Rightarrow> real\"\n  assumes \"u \\<longlonglongrightarrow> \\<infinity>\" \"v \\<longlonglongrightarrow> \\<infinity>\"\n  shows \"Gromov_completion_rel u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "have *: \"Gromov_product_at 0 m n \\<ge> min m n\" for m n::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. min m n \\<le> Gromov_product_at 0 m n", "unfolding Gromov_product_at_def dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min m n\n    \\<le> (\\<bar>0 - m\\<bar> + \\<bar>0 - n\\<bar> - \\<bar>m - n\\<bar>) / 2", "by auto"], ["proof (state)\nthis:\n  min ?m ?n \\<le> Gromov_product_at 0 ?m ?n\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "have **: \"Gromov_product_at a m n \\<ge> min m n - abs a\" for m n a::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. min m n - \\<bar>a\\<bar> \\<le> Gromov_product_at a m n", "using Gromov_product_at_diff1[of 0 m n a] *[of m n]"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at 0 m n - Gromov_product_at a m n\\<bar>\n  \\<le> dist 0 a\n  min m n \\<le> Gromov_product_at 0 m n\n\ngoal (1 subgoal):\n 1. min m n - \\<bar>a\\<bar> \\<le> Gromov_product_at a m n", "by auto"], ["proof (state)\nthis:\n  min ?m ?n - \\<bar>?a\\<bar> \\<le> Gromov_product_at ?a ?m ?n\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "have \"(\\<lambda>n. Gromov_product_at a (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "proof (rule tendsto_sandwich[of \"\\<lambda>n. min (u n) (v n) - abs a\" _ _ \"\\<lambda>n. \\<infinity>\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (min (u n) (v n) - \\<bar>a\\<bar>)\n       \\<le> ereal (Gromov_product_at a (u n) (v n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 3. (\\<lambda>x. ereal (min (u x) (v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "have \"ereal (min (u n) (v n) - \\<bar>a\\<bar>) \\<le> ereal (Gromov_product_at a (u n) (v n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (min (u n) (v n) - \\<bar>a\\<bar>)\n    \\<le> ereal (Gromov_product_at a (u n) (v n))", "using **[of \"u n\" \"v n\" a]"], ["proof (prove)\nusing this:\n  min (u n) (v n) - \\<bar>a\\<bar> \\<le> Gromov_product_at a (u n) (v n)\n\ngoal (1 subgoal):\n 1. ereal (min (u n) (v n) - \\<bar>a\\<bar>)\n    \\<le> ereal (Gromov_product_at a (u n) (v n))", "by auto"], ["proof (state)\nthis:\n  ereal (min (u ?n) (v ?n) - \\<bar>a\\<bar>)\n  \\<le> ereal (Gromov_product_at a (u ?n) (v ?n))\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (min (u n) (v n) - \\<bar>a\\<bar>)\n       \\<le> ereal (Gromov_product_at a (u n) (v n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 3. (\\<lambda>x. ereal (min (u x) (v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  ereal (min (u ?n) (v ?n) - \\<bar>a\\<bar>)\n  \\<le> ereal (Gromov_product_at a (u ?n) (v ?n))", "show \"\\<forall>\\<^sub>F n in sequentially. ereal (min (u n) (v n) - \\<bar>a\\<bar>) \\<le> ereal (Gromov_product_at a (u n) (v n))\""], ["proof (prove)\nusing this:\n  ereal (min (u ?n) (v ?n) - \\<bar>a\\<bar>)\n  \\<le> ereal (Gromov_product_at a (u ?n) (v ?n))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (min (u n) (v n) - \\<bar>a\\<bar>)\n       \\<le> ereal (Gromov_product_at a (u n) (v n))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     ereal (min (u n) (v n) - \\<bar>a\\<bar>)\n     \\<le> ereal (Gromov_product_at a (u n) (v n))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 2. (\\<lambda>x. ereal (min (u x) (v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "have \"(\\<lambda>x. min (ereal(u x)) (ereal (v x)) - ereal \\<bar>a\\<bar>) \\<longlonglongrightarrow> min \\<infinity> \\<infinity> - ereal \\<bar>a\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. min (ereal (u x)) (ereal (v x)) - ereal \\<bar>a\\<bar>)\n    \\<longlonglongrightarrow> min \\<infinity> \\<infinity> -\n                              ereal \\<bar>a\\<bar>", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity>\n 2. (\\<lambda>x. ereal (v x)) \\<longlonglongrightarrow> \\<infinity>\n 3. \\<not> (min \\<infinity> \\<infinity> = \\<infinity> \\<and>\n            ereal \\<bar>a\\<bar> = \\<infinity> \\<or>\n            min \\<infinity> \\<infinity> = - \\<infinity> \\<and>\n            ereal \\<bar>a\\<bar> = - \\<infinity>)", "using assms"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity>\n  (\\<lambda>x. ereal (v x)) \\<longlonglongrightarrow> \\<infinity>\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity>\n 2. (\\<lambda>x. ereal (v x)) \\<longlonglongrightarrow> \\<infinity>\n 3. \\<not> (min \\<infinity> \\<infinity> = \\<infinity> \\<and>\n            ereal \\<bar>a\\<bar> = \\<infinity> \\<or>\n            min \\<infinity> \\<infinity> = - \\<infinity> \\<and>\n            ereal \\<bar>a\\<bar> = - \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. min (ereal (u x)) (ereal (v x)) - ereal \\<bar>a\\<bar>)\n  \\<longlonglongrightarrow> min \\<infinity> \\<infinity> -\n                            ereal \\<bar>a\\<bar>\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 2. (\\<lambda>x. ereal (min (u x) (v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. min (ereal (u x)) (ereal (v x)) - ereal \\<bar>a\\<bar>)\n  \\<longlonglongrightarrow> min \\<infinity> \\<infinity> -\n                            ereal \\<bar>a\\<bar>", "show \"(\\<lambda>x. ereal (min (u x) (v x) - \\<bar>a\\<bar>)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. min (ereal (u x)) (ereal (v x)) - ereal \\<bar>a\\<bar>)\n  \\<longlonglongrightarrow> min \\<infinity> \\<infinity> -\n                            ereal \\<bar>a\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (min (u x) (v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. min (ereal (u x)) (ereal (v x)) - ereal \\<bar>a\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<lambda>x. ereal (min (u x) (v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding ereal_minus(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. min (ereal (u x)) (ereal (v x)) - ereal \\<bar>a\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<lambda>x. ereal (min (u x) (v x)) - ereal \\<bar>a\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (min (u x) (v x) - \\<bar>a\\<bar>))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 2. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "qed (auto)"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "have \"Gromov_converging_at_boundary u\" \"Gromov_converging_at_boundary v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u &&& Gromov_converging_at_boundary v", "using real_Gromov_converging_to_boundary assms"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary ?u =\n  ((\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n   (\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> - \\<infinity>)\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity>\n  (\\<lambda>x. ereal (v x)) \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u &&& Gromov_converging_at_boundary v", "by auto"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary v \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>There is one single point at minus infinity in the Gromov completion of reals, i.e., two\nsequences tending to minus infinity are equivalent.\\<close>"], ["", "lemma real_Gromov_completion_rel_MInf:\n  fixes u v::\"nat \\<Rightarrow> real\"\n  assumes \"u \\<longlonglongrightarrow> -\\<infinity>\" \"v \\<longlonglongrightarrow> -\\<infinity>\"\n  shows \"Gromov_completion_rel u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "have *: \"Gromov_product_at 0 m n \\<ge> - max m n\" for m n::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. - max m n \\<le> Gromov_product_at 0 m n", "unfolding Gromov_product_at_def dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - max m n\n    \\<le> (\\<bar>0 - m\\<bar> + \\<bar>0 - n\\<bar> - \\<bar>m - n\\<bar>) / 2", "by auto"], ["proof (state)\nthis:\n  - max ?m ?n \\<le> Gromov_product_at 0 ?m ?n\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "have **: \"Gromov_product_at a m n \\<ge> - max m n - abs a\" for m n a::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. - max m n - \\<bar>a\\<bar> \\<le> Gromov_product_at a m n", "using Gromov_product_at_diff1[of 0 m n a] *[of m n]"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at 0 m n - Gromov_product_at a m n\\<bar>\n  \\<le> dist 0 a\n  - max m n \\<le> Gromov_product_at 0 m n\n\ngoal (1 subgoal):\n 1. - max m n - \\<bar>a\\<bar> \\<le> Gromov_product_at a m n", "by auto"], ["proof (state)\nthis:\n  - max ?m ?n - \\<bar>?a\\<bar> \\<le> Gromov_product_at ?a ?m ?n\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "have \"(\\<lambda>n. Gromov_product_at a (u n) (v n)) \\<longlonglongrightarrow> \\<infinity>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n    \\<longlonglongrightarrow> \\<infinity>", "proof (rule tendsto_sandwich[of \"\\<lambda>n. min (-u n) (-v n) - abs a\" _ _ \"\\<lambda>n. \\<infinity>\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (min (- u n) (- v n) - \\<bar>a\\<bar>)\n       \\<le> ereal (Gromov_product_at a (u n) (v n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 3. (\\<lambda>x. ereal (min (- u x) (- v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "have \"ereal (min (-u n) (-v n) - \\<bar>a\\<bar>) \\<le> ereal (Gromov_product_at a (u n) (v n))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal (min (- u n) (- v n) - \\<bar>a\\<bar>)\n    \\<le> ereal (Gromov_product_at a (u n) (v n))", "using **[of \"u n\" \"v n\" a]"], ["proof (prove)\nusing this:\n  - max (u n) (v n) - \\<bar>a\\<bar> \\<le> Gromov_product_at a (u n) (v n)\n\ngoal (1 subgoal):\n 1. ereal (min (- u n) (- v n) - \\<bar>a\\<bar>)\n    \\<le> ereal (Gromov_product_at a (u n) (v n))", "by auto"], ["proof (state)\nthis:\n  ereal (min (- u ?n) (- v ?n) - \\<bar>a\\<bar>)\n  \\<le> ereal (Gromov_product_at a (u ?n) (v ?n))\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (min (- u n) (- v n) - \\<bar>a\\<bar>)\n       \\<le> ereal (Gromov_product_at a (u n) (v n))\n 2. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 3. (\\<lambda>x. ereal (min (- u x) (- v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>\n 4. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  ereal (min (- u ?n) (- v ?n) - \\<bar>a\\<bar>)\n  \\<le> ereal (Gromov_product_at a (u ?n) (v ?n))", "show \"\\<forall>\\<^sub>F n in sequentially. ereal (min (-u n) (-v n) - \\<bar>a\\<bar>) \\<le> ereal (Gromov_product_at a (u n) (v n))\""], ["proof (prove)\nusing this:\n  ereal (min (- u ?n) (- v ?n) - \\<bar>a\\<bar>)\n  \\<le> ereal (Gromov_product_at a (u ?n) (v ?n))\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (min (- u n) (- v n) - \\<bar>a\\<bar>)\n       \\<le> ereal (Gromov_product_at a (u n) (v n))", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     ereal (min (- u n) (- v n) - \\<bar>a\\<bar>)\n     \\<le> ereal (Gromov_product_at a (u n) (v n))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 2. (\\<lambda>x. ereal (min (- u x) (- v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "have \"(\\<lambda>x. min (-ereal(u x)) (-ereal (v x)) - ereal \\<bar>a\\<bar>) \\<longlonglongrightarrow> min (-(-\\<infinity>)) (-(-\\<infinity>)) - ereal \\<bar>a\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. min (- ereal (u x)) (- ereal (v x)) - ereal \\<bar>a\\<bar>)\n    \\<longlonglongrightarrow> min (- (- \\<infinity>)) (- (- \\<infinity>)) -\n                              ereal \\<bar>a\\<bar>", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>\n 2. (\\<lambda>x. ereal (v x)) \\<longlonglongrightarrow> - \\<infinity>\n 3. \\<not> (min (- (- \\<infinity>)) (- (- \\<infinity>)) = \\<infinity> \\<and>\n            ereal \\<bar>a\\<bar> = \\<infinity> \\<or>\n            min (- (- \\<infinity>)) (- (- \\<infinity>)) =\n            - \\<infinity> \\<and>\n            ereal \\<bar>a\\<bar> = - \\<infinity>)", "using assms"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>\n  (\\<lambda>x. ereal (v x)) \\<longlonglongrightarrow> - \\<infinity>\n\ngoal (3 subgoals):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>\n 2. (\\<lambda>x. ereal (v x)) \\<longlonglongrightarrow> - \\<infinity>\n 3. \\<not> (min (- (- \\<infinity>)) (- (- \\<infinity>)) = \\<infinity> \\<and>\n            ereal \\<bar>a\\<bar> = \\<infinity> \\<or>\n            min (- (- \\<infinity>)) (- (- \\<infinity>)) =\n            - \\<infinity> \\<and>\n            ereal \\<bar>a\\<bar> = - \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. min (- ereal (u x)) (- ereal (v x)) - ereal \\<bar>a\\<bar>)\n  \\<longlonglongrightarrow> min (- (- \\<infinity>)) (- (- \\<infinity>)) -\n                            ereal \\<bar>a\\<bar>\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 2. (\\<lambda>x. ereal (min (- u x) (- v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>\n 3. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. min (- ereal (u x)) (- ereal (v x)) - ereal \\<bar>a\\<bar>)\n  \\<longlonglongrightarrow> min (- (- \\<infinity>)) (- (- \\<infinity>)) -\n                            ereal \\<bar>a\\<bar>", "show \"(\\<lambda>x. ereal (min (-u x) (-v x) - \\<bar>a\\<bar>)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. min (- ereal (u x)) (- ereal (v x)) - ereal \\<bar>a\\<bar>)\n  \\<longlonglongrightarrow> min (- (- \\<infinity>)) (- (- \\<infinity>)) -\n                            ereal \\<bar>a\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (min (- u x) (- v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. min (ereal (- u x)) (ereal (- v x)) - ereal \\<bar>a\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<lambda>x. ereal (min (- u x) (- v x) - \\<bar>a\\<bar>))\n    \\<longlonglongrightarrow> \\<infinity>", "unfolding ereal_minus(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. min (ereal (- u x)) (ereal (- v x)) - ereal \\<bar>a\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    (\\<lambda>x. ereal (min (- u x) (- v x)) - ereal \\<bar>a\\<bar>)\n    \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (min (- u x) (- v x) - \\<bar>a\\<bar>))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       ereal (Gromov_product_at a (u n) (v n)) \\<le> \\<infinity>\n 2. (\\<lambda>n. \\<infinity>) \\<longlonglongrightarrow> \\<infinity>", "qed (auto)"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "have \"Gromov_converging_at_boundary u\" \"Gromov_converging_at_boundary v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u &&& Gromov_converging_at_boundary v", "using real_Gromov_converging_to_boundary assms"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary ?u =\n  ((\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n   (\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> - \\<infinity>)\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>\n  (\\<lambda>x. ereal (v x)) \\<longlonglongrightarrow> - \\<infinity>\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u &&& Gromov_converging_at_boundary v", "by auto"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. Gromov_completion_rel u v", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (Gromov_product_at ?a (u x) (v x)))\n  \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary v\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u \\<and>\n    Gromov_converging_at_boundary v \\<and>\n    (\\<forall>a.\n        (\\<lambda>x. ereal (Gromov_product_at a (u x) (v x)))\n        \\<longlonglongrightarrow> \\<infinity>) \\<or>\n    (\\<forall>n m. u n = v m \\<and> u n = u m \\<and> v n = v m)", "by auto"], ["proof (state)\nthis:\n  Gromov_completion_rel u v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>It follows from the two lemmas above that the Gromov completion of reals is obtained by\nadding one single point at infinity and one single point at minus infinity. Hence, it is in\nbijection with the extended reals.\\<close>"], ["", "function to_real_Gromov_completion::\"ereal \\<Rightarrow> real Gromov_completion\"\n  where \"to_real_Gromov_completion (ereal r) = to_Gromov_completion r\"\n  | \"to_real_Gromov_completion (\\<infinity>) = abs_Gromov_completion (\\<lambda>n. n)\"\n  | \"to_real_Gromov_completion (-\\<infinity>) = abs_Gromov_completion (\\<lambda>n. -n)\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>r. x = ereal r \\<Longrightarrow> P;\n        x = \\<infinity> \\<Longrightarrow> P;\n        x = - \\<infinity> \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>r ra.\n       ereal r = ereal ra \\<Longrightarrow>\n       to_Gromov_completion r = to_Gromov_completion ra\n 3. \\<And>r.\n       ereal r = \\<infinity> \\<Longrightarrow>\n       to_Gromov_completion r = abs_Gromov_completion real\n 4. \\<And>r.\n       ereal r = - \\<infinity> \\<Longrightarrow>\n       to_Gromov_completion r =\n       abs_Gromov_completion (\\<lambda>x. real_of_int (- int x))\n 5. \\<infinity> = \\<infinity> \\<Longrightarrow>\n    abs_Gromov_completion real = abs_Gromov_completion real\n 6. \\<infinity> = - \\<infinity> \\<Longrightarrow>\n    abs_Gromov_completion real =\n    abs_Gromov_completion (\\<lambda>x. real_of_int (- int x))\n 7. - \\<infinity> = - \\<infinity> \\<Longrightarrow>\n    abs_Gromov_completion (\\<lambda>x. real_of_int (- int x)) =\n    abs_Gromov_completion (\\<lambda>x. real_of_int (- int x))", "by (auto intro: ereal_cases)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All to_real_Gromov_completion_dom", "by standard (rule wf_empty)"], ["", "text \\<open>To prove the bijectivity, we prove by hand injectivity and surjectivity using the above\nlemmas.\\<close>"], ["", "lemma bij_to_real_Gromov_completion:\n  \"bij to_real_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "have [simp]: \"Gromov_completion_rel (\\<lambda>n. n) (\\<lambda>n. n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel real real", "by (intro real_Gromov_completion_rel_PInf tendsto_intros)"], ["proof (state)\nthis:\n  Gromov_completion_rel real real\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "have [simp]: \"Gromov_completion_rel (\\<lambda>n. -real n) (\\<lambda>n. -real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. - real n) (\\<lambda>n. - real n)", "by (intro real_Gromov_completion_rel_MInf tendsto_intros)"], ["proof (state)\nthis:\n  Gromov_completion_rel (\\<lambda>n. - real n) (\\<lambda>n. - real n)\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "have \"\\<exists>x. to_real_Gromov_completion x = y\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. to_real_Gromov_completion x = y", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       y = to_Gromov_completion x \\<Longrightarrow>\n       \\<exists>x. to_real_Gromov_completion x = y\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "case (to_Gromov_completion x)"], ["proof (state)\nthis:\n  y = to_Gromov_completion x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       y = to_Gromov_completion x \\<Longrightarrow>\n       \\<exists>x. to_real_Gromov_completion x = y\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "then"], ["proof (chain)\npicking this:\n  y = to_Gromov_completion x", "have \"y = to_real_Gromov_completion x\""], ["proof (prove)\nusing this:\n  y = to_Gromov_completion x\n\ngoal (1 subgoal):\n 1. y = to_real_Gromov_completion (ereal x)", "by auto"], ["proof (state)\nthis:\n  y = to_real_Gromov_completion (ereal x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       y = to_Gromov_completion x \\<Longrightarrow>\n       \\<exists>x. to_real_Gromov_completion x = y\n 2. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "then"], ["proof (chain)\npicking this:\n  y = to_real_Gromov_completion (ereal x)", "show ?thesis"], ["proof (prove)\nusing this:\n  y = to_real_Gromov_completion (ereal x)\n\ngoal (1 subgoal):\n 1. \\<exists>x. to_real_Gromov_completion x = y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. to_real_Gromov_completion x = y\n\ngoal (1 subgoal):\n 1. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "case boundary"], ["proof (state)\nthis:\n  y \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "define u where u: \"u = rep_Gromov_completion y\""], ["proof (state)\nthis:\n  u = rep_Gromov_completion y\n\ngoal (1 subgoal):\n 1. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "have y: \"abs_Gromov_completion u = y\" \"Gromov_completion_rel u u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion u = y &&& Gromov_completion_rel u u", "unfolding u"], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion (rep_Gromov_completion y) = y &&&\n    Gromov_completion_rel (rep_Gromov_completion y)\n     (rep_Gromov_completion y)", "using Quotient3_abs_rep[OF Quotient3_Gromov_completion]\n      Quotient3_rep_reflp[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  abs_Gromov_completion (rep_Gromov_completion ?a) = ?a\n  Gromov_completion_rel (rep_Gromov_completion ?a)\n   (rep_Gromov_completion ?a)\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion (rep_Gromov_completion y) = y &&&\n    Gromov_completion_rel (rep_Gromov_completion y)\n     (rep_Gromov_completion y)", "by auto"], ["proof (state)\nthis:\n  abs_Gromov_completion u = y\n  Gromov_completion_rel u u\n\ngoal (1 subgoal):\n 1. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "have \"Gromov_converging_at_boundary u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "using u boundary"], ["proof (prove)\nusing this:\n  u = rep_Gromov_completion y\n  y \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. Gromov_converging_at_boundary u", "by (simp add: Gromov_boundary_rep_converging)"], ["proof (state)\nthis:\n  Gromov_converging_at_boundary u\n\ngoal (1 subgoal):\n 1. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "then"], ["proof (chain)\npicking this:\n  Gromov_converging_at_boundary u", "have \"(u \\<longlonglongrightarrow> \\<infinity>) \\<or> (u \\<longlonglongrightarrow> - \\<infinity>)\""], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "using real_Gromov_converging_to_boundary"], ["proof (prove)\nusing this:\n  Gromov_converging_at_boundary u\n  Gromov_converging_at_boundary ?u =\n  ((\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n   (\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> - \\<infinity>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n    (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>\n\ngoal (1 subgoal):\n 1. y \\<in> Gromov_boundary \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>x. to_real_Gromov_completion x = y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y\n 2. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "assume \"u \\<longlonglongrightarrow> \\<infinity>\""], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y\n 2. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "have \"abs_Gromov_completion (\\<lambda>n. n) = abs_Gromov_completion u \""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion real = abs_Gromov_completion u", "apply (rule Quotient3_rel_abs[OF Quotient3_Gromov_completion])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel real u", "by (intro real_Gromov_completion_rel_PInf[OF _ \\<open>u \\<longlonglongrightarrow> \\<infinity>\\<close>] tendsto_intros)"], ["proof (state)\nthis:\n  abs_Gromov_completion real = abs_Gromov_completion u\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y\n 2. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion real = abs_Gromov_completion u", "have \"to_real_Gromov_completion \\<infinity> = y\""], ["proof (prove)\nusing this:\n  abs_Gromov_completion real = abs_Gromov_completion u\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> = y", "unfolding y"], ["proof (prove)\nusing this:\n  abs_Gromov_completion real = y\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> = y", "by auto"], ["proof (state)\nthis:\n  to_real_Gromov_completion \\<infinity> = y\n\ngoal (2 subgoals):\n 1. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y\n 2. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "then"], ["proof (chain)\npicking this:\n  to_real_Gromov_completion \\<infinity> = y", "show ?thesis"], ["proof (prove)\nusing this:\n  to_real_Gromov_completion \\<infinity> = y\n\ngoal (1 subgoal):\n 1. \\<exists>x. to_real_Gromov_completion x = y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. to_real_Gromov_completion x = y\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "assume \"u \\<longlonglongrightarrow> -\\<infinity>\""], ["proof (state)\nthis:\n  (\\<lambda>x. ereal (u x)) \\<longlonglongrightarrow> - \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "have \"abs_Gromov_completion (\\<lambda>n. -real n) = abs_Gromov_completion u \""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_Gromov_completion (\\<lambda>n. - real n) = abs_Gromov_completion u", "apply (rule Quotient3_rel_abs[OF Quotient3_Gromov_completion])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. - real n) u", "by (intro real_Gromov_completion_rel_MInf[OF _ \\<open>u \\<longlonglongrightarrow> -\\<infinity>\\<close>] tendsto_intros)"], ["proof (state)\nthis:\n  abs_Gromov_completion (\\<lambda>n. - real n) = abs_Gromov_completion u\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion (\\<lambda>n. - real n) = abs_Gromov_completion u", "have \"to_real_Gromov_completion (-\\<infinity>) = y\""], ["proof (prove)\nusing this:\n  abs_Gromov_completion (\\<lambda>n. - real n) = abs_Gromov_completion u\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion (- \\<infinity>) = y", "unfolding y"], ["proof (prove)\nusing this:\n  abs_Gromov_completion (\\<lambda>n. - real n) = y\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion (- \\<infinity>) = y", "by auto"], ["proof (state)\nthis:\n  to_real_Gromov_completion (- \\<infinity>) = y\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. ereal (u x))\n    \\<longlonglongrightarrow> - \\<infinity> \\<Longrightarrow>\n    \\<exists>x. to_real_Gromov_completion x = y", "then"], ["proof (chain)\npicking this:\n  to_real_Gromov_completion (- \\<infinity>) = y", "show ?thesis"], ["proof (prove)\nusing this:\n  to_real_Gromov_completion (- \\<infinity>) = y\n\ngoal (1 subgoal):\n 1. \\<exists>x. to_real_Gromov_completion x = y", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. to_real_Gromov_completion x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. to_real_Gromov_completion x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. to_real_Gromov_completion x = ?y\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. to_real_Gromov_completion x = ?y", "have \"surj to_real_Gromov_completion\""], ["proof (prove)\nusing this:\n  \\<exists>x. to_real_Gromov_completion x = ?y\n\ngoal (1 subgoal):\n 1. surj to_real_Gromov_completion", "unfolding surj_def"], ["proof (prove)\nusing this:\n  \\<exists>x. to_real_Gromov_completion x = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = to_real_Gromov_completion x", "by metis"], ["proof (state)\nthis:\n  surj to_real_Gromov_completion\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "have \"to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary\"\n       \"to_real_Gromov_completion (-\\<infinity>) \\<in> Gromov_boundary\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary &&&\n    to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary", "by (auto intro!: abs_Gromov_completion_in_Gromov_boundary tendsto_intros simp add: real_Gromov_converging_to_boundary)"], ["proof (state)\nthis:\n  to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary\n  to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "moreover"], ["proof (state)\nthis:\n  to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary\n  to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "have \"to_real_Gromov_completion \\<infinity> \\<noteq> to_real_Gromov_completion (-\\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> \\<noteq>\n    to_real_Gromov_completion (- \\<infinity>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> \\<noteq>\n    to_real_Gromov_completion (- \\<infinity>)", "have \"Gromov_product_at 0 (real n) (-real n) = 0\" for n::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at 0 (real n) (- real n) = 0", "unfolding Gromov_product_at_def dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>0 - real n\\<bar> + \\<bar>0 - - real n\\<bar> -\n     \\<bar>real n - - real n\\<bar>) /\n    2 =\n    0", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at 0 (real ?n) (- real ?n) = 0\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> \\<noteq>\n    to_real_Gromov_completion (- \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  Gromov_product_at 0 (real ?n) (- real ?n) = 0", "have *: \"(\\<lambda>n. ereal(Gromov_product_at 0 (real n) (-real n))) \\<longlonglongrightarrow> ereal 0\""], ["proof (prove)\nusing this:\n  Gromov_product_at 0 (real ?n) (- real ?n) = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (Gromov_product_at 0 (real n) (- real n)))\n    \\<longlonglongrightarrow> ereal 0", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. ereal (Gromov_product_at 0 (real n) (- real n)))\n  \\<longlonglongrightarrow> ereal 0\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> \\<noteq>\n    to_real_Gromov_completion (- \\<infinity>)", "have \"\\<not>((\\<lambda>n. Gromov_product_at 0 (real n) (-real n)) \\<longlonglongrightarrow> \\<infinity>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<lambda>x. ereal (Gromov_product_at 0 (real x) (- real x)))\n           \\<longlonglongrightarrow> \\<infinity>", "using LIMSEQ_unique[OF *]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. ereal (Gromov_product_at 0 (real n) (- real n)))\n  \\<longlonglongrightarrow> ?b \\<Longrightarrow>\n  ereal 0 = ?b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<lambda>x. ereal (Gromov_product_at 0 (real x) (- real x)))\n           \\<longlonglongrightarrow> \\<infinity>", "by fastforce"], ["proof (state)\nthis:\n  \\<not> (\\<lambda>x. ereal (Gromov_product_at 0 (real x) (- real x)))\n         \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> \\<noteq>\n    to_real_Gromov_completion (- \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<lambda>x. ereal (Gromov_product_at 0 (real x) (- real x)))\n         \\<longlonglongrightarrow> \\<infinity>", "have \"\\<not>(Gromov_completion_rel (\\<lambda>n. n) (\\<lambda>n. -n))\""], ["proof (prove)\nusing this:\n  \\<not> (\\<lambda>x. ereal (Gromov_product_at 0 (real x) (- real x)))\n         \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_completion_rel real (\\<lambda>x. real_of_int (- int x))", "unfolding Gromov_completion_rel_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<lambda>x. ereal (Gromov_product_at 0 (real x) (- real x)))\n         \\<longlonglongrightarrow> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> (Gromov_converging_at_boundary real \\<and>\n            Gromov_converging_at_boundary\n             (\\<lambda>x. real_of_int (- int x)) \\<and>\n            (\\<forall>a.\n                (\\<lambda>x.\n                    ereal\n                     (Gromov_product_at a (real x) (real_of_int (- int x))))\n                \\<longlonglongrightarrow> \\<infinity>) \\<or>\n            (\\<forall>n m.\n                real n = real_of_int (- int m) \\<and>\n                real n = real m \\<and>\n                real_of_int (- int n) = real_of_int (- int m)))", "by auto (metis nat.simps(3) of_nat_0 of_nat_eq_0_iff)"], ["proof (state)\nthis:\n  \\<not> Gromov_completion_rel real (\\<lambda>x. real_of_int (- int x))\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> \\<noteq>\n    to_real_Gromov_completion (- \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  \\<not> Gromov_completion_rel real (\\<lambda>x. real_of_int (- int x))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Gromov_completion_rel real (\\<lambda>x. real_of_int (- int x))\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> \\<noteq>\n    to_real_Gromov_completion (- \\<infinity>)", "using Quotient3_rel[OF Quotient3_Gromov_completion, of \"\\<lambda>n. n\" \"\\<lambda>n. -real n\"]"], ["proof (prove)\nusing this:\n  \\<not> Gromov_completion_rel real (\\<lambda>x. real_of_int (- int x))\n  (Gromov_completion_rel real real \\<and>\n   Gromov_completion_rel (\\<lambda>n. - real n)\n    (\\<lambda>n. - real n) \\<and>\n   abs_Gromov_completion real =\n   abs_Gromov_completion (\\<lambda>n. - real n)) =\n  Gromov_completion_rel real (\\<lambda>n. - real n)\n\ngoal (1 subgoal):\n 1. to_real_Gromov_completion \\<infinity> \\<noteq>\n    to_real_Gromov_completion (- \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  to_real_Gromov_completion \\<infinity> \\<noteq>\n  to_real_Gromov_completion (- \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  to_real_Gromov_completion \\<infinity> \\<noteq>\n  to_real_Gromov_completion (- \\<infinity>)\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "ultimately"], ["proof (chain)\npicking this:\n  to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary\n  to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary\n  to_real_Gromov_completion \\<infinity> \\<noteq>\n  to_real_Gromov_completion (- \\<infinity>)", "have \"x = y\" if \"to_real_Gromov_completion x = to_real_Gromov_completion y\" for x y"], ["proof (prove)\nusing this:\n  to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary\n  to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary\n  to_real_Gromov_completion \\<infinity> \\<noteq>\n  to_real_Gromov_completion (- \\<infinity>)\n\ngoal (1 subgoal):\n 1. x = y", "using that injD[OF to_Gromov_completion_inj]"], ["proof (prove)\nusing this:\n  to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary\n  to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary\n  to_real_Gromov_completion \\<infinity> \\<noteq>\n  to_real_Gromov_completion (- \\<infinity>)\n  to_real_Gromov_completion x = to_real_Gromov_completion y\n  to_Gromov_completion ?x = to_Gromov_completion ?y \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. x = y", "apply (cases x y rule: ereal2_cases)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>r ra.\n       \\<lbrakk>to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary;\n        to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary;\n        to_real_Gromov_completion \\<infinity> \\<noteq>\n        to_real_Gromov_completion (- \\<infinity>);\n        to_real_Gromov_completion x = to_real_Gromov_completion y;\n        \\<And>x y.\n           to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n           x = y;\n        x = ereal r; y = ereal ra\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>r.\n       \\<lbrakk>to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary;\n        to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary;\n        to_real_Gromov_completion \\<infinity> \\<noteq>\n        to_real_Gromov_completion (- \\<infinity>);\n        to_real_Gromov_completion x = to_real_Gromov_completion y;\n        \\<And>x y.\n           to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n           x = y;\n        x = ereal r; y = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>r.\n       \\<lbrakk>to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary;\n        to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary;\n        to_real_Gromov_completion \\<infinity> \\<noteq>\n        to_real_Gromov_completion (- \\<infinity>);\n        to_real_Gromov_completion x = to_real_Gromov_completion y;\n        \\<And>x y.\n           to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n           x = y;\n        x = ereal r; y = - \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>r.\n       \\<lbrakk>to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary;\n        to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary;\n        to_real_Gromov_completion \\<infinity> \\<noteq>\n        to_real_Gromov_completion (- \\<infinity>);\n        to_real_Gromov_completion x = to_real_Gromov_completion y;\n        \\<And>x y.\n           to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n           x = y;\n        x = \\<infinity>; y = ereal r\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<lbrakk>to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary;\n     to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary;\n     to_real_Gromov_completion \\<infinity> \\<noteq>\n     to_real_Gromov_completion (- \\<infinity>);\n     to_real_Gromov_completion x = to_real_Gromov_completion y;\n     \\<And>x y.\n        to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n        x = y;\n     x = \\<infinity>; y = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> x = y\n 6. \\<lbrakk>to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary;\n     to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary;\n     to_real_Gromov_completion \\<infinity> \\<noteq>\n     to_real_Gromov_completion (- \\<infinity>);\n     to_real_Gromov_completion x = to_real_Gromov_completion y;\n     \\<And>x y.\n        to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n        x = y;\n     x = \\<infinity>; y = - \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> x = y\n 7. \\<And>r.\n       \\<lbrakk>to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary;\n        to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary;\n        to_real_Gromov_completion \\<infinity> \\<noteq>\n        to_real_Gromov_completion (- \\<infinity>);\n        to_real_Gromov_completion x = to_real_Gromov_completion y;\n        \\<And>x y.\n           to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n           x = y;\n        x = - \\<infinity>; y = ereal r\\<rbrakk>\n       \\<Longrightarrow> x = y\n 8. \\<lbrakk>to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary;\n     to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary;\n     to_real_Gromov_completion \\<infinity> \\<noteq>\n     to_real_Gromov_completion (- \\<infinity>);\n     to_real_Gromov_completion x = to_real_Gromov_completion y;\n     \\<And>x y.\n        to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n        x = y;\n     x = - \\<infinity>; y = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> x = y\n 9. \\<lbrakk>to_real_Gromov_completion \\<infinity> \\<in> Gromov_boundary;\n     to_real_Gromov_completion (- \\<infinity>) \\<in> Gromov_boundary;\n     to_real_Gromov_completion \\<infinity> \\<noteq>\n     to_real_Gromov_completion (- \\<infinity>);\n     to_real_Gromov_completion x = to_real_Gromov_completion y;\n     \\<And>x y.\n        to_Gromov_completion x = to_Gromov_completion y \\<Longrightarrow>\n        x = y;\n     x = - \\<infinity>; y = - \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (auto) (metis not_in_Gromov_boundary')+"], ["proof (state)\nthis:\n  to_real_Gromov_completion ?x =\n  to_real_Gromov_completion ?y \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "then"], ["proof (chain)\npicking this:\n  to_real_Gromov_completion ?x =\n  to_real_Gromov_completion ?y \\<Longrightarrow>\n  ?x = ?y", "have \"inj to_real_Gromov_completion\""], ["proof (prove)\nusing this:\n  to_real_Gromov_completion ?x =\n  to_real_Gromov_completion ?y \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. inj to_real_Gromov_completion", "unfolding inj_def"], ["proof (prove)\nusing this:\n  to_real_Gromov_completion ?x =\n  to_real_Gromov_completion ?y \\<Longrightarrow>\n  ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       to_real_Gromov_completion x =\n       to_real_Gromov_completion y \\<longrightarrow>\n       x = y", "by auto"], ["proof (state)\nthis:\n  inj to_real_Gromov_completion\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "then"], ["proof (chain)\npicking this:\n  inj to_real_Gromov_completion", "show \"bij to_real_Gromov_completion\""], ["proof (prove)\nusing this:\n  inj to_real_Gromov_completion\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "using \\<open>surj to_real_Gromov_completion\\<close>"], ["proof (prove)\nusing this:\n  inj to_real_Gromov_completion\n  surj to_real_Gromov_completion\n\ngoal (1 subgoal):\n 1. bij to_real_Gromov_completion", "by (simp add: bijI)"], ["proof (state)\nthis:\n  bij to_real_Gromov_completion\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next, we prove that we have a homeomorphism. By compactness of ereals, it suffices to show\nthat the inclusion map is continuous everywhere. It would be a pain to distinguish all the time if points are\nat infinity or not, we rather use a criterion saying that it suffices to prove sequential\ncontinuity for sequences taking values in a dense subset of the space, here we take the reals.\nHence, it suffices to show that if a sequence of reals $v_n$ converges to a limit $a$ in the\nextended reals, then the image of $v_n$ in the Gromov completion (which is an inner point) converges\nto the point corresponding to $a$. We treat separately the cases $a\\in \\mathbb{R}$, $a = \\infty$ and\n$a = -\\infty$. In the first case, everything is trivial. In the other cases, we have characterized\nin general sequences inside the space that converge to a boundary point, as sequences in the equivalence\nclass defining this boundary point. Since we have described explicitly these equivalence classes in\nthe case of the Gromov completion of the reals (they are respectively the sequences tending to\n$\\infty$ and to $-\\infty$), the result follows readily without any additional computation.\\<close>"], ["", "proposition homeo_to_real_Gromov_completion:\n  \"homeomorphism_on UNIV to_real_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. homeomorphism_on UNIV to_real_Gromov_completion", "proof (rule homeomorphism_on_compact)"], ["proof (state)\ngoal (3 subgoals):\n 1. continuous_on UNIV to_real_Gromov_completion\n 2. compact UNIV\n 3. inj to_real_Gromov_completion", "show \"inj to_real_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj to_real_Gromov_completion", "using bij_to_real_Gromov_completion"], ["proof (prove)\nusing this:\n  bij to_real_Gromov_completion\n\ngoal (1 subgoal):\n 1. inj to_real_Gromov_completion", "by (simp add: bij_betw_def)"], ["proof (state)\nthis:\n  inj to_real_Gromov_completion\n\ngoal (2 subgoals):\n 1. continuous_on UNIV to_real_Gromov_completion\n 2. compact UNIV", "show \"compact (UNIV::ereal set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact UNIV", "by (simp add: compact_UNIV)"], ["proof (state)\nthis:\n  compact UNIV\n\ngoal (1 subgoal):\n 1. continuous_on UNIV to_real_Gromov_completion", "show \"continuous_on UNIV to_real_Gromov_completion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on UNIV to_real_Gromov_completion", "proof (rule continuous_on_extension_sequentially[of _ \"{-\\<infinity><..<\\<infinity>}\"], auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u b.\n       \\<lbrakk>\\<forall>n.\n                   u n \\<noteq> - \\<infinity> \\<and>\n                   u n \\<noteq> \\<infinity>;\n        u \\<longlonglongrightarrow> b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n. to_real_Gromov_completion (u n))\n                         \\<longlonglongrightarrow> to_real_Gromov_completion\n              b", "fix u::\"nat \\<Rightarrow> ereal\" and b::ereal"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u b.\n       \\<lbrakk>\\<forall>n.\n                   u n \\<noteq> - \\<infinity> \\<and>\n                   u n \\<noteq> \\<infinity>;\n        u \\<longlonglongrightarrow> b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n. to_real_Gromov_completion (u n))\n                         \\<longlonglongrightarrow> to_real_Gromov_completion\n              b", "assume u: \"\\<forall>n. u n \\<noteq> - \\<infinity> \\<and> u n \\<noteq> \\<infinity>\" \"u \\<longlonglongrightarrow> b\""], ["proof (state)\nthis:\n  \\<forall>n. u n \\<noteq> - \\<infinity> \\<and> u n \\<noteq> \\<infinity>\n  u \\<longlonglongrightarrow> b\n\ngoal (1 subgoal):\n 1. \\<And>u b.\n       \\<lbrakk>\\<forall>n.\n                   u n \\<noteq> - \\<infinity> \\<and>\n                   u n \\<noteq> \\<infinity>;\n        u \\<longlonglongrightarrow> b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n. to_real_Gromov_completion (u n))\n                         \\<longlonglongrightarrow> to_real_Gromov_completion\n              b", "define v where \"v = (\\<lambda>n. real_of_ereal (u n))\""], ["proof (state)\nthis:\n  v = (\\<lambda>n. real_of_ereal (u n))\n\ngoal (1 subgoal):\n 1. \\<And>u b.\n       \\<lbrakk>\\<forall>n.\n                   u n \\<noteq> - \\<infinity> \\<and>\n                   u n \\<noteq> \\<infinity>;\n        u \\<longlonglongrightarrow> b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n. to_real_Gromov_completion (u n))\n                         \\<longlonglongrightarrow> to_real_Gromov_completion\n              b", "have uv: \"u n = ereal (v n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. u n = ereal (v n)", "using u"], ["proof (prove)\nusing this:\n  \\<forall>n. u n \\<noteq> - \\<infinity> \\<and> u n \\<noteq> \\<infinity>\n  u \\<longlonglongrightarrow> b\n\ngoal (1 subgoal):\n 1. u n = ereal (v n)", "unfolding v_def"], ["proof (prove)\nusing this:\n  \\<forall>n. u n \\<noteq> - \\<infinity> \\<and> u n \\<noteq> \\<infinity>\n  u \\<longlonglongrightarrow> b\n\ngoal (1 subgoal):\n 1. u n = ereal (real_of_ereal (u n))", "by (simp add: ereal_infinity_cases ereal_real)"], ["proof (state)\nthis:\n  u ?n = ereal (v ?n)\n\ngoal (1 subgoal):\n 1. \\<And>u b.\n       \\<lbrakk>\\<forall>n.\n                   u n \\<noteq> - \\<infinity> \\<and>\n                   u n \\<noteq> \\<infinity>;\n        u \\<longlonglongrightarrow> b\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n. to_real_Gromov_completion (u n))\n                         \\<longlonglongrightarrow> to_real_Gromov_completion\n              b", "show \"(\\<lambda>n. to_real_Gromov_completion (u n)) \\<longlonglongrightarrow> to_real_Gromov_completion b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "proof (cases b)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>r.\n       b = ereal r \\<Longrightarrow>\n       (\\<lambda>n. to_real_Gromov_completion (u n))\n       \\<longlonglongrightarrow> to_real_Gromov_completion b\n 2. b = \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b\n 3. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "case (real r)"], ["proof (state)\nthis:\n  b = ereal r\n\ngoal (3 subgoals):\n 1. \\<And>r.\n       b = ereal r \\<Longrightarrow>\n       (\\<lambda>n. to_real_Gromov_completion (u n))\n       \\<longlonglongrightarrow> to_real_Gromov_completion b\n 2. b = \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b\n 3. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "then"], ["proof (chain)\npicking this:\n  b = ereal r", "show ?thesis"], ["proof (prove)\nusing this:\n  b = ereal r\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "using \\<open>u \\<longlonglongrightarrow> b\\<close>"], ["proof (prove)\nusing this:\n  b = ereal r\n  u \\<longlonglongrightarrow> b\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "unfolding uv"], ["proof (prove)\nusing this:\n  b = ereal r\n  (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> b\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (ereal (v n)))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. to_real_Gromov_completion (u n))\n  \\<longlonglongrightarrow> to_real_Gromov_completion b\n\ngoal (2 subgoals):\n 1. b = \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b\n 2. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. b = \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b\n 2. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "case PInf"], ["proof (state)\nthis:\n  b = \\<infinity>\n\ngoal (2 subgoals):\n 1. b = \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b\n 2. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "then"], ["proof (chain)\npicking this:\n  b = \\<infinity>", "have *: \"(\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>\""], ["proof (prove)\nusing this:\n  b = \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>", "using \\<open>u \\<longlonglongrightarrow> b\\<close>"], ["proof (prove)\nusing this:\n  b = \\<infinity>\n  u \\<longlonglongrightarrow> b\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>", "unfolding uv"], ["proof (prove)\nusing this:\n  b = \\<infinity>\n  (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> b\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>\n\ngoal (2 subgoals):\n 1. b = \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b\n 2. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "have A: \"Gromov_completion_rel real v\" \"Gromov_completion_rel real real\" \"Gromov_completion_rel v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel real v &&&\n    Gromov_completion_rel real real &&& Gromov_completion_rel v v", "by (auto intro!: real_Gromov_completion_rel_PInf * tendsto_intros)"], ["proof (state)\nthis:\n  Gromov_completion_rel real v\n  Gromov_completion_rel real real\n  Gromov_completion_rel v v\n\ngoal (2 subgoals):\n 1. b = \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b\n 2. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel real v\n  Gromov_completion_rel real real\n  Gromov_completion_rel v v", "have B: \"abs_Gromov_completion v = abs_Gromov_completion real\""], ["proof (prove)\nusing this:\n  Gromov_completion_rel real v\n  Gromov_completion_rel real real\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion v = abs_Gromov_completion real", "using Quotient3_rel_abs[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  Gromov_completion_rel real v\n  Gromov_completion_rel real real\n  Gromov_completion_rel v v\n  Gromov_completion_rel ?r ?s \\<Longrightarrow>\n  abs_Gromov_completion ?r = abs_Gromov_completion ?s\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion v = abs_Gromov_completion real", "by force"], ["proof (state)\nthis:\n  abs_Gromov_completion v = abs_Gromov_completion real\n\ngoal (2 subgoals):\n 1. b = \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b\n 2. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion v = abs_Gromov_completion real", "show ?thesis"], ["proof (prove)\nusing this:\n  abs_Gromov_completion v = abs_Gromov_completion real\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "using \\<open>u \\<longlonglongrightarrow> b\\<close> PInf"], ["proof (prove)\nusing this:\n  abs_Gromov_completion v = abs_Gromov_completion real\n  u \\<longlonglongrightarrow> b\n  b = \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "unfolding uv"], ["proof (prove)\nusing this:\n  abs_Gromov_completion v = abs_Gromov_completion real\n  (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> b\n  b = \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (ereal (v n)))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_Gromov_completion v = abs_Gromov_completion real;\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>;\n     b = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. to_Gromov_completion (v n))\n                      \\<longlonglongrightarrow> abs_Gromov_completion real", "apply (subst Gromov_completion_converge_to_boundary)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_Gromov_completion v = abs_Gromov_completion real;\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>;\n     b = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> abs_Gromov_completion real \\<in> Gromov_boundary\n 2. \\<lbrakk>abs_Gromov_completion v = abs_Gromov_completion real;\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>;\n     b = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> Gromov_completion_rel v v \\<and>\n                      abs_Gromov_completion v = abs_Gromov_completion real", "using id_nat_ereal_tendsto_PInf real_Gromov_converging_to_boundary A B"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (real x)) \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary ?u =\n  ((\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n   (\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> - \\<infinity>)\n  Gromov_completion_rel real v\n  Gromov_completion_rel real real\n  Gromov_completion_rel v v\n  abs_Gromov_completion v = abs_Gromov_completion real\n\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_Gromov_completion v = abs_Gromov_completion real;\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>;\n     b = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> abs_Gromov_completion real \\<in> Gromov_boundary\n 2. \\<lbrakk>abs_Gromov_completion v = abs_Gromov_completion real;\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> \\<infinity>;\n     b = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> Gromov_completion_rel v v \\<and>\n                      abs_Gromov_completion v = abs_Gromov_completion real", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. to_real_Gromov_completion (u n))\n  \\<longlonglongrightarrow> to_real_Gromov_completion b\n\ngoal (1 subgoal):\n 1. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "case MInf"], ["proof (state)\nthis:\n  b = - \\<infinity>\n\ngoal (1 subgoal):\n 1. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "then"], ["proof (chain)\npicking this:\n  b = - \\<infinity>", "have *: \"(\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> -\\<infinity>\""], ["proof (prove)\nusing this:\n  b = - \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> - \\<infinity>", "using \\<open>u \\<longlonglongrightarrow> b\\<close>"], ["proof (prove)\nusing this:\n  b = - \\<infinity>\n  u \\<longlonglongrightarrow> b\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> - \\<infinity>", "unfolding uv"], ["proof (prove)\nusing this:\n  b = - \\<infinity>\n  (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> b\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> - \\<infinity>", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> - \\<infinity>\n\ngoal (1 subgoal):\n 1. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "have A: \"Gromov_completion_rel (\\<lambda>n. -real n) v\" \"Gromov_completion_rel (\\<lambda>n. -real n) (\\<lambda>n. -real n)\" \"Gromov_completion_rel v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_completion_rel (\\<lambda>n. - real n) v &&&\n    Gromov_completion_rel (\\<lambda>n. - real n) (\\<lambda>n. - real n) &&&\n    Gromov_completion_rel v v", "by (auto intro!: real_Gromov_completion_rel_MInf * tendsto_intros)"], ["proof (state)\nthis:\n  Gromov_completion_rel (\\<lambda>n. - real n) v\n  Gromov_completion_rel (\\<lambda>n. - real n) (\\<lambda>n. - real n)\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "then"], ["proof (chain)\npicking this:\n  Gromov_completion_rel (\\<lambda>n. - real n) v\n  Gromov_completion_rel (\\<lambda>n. - real n) (\\<lambda>n. - real n)\n  Gromov_completion_rel v v", "have B: \"abs_Gromov_completion v = abs_Gromov_completion (\\<lambda>n. -real n)\""], ["proof (prove)\nusing this:\n  Gromov_completion_rel (\\<lambda>n. - real n) v\n  Gromov_completion_rel (\\<lambda>n. - real n) (\\<lambda>n. - real n)\n  Gromov_completion_rel v v\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion v = abs_Gromov_completion (\\<lambda>n. - real n)", "using Quotient3_rel_abs[OF Quotient3_Gromov_completion]"], ["proof (prove)\nusing this:\n  Gromov_completion_rel (\\<lambda>n. - real n) v\n  Gromov_completion_rel (\\<lambda>n. - real n) (\\<lambda>n. - real n)\n  Gromov_completion_rel v v\n  Gromov_completion_rel ?r ?s \\<Longrightarrow>\n  abs_Gromov_completion ?r = abs_Gromov_completion ?s\n\ngoal (1 subgoal):\n 1. abs_Gromov_completion v = abs_Gromov_completion (\\<lambda>n. - real n)", "by force"], ["proof (state)\nthis:\n  abs_Gromov_completion v = abs_Gromov_completion (\\<lambda>n. - real n)\n\ngoal (1 subgoal):\n 1. b = - \\<infinity> \\<Longrightarrow>\n    (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "then"], ["proof (chain)\npicking this:\n  abs_Gromov_completion v = abs_Gromov_completion (\\<lambda>n. - real n)", "show ?thesis"], ["proof (prove)\nusing this:\n  abs_Gromov_completion v = abs_Gromov_completion (\\<lambda>n. - real n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "using \\<open>u \\<longlonglongrightarrow> b\\<close> MInf"], ["proof (prove)\nusing this:\n  abs_Gromov_completion v = abs_Gromov_completion (\\<lambda>n. - real n)\n  u \\<longlonglongrightarrow> b\n  b = - \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (u n))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "unfolding uv"], ["proof (prove)\nusing this:\n  abs_Gromov_completion v = abs_Gromov_completion (\\<lambda>n. - real n)\n  (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> b\n  b = - \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. to_real_Gromov_completion (ereal (v n)))\n    \\<longlonglongrightarrow> to_real_Gromov_completion b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>abs_Gromov_completion v =\n             abs_Gromov_completion (\\<lambda>n. - real n);\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> - \\<infinity>;\n     b = - \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>n. to_Gromov_completion (v n))\n                      \\<longlonglongrightarrow> abs_Gromov_completion\n           (\\<lambda>x. - real x)", "apply (subst Gromov_completion_converge_to_boundary)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_Gromov_completion v =\n             abs_Gromov_completion (\\<lambda>n. - real n);\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> - \\<infinity>;\n     b = - \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> abs_Gromov_completion (\\<lambda>x. - real x)\n                      \\<in> Gromov_boundary\n 2. \\<lbrakk>abs_Gromov_completion v =\n             abs_Gromov_completion (\\<lambda>n. - real n);\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> - \\<infinity>;\n     b = - \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> Gromov_completion_rel v v \\<and>\n                      abs_Gromov_completion v =\n                      abs_Gromov_completion (\\<lambda>x. - real x)", "using id_nat_ereal_tendsto_PInf real_Gromov_converging_to_boundary A B"], ["proof (prove)\nusing this:\n  (\\<lambda>x. ereal (real x)) \\<longlonglongrightarrow> \\<infinity>\n  Gromov_converging_at_boundary ?u =\n  ((\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> \\<infinity> \\<or>\n   (\\<lambda>x. ereal (?u x)) \\<longlonglongrightarrow> - \\<infinity>)\n  Gromov_completion_rel (\\<lambda>n. - real n) v\n  Gromov_completion_rel (\\<lambda>n. - real n) (\\<lambda>n. - real n)\n  Gromov_completion_rel v v\n  abs_Gromov_completion v = abs_Gromov_completion (\\<lambda>n. - real n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>abs_Gromov_completion v =\n             abs_Gromov_completion (\\<lambda>n. - real n);\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> - \\<infinity>;\n     b = - \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> abs_Gromov_completion (\\<lambda>x. - real x)\n                      \\<in> Gromov_boundary\n 2. \\<lbrakk>abs_Gromov_completion v =\n             abs_Gromov_completion (\\<lambda>n. - real n);\n     (\\<lambda>n. ereal (v n)) \\<longlonglongrightarrow> - \\<infinity>;\n     b = - \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> Gromov_completion_rel v v \\<and>\n                      abs_Gromov_completion v =\n                      abs_Gromov_completion (\\<lambda>x. - real x)", "by (auto simp add: ereal_minus_real_tendsto_MInf)"], ["proof (state)\nthis:\n  (\\<lambda>n. to_real_Gromov_completion (u n))\n  \\<longlonglongrightarrow> to_real_Gromov_completion b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n. to_real_Gromov_completion (u n))\n  \\<longlonglongrightarrow> to_real_Gromov_completion b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  continuous_on UNIV to_real_Gromov_completion\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*of theory Gromov_Boundary*)"]]}