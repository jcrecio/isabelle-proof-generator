{"file_name": "/home/qj213/afp-2021-10-22/thys/Gromov_Hyperbolicity/Gromov_Hyperbolicity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gromov_Hyperbolicity", "problem_names": ["lemma Gromov_hyperbolic_subsetI [intro]:\n  assumes \"\\<And>x y z t. x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> z \\<in> A \\<Longrightarrow> t \\<in> A \\<Longrightarrow> dist x y + dist z t \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta\"\n  shows \"Gromov_hyperbolic_subset delta A\"", "lemma Gromov_hyperbolic_ineq_not_distinct:\n  assumes \"x = y \\<or> x = z \\<or> x = t \\<or> y = z \\<or> y = t \\<or> z = (t::'a::metric_space)\"\n  shows \"dist x y + dist z t \\<le> max (dist x z + dist y t) (dist x t + dist y z)\"", "lemma Gromov_hyperbolic_closure:\n  assumes \"Gromov_hyperbolic_subset delta A\"\n  shows \"Gromov_hyperbolic_subset delta (closure A)\"", "lemma Gromov_hyperbolic_subsetI2:\n  fixes delta::real\n  assumes \"\\<And>e x y z. e \\<in> A \\<Longrightarrow> x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> z \\<in> A \\<Longrightarrow> Gromov_product_at (e::'a::metric_space) x z \\<ge> min (Gromov_product_at e x y) (Gromov_product_at e y z) - delta\"\n  shows \"Gromov_hyperbolic_subset delta A\"", "lemma Gromov_product_nonneg [simp, mono_intros]:\n  \"Gromov_product_at e x y \\<ge> 0\"", "lemma Gromov_product_commute:\n  \"Gromov_product_at e x y = Gromov_product_at e y x\"", "lemma Gromov_product_le_dist [simp, mono_intros]:\n  \"Gromov_product_at e x y \\<le> dist e x\"\n  \"Gromov_product_at e x y \\<le> dist e y\"", "lemma Gromov_product_le_infdist [mono_intros]:\n  assumes \"geodesic_segment_between G x y\"\n  shows \"Gromov_product_at e x y \\<le> infdist e G\"", "lemma Gromov_product_add:\n  \"Gromov_product_at e x y + Gromov_product_at x e y = dist e x\"", "lemma Gromov_product_geodesic_segment:\n  assumes \"geodesic_segment_between G x y\" \"t \\<in> {0..dist x y}\"\n  shows \"Gromov_product_at x y (geodesic_segment_param G x t) = t\"", "lemma Gromov_product_e_x_x [simp]:\n  \"Gromov_product_at e x x = dist e x\"", "lemma Gromov_product_at_diff:\n  \"\\<bar>Gromov_product_at x y z - Gromov_product_at a b c\\<bar> \\<le> dist x a + dist y b + dist z c\"", "lemma Gromov_product_at_diff1:\n  \"\\<bar>Gromov_product_at a x y - Gromov_product_at b x y\\<bar> \\<le> dist a b\"", "lemma Gromov_product_at_diff2:\n  \"\\<bar>Gromov_product_at e x z - Gromov_product_at e y z\\<bar> \\<le> dist x y\"", "lemma Gromov_product_at_diff3:\n  \"\\<bar>Gromov_product_at e x y - Gromov_product_at e x z\\<bar> \\<le> dist y z\"", "lemma Gromov_product_at_continuous:\n  assumes \"(u \\<longlongrightarrow> x) F\" \"(v \\<longlongrightarrow> y) F\" \"(w \\<longlongrightarrow> z) F\"\n  shows \"((\\<lambda>n. Gromov_product_at (u n) (v n) (w n)) \\<longlongrightarrow> Gromov_product_at x y z) F\"", "lemma (in Gromov_hyperbolic_space) hyperb_quad_ineq [mono_intros]:\n  shows \"dist x y + dist z t \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * deltaG(TYPE('a))\"", "lemma delta_nonneg [simp, mono_intros]:\n  \"deltaG(TYPE('a)) \\<ge> 0\"", "lemma hyperb_ineq [mono_intros]:\n  \"Gromov_product_at (e::'a) x z \\<ge> min (Gromov_product_at e x y) (Gromov_product_at e y z) - deltaG(TYPE('a))\"", "lemma hyperb_ineq' [mono_intros]:\n  \"Gromov_product_at (e::'a) x z + deltaG(TYPE('a)) \\<ge> min (Gromov_product_at e x y) (Gromov_product_at e y z)\"", "lemma hyperb_ineq_4_points [mono_intros]:\n  \"Min {Gromov_product_at (e::'a) x y, Gromov_product_at e y z, Gromov_product_at e z t} - 2 * deltaG(TYPE('a)) \\<le> Gromov_product_at e x t\"", "lemma hyperb_ineq_4_points' [mono_intros]:\n  \"Min {Gromov_product_at (e::'a) x y, Gromov_product_at e y z, Gromov_product_at e z t} \\<le> Gromov_product_at e x t + 2 * deltaG(TYPE('a))\"", "lemma thin_triangles1:\n  assumes \"geodesic_segment_between G x y\" \"geodesic_segment_between H x (z::'a)\"\n          \"t \\<in> {0..Gromov_product_at x y z}\"\n  shows \"dist (geodesic_segment_param G x t) (geodesic_segment_param H x t) \\<le> 4 * deltaG(TYPE('a))\"", "theorem thin_triangles:\n  assumes \"geodesic_segment_between Gxy x y\"\n          \"geodesic_segment_between Gxz x z\"\n          \"geodesic_segment_between Gyz y z\"\n          \"(w::'a) \\<in> Gyz\"\n  shows \"infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG(TYPE('a))\"", "lemma geodesics_nearby:\n  assumes \"geodesic_segment_between G x y\" \"geodesic_segment_between H x y\"\n          \"(z::'a) \\<in> G\"\n  shows \"infdist z H \\<le> 4 * deltaG(TYPE('a))\"", "lemma slim_triangle:\n  assumes \"geodesic_segment_between Gxy x y\"\n          \"geodesic_segment_between Gxz x z\"\n          \"geodesic_segment_between Gyz y (z::'a)\"\n  shows \"\\<exists>w. infdist w Gxy \\<le> 4 * deltaG(TYPE('a)) \\<and>\n             infdist w Gxz \\<le> 4 * deltaG(TYPE('a)) \\<and>\n             infdist w Gyz \\<le> 4 * deltaG(TYPE('a)) \\<and>\n             dist w x = (Gromov_product_at x y z) \\<and> w \\<in> Gxy\"", "lemma dist_triangle_side_middle:\n  assumes \"geodesic_segment_between G x (y::'a)\"\n  shows \"dist z (geodesic_segment_param G x (Gromov_product_at x z y)) \\<le> Gromov_product_at z x y + 2 * deltaG(TYPE('a))\"", "lemma infdist_triangle_side [mono_intros]:\n  assumes \"geodesic_segment_between G x (y::'a)\"\n  shows \"infdist z G \\<le> Gromov_product_at z x y + 2 * deltaG(TYPE('a))\"", "lemma dist_le_max_dist_triangle:\n  assumes \"geodesic_segment_between G x y\"\n          \"m \\<in> G\"\n  shows \"dist m z \\<le> max (dist x z) (dist y z) + deltaG(TYPE('a))\"", "lemma (in Gromov_hyperbolic_space_geodesic) thin_quadrilaterals:\n  assumes \"geodesic_segment_between Gxy x y\"\n          \"geodesic_segment_between Gyz y z\"\n          \"geodesic_segment_between Gzt z t\"\n          \"geodesic_segment_between Gxt x t\"\n          \"(w::'a) \\<in> Gxt\"\n  shows \"infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG(TYPE('a))\"", "lemma (in geodesic_space) controlled_thin_triangles_implies_hyperbolic:\n  assumes \"\\<And>(x::'a) y z t Gxy Gxz. geodesic_segment_between Gxy x y \\<Longrightarrow> geodesic_segment_between Gxz x z \\<Longrightarrow> t \\<in> {0..Gromov_product_at x y z}\n      \\<Longrightarrow> dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t) \\<le> delta\"\n  shows \"Gromov_hyperbolic_subset delta (UNIV::'a set)\"", "lemma geodesic_segment_between_real:\n  assumes \"x \\<le> (y::real)\"\n  shows \"geodesic_segment_between (G::real set) x y = (G = {x..y})\"", "lemma geodesic_segment_between_real':\n  \"{x--y} = {min x y..max x (y::real)}\"", "lemma geodesic_segment_real:\n  \"geodesic_segment (G::real set) = (\\<exists>x y. x \\<le> y \\<and> G = {x..y})\"", "lemma center_as_intersection:\n  \"{x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}\"", "lemma center_on_geodesic [simp]:\n  \"center x y z \\<in> {x--y}\"\n  \"center x y z \\<in> {x--z}\"\n  \"center x y z \\<in> {y--z}\"\n  \"center x y z \\<in> {y--x}\"\n  \"center x y z \\<in> {z--x}\"\n  \"center x y z \\<in> {z--y}\"", "lemma center_commute:\n  \"center x y z = center x z y\"\n  \"center x y z = center y x z\"\n  \"center x y z = center y z x\"\n  \"center x y z = center z x y\"\n  \"center x y z = center z y x\"", "lemma center_dist:\n  \"dist x (center x y z) = Gromov_product_at x y z\"", "lemma geodesic_intersection:\n  \"{x--y} \\<inter> {x--z} = {x--center x y z}\""], "translations": [["", "lemma Gromov_hyperbolic_subsetI [intro]:\n  assumes \"\\<And>x y z t. x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> z \\<in> A \\<Longrightarrow> t \\<in> A \\<Longrightarrow> dist x y + dist z t \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta\"\n  shows \"Gromov_hyperbolic_subset delta A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset delta A", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; ?z \\<in> A; ?t \\<in> A\\<rbrakk>\n  \\<Longrightarrow> dist ?x ?y + dist ?z ?t\n                    \\<le> max (dist ?x ?z + dist ?y ?t)\n                           (dist ?x ?t + dist ?y ?z) +\n                          2 * delta\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset delta A", "unfolding Gromov_hyperbolic_subset_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; ?z \\<in> A; ?t \\<in> A\\<rbrakk>\n  \\<Longrightarrow> dist ?x ?y + dist ?z ?t\n                    \\<le> max (dist ?x ?z + dist ?y ?t)\n                           (dist ?x ?t + dist ?y ?z) +\n                          2 * delta\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>A.\n       \\<forall>y\\<in>A.\n          \\<forall>z\\<in>A.\n             \\<forall>t\\<in>A.\n                dist x y + dist z t\n                \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n                      2 * delta", "by auto"], ["", "text \\<open>When the four points are not all distinct, the above inequality is always satisfied for\n$\\delta = 0$.\\<close>"], ["", "lemma Gromov_hyperbolic_ineq_not_distinct:\n  assumes \"x = y \\<or> x = z \\<or> x = t \\<or> y = z \\<or> y = t \\<or> z = (t::'a::metric_space)\"\n  shows \"dist x y + dist z t \\<le> max (dist x z + dist y t) (dist x t + dist y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z)", "using assms"], ["proof (prove)\nusing this:\n  x = y \\<or> x = z \\<or> x = t \\<or> y = z \\<or> y = t \\<or> z = t\n\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z)", "by (auto simp add: dist_commute, simp add: dist_triangle add.commute, simp add: dist_triangle3)"], ["", "text \\<open>It readily follows from the definition that hyperbolicity passes to the closure of the set.\\<close>"], ["", "lemma Gromov_hyperbolic_closure:\n  assumes \"Gromov_hyperbolic_subset delta A\"\n  shows \"Gromov_hyperbolic_subset delta (closure A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset delta (closure A)", "unfolding Gromov_hyperbolic_subset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>closure A.\n       \\<forall>y\\<in>closure A.\n          \\<forall>z\\<in>closure A.\n             \\<forall>t\\<in>closure A.\n                dist x y + dist z t\n                \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n                      2 * delta", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "fix x y z t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "assume H: \"x \\<in> closure A\" \"y \\<in> closure A\" \"z \\<in> closure A\" \"t \\<in> closure A\""], ["proof (state)\nthis:\n  x \\<in> closure A\n  y \\<in> closure A\n  z \\<in> closure A\n  t \\<in> closure A\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "obtain X::\"nat \\<Rightarrow> 'a\" where X: \"\\<And>n. X n \\<in> A\" \"X \\<longlonglongrightarrow> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>\\<And>n. X n \\<in> A;\n         X \\<longlonglongrightarrow> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using H closure_sequential"], ["proof (prove)\nusing this:\n  x \\<in> closure A\n  y \\<in> closure A\n  z \\<in> closure A\n  t \\<in> closure A\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>\\<And>n. X n \\<in> A;\n         X \\<longlonglongrightarrow> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  X ?n \\<in> A\n  X \\<longlonglongrightarrow> x\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "obtain Y::\"nat \\<Rightarrow> 'a\" where Y: \"\\<And>n. Y n \\<in> A\" \"Y \\<longlonglongrightarrow> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>\\<And>n. Y n \\<in> A;\n         Y \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using H closure_sequential"], ["proof (prove)\nusing this:\n  x \\<in> closure A\n  y \\<in> closure A\n  z \\<in> closure A\n  t \\<in> closure A\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>\\<And>n. Y n \\<in> A;\n         Y \\<longlonglongrightarrow> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Y ?n \\<in> A\n  Y \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "obtain Z::\"nat \\<Rightarrow> 'a\" where Z: \"\\<And>n. Z n \\<in> A\" \"Z \\<longlonglongrightarrow> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>\\<And>n. Z n \\<in> A;\n         Z \\<longlonglongrightarrow> z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using H closure_sequential"], ["proof (prove)\nusing this:\n  x \\<in> closure A\n  y \\<in> closure A\n  z \\<in> closure A\n  t \\<in> closure A\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>\\<And>n. Z n \\<in> A;\n         Z \\<longlonglongrightarrow> z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Z ?n \\<in> A\n  Z \\<longlonglongrightarrow> z\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "obtain T::\"nat \\<Rightarrow> 'a\" where T: \"\\<And>n. T n \\<in> A\" \"T \\<longlonglongrightarrow> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>\\<And>n. T n \\<in> A;\n         T \\<longlonglongrightarrow> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using H closure_sequential"], ["proof (prove)\nusing this:\n  x \\<in> closure A\n  y \\<in> closure A\n  z \\<in> closure A\n  t \\<in> closure A\n  (?l \\<in> closure ?S) =\n  (\\<exists>x.\n      (\\<forall>n. x n \\<in> ?S) \\<and> x \\<longlonglongrightarrow> ?l)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>\\<And>n. T n \\<in> A;\n         T \\<longlonglongrightarrow> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  T ?n \\<in> A\n  T \\<longlonglongrightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "have *: \"max (dist (X n) (Z n) + dist (Y n) (T n)) (dist (X n) (T n) + dist (Y n) (Z n)) + 2 * delta - dist (X n) (Y n) - dist (Z n) (T n) \\<ge> 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> max (dist (X n) (Z n) + dist (Y n) (T n))\n             (dist (X n) (T n) + dist (Y n) (Z n)) +\n            2 * delta -\n            dist (X n) (Y n) -\n            dist (Z n) (T n)", "using assms X(1)[of n] Y(1)[of n] Z(1)[of n] T(1)[of n]"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset delta A\n  X n \\<in> A\n  Y n \\<in> A\n  Z n \\<in> A\n  T n \\<in> A\n\ngoal (1 subgoal):\n 1. 0 \\<le> max (dist (X n) (Z n) + dist (Y n) (T n))\n             (dist (X n) (T n) + dist (Y n) (Z n)) +\n            2 * delta -\n            dist (X n) (Y n) -\n            dist (Z n) (T n)", "unfolding Gromov_hyperbolic_subset_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>A.\n     \\<forall>y\\<in>A.\n        \\<forall>z\\<in>A.\n           \\<forall>t\\<in>A.\n              dist x y + dist z t\n              \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n                    2 * delta\n  X n \\<in> A\n  Y n \\<in> A\n  Z n \\<in> A\n  T n \\<in> A\n\ngoal (1 subgoal):\n 1. 0 \\<le> max (dist (X n) (Z n) + dist (Y n) (T n))\n             (dist (X n) (T n) + dist (Y n) (Z n)) +\n            2 * delta -\n            dist (X n) (Y n) -\n            dist (Z n) (T n)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  0 \\<le> max (dist (X ?n) (Z ?n) + dist (Y ?n) (T ?n))\n           (dist (X ?n) (T ?n) + dist (Y ?n) (Z ?n)) +\n          2 * delta -\n          dist (X ?n) (Y ?n) -\n          dist (Z ?n) (T ?n)\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "have **: \"(\\<lambda>n. max (dist (X n) (Z n) + dist (Y n) (T n)) (dist (X n) (T n) + dist (Y n) (Z n)) + 2 * delta - dist (X n) (Y n) - dist (Z n) (T n))\n    \\<longlonglongrightarrow> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta - dist x y - dist z t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        max (dist (X n) (Z n) + dist (Y n) (T n))\n         (dist (X n) (T n) + dist (Y n) (Z n)) +\n        2 * delta -\n        dist (X n) (Y n) -\n        dist (Z n) (T n))\n    \\<longlonglongrightarrow> max (dist x z + dist y t)\n                               (dist x t + dist y z) +\n                              2 * delta -\n                              dist x y -\n                              dist z t", "apply (auto intro!: tendsto_intros)"], ["proof (prove)\ngoal (12 subgoals):\n 1. X \\<longlonglongrightarrow> x\n 2. Z \\<longlonglongrightarrow> z\n 3. Y \\<longlonglongrightarrow> y\n 4. T \\<longlonglongrightarrow> t\n 5. X \\<longlonglongrightarrow> x\n 6. T \\<longlonglongrightarrow> t\n 7. Y \\<longlonglongrightarrow> y\n 8. Z \\<longlonglongrightarrow> z\n 9. X \\<longlonglongrightarrow> x\n 10. Y \\<longlonglongrightarrow> y\nA total of 12 subgoals...", "using X Y Z T"], ["proof (prove)\nusing this:\n  X ?n \\<in> A\n  X \\<longlonglongrightarrow> x\n  Y ?n \\<in> A\n  Y \\<longlonglongrightarrow> y\n  Z ?n \\<in> A\n  Z \\<longlonglongrightarrow> z\n  T ?n \\<in> A\n  T \\<longlonglongrightarrow> t\n\ngoal (12 subgoals):\n 1. X \\<longlonglongrightarrow> x\n 2. Z \\<longlonglongrightarrow> z\n 3. Y \\<longlonglongrightarrow> y\n 4. T \\<longlonglongrightarrow> t\n 5. X \\<longlonglongrightarrow> x\n 6. T \\<longlonglongrightarrow> t\n 7. Y \\<longlonglongrightarrow> y\n 8. Z \\<longlonglongrightarrow> z\n 9. X \\<longlonglongrightarrow> x\n 10. Y \\<longlonglongrightarrow> y\nA total of 12 subgoals...", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      max (dist (X n) (Z n) + dist (Y n) (T n))\n       (dist (X n) (T n) + dist (Y n) (Z n)) +\n      2 * delta -\n      dist (X n) (Y n) -\n      dist (Z n) (T n))\n  \\<longlonglongrightarrow> max (dist x z + dist y t)\n                             (dist x t + dist y z) +\n                            2 * delta -\n                            dist x y -\n                            dist z t\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "have \"max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta - dist x y - dist z t \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta -\n            dist x y -\n            dist z t", "apply (rule LIMSEQ_le_const[OF **])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          0 \\<le> max (dist (X n) (Z n) + dist (Y n) (T n))\n                   (dist (X n) (T n) + dist (Y n) (Z n)) +\n                  2 * delta -\n                  dist (X n) (Y n) -\n                  dist (Z n) (T n)", "using *"], ["proof (prove)\nusing this:\n  0 \\<le> max (dist (X ?n) (Z ?n) + dist (Y ?n) (T ?n))\n           (dist (X ?n) (T ?n) + dist (Y ?n) (Z ?n)) +\n          2 * delta -\n          dist (X ?n) (Y ?n) -\n          dist (Z ?n) (T ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          0 \\<le> max (dist (X n) (Z n) + dist (Y n) (T n))\n                   (dist (X n) (T n) + dist (Y n) (Z n)) +\n                  2 * delta -\n                  dist (X n) (Y n) -\n                  dist (Z n) (T n)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta -\n          dist x y -\n          dist z t\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> closure A; y \\<in> closure A; z \\<in> closure A;\n        t \\<in> closure A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "then"], ["proof (chain)\npicking this:\n  0 \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta -\n          dist x y -\n          dist z t", "show \"dist x y + dist z t \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta\""], ["proof (prove)\nusing this:\n  0 \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta -\n          dist x y -\n          dist z t\n\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta", "by auto"], ["proof (state)\nthis:\n  dist x y + dist z t\n  \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A good formulation of hyperbolicity is in terms of Gromov products. Intuitively, the\nGromov product of $x$ and $y$ based at $e$ is the distance between $e$ and the geodesic between\n$x$ and $y$. It is also the time after which the geodesics from $e$ to $x$ and from $e$ to $y$\nstop travelling together.\\<close>"], ["", "definition Gromov_product_at::\"('a::metric_space) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> real\"\n  where \"Gromov_product_at e x y = (dist e x + dist e y - dist x y) / 2\""], ["", "lemma Gromov_hyperbolic_subsetI2:\n  fixes delta::real\n  assumes \"\\<And>e x y z. e \\<in> A \\<Longrightarrow> x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> z \\<in> A \\<Longrightarrow> Gromov_product_at (e::'a::metric_space) x z \\<ge> min (Gromov_product_at e x y) (Gromov_product_at e y z) - delta\"\n  shows \"Gromov_hyperbolic_subset delta A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset delta A", "proof (rule Gromov_hyperbolic_subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> A; y \\<in> A; z \\<in> A; t \\<in> A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "fix x y z t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> A; y \\<in> A; z \\<in> A; t \\<in> A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "assume H: \"x \\<in> A\" \"z \\<in> A\" \"y \\<in> A\" \"t \\<in> A\""], ["proof (state)\nthis:\n  x \\<in> A\n  z \\<in> A\n  y \\<in> A\n  t \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> A; y \\<in> A; z \\<in> A; t \\<in> A\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * delta", "show \"dist x y + dist z t \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta", "using assms[OF H]"], ["proof (prove)\nusing this:\n  min (Gromov_product_at x z y) (Gromov_product_at x y t) - delta\n  \\<le> Gromov_product_at x z t\n\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta", "unfolding Gromov_product_at_def min_def max_def"], ["proof (prove)\nusing this:\n  (if (dist x z + dist x y - dist z y) / 2\n      \\<le> (dist x y + dist x t - dist y t) / 2\n   then (dist x z + dist x y - dist z y) / 2\n   else (dist x y + dist x t - dist y t) / 2) -\n  delta\n  \\<le> (dist x z + dist x t - dist z t) / 2\n\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> (if dist x z + dist y t \\<le> dist x t + dist y z\n           then dist x t + dist y z else dist x z + dist y t) +\n          2 * delta", "by (auto simp add: divide_simps algebra_simps dist_commute)"], ["proof (state)\nthis:\n  dist x y + dist z t\n  \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * delta\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gromov_product_nonneg [simp, mono_intros]:\n  \"Gromov_product_at e x y \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Gromov_product_at e x y", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (dist e x + dist e y - dist x y) / 2", "by (simp add: dist_triangle3)"], ["", "lemma Gromov_product_commute:\n  \"Gromov_product_at e x y = Gromov_product_at e y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at e x y = Gromov_product_at e y x", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist e x + dist e y - dist x y) / 2 =\n    (dist e y + dist e x - dist y x) / 2", "by (auto simp add: dist_commute)"], ["", "lemma Gromov_product_le_dist [simp, mono_intros]:\n  \"Gromov_product_at e x y \\<le> dist e x\"\n  \"Gromov_product_at e x y \\<le> dist e y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> dist e x &&&\n    Gromov_product_at e x y \\<le> dist e y", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist e x + dist e y - dist x y) / 2 \\<le> dist e x &&&\n    (dist e x + dist e y - dist x y) / 2 \\<le> dist e y", "by (auto simp add: diff_le_eq dist_triangle dist_triangle2)"], ["", "lemma Gromov_product_le_infdist [mono_intros]:\n  assumes \"geodesic_segment_between G x y\"\n  shows \"Gromov_product_at e x y \\<le> infdist e G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> infdist e G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> infdist e G", "have [simp]: \"G \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<noteq> {}", "using assms"], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n\ngoal (1 subgoal):\n 1. G \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> infdist e G", "have \"Gromov_product_at e x y \\<le> dist e z\" if \"z \\<in> G\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> dist e z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> dist e z", "have \"dist e x + dist e y \\<le> (dist e z + dist z x) + (dist e z + dist z y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e x + dist e y \\<le> dist e z + dist z x + (dist e z + dist z y)", "by (intro add_mono dist_triangle)"], ["proof (state)\nthis:\n  dist e x + dist e y \\<le> dist e z + dist z x + (dist e z + dist z y)\n\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> dist e z", "also"], ["proof (state)\nthis:\n  dist e x + dist e y \\<le> dist e z + dist z x + (dist e z + dist z y)\n\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> dist e z", "have \"... = 2 * dist e z + dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e z + dist z x + (dist e z + dist z y) = 2 * dist e z + dist x y", "apply (auto simp add: dist_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z + dist y z = dist x y", "using \\<open>z \\<in> G\\<close> assms"], ["proof (prove)\nusing this:\n  z \\<in> G\n  geodesic_segment_between G x y\n\ngoal (1 subgoal):\n 1. dist x z + dist y z = dist x y", "by (metis dist_commute geodesic_segment_dist)"], ["proof (state)\nthis:\n  dist e z + dist z x + (dist e z + dist z y) = 2 * dist e z + dist x y\n\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> dist e z", "finally"], ["proof (chain)\npicking this:\n  dist e x + dist e y \\<le> 2 * dist e z + dist x y", "show ?thesis"], ["proof (prove)\nusing this:\n  dist e x + dist e y \\<le> 2 * dist e z + dist x y\n\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> dist e z", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist e x + dist e y \\<le> 2 * dist e z + dist x y\n\ngoal (1 subgoal):\n 1. (dist e x + dist e y - dist x y) / 2 \\<le> dist e z", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at e x y \\<le> dist e z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> G \\<Longrightarrow> Gromov_product_at e x y \\<le> dist e ?z\n\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> infdist e G", "then"], ["proof (chain)\npicking this:\n  ?z \\<in> G \\<Longrightarrow> Gromov_product_at e x y \\<le> dist e ?z", "show ?thesis"], ["proof (prove)\nusing this:\n  ?z \\<in> G \\<Longrightarrow> Gromov_product_at e x y \\<le> dist e ?z\n\ngoal (1 subgoal):\n 1. Gromov_product_at e x y \\<le> infdist e G", "apply (subst infdist_notempty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>z.\n        z \\<in> G \\<Longrightarrow>\n        Gromov_product_at e x y \\<le> dist e z) \\<Longrightarrow>\n    G \\<noteq> {}\n 2. (\\<And>z.\n        z \\<in> G \\<Longrightarrow>\n        Gromov_product_at e x y \\<le> dist e z) \\<Longrightarrow>\n    Gromov_product_at e x y \\<le> Inf (dist e ` G)", "by (auto intro: cINF_greatest)"], ["proof (state)\nthis:\n  Gromov_product_at e x y \\<le> infdist e G\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gromov_product_add:\n  \"Gromov_product_at e x y + Gromov_product_at x e y = dist e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at e x y + Gromov_product_at x e y = dist e x", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist e x + dist e y - dist x y) / 2 +\n    (dist x e + dist x y - dist e y) / 2 =\n    dist e x", "by (auto simp add: algebra_simps divide_simps dist_commute)"], ["", "lemma Gromov_product_geodesic_segment:\n  assumes \"geodesic_segment_between G x y\" \"t \\<in> {0..dist x y}\"\n  shows \"Gromov_product_at x y (geodesic_segment_param G x t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at x y (geodesic_segment_param G x t) = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_product_at x y (geodesic_segment_param G x t) = t", "have \"dist x (geodesic_segment_param G x t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param G x t) = t", "using assms(1) assms(2) geodesic_segment_param(6)"], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n  t \\<in> {0..dist x y}\n  \\<lbrakk>geodesic_segment_between ?G ?x ?y;\n   ?t \\<in> {0..dist ?x ?y}\\<rbrakk>\n  \\<Longrightarrow> dist ?x (geodesic_segment_param ?G ?x ?t) = ?t\n\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param G x t) = t", "by auto"], ["proof (state)\nthis:\n  dist x (geodesic_segment_param G x t) = t\n\ngoal (1 subgoal):\n 1. Gromov_product_at x y (geodesic_segment_param G x t) = t", "moreover"], ["proof (state)\nthis:\n  dist x (geodesic_segment_param G x t) = t\n\ngoal (1 subgoal):\n 1. Gromov_product_at x y (geodesic_segment_param G x t) = t", "have \"dist y (geodesic_segment_param G x t) = dist x y - t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y (geodesic_segment_param G x t) = dist x y - t", "by (metis \\<open>dist x (geodesic_segment_param G x t) = t\\<close> add_diff_cancel_left' assms(1) assms(2) dist_commute geodesic_segment_dist geodesic_segment_param(3))"], ["proof (state)\nthis:\n  dist y (geodesic_segment_param G x t) = dist x y - t\n\ngoal (1 subgoal):\n 1. Gromov_product_at x y (geodesic_segment_param G x t) = t", "ultimately"], ["proof (chain)\npicking this:\n  dist x (geodesic_segment_param G x t) = t\n  dist y (geodesic_segment_param G x t) = dist x y - t", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x (geodesic_segment_param G x t) = t\n  dist y (geodesic_segment_param G x t) = dist x y - t\n\ngoal (1 subgoal):\n 1. Gromov_product_at x y (geodesic_segment_param G x t) = t", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist x (geodesic_segment_param G x t) = t\n  dist y (geodesic_segment_param G x t) = dist x y - t\n\ngoal (1 subgoal):\n 1. (dist x y + dist x (geodesic_segment_param G x t) -\n     dist y (geodesic_segment_param G x t)) /\n    2 =\n    t", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at x y (geodesic_segment_param G x t) = t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Gromov_product_e_x_x [simp]:\n  \"Gromov_product_at e x x = dist e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at e x x = dist e x", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist e x + dist e x - dist x x) / 2 = dist e x", "by auto"], ["", "lemma Gromov_product_at_diff:\n  \"\\<bar>Gromov_product_at x y z - Gromov_product_at a b c\\<bar> \\<le> dist x a + dist y b + dist z c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Gromov_product_at x y z - Gromov_product_at a b c\\<bar>\n    \\<le> dist x a + dist y b + dist z c", "unfolding Gromov_product_at_def abs_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist x y + dist x z - dist y z) / 2 -\n    (dist a b + dist a c - dist b c) / 2\n    \\<le> dist x a + dist y b + dist z c \\<and>\n    - ((dist x y + dist x z - dist y z) / 2 -\n       (dist a b + dist a c - dist b c) / 2)\n    \\<le> dist x a + dist y b + dist z c", "apply (auto simp add: divide_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x y * 2 + dist x z * 2 - dist y z * 2 -\n    (dist a b * 2 + dist a c * 2 - dist b c * 2)\n    \\<le> dist x a * 4 + dist y b * 4 + dist z c * 4\n 2. dist a b * 2 + dist a c * 2 - dist b c * 2 -\n    (dist x y * 2 + dist x z * 2 - dist y z * 2)\n    \\<le> dist x a * 4 + dist y b * 4 + dist z c * 4", "by (smt dist_commute dist_triangle4)+"], ["", "lemma Gromov_product_at_diff1:\n  \"\\<bar>Gromov_product_at a x y - Gromov_product_at b x y\\<bar> \\<le> dist a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Gromov_product_at a x y - Gromov_product_at b x y\\<bar>\n    \\<le> dist a b", "using Gromov_product_at_diff[of a x y b x y]"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at a x y - Gromov_product_at b x y\\<bar>\n  \\<le> dist a b + dist x x + dist y y\n\ngoal (1 subgoal):\n 1. \\<bar>Gromov_product_at a x y - Gromov_product_at b x y\\<bar>\n    \\<le> dist a b", "by auto"], ["", "lemma Gromov_product_at_diff2:\n  \"\\<bar>Gromov_product_at e x z - Gromov_product_at e y z\\<bar> \\<le> dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Gromov_product_at e x z - Gromov_product_at e y z\\<bar>\n    \\<le> dist x y", "using Gromov_product_at_diff[of e x z e y z]"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e x z - Gromov_product_at e y z\\<bar>\n  \\<le> dist e e + dist x y + dist z z\n\ngoal (1 subgoal):\n 1. \\<bar>Gromov_product_at e x z - Gromov_product_at e y z\\<bar>\n    \\<le> dist x y", "by auto"], ["", "lemma Gromov_product_at_diff3:\n  \"\\<bar>Gromov_product_at e x y - Gromov_product_at e x z\\<bar> \\<le> dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Gromov_product_at e x y - Gromov_product_at e x z\\<bar>\n    \\<le> dist y z", "using Gromov_product_at_diff[of e x y e x z]"], ["proof (prove)\nusing this:\n  \\<bar>Gromov_product_at e x y - Gromov_product_at e x z\\<bar>\n  \\<le> dist e e + dist x x + dist y z\n\ngoal (1 subgoal):\n 1. \\<bar>Gromov_product_at e x y - Gromov_product_at e x z\\<bar>\n    \\<le> dist y z", "by auto"], ["", "text \\<open>The Gromov product is continuous in its three variables. We formulate it in terms of sequences,\nas it is the way it will be used below (and moreover continuity for functions of several variables\nis very poor in the library).\\<close>"], ["", "lemma Gromov_product_at_continuous:\n  assumes \"(u \\<longlongrightarrow> x) F\" \"(v \\<longlongrightarrow> y) F\" \"(w \\<longlongrightarrow> z) F\"\n  shows \"((\\<lambda>n. Gromov_product_at (u n) (v n) (w n)) \\<longlongrightarrow> Gromov_product_at x y z) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. Gromov_product_at (u n) (v n) (w n)) \\<longlongrightarrow>\n     Gromov_product_at x y z)\n     F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>n. Gromov_product_at (u n) (v n) (w n)) \\<longlongrightarrow>\n     Gromov_product_at x y z)\n     F", "have \"((\\<lambda>n. abs(Gromov_product_at (u n) (v n) (w n) - Gromov_product_at x y z)) \\<longlongrightarrow> 0 + 0 + 0) F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         \\<bar>Gromov_product_at (u n) (v n) (w n) -\n               Gromov_product_at x y z\\<bar>) \\<longlongrightarrow>\n     0 + 0 + 0)\n     F", "apply (rule tendsto_sandwich[of \"\\<lambda>n. 0\" _ _ \"\\<lambda>n. dist (u n) x + dist (v n) y + dist (w n) z\", OF always_eventually always_eventually])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>xa.\n       0 \\<le> \\<bar>Gromov_product_at (u xa) (v xa) (w xa) -\n                     Gromov_product_at x y z\\<bar>\n 2. \\<forall>xa.\n       \\<bar>Gromov_product_at (u xa) (v xa) (w xa) -\n             Gromov_product_at x y z\\<bar>\n       \\<le> dist (u xa) x + dist (v xa) y + dist (w xa) z\n 3. ((\\<lambda>n. 0) \\<longlongrightarrow> 0 + 0 + 0) F\n 4. ((\\<lambda>n.\n         dist (u n) x + dist (v n) y + dist (w n) z) \\<longlongrightarrow>\n     0 + 0 + 0)\n     F", "apply (simp, simp add: Gromov_product_at_diff, simp, intro tendsto_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ((\\<lambda>xa. dist (u xa) x) \\<longlongrightarrow> 0) F\n 2. ((\\<lambda>x. dist (v x) y) \\<longlongrightarrow> 0) F\n 3. ((\\<lambda>x. dist (w x) z) \\<longlongrightarrow> 0) F", "using assms tendsto_dist_iff"], ["proof (prove)\nusing this:\n  (u \\<longlongrightarrow> x) F\n  (v \\<longlongrightarrow> y) F\n  (w \\<longlongrightarrow> z) F\n  (?f \\<longlongrightarrow> ?l) ?F =\n  ((\\<lambda>x. dist (?f x) ?l) \\<longlongrightarrow> 0) ?F\n\ngoal (3 subgoals):\n 1. ((\\<lambda>xa. dist (u xa) x) \\<longlongrightarrow> 0) F\n 2. ((\\<lambda>x. dist (v x) y) \\<longlongrightarrow> 0) F\n 3. ((\\<lambda>x. dist (w x) z) \\<longlongrightarrow> 0) F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n.\n       \\<bar>Gromov_product_at (u n) (v n) (w n) -\n             Gromov_product_at x y z\\<bar>) \\<longlongrightarrow>\n   0 + 0 + 0)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. Gromov_product_at (u n) (v n) (w n)) \\<longlongrightarrow>\n     Gromov_product_at x y z)\n     F", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>n.\n       \\<bar>Gromov_product_at (u n) (v n) (w n) -\n             Gromov_product_at x y z\\<bar>) \\<longlongrightarrow>\n   0 + 0 + 0)\n   F", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>n.\n       \\<bar>Gromov_product_at (u n) (v n) (w n) -\n             Gromov_product_at x y z\\<bar>) \\<longlongrightarrow>\n   0 + 0 + 0)\n   F\n\ngoal (1 subgoal):\n 1. ((\\<lambda>n. Gromov_product_at (u n) (v n) (w n)) \\<longlongrightarrow>\n     Gromov_product_at x y z)\n     F", "apply (subst tendsto_dist_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         \\<bar>Gromov_product_at (u n) (v n) (w n) -\n               Gromov_product_at x y z\\<bar>) \\<longlongrightarrow>\n     0 + 0 + 0)\n     F \\<Longrightarrow>\n    ((\\<lambda>xa.\n         dist (Gromov_product_at (u xa) (v xa) (w xa))\n          (Gromov_product_at x y z)) \\<longlongrightarrow>\n     0)\n     F", "unfolding dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>n.\n         \\<bar>Gromov_product_at (u n) (v n) (w n) -\n               Gromov_product_at x y z\\<bar>) \\<longlongrightarrow>\n     0 + 0 + 0)\n     F \\<Longrightarrow>\n    ((\\<lambda>xa.\n         \\<bar>Gromov_product_at (u xa) (v xa) (w xa) -\n               Gromov_product_at x y z\\<bar>) \\<longlongrightarrow>\n     0)\n     F", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>n. Gromov_product_at (u n) (v n) (w n)) \\<longlongrightarrow>\n   Gromov_product_at x y z)\n   F\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Typeclass for Gromov hyperbolic spaces\\<close>"], ["", "text \\<open>We could (should?) just derive \\verb+Gromov_hyperbolic_space+ from \\verb+metric_space+.\nHowever, in this case, properties of metric spaces are not available when working in the locale!\nIt is more efficient to ensure that we have a metric space by putting a type class restriction\nin the definition. The $\\delta$ in Gromov-hyperbolicity type class is called \\verb+deltaG+ to\navoid name clashes.\n\\<close>"], ["", "class metric_space_with_deltaG = metric_space +\n  fixes deltaG::\"('a::metric_space) itself \\<Rightarrow> real\""], ["", "class Gromov_hyperbolic_space = metric_space_with_deltaG +\n  assumes hyperb_quad_ineq0: \"Gromov_hyperbolic_subset (deltaG(TYPE('a::metric_space))) (UNIV::'a set)\""], ["", "class Gromov_hyperbolic_space_geodesic = Gromov_hyperbolic_space + geodesic_space"], ["", "lemma (in Gromov_hyperbolic_space) hyperb_quad_ineq [mono_intros]:\n  shows \"dist x y + dist z t \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n          2 * deltaG TYPE('a)", "using hyperb_quad_ineq0"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV\n\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n          2 * deltaG TYPE('a)", "unfolding Gromov_hyperbolic_subset_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        \\<forall>z\\<in>UNIV.\n           \\<forall>t\\<in>UNIV.\n              dist x y + dist z t\n              \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n                    2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n          2 * deltaG TYPE('a)", "by auto"], ["", "text \\<open>It readily follows from the definition that the completion of a $\\delta$-hyperbolic\nspace is still $\\delta$-hyperbolic.\\<close>"], ["", "instantiation metric_completion :: (Gromov_hyperbolic_space) Gromov_hyperbolic_space\nbegin"], ["", "definition deltaG_metric_completion::\"('a metric_completion) itself \\<Rightarrow> real\" where\n  \"deltaG_metric_completion _ = deltaG(TYPE('a))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a metric_completion, Gromov_hyperbolic_space_class)", "proof (standard, rule Gromov_hyperbolic_subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; z \\<in> UNIV;\n        t \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * deltaG TYPE('a metric_completion)", "have \"Gromov_hyperbolic_subset (deltaG(TYPE('a))) (range (to_metric_completion::'a \\<Rightarrow> _))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) (range to_metric_completion)", "unfolding Gromov_hyperbolic_subset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>range to_metric_completion.\n       \\<forall>y\\<in>range to_metric_completion.\n          \\<forall>z\\<in>range to_metric_completion.\n             \\<forall>t\\<in>range to_metric_completion.\n                dist x y + dist z t\n                \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n                      2 * deltaG TYPE('a)", "apply (auto simp add: isometry_onD[OF to_metric_completion_isometry])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       dist x y + dist z t\n       \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n             2 * deltaG TYPE('a)", "by (metis hyperb_quad_ineq)"], ["proof (state)\nthis:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) (range to_metric_completion)\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; z \\<in> UNIV;\n        t \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * deltaG TYPE('a metric_completion)", "then"], ["proof (chain)\npicking this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) (range to_metric_completion)", "have \"Gromov_hyperbolic_subset (deltaG TYPE('a metric_completion)) (UNIV::'a metric_completion set)\""], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) (range to_metric_completion)\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a metric_completion)) UNIV", "unfolding deltaG_metric_completion_def to_metric_completion_dense'[symmetric]"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) (range to_metric_completion)\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a))\n     (closure (range to_metric_completion))", "using Gromov_hyperbolic_closure"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) (range to_metric_completion)\n  Gromov_hyperbolic_subset ?delta ?A \\<Longrightarrow>\n  Gromov_hyperbolic_subset ?delta (closure ?A)\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a))\n     (closure (range to_metric_completion))", "by auto"], ["proof (state)\nthis:\n  Gromov_hyperbolic_subset (deltaG TYPE('a metric_completion)) UNIV\n\ngoal (1 subgoal):\n 1. \\<And>x y z t.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; z \\<in> UNIV;\n        t \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> dist x y + dist z t\n                         \\<le> max (dist x z + dist y t)\n                                (dist x t + dist y z) +\n                               2 * deltaG TYPE('a metric_completion)", "then"], ["proof (chain)\npicking this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a metric_completion)) UNIV", "show \"dist x y + dist z t \\<le> max (dist x z + dist y t) (dist x t + dist y z) + 2 * deltaG TYPE('a metric_completion)\"\n      for x y z t::\"'a metric_completion\""], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (deltaG TYPE('a metric_completion)) UNIV\n\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n          2 * deltaG TYPE('a metric_completion)", "unfolding Gromov_hyperbolic_subset_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        \\<forall>z\\<in>UNIV.\n           \\<forall>t\\<in>UNIV.\n              dist x y + dist z t\n              \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n                    2 * deltaG TYPE('a metric_completion)\n\ngoal (1 subgoal):\n 1. dist x y + dist z t\n    \\<le> max (dist x z + dist y t) (dist x t + dist y z) +\n          2 * deltaG TYPE('a metric_completion)", "by auto"], ["proof (state)\nthis:\n  dist ?x ?y + dist ?z ?t\n  \\<le> max (dist ?x ?z + dist ?y ?t) (dist ?x ?t + dist ?y ?z) +\n        2 * deltaG TYPE('a metric_completion)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*of instantiation metric_completion (of Gromov_hyperbolic_space) is Gromov_hyperbolic*)"], ["", "context Gromov_hyperbolic_space\nbegin"], ["", "lemma delta_nonneg [simp, mono_intros]:\n  \"deltaG(TYPE('a)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> deltaG TYPE('a)", "obtain x::'a where True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (True \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  True\n\ngoal (1 subgoal):\n 1. 0 \\<le> deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> deltaG TYPE('a)", "using hyperb_quad_ineq[of x x x x]"], ["proof (prove)\nusing this:\n  dist x x + dist x x\n  \\<le> max (dist x x + dist x x) (dist x x + dist x x) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hyperb_ineq [mono_intros]:\n  \"Gromov_product_at (e::'a) x z \\<ge> min (Gromov_product_at e x y) (Gromov_product_at e y z) - deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at e x y) (Gromov_product_at e y z) -\n    deltaG TYPE('a)\n    \\<le> Gromov_product_at e x z", "using hyperb_quad_ineq[of e y x z]"], ["proof (prove)\nusing this:\n  dist e y + dist x z\n  \\<le> max (dist e x + dist y z) (dist e z + dist y x) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. min (Gromov_product_at e x y) (Gromov_product_at e y z) -\n    deltaG TYPE('a)\n    \\<le> Gromov_product_at e x z", "unfolding Gromov_product_at_def min_def max_def"], ["proof (prove)\nusing this:\n  dist e y + dist x z\n  \\<le> (if dist e x + dist y z \\<le> dist e z + dist y x\n         then dist e z + dist y x else dist e x + dist y z) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. (if (dist e x + dist e y - dist x y) / 2\n        \\<le> (dist e y + dist e z - dist y z) / 2\n     then (dist e x + dist e y - dist x y) / 2\n     else (dist e y + dist e z - dist y z) / 2) -\n    deltaG TYPE('a)\n    \\<le> (dist e x + dist e z - dist x z) / 2", "by (auto simp add: divide_simps algebra_simps metric_space_class.dist_commute)"], ["", "lemma hyperb_ineq' [mono_intros]:\n  \"Gromov_product_at (e::'a) x z + deltaG(TYPE('a)) \\<ge> min (Gromov_product_at e x y) (Gromov_product_at e y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at e x y) (Gromov_product_at e y z)\n    \\<le> Gromov_product_at e x z + deltaG TYPE('a)", "using hyperb_ineq[of e x y z]"], ["proof (prove)\nusing this:\n  min (Gromov_product_at e x y) (Gromov_product_at e y z) - deltaG TYPE('a)\n  \\<le> Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. min (Gromov_product_at e x y) (Gromov_product_at e y z)\n    \\<le> Gromov_product_at e x z + deltaG TYPE('a)", "by auto"], ["", "lemma hyperb_ineq_4_points [mono_intros]:\n  \"Min {Gromov_product_at (e::'a) x y, Gromov_product_at e y z, Gromov_product_at e z t} - 2 * deltaG(TYPE('a)) \\<le> Gromov_product_at e x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {Gromov_product_at e x y, Gromov_product_at e y z,\n         Gromov_product_at e z t} -\n    2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at e x t", "using hyperb_ineq[of e x y z] hyperb_ineq[of e x z t]"], ["proof (prove)\nusing this:\n  min (Gromov_product_at e x y) (Gromov_product_at e y z) - deltaG TYPE('a)\n  \\<le> Gromov_product_at e x z\n  min (Gromov_product_at e x z) (Gromov_product_at e z t) - deltaG TYPE('a)\n  \\<le> Gromov_product_at e x t\n\ngoal (1 subgoal):\n 1. Min {Gromov_product_at e x y, Gromov_product_at e y z,\n         Gromov_product_at e z t} -\n    2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at e x t", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>min (Gromov_product_at e x y) (Gromov_product_at e y z) -\n             deltaG TYPE('a)\n             \\<le> Gromov_product_at e x z;\n     min (Gromov_product_at e x z) (Gromov_product_at e z t) -\n     deltaG TYPE('a)\n     \\<le> Gromov_product_at e x t\\<rbrakk>\n    \\<Longrightarrow> min (Gromov_product_at e x y)\n                       (min (Gromov_product_at e y z)\n                         (Gromov_product_at e z t)) -\n                      2 * deltaG TYPE('a)\n                      \\<le> Gromov_product_at e x t", "using delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>min (Gromov_product_at e x y) (Gromov_product_at e y z) -\n             deltaG TYPE('a)\n             \\<le> Gromov_product_at e x z;\n     min (Gromov_product_at e x z) (Gromov_product_at e z t) -\n     deltaG TYPE('a)\n     \\<le> Gromov_product_at e x t\\<rbrakk>\n    \\<Longrightarrow> min (Gromov_product_at e x y)\n                       (min (Gromov_product_at e y z)\n                         (Gromov_product_at e z t)) -\n                      2 * deltaG TYPE('a)\n                      \\<le> Gromov_product_at e x t", "by linarith"], ["", "lemma hyperb_ineq_4_points' [mono_intros]:\n  \"Min {Gromov_product_at (e::'a) x y, Gromov_product_at e y z, Gromov_product_at e z t} \\<le> Gromov_product_at e x t + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {Gromov_product_at e x y, Gromov_product_at e y z,\n         Gromov_product_at e z t}\n    \\<le> Gromov_product_at e x t + 2 * deltaG TYPE('a)", "using hyperb_ineq_4_points[of e x y z t]"], ["proof (prove)\nusing this:\n  Min {Gromov_product_at e x y, Gromov_product_at e y z,\n       Gromov_product_at e z t} -\n  2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at e x t\n\ngoal (1 subgoal):\n 1. Min {Gromov_product_at e x y, Gromov_product_at e y z,\n         Gromov_product_at e z t}\n    \\<le> Gromov_product_at e x t + 2 * deltaG TYPE('a)", "by auto"], ["", "text \\<open>In Gromov-hyperbolic spaces, geodesic triangles are thin, i.e., a point on one side of a\ngeodesic triangle is close to the union of the two other sides (where the constant in \"close\"\nis $4\\delta$, independent of the size of the triangle). We prove this basic property\n(which, in fact, is a characterization of Gromov-hyperbolic spaces: a geodesic space in which\ntriangles are thin is hyperbolic).\\<close>"], ["", "lemma thin_triangles1:\n  assumes \"geodesic_segment_between G x y\" \"geodesic_segment_between H x (z::'a)\"\n          \"t \\<in> {0..Gromov_product_at x y z}\"\n  shows \"dist (geodesic_segment_param G x t) (geodesic_segment_param H x t) \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "have *: \"Gromov_product_at x z (geodesic_segment_param H x t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at x z (geodesic_segment_param H x t) = t", "apply (rule Gromov_product_geodesic_segment[OF assms(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> {0..dist x z}", "using assms(3) Gromov_product_le_dist(2)"], ["proof (prove)\nusing this:\n  t \\<in> {0..Gromov_product_at x y z}\n  Gromov_product_at ?e ?x ?y \\<le> dist ?e ?y\n\ngoal (1 subgoal):\n 1. t \\<in> {0..dist x z}", "by (metis atLeastatMost_subset_iff subset_iff)"], ["proof (state)\nthis:\n  Gromov_product_at x z (geodesic_segment_param H x t) = t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "have \"Gromov_product_at x y (geodesic_segment_param H x t)\n        \\<ge> min (Gromov_product_at x y z) (Gromov_product_at x z (geodesic_segment_param H x t)) - deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at x y z)\n     (Gromov_product_at x z (geodesic_segment_param H x t)) -\n    deltaG TYPE('a)\n    \\<le> Gromov_product_at x y (geodesic_segment_param H x t)", "by (rule hyperb_ineq)"], ["proof (state)\nthis:\n  min (Gromov_product_at x y z)\n   (Gromov_product_at x z (geodesic_segment_param H x t)) -\n  deltaG TYPE('a)\n  \\<le> Gromov_product_at x y (geodesic_segment_param H x t)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  min (Gromov_product_at x y z)\n   (Gromov_product_at x z (geodesic_segment_param H x t)) -\n  deltaG TYPE('a)\n  \\<le> Gromov_product_at x y (geodesic_segment_param H x t)", "have I: \"Gromov_product_at x y (geodesic_segment_param H x t) \\<ge> t - deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  min (Gromov_product_at x y z)\n   (Gromov_product_at x z (geodesic_segment_param H x t)) -\n  deltaG TYPE('a)\n  \\<le> Gromov_product_at x y (geodesic_segment_param H x t)\n\ngoal (1 subgoal):\n 1. t - deltaG TYPE('a)\n    \\<le> Gromov_product_at x y (geodesic_segment_param H x t)", "using assms(3)"], ["proof (prove)\nusing this:\n  min (Gromov_product_at x y z)\n   (Gromov_product_at x z (geodesic_segment_param H x t)) -\n  deltaG TYPE('a)\n  \\<le> Gromov_product_at x y (geodesic_segment_param H x t)\n  t \\<in> {0..Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. t - deltaG TYPE('a)\n    \\<le> Gromov_product_at x y (geodesic_segment_param H x t)", "unfolding *"], ["proof (prove)\nusing this:\n  min (Gromov_product_at x y z) t - deltaG TYPE('a)\n  \\<le> Gromov_product_at x y (geodesic_segment_param H x t)\n  t \\<in> {0..Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. t - deltaG TYPE('a)\n    \\<le> Gromov_product_at x y (geodesic_segment_param H x t)", "by auto"], ["proof (state)\nthis:\n  t - deltaG TYPE('a)\n  \\<le> Gromov_product_at x y (geodesic_segment_param H x t)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "have *: \"Gromov_product_at x (geodesic_segment_param G x t) y = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at x (geodesic_segment_param G x t) y = t", "apply (subst Gromov_product_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at x y (geodesic_segment_param G x t) = t", "apply (rule Gromov_product_geodesic_segment[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> {0..dist x y}", "using assms(3) Gromov_product_le_dist(1)"], ["proof (prove)\nusing this:\n  t \\<in> {0..Gromov_product_at x y z}\n  Gromov_product_at ?e ?x ?y \\<le> dist ?e ?x\n\ngoal (1 subgoal):\n 1. t \\<in> {0..dist x y}", "by (metis atLeastatMost_subset_iff subset_iff)"], ["proof (state)\nthis:\n  Gromov_product_at x (geodesic_segment_param G x t) y = t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "have \"t - 2 * deltaG(TYPE('a)) = min t (t- deltaG(TYPE('a))) - deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t - 2 * deltaG TYPE('a) = min t (t - deltaG TYPE('a)) - deltaG TYPE('a)", "unfolding min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t - 2 * deltaG TYPE('a) =\n    (if t \\<le> t - deltaG TYPE('a) then t else t - deltaG TYPE('a)) -\n    deltaG TYPE('a)", "using antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. t - 2 * deltaG TYPE('a) =\n    (if t \\<le> t - deltaG TYPE('a) then t else t - deltaG TYPE('a)) -\n    deltaG TYPE('a)", "by fastforce"], ["proof (state)\nthis:\n  t - 2 * deltaG TYPE('a) = min t (t - deltaG TYPE('a)) - deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  t - 2 * deltaG TYPE('a) = min t (t - deltaG TYPE('a)) - deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "have \"... \\<le> min (Gromov_product_at x (geodesic_segment_param G x t) y) (Gromov_product_at x y (geodesic_segment_param H x t)) - deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min t (t - deltaG TYPE('a)) - deltaG TYPE('a)\n    \\<le> min (Gromov_product_at x (geodesic_segment_param G x t) y)\n           (Gromov_product_at x y (geodesic_segment_param H x t)) -\n          deltaG TYPE('a)", "using I *"], ["proof (prove)\nusing this:\n  t - deltaG TYPE('a)\n  \\<le> Gromov_product_at x y (geodesic_segment_param H x t)\n  Gromov_product_at x (geodesic_segment_param G x t) y = t\n\ngoal (1 subgoal):\n 1. min t (t - deltaG TYPE('a)) - deltaG TYPE('a)\n    \\<le> min (Gromov_product_at x (geodesic_segment_param G x t) y)\n           (Gromov_product_at x y (geodesic_segment_param H x t)) -\n          deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  min t (t - deltaG TYPE('a)) - deltaG TYPE('a)\n  \\<le> min (Gromov_product_at x (geodesic_segment_param G x t) y)\n         (Gromov_product_at x y (geodesic_segment_param H x t)) -\n        deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  min t (t - deltaG TYPE('a)) - deltaG TYPE('a)\n  \\<le> min (Gromov_product_at x (geodesic_segment_param G x t) y)\n         (Gromov_product_at x y (geodesic_segment_param H x t)) -\n        deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "have \"... \\<le> Gromov_product_at x (geodesic_segment_param G x t) (geodesic_segment_param H x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at x (geodesic_segment_param G x t) y)\n     (Gromov_product_at x y (geodesic_segment_param H x t)) -\n    deltaG TYPE('a)\n    \\<le> Gromov_product_at x (geodesic_segment_param G x t)\n           (geodesic_segment_param H x t)", "by (rule hyperb_ineq)"], ["proof (state)\nthis:\n  min (Gromov_product_at x (geodesic_segment_param G x t) y)\n   (Gromov_product_at x y (geodesic_segment_param H x t)) -\n  deltaG TYPE('a)\n  \\<le> Gromov_product_at x (geodesic_segment_param G x t)\n         (geodesic_segment_param H x t)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  t - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at x (geodesic_segment_param G x t)\n         (geodesic_segment_param H x t)", "have I: \"Gromov_product_at x (geodesic_segment_param G x t) (geodesic_segment_param H x t) \\<ge> t - 2 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  t - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at x (geodesic_segment_param G x t)\n         (geodesic_segment_param H x t)\n\ngoal (1 subgoal):\n 1. t - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at x (geodesic_segment_param G x t)\n           (geodesic_segment_param H x t)", "by simp"], ["proof (state)\nthis:\n  t - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at x (geodesic_segment_param G x t)\n         (geodesic_segment_param H x t)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "have A: \"dist x (geodesic_segment_param G x t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param G x t) = t", "by (meson assms(1) assms(3) atLeastatMost_subset_iff geodesic_segment_param(6) Gromov_product_le_dist(1) subset_eq)"], ["proof (state)\nthis:\n  dist x (geodesic_segment_param G x t) = t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "have B: \"dist x (geodesic_segment_param H x t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param H x t) = t", "by (meson assms(2) assms(3) atLeastatMost_subset_iff geodesic_segment_param(6) Gromov_product_le_dist(2) subset_eq)"], ["proof (state)\nthis:\n  dist x (geodesic_segment_param H x t) = t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "using I"], ["proof (prove)\nusing this:\n  t - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at x (geodesic_segment_param G x t)\n         (geodesic_segment_param H x t)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "unfolding Gromov_product_at_def A B"], ["proof (prove)\nusing this:\n  t - 2 * deltaG TYPE('a)\n  \\<le> (t + t -\n         dist (geodesic_segment_param G x t)\n          (geodesic_segment_param H x t)) /\n        2\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n    \\<le> 4 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist (geodesic_segment_param G x t) (geodesic_segment_param H x t)\n  \\<le> 4 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem thin_triangles:\n  assumes \"geodesic_segment_between Gxy x y\"\n          \"geodesic_segment_between Gxz x z\"\n          \"geodesic_segment_between Gyz y z\"\n          \"(w::'a) \\<in> Gyz\"\n  shows \"infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "obtain t where w: \"t \\<in> {0..dist y z}\" \"w = geodesic_segment_param Gyz y t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> {0..dist y z};\n         w = geodesic_segment_param Gyz y t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using geodesic_segment_param[OF assms(3)] assms(4)"], ["proof (prove)\nusing this:\n  geodesic_segment_param Gyz y 0 = y\n  geodesic_segment_param Gyz y (dist y z) = z\n  ?t \\<in> {0..dist y z} \\<Longrightarrow>\n  geodesic_segment_param Gyz y ?t \\<in> Gyz\n  isometry_on {0..dist y z} (geodesic_segment_param Gyz y)\n  geodesic_segment_param Gyz y ` {0..dist y z} = Gyz\n  ?t \\<in> {0..dist y z} \\<Longrightarrow>\n  dist y (geodesic_segment_param Gyz y ?t) = ?t\n  \\<lbrakk>?s \\<in> {0..dist y z}; ?t \\<in> {0..dist y z}\\<rbrakk>\n  \\<Longrightarrow> dist (geodesic_segment_param Gyz y ?s)\n                     (geodesic_segment_param Gyz y ?t) =\n                    \\<bar>?s - ?t\\<bar>\n  ?z \\<in> Gyz \\<Longrightarrow>\n  ?z = geodesic_segment_param Gyz y (dist y ?z)\n  w \\<in> Gyz\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> {0..dist y z};\n         w = geodesic_segment_param Gyz y t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis imageE)"], ["proof (state)\nthis:\n  t \\<in> {0..dist y z}\n  w = geodesic_segment_param Gyz y t\n\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "proof (cases \"t \\<le> Gromov_product_at y x z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)\n 2. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "case True"], ["proof (state)\nthis:\n  t \\<le> Gromov_product_at y x z\n\ngoal (2 subgoals):\n 1. t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)\n 2. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "have *: \"dist w (geodesic_segment_param Gxy y t) \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist w (geodesic_segment_param Gxy y t) \\<le> 4 * deltaG TYPE('a)", "unfolding w(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gyz y t) (geodesic_segment_param Gxy y t)\n    \\<le> 4 * deltaG TYPE('a)", "apply (rule thin_triangles1[of _ _ z _ x])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment_between Gyz y z\n 2. geodesic_segment_between Gxy y x\n 3. t \\<in> {0..Gromov_product_at y z x}", "using True assms(1) assms(3) w(1)"], ["proof (prove)\nusing this:\n  t \\<le> Gromov_product_at y x z\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gyz y z\n  t \\<in> {0..dist y z}\n\ngoal (3 subgoals):\n 1. geodesic_segment_between Gyz y z\n 2. geodesic_segment_between Gxy y x\n 3. t \\<in> {0..Gromov_product_at y z x}", "by (auto simp add: geodesic_segment_commute Gromov_product_commute)"], ["proof (state)\nthis:\n  dist w (geodesic_segment_param Gxy y t) \\<le> 4 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)\n 2. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "apply (rule infdist_le2[OF _ *])"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gxy y t \\<in> Gxy \\<union> Gxz", "by (metis True assms(1) box_real(2) geodesic_segment_commute geodesic_segment_param(3) Gromov_product_le_dist(1) mem_box_real(2) order_trans subset_eq sup.cobounded1 w(1))"], ["proof (state)\nthis:\n  infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "case False"], ["proof (state)\nthis:\n  \\<not> t \\<le> Gromov_product_at y x z\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "define s where \"s = dist y z - t\""], ["proof (state)\nthis:\n  s = dist y z - t\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "have s: \"s \\<in> {0..Gromov_product_at z y x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {0..Gromov_product_at z y x}", "unfolding s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y z - t \\<in> {0..Gromov_product_at z y x}", "using Gromov_product_add[of y z x] w(1) False"], ["proof (prove)\nusing this:\n  Gromov_product_at y z x + Gromov_product_at z y x = dist y z\n  t \\<in> {0..dist y z}\n  \\<not> t \\<le> Gromov_product_at y x z\n\ngoal (1 subgoal):\n 1. dist y z - t \\<in> {0..Gromov_product_at z y x}", "by (auto simp add: Gromov_product_commute)"], ["proof (state)\nthis:\n  s \\<in> {0..Gromov_product_at z y x}\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "have w2: \"w = geodesic_segment_param Gyz z s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = geodesic_segment_param Gyz z s", "unfolding s_def w(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gyz y t =\n    geodesic_segment_param Gyz z (dist y z - t)", "apply (rule geodesic_segment_reverse_param[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. geodesic_segment_between Gyz y z\n 2. t \\<in> {0..dist y z}", "using assms(3) w(1)"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gyz y z\n  t \\<in> {0..dist y z}\n\ngoal (2 subgoals):\n 1. geodesic_segment_between Gyz y z\n 2. t \\<in> {0..dist y z}", "by auto"], ["proof (state)\nthis:\n  w = geodesic_segment_param Gyz z s\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "have *: \"dist w (geodesic_segment_param Gxz z s) \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist w (geodesic_segment_param Gxz z s) \\<le> 4 * deltaG TYPE('a)", "unfolding w2"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gyz z s) (geodesic_segment_param Gxz z s)\n    \\<le> 4 * deltaG TYPE('a)", "apply (rule thin_triangles1[of _ _ y _ x])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment_between Gyz z y\n 2. geodesic_segment_between Gxz z x\n 3. s \\<in> {0..Gromov_product_at z y x}", "using s assms"], ["proof (prove)\nusing this:\n  s \\<in> {0..Gromov_product_at z y x}\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  geodesic_segment_between Gyz y z\n  w \\<in> Gyz\n\ngoal (3 subgoals):\n 1. geodesic_segment_between Gyz z y\n 2. geodesic_segment_between Gxz z x\n 3. s \\<in> {0..Gromov_product_at z y x}", "by (auto simp add: geodesic_segment_commute)"], ["proof (state)\nthis:\n  dist w (geodesic_segment_param Gxz z s) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> Gromov_product_at y x z \\<Longrightarrow>\n    infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)", "apply (rule infdist_le2[OF _ *])"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gxz z s \\<in> Gxy \\<union> Gxz", "by (metis Un_iff assms(2) atLeastAtMost_iff geodesic_segment_commute geodesic_segment_param(3) Gromov_product_commute Gromov_product_le_dist(1) order_trans s)"], ["proof (state)\nthis:\n  infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infdist w (Gxy \\<union> Gxz) \\<le> 4 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A consequence of the thin triangles property is that, although the geodesic between\ntwo points is in general not unique in a Gromov-hyperbolic space, two such geodesics are\nwithin $O(\\delta)$ of each other.\\<close>"], ["", "lemma geodesics_nearby:\n  assumes \"geodesic_segment_between G x y\" \"geodesic_segment_between H x y\"\n          \"(z::'a) \\<in> G\"\n  shows \"infdist z H \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist z H \\<le> 4 * deltaG TYPE('a)", "using thin_triangles[OF geodesic_segment_between_x_x(1) assms(2) assms(1) assms(3)]\ngeodesic_segment_endpoints(1)[OF assms(2)] insert_absorb"], ["proof (prove)\nusing this:\n  infdist z ({x} \\<union> H) \\<le> 4 * deltaG TYPE('a)\n  x \\<in> H\n  ?a \\<in> ?A \\<Longrightarrow> insert ?a ?A = ?A\n\ngoal (1 subgoal):\n 1. infdist z H \\<le> 4 * deltaG TYPE('a)", "by fastforce"], ["", "text \\<open>A small variant of the property of thin triangles is that triangles are slim, i.e., there is\na point which is close to the three sides of the triangle (a \"center\" of the triangle, but\nonly defined up to $O(\\delta)$). And one can take it on any side, and its distance to the corresponding\nvertices is expressed in terms of a Gromov product.\\<close>"], ["", "lemma slim_triangle:\n  assumes \"geodesic_segment_between Gxy x y\"\n          \"geodesic_segment_between Gxz x z\"\n          \"geodesic_segment_between Gyz y (z::'a)\"\n  shows \"\\<exists>w. infdist w Gxy \\<le> 4 * deltaG(TYPE('a)) \\<and>\n             infdist w Gxz \\<le> 4 * deltaG(TYPE('a)) \\<and>\n             infdist w Gyz \\<le> 4 * deltaG(TYPE('a)) \\<and>\n             dist w x = (Gromov_product_at x y z) \\<and> w \\<in> Gxy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "define w where \"w = geodesic_segment_param Gxy x (Gromov_product_at x y z)\""], ["proof (state)\nthis:\n  w = geodesic_segment_param Gxy x (Gromov_product_at x y z)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "have \"w \\<in> Gxy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> Gxy", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gxy x (Gromov_product_at x y z) \\<in> Gxy", "by (rule geodesic_segment_param(3)[OF assms(1)], auto)"], ["proof (state)\nthis:\n  w \\<in> Gxy\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "then"], ["proof (chain)\npicking this:\n  w \\<in> Gxy", "have xy: \"infdist w Gxy \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  w \\<in> Gxy\n\ngoal (1 subgoal):\n 1. infdist w Gxy \\<le> 4 * deltaG TYPE('a)", "by simp"], ["proof (state)\nthis:\n  infdist w Gxy \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "have *: \"dist w x = (Gromov_product_at x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist w x = Gromov_product_at x y z", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) x =\n    Gromov_product_at x y z", "using assms(1)"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) x =\n    Gromov_product_at x y z", "by (metis Gromov_product_le_dist(1) Gromov_product_nonneg atLeastAtMost_iff geodesic_segment_param(6) metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist w x = Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "define w2 where \"w2 = geodesic_segment_param Gxz x (Gromov_product_at x y z)\""], ["proof (state)\nthis:\n  w2 = geodesic_segment_param Gxz x (Gromov_product_at x y z)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "have \"w2 \\<in> Gxz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w2 \\<in> Gxz", "unfolding w2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gxz x (Gromov_product_at x y z) \\<in> Gxz", "by (rule geodesic_segment_param(3)[OF assms(2)], auto)"], ["proof (state)\nthis:\n  w2 \\<in> Gxz\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "moreover"], ["proof (state)\nthis:\n  w2 \\<in> Gxz\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "have \"dist w w2 \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist w w2 \\<le> 4 * deltaG TYPE('a)", "unfolding w_def w2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 4 * deltaG TYPE('a)", "by (rule thin_triangles1[OF assms(1) assms(2)], auto)"], ["proof (state)\nthis:\n  dist w w2 \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "ultimately"], ["proof (chain)\npicking this:\n  w2 \\<in> Gxz\n  dist w w2 \\<le> 4 * deltaG TYPE('a)", "have xz: \"infdist w Gxz \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  w2 \\<in> Gxz\n  dist w w2 \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist w Gxz \\<le> 4 * deltaG TYPE('a)", "using infdist_le2"], ["proof (prove)\nusing this:\n  w2 \\<in> Gxz\n  dist w w2 \\<le> 4 * deltaG TYPE('a)\n  \\<lbrakk>?a \\<in> ?A; dist ?x ?a \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> infdist ?x ?A \\<le> ?d\n\ngoal (1 subgoal):\n 1. infdist w Gxz \\<le> 4 * deltaG TYPE('a)", "by blast"], ["proof (state)\nthis:\n  infdist w Gxz \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "have \"w = geodesic_segment_param Gxy y (dist x y - Gromov_product_at x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = geodesic_segment_param Gxy y (dist x y - Gromov_product_at x y z)", "unfolding w_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gxy x (Gromov_product_at x y z) =\n    geodesic_segment_param Gxy y (dist x y - Gromov_product_at x y z)", "by (rule geodesic_segment_reverse_param[OF assms(1), symmetric], auto)"], ["proof (state)\nthis:\n  w = geodesic_segment_param Gxy y (dist x y - Gromov_product_at x y z)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "then"], ["proof (chain)\npicking this:\n  w = geodesic_segment_param Gxy y (dist x y - Gromov_product_at x y z)", "have w: \"w = geodesic_segment_param Gxy y (Gromov_product_at y x z)\""], ["proof (prove)\nusing this:\n  w = geodesic_segment_param Gxy y (dist x y - Gromov_product_at x y z)\n\ngoal (1 subgoal):\n 1. w = geodesic_segment_param Gxy y (Gromov_product_at y x z)", "using Gromov_product_add[of x y z]"], ["proof (prove)\nusing this:\n  w = geodesic_segment_param Gxy y (dist x y - Gromov_product_at x y z)\n  Gromov_product_at x y z + Gromov_product_at y x z = dist x y\n\ngoal (1 subgoal):\n 1. w = geodesic_segment_param Gxy y (Gromov_product_at y x z)", "by (metis add_diff_cancel_left')"], ["proof (state)\nthis:\n  w = geodesic_segment_param Gxy y (Gromov_product_at y x z)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "define w3 where \"w3 = geodesic_segment_param Gyz y (Gromov_product_at y x z)\""], ["proof (state)\nthis:\n  w3 = geodesic_segment_param Gyz y (Gromov_product_at y x z)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "have \"w3 \\<in> Gyz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w3 \\<in> Gyz", "unfolding w3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gyz y (Gromov_product_at y x z) \\<in> Gyz", "by (rule geodesic_segment_param(3)[OF assms(3)], auto)"], ["proof (state)\nthis:\n  w3 \\<in> Gyz\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "moreover"], ["proof (state)\nthis:\n  w3 \\<in> Gyz\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "have \"dist w w3 \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist w w3 \\<le> 4 * deltaG TYPE('a)", "unfolding w w3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy y (Gromov_product_at y x z))\n     (geodesic_segment_param Gyz y (Gromov_product_at y x z))\n    \\<le> 4 * deltaG TYPE('a)", "by (rule thin_triangles1[OF geodesic_segment_commute[OF assms(1)] assms(3)], auto)"], ["proof (state)\nthis:\n  dist w w3 \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "ultimately"], ["proof (chain)\npicking this:\n  w3 \\<in> Gyz\n  dist w w3 \\<le> 4 * deltaG TYPE('a)", "have yz: \"infdist w Gyz \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  w3 \\<in> Gyz\n  dist w w3 \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist w Gyz \\<le> 4 * deltaG TYPE('a)", "using infdist_le2"], ["proof (prove)\nusing this:\n  w3 \\<in> Gyz\n  dist w w3 \\<le> 4 * deltaG TYPE('a)\n  \\<lbrakk>?a \\<in> ?A; dist ?x ?a \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> infdist ?x ?A \\<le> ?d\n\ngoal (1 subgoal):\n 1. infdist w Gyz \\<le> 4 * deltaG TYPE('a)", "by blast"], ["proof (state)\nthis:\n  infdist w Gyz \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "using xy xz yz * \\<open>w \\<in> Gxy\\<close>"], ["proof (prove)\nusing this:\n  infdist w Gxy \\<le> 4 * deltaG TYPE('a)\n  infdist w Gxz \\<le> 4 * deltaG TYPE('a)\n  infdist w Gyz \\<le> 4 * deltaG TYPE('a)\n  dist w x = Gromov_product_at x y z\n  w \\<in> Gxy\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n       infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n       dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy", "by force"], ["proof (state)\nthis:\n  \\<exists>w.\n     infdist w Gxy \\<le> 4 * deltaG TYPE('a) \\<and>\n     infdist w Gxz \\<le> 4 * deltaG TYPE('a) \\<and>\n     infdist w Gyz \\<le> 4 * deltaG TYPE('a) \\<and>\n     dist w x = Gromov_product_at x y z \\<and> w \\<in> Gxy\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The distance of a vertex of a triangle to the opposite side is essentially given by the\nGromov product, up to $2\\delta$.\\<close>"], ["", "lemma dist_triangle_side_middle:\n  assumes \"geodesic_segment_between G x (y::'a)\"\n  shows \"dist z (geodesic_segment_param G x (Gromov_product_at x z y)) \\<le> Gromov_product_at z x y + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "define m where \"m = geodesic_segment_param G x (Gromov_product_at x z y)\""], ["proof (state)\nthis:\n  m = geodesic_segment_param G x (Gromov_product_at x z y)\n\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "have \"m \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> G", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param G x (Gromov_product_at x z y) \\<in> G", "using assms(1)"], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n\ngoal (1 subgoal):\n 1. geodesic_segment_param G x (Gromov_product_at x z y) \\<in> G", "by auto"], ["proof (state)\nthis:\n  m \\<in> G\n\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "have A: \"dist x m = Gromov_product_at x z y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x m = Gromov_product_at x z y", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param G x (Gromov_product_at x z y)) =\n    Gromov_product_at x z y", "by (rule geodesic_segment_param(6)[OF assms(1)], auto)"], ["proof (state)\nthis:\n  dist x m = Gromov_product_at x z y\n\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "have B: \"dist y m = dist x y - dist x m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y m = dist x y - dist x m", "using geodesic_segment_dist[OF assms \\<open>m \\<in> G\\<close>]"], ["proof (prove)\nusing this:\n  dist x m + dist m y = dist x y\n\ngoal (1 subgoal):\n 1. dist y m = dist x y - dist x m", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist y m = dist x y - dist x m\n\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "have *: \"dist x z + dist y m = Gromov_product_at z x y + dist x y\"\n          \"dist x m + dist y z = Gromov_product_at z x y + dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z + dist y m = Gromov_product_at z x y + dist x y &&&\n    dist x m + dist y z = Gromov_product_at z x y + dist x y", "unfolding B A Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z + (dist x y - (dist x z + dist x y - dist z y) / 2) =\n    (dist z x + dist z y - dist x y) / 2 + dist x y &&&\n    (dist x z + dist x y - dist z y) / 2 + dist y z =\n    (dist z x + dist z y - dist x y) / 2 + dist x y", "by (auto simp add: metric_space_class.dist_commute divide_simps)"], ["proof (state)\nthis:\n  dist x z + dist y m = Gromov_product_at z x y + dist x y\n  dist x m + dist y z = Gromov_product_at z x y + dist x y\n\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "have \"dist x y + dist z m \\<le> max (dist x z + dist y m) (dist x m + dist y z) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y + dist z m\n    \\<le> max (dist x z + dist y m) (dist x m + dist y z) +\n          2 * deltaG TYPE('a)", "by (rule hyperb_quad_ineq)"], ["proof (state)\nthis:\n  dist x y + dist z m\n  \\<le> max (dist x z + dist y m) (dist x m + dist y z) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  dist x y + dist z m\n  \\<le> max (dist x z + dist y m) (dist x m + dist y z) +\n        2 * deltaG TYPE('a)", "have \"dist z m \\<le> Gromov_product_at z x y + 2 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  dist x y + dist z m\n  \\<le> max (dist x z + dist y m) (dist x m + dist y z) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z m \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "unfolding *"], ["proof (prove)\nusing this:\n  dist x y + dist z m\n  \\<le> max (Gromov_product_at z x y + dist x y)\n         (Gromov_product_at z x y + dist x y) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z m \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist z m \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  dist z m \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist z m \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "unfolding m_def"], ["proof (prove)\nusing this:\n  dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n  \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n    \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n  \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infdist_triangle_side [mono_intros]:\n  assumes \"geodesic_segment_between G x (y::'a)\"\n  shows \"infdist z G \\<le> Gromov_product_at z x y + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist z G \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist z G \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "have \"infdist z G \\<le> dist z (geodesic_segment_param G x (Gromov_product_at x z y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist z G\n    \\<le> dist z (geodesic_segment_param G x (Gromov_product_at x z y))", "using assms"], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n\ngoal (1 subgoal):\n 1. infdist z G\n    \\<le> dist z (geodesic_segment_param G x (Gromov_product_at x z y))", "by (auto intro!: infdist_le)"], ["proof (state)\nthis:\n  infdist z G\n  \\<le> dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n\ngoal (1 subgoal):\n 1. infdist z G \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  infdist z G\n  \\<le> dist z (geodesic_segment_param G x (Gromov_product_at x z y))", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist z G\n  \\<le> dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n\ngoal (1 subgoal):\n 1. infdist z G \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "using dist_triangle_side_middle[OF assms, of z]"], ["proof (prove)\nusing this:\n  infdist z G\n  \\<le> dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n  dist z (geodesic_segment_param G x (Gromov_product_at x z y))\n  \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist z G \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  infdist z G \\<le> Gromov_product_at z x y + 2 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The distance of a point on a side of triangle to the opposite vertex is controlled by\nthe length of the opposite sides, up to $\\delta$.\\<close>"], ["", "lemma dist_le_max_dist_triangle:\n  assumes \"geodesic_segment_between G x y\"\n          \"m \\<in> G\"\n  shows \"dist m z \\<le> max (dist x z) (dist y z) + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "consider \"dist m x \\<le> deltaG(TYPE('a))\" | \"dist m y \\<le> deltaG(TYPE('a))\" |\n           \"dist m x \\<ge> deltaG(TYPE('a)) \\<and> dist m y \\<ge> deltaG(TYPE('a)) \\<and> Gromov_product_at z x m \\<le> Gromov_product_at z m y\" |\n           \"dist m x \\<ge> deltaG(TYPE('a)) \\<and> dist m y \\<ge> deltaG(TYPE('a)) \\<and> Gromov_product_at z m y \\<le> Gromov_product_at z x m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist m x \\<le> deltaG TYPE('a) \\<Longrightarrow> thesis;\n     dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow> thesis;\n     deltaG TYPE('a) \\<le> dist m x \\<and>\n     deltaG TYPE('a) \\<le> dist m y \\<and>\n     Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n     thesis;\n     deltaG TYPE('a) \\<le> dist m x \\<and>\n     deltaG TYPE('a) \\<le> dist m y \\<and>\n     Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>dist m x \\<le> deltaG TYPE('a) \\<Longrightarrow> ?thesis;\n   dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow> ?thesis;\n   deltaG TYPE('a) \\<le> dist m x \\<and>\n   deltaG TYPE('a) \\<le> dist m y \\<and>\n   Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n   ?thesis;\n   deltaG TYPE('a) \\<le> dist m x \\<and>\n   deltaG TYPE('a) \\<le> dist m y \\<and>\n   Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>dist m x \\<le> deltaG TYPE('a) \\<Longrightarrow> ?thesis;\n   dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow> ?thesis;\n   deltaG TYPE('a) \\<le> dist m x \\<and>\n   deltaG TYPE('a) \\<le> dist m y \\<and>\n   Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n   ?thesis;\n   deltaG TYPE('a) \\<le> dist m x \\<and>\n   deltaG TYPE('a) \\<le> dist m y \\<and>\n   Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>dist m x \\<le> deltaG TYPE('a) \\<Longrightarrow> ?thesis;\n   dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow> ?thesis;\n   deltaG TYPE('a) \\<le> dist m x \\<and>\n   deltaG TYPE('a) \\<le> dist m y \\<and>\n   Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n   ?thesis;\n   deltaG TYPE('a) \\<le> dist m x \\<and>\n   deltaG TYPE('a) \\<le> dist m y \\<and>\n   Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "proof (cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. dist m x \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 3. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 4. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "case 1"], ["proof (state)\nthis:\n  dist m x \\<le> deltaG TYPE('a)\n\ngoal (4 subgoals):\n 1. dist m x \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 3. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 4. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "have \"dist m z \\<le> dist m x + dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m z \\<le> dist m x + dist x z", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist m z \\<le> dist m x + dist x z\n\ngoal (4 subgoals):\n 1. dist m x \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 3. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 4. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  dist m z \\<le> dist m x + dist x z", "show ?thesis"], ["proof (prove)\nusing this:\n  dist m z \\<le> dist m x + dist x z\n\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "using 1"], ["proof (prove)\nusing this:\n  dist m z \\<le> dist m x + dist x z\n  dist m x \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n\ngoal (3 subgoals):\n 1. dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 3. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 3. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "case 2"], ["proof (state)\nthis:\n  dist m y \\<le> deltaG TYPE('a)\n\ngoal (3 subgoals):\n 1. dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 3. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "have \"dist m z \\<le> dist m y + dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m z \\<le> dist m y + dist y z", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist m z \\<le> dist m y + dist y z\n\ngoal (3 subgoals):\n 1. dist m y \\<le> deltaG TYPE('a) \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 3. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  dist m z \\<le> dist m y + dist y z", "show ?thesis"], ["proof (prove)\nusing this:\n  dist m z \\<le> dist m y + dist y z\n\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "using 2"], ["proof (prove)\nusing this:\n  dist m z \\<le> dist m y + dist y z\n  dist m y \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "case 3"], ["proof (state)\nthis:\n  deltaG TYPE('a) \\<le> dist m x \\<and>\n  deltaG TYPE('a) \\<le> dist m y \\<and>\n  Gromov_product_at z x m \\<le> Gromov_product_at z m y\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  deltaG TYPE('a) \\<le> dist m x \\<and>\n  deltaG TYPE('a) \\<le> dist m y \\<and>\n  Gromov_product_at z x m \\<le> Gromov_product_at z m y", "have \"Gromov_product_at z x m = min (Gromov_product_at z x m) (Gromov_product_at z m y)\""], ["proof (prove)\nusing this:\n  deltaG TYPE('a) \\<le> dist m x \\<and>\n  deltaG TYPE('a) \\<le> dist m y \\<and>\n  Gromov_product_at z x m \\<le> Gromov_product_at z m y\n\ngoal (1 subgoal):\n 1. Gromov_product_at z x m =\n    min (Gromov_product_at z x m) (Gromov_product_at z m y)", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at z x m =\n  min (Gromov_product_at z x m) (Gromov_product_at z m y)\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  Gromov_product_at z x m =\n  min (Gromov_product_at z x m) (Gromov_product_at z m y)\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "have \"... \\<le> Gromov_product_at z x y + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at z x m) (Gromov_product_at z m y)\n    \\<le> Gromov_product_at z x y + deltaG TYPE('a)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  min (Gromov_product_at z x m) (Gromov_product_at z m y)\n  \\<le> Gromov_product_at z x y + deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  Gromov_product_at z x m \\<le> Gromov_product_at z x y + deltaG TYPE('a)", "have \"dist z m \\<le> dist z y + dist x m - dist x y + 2 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  Gromov_product_at z x m \\<le> Gromov_product_at z x y + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z m \\<le> dist z y + dist x m - dist x y + 2 * deltaG TYPE('a)", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  (dist z x + dist z m - dist x m) / 2\n  \\<le> (dist z x + dist z y - dist x y) / 2 + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z m \\<le> dist z y + dist x m - dist x y + 2 * deltaG TYPE('a)", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  dist z m \\<le> dist z y + dist x m - dist x y + 2 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  dist z m \\<le> dist z y + dist x m - dist x y + 2 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "have \"... = dist z y - dist m y + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z y + dist x m - dist x y + 2 * deltaG TYPE('a) =\n    dist z y - dist m y + 2 * deltaG TYPE('a)", "using geodesic_segment_dist[OF assms]"], ["proof (prove)\nusing this:\n  dist x m + dist m y = dist x y\n\ngoal (1 subgoal):\n 1. dist z y + dist x m - dist x y + 2 * deltaG TYPE('a) =\n    dist z y - dist m y + 2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist z y + dist x m - dist x y + 2 * deltaG TYPE('a) =\n  dist z y - dist m y + 2 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  dist z y + dist x m - dist x y + 2 * deltaG TYPE('a) =\n  dist z y - dist m y + 2 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "have \"... \\<le> dist z y + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z y - dist m y + 2 * deltaG TYPE('a)\n    \\<le> dist z y + deltaG TYPE('a)", "using 3"], ["proof (prove)\nusing this:\n  deltaG TYPE('a) \\<le> dist m x \\<and>\n  deltaG TYPE('a) \\<le> dist m y \\<and>\n  Gromov_product_at z x m \\<le> Gromov_product_at z m y\n\ngoal (1 subgoal):\n 1. dist z y - dist m y + 2 * deltaG TYPE('a)\n    \\<le> dist z y + deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist z y - dist m y + 2 * deltaG TYPE('a) \\<le> dist z y + deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z x m \\<le> Gromov_product_at z m y \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n 2. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  dist z m \\<le> dist z y + deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist z m \\<le> dist z y + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "case 4"], ["proof (state)\nthis:\n  deltaG TYPE('a) \\<le> dist m x \\<and>\n  deltaG TYPE('a) \\<le> dist m y \\<and>\n  Gromov_product_at z m y \\<le> Gromov_product_at z x m\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  deltaG TYPE('a) \\<le> dist m x \\<and>\n  deltaG TYPE('a) \\<le> dist m y \\<and>\n  Gromov_product_at z m y \\<le> Gromov_product_at z x m", "have \"Gromov_product_at z m y = min (Gromov_product_at z x m) (Gromov_product_at z m y)\""], ["proof (prove)\nusing this:\n  deltaG TYPE('a) \\<le> dist m x \\<and>\n  deltaG TYPE('a) \\<le> dist m y \\<and>\n  Gromov_product_at z m y \\<le> Gromov_product_at z x m\n\ngoal (1 subgoal):\n 1. Gromov_product_at z m y =\n    min (Gromov_product_at z x m) (Gromov_product_at z m y)", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at z m y =\n  min (Gromov_product_at z x m) (Gromov_product_at z m y)\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  Gromov_product_at z m y =\n  min (Gromov_product_at z x m) (Gromov_product_at z m y)\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "have \"... \\<le> Gromov_product_at z x y + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min (Gromov_product_at z x m) (Gromov_product_at z m y)\n    \\<le> Gromov_product_at z x y + deltaG TYPE('a)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  min (Gromov_product_at z x m) (Gromov_product_at z m y)\n  \\<le> Gromov_product_at z x y + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  Gromov_product_at z m y \\<le> Gromov_product_at z x y + deltaG TYPE('a)", "have \"dist z m \\<le> dist z x + dist m y - dist x y + 2 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  Gromov_product_at z m y \\<le> Gromov_product_at z x y + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z m \\<le> dist z x + dist m y - dist x y + 2 * deltaG TYPE('a)", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  (dist z m + dist z y - dist m y) / 2\n  \\<le> (dist z x + dist z y - dist x y) / 2 + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist z m \\<le> dist z x + dist m y - dist x y + 2 * deltaG TYPE('a)", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  dist z m \\<le> dist z x + dist m y - dist x y + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  dist z m \\<le> dist z x + dist m y - dist x y + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "have \"... = dist z x - dist x m + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z x + dist m y - dist x y + 2 * deltaG TYPE('a) =\n    dist z x - dist x m + 2 * deltaG TYPE('a)", "using geodesic_segment_dist[OF assms]"], ["proof (prove)\nusing this:\n  dist x m + dist m y = dist x y\n\ngoal (1 subgoal):\n 1. dist z x + dist m y - dist x y + 2 * deltaG TYPE('a) =\n    dist z x - dist x m + 2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist z x + dist m y - dist x y + 2 * deltaG TYPE('a) =\n  dist z x - dist x m + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  dist z x + dist m y - dist x y + 2 * deltaG TYPE('a) =\n  dist z x - dist x m + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "have \"... \\<le> dist z x + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z x - dist x m + 2 * deltaG TYPE('a)\n    \\<le> dist z x + deltaG TYPE('a)", "using 4"], ["proof (prove)\nusing this:\n  deltaG TYPE('a) \\<le> dist m x \\<and>\n  deltaG TYPE('a) \\<le> dist m y \\<and>\n  Gromov_product_at z m y \\<le> Gromov_product_at z x m\n\ngoal (1 subgoal):\n 1. dist z x - dist x m + 2 * deltaG TYPE('a)\n    \\<le> dist z x + deltaG TYPE('a)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist z x - dist x m + 2 * deltaG TYPE('a) \\<le> dist z x + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) \\<le> dist m x \\<and>\n    deltaG TYPE('a) \\<le> dist m y \\<and>\n    Gromov_product_at z m y \\<le> Gromov_product_at z x m \\<Longrightarrow>\n    dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  dist z m \\<le> dist z x + deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist z m \\<le> dist z x + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist m z \\<le> max (dist x z) (dist y z) + deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* of locale Gromov_hyperbolic_space *)"], ["", "text \\<open>A useful variation around the previous properties is that quadrilaterals are thin, in the\nfollowing sense: if one has a union of three geodesics from $x$ to $t$, then a geodesic from $x$\nto $t$ remains within distance $8\\delta$ of the union of these 3 geodesics. We formulate the\nstatement in geodesic hyperbolic spaces as the proof requires the construction of an additional\ngeodesic, but in fact the statement is true without this assumption, thanks to the Bonk-Schramm\nextension theorem.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) thin_quadrilaterals:\n  assumes \"geodesic_segment_between Gxy x y\"\n          \"geodesic_segment_between Gyz y z\"\n          \"geodesic_segment_between Gzt z t\"\n          \"geodesic_segment_between Gxt x t\"\n          \"(w::'a) \\<in> Gxt\"\n  shows \"infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "have I: \"infdist w ({x--z} \\<union> Gzt) \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w ({x--z} \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "apply (rule thin_triangles[OF _ assms(3) assms(4) assms(5)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between {x--z} z x", "by (simp add: geodesic_segment_commute)"], ["proof (state)\nthis:\n  infdist w ({x--z} \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "have \"\\<exists>u \\<in> {x--z} \\<union> Gzt. infdist w ({x--z} \\<union> Gzt) = dist w u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>{x--z} \\<union> Gzt.\n       infdist w ({x--z} \\<union> Gzt) = dist w u", "apply (rule infdist_proper_attained, auto intro!: proper_Un simp add: geodesic_segment_topology(7))"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper Gzt", "by (meson assms(3) geodesic_segmentI geodesic_segment_topology)"], ["proof (state)\nthis:\n  \\<exists>u\\<in>{x--z} \\<union> Gzt.\n     infdist w ({x--z} \\<union> Gzt) = dist w u\n\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>{x--z} \\<union> Gzt.\n     infdist w ({x--z} \\<union> Gzt) = dist w u", "obtain u where u: \"u \\<in> {x--z} \\<union> Gzt\" \"infdist w ({x--z} \\<union> Gzt) = dist w u\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>{x--z} \\<union> Gzt.\n     infdist w ({x--z} \\<union> Gzt) = dist w u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> {x--z} \\<union> Gzt;\n         infdist w ({x--z} \\<union> Gzt) = dist w u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> {x--z} \\<union> Gzt\n  infdist w ({x--z} \\<union> Gzt) = dist w u\n\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "have \"infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "proof (cases \"u \\<in> {x--z}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n 2. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "case True"], ["proof (state)\nthis:\n  u \\<in> {x--z}\n\ngoal (2 subgoals):\n 1. u \\<in> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n 2. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "have \"infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> infdist u (Gxy \\<union> Gyz)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist u (Gxy \\<union> Gyz \\<union> Gzt)\n    \\<le> infdist u (Gxy \\<union> Gyz)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Gxy \\<union> Gyz \\<subseteq> Gxy \\<union> Gyz \\<union> Gzt\n 2. Gxy \\<union> Gyz \\<noteq> {}", "using assms(1)"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n\ngoal (2 subgoals):\n 1. Gxy \\<union> Gyz \\<subseteq> Gxy \\<union> Gyz \\<union> Gzt\n 2. Gxy \\<union> Gyz \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt)\n  \\<le> infdist u (Gxy \\<union> Gyz)\n\ngoal (2 subgoals):\n 1. u \\<in> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n 2. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt)\n  \\<le> infdist u (Gxy \\<union> Gyz)\n\ngoal (2 subgoals):\n 1. u \\<in> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n 2. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "have \"... \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist u (Gxy \\<union> Gyz) \\<le> 4 * deltaG TYPE('a)", "using thin_triangles[OF geodesic_segment_commute[OF assms(1)] assms(2) _ True]"], ["proof (prove)\nusing this:\n  geodesic_segment_between {x--z} x z \\<Longrightarrow>\n  infdist u (Gxy \\<union> Gyz) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist u (Gxy \\<union> Gyz) \\<le> 4 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  infdist u (Gxy \\<union> Gyz) \\<le> 4 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. u \\<in> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n 2. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "case False"], ["proof (state)\nthis:\n  u \\<notin> {x--z}\n\ngoal (1 subgoal):\n 1. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  u \\<notin> {x--z}", "have *: \"u \\<in> Gzt\""], ["proof (prove)\nusing this:\n  u \\<notin> {x--z}\n\ngoal (1 subgoal):\n 1. u \\<in> Gzt", "using u(1)"], ["proof (prove)\nusing this:\n  u \\<notin> {x--z}\n  u \\<in> {x--z} \\<union> Gzt\n\ngoal (1 subgoal):\n 1. u \\<in> Gzt", "by auto"], ["proof (state)\nthis:\n  u \\<in> Gzt\n\ngoal (1 subgoal):\n 1. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "have \"infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> infdist u Gzt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> infdist u Gzt", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Gzt \\<subseteq> Gxy \\<union> Gyz \\<union> Gzt\n 2. Gzt \\<noteq> {}", "using assms(3)"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gzt z t\n\ngoal (2 subgoals):\n 1. Gzt \\<subseteq> Gxy \\<union> Gyz \\<union> Gzt\n 2. Gzt \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> infdist u Gzt\n\ngoal (1 subgoal):\n 1. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> infdist u Gzt\n\ngoal (1 subgoal):\n 1. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist u Gzt = 0", "using *"], ["proof (prove)\nusing this:\n  u \\<in> Gzt\n\ngoal (1 subgoal):\n 1. infdist u Gzt = 0", "by auto"], ["proof (state)\nthis:\n  infdist u Gzt = 0\n\ngoal (1 subgoal):\n 1. u \\<notin> {x--z} \\<Longrightarrow>\n    infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 0\n\ngoal (1 subgoal):\n 1. infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "using local.delta_nonneg"], ["proof (prove)\nusing this:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 0\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)", "by linarith"], ["proof (state)\nthis:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "moreover"], ["proof (state)\nthis:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "have \"infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> infdist u (Gxy \\<union> Gyz \\<union> Gzt) + dist w u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt)\n    \\<le> infdist u (Gxy \\<union> Gyz \\<union> Gzt) + dist w u", "by (intro mono_intros)"], ["proof (state)\nthis:\n  infdist w (Gxy \\<union> Gyz \\<union> Gzt)\n  \\<le> infdist u (Gxy \\<union> Gyz \\<union> Gzt) + dist w u\n\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "ultimately"], ["proof (chain)\npicking this:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n  infdist w (Gxy \\<union> Gyz \\<union> Gzt)\n  \\<le> infdist u (Gxy \\<union> Gyz \\<union> Gzt) + dist w u", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n  infdist w (Gxy \\<union> Gyz \\<union> Gzt)\n  \\<le> infdist u (Gxy \\<union> Gyz \\<union> Gzt) + dist w u\n\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "using I u(2)"], ["proof (prove)\nusing this:\n  infdist u (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n  infdist w (Gxy \\<union> Gyz \\<union> Gzt)\n  \\<le> infdist u (Gxy \\<union> Gyz \\<union> Gzt) + dist w u\n  infdist w ({x--z} \\<union> Gzt) \\<le> 4 * deltaG TYPE('a)\n  infdist w ({x--z} \\<union> Gzt) = dist w u\n\ngoal (1 subgoal):\n 1. infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  infdist w (Gxy \\<union> Gyz \\<union> Gzt) \\<le> 8 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>There are converses to the above statements: if triangles are thin, or slim, then the space\nis Gromov-hyperbolic, for some $\\delta$. We prove these criteria here, following the proofs in\nGhys (with a simplification in the case of slim triangles.\\<close>"], ["", "text \\<open>The basic result we will use twice below is the following: if points on sides of triangles\nat the same distance of the basepoint are close to each other up to the Gromov product, then the\nspace is hyperbolic. The proof goes as follows. One wants to show that $(x,z)_e \\geq\n\\min((x,y)_e, (y,z)_e) - \\delta = t-\\delta$. On $[ex]$, $[ey]$ and $[ez]$, consider points\n$wx$, $wy$ and $wz$ at distance $t$ of $e$. Then $wx$ and $wy$ are $\\delta$-close by assumption,\nand so are $wy$ and $wz$. Then $wx$ and $wz$ are $2\\delta$-close. One can use these two points\nto express $(x,z)_e$, and the result follows readily.\\<close>"], ["", "lemma (in geodesic_space) controlled_thin_triangles_implies_hyperbolic:\n  assumes \"\\<And>(x::'a) y z t Gxy Gxz. geodesic_segment_between Gxy x y \\<Longrightarrow> geodesic_segment_between Gxz x z \\<Longrightarrow> t \\<in> {0..Gromov_product_at x y z}\n      \\<Longrightarrow> dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t) \\<le> delta\"\n  shows \"Gromov_hyperbolic_subset delta (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset delta UNIV", "proof (rule Gromov_hyperbolic_subsetI2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "fix e x y z::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "define t where \"t = min (Gromov_product_at e x y) (Gromov_product_at e y z)\""], ["proof (state)\nthis:\n  t = min (Gromov_product_at e x y) (Gromov_product_at e y z)\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "define wx where \"wx = geodesic_segment_param {e--x} e t\""], ["proof (state)\nthis:\n  wx = geodesic_segment_param {e--x} e t\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "define wy where \"wy = geodesic_segment_param {e--y} e t\""], ["proof (state)\nthis:\n  wy = geodesic_segment_param {e--y} e t\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "define wz where \"wz = geodesic_segment_param {e--z} e t\""], ["proof (state)\nthis:\n  wz = geodesic_segment_param {e--z} e t\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"dist wx wy \\<le> delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wx wy \\<le> delta", "unfolding wx_def wy_def t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist\n     (geodesic_segment_param {e--x} e\n       (min (Gromov_product_at e x y) (Gromov_product_at e y z)))\n     (geodesic_segment_param {e--y} e\n       (min (Gromov_product_at e x y) (Gromov_product_at e y z)))\n    \\<le> delta", "by (rule assms[of _ _ x _ y], auto)"], ["proof (state)\nthis:\n  dist wx wy \\<le> delta\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"dist wy wz \\<le> delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wy wz \\<le> delta", "unfolding wy_def wz_def t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist\n     (geodesic_segment_param {e--y} e\n       (min (Gromov_product_at e x y) (Gromov_product_at e y z)))\n     (geodesic_segment_param {e--z} e\n       (min (Gromov_product_at e x y) (Gromov_product_at e y z)))\n    \\<le> delta", "by (rule assms[of _ _ y _ z], auto)"], ["proof (state)\nthis:\n  dist wy wz \\<le> delta\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"t + dist wy x = dist e wx + dist wy x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t + dist wy x = dist e wx + dist wy x", "unfolding wx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t + dist wy x = dist e (geodesic_segment_param {e--x} e t) + dist wy x", "apply (auto intro!: geodesic_segment_param_in_geodesic_spaces(6)[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> t\n 2. t \\<le> dist e x", "unfolding t_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> min (Gromov_product_at e x y) (Gromov_product_at e y z)\n 2. min (Gromov_product_at e x y) (Gromov_product_at e y z) \\<le> dist e x", "by (auto, meson Gromov_product_le_dist(1) min.absorb_iff2 min.left_idem order.trans)"], ["proof (state)\nthis:\n  t + dist wy x = dist e wx + dist wy x\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "also"], ["proof (state)\nthis:\n  t + dist wy x = dist e wx + dist wy x\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"... \\<le> dist e wx + (dist wy wx + dist wx x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e wx + dist wy x \\<le> dist e wx + (dist wy wx + dist wx x)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist e wx + dist wy x \\<le> dist e wx + (dist wy wx + dist wx x)\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "also"], ["proof (state)\nthis:\n  dist e wx + dist wy x \\<le> dist e wx + (dist wy wx + dist wx x)\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"... \\<le> dist e wx + (delta + dist wx x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e wx + (dist wy wx + dist wx x)\n    \\<le> dist e wx + (delta + dist wx x)", "using \\<open>dist wx wy \\<le> delta\\<close>"], ["proof (prove)\nusing this:\n  dist wx wy \\<le> delta\n\ngoal (1 subgoal):\n 1. dist e wx + (dist wy wx + dist wx x)\n    \\<le> dist e wx + (delta + dist wx x)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist e wx + (dist wy wx + dist wx x) \\<le> dist e wx + (delta + dist wx x)\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "also"], ["proof (state)\nthis:\n  dist e wx + (dist wy wx + dist wx x) \\<le> dist e wx + (delta + dist wx x)\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"... = delta + dist e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e wx + (delta + dist wx x) = delta + dist e x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e wx + dist wx x = dist e x", "apply (rule geodesic_segment_dist[of \"{e--x}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. geodesic_segment_between {e--x} e x\n 2. wx \\<in> {e--x}", "unfolding wx_def t_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. geodesic_segment_between {e--x} e x\n 2. geodesic_segment_param {e--x} e\n     (min (Gromov_product_at e x y) (Gromov_product_at e y z))\n    \\<in> {e--x}", "by (auto simp add: geodesic_segment_param_in_segment)"], ["proof (state)\nthis:\n  dist e wx + (delta + dist wx x) = delta + dist e x\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "finally"], ["proof (chain)\npicking this:\n  t + dist wy x \\<le> delta + dist e x", "have *: \"t + dist wy x - delta \\<le> dist e x\""], ["proof (prove)\nusing this:\n  t + dist wy x \\<le> delta + dist e x\n\ngoal (1 subgoal):\n 1. t + dist wy x - delta \\<le> dist e x", "by simp"], ["proof (state)\nthis:\n  t + dist wy x - delta \\<le> dist e x\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"t + dist wy z = dist e wz + dist wy z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t + dist wy z = dist e wz + dist wy z", "unfolding wz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t + dist wy z = dist e (geodesic_segment_param {e--z} e t) + dist wy z", "apply (auto intro!: geodesic_segment_param_in_geodesic_spaces(6)[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> t\n 2. t \\<le> dist e z", "unfolding t_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> min (Gromov_product_at e x y) (Gromov_product_at e y z)\n 2. min (Gromov_product_at e x y) (Gromov_product_at e y z) \\<le> dist e z", "by (auto, meson Gromov_product_le_dist(2) min.absorb_iff1 min.right_idem order.trans)"], ["proof (state)\nthis:\n  t + dist wy z = dist e wz + dist wy z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "also"], ["proof (state)\nthis:\n  t + dist wy z = dist e wz + dist wy z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"... \\<le> dist e wz + (dist wy wz + dist wz z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e wz + dist wy z \\<le> dist e wz + (dist wy wz + dist wz z)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist e wz + dist wy z \\<le> dist e wz + (dist wy wz + dist wz z)\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "also"], ["proof (state)\nthis:\n  dist e wz + dist wy z \\<le> dist e wz + (dist wy wz + dist wz z)\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"... \\<le> dist e wz + (delta + dist wz z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e wz + (dist wy wz + dist wz z)\n    \\<le> dist e wz + (delta + dist wz z)", "using \\<open>dist wy wz \\<le> delta\\<close>"], ["proof (prove)\nusing this:\n  dist wy wz \\<le> delta\n\ngoal (1 subgoal):\n 1. dist e wz + (dist wy wz + dist wz z)\n    \\<le> dist e wz + (delta + dist wz z)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist e wz + (dist wy wz + dist wz z) \\<le> dist e wz + (delta + dist wz z)\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "also"], ["proof (state)\nthis:\n  dist e wz + (dist wy wz + dist wz z) \\<le> dist e wz + (delta + dist wz z)\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"... = delta + dist e z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e wz + (delta + dist wz z) = delta + dist e z", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e wz + dist wz z = dist e z", "apply (rule geodesic_segment_dist[of \"{e--z}\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. geodesic_segment_between {e--z} e z\n 2. wz \\<in> {e--z}", "unfolding wz_def t_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. geodesic_segment_between {e--z} e z\n 2. geodesic_segment_param {e--z} e\n     (min (Gromov_product_at e x y) (Gromov_product_at e y z))\n    \\<in> {e--z}", "by (auto simp add: geodesic_segment_param_in_segment)"], ["proof (state)\nthis:\n  dist e wz + (delta + dist wz z) = delta + dist e z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "finally"], ["proof (chain)\npicking this:\n  t + dist wy z \\<le> delta + dist e z", "have \"t + dist wy z - delta \\<le> dist e z\""], ["proof (prove)\nusing this:\n  t + dist wy z \\<le> delta + dist e z\n\ngoal (1 subgoal):\n 1. t + dist wy z - delta \\<le> dist e z", "by simp"], ["proof (state)\nthis:\n  t + dist wy z - delta \\<le> dist e z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "then"], ["proof (chain)\npicking this:\n  t + dist wy z - delta \\<le> dist e z", "have \"(t + dist wy x - delta) + (t + dist wy z - delta) \\<le> dist e x + dist e z\""], ["proof (prove)\nusing this:\n  t + dist wy z - delta \\<le> dist e z\n\ngoal (1 subgoal):\n 1. t + dist wy x - delta + (t + dist wy z - delta)\n    \\<le> dist e x + dist e z", "using *"], ["proof (prove)\nusing this:\n  t + dist wy z - delta \\<le> dist e z\n  t + dist wy x - delta \\<le> dist e x\n\ngoal (1 subgoal):\n 1. t + dist wy x - delta + (t + dist wy z - delta)\n    \\<le> dist e x + dist e z", "by simp"], ["proof (state)\nthis:\n  t + dist wy x - delta + (t + dist wy z - delta) \\<le> dist e x + dist e z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "also"], ["proof (state)\nthis:\n  t + dist wy x - delta + (t + dist wy z - delta) \\<le> dist e x + dist e z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"... = dist x z + 2 * Gromov_product_at e x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e x + dist e z = dist x z + 2 * Gromov_product_at e x z", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist e x + dist e z =\n    dist x z + 2 * ((dist e x + dist e z - dist x z) / 2)", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  dist e x + dist e z = dist x z + 2 * Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "also"], ["proof (state)\nthis:\n  dist e x + dist e z = dist x z + 2 * Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "have \"... \\<le> dist wy x + dist wy z + 2 * Gromov_product_at e x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z + 2 * Gromov_product_at e x z\n    \\<le> dist wy x + dist wy z + 2 * Gromov_product_at e x z", "using metric_space_class.dist_triangle[of x z wy]"], ["proof (prove)\nusing this:\n  dist x z \\<le> dist x wy + dist wy z\n\ngoal (1 subgoal):\n 1. dist x z + 2 * Gromov_product_at e x z\n    \\<le> dist wy x + dist wy z + 2 * Gromov_product_at e x z", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x z + 2 * Gromov_product_at e x z\n  \\<le> dist wy x + dist wy z + 2 * Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "finally"], ["proof (chain)\npicking this:\n  t + dist wy x - delta + (t + dist wy z - delta)\n  \\<le> dist wy x + dist wy z + 2 * Gromov_product_at e x z", "have \"2 * t - 2 * delta \\<le> 2 * Gromov_product_at e x z\""], ["proof (prove)\nusing this:\n  t + dist wy x - delta + (t + dist wy z - delta)\n  \\<le> dist wy x + dist wy z + 2 * Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. 2 * t - 2 * delta \\<le> 2 * Gromov_product_at e x z", "by auto"], ["proof (state)\nthis:\n  2 * t - 2 * delta \\<le> 2 * Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. \\<And>e x y z.\n       \\<lbrakk>e \\<in> UNIV; x \\<in> UNIV; y \\<in> UNIV;\n        z \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> min (Gromov_product_at e x y)\n                          (Gromov_product_at e y z) -\n                         delta\n                         \\<le> Gromov_product_at e x z", "then"], ["proof (chain)\npicking this:\n  2 * t - 2 * delta \\<le> 2 * Gromov_product_at e x z", "show \"min (Gromov_product_at e x y) (Gromov_product_at e y z) - delta \\<le> Gromov_product_at e x z\""], ["proof (prove)\nusing this:\n  2 * t - 2 * delta \\<le> 2 * Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. min (Gromov_product_at e x y) (Gromov_product_at e y z) - delta\n    \\<le> Gromov_product_at e x z", "unfolding t_def"], ["proof (prove)\nusing this:\n  2 * min (Gromov_product_at e x y) (Gromov_product_at e y z) - 2 * delta\n  \\<le> 2 * Gromov_product_at e x z\n\ngoal (1 subgoal):\n 1. min (Gromov_product_at e x y) (Gromov_product_at e y z) - delta\n    \\<le> Gromov_product_at e x z", "by auto"], ["proof (state)\nthis:\n  min (Gromov_product_at e x y) (Gromov_product_at e y z) - delta\n  \\<le> Gromov_product_at e x z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We prove that if triangles are thin, i.e., they satisfy the Rips condition, i.e., every side\nof a triangle is included in the $\\delta$-neighborhood of the union of the other triangles, then\nthe space is hyperbolic. If a point $w$ on $[xy]$ satisfies $d(x,w) < (y,z)_x - \\delta$, then its\nfriend on $[xz] \\cup [yz]$ has to be on $[xz]$, and roughly at the same distance of the origin.\nThen it follows that the point on $[xz]$ with $d(x,w') = d(x,w)$ is close to $w$, as desired.\nIf $d(x,w) \\in [(y,z)_x - \\delta, (y,z)_x)$, we argue in the same way but for the point which\nis closer to $x$ by an amount $\\delta$. Finally, the last case $d(x,w) = (y,z)_x$ follows by\ncontinuity.\\<close>"], ["", "proposition (in geodesic_space) thin_triangles_implies_hyperbolic:\n  assumes \"\\<And>(x::'a) y z w Gxy Gyz Gxz. geodesic_segment_between Gxy x y \\<Longrightarrow> geodesic_segment_between Gxz x z \\<Longrightarrow> geodesic_segment_between Gyz y z\n        \\<Longrightarrow> w \\<in> Gxy \\<Longrightarrow> infdist w (Gxz \\<union> Gyz) \\<le> delta\"\n  shows \"Gromov_hyperbolic_subset (4 * delta) (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (4 * delta) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (4 * delta) UNIV", "obtain x0::'a where True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (True \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  True\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (4 * delta) UNIV", "have \"infdist x0 ({x0} \\<union> {x0}) \\<le> delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x0 ({x0} \\<union> {x0}) \\<le> delta", "by (rule assms[of \"{x0}\" x0 x0 \"{x0}\" x0 \"{x0}\" x0], auto)"], ["proof (state)\nthis:\n  infdist x0 ({x0} \\<union> {x0}) \\<le> delta\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (4 * delta) UNIV", "then"], ["proof (chain)\npicking this:\n  infdist x0 ({x0} \\<union> {x0}) \\<le> delta", "have [simp]: \"delta \\<ge> 0\""], ["proof (prove)\nusing this:\n  infdist x0 ({x0} \\<union> {x0}) \\<le> delta\n\ngoal (1 subgoal):\n 1. 0 \\<le> delta", "using infdist_nonneg"], ["proof (prove)\nusing this:\n  infdist x0 ({x0} \\<union> {x0}) \\<le> delta\n  0 \\<le> infdist ?x ?A\n\ngoal (1 subgoal):\n 1. 0 \\<le> delta", "by auto"], ["proof (state)\nthis:\n  0 \\<le> delta\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (4 * delta) UNIV", "have \"dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t) \\<le> 4 * delta\"\n    if H: \"geodesic_segment_between Gxy x y\" \"geodesic_segment_between Gxz x z\" \"t \\<in> {0..Gromov_product_at x y z}\"\n    for x y z t Gxy Gxz"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have Main: \"dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u) \\<le> 4 * delta\"\n      if \"u \\<in> {delta..<Gromov_product_at x y z}\" for u"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "define wy where \"wy = geodesic_segment_param Gxy x (u-delta)\""], ["proof (state)\nthis:\n  wy = geodesic_segment_param Gxy x (u - delta)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"dist wy (geodesic_segment_param Gxy x u) = abs((u-delta) - u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wy (geodesic_segment_param Gxy x u) = \\<bar>u - delta - u\\<bar>", "unfolding wy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (u - delta))\n     (geodesic_segment_param Gxy x u) =\n    \\<bar>u - delta - u\\<bar>", "apply (rule geodesic_segment_param(7)[OF H(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. u - delta \\<in> {0..dist x y}\n 2. u \\<in> {0..dist x y}", "using that"], ["proof (prove)\nusing this:\n  u \\<in> {delta..<Gromov_product_at x y z}\n\ngoal (2 subgoals):\n 1. u - delta \\<in> {0..dist x y}\n 2. u \\<in> {0..dist x y}", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>delta \\<le> u; u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> u - delta \\<le> dist x y\n 2. \\<lbrakk>delta \\<le> u; u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> u\n 3. \\<lbrakk>delta \\<le> u; u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> u \\<le> dist x y", "using Gromov_product_le_dist(1)[of x y z] \\<open>delta \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  Gromov_product_at x y z \\<le> dist x y\n  0 \\<le> delta\n\ngoal (3 subgoals):\n 1. \\<lbrakk>delta \\<le> u; u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> u - delta \\<le> dist x y\n 2. \\<lbrakk>delta \\<le> u; u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> u\n 3. \\<lbrakk>delta \\<le> u; u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> u \\<le> dist x y", "by linarith+"], ["proof (state)\nthis:\n  dist wy (geodesic_segment_param Gxy x u) = \\<bar>u - delta - u\\<bar>\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "then"], ["proof (chain)\npicking this:\n  dist wy (geodesic_segment_param Gxy x u) = \\<bar>u - delta - u\\<bar>", "have I1: \"dist wy (geodesic_segment_param Gxy x u) = delta\""], ["proof (prove)\nusing this:\n  dist wy (geodesic_segment_param Gxy x u) = \\<bar>u - delta - u\\<bar>\n\ngoal (1 subgoal):\n 1. dist wy (geodesic_segment_param Gxy x u) = delta", "by auto"], ["proof (state)\nthis:\n  dist wy (geodesic_segment_param Gxy x u) = delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"infdist wy (Gxz \\<union> {y--z}) \\<le> delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist wy (Gxz \\<union> {y--z}) \\<le> delta", "unfolding wy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (geodesic_segment_param Gxy x (u - delta)) (Gxz \\<union> {y--z})\n    \\<le> delta", "apply (rule assms[of Gxy x y _ z])"], ["proof (prove)\ngoal (4 subgoals):\n 1. geodesic_segment_between Gxy x y\n 2. geodesic_segment_between Gxz x z\n 3. geodesic_segment_between {y--z} y z\n 4. geodesic_segment_param Gxy x (u - delta) \\<in> Gxy", "using H"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  t \\<in> {0..Gromov_product_at x y z}\n\ngoal (4 subgoals):\n 1. geodesic_segment_between Gxy x y\n 2. geodesic_segment_between Gxz x z\n 3. geodesic_segment_between {y--z} y z\n 4. geodesic_segment_param Gxy x (u - delta) \\<in> Gxy", "by (auto simp add: geodesic_segment_param_in_segment)"], ["proof (state)\nthis:\n  infdist wy (Gxz \\<union> {y--z}) \\<le> delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "moreover"], ["proof (state)\nthis:\n  infdist wy (Gxz \\<union> {y--z}) \\<le> delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"\\<exists>wz \\<in> Gxz \\<union> {y--z}. infdist wy (Gxz \\<union> {y--z}) = dist wy wz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>wz\\<in>Gxz \\<union> {y--z}.\n       infdist wy (Gxz \\<union> {y--z}) = dist wy wz", "apply (rule infdist_proper_attained, intro proper_Un)"], ["proof (prove)\ngoal (3 subgoals):\n 1. proper Gxz\n 2. proper {y--z}\n 3. Gxz \\<union> {y--z} \\<noteq> {}", "using H(2)"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxz x z\n\ngoal (3 subgoals):\n 1. proper Gxz\n 2. proper {y--z}\n 3. Gxz \\<union> {y--z} \\<noteq> {}", "by (auto simp add: geodesic_segment_topology)"], ["proof (state)\nthis:\n  \\<exists>wz\\<in>Gxz \\<union> {y--z}.\n     infdist wy (Gxz \\<union> {y--z}) = dist wy wz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "ultimately"], ["proof (chain)\npicking this:\n  infdist wy (Gxz \\<union> {y--z}) \\<le> delta\n  \\<exists>wz\\<in>Gxz \\<union> {y--z}.\n     infdist wy (Gxz \\<union> {y--z}) = dist wy wz", "obtain wz where wz: \"wz \\<in> Gxz \\<union> {y--z}\" \"dist wy wz \\<le> delta\""], ["proof (prove)\nusing this:\n  infdist wy (Gxz \\<union> {y--z}) \\<le> delta\n  \\<exists>wz\\<in>Gxz \\<union> {y--z}.\n     infdist wy (Gxz \\<union> {y--z}) = dist wy wz\n\ngoal (1 subgoal):\n 1. (\\<And>wz.\n        \\<lbrakk>wz \\<in> Gxz \\<union> {y--z};\n         dist wy wz \\<le> delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  wz \\<in> Gxz \\<union> {y--z}\n  dist wy wz \\<le> delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"dist wz x \\<le> dist wz wy + dist wy x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wz x \\<le> dist wz wy + dist wy x", "by (rule metric_space_class.dist_triangle)"], ["proof (state)\nthis:\n  dist wz x \\<le> dist wz wy + dist wy x\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "also"], ["proof (state)\nthis:\n  dist wz x \\<le> dist wz wy + dist wy x\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"... \\<le> delta + (u-delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wz wy + dist wy x \\<le> delta + (u - delta)", "apply (intro add_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist wz wy \\<le> delta\n 2. dist wy x \\<le> u - delta", "using wz(2)"], ["proof (prove)\nusing this:\n  dist wy wz \\<le> delta\n\ngoal (2 subgoals):\n 1. dist wz wy \\<le> delta\n 2. dist wy x \\<le> u - delta", "unfolding wy_def"], ["proof (prove)\nusing this:\n  dist (geodesic_segment_param Gxy x (u - delta)) wz \\<le> delta\n\ngoal (2 subgoals):\n 1. dist wz (geodesic_segment_param Gxy x (u - delta)) \\<le> delta\n 2. dist (geodesic_segment_param Gxy x (u - delta)) x \\<le> u - delta", "apply (auto simp add: metric_space_class.dist_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wz (geodesic_segment_param Gxy x (u - delta))\n    \\<le> delta \\<Longrightarrow>\n    dist x (geodesic_segment_param Gxy x (u - delta)) \\<le> u - delta", "apply (intro eq_refl geodesic_segment_param(6)[OF H(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wz (geodesic_segment_param Gxy x (u - delta))\n    \\<le> delta \\<Longrightarrow>\n    u - delta \\<in> {0..dist x y}", "using that"], ["proof (prove)\nusing this:\n  u \\<in> {delta..<Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. dist wz (geodesic_segment_param Gxy x (u - delta))\n    \\<le> delta \\<Longrightarrow>\n    u - delta \\<in> {0..dist x y}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist wz (geodesic_segment_param Gxy x (u - delta)) \\<le> delta;\n     delta \\<le> u; u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> u - delta \\<le> dist x y", "by (metis diff_0_right diff_mono dual_order.trans Gromov_product_le_dist(1) less_eq_real_def metric_space_class.dist_commute metric_space_class.zero_le_dist wy_def)"], ["proof (state)\nthis:\n  dist wz wy + dist wy x \\<le> delta + (u - delta)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "finally"], ["proof (chain)\npicking this:\n  dist wz x \\<le> delta + (u - delta)", "have \"dist wz x \\<le> u\""], ["proof (prove)\nusing this:\n  dist wz x \\<le> delta + (u - delta)\n\ngoal (1 subgoal):\n 1. dist wz x \\<le> u", "by auto"], ["proof (state)\nthis:\n  dist wz x \\<le> u\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "also"], ["proof (state)\nthis:\n  dist wz x \\<le> u\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"... < Gromov_product_at x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u < Gromov_product_at x y z", "using that"], ["proof (prove)\nusing this:\n  u \\<in> {delta..<Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. u < Gromov_product_at x y z", "by auto"], ["proof (state)\nthis:\n  u < Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "also"], ["proof (state)\nthis:\n  u < Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"... \\<le> infdist x {y--z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at x y z \\<le> infdist x {y--z}", "by (rule Gromov_product_le_infdist, auto)"], ["proof (state)\nthis:\n  Gromov_product_at x y z \\<le> infdist x {y--z}\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "finally"], ["proof (chain)\npicking this:\n  dist wz x < infdist x {y--z}", "have \"dist x wz < infdist x {y--z}\""], ["proof (prove)\nusing this:\n  dist wz x < infdist x {y--z}\n\ngoal (1 subgoal):\n 1. dist x wz < infdist x {y--z}", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x wz < infdist x {y--z}\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "then"], ["proof (chain)\npicking this:\n  dist x wz < infdist x {y--z}", "have \"wz \\<notin> {y--z}\""], ["proof (prove)\nusing this:\n  dist x wz < infdist x {y--z}\n\ngoal (1 subgoal):\n 1. wz \\<notin> {y--z}", "by (metis add.left_neutral infdist_triangle infdist_zero leD)"], ["proof (state)\nthis:\n  wz \\<notin> {y--z}\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "then"], ["proof (chain)\npicking this:\n  wz \\<notin> {y--z}", "have \"wz \\<in> Gxz\""], ["proof (prove)\nusing this:\n  wz \\<notin> {y--z}\n\ngoal (1 subgoal):\n 1. wz \\<in> Gxz", "using wz"], ["proof (prove)\nusing this:\n  wz \\<notin> {y--z}\n  wz \\<in> Gxz \\<union> {y--z}\n  dist wy wz \\<le> delta\n\ngoal (1 subgoal):\n 1. wz \\<in> Gxz", "by auto"], ["proof (state)\nthis:\n  wz \\<in> Gxz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"u - delta = dist x wy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u - delta = dist x wy", "unfolding wy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u - delta = dist x (geodesic_segment_param Gxy x (u - delta))", "apply (rule geodesic_segment_param(6)[symmetric, OF H(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. u - delta \\<in> {0..dist x y}", "using that"], ["proof (prove)\nusing this:\n  u \\<in> {delta..<Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. u - delta \\<in> {0..dist x y}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>delta \\<le> u; u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> u - delta \\<le> dist x y", "using Gromov_product_le_dist(1)[of x y z] \\<open>delta \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  Gromov_product_at x y z \\<le> dist x y\n  0 \\<le> delta\n\ngoal (1 subgoal):\n 1. \\<lbrakk>delta \\<le> u; u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> u - delta \\<le> dist x y", "by linarith"], ["proof (state)\nthis:\n  u - delta = dist x wy\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "also"], ["proof (state)\nthis:\n  u - delta = dist x wy\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"... \\<le> dist x wz + dist wz wy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wy \\<le> dist x wz + dist wz wy", "by (rule metric_space_class.dist_triangle)"], ["proof (state)\nthis:\n  dist x wy \\<le> dist x wz + dist wz wy\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "also"], ["proof (state)\nthis:\n  dist x wy \\<le> dist x wz + dist wz wy\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"... \\<le> dist x wz + delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wz + dist wz wy \\<le> dist x wz + delta", "using wz(2)"], ["proof (prove)\nusing this:\n  dist wy wz \\<le> delta\n\ngoal (1 subgoal):\n 1. dist x wz + dist wz wy \\<le> dist x wz + delta", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x wz + dist wz wy \\<le> dist x wz + delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "finally"], ["proof (chain)\npicking this:\n  u - delta \\<le> dist x wz + delta", "have \"dist x wz \\<ge> u - 2 * delta\""], ["proof (prove)\nusing this:\n  u - delta \\<le> dist x wz + delta\n\ngoal (1 subgoal):\n 1. u - 2 * delta \\<le> dist x wz", "by auto"], ["proof (state)\nthis:\n  u - 2 * delta \\<le> dist x wz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "define dz where \"dz = dist x wz\""], ["proof (state)\nthis:\n  dz = dist x wz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have *: \"wz = geodesic_segment_param Gxz x dz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wz = geodesic_segment_param Gxz x dz", "unfolding dz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wz = geodesic_segment_param Gxz x (dist x wz)", "using \\<open>wz \\<in> Gxz\\<close> H(2)"], ["proof (prove)\nusing this:\n  wz \\<in> Gxz\n  geodesic_segment_between Gxz x z\n\ngoal (1 subgoal):\n 1. wz = geodesic_segment_param Gxz x (dist x wz)", "by auto"], ["proof (state)\nthis:\n  wz = geodesic_segment_param Gxz x dz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"dist wz (geodesic_segment_param Gxz x u) = abs(dz - u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wz (geodesic_segment_param Gxz x u) = \\<bar>dz - u\\<bar>", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxz x dz)\n     (geodesic_segment_param Gxz x u) =\n    \\<bar>dz - u\\<bar>", "apply (rule geodesic_segment_param(7)[OF H(2)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. dz \\<in> {0..dist x z}\n 2. u \\<in> {0..dist x z}", "unfolding dz_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x wz \\<in> {0..dist x z}\n 2. u \\<in> {0..dist x z}", "using \\<open>dist wz x \\<le> u\\<close> that"], ["proof (prove)\nusing this:\n  dist wz x \\<le> u\n  u \\<in> {delta..<Gromov_product_at x y z}\n\ngoal (2 subgoals):\n 1. dist x wz \\<in> {0..dist x z}\n 2. u \\<in> {0..dist x z}", "apply (auto simp add: metric_space_class.dist_commute)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>dist wz x \\<le> u; delta \\<le> u;\n     u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> dist wz x \\<le> dist x z\n 2. \\<lbrakk>dist wz x \\<le> u; delta \\<le> u;\n     u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> u\n 3. \\<lbrakk>dist wz x \\<le> u; delta \\<le> u;\n     u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> u \\<le> dist x z", "using Gromov_product_le_dist(2)[of x y z] \\<open>delta \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  Gromov_product_at x y z \\<le> dist x z\n  0 \\<le> delta\n\ngoal (3 subgoals):\n 1. \\<lbrakk>dist wz x \\<le> u; delta \\<le> u;\n     u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> dist wz x \\<le> dist x z\n 2. \\<lbrakk>dist wz x \\<le> u; delta \\<le> u;\n     u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> u\n 3. \\<lbrakk>dist wz x \\<le> u; delta \\<le> u;\n     u < Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> u \\<le> dist x z", "by linarith+"], ["proof (state)\nthis:\n  dist wz (geodesic_segment_param Gxz x u) = \\<bar>dz - u\\<bar>\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "also"], ["proof (state)\nthis:\n  dist wz (geodesic_segment_param Gxz x u) = \\<bar>dz - u\\<bar>\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"... \\<le> 2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dz - u\\<bar> \\<le> 2 * delta", "unfolding dz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dist x wz - u\\<bar> \\<le> 2 * delta", "using \\<open>dist wz x \\<le> u\\<close> \\<open>dist x wz \\<ge> u - 2 * delta\\<close>"], ["proof (prove)\nusing this:\n  dist wz x \\<le> u\n  u - 2 * delta \\<le> dist x wz\n\ngoal (1 subgoal):\n 1. \\<bar>dist x wz - u\\<bar> \\<le> 2 * delta", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  \\<bar>dz - u\\<bar> \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "finally"], ["proof (chain)\npicking this:\n  dist wz (geodesic_segment_param Gxz x u) \\<le> 2 * delta", "have I3: \"dist wz (geodesic_segment_param Gxz x u) \\<le> 2 * delta\""], ["proof (prove)\nusing this:\n  dist wz (geodesic_segment_param Gxz x u) \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist wz (geodesic_segment_param Gxz x u) \\<le> 2 * delta", "by simp"], ["proof (state)\nthis:\n  dist wz (geodesic_segment_param Gxz x u) \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n              \\<le> dist (geodesic_segment_param Gxy x u) wy + dist wy wz + dist wz (geodesic_segment_param Gxz x u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> dist (geodesic_segment_param Gxy x u) wy + dist wy wz +\n          dist wz (geodesic_segment_param Gxz x u)", "by (rule dist_triangle4)"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n  \\<le> dist (geodesic_segment_param Gxy x u) wy + dist wy wz +\n        dist wz (geodesic_segment_param Gxz x u)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "also"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n  \\<le> dist (geodesic_segment_param Gxy x u) wy + dist wy wz +\n        dist wz (geodesic_segment_param Gxz x u)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "have \"... \\<le> delta + delta + (2 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) wy + dist wy wz +\n    dist wz (geodesic_segment_param Gxz x u)\n    \\<le> delta + delta + 2 * delta", "using I1 wz(2) I3"], ["proof (prove)\nusing this:\n  dist wy (geodesic_segment_param Gxy x u) = delta\n  dist wy wz \\<le> delta\n  dist wz (geodesic_segment_param Gxz x u) \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) wy + dist wy wz +\n    dist wz (geodesic_segment_param Gxz x u)\n    \\<le> delta + delta + 2 * delta", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x u) wy + dist wy wz +\n  dist wz (geodesic_segment_param Gxz x u)\n  \\<le> delta + delta + 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "finally"], ["proof (chain)\npicking this:\n  dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n  \\<le> delta + delta + 2 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n  \\<le> delta + delta + 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n    \\<le> 4 * delta", "by simp"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x u) (geodesic_segment_param Gxz x u)\n  \\<le> 4 * delta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n  dist (geodesic_segment_param Gxy x ?u) (geodesic_segment_param Gxz x ?u)\n  \\<le> 4 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have \"t \\<in> {0..dist x y}\" \"t \\<in> {0..dist x z}\" \"t \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> {0..dist x y} &&& t \\<in> {0..dist x z} &&& 0 \\<le> t", "using \\<open>t \\<in> {0..Gromov_product_at x y z}\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {0..Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. t \\<in> {0..dist x y} &&& t \\<in> {0..dist x z} &&& 0 \\<le> t", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> t; t \\<le> Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> t \\<le> dist x y\n 2. \\<lbrakk>0 \\<le> t; t \\<le> Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> t \\<le> dist x z", "using Gromov_product_le_dist[of x y z]"], ["proof (prove)\nusing this:\n  Gromov_product_at x y z \\<le> dist x y\n  Gromov_product_at x y z \\<le> dist x z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> t; t \\<le> Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> t \\<le> dist x y\n 2. \\<lbrakk>0 \\<le> t; t \\<le> Gromov_product_at x y z\\<rbrakk>\n    \\<Longrightarrow> t \\<le> dist x z", "by linarith+"], ["proof (state)\nthis:\n  t \\<in> {0..dist x y}\n  t \\<in> {0..dist x z}\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "consider \"t \\<le> delta\" | \"t \\<in> {delta..<Gromov_product_at x y z}\" | \"t = Gromov_product_at x y z \\<and> t > delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<le> delta \\<Longrightarrow> thesis;\n     t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow> thesis;\n     t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \\<open>t \\<in> {0..Gromov_product_at x y z}\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {0..Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<le> delta \\<Longrightarrow> thesis;\n     t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow> thesis;\n     t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (auto, linarith)"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<le> delta \\<Longrightarrow> ?thesis;\n   t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow> ?thesis;\n   t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>t \\<le> delta \\<Longrightarrow> ?thesis;\n   t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow> ?thesis;\n   t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<le> delta \\<Longrightarrow> ?thesis;\n   t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow> ?thesis;\n   t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. t \\<le> delta \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 3. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "case 1"], ["proof (state)\nthis:\n  t \\<le> delta\n\ngoal (3 subgoals):\n 1. t \\<le> delta \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 3. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have \"dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t) \\<le> dist x (geodesic_segment_param Gxy x t) + dist x (geodesic_segment_param Gxz x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> dist x (geodesic_segment_param Gxy x t) +\n          dist x (geodesic_segment_param Gxz x t)", "by (rule metric_space_class.dist_triangle3)"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> dist x (geodesic_segment_param Gxy x t) +\n        dist x (geodesic_segment_param Gxz x t)\n\ngoal (3 subgoals):\n 1. t \\<le> delta \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 3. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "also"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> dist x (geodesic_segment_param Gxy x t) +\n        dist x (geodesic_segment_param Gxz x t)\n\ngoal (3 subgoals):\n 1. t \\<le> delta \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 3. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have \"... = t + t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param Gxy x t) +\n    dist x (geodesic_segment_param Gxz x t) =\n    t + t", "using geodesic_segment_param(6)[OF H(1) \\<open>t \\<in> {0..dist x y}\\<close>] geodesic_segment_param(6)[OF H(2) \\<open>t \\<in> {0..dist x z}\\<close>]"], ["proof (prove)\nusing this:\n  dist x (geodesic_segment_param Gxy x t) = t\n  dist x (geodesic_segment_param Gxz x t) = t\n\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param Gxy x t) +\n    dist x (geodesic_segment_param Gxz x t) =\n    t + t", "by auto"], ["proof (state)\nthis:\n  dist x (geodesic_segment_param Gxy x t) +\n  dist x (geodesic_segment_param Gxz x t) =\n  t + t\n\ngoal (3 subgoals):\n 1. t \\<le> delta \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 3. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "also"], ["proof (state)\nthis:\n  dist x (geodesic_segment_param Gxy x t) +\n  dist x (geodesic_segment_param Gxz x t) =\n  t + t\n\ngoal (3 subgoals):\n 1. t \\<le> delta \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 3. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have \"... \\<le> 4 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t + t \\<le> 4 * delta", "using 1 \\<open>delta \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  t \\<le> delta\n  0 \\<le> delta\n\ngoal (1 subgoal):\n 1. t + t \\<le> 4 * delta", "by linarith"], ["proof (state)\nthis:\n  t + t \\<le> 4 * delta\n\ngoal (3 subgoals):\n 1. t \\<le> delta \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 3. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "finally"], ["proof (chain)\npicking this:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> 4 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> 4 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "by simp"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> 4 * delta\n\ngoal (2 subgoals):\n 1. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "case 2"], ["proof (state)\nthis:\n  t \\<in> {delta..<Gromov_product_at x y z}\n\ngoal (2 subgoals):\n 1. t \\<in> {delta..<Gromov_product_at x y z} \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta\n 2. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "using Main[OF 2]"], ["proof (prove)\nusing this:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> 4 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "by simp"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> 4 * delta\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "case 3"], ["proof (state)\nthis:\n  t = Gromov_product_at x y z \\<and> delta < t\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "text \\<open>In this case, we argue by approximating $t$ by a slightly smaller parameter, for which\n      the result has already been proved above. We need to argue that all functions are continuous\n      on the sets we are considering, which is straightforward but tedious.\\<close>"], ["proof (state)\nthis:\n  t = Gromov_product_at x y z \\<and> delta < t\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "define u::\"nat \\<Rightarrow> real\" where \"u = (\\<lambda>n. t-1/n)\""], ["proof (state)\nthis:\n  u = (\\<lambda>x. t - 1 / real x)\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have \"u \\<longlonglongrightarrow> t - 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<longlonglongrightarrow> t - 0", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. t - 1 / real x) \\<longlonglongrightarrow> t - 0", "by (intro tendsto_intros)"], ["proof (state)\nthis:\n  u \\<longlonglongrightarrow> t - 0\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "then"], ["proof (chain)\npicking this:\n  u \\<longlonglongrightarrow> t - 0", "have \"u \\<longlonglongrightarrow> t\""], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> t - 0\n\ngoal (1 subgoal):\n 1. u \\<longlonglongrightarrow> t", "by simp"], ["proof (state)\nthis:\n  u \\<longlonglongrightarrow> t\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "then"], ["proof (chain)\npicking this:\n  u \\<longlonglongrightarrow> t", "have *: \"eventually (\\<lambda>n. u n > delta) sequentially\""], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> t\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. delta < u n", "using 3"], ["proof (prove)\nusing this:\n  u \\<longlonglongrightarrow> t\n  t = Gromov_product_at x y z \\<and> delta < t\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. delta < u n", "by (auto simp add: order_tendsto_iff)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. delta < u n\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have **: \"eventually (\\<lambda>n. u n \\<ge> 0) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> u n", "apply (rule eventually_elim2[OF *, of \"(\\<lambda>n. delta \\<ge> 0)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. 0 \\<le> delta\n 2. \\<And>n.\n       \\<lbrakk>delta < u n; 0 \\<le> delta\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> u n", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. delta < u n \\<Longrightarrow> 0 \\<le> u n", "using \\<open>delta \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> delta\n\ngoal (1 subgoal):\n 1. \\<And>n. delta < u n \\<Longrightarrow> 0 \\<le> u n", "by linarith"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially. 0 \\<le> u n\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have ***: \"u n \\<le> t\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. u n \\<le> t", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t - 1 / real n \\<le> t", "by auto"], ["proof (state)\nthis:\n  u ?n \\<le> t\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have A: \"eventually (\\<lambda>n. u n \\<in> {delta..<Gromov_product_at x y z}) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       u n \\<in> {delta..<Gromov_product_at x y z}", "apply (auto intro!: eventually_conj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially. delta \\<le> u n\n 2. \\<forall>\\<^sub>F n in sequentially. u n < Gromov_product_at x y z", "apply (rule eventually_mono[OF *], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially. u n < Gromov_product_at x y z", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       t - 1 / real n < Gromov_product_at x y z", "using 3"], ["proof (prove)\nusing this:\n  t = Gromov_product_at x y z \\<and> delta < t\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       t - 1 / real n < Gromov_product_at x y z", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     u n \\<in> {delta..<Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have B: \"eventually (\\<lambda>n. dist (geodesic_segment_param Gxy x (u n)) (geodesic_segment_param Gxz x (u n)) \\<le> 4 * delta) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       dist (geodesic_segment_param Gxy x (u n))\n        (geodesic_segment_param Gxz x (u n))\n       \\<le> 4 * delta", "by (rule eventually_mono[OF A Main], simp)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F n in sequentially.\n     dist (geodesic_segment_param Gxy x (u n))\n      (geodesic_segment_param Gxz x (u n))\n     \\<le> 4 * delta\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "have C: \"(\\<lambda>n. dist (geodesic_segment_param Gxy x (u n)) (geodesic_segment_param Gxz x (u n)))\n            \\<longlonglongrightarrow> dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        dist (geodesic_segment_param Gxy x (u n))\n         (geodesic_segment_param Gxz x (u n)))\n    \\<longlonglongrightarrow> dist (geodesic_segment_param Gxy x t)\n                               (geodesic_segment_param Gxz x t)", "apply (intro tendsto_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>xa. geodesic_segment_param Gxy x (u xa))\n    \\<longlonglongrightarrow> geodesic_segment_param Gxy x t\n 2. (\\<lambda>xa. geodesic_segment_param Gxz x (u xa))\n    \\<longlonglongrightarrow> geodesic_segment_param Gxz x t", "apply (rule continuous_on_tendsto_compose[OF _ \\<open>u \\<longlonglongrightarrow> t\\<close> \\<open>t \\<in> {0..dist x y}\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {0..dist x y} (geodesic_segment_param Gxy x)\n 2. \\<forall>\\<^sub>F xa in sequentially. u xa \\<in> {0..dist x y}\n 3. (\\<lambda>xa. geodesic_segment_param Gxz x (u xa))\n    \\<longlonglongrightarrow> geodesic_segment_param Gxz x t", "apply (simp add: isometry_on_continuous H(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F xa in sequentially. u xa \\<in> {0..dist x y}\n 2. (\\<lambda>xa. geodesic_segment_param Gxz x (u xa))\n    \\<longlonglongrightarrow> geodesic_segment_param Gxz x t", "using ** *** \\<open>t \\<in> {0..dist x y}\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. 0 \\<le> u n\n  u ?n \\<le> t\n  t \\<in> {0..dist x y}\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F xa in sequentially. u xa \\<in> {0..dist x y}\n 2. (\\<lambda>xa. geodesic_segment_param Gxz x (u xa))\n    \\<longlonglongrightarrow> geodesic_segment_param Gxz x t", "apply (simp, intro eventually_conj, simp, meson dual_order.trans eventually_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xa. geodesic_segment_param Gxz x (u xa))\n    \\<longlonglongrightarrow> geodesic_segment_param Gxz x t", "apply (rule continuous_on_tendsto_compose[OF _ \\<open>u \\<longlonglongrightarrow> t\\<close> \\<open>t \\<in> {0..dist x z}\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {0..dist x z} (geodesic_segment_param Gxz x)\n 2. \\<forall>\\<^sub>F xa in sequentially. u xa \\<in> {0..dist x z}", "apply (simp add: isometry_on_continuous H(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xa in sequentially. u xa \\<in> {0..dist x z}", "using ** *** \\<open>t \\<in> {0..dist x z}\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially. 0 \\<le> u n\n  u ?n \\<le> t\n  t \\<in> {0..dist x z}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xa in sequentially. u xa \\<in> {0..dist x z}", "apply (simp, intro eventually_conj, simp, meson dual_order.trans eventually_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      dist (geodesic_segment_param Gxy x (u n))\n       (geodesic_segment_param Gxz x (u n)))\n  \\<longlonglongrightarrow> dist (geodesic_segment_param Gxy x t)\n                             (geodesic_segment_param Gxz x t)\n\ngoal (1 subgoal):\n 1. t = Gromov_product_at x y z \\<and> delta < t \\<Longrightarrow>\n    dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "using B"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F n in sequentially.\n     dist (geodesic_segment_param Gxy x (u n))\n      (geodesic_segment_param Gxz x (u n))\n     \\<le> 4 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "unfolding eventually_sequentially"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        dist (geodesic_segment_param Gxy x (u n))\n         (geodesic_segment_param Gxz x (u n))\n        \\<le> 4 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "using LIMSEQ_le_const2[OF C]"], ["proof (prove)\nusing this:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        dist (geodesic_segment_param Gxy x (u n))\n         (geodesic_segment_param Gxz x (u n))\n        \\<le> 4 * delta\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        dist (geodesic_segment_param Gxy x (u n))\n         (geodesic_segment_param Gxz x (u n))\n        \\<le> ?a \\<Longrightarrow>\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> ?a\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 4 * delta", "by simp"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> 4 * delta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> 4 * delta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z;\n   ?t \\<in> {0..Gromov_product_at ?x ?y ?z}\\<rbrakk>\n  \\<Longrightarrow> dist (geodesic_segment_param ?Gxy ?x ?t)\n                     (geodesic_segment_param ?Gxz ?x ?t)\n                    \\<le> 4 * delta\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (4 * delta) UNIV", "with controlled_thin_triangles_implies_hyperbolic[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y z t Gxy Gxz.\n              \\<lbrakk>geodesic_segment_between Gxy x y;\n               geodesic_segment_between Gxz x z;\n               t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n              \\<Longrightarrow> geodesic_segment_between Gxy x\n                                 (?y1 x y z t Gxy Gxz);\n   \\<And>x y z t Gxy Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z;\n       t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n      \\<Longrightarrow> geodesic_segment_between Gxz x\n                         (?z1 x y z t Gxy Gxz);\n   \\<And>x y z t Gxy Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z;\n       t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n      \\<Longrightarrow> t \\<in> {0..Gromov_product_at x\n                                     (?y1 x y z t Gxy Gxz)\n                                     (?z1 x y z t Gxy Gxz)}\\<rbrakk>\n  \\<Longrightarrow> Gromov_hyperbolic_subset (4 * delta) UNIV\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z;\n   ?t \\<in> {0..Gromov_product_at ?x ?y ?z}\\<rbrakk>\n  \\<Longrightarrow> dist (geodesic_segment_param ?Gxy ?x ?t)\n                     (geodesic_segment_param ?Gxz ?x ?t)\n                    \\<le> 4 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y z t Gxy Gxz.\n              \\<lbrakk>geodesic_segment_between Gxy x y;\n               geodesic_segment_between Gxz x z;\n               t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n              \\<Longrightarrow> geodesic_segment_between Gxy x\n                                 (?y1 x y z t Gxy Gxz);\n   \\<And>x y z t Gxy Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z;\n       t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n      \\<Longrightarrow> geodesic_segment_between Gxz x\n                         (?z1 x y z t Gxy Gxz);\n   \\<And>x y z t Gxy Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z;\n       t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n      \\<Longrightarrow> t \\<in> {0..Gromov_product_at x\n                                     (?y1 x y z t Gxy Gxz)\n                                     (?z1 x y z t Gxy Gxz)}\\<rbrakk>\n  \\<Longrightarrow> Gromov_hyperbolic_subset (4 * delta) UNIV\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z;\n   ?t \\<in> {0..Gromov_product_at ?x ?y ?z}\\<rbrakk>\n  \\<Longrightarrow> dist (geodesic_segment_param ?Gxy ?x ?t)\n                     (geodesic_segment_param ?Gxz ?x ?t)\n                    \\<le> 4 * delta\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (4 * delta) UNIV", "by auto"], ["proof (state)\nthis:\n  Gromov_hyperbolic_subset (4 * delta) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Then, we prove that if triangles are slim (i.e., there is a point that is $\\delta$-close to\nall sides), then the space is hyperbolic. Using the previous statement, we should show that points\non $[xy]$ and $[xz]$ at the same distance $t$ of the origin are close, if $t \\leq (y,z)_x$.\nThere are two steps:\n- for $t = (y,z)_x$, then the two points are in fact close to the middle of the triangle\n(as this point satisfies $d(x,y) = d(x,w) + d(w,y) + O(\\delta)$, and similarly for the other sides,\none gets readily $d(x,w) = (y,z)_w + O(\\delta)$ by expanding the formula for the Gromov product).\nHence, they are close together.\n- For $t < (y,z)_x$, we argue that there are points $y' \\in [xy]$ and $z' \\in [xz]$ for which\n$t = (y',z')_x$, by a continuity argument and the intermediate value theorem.\nThen the result follows from the first step in the triangle $xy'z'$.\n\nThe proof we give is simpler than the one in~\\cite{ghys_hyperbolique}, and gives better constants.\\<close>"], ["", "proposition (in geodesic_space) slim_triangles_implies_hyperbolic:\n  assumes \"\\<And>(x::'a) y z Gxy Gyz Gxz. geodesic_segment_between Gxy x y \\<Longrightarrow> geodesic_segment_between Gxz x z \\<Longrightarrow> geodesic_segment_between Gyz y z\n        \\<Longrightarrow> \\<exists>w. infdist w Gxy \\<le> delta \\<and> infdist w Gxz \\<le> delta \\<and> infdist w Gyz \\<le> delta\"\n  shows \"Gromov_hyperbolic_subset (6 * delta) (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (6 * delta) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (6 * delta) UNIV", "text \\<open>First step: the result is true for $t = (y,z)_x$.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (6 * delta) UNIV", "have Main: \"dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) (geodesic_segment_param Gxz x (Gromov_product_at x y z)) \\<le> 6 * delta\"\n    if H: \"geodesic_segment_between Gxy x y\" \"geodesic_segment_between Gxz x z\"\n    for x y z Gxy Gxz"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "obtain w where w: \"infdist w Gxy \\<le> delta\" \"infdist w Gxz \\<le> delta\" \"infdist w {y--z} \\<le> delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>infdist w Gxy \\<le> delta; infdist w Gxz \\<le> delta;\n         infdist w {y--z} \\<le> delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms[OF H, of \"{y--z}\"]"], ["proof (prove)\nusing this:\n  geodesic_segment_between {y--z} y z \\<Longrightarrow>\n  \\<exists>w.\n     infdist w Gxy \\<le> delta \\<and>\n     infdist w Gxz \\<le> delta \\<and> infdist w {y--z} \\<le> delta\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>infdist w Gxy \\<le> delta; infdist w Gxz \\<le> delta;\n         infdist w {y--z} \\<le> delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  infdist w Gxy \\<le> delta\n  infdist w Gxz \\<le> delta\n  infdist w {y--z} \\<le> delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"\\<exists>wxy \\<in> Gxy. infdist w Gxy = dist w wxy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>wxy\\<in>Gxy. infdist w Gxy = dist w wxy", "apply (rule infdist_proper_attained)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper Gxy\n 2. Gxy \\<noteq> {}", "using H(1)"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n\ngoal (2 subgoals):\n 1. proper Gxy\n 2. Gxy \\<noteq> {}", "by (auto simp add: geodesic_segment_topology)"], ["proof (state)\nthis:\n  \\<exists>wxy\\<in>Gxy. infdist w Gxy = dist w wxy\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "then"], ["proof (chain)\npicking this:\n  \\<exists>wxy\\<in>Gxy. infdist w Gxy = dist w wxy", "obtain wxy where wxy: \"wxy \\<in> Gxy\" \"dist w wxy \\<le> delta\""], ["proof (prove)\nusing this:\n  \\<exists>wxy\\<in>Gxy. infdist w Gxy = dist w wxy\n\ngoal (1 subgoal):\n 1. (\\<And>wxy.\n        \\<lbrakk>wxy \\<in> Gxy; dist w wxy \\<le> delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using w"], ["proof (prove)\nusing this:\n  \\<exists>wxy\\<in>Gxy. infdist w Gxy = dist w wxy\n  infdist w Gxy \\<le> delta\n  infdist w Gxz \\<le> delta\n  infdist w {y--z} \\<le> delta\n\ngoal (1 subgoal):\n 1. (\\<And>wxy.\n        \\<lbrakk>wxy \\<in> Gxy; dist w wxy \\<le> delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  wxy \\<in> Gxy\n  dist w wxy \\<le> delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"\\<exists>wxz \\<in> Gxz. infdist w Gxz = dist w wxz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>wxz\\<in>Gxz. infdist w Gxz = dist w wxz", "apply (rule infdist_proper_attained)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper Gxz\n 2. Gxz \\<noteq> {}", "using H(2)"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxz x z\n\ngoal (2 subgoals):\n 1. proper Gxz\n 2. Gxz \\<noteq> {}", "by (auto simp add: geodesic_segment_topology)"], ["proof (state)\nthis:\n  \\<exists>wxz\\<in>Gxz. infdist w Gxz = dist w wxz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "then"], ["proof (chain)\npicking this:\n  \\<exists>wxz\\<in>Gxz. infdist w Gxz = dist w wxz", "obtain wxz where wxz: \"wxz \\<in> Gxz\" \"dist w wxz \\<le> delta\""], ["proof (prove)\nusing this:\n  \\<exists>wxz\\<in>Gxz. infdist w Gxz = dist w wxz\n\ngoal (1 subgoal):\n 1. (\\<And>wxz.\n        \\<lbrakk>wxz \\<in> Gxz; dist w wxz \\<le> delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using w"], ["proof (prove)\nusing this:\n  \\<exists>wxz\\<in>Gxz. infdist w Gxz = dist w wxz\n  infdist w Gxy \\<le> delta\n  infdist w Gxz \\<le> delta\n  infdist w {y--z} \\<le> delta\n\ngoal (1 subgoal):\n 1. (\\<And>wxz.\n        \\<lbrakk>wxz \\<in> Gxz; dist w wxz \\<le> delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  wxz \\<in> Gxz\n  dist w wxz \\<le> delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"\\<exists>wyz \\<in> {y--z}. infdist w {y--z} = dist w wyz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>wyz\\<in>{y--z}. infdist w {y--z} = dist w wyz", "apply (rule infdist_proper_attained)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper {y--z}\n 2. {y--z} \\<noteq> {}", "by (auto simp add: geodesic_segment_topology)"], ["proof (state)\nthis:\n  \\<exists>wyz\\<in>{y--z}. infdist w {y--z} = dist w wyz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "then"], ["proof (chain)\npicking this:\n  \\<exists>wyz\\<in>{y--z}. infdist w {y--z} = dist w wyz", "obtain wyz where wyz: \"wyz \\<in> {y--z}\" \"dist w wyz \\<le> delta\""], ["proof (prove)\nusing this:\n  \\<exists>wyz\\<in>{y--z}. infdist w {y--z} = dist w wyz\n\ngoal (1 subgoal):\n 1. (\\<And>wyz.\n        \\<lbrakk>wyz \\<in> {y--z}; dist w wyz \\<le> delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using w"], ["proof (prove)\nusing this:\n  \\<exists>wyz\\<in>{y--z}. infdist w {y--z} = dist w wyz\n  infdist w Gxy \\<le> delta\n  infdist w Gxz \\<le> delta\n  infdist w {y--z} \\<le> delta\n\ngoal (1 subgoal):\n 1. (\\<And>wyz.\n        \\<lbrakk>wyz \\<in> {y--z}; dist w wyz \\<le> delta\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  wyz \\<in> {y--z}\n  dist w wyz \\<le> delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have I: \"dist wxy wxz \\<le> 2 * delta\" \"dist wxy wyz \\<le> 2 * delta\" \"dist wxz wyz \\<le> 2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wxy wxz \\<le> 2 * delta &&&\n    dist wxy wyz \\<le> 2 * delta &&& dist wxz wyz \\<le> 2 * delta", "using metric_space_class.dist_triangle[of wxy wxz w] metric_space_class.dist_triangle[of wxy wyz w] metric_space_class.dist_triangle[of wxz wyz w]\n            wxy(2) wyz(2) wxz(2)"], ["proof (prove)\nusing this:\n  dist wxy wxz \\<le> dist wxy w + dist w wxz\n  dist wxy wyz \\<le> dist wxy w + dist w wyz\n  dist wxz wyz \\<le> dist wxz w + dist w wyz\n  dist w wxy \\<le> delta\n  dist w wyz \\<le> delta\n  dist w wxz \\<le> delta\n\ngoal (1 subgoal):\n 1. dist wxy wxz \\<le> 2 * delta &&&\n    dist wxy wyz \\<le> 2 * delta &&& dist wxz wyz \\<le> 2 * delta", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist wxy wxz \\<le> 2 * delta\n  dist wxy wyz \\<le> 2 * delta\n  dist wxz wyz \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "text \\<open>We show that $d(x, wxy)$ is close to the Gromov product of $y$ and $z$ seen from $x$.\n    This follows from the fact that $w$ is essentially on all geodesics, so that everything simplifies\n    when one writes down the Gromov products, leaving only $d(x, w)$ up to $O(\\delta)$.\n    To get the right $O(\\delta)$, one has to be a little bit careful, using the triangular inequality\n    when possible. This means that the computations for the upper and lower bounds are different,\n    making them a little bit tedious, although straightforward.\\<close>"], ["proof (state)\nthis:\n  dist wxy wxz \\<le> 2 * delta\n  dist wxy wyz \\<le> 2 * delta\n  dist wxz wyz \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"dist y wxy -4 * delta + dist wxy z \\<le> dist y wxy - dist wxy wyz + dist wxy z - dist wxy wyz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y wxy - 4 * delta + dist wxy z\n    \\<le> dist y wxy - dist wxy wyz + dist wxy z - dist wxy wyz", "using I"], ["proof (prove)\nusing this:\n  dist wxy wxz \\<le> 2 * delta\n  dist wxy wyz \\<le> 2 * delta\n  dist wxz wyz \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist y wxy - 4 * delta + dist wxy z\n    \\<le> dist y wxy - dist wxy wyz + dist wxy z - dist wxy wyz", "by simp"], ["proof (state)\nthis:\n  dist y wxy - 4 * delta + dist wxy z\n  \\<le> dist y wxy - dist wxy wyz + dist wxy z - dist wxy wyz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist y wxy - 4 * delta + dist wxy z\n  \\<le> dist y wxy - dist wxy wyz + dist wxy z - dist wxy wyz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> dist wyz y + dist wyz z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y wxy - dist wxy wyz + dist wxy z - dist wxy wyz\n    \\<le> dist wyz y + dist wyz z", "using metric_space_class.dist_triangle[of y wxy wyz] metric_space_class.dist_triangle[of wxy z wyz]"], ["proof (prove)\nusing this:\n  dist y wxy \\<le> dist y wyz + dist wyz wxy\n  dist wxy z \\<le> dist wxy wyz + dist wyz z\n\ngoal (1 subgoal):\n 1. dist y wxy - dist wxy wyz + dist wxy z - dist wxy wyz\n    \\<le> dist wyz y + dist wyz z", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist y wxy - dist wxy wyz + dist wxy z - dist wxy wyz\n  \\<le> dist wyz y + dist wyz z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist y wxy - dist wxy wyz + dist wxy z - dist wxy wyz\n  \\<le> dist wyz y + dist wyz z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... = dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wyz y + dist wyz z = dist y z", "using wyz(1)"], ["proof (prove)\nusing this:\n  wyz \\<in> {y--z}\n\ngoal (1 subgoal):\n 1. dist wyz y + dist wyz z = dist y z", "by (metis geodesic_segment_dist local.some_geodesic_is_geodesic_segment(1) metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist wyz y + dist wyz z = dist y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist y wxy - 4 * delta + dist wxy z \\<le> dist y z", "have *: \"dist y wxy + dist wxy z - 4 * delta \\<le> dist y z\""], ["proof (prove)\nusing this:\n  dist y wxy - 4 * delta + dist wxy z \\<le> dist y z\n\ngoal (1 subgoal):\n 1. dist y wxy + dist wxy z - 4 * delta \\<le> dist y z", "by simp"], ["proof (state)\nthis:\n  dist y wxy + dist wxy z - 4 * delta \\<le> dist y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"2 * Gromov_product_at x y z = dist x y + dist x z - dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Gromov_product_at x y z = dist x y + dist x z - dist y z", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ((dist x y + dist x z - dist y z) / 2) =\n    dist x y + dist x z - dist y z", "by simp"], ["proof (state)\nthis:\n  2 * Gromov_product_at x y z = dist x y + dist x z - dist y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  2 * Gromov_product_at x y z = dist x y + dist x z - dist y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> dist x wxy + dist wxy y + dist x wxy + dist wxy z - (dist y wxy + dist wxy z - 4 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y + dist x z - dist y z\n    \\<le> dist x wxy + dist wxy y + dist x wxy + dist wxy z -\n          (dist y wxy + dist wxy z - 4 * delta)", "using metric_space_class.dist_triangle[of x y wxy] metric_space_class.dist_triangle[of x z wxy] *"], ["proof (prove)\nusing this:\n  dist x y \\<le> dist x wxy + dist wxy y\n  dist x z \\<le> dist x wxy + dist wxy z\n  dist y wxy + dist wxy z - 4 * delta \\<le> dist y z\n\ngoal (1 subgoal):\n 1. dist x y + dist x z - dist y z\n    \\<le> dist x wxy + dist wxy y + dist x wxy + dist wxy z -\n          (dist y wxy + dist wxy z - 4 * delta)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x y + dist x z - dist y z\n  \\<le> dist x wxy + dist wxy y + dist x wxy + dist wxy z -\n        (dist y wxy + dist wxy z - 4 * delta)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist x y + dist x z - dist y z\n  \\<le> dist x wxy + dist wxy y + dist x wxy + dist wxy z -\n        (dist y wxy + dist wxy z - 4 * delta)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... = 2 * dist x wxy + 4 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wxy + dist wxy y + dist x wxy + dist wxy z -\n    (dist y wxy + dist wxy z - 4 * delta) =\n    2 * dist x wxy + 4 * delta", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x wxy + dist wxy y + dist x wxy + dist wxy z -\n  (dist y wxy + dist wxy z - 4 * delta) =\n  2 * dist x wxy + 4 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * Gromov_product_at x y z \\<le> 2 * dist x wxy + 4 * delta", "have A: \"Gromov_product_at x y z \\<le> dist x wxy + 2 * delta\""], ["proof (prove)\nusing this:\n  2 * Gromov_product_at x y z \\<le> 2 * dist x wxy + 4 * delta\n\ngoal (1 subgoal):\n 1. Gromov_product_at x y z \\<le> dist x wxy + 2 * delta", "by simp"], ["proof (state)\nthis:\n  Gromov_product_at x y z \\<le> dist x wxy + 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"dist x wxy -4 * delta + dist wxy z \\<le> dist x wxy - dist wxy wxz + dist wxy z - dist wxy wxz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wxy - 4 * delta + dist wxy z\n    \\<le> dist x wxy - dist wxy wxz + dist wxy z - dist wxy wxz", "using I"], ["proof (prove)\nusing this:\n  dist wxy wxz \\<le> 2 * delta\n  dist wxy wyz \\<le> 2 * delta\n  dist wxz wyz \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist x wxy - 4 * delta + dist wxy z\n    \\<le> dist x wxy - dist wxy wxz + dist wxy z - dist wxy wxz", "by simp"], ["proof (state)\nthis:\n  dist x wxy - 4 * delta + dist wxy z\n  \\<le> dist x wxy - dist wxy wxz + dist wxy z - dist wxy wxz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist x wxy - 4 * delta + dist wxy z\n  \\<le> dist x wxy - dist wxy wxz + dist wxy z - dist wxy wxz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> dist wxz x + dist wxz z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wxy - dist wxy wxz + dist wxy z - dist wxy wxz\n    \\<le> dist wxz x + dist wxz z", "using metric_space_class.dist_triangle[of x wxy wxz] metric_space_class.dist_triangle[of wxy z wxz]"], ["proof (prove)\nusing this:\n  dist x wxy \\<le> dist x wxz + dist wxz wxy\n  dist wxy z \\<le> dist wxy wxz + dist wxz z\n\ngoal (1 subgoal):\n 1. dist x wxy - dist wxy wxz + dist wxy z - dist wxy wxz\n    \\<le> dist wxz x + dist wxz z", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x wxy - dist wxy wxz + dist wxy z - dist wxy wxz\n  \\<le> dist wxz x + dist wxz z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist x wxy - dist wxy wxz + dist wxy z - dist wxy wxz\n  \\<le> dist wxz x + dist wxz z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... = dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wxz x + dist wxz z = dist x z", "using wxz(1) H(2)"], ["proof (prove)\nusing this:\n  wxz \\<in> Gxz\n  geodesic_segment_between Gxz x z\n\ngoal (1 subgoal):\n 1. dist wxz x + dist wxz z = dist x z", "by (metis geodesic_segment_dist metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist wxz x + dist wxz z = dist x z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist x wxy - 4 * delta + dist wxy z \\<le> dist x z", "have *: \"dist x wxy + dist wxy z - 4 * delta \\<le> dist x z\""], ["proof (prove)\nusing this:\n  dist x wxy - 4 * delta + dist wxy z \\<le> dist x z\n\ngoal (1 subgoal):\n 1. dist x wxy + dist wxy z - 4 * delta \\<le> dist x z", "by simp"], ["proof (state)\nthis:\n  dist x wxy + dist wxy z - 4 * delta \\<le> dist x z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"2 * dist x wxy - 4 * delta = (dist x wxy + dist wxy y) + (dist x wxy + dist wxy z - 4 * delta) - (dist y wxy + dist wxy z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * dist x wxy - 4 * delta =\n    dist x wxy + dist wxy y + (dist x wxy + dist wxy z - 4 * delta) -\n    (dist y wxy + dist wxy z)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  2 * dist x wxy - 4 * delta =\n  dist x wxy + dist wxy y + (dist x wxy + dist wxy z - 4 * delta) -\n  (dist y wxy + dist wxy z)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  2 * dist x wxy - 4 * delta =\n  dist x wxy + dist wxy y + (dist x wxy + dist wxy z - 4 * delta) -\n  (dist y wxy + dist wxy z)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> dist x y + dist x z - dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wxy + dist wxy y + (dist x wxy + dist wxy z - 4 * delta) -\n    (dist y wxy + dist wxy z)\n    \\<le> dist x y + dist x z - dist y z", "using * metric_space_class.dist_triangle[of y z wxy] geodesic_segment_dist[OF H(1) wxy(1)]"], ["proof (prove)\nusing this:\n  dist x wxy + dist wxy z - 4 * delta \\<le> dist x z\n  dist y z \\<le> dist y wxy + dist wxy z\n  dist x wxy + dist wxy y = dist x y\n\ngoal (1 subgoal):\n 1. dist x wxy + dist wxy y + (dist x wxy + dist wxy z - 4 * delta) -\n    (dist y wxy + dist wxy z)\n    \\<le> dist x y + dist x z - dist y z", "by auto"], ["proof (state)\nthis:\n  dist x wxy + dist wxy y + (dist x wxy + dist wxy z - 4 * delta) -\n  (dist y wxy + dist wxy z)\n  \\<le> dist x y + dist x z - dist y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist x wxy + dist wxy y + (dist x wxy + dist wxy z - 4 * delta) -\n  (dist y wxy + dist wxy z)\n  \\<le> dist x y + dist x z - dist y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... = 2 * Gromov_product_at x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y + dist x z - dist y z = 2 * Gromov_product_at x y z", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y + dist x z - dist y z =\n    2 * ((dist x y + dist x z - dist y z) / 2)", "by simp"], ["proof (state)\nthis:\n  dist x y + dist x z - dist y z = 2 * Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * dist x wxy - 4 * delta \\<le> 2 * Gromov_product_at x y z", "have B: \"Gromov_product_at x y z \\<ge> dist x wxy - 2 * delta\""], ["proof (prove)\nusing this:\n  2 * dist x wxy - 4 * delta \\<le> 2 * Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. dist x wxy - 2 * delta \\<le> Gromov_product_at x y z", "by simp"], ["proof (state)\nthis:\n  dist x wxy - 2 * delta \\<le> Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "define dy where \"dy = dist x wxy\""], ["proof (state)\nthis:\n  dy = dist x wxy\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have *: \"wxy = geodesic_segment_param Gxy x dy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wxy = geodesic_segment_param Gxy x dy", "unfolding dy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wxy = geodesic_segment_param Gxy x (dist x wxy)", "using \\<open>wxy \\<in> Gxy\\<close> H(1)"], ["proof (prove)\nusing this:\n  wxy \\<in> Gxy\n  geodesic_segment_between Gxy x y\n\ngoal (1 subgoal):\n 1. wxy = geodesic_segment_param Gxy x (dist x wxy)", "by auto"], ["proof (state)\nthis:\n  wxy = geodesic_segment_param Gxy x dy\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z)) = abs(dy - Gromov_product_at x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z)) =\n    \\<bar>dy - Gromov_product_at x y z\\<bar>", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x dy)\n     (geodesic_segment_param Gxy x (Gromov_product_at x y z)) =\n    \\<bar>dy - Gromov_product_at x y z\\<bar>", "apply (rule geodesic_segment_param(7)[OF H(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. dy \\<in> {0..dist x y}\n 2. Gromov_product_at x y z \\<in> {0..dist x y}", "unfolding dy_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x wxy \\<in> {0..dist x y}\n 2. Gromov_product_at x y z \\<in> {0..dist x y}", "using that geodesic_segment_dist_le[OF H(1) wxy(1), of x]"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  x \\<in> Gxy \\<Longrightarrow> dist wxy x \\<le> dist x y\n\ngoal (2 subgoals):\n 1. dist x wxy \\<in> {0..dist x y}\n 2. Gromov_product_at x y z \\<in> {0..dist x y}", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z)) =\n  \\<bar>dy - Gromov_product_at x y z\\<bar>\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z)) =\n  \\<bar>dy - Gromov_product_at x y z\\<bar>\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> 2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dy - Gromov_product_at x y z\\<bar> \\<le> 2 * delta", "using A B"], ["proof (prove)\nusing this:\n  Gromov_product_at x y z \\<le> dist x wxy + 2 * delta\n  dist x wxy - 2 * delta \\<le> Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. \\<bar>dy - Gromov_product_at x y z\\<bar> \\<le> 2 * delta", "unfolding dy_def"], ["proof (prove)\nusing this:\n  Gromov_product_at x y z \\<le> dist x wxy + 2 * delta\n  dist x wxy - 2 * delta \\<le> Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. \\<bar>dist x wxy - Gromov_product_at x y z\\<bar> \\<le> 2 * delta", "by auto"], ["proof (state)\nthis:\n  \\<bar>dy - Gromov_product_at x y z\\<bar> \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n  \\<le> 2 * delta", "have Iy: \"dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z)) \\<le> 2 * delta\""], ["proof (prove)\nusing this:\n  dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n  \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n    \\<le> 2 * delta", "by simp"], ["proof (state)\nthis:\n  dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n  \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "text \\<open>We need the same estimate for $wxz$. The proof is exactly the same, copied and pasted.\n    It would be better to have a separate statement, but since its assumptions would be rather\n    cumbersome I decided to keep the two proofs.\\<close>"], ["proof (state)\nthis:\n  dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n  \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"dist z wxz -4 * delta + dist wxz y \\<le> dist z wxz - dist wxz wyz + dist wxz y - dist wxz wyz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z wxz - 4 * delta + dist wxz y\n    \\<le> dist z wxz - dist wxz wyz + dist wxz y - dist wxz wyz", "using I"], ["proof (prove)\nusing this:\n  dist wxy wxz \\<le> 2 * delta\n  dist wxy wyz \\<le> 2 * delta\n  dist wxz wyz \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist z wxz - 4 * delta + dist wxz y\n    \\<le> dist z wxz - dist wxz wyz + dist wxz y - dist wxz wyz", "by simp"], ["proof (state)\nthis:\n  dist z wxz - 4 * delta + dist wxz y\n  \\<le> dist z wxz - dist wxz wyz + dist wxz y - dist wxz wyz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist z wxz - 4 * delta + dist wxz y\n  \\<le> dist z wxz - dist wxz wyz + dist wxz y - dist wxz wyz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> dist wyz z + dist wyz y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z wxz - dist wxz wyz + dist wxz y - dist wxz wyz\n    \\<le> dist wyz z + dist wyz y", "using metric_space_class.dist_triangle[of z wxz wyz] metric_space_class.dist_triangle[of wxz y wyz]"], ["proof (prove)\nusing this:\n  dist z wxz \\<le> dist z wyz + dist wyz wxz\n  dist wxz y \\<le> dist wxz wyz + dist wyz y\n\ngoal (1 subgoal):\n 1. dist z wxz - dist wxz wyz + dist wxz y - dist wxz wyz\n    \\<le> dist wyz z + dist wyz y", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist z wxz - dist wxz wyz + dist wxz y - dist wxz wyz\n  \\<le> dist wyz z + dist wyz y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist z wxz - dist wxz wyz + dist wxz y - dist wxz wyz\n  \\<le> dist wyz z + dist wyz y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... = dist z y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wyz z + dist wyz y = dist z y", "using \\<open>dist wyz y + dist wyz z = dist y z\\<close>"], ["proof (prove)\nusing this:\n  dist wyz y + dist wyz z = dist y z\n\ngoal (1 subgoal):\n 1. dist wyz z + dist wyz y = dist z y", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist wyz z + dist wyz y = dist z y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist z wxz - 4 * delta + dist wxz y \\<le> dist z y", "have *: \"dist z wxz + dist wxz y - 4 * delta \\<le> dist z y\""], ["proof (prove)\nusing this:\n  dist z wxz - 4 * delta + dist wxz y \\<le> dist z y\n\ngoal (1 subgoal):\n 1. dist z wxz + dist wxz y - 4 * delta \\<le> dist z y", "by simp"], ["proof (state)\nthis:\n  dist z wxz + dist wxz y - 4 * delta \\<le> dist z y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"2 * Gromov_product_at x y z = dist x z + dist x y - dist z y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Gromov_product_at x y z = dist x z + dist x y - dist z y", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ((dist x y + dist x z - dist y z) / 2) =\n    dist x z + dist x y - dist z y", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  2 * Gromov_product_at x y z = dist x z + dist x y - dist z y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  2 * Gromov_product_at x y z = dist x z + dist x y - dist z y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> dist x wxz + dist wxz z + dist x wxz + dist wxz y - (dist z wxz + dist wxz y - 4 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z + dist x y - dist z y\n    \\<le> dist x wxz + dist wxz z + dist x wxz + dist wxz y -\n          (dist z wxz + dist wxz y - 4 * delta)", "using metric_space_class.dist_triangle[of x z wxz] metric_space_class.dist_triangle[of x y wxz] *"], ["proof (prove)\nusing this:\n  dist x z \\<le> dist x wxz + dist wxz z\n  dist x y \\<le> dist x wxz + dist wxz y\n  dist z wxz + dist wxz y - 4 * delta \\<le> dist z y\n\ngoal (1 subgoal):\n 1. dist x z + dist x y - dist z y\n    \\<le> dist x wxz + dist wxz z + dist x wxz + dist wxz y -\n          (dist z wxz + dist wxz y - 4 * delta)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x z + dist x y - dist z y\n  \\<le> dist x wxz + dist wxz z + dist x wxz + dist wxz y -\n        (dist z wxz + dist wxz y - 4 * delta)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist x z + dist x y - dist z y\n  \\<le> dist x wxz + dist wxz z + dist x wxz + dist wxz y -\n        (dist z wxz + dist wxz y - 4 * delta)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... = 2 * dist x wxz + 4 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wxz + dist wxz z + dist x wxz + dist wxz y -\n    (dist z wxz + dist wxz y - 4 * delta) =\n    2 * dist x wxz + 4 * delta", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x wxz + dist wxz z + dist x wxz + dist wxz y -\n  (dist z wxz + dist wxz y - 4 * delta) =\n  2 * dist x wxz + 4 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * Gromov_product_at x y z \\<le> 2 * dist x wxz + 4 * delta", "have A: \"Gromov_product_at x y z \\<le> dist x wxz + 2 * delta\""], ["proof (prove)\nusing this:\n  2 * Gromov_product_at x y z \\<le> 2 * dist x wxz + 4 * delta\n\ngoal (1 subgoal):\n 1. Gromov_product_at x y z \\<le> dist x wxz + 2 * delta", "by simp"], ["proof (state)\nthis:\n  Gromov_product_at x y z \\<le> dist x wxz + 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"dist x wxz -4 * delta + dist wxz y \\<le> dist x wxz - dist wxz wxy + dist wxz y - dist wxz wxy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wxz - 4 * delta + dist wxz y\n    \\<le> dist x wxz - dist wxz wxy + dist wxz y - dist wxz wxy", "using I"], ["proof (prove)\nusing this:\n  dist wxy wxz \\<le> 2 * delta\n  dist wxy wyz \\<le> 2 * delta\n  dist wxz wyz \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist x wxz - 4 * delta + dist wxz y\n    \\<le> dist x wxz - dist wxz wxy + dist wxz y - dist wxz wxy", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x wxz - 4 * delta + dist wxz y\n  \\<le> dist x wxz - dist wxz wxy + dist wxz y - dist wxz wxy\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist x wxz - 4 * delta + dist wxz y\n  \\<le> dist x wxz - dist wxz wxy + dist wxz y - dist wxz wxy\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> dist wxy x + dist wxy y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wxz - dist wxz wxy + dist wxz y - dist wxz wxy\n    \\<le> dist wxy x + dist wxy y", "using metric_space_class.dist_triangle[of x wxz wxy] metric_space_class.dist_triangle[of wxz y wxy]"], ["proof (prove)\nusing this:\n  dist x wxz \\<le> dist x wxy + dist wxy wxz\n  dist wxz y \\<le> dist wxz wxy + dist wxy y\n\ngoal (1 subgoal):\n 1. dist x wxz - dist wxz wxy + dist wxz y - dist wxz wxy\n    \\<le> dist wxy x + dist wxy y", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x wxz - dist wxz wxy + dist wxz y - dist wxz wxy\n  \\<le> dist wxy x + dist wxy y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist x wxz - dist wxz wxy + dist wxz y - dist wxz wxy\n  \\<le> dist wxy x + dist wxy y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... = dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wxy x + dist wxy y = dist x y", "using wxy(1) H(1)"], ["proof (prove)\nusing this:\n  wxy \\<in> Gxy\n  geodesic_segment_between Gxy x y\n\ngoal (1 subgoal):\n 1. dist wxy x + dist wxy y = dist x y", "by (metis geodesic_segment_dist metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist wxy x + dist wxy y = dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist x wxz - 4 * delta + dist wxz y \\<le> dist x y", "have *: \"dist x wxz + dist wxz y - 4 * delta \\<le> dist x y\""], ["proof (prove)\nusing this:\n  dist x wxz - 4 * delta + dist wxz y \\<le> dist x y\n\ngoal (1 subgoal):\n 1. dist x wxz + dist wxz y - 4 * delta \\<le> dist x y", "by simp"], ["proof (state)\nthis:\n  dist x wxz + dist wxz y - 4 * delta \\<le> dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"2 * dist x wxz - 4 * delta = (dist x wxz + dist wxz z) + (dist x wxz + dist wxz y - 4 * delta) - (dist z wxz + dist wxz y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * dist x wxz - 4 * delta =\n    dist x wxz + dist wxz z + (dist x wxz + dist wxz y - 4 * delta) -\n    (dist z wxz + dist wxz y)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  2 * dist x wxz - 4 * delta =\n  dist x wxz + dist wxz z + (dist x wxz + dist wxz y - 4 * delta) -\n  (dist z wxz + dist wxz y)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  2 * dist x wxz - 4 * delta =\n  dist x wxz + dist wxz z + (dist x wxz + dist wxz y - 4 * delta) -\n  (dist z wxz + dist wxz y)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> dist x z + dist x y - dist z y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x wxz + dist wxz z + (dist x wxz + dist wxz y - 4 * delta) -\n    (dist z wxz + dist wxz y)\n    \\<le> dist x z + dist x y - dist z y", "using * metric_space_class.dist_triangle[of z y wxz] geodesic_segment_dist[OF H(2) wxz(1)]"], ["proof (prove)\nusing this:\n  dist x wxz + dist wxz y - 4 * delta \\<le> dist x y\n  dist z y \\<le> dist z wxz + dist wxz y\n  dist x wxz + dist wxz z = dist x z\n\ngoal (1 subgoal):\n 1. dist x wxz + dist wxz z + (dist x wxz + dist wxz y - 4 * delta) -\n    (dist z wxz + dist wxz y)\n    \\<le> dist x z + dist x y - dist z y", "by auto"], ["proof (state)\nthis:\n  dist x wxz + dist wxz z + (dist x wxz + dist wxz y - 4 * delta) -\n  (dist z wxz + dist wxz y)\n  \\<le> dist x z + dist x y - dist z y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist x wxz + dist wxz z + (dist x wxz + dist wxz y - 4 * delta) -\n  (dist z wxz + dist wxz y)\n  \\<le> dist x z + dist x y - dist z y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... = 2 * Gromov_product_at x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z + dist x y - dist z y = 2 * Gromov_product_at x y z", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z + dist x y - dist z y =\n    2 * ((dist x y + dist x z - dist y z) / 2)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x z + dist x y - dist z y = 2 * Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * dist x wxz - 4 * delta \\<le> 2 * Gromov_product_at x y z", "have B: \"Gromov_product_at x y z \\<ge> dist x wxz - 2 * delta\""], ["proof (prove)\nusing this:\n  2 * dist x wxz - 4 * delta \\<le> 2 * Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. dist x wxz - 2 * delta \\<le> Gromov_product_at x y z", "by simp"], ["proof (state)\nthis:\n  dist x wxz - 2 * delta \\<le> Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "define dz where \"dz = dist x wxz\""], ["proof (state)\nthis:\n  dz = dist x wxz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have *: \"wxz = geodesic_segment_param Gxz x dz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wxz = geodesic_segment_param Gxz x dz", "unfolding dz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wxz = geodesic_segment_param Gxz x (dist x wxz)", "using \\<open>wxz \\<in> Gxz\\<close> H(2)"], ["proof (prove)\nusing this:\n  wxz \\<in> Gxz\n  geodesic_segment_between Gxz x z\n\ngoal (1 subgoal):\n 1. wxz = geodesic_segment_param Gxz x (dist x wxz)", "by auto"], ["proof (state)\nthis:\n  wxz = geodesic_segment_param Gxz x dz\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z)) = abs(dz - Gromov_product_at x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z)) =\n    \\<bar>dz - Gromov_product_at x y z\\<bar>", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxz x dz)\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z)) =\n    \\<bar>dz - Gromov_product_at x y z\\<bar>", "apply (rule geodesic_segment_param(7)[OF H(2)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. dz \\<in> {0..dist x z}\n 2. Gromov_product_at x y z \\<in> {0..dist x z}", "unfolding dz_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x wxz \\<in> {0..dist x z}\n 2. Gromov_product_at x y z \\<in> {0..dist x z}", "using that geodesic_segment_dist_le[OF H(2) wxz(1), of x]"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  x \\<in> Gxz \\<Longrightarrow> dist wxz x \\<le> dist x z\n\ngoal (2 subgoals):\n 1. dist x wxz \\<in> {0..dist x z}\n 2. Gromov_product_at x y z \\<in> {0..dist x z}", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z)) =\n  \\<bar>dz - Gromov_product_at x y z\\<bar>\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z)) =\n  \\<bar>dz - Gromov_product_at x y z\\<bar>\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> 2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dz - Gromov_product_at x y z\\<bar> \\<le> 2 * delta", "using A B"], ["proof (prove)\nusing this:\n  Gromov_product_at x y z \\<le> dist x wxz + 2 * delta\n  dist x wxz - 2 * delta \\<le> Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. \\<bar>dz - Gromov_product_at x y z\\<bar> \\<le> 2 * delta", "unfolding dz_def"], ["proof (prove)\nusing this:\n  Gromov_product_at x y z \\<le> dist x wxz + 2 * delta\n  dist x wxz - 2 * delta \\<le> Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. \\<bar>dist x wxz - Gromov_product_at x y z\\<bar> \\<le> 2 * delta", "by auto"], ["proof (state)\nthis:\n  \\<bar>dz - Gromov_product_at x y z\\<bar> \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> 2 * delta", "have Iz: \"dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z)) \\<le> 2 * delta\""], ["proof (prove)\nusing this:\n  dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 2 * delta", "by simp"], ["proof (state)\nthis:\n  dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n      \\<le> dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) wxy + dist wxy wxz + dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n           wxy +\n          dist wxy wxz +\n          dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))", "by (rule dist_triangle4)"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n   (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) wxy +\n        dist wxy wxz +\n        dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "also"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n   (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) wxy +\n        dist wxy wxz +\n        dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "have \"... \\<le> 2 * delta + 2 * delta + 2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) wxy +\n    dist wxy wxz +\n    dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 2 * delta + 2 * delta + 2 * delta", "using Iy Iz I"], ["proof (prove)\nusing this:\n  dist wxy (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n  \\<le> 2 * delta\n  dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> 2 * delta\n  dist wxy wxz \\<le> 2 * delta\n  dist wxy wyz \\<le> 2 * delta\n  dist wxz wyz \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) wxy +\n    dist wxy wxz +\n    dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 2 * delta + 2 * delta + 2 * delta", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x (Gromov_product_at x y z)) wxy +\n  dist wxy wxz +\n  dist wxz (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> 2 * delta + 2 * delta + 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n   (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> 2 * delta + 2 * delta + 2 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n   (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> 2 * delta + 2 * delta + 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n     (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n    \\<le> 6 * delta", "by simp"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x (Gromov_product_at x y z))\n   (geodesic_segment_param Gxz x (Gromov_product_at x y z))\n  \\<le> 6 * delta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z\\<rbrakk>\n  \\<Longrightarrow> dist\n                     (geodesic_segment_param ?Gxy ?x\n                       (Gromov_product_at ?x ?y ?z))\n                     (geodesic_segment_param ?Gxz ?x\n                       (Gromov_product_at ?x ?y ?z))\n                    \\<le> 6 * delta\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (6 * delta) UNIV", "text \\<open>Second step: the result is true for $t \\leq (y,z)_x$, by a continuity argument and a\n  reduction to the first step.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z\\<rbrakk>\n  \\<Longrightarrow> dist\n                     (geodesic_segment_param ?Gxy ?x\n                       (Gromov_product_at ?x ?y ?z))\n                     (geodesic_segment_param ?Gxz ?x\n                       (Gromov_product_at ?x ?y ?z))\n                    \\<le> 6 * delta\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (6 * delta) UNIV", "have \"dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t) \\<le> 6 * delta\"\n    if H: \"geodesic_segment_between Gxy x y\" \"geodesic_segment_between Gxz x z\" \"t \\<in> {0..Gromov_product_at x y z}\"\n    for x y z t Gxy Gxz"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "define ys where \"ys = (\\<lambda>s. geodesic_segment_param Gxy x (s * dist x y))\""], ["proof (state)\nthis:\n  ys = (\\<lambda>s. geodesic_segment_param Gxy x (s * dist x y))\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "define zs where \"zs = (\\<lambda>s. geodesic_segment_param Gxz x (s * dist x z))\""], ["proof (state)\nthis:\n  zs = (\\<lambda>s. geodesic_segment_param Gxz x (s * dist x z))\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "define F where \"F = (\\<lambda>s. Gromov_product_at x (ys s) (zs s))\""], ["proof (state)\nthis:\n  F = (\\<lambda>s. Gromov_product_at x (ys s) (zs s))\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "have \"\\<exists>s. 0 \\<le> s \\<and> s \\<le> 1 \\<and> F s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s\\<ge>0. s \\<le> 1 \\<and> F s = t", "proof (rule IVT')"], ["proof (state)\ngoal (4 subgoals):\n 1. F 0 \\<le> t\n 2. t \\<le> F 1\n 3. 0 \\<le> 1\n 4. continuous_on {0..1} F", "show \"F 0 \\<le> t\" \"t \\<le> F 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F 0 \\<le> t &&& t \\<le> F 1", "unfolding F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at x (ys 0) (zs 0) \\<le> t &&&\n    t \\<le> Gromov_product_at x (ys 1) (zs 1)", "using that"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  t \\<in> {0..Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. Gromov_product_at x (ys 0) (zs 0) \\<le> t &&&\n    t \\<le> Gromov_product_at x (ys 1) (zs 1)", "unfolding ys_def zs_def"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  t \\<in> {0..Gromov_product_at x y z}\n\ngoal (1 subgoal):\n 1. Gromov_product_at x (geodesic_segment_param Gxy x (0 * dist x y))\n     (geodesic_segment_param Gxz x (0 * dist x z))\n    \\<le> t &&&\n    t \\<le> Gromov_product_at x\n             (geodesic_segment_param Gxy x (1 * dist x y))\n             (geodesic_segment_param Gxz x (1 * dist x z))", "by (auto simp add: Gromov_product_e_x_x)"], ["proof (state)\nthis:\n  F 0 \\<le> t\n  t \\<le> F 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> 1\n 2. continuous_on {0..1} F", "show \"continuous_on {0..1} F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1} F", "unfolding F_def Gromov_product_at_def ys_def zs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..1}\n     (\\<lambda>s.\n         (dist x (geodesic_segment_param Gxy x (s * dist x y)) +\n          dist x (geodesic_segment_param Gxz x (s * dist x z)) -\n          dist (geodesic_segment_param Gxy x (s * dist x y))\n           (geodesic_segment_param Gxz x (s * dist x z))) /\n         2)", "apply (intro continuous_intros continuous_on_compose2[of \"{0..dist x y}\" _ _ \"\\<lambda>t. t * dist x y\"] continuous_on_compose2[of \"{0..dist x z}\" _ _ \"\\<lambda>t. t * dist x z\"])"], ["proof (prove)\ngoal (9 subgoals):\n 1. continuous_on {0..dist x y} (geodesic_segment_param Gxy x)\n 2. (\\<lambda>t. t * dist x y) ` {0..1} \\<subseteq> {0..dist x y}\n 3. continuous_on {0..dist x z} (geodesic_segment_param Gxz x)\n 4. (\\<lambda>t. t * dist x z) ` {0..1} \\<subseteq> {0..dist x z}\n 5. continuous_on {0..dist x y} (geodesic_segment_param Gxy x)\n 6. (\\<lambda>t. t * dist x y) ` {0..1} \\<subseteq> {0..dist x y}\n 7. continuous_on {0..dist x z} (geodesic_segment_param Gxz x)\n 8. (\\<lambda>t. t * dist x z) ` {0..1} \\<subseteq> {0..dist x z}\n 9. \\<forall>s\\<in>{0..1}. 2 \\<noteq> 0", "apply (auto intro!: isometry_on_continuous geodesic_segment_param(4) that)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; t \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> t * dist x y \\<le> dist x y\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> t; t \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> t * dist x z \\<le> dist x z\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> t; t \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> t * dist x y \\<le> dist x y\n 4. \\<And>t.\n       \\<lbrakk>0 \\<le> t; t \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> t * dist x z \\<le> dist x z", "using metric_space_class.zero_le_dist mult_left_le_one_le"], ["proof (prove)\nusing this:\n  0 \\<le> dist ?x ?y\n  \\<lbrakk>(0::?'a) \\<le> ?x; (0::?'a) \\<le> ?y; ?y \\<le> (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?y * ?x \\<le> ?x\n\ngoal (4 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>0 \\<le> t; t \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> t * dist x y \\<le> dist x y\n 2. \\<And>t.\n       \\<lbrakk>0 \\<le> t; t \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> t * dist x z \\<le> dist x z\n 3. \\<And>t.\n       \\<lbrakk>0 \\<le> t; t \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> t * dist x y \\<le> dist x y\n 4. \\<And>t.\n       \\<lbrakk>0 \\<le> t; t \\<le> 1\\<rbrakk>\n       \\<Longrightarrow> t * dist x z \\<le> dist x z", "by blast+"], ["proof (state)\nthis:\n  continuous_on {0..1} F\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1", "qed (simp)"], ["proof (state)\nthis:\n  \\<exists>s\\<ge>0. s \\<le> 1 \\<and> F s = t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "then"], ["proof (chain)\npicking this:\n  \\<exists>s\\<ge>0. s \\<le> 1 \\<and> F s = t", "obtain s where s: \"s \\<in> {0..1}\" \"t = Gromov_product_at x (ys s) (zs s)\""], ["proof (prove)\nusing this:\n  \\<exists>s\\<ge>0. s \\<le> 1 \\<and> F s = t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> {0..1};\n         t = Gromov_product_at x (ys s) (zs s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding F_def"], ["proof (prove)\nusing this:\n  \\<exists>s\\<ge>0. s \\<le> 1 \\<and> Gromov_product_at x (ys s) (zs s) = t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> {0..1};\n         t = Gromov_product_at x (ys s) (zs s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> {0..1}\n  t = Gromov_product_at x (ys s) (zs s)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "have a: \"x = geodesic_segment_param Gxy x 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = geodesic_segment_param Gxy x 0", "using H(1)"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n\ngoal (1 subgoal):\n 1. x = geodesic_segment_param Gxy x 0", "by auto"], ["proof (state)\nthis:\n  x = geodesic_segment_param Gxy x 0\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "have b: \"x = geodesic_segment_param Gxz x 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = geodesic_segment_param Gxz x 0", "using H(2)"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxz x z\n\ngoal (1 subgoal):\n 1. x = geodesic_segment_param Gxz x 0", "by auto"], ["proof (state)\nthis:\n  x = geodesic_segment_param Gxz x 0\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "have dy: \"dist x (ys s) = s * dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (ys s) = s * dist x y", "unfolding ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param Gxy x (s * dist x y)) = s * dist x y", "apply (rule geodesic_segment_param[OF H(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s * dist x y \\<in> {0..dist x y}", "using s(1)"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. s * dist x y \\<in> {0..dist x y}", "by (auto simp add: mult_left_le_one_le)"], ["proof (state)\nthis:\n  dist x (ys s) = s * dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "have dz: \"dist x (zs s) = s * dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (zs s) = s * dist x z", "unfolding zs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param Gxz x (s * dist x z)) = s * dist x z", "apply (rule geodesic_segment_param[OF H(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. s * dist x z \\<in> {0..dist x z}", "using s(1)"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (1 subgoal):\n 1. s * dist x z \\<in> {0..dist x z}", "by (auto simp add: mult_left_le_one_le)"], ["proof (state)\nthis:\n  dist x (zs s) = s * dist x z\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "define Gxy2 where \"Gxy2 = geodesic_subsegment Gxy x 0 (s * dist x y)\""], ["proof (state)\nthis:\n  Gxy2 = geodesic_subsegment Gxy x 0 (s * dist x y)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "define Gxz2 where \"Gxz2 = geodesic_subsegment Gxz x 0 (s * dist x z)\""], ["proof (state)\nthis:\n  Gxz2 = geodesic_subsegment Gxz x 0 (s * dist x z)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "have \"dist (geodesic_segment_param Gxy2 x t) (geodesic_segment_param Gxz2 x t) \\<le> 6 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy2 x t) (geodesic_segment_param Gxz2 x t)\n    \\<le> 6 * delta", "unfolding s(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy2 x (Gromov_product_at x (ys s) (zs s)))\n     (geodesic_segment_param Gxz2 x (Gromov_product_at x (ys s) (zs s)))\n    \\<le> 6 * delta", "proof (rule Main)"], ["proof (state)\ngoal (2 subgoals):\n 1. geodesic_segment_between Gxy2 x (ys s)\n 2. geodesic_segment_between Gxz2 x (zs s)", "show \"geodesic_segment_between Gxy2 x (ys s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between Gxy2 x (ys s)", "apply (subst a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between Gxy2 (geodesic_segment_param Gxy x 0) (ys s)", "unfolding Gxy2_def ys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (geodesic_subsegment Gxy x 0 (s * dist x y))\n     (geodesic_segment_param Gxy x 0)\n     (geodesic_segment_param Gxy x (s * dist x y))", "apply (rule geodesic_subsegment[OF H(1)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x y\n 3. s * dist x y \\<le> dist x y", "using s(1)"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (3 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x y\n 3. s * dist x y \\<le> dist x y", "by (auto simp add: mult_left_le_one_le)"], ["proof (state)\nthis:\n  geodesic_segment_between Gxy2 x (ys s)\n\ngoal (1 subgoal):\n 1. geodesic_segment_between Gxz2 x (zs s)", "show \"geodesic_segment_between Gxz2 x (zs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between Gxz2 x (zs s)", "apply (subst b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between Gxz2 (geodesic_segment_param Gxz x 0) (zs s)", "unfolding Gxz2_def zs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (geodesic_subsegment Gxz x 0 (s * dist x z))\n     (geodesic_segment_param Gxz x 0)\n     (geodesic_segment_param Gxz x (s * dist x z))", "apply (rule geodesic_subsegment[OF H(2)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x z\n 3. s * dist x z \\<le> dist x z", "using s(1)"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n\ngoal (3 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x z\n 3. s * dist x z \\<le> dist x z", "by (auto simp add: mult_left_le_one_le)"], ["proof (state)\nthis:\n  geodesic_segment_between Gxz2 x (zs s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy2 x t) (geodesic_segment_param Gxz2 x t)\n  \\<le> 6 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "moreover"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy2 x t) (geodesic_segment_param Gxz2 x t)\n  \\<le> 6 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "have \"geodesic_segment_param Gxy2 x (t-0) = geodesic_segment_param Gxy x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gxy2 x (t - 0) = geodesic_segment_param Gxy x t", "apply (subst a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gxy2 (geodesic_segment_param Gxy x 0) (t - 0) =\n    geodesic_segment_param Gxy x t", "unfolding Gxy2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param (geodesic_subsegment Gxy x 0 (s * dist x y))\n     (geodesic_segment_param Gxy x 0) (t - 0) =\n    geodesic_segment_param Gxy x t", "apply (rule geodesic_subsegment(3)[OF H(1)])"], ["proof (prove)\ngoal (5 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x y\n 3. s * dist x y \\<le> dist x y\n 4. 0 \\<le> t\n 5. t \\<le> s * dist x y", "using s(1) H(3)"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n  t \\<in> {0..Gromov_product_at x y z}\n\ngoal (5 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x y\n 3. s * dist x y \\<le> dist x y\n 4. 0 \\<le> t\n 5. t \\<le> s * dist x y", "unfolding s(2)"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n  Gromov_product_at x (ys s) (zs s) \\<in> {0..Gromov_product_at x y z}\n\ngoal (5 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x y\n 3. s * dist x y \\<le> dist x y\n 4. 0 \\<le> Gromov_product_at x (ys s) (zs s)\n 5. Gromov_product_at x (ys s) (zs s) \\<le> s * dist x y", "apply (auto simp add: mult_left_le_one_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Gromov_product_at x (ys s) (zs s)\n             \\<le> Gromov_product_at x y z;\n     0 \\<le> s; s \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> Gromov_product_at x (ys s) (zs s) \\<le> s * dist x y", "unfolding dy[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Gromov_product_at x (ys s) (zs s)\n             \\<le> Gromov_product_at x y z;\n     0 \\<le> s; s \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> Gromov_product_at x (ys s) (zs s) \\<le> dist x (ys s)", "by (rule Gromov_product_le_dist)"], ["proof (state)\nthis:\n  geodesic_segment_param Gxy2 x (t - 0) = geodesic_segment_param Gxy x t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "moreover"], ["proof (state)\nthis:\n  geodesic_segment_param Gxy2 x (t - 0) = geodesic_segment_param Gxy x t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "have \"geodesic_segment_param Gxz2 x (t-0) = geodesic_segment_param Gxz x t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gxz2 x (t - 0) = geodesic_segment_param Gxz x t", "apply (subst b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param Gxz2 (geodesic_segment_param Gxz x 0) (t - 0) =\n    geodesic_segment_param Gxz x t", "unfolding Gxz2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param (geodesic_subsegment Gxz x 0 (s * dist x z))\n     (geodesic_segment_param Gxz x 0) (t - 0) =\n    geodesic_segment_param Gxz x t", "apply (rule geodesic_subsegment(3)[OF H(2)])"], ["proof (prove)\ngoal (5 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x z\n 3. s * dist x z \\<le> dist x z\n 4. 0 \\<le> t\n 5. t \\<le> s * dist x z", "using s(1) H(3)"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n  t \\<in> {0..Gromov_product_at x y z}\n\ngoal (5 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x z\n 3. s * dist x z \\<le> dist x z\n 4. 0 \\<le> t\n 5. t \\<le> s * dist x z", "unfolding s(2)"], ["proof (prove)\nusing this:\n  s \\<in> {0..1}\n  Gromov_product_at x (ys s) (zs s) \\<in> {0..Gromov_product_at x y z}\n\ngoal (5 subgoals):\n 1. 0 \\<le> 0\n 2. 0 \\<le> s * dist x z\n 3. s * dist x z \\<le> dist x z\n 4. 0 \\<le> Gromov_product_at x (ys s) (zs s)\n 5. Gromov_product_at x (ys s) (zs s) \\<le> s * dist x z", "apply (auto simp add: mult_left_le_one_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Gromov_product_at x (ys s) (zs s)\n             \\<le> Gromov_product_at x y z;\n     0 \\<le> s; s \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> Gromov_product_at x (ys s) (zs s) \\<le> s * dist x z", "unfolding dz[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Gromov_product_at x (ys s) (zs s)\n             \\<le> Gromov_product_at x y z;\n     0 \\<le> s; s \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> Gromov_product_at x (ys s) (zs s) \\<le> dist x (zs s)", "by (rule Gromov_product_le_dist)"], ["proof (state)\nthis:\n  geodesic_segment_param Gxz2 x (t - 0) = geodesic_segment_param Gxz x t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "ultimately"], ["proof (chain)\npicking this:\n  dist (geodesic_segment_param Gxy2 x t) (geodesic_segment_param Gxz2 x t)\n  \\<le> 6 * delta\n  geodesic_segment_param Gxy2 x (t - 0) = geodesic_segment_param Gxy x t\n  geodesic_segment_param Gxz2 x (t - 0) = geodesic_segment_param Gxz x t", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (geodesic_segment_param Gxy2 x t) (geodesic_segment_param Gxz2 x t)\n  \\<le> 6 * delta\n  geodesic_segment_param Gxy2 x (t - 0) = geodesic_segment_param Gxy x t\n  geodesic_segment_param Gxz2 x (t - 0) = geodesic_segment_param Gxz x t\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n    \\<le> 6 * delta", "by simp"], ["proof (state)\nthis:\n  dist (geodesic_segment_param Gxy x t) (geodesic_segment_param Gxz x t)\n  \\<le> 6 * delta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z;\n   ?t \\<in> {0..Gromov_product_at ?x ?y ?z}\\<rbrakk>\n  \\<Longrightarrow> dist (geodesic_segment_param ?Gxy ?x ?t)\n                     (geodesic_segment_param ?Gxz ?x ?t)\n                    \\<le> 6 * delta\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (6 * delta) UNIV", "with controlled_thin_triangles_implies_hyperbolic[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y z t Gxy Gxz.\n              \\<lbrakk>geodesic_segment_between Gxy x y;\n               geodesic_segment_between Gxz x z;\n               t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n              \\<Longrightarrow> geodesic_segment_between Gxy x\n                                 (?y1 x y z t Gxy Gxz);\n   \\<And>x y z t Gxy Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z;\n       t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n      \\<Longrightarrow> geodesic_segment_between Gxz x\n                         (?z1 x y z t Gxy Gxz);\n   \\<And>x y z t Gxy Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z;\n       t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n      \\<Longrightarrow> t \\<in> {0..Gromov_product_at x\n                                     (?y1 x y z t Gxy Gxz)\n                                     (?z1 x y z t Gxy Gxz)}\\<rbrakk>\n  \\<Longrightarrow> Gromov_hyperbolic_subset (6 * delta) UNIV\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z;\n   ?t \\<in> {0..Gromov_product_at ?x ?y ?z}\\<rbrakk>\n  \\<Longrightarrow> dist (geodesic_segment_param ?Gxy ?x ?t)\n                     (geodesic_segment_param ?Gxz ?x ?t)\n                    \\<le> 6 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y z t Gxy Gxz.\n              \\<lbrakk>geodesic_segment_between Gxy x y;\n               geodesic_segment_between Gxz x z;\n               t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n              \\<Longrightarrow> geodesic_segment_between Gxy x\n                                 (?y1 x y z t Gxy Gxz);\n   \\<And>x y z t Gxy Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z;\n       t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n      \\<Longrightarrow> geodesic_segment_between Gxz x\n                         (?z1 x y z t Gxy Gxz);\n   \\<And>x y z t Gxy Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z;\n       t \\<in> {0..Gromov_product_at x y z}\\<rbrakk>\n      \\<Longrightarrow> t \\<in> {0..Gromov_product_at x\n                                     (?y1 x y z t Gxy Gxz)\n                                     (?z1 x y z t Gxy Gxz)}\\<rbrakk>\n  \\<Longrightarrow> Gromov_hyperbolic_subset (6 * delta) UNIV\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z;\n   ?t \\<in> {0..Gromov_product_at ?x ?y ?z}\\<rbrakk>\n  \\<Longrightarrow> dist (geodesic_segment_param ?Gxy ?x ?t)\n                     (geodesic_segment_param ?Gxz ?x ?t)\n                    \\<le> 6 * delta\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (6 * delta) UNIV", "by auto"], ["proof (state)\nthis:\n  Gromov_hyperbolic_subset (6 * delta) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Metric trees\\<close>"], ["", "text \\<open>Metric trees have several equivalent definitions. The simplest one is probably that it\nis a geodesic space in which the union of two geodesic segments intersecting only at one endpoint is\nstill a geodesic segment.\n\nMetric trees are Gromov hyperbolic, with $\\delta = 0$.\\<close>"], ["", "class metric_tree = geodesic_space +\n  assumes geod_union: \"geodesic_segment_between G x y \\<Longrightarrow> geodesic_segment_between H y z \\<Longrightarrow> G \\<inter> H = {y} \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z\""], ["", "text \\<open>We will now show that the real line is a metric tree, by identifying its geodesic\nsegments, i.e., the compact intervals.\\<close>"], ["", "lemma geodesic_segment_between_real:\n  assumes \"x \\<le> (y::real)\"\n  shows \"geodesic_segment_between (G::real set) x y = (G = {x..y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between G x y = (G = {x..y})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. geodesic_segment_between G x y \\<Longrightarrow> G = {x..y}\n 2. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "assume H: \"geodesic_segment_between G x y\""], ["proof (state)\nthis:\n  geodesic_segment_between G x y\n\ngoal (2 subgoals):\n 1. geodesic_segment_between G x y \\<Longrightarrow> G = {x..y}\n 2. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "then"], ["proof (chain)\npicking this:\n  geodesic_segment_between G x y", "have \"connected G\" \"x \\<in> G\" \"y \\<in> G\""], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n\ngoal (1 subgoal):\n 1. connected G &&& x \\<in> G &&& y \\<in> G", "using geodesic_segment_topology(2) geodesic_segmentI geodesic_segment_endpoints"], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n  geodesic_segment ?G \\<Longrightarrow> connected ?G\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> geodesic_segment ?G\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> ?x \\<in> ?G\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> ?y \\<in> ?G\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> ?G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. connected G &&& x \\<in> G &&& y \\<in> G", "by auto"], ["proof (state)\nthis:\n  connected G\n  x \\<in> G\n  y \\<in> G\n\ngoal (2 subgoals):\n 1. geodesic_segment_between G x y \\<Longrightarrow> G = {x..y}\n 2. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "then"], ["proof (chain)\npicking this:\n  connected G\n  x \\<in> G\n  y \\<in> G", "have *: \"{x..y} \\<subseteq> G\""], ["proof (prove)\nusing this:\n  connected G\n  x \\<in> G\n  y \\<in> G\n\ngoal (1 subgoal):\n 1. {x..y} \\<subseteq> G", "by (simp add: connected_contains_Icc)"], ["proof (state)\nthis:\n  {x..y} \\<subseteq> G\n\ngoal (2 subgoals):\n 1. geodesic_segment_between G x y \\<Longrightarrow> G = {x..y}\n 2. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "moreover"], ["proof (state)\nthis:\n  {x..y} \\<subseteq> G\n\ngoal (2 subgoals):\n 1. geodesic_segment_between G x y \\<Longrightarrow> G = {x..y}\n 2. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "have \"G \\<subseteq> {x..y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<subseteq> {x..y}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> G \\<Longrightarrow> xa \\<in> {x..y}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> G \\<Longrightarrow> xa \\<in> {x..y}", "assume \"s \\<in> G\""], ["proof (state)\nthis:\n  s \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> G \\<Longrightarrow> xa \\<in> {x..y}", "have \"abs(s-x) + abs(s-y) = abs(x-y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>s - x\\<bar> + \\<bar>s - y\\<bar> = \\<bar>x - y\\<bar>", "using geodesic_segment_dist[OF H \\<open>s \\<in> G\\<close>]"], ["proof (prove)\nusing this:\n  dist x s + dist s y = dist x y\n\ngoal (1 subgoal):\n 1. \\<bar>s - x\\<bar> + \\<bar>s - y\\<bar> = \\<bar>x - y\\<bar>", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  \\<bar>x - s\\<bar> + \\<bar>s - y\\<bar> = \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>s - x\\<bar> + \\<bar>s - y\\<bar> = \\<bar>x - y\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>s - x\\<bar> + \\<bar>s - y\\<bar> = \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>xa. xa \\<in> G \\<Longrightarrow> xa \\<in> {x..y}", "then"], ["proof (chain)\npicking this:\n  \\<bar>s - x\\<bar> + \\<bar>s - y\\<bar> = \\<bar>x - y\\<bar>", "show \"s \\<in> {x..y}\""], ["proof (prove)\nusing this:\n  \\<bar>s - x\\<bar> + \\<bar>s - y\\<bar> = \\<bar>x - y\\<bar>\n\ngoal (1 subgoal):\n 1. s \\<in> {x..y}", "using \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>s - x\\<bar> + \\<bar>s - y\\<bar> = \\<bar>x - y\\<bar>\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. s \\<in> {x..y}", "by auto"], ["proof (state)\nthis:\n  s \\<in> {x..y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G \\<subseteq> {x..y}\n\ngoal (2 subgoals):\n 1. geodesic_segment_between G x y \\<Longrightarrow> G = {x..y}\n 2. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "ultimately"], ["proof (chain)\npicking this:\n  {x..y} \\<subseteq> G\n  G \\<subseteq> {x..y}", "show \"G = {x..y}\""], ["proof (prove)\nusing this:\n  {x..y} \\<subseteq> G\n  G \\<subseteq> {x..y}\n\ngoal (1 subgoal):\n 1. G = {x..y}", "by auto"], ["proof (state)\nthis:\n  G = {x..y}\n\ngoal (1 subgoal):\n 1. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "assume H: \"G = {x..y}\""], ["proof (state)\nthis:\n  G = {x..y}\n\ngoal (1 subgoal):\n 1. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "define g where \"g = (\\<lambda>t. t + x)\""], ["proof (state)\nthis:\n  g = (\\<lambda>t. t + x)\n\ngoal (1 subgoal):\n 1. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "have \"g 0 = x \\<and> g (dist x y) = y \\<and> isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g 0 = x \\<and>\n    g (dist x y) = y \\<and>\n    isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}", "unfolding g_def isometry_on_def H"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + x = x \\<and>\n    dist x y + x = y \\<and>\n    (\\<forall>xa\\<in>{0..dist x y}.\n        \\<forall>y\\<in>{0..dist x y}.\n           dist (xa + x) (y + x) = dist xa y) \\<and>\n    {x..y} = (\\<lambda>t. t + x) ` {0..dist x y}", "using \\<open>x \\<le> y\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. 0 + x = x \\<and>\n    dist x y + x = y \\<and>\n    (\\<forall>xa\\<in>{0..dist x y}.\n        \\<forall>y\\<in>{0..dist x y}.\n           dist (xa + x) (y + x) = dist xa y) \\<and>\n    {x..y} = (\\<lambda>t. t + x) ` {0..dist x y}", "by (auto simp add: dist_real_def)"], ["proof (state)\nthis:\n  g 0 = x \\<and>\n  g (dist x y) = y \\<and>\n  isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}\n\ngoal (1 subgoal):\n 1. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "then"], ["proof (chain)\npicking this:\n  g 0 = x \\<and>\n  g (dist x y) = y \\<and>\n  isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}", "have \"\\<exists>g. g 0 = x \\<and> g (dist x y) = y \\<and> isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}\""], ["proof (prove)\nusing this:\n  g 0 = x \\<and>\n  g (dist x y) = y \\<and>\n  isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       g 0 = x \\<and>\n       g (dist x y) = y \\<and>\n       isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}", "by auto"], ["proof (state)\nthis:\n  \\<exists>g.\n     g 0 = x \\<and>\n     g (dist x y) = y \\<and>\n     isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}\n\ngoal (1 subgoal):\n 1. G = {x..y} \\<Longrightarrow> geodesic_segment_between G x y", "then"], ["proof (chain)\npicking this:\n  \\<exists>g.\n     g 0 = x \\<and>\n     g (dist x y) = y \\<and>\n     isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}", "show \"geodesic_segment_between G x y\""], ["proof (prove)\nusing this:\n  \\<exists>g.\n     g 0 = x \\<and>\n     g (dist x y) = y \\<and>\n     isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}\n\ngoal (1 subgoal):\n 1. geodesic_segment_between G x y", "unfolding geodesic_segment_between_def"], ["proof (prove)\nusing this:\n  \\<exists>g.\n     g 0 = x \\<and>\n     g (dist x y) = y \\<and>\n     isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       g 0 = x \\<and>\n       g (dist x y) = y \\<and>\n       isometry_on {0..dist x y} g \\<and> G = g ` {0..dist x y}", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between G x y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma geodesic_segment_between_real':\n  \"{x--y} = {min x y..max x (y::real)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x--y} = {min x y..max x y}", "by (metis geodesic_segment_between_real geodesic_segment_commute some_geodesic_is_geodesic_segment(1) max_def min.cobounded1 min_def)"], ["", "lemma geodesic_segment_real:\n  \"geodesic_segment (G::real set) = (\\<exists>x y. x \\<le> y \\<and> G = {x..y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment G = (\\<exists>x y. x \\<le> y \\<and> G = {x..y})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. geodesic_segment G \\<Longrightarrow>\n    \\<exists>x y. x \\<le> y \\<and> G = {x..y}\n 2. \\<exists>x y. x \\<le> y \\<and> G = {x..y} \\<Longrightarrow>\n    geodesic_segment G", "assume \"geodesic_segment G\""], ["proof (state)\nthis:\n  geodesic_segment G\n\ngoal (2 subgoals):\n 1. geodesic_segment G \\<Longrightarrow>\n    \\<exists>x y. x \\<le> y \\<and> G = {x..y}\n 2. \\<exists>x y. x \\<le> y \\<and> G = {x..y} \\<Longrightarrow>\n    geodesic_segment G", "then"], ["proof (chain)\npicking this:\n  geodesic_segment G", "obtain x y where *: \"geodesic_segment_between G x y\""], ["proof (prove)\nusing this:\n  geodesic_segment G\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        geodesic_segment_between G x y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding geodesic_segment_def"], ["proof (prove)\nusing this:\n  \\<exists>x. Ex (geodesic_segment_between G x)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        geodesic_segment_between G x y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between G x y\n\ngoal (2 subgoals):\n 1. geodesic_segment G \\<Longrightarrow>\n    \\<exists>x y. x \\<le> y \\<and> G = {x..y}\n 2. \\<exists>x y. x \\<le> y \\<and> G = {x..y} \\<Longrightarrow>\n    geodesic_segment G", "have \"(x \\<le> y \\<and> G = {x..y}) \\<or> (y \\<le> x \\<and> G = {y..x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}", "apply (rule le_cases[of x y])"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}\n 2. y \\<le> x \\<Longrightarrow>\n    x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}", "using geodesic_segment_between_real * geodesic_segment_commute"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow>\n  geodesic_segment_between ?G ?x ?y = (?G = {?x..?y})\n  geodesic_segment_between G x y\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow>\n  geodesic_segment_between ?G ?y ?x\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow>\n    x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}\n 2. y \\<le> x \\<Longrightarrow>\n    x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow>\n    x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}", "using geodesic_segment_between_real * geodesic_segment_commute"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow>\n  geodesic_segment_between ?G ?x ?y = (?G = {?x..?y})\n  geodesic_segment_between G x y\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow>\n  geodesic_segment_between ?G ?y ?x\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<Longrightarrow>\n    x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}", "by metis"], ["proof (state)\nthis:\n  x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}\n\ngoal (2 subgoals):\n 1. geodesic_segment G \\<Longrightarrow>\n    \\<exists>x y. x \\<le> y \\<and> G = {x..y}\n 2. \\<exists>x y. x \\<le> y \\<and> G = {x..y} \\<Longrightarrow>\n    geodesic_segment G", "then"], ["proof (chain)\npicking this:\n  x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}", "show \"\\<exists>x y. x \\<le> y \\<and> G = {x..y}\""], ["proof (prove)\nusing this:\n  x \\<le> y \\<and> G = {x..y} \\<or> y \\<le> x \\<and> G = {y..x}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<le> y \\<and> G = {x..y}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x y. x \\<le> y \\<and> G = {x..y}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<le> y \\<and> G = {x..y} \\<Longrightarrow>\n    geodesic_segment G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<le> y \\<and> G = {x..y} \\<Longrightarrow>\n    geodesic_segment G", "assume \"\\<exists>x y. x \\<le> y \\<and> G = {x..y}\""], ["proof (state)\nthis:\n  \\<exists>x y. x \\<le> y \\<and> G = {x..y}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. x \\<le> y \\<and> G = {x..y} \\<Longrightarrow>\n    geodesic_segment G", "then"], ["proof (chain)\npicking this:\n  \\<exists>x y. x \\<le> y \\<and> G = {x..y}", "show \"geodesic_segment G\""], ["proof (prove)\nusing this:\n  \\<exists>x y. x \\<le> y \\<and> G = {x..y}\n\ngoal (1 subgoal):\n 1. geodesic_segment G", "unfolding geodesic_segment_def"], ["proof (prove)\nusing this:\n  \\<exists>x y. x \\<le> y \\<and> G = {x..y}\n\ngoal (1 subgoal):\n 1. \\<exists>x. Ex (geodesic_segment_between G x)", "using geodesic_segment_between_real"], ["proof (prove)\nusing this:\n  \\<exists>x y. x \\<le> y \\<and> G = {x..y}\n  ?x \\<le> ?y \\<Longrightarrow>\n  geodesic_segment_between ?G ?x ?y = (?G = {?x..?y})\n\ngoal (1 subgoal):\n 1. \\<exists>x. Ex (geodesic_segment_between G x)", "by metis"], ["proof (state)\nthis:\n  geodesic_segment G\n\ngoal:\nNo subgoals!", "qed"], ["", "instance real::metric_tree"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real, metric_tree_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G x y H z.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H y z; G \\<inter> H = {y}\\<rbrakk>\n       \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z", "fix G H::\"real set\" and x y z::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G x y H z.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H y z; G \\<inter> H = {y}\\<rbrakk>\n       \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z", "assume GH: \"geodesic_segment_between G x y\" \"geodesic_segment_between H y z\" \"G \\<inter> H = {y}\""], ["proof (state)\nthis:\n  geodesic_segment_between G x y\n  geodesic_segment_between H y z\n  G \\<inter> H = {y}\n\ngoal (1 subgoal):\n 1. \\<And>G x y H z.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H y z; G \\<inter> H = {y}\\<rbrakk>\n       \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z", "have G: \"G = {min x y..max x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G = {min x y..max x y}", "using GH"], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n  geodesic_segment_between H y z\n  G \\<inter> H = {y}\n\ngoal (1 subgoal):\n 1. G = {min x y..max x y}", "by (metis geodesic_segment_between_real geodesic_segment_commute inf_real_def inf_sup_ord(2) max.coboundedI2 max_def min_def)"], ["proof (state)\nthis:\n  G = {min x y..max x y}\n\ngoal (1 subgoal):\n 1. \\<And>G x y H z.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H y z; G \\<inter> H = {y}\\<rbrakk>\n       \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z", "have H: \"H = {min y z..max y z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = {min y z..max y z}", "using GH"], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n  geodesic_segment_between H y z\n  G \\<inter> H = {y}\n\ngoal (1 subgoal):\n 1. H = {min y z..max y z}", "by (metis geodesic_segment_between_real geodesic_segment_commute inf_real_def inf_sup_ord(2) max.coboundedI2 max_def min_def)"], ["proof (state)\nthis:\n  H = {min y z..max y z}\n\ngoal (1 subgoal):\n 1. \\<And>G x y H z.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H y z; G \\<inter> H = {y}\\<rbrakk>\n       \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z", "have *: \"(x \\<le> y \\<and> y \\<le> z) \\<or> (z \\<le> y \\<and> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<and> y \\<le> z \\<or> z \\<le> y \\<and> y \\<le> x", "using G H \\<open>G \\<inter> H = {y}\\<close>"], ["proof (prove)\nusing this:\n  G = {min x y..max x y}\n  H = {min y z..max y z}\n  G \\<inter> H = {y}\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<and> y \\<le> z \\<or> z \\<le> y \\<and> y \\<le> x", "unfolding min_def max_def"], ["proof (prove)\nusing this:\n  G = {if x \\<le> y then x else y..if x \\<le> y then y else x}\n  H = {if y \\<le> z then y else z..if y \\<le> z then z else y}\n  G \\<inter> H = {y}\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<and> y \\<le> z \\<or> z \\<le> y \\<and> y \\<le> x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>G = {if x \\<le> y then x else y..if x \\<le> y then y else x};\n     H = {y..z}; max (if x \\<le> y then x else y) y = y;\n     min (if x \\<le> y then y else x) z = y; \\<not> z \\<le> y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y\n 2. \\<lbrakk>G = {x..y};\n     H = {if y \\<le> z then y else z..if y \\<le> z then z else y};\n     max x (if y \\<le> z then y else z) = y;\n     min y (if y \\<le> z then z else y) = y; \\<not> y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y \\<le> z", "apply (metis (mono_tags, hide_lams) min_le_iff_disj order_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G = {x..y};\n     H = {if y \\<le> z then y else z..if y \\<le> z then z else y};\n     max x (if y \\<le> z then y else z) = y;\n     min y (if y \\<le> z then z else y) = y; \\<not> y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y \\<le> z", "by (metis (full_types) less_eq_real_def max_def)"], ["proof (state)\nthis:\n  x \\<le> y \\<and> y \\<le> z \\<or> z \\<le> y \\<and> y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>G x y H z.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H y z; G \\<inter> H = {y}\\<rbrakk>\n       \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z", "show \"geodesic_segment_between (G \\<union> H) x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (G \\<union> H) x z", "using *"], ["proof (prove)\nusing this:\n  x \\<le> y \\<and> y \\<le> z \\<or> z \\<le> y \\<and> y \\<le> x\n\ngoal (1 subgoal):\n 1. geodesic_segment_between (G \\<union> H) x z", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<le> y \\<and> y \\<le> z \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z\n 2. z \\<le> y \\<and> y \\<le> x \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "using \\<open>G \\<inter> H = {y}\\<close>"], ["proof (prove)\nusing this:\n  G \\<inter> H = {y}\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<and> y \\<le> z \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z\n 2. z \\<le> y \\<and> y \\<le> x \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "unfolding G H"], ["proof (prove)\nusing this:\n  {min x y..max x y} \\<inter> {min y z..max y z} = {y}\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<and> y \\<le> z \\<Longrightarrow>\n    geodesic_segment_between\n     ({min x y..max x y} \\<union> {min y z..max y z}) x z\n 2. z \\<le> y \\<and> y \\<le> x \\<Longrightarrow>\n    geodesic_segment_between\n     ({min x y..max x y} \\<union> {min y z..max y z}) x z", "apply (metis G GH(1) GH(2) H geodesic_segment_between_real ivl_disj_un_two_touch(4) order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> y \\<and> y \\<le> x \\<Longrightarrow>\n    geodesic_segment_between\n     ({min x y..max x y} \\<union> {min y z..max y z}) x z", "using \\<open>G \\<inter> H = {y}\\<close>"], ["proof (prove)\nusing this:\n  G \\<inter> H = {y}\n\ngoal (1 subgoal):\n 1. z \\<le> y \\<and> y \\<le> x \\<Longrightarrow>\n    geodesic_segment_between\n     ({min x y..max x y} \\<union> {min y z..max y z}) x z", "unfolding G H"], ["proof (prove)\nusing this:\n  {min x y..max x y} \\<inter> {min y z..max y z} = {y}\n\ngoal (1 subgoal):\n 1. z \\<le> y \\<and> y \\<le> x \\<Longrightarrow>\n    geodesic_segment_between\n     ({min x y..max x y} \\<union> {min y z..max y z}) x z", "by (metis (full_types) Un_commute geodesic_segment_between_real geodesic_segment_commute ivl_disj_un_two_touch(4) le_max_iff_disj max.absorb_iff2 max.commute min_absorb2)"], ["proof (state)\nthis:\n  geodesic_segment_between (G \\<union> H) x z\n\ngoal:\nNo subgoals!", "qed"], ["", "context metric_tree begin"], ["", "text \\<open>We show that a metric tree is uniquely geodesic.\\<close>"], ["", "subclass uniquely_geodesic_space"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.uniquely_geodesic_space dist uniformity open", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y G H.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H x y\\<rbrakk>\n       \\<Longrightarrow> G = H", "fix x y G H"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y G H.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H x y\\<rbrakk>\n       \\<Longrightarrow> G = H", "assume H: \"geodesic_segment_between G x y\" \"geodesic_segment_between H x (y::'a)\""], ["proof (state)\nthis:\n  geodesic_segment_between G x y\n  geodesic_segment_between H x y\n\ngoal (1 subgoal):\n 1. \\<And>x y G H.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H x y\\<rbrakk>\n       \\<Longrightarrow> G = H", "show \"G = H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G = H", "proof (rule uniquely_geodesic_spaceI[OF _ H])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G H x y.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H x y; G \\<inter> H = {x, y}\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix G H x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G H x y.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H x y; G \\<inter> H = {x, y}\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"geodesic_segment_between G x y\" \"geodesic_segment_between H x y\" \"G \\<inter> H = {x, (y::'a)}\""], ["proof (state)\nthis:\n  geodesic_segment_between G x y\n  geodesic_segment_between H x y\n  G \\<inter> H = {x, y}\n\ngoal (1 subgoal):\n 1. \\<And>G H x y.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H x y; G \\<inter> H = {x, y}\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "assume \"x \\<noteq> y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> y", "have \"dist x y > 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < dist x y", "by auto"], ["proof (state)\nthis:\n  0 < dist x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "obtain g where g: \"g 0 = x\" \"g (dist x y) = y\" \"isometry_on {0..dist x y} g\" \"G = g`{0..dist x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g 0 = x; g (dist x y) = y; isometry_on {0..dist x y} g;\n         G = g ` {0..dist x y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson \\<open>geodesic_segment_between G x y\\<close> geodesic_segment_between_def)"], ["proof (state)\nthis:\n  g 0 = x\n  g (dist x y) = y\n  isometry_on {0..dist x y} g\n  G = g ` {0..dist x y}\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "define G2 where \"G2 = g`{0..dist x y/2}\""], ["proof (state)\nthis:\n  G2 = g ` {0..dist x y / 2}\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have \"G2 \\<subseteq> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G2 \\<subseteq> G", "unfolding G2_def g(4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. g ` {0..dist x y / 2} \\<subseteq> g ` {0..dist x y}", "by auto"], ["proof (state)\nthis:\n  G2 \\<subseteq> G\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "define z where \"z = g(dist x y/2)\""], ["proof (state)\nthis:\n  z = g (dist x y / 2)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have \"dist x z = dist x y/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z = dist x y / 2", "using isometry_onD[OF g(3), of 0 \"dist x y/2\"] g(1) z_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<in> {0..dist x y}; dist x y / 2 \\<in> {0..dist x y}\\<rbrakk>\n  \\<Longrightarrow> dist (g 0) (g (dist x y / 2)) = dist 0 (dist x y / 2)\n  g 0 = x\n  z = g (dist x y / 2)\n\ngoal (1 subgoal):\n 1. dist x z = dist x y / 2", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<in> {0..dist x y}; dist x y / 2 \\<in> {0..dist x y}\\<rbrakk>\n  \\<Longrightarrow> dist (g 0) (g (dist x y / 2)) =\n                    \\<bar>0 - dist x y / 2\\<bar>\n  g 0 = x\n  z = g (dist x y / 2)\n\ngoal (1 subgoal):\n 1. dist x z = dist x y / 2", "by auto"], ["proof (state)\nthis:\n  dist x z = dist x y / 2\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have \"dist y z = dist x y/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y z = dist x y / 2", "using isometry_onD[OF g(3), of \"dist x y\" \"dist x y/2\"] g(2) z_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>dist x y \\<in> {0..dist x y};\n   dist x y / 2 \\<in> {0..dist x y}\\<rbrakk>\n  \\<Longrightarrow> dist (g (dist x y)) (g (dist x y / 2)) =\n                    dist (dist x y) (dist x y / 2)\n  g (dist x y) = y\n  z = g (dist x y / 2)\n\ngoal (1 subgoal):\n 1. dist y z = dist x y / 2", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>dist x y \\<in> {0..dist x y};\n   dist x y / 2 \\<in> {0..dist x y}\\<rbrakk>\n  \\<Longrightarrow> dist (g (dist x y)) (g (dist x y / 2)) =\n                    \\<bar>dist x y - dist x y / 2\\<bar>\n  g (dist x y) = y\n  z = g (dist x y / 2)\n\ngoal (1 subgoal):\n 1. dist y z = dist x y / 2", "by auto"], ["proof (state)\nthis:\n  dist y z = dist x y / 2\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have G2: \"geodesic_segment_between G2 x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between G2 x z", "unfolding \\<open>g 0 = x\\<close>[symmetric] z_def G2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (g ` {0..dist (g 0) y / 2}) (g 0)\n     (g (dist (g 0) y / 2))", "apply (rule geodesic_segmentI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. isometry_on {0..dist (g 0) y / 2} g\n 2. 0 \\<le> dist (g 0) y / 2", "by (rule isometry_on_subset[OF g(3)], auto simp add: \\<open>g 0 = x\\<close>)"], ["proof (state)\nthis:\n  geodesic_segment_between G2 x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have [simp]: \"x \\<in> G2\" \"z \\<in> G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> G2 &&& z \\<in> G2", "using geodesic_segment_endpoints G2"], ["proof (prove)\nusing this:\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> ?x \\<in> ?G\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> ?y \\<in> ?G\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> ?G \\<noteq> {}\n  geodesic_segment_between G2 x z\n\ngoal (1 subgoal):\n 1. x \\<in> G2 &&& z \\<in> G2", "by auto"], ["proof (state)\nthis:\n  x \\<in> G2\n  z \\<in> G2\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have \"dist x a \\<le> dist x z\" if \"a \\<in> G2\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x a \\<le> dist x z", "apply (rule geodesic_segment_dist_le)"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment_between ?G x z\n 2. x \\<in> ?G\n 3. a \\<in> ?G", "using G2 that"], ["proof (prove)\nusing this:\n  geodesic_segment_between G2 x z\n  a \\<in> G2\n\ngoal (3 subgoals):\n 1. geodesic_segment_between ?G x z\n 2. x \\<in> ?G\n 3. a \\<in> ?G", "by auto"], ["proof (state)\nthis:\n  ?a \\<in> G2 \\<Longrightarrow> dist x ?a \\<le> dist x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  ?a \\<in> G2 \\<Longrightarrow> dist x ?a \\<le> dist x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have \"... < dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z < dist x y", "unfolding \\<open>dist x z = dist x y/2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y / 2 < dist x y", "using \\<open>dist x y > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < dist x y\n\ngoal (1 subgoal):\n 1. dist x y / 2 < dist x y", "by auto"], ["proof (state)\nthis:\n  dist x z < dist x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  ?a1 \\<in> G2 \\<Longrightarrow> dist x ?a1 < dist x y", "have \"y \\<notin> G2\""], ["proof (prove)\nusing this:\n  ?a1 \\<in> G2 \\<Longrightarrow> dist x ?a1 < dist x y\n\ngoal (1 subgoal):\n 1. y \\<notin> G2", "by auto"], ["proof (state)\nthis:\n  y \\<notin> G2\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  y \\<notin> G2", "have \"G2 \\<inter> H = {x}\""], ["proof (prove)\nusing this:\n  y \\<notin> G2\n\ngoal (1 subgoal):\n 1. G2 \\<inter> H = {x}", "using \\<open>G2 \\<subseteq> G\\<close> \\<open>x \\<in> G2\\<close> \\<open>G \\<inter> H = {x, y}\\<close>"], ["proof (prove)\nusing this:\n  y \\<notin> G2\n  G2 \\<subseteq> G\n  x \\<in> G2\n  G \\<inter> H = {x, y}\n\ngoal (1 subgoal):\n 1. G2 \\<inter> H = {x}", "by auto"], ["proof (state)\nthis:\n  G2 \\<inter> H = {x}\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have *: \"geodesic_segment_between (G2 \\<union> H) z y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (G2 \\<union> H) z y", "apply (rule geod_union[of _ _ x])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment_between G2 z x\n 2. geodesic_segment_between H x y\n 3. G2 \\<inter> H = {x}", "using \\<open>G2 \\<inter> H = {x}\\<close> \\<open>geodesic_segment_between H x y\\<close> G2"], ["proof (prove)\nusing this:\n  G2 \\<inter> H = {x}\n  geodesic_segment_between H x y\n  geodesic_segment_between G2 x z\n\ngoal (3 subgoals):\n 1. geodesic_segment_between G2 z x\n 2. geodesic_segment_between H x y\n 3. G2 \\<inter> H = {x}", "by (auto simp add: geodesic_segment_commute)"], ["proof (state)\nthis:\n  geodesic_segment_between (G2 \\<union> H) z y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have \"dist x y \\<le> dist z x + dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y \\<le> dist z x + dist x y", "by auto"], ["proof (state)\nthis:\n  dist x y \\<le> dist z x + dist x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  dist x y \\<le> dist z x + dist x y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have \"... = dist z y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z x + dist x y = dist z y", "apply (rule geodesic_segment_dist[OF *])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> G2 \\<union> H", "using \\<open>G \\<inter> H = {x, y}\\<close>"], ["proof (prove)\nusing this:\n  G \\<inter> H = {x, y}\n\ngoal (1 subgoal):\n 1. x \\<in> G2 \\<union> H", "by auto"], ["proof (state)\nthis:\n  dist z x + dist x y = dist z y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  dist z x + dist x y = dist z y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "have \"... = dist x y / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist z y = dist x y / 2", "by (simp add: \\<open>dist y z = dist x y / 2\\<close> metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist z y = dist x y / 2\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  dist x y \\<le> dist x y / 2", "show False"], ["proof (prove)\nusing this:\n  dist x y \\<le> dist x y / 2\n\ngoal (1 subgoal):\n 1. False", "using \\<open>dist x y > 0\\<close>"], ["proof (prove)\nusing this:\n  dist x y \\<le> dist x y / 2\n  0 < dist x y\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G = H\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>An important property of metric trees is that any geodesic triangle is degenerate, i.e., the\nthree sides intersect at a unique point, the center of the triangle, that we introduce now.\\<close>"], ["", "definition center::\"'a \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  where \"center x y z = (SOME t. t \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z})\""], ["", "lemma center_as_intersection:\n  \"{x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "obtain g where g: \"g 0 = x\" \"g (dist x y) = y\" \"isometry_on {0..dist x y} g\" \"{x--y} = g`{0..dist x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g 0 = x; g (dist x y) = y; isometry_on {0..dist x y} g;\n         {x--y} = g ` {0..dist x y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson geodesic_segment_between_def some_geodesic_is_geodesic_segment(1))"], ["proof (state)\nthis:\n  g 0 = x\n  g (dist x y) = y\n  isometry_on {0..dist x y} g\n  {x--y} = g ` {0..dist x y}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "obtain h where h: \"h 0 = x\" \"h (dist x z) = z\" \"isometry_on {0..dist x z} h\" \"{x--z} = h`{0..dist x z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>h 0 = x; h (dist x z) = z; isometry_on {0..dist x z} h;\n         {x--z} = h ` {0..dist x z}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson geodesic_segment_between_def some_geodesic_is_geodesic_segment(1))"], ["proof (state)\nthis:\n  h 0 = x\n  h (dist x z) = z\n  isometry_on {0..dist x z} h\n  {x--z} = h ` {0..dist x z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "define Z where \"Z = {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}\""], ["proof (state)\nthis:\n  Z = {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have \"0 \\<in> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> Z", "unfolding Z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}", "using g(1) h(1)"], ["proof (prove)\nusing this:\n  g 0 = x\n  h 0 = x\n\ngoal (1 subgoal):\n 1. 0 \\<in> {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}", "by auto"], ["proof (state)\nthis:\n  0 \\<in> Z\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have [simp]: \"closed Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed Z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed Z", "have *: \"Z = (\\<lambda>s. dist (g s) (h s))-`{0} \\<inter> {0..min (dist x y) (dist x z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z =\n    (\\<lambda>s. dist (g s) (h s)) -` {0} \\<inter>\n    {0..min (dist x y) (dist x z)}", "unfolding Z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t} =\n    (\\<lambda>s. dist (g s) (h s)) -` {0} \\<inter>\n    {0..min (dist x y) (dist x z)}", "by auto"], ["proof (state)\nthis:\n  Z =\n  (\\<lambda>s. dist (g s) (h s)) -` {0} \\<inter>\n  {0..min (dist x y) (dist x z)}\n\ngoal (1 subgoal):\n 1. closed Z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed Z", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\n     ((\\<lambda>s. dist (g s) (h s)) -` {0} \\<inter>\n      {0..min (dist x y) (dist x z)})", "apply (rule closed_vimage_Int)"], ["proof (prove)\ngoal (3 subgoals):\n 1. closed {0}\n 2. continuous_on {0..min (dist x y) (dist x z)}\n     (\\<lambda>s. dist (g s) (h s))\n 3. closed {0..min (dist x y) (dist x z)}", "using continuous_on_subset[OF isometry_on_continuous[OF g(3)], of \"{0..min (dist x y) (dist x z)}\"]\n            continuous_on_subset[OF isometry_on_continuous[OF h(3)], of \"{0..min (dist x y) (dist x z)}\"]\n            continuous_on_dist"], ["proof (prove)\nusing this:\n  {0..min (dist x y) (dist x z)} \\<subseteq> {0..dist x y} \\<Longrightarrow>\n  continuous_on {0..min (dist x y) (dist x z)} g\n  {0..min (dist x y) (dist x z)} \\<subseteq> {0..dist x z} \\<Longrightarrow>\n  continuous_on {0..min (dist x y) (dist x z)} h\n  \\<lbrakk>continuous_on ?s ?f; continuous_on ?s ?g\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s (\\<lambda>x. dist (?f x) (?g x))\n\ngoal (3 subgoals):\n 1. closed {0}\n 2. continuous_on {0..min (dist x y) (dist x z)}\n     (\\<lambda>s. dist (g s) (h s))\n 3. closed {0..min (dist x y) (dist x z)}", "by auto"], ["proof (state)\nthis:\n  closed Z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed Z\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "define a where \"a = Sup Z\""], ["proof (state)\nthis:\n  a = Sup Z\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have \"a \\<in> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> Z", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup Z \\<in> Z", "apply (rule closed_contains_Sup, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Z = {} \\<Longrightarrow> False\n 2. bdd_above Z", "using \\<open>0 \\<in> Z\\<close> Z_def"], ["proof (prove)\nusing this:\n  0 \\<in> Z\n  Z = {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}\n\ngoal (2 subgoals):\n 1. Z = {} \\<Longrightarrow> False\n 2. bdd_above Z", "by auto"], ["proof (state)\nthis:\n  a \\<in> Z\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "define c where \"c = h a\""], ["proof (state)\nthis:\n  c = h a\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "then"], ["proof (chain)\npicking this:\n  c = h a", "have a: \"g a = c\" \"h a = c\" \"a \\<ge> 0\" \"a \\<le> dist x y\" \"a \\<le> dist x z\""], ["proof (prove)\nusing this:\n  c = h a\n\ngoal (1 subgoal):\n 1. (g a = c &&& h a = c) &&&\n    0 \\<le> a &&& a \\<le> dist x y &&& a \\<le> dist x z", "using \\<open>a \\<in> Z\\<close>"], ["proof (prove)\nusing this:\n  c = h a\n  a \\<in> Z\n\ngoal (1 subgoal):\n 1. (g a = c &&& h a = c) &&&\n    0 \\<le> a &&& a \\<le> dist x y &&& a \\<le> dist x z", "unfolding Z_def c_def"], ["proof (prove)\nusing this:\n  h a = h a\n  a \\<in> {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}\n\ngoal (1 subgoal):\n 1. (g a = h a &&& h a = h a) &&&\n    0 \\<le> a &&& a \\<le> dist x y &&& a \\<le> dist x z", "by auto"], ["proof (state)\nthis:\n  g a = c\n  h a = c\n  0 \\<le> a\n  a \\<le> dist x y\n  a \\<le> dist x z\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "define G2 where \"G2 = g`{a..dist x y}\""], ["proof (state)\nthis:\n  G2 = g ` {a..dist x y}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have G2: \"geodesic_segment_between G2 (g a) (g (dist x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between G2 (g a) (g (dist x y))", "unfolding G2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (g ` {a..dist x y}) (g a) (g (dist x y))", "apply (rule geodesic_segmentI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. isometry_on {a..dist x y} g\n 2. a \\<le> dist x y", "using isometry_on_subset[OF g(3)] \\<open>a \\<in> Z\\<close>"], ["proof (prove)\nusing this:\n  ?Y \\<subseteq> {0..dist x y} \\<Longrightarrow> isometry_on ?Y g\n  a \\<in> Z\n\ngoal (2 subgoals):\n 1. isometry_on {a..dist x y} g\n 2. a \\<le> dist x y", "unfolding Z_def"], ["proof (prove)\nusing this:\n  ?Y \\<subseteq> {0..dist x y} \\<Longrightarrow> isometry_on ?Y g\n  a \\<in> {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}\n\ngoal (2 subgoals):\n 1. isometry_on {a..dist x y} g\n 2. a \\<le> dist x y", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between G2 (g a) (g (dist x y))\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "define H2 where \"H2 = h`{a..dist x z}\""], ["proof (state)\nthis:\n  H2 = h ` {a..dist x z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have H2: \"geodesic_segment_between H2 (h a) (h (dist x z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between H2 (h a) (h (dist x z))", "unfolding H2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (h ` {a..dist x z}) (h a) (h (dist x z))", "apply (rule geodesic_segmentI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. isometry_on {a..dist x z} h\n 2. a \\<le> dist x z", "using isometry_on_subset[OF h(3)] \\<open>a \\<in> Z\\<close>"], ["proof (prove)\nusing this:\n  ?Y \\<subseteq> {0..dist x z} \\<Longrightarrow> isometry_on ?Y h\n  a \\<in> Z\n\ngoal (2 subgoals):\n 1. isometry_on {a..dist x z} h\n 2. a \\<le> dist x z", "unfolding Z_def"], ["proof (prove)\nusing this:\n  ?Y \\<subseteq> {0..dist x z} \\<Longrightarrow> isometry_on ?Y h\n  a \\<in> {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}\n\ngoal (2 subgoals):\n 1. isometry_on {a..dist x z} h\n 2. a \\<le> dist x z", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between H2 (h a) (h (dist x z))\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have \"G2 \\<inter> H2 \\<subseteq> {c}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G2 \\<inter> H2 \\<subseteq> {c}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "assume w: \"w \\<in> G2 \\<inter> H2\""], ["proof (state)\nthis:\n  w \\<in> G2 \\<inter> H2\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "obtain sg where sg: \"w = g sg\" \"sg \\<in> {a..dist x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sg.\n        \\<lbrakk>w = g sg; sg \\<in> {a..dist x y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using w"], ["proof (prove)\nusing this:\n  w \\<in> G2 \\<inter> H2\n\ngoal (1 subgoal):\n 1. (\\<And>sg.\n        \\<lbrakk>w = g sg; sg \\<in> {a..dist x y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding G2_def"], ["proof (prove)\nusing this:\n  w \\<in> g ` {a..dist x y} \\<inter> H2\n\ngoal (1 subgoal):\n 1. (\\<And>sg.\n        \\<lbrakk>w = g sg; sg \\<in> {a..dist x y}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = g sg\n  sg \\<in> {a..dist x y}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "obtain sh where sh: \"w = h sh\" \"sh \\<in> {a..dist x z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sh.\n        \\<lbrakk>w = h sh; sh \\<in> {a..dist x z}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using w"], ["proof (prove)\nusing this:\n  w \\<in> G2 \\<inter> H2\n\ngoal (1 subgoal):\n 1. (\\<And>sh.\n        \\<lbrakk>w = h sh; sh \\<in> {a..dist x z}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding H2_def"], ["proof (prove)\nusing this:\n  w \\<in> G2 \\<inter> h ` {a..dist x z}\n\ngoal (1 subgoal):\n 1. (\\<And>sh.\n        \\<lbrakk>w = h sh; sh \\<in> {a..dist x z}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w = h sh\n  sh \\<in> {a..dist x z}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "have \"dist w x = sg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist w x = sg", "unfolding g(1)[symmetric] sg(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (g sg) (g 0) = sg", "using isometry_onD[OF g(3), of 0 sg] sg(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<in> {0..dist x y}; sg \\<in> {0..dist x y}\\<rbrakk>\n  \\<Longrightarrow> dist (g 0) (g sg) = dist 0 sg\n  sg \\<in> {a..dist x y}\n\ngoal (1 subgoal):\n 1. dist (g sg) (g 0) = sg", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<in> {0..dist x y}; sg \\<in> {0..dist x y}\\<rbrakk>\n  \\<Longrightarrow> dist (g 0) (g sg) = \\<bar>0 - sg\\<bar>\n  sg \\<in> {a..dist x y}\n\ngoal (1 subgoal):\n 1. dist (g sg) (g 0) = sg", "using a"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<in> {0..dist x y}; sg \\<in> {0..dist x y}\\<rbrakk>\n  \\<Longrightarrow> dist (g 0) (g sg) = \\<bar>0 - sg\\<bar>\n  sg \\<in> {a..dist x y}\n  g a = c\n  h a = c\n  0 \\<le> a\n  a \\<le> dist x y\n  a \\<le> dist x z\n\ngoal (1 subgoal):\n 1. dist (g sg) (g 0) = sg", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist w x = sg\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "moreover"], ["proof (state)\nthis:\n  dist w x = sg\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "have \"dist w x = sh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist w x = sh", "unfolding h(1)[symmetric] sh(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (h sh) (h 0) = sh", "using isometry_onD[OF h(3), of 0 sh] sh(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<in> {0..dist x z}; sh \\<in> {0..dist x z}\\<rbrakk>\n  \\<Longrightarrow> dist (h 0) (h sh) = dist 0 sh\n  sh \\<in> {a..dist x z}\n\ngoal (1 subgoal):\n 1. dist (h sh) (h 0) = sh", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<in> {0..dist x z}; sh \\<in> {0..dist x z}\\<rbrakk>\n  \\<Longrightarrow> dist (h 0) (h sh) = \\<bar>0 - sh\\<bar>\n  sh \\<in> {a..dist x z}\n\ngoal (1 subgoal):\n 1. dist (h sh) (h 0) = sh", "using a"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<in> {0..dist x z}; sh \\<in> {0..dist x z}\\<rbrakk>\n  \\<Longrightarrow> dist (h 0) (h sh) = \\<bar>0 - sh\\<bar>\n  sh \\<in> {a..dist x z}\n  g a = c\n  h a = c\n  0 \\<le> a\n  a \\<le> dist x y\n  a \\<le> dist x z\n\ngoal (1 subgoal):\n 1. dist (h sh) (h 0) = sh", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist w x = sh\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "ultimately"], ["proof (chain)\npicking this:\n  dist w x = sg\n  dist w x = sh", "have \"sg = sh\""], ["proof (prove)\nusing this:\n  dist w x = sg\n  dist w x = sh\n\ngoal (1 subgoal):\n 1. sg = sh", "by simp"], ["proof (state)\nthis:\n  sg = sh\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "have \"sh \\<in> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sh \\<in> Z", "unfolding Z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sh \\<in> {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}", "using sg sh \\<open>a \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  w = g sg\n  sg \\<in> {a..dist x y}\n  w = h sh\n  sh \\<in> {a..dist x z}\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. sh \\<in> {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}", "unfolding \\<open>sg = sh\\<close>"], ["proof (prove)\nusing this:\n  w = g sh\n  sh \\<in> {a..dist x y}\n  w = h sh\n  sh \\<in> {a..dist x z}\n  0 \\<le> a\n\ngoal (1 subgoal):\n 1. sh \\<in> {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}", "by auto"], ["proof (state)\nthis:\n  sh \\<in> Z\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "then"], ["proof (chain)\npicking this:\n  sh \\<in> Z", "have \"sh \\<le> a\""], ["proof (prove)\nusing this:\n  sh \\<in> Z\n\ngoal (1 subgoal):\n 1. sh \\<le> a", "unfolding a_def"], ["proof (prove)\nusing this:\n  sh \\<in> Z\n\ngoal (1 subgoal):\n 1. sh \\<le> Sup Z", "apply (rule cSup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above Z", "unfolding Z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above {t \\<in> {0..min (dist x y) (dist x z)}. g t = h t}", "by auto"], ["proof (state)\nthis:\n  sh \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "then"], ["proof (chain)\npicking this:\n  sh \\<le> a", "have \"sh = a\""], ["proof (prove)\nusing this:\n  sh \\<le> a\n\ngoal (1 subgoal):\n 1. sh = a", "using sh(2)"], ["proof (prove)\nusing this:\n  sh \\<le> a\n  sh \\<in> {a..dist x z}\n\ngoal (1 subgoal):\n 1. sh = a", "by auto"], ["proof (state)\nthis:\n  sh = a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> G2 \\<inter> H2 \\<Longrightarrow> x \\<in> {c}", "then"], ["proof (chain)\npicking this:\n  sh = a", "show \"w \\<in> {c}\""], ["proof (prove)\nusing this:\n  sh = a\n\ngoal (1 subgoal):\n 1. w \\<in> {c}", "unfolding sh(1)"], ["proof (prove)\nusing this:\n  sh = a\n\ngoal (1 subgoal):\n 1. h sh \\<in> {c}", "using a(2)"], ["proof (prove)\nusing this:\n  sh = a\n  h a = c\n\ngoal (1 subgoal):\n 1. h sh \\<in> {c}", "by auto"], ["proof (state)\nthis:\n  w \\<in> {c}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G2 \\<inter> H2 \\<subseteq> {c}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "then"], ["proof (chain)\npicking this:\n  G2 \\<inter> H2 \\<subseteq> {c}", "have *: \"G2 \\<inter> H2 = {c}\""], ["proof (prove)\nusing this:\n  G2 \\<inter> H2 \\<subseteq> {c}\n\ngoal (1 subgoal):\n 1. G2 \\<inter> H2 = {c}", "unfolding G2_def H2_def"], ["proof (prove)\nusing this:\n  g ` {a..dist x y} \\<inter> h ` {a..dist x z} \\<subseteq> {c}\n\ngoal (1 subgoal):\n 1. g ` {a..dist x y} \\<inter> h ` {a..dist x z} = {c}", "using a"], ["proof (prove)\nusing this:\n  g ` {a..dist x y} \\<inter> h ` {a..dist x z} \\<subseteq> {c}\n  g a = c\n  h a = c\n  0 \\<le> a\n  a \\<le> dist x y\n  a \\<le> dist x z\n\ngoal (1 subgoal):\n 1. g ` {a..dist x y} \\<inter> h ` {a..dist x z} = {c}", "by (auto simp add: image_iff, force)"], ["proof (state)\nthis:\n  G2 \\<inter> H2 = {c}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have \"geodesic_segment_between (G2 \\<union> H2) y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (G2 \\<union> H2) y z", "apply (subst g(2)[symmetric], subst h(2)[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (G2 \\<union> H2) (g (dist x y)) (h (dist x z))", "apply(rule geod_union[of _ _ \"h a\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment_between G2 (g (dist x y)) (h a)\n 2. geodesic_segment_between H2 (h a) (h (dist x z))\n 3. G2 \\<inter> H2 = {h a}", "using geodesic_segment_commute G2 H2 a *"], ["proof (prove)\nusing this:\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow>\n  geodesic_segment_between ?G ?y ?x\n  geodesic_segment_between G2 (g a) (g (dist x y))\n  geodesic_segment_between H2 (h a) (h (dist x z))\n  g a = c\n  h a = c\n  0 \\<le> a\n  a \\<le> dist x y\n  a \\<le> dist x z\n  G2 \\<inter> H2 = {c}\n\ngoal (3 subgoals):\n 1. geodesic_segment_between G2 (g (dist x y)) (h a)\n 2. geodesic_segment_between H2 (h a) (h (dist x z))\n 3. G2 \\<inter> H2 = {h a}", "by force+"], ["proof (state)\nthis:\n  geodesic_segment_between (G2 \\<union> H2) y z\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "then"], ["proof (chain)\npicking this:\n  geodesic_segment_between (G2 \\<union> H2) y z", "have \"G2 \\<union> H2 = {y--z}\""], ["proof (prove)\nusing this:\n  geodesic_segment_between (G2 \\<union> H2) y z\n\ngoal (1 subgoal):\n 1. G2 \\<union> H2 = {y--z}", "using geodesic_segment_unique"], ["proof (prove)\nusing this:\n  geodesic_segment_between (G2 \\<union> H2) y z\n  geodesic_segment_between ?G ?x ?y = (?G = {?x--?y})\n\ngoal (1 subgoal):\n 1. G2 \\<union> H2 = {y--z}", "by auto"], ["proof (state)\nthis:\n  G2 \\<union> H2 = {y--z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "then"], ["proof (chain)\npicking this:\n  G2 \\<union> H2 = {y--z}", "have \"c \\<in> {y--z}\""], ["proof (prove)\nusing this:\n  G2 \\<union> H2 = {y--z}\n\ngoal (1 subgoal):\n 1. c \\<in> {y--z}", "using *"], ["proof (prove)\nusing this:\n  G2 \\<union> H2 = {y--z}\n  G2 \\<inter> H2 = {c}\n\ngoal (1 subgoal):\n 1. c \\<in> {y--z}", "by auto"], ["proof (state)\nthis:\n  c \\<in> {y--z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "then"], ["proof (chain)\npicking this:\n  c \\<in> {y--z}", "have *: \"c \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\""], ["proof (prove)\nusing this:\n  c \\<in> {y--z}\n\ngoal (1 subgoal):\n 1. c \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}", "using g(4) h(4) c_def a"], ["proof (prove)\nusing this:\n  c \\<in> {y--z}\n  {x--y} = g ` {0..dist x y}\n  {x--z} = h ` {0..dist x z}\n  c = h a\n  g a = c\n  h a = c\n  0 \\<le> a\n  a \\<le> dist x y\n  a \\<le> dist x z\n\ngoal (1 subgoal):\n 1. c \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}", "by force"], ["proof (state)\nthis:\n  c \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have center: \"center x y z \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. center x y z \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}", "unfolding center_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME t. t \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z})\n    \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}", "using someI[of \"\\<lambda>p. p \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\", OF *]"], ["proof (prove)\nusing this:\n  (SOME p. p \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z})\n  \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\n\ngoal (1 subgoal):\n 1. (SOME t. t \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z})\n    \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}", "by blast"], ["proof (state)\nthis:\n  center x y z \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have *: \"dist x d = Gromov_product_at x y z\" if \"d \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\" for d"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x d = Gromov_product_at x y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist x d = Gromov_product_at x y z", "have \"dist x y = dist x d + dist d y\"\n         \"dist x z = dist x d + dist d z\"\n         \"dist y z = dist y d + dist d z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y = dist x d + dist d y &&&\n    dist x z = dist x d + dist d z &&& dist y z = dist y d + dist d z", "using that"], ["proof (prove)\nusing this:\n  d \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\n\ngoal (1 subgoal):\n 1. dist x y = dist x d + dist d y &&&\n    dist x z = dist x d + dist d z &&& dist y z = dist y d + dist d z", "by (auto simp add: geodesic_segment_dist geodesic_segment_unique)"], ["proof (state)\nthis:\n  dist x y = dist x d + dist d y\n  dist x z = dist x d + dist d z\n  dist y z = dist y d + dist d z\n\ngoal (1 subgoal):\n 1. dist x d = Gromov_product_at x y z", "then"], ["proof (chain)\npicking this:\n  dist x y = dist x d + dist d y\n  dist x z = dist x d + dist d z\n  dist y z = dist y d + dist d z", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x y = dist x d + dist d y\n  dist x z = dist x d + dist d z\n  dist y z = dist y d + dist d z\n\ngoal (1 subgoal):\n 1. dist x d = Gromov_product_at x y z", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist x y = dist x d + dist d y\n  dist x z = dist x d + dist d z\n  dist y z = dist y d + dist d z\n\ngoal (1 subgoal):\n 1. dist x d = (dist x y + dist x z - dist y z) / 2", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x d = Gromov_product_at x y z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?d \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z} \\<Longrightarrow>\n  dist x ?d = Gromov_product_at x y z\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "have \"d = center x y z\" if \"d \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\" for d"], ["proof (prove)\ngoal (1 subgoal):\n 1. d = center x y z", "apply (rule geodesic_segment_dist_unique[of \"{x--y}\" x y])"], ["proof (prove)\ngoal (4 subgoals):\n 1. geodesic_segment_between {x--y} x y\n 2. d \\<in> {x--y}\n 3. center x y z \\<in> {x--y}\n 4. dist x d = dist x (center x y z)", "using *[OF that] *[OF center] that center"], ["proof (prove)\nusing this:\n  dist x d = Gromov_product_at x y z\n  dist x (center x y z) = Gromov_product_at x y z\n  d \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\n  center x y z \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\n\ngoal (4 subgoals):\n 1. geodesic_segment_between {x--y} x y\n 2. d \\<in> {x--y}\n 3. center x y z \\<in> {x--y}\n 4. dist x d = dist x (center x y z)", "by auto"], ["proof (state)\nthis:\n  ?d \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z} \\<Longrightarrow>\n  ?d = center x y z\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "then"], ["proof (chain)\npicking this:\n  ?d \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z} \\<Longrightarrow>\n  ?d = center x y z", "show \"{x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}\""], ["proof (prove)\nusing this:\n  ?d \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z} \\<Longrightarrow>\n  ?d = center x y z\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "using center"], ["proof (prove)\nusing this:\n  ?d \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z} \\<Longrightarrow>\n  ?d = center x y z\n  center x y z \\<in> {x--y} \\<inter> {x--z} \\<inter> {y--z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}", "by blast"], ["proof (state)\nthis:\n  {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma center_on_geodesic [simp]:\n  \"center x y z \\<in> {x--y}\"\n  \"center x y z \\<in> {x--z}\"\n  \"center x y z \\<in> {y--z}\"\n  \"center x y z \\<in> {y--x}\"\n  \"center x y z \\<in> {z--x}\"\n  \"center x y z \\<in> {z--y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (center x y z \\<in> {x--y} &&&\n     center x y z \\<in> {x--z} &&& center x y z \\<in> {y--z}) &&&\n    center x y z \\<in> {y--x} &&&\n    center x y z \\<in> {z--x} &&& center x y z \\<in> {z--y}", "using center_as_intersection"], ["proof (prove)\nusing this:\n  {?x--?y} \\<inter> {?x--?z} \\<inter> {?y--?z} = {center ?x ?y ?z}\n\ngoal (1 subgoal):\n 1. (center x y z \\<in> {x--y} &&&\n     center x y z \\<in> {x--z} &&& center x y z \\<in> {y--z}) &&&\n    center x y z \\<in> {y--x} &&&\n    center x y z \\<in> {z--x} &&& center x y z \\<in> {z--y}", "by (auto simp add: some_geodesic_commute)"], ["", "lemma center_commute:\n  \"center x y z = center x z y\"\n  \"center x y z = center y x z\"\n  \"center x y z = center y z x\"\n  \"center x y z = center z x y\"\n  \"center x y z = center z y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (center x y z = center x z y &&& center x y z = center y x z) &&&\n    center x y z = center y z x &&&\n    center x y z = center z x y &&& center x y z = center z y x", "using center_as_intersection some_geodesic_commute"], ["proof (prove)\nusing this:\n  {?x--?y} \\<inter> {?x--?z} \\<inter> {?y--?z} = {center ?x ?y ?z}\n  {?x--?S--?y} = {?y--?S--?x}\n\ngoal (1 subgoal):\n 1. (center x y z = center x z y &&& center x y z = center y x z) &&&\n    center x y z = center y z x &&&\n    center x y z = center z x y &&& center x y z = center z y x", "by blast+"], ["", "lemma center_dist:\n  \"dist x (center x y z) = Gromov_product_at x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (center x y z) = Gromov_product_at x y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist x (center x y z) = Gromov_product_at x y z", "have \"dist x y = dist x (center x y z) + dist (center x y z) y\"\n       \"dist x z = dist x (center x y z) + dist (center x y z) z\"\n       \"dist y z = dist y (center x y z) + dist (center x y z) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y = dist x (center x y z) + dist (center x y z) y &&&\n    dist x z = dist x (center x y z) + dist (center x y z) z &&&\n    dist y z = dist y (center x y z) + dist (center x y z) z", "by (auto simp add: geodesic_segment_dist geodesic_segment_unique)"], ["proof (state)\nthis:\n  dist x y = dist x (center x y z) + dist (center x y z) y\n  dist x z = dist x (center x y z) + dist (center x y z) z\n  dist y z = dist y (center x y z) + dist (center x y z) z\n\ngoal (1 subgoal):\n 1. dist x (center x y z) = Gromov_product_at x y z", "then"], ["proof (chain)\npicking this:\n  dist x y = dist x (center x y z) + dist (center x y z) y\n  dist x z = dist x (center x y z) + dist (center x y z) z\n  dist y z = dist y (center x y z) + dist (center x y z) z", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x y = dist x (center x y z) + dist (center x y z) y\n  dist x z = dist x (center x y z) + dist (center x y z) z\n  dist y z = dist y (center x y z) + dist (center x y z) z\n\ngoal (1 subgoal):\n 1. dist x (center x y z) = Gromov_product_at x y z", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist x y = dist x (center x y z) + dist (center x y z) y\n  dist x z = dist x (center x y z) + dist (center x y z) z\n  dist y z = dist y (center x y z) + dist (center x y z) z\n\ngoal (1 subgoal):\n 1. dist x (center x y z) = (dist x y + dist x z - dist y z) / 2", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x (center x y z) = Gromov_product_at x y z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma geodesic_intersection:\n  \"{x--y} \\<inter> {x--z} = {x--center x y z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "have \"{x--y} = {x--center x y z} \\<union> {center x y z--y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x--y} = {x--center x y z} \\<union> {center x y z--y}", "using center_as_intersection geodesic_segment_split"], ["proof (prove)\nusing this:\n  {?x--?y} \\<inter> {?x--?z} \\<inter> {?y--?z} = {center ?x ?y ?z}\n  ?y \\<in> {?x--?z} \\<Longrightarrow> {?x--?z} = {?x--?y} \\<union> {?y--?z}\n  ?y \\<in> {?x--?z} \\<Longrightarrow> {?x--?y} \\<inter> {?y--?z} = {?y}\n\ngoal (1 subgoal):\n 1. {x--y} = {x--center x y z} \\<union> {center x y z--y}", "by blast"], ["proof (state)\nthis:\n  {x--y} = {x--center x y z} \\<union> {center x y z--y}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "moreover"], ["proof (state)\nthis:\n  {x--y} = {x--center x y z} \\<union> {center x y z--y}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "have \"{x--z} = {x--center x y z} \\<union> {center x y z--z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x--z} = {x--center x y z} \\<union> {center x y z--z}", "using center_as_intersection geodesic_segment_split"], ["proof (prove)\nusing this:\n  {?x--?y} \\<inter> {?x--?z} \\<inter> {?y--?z} = {center ?x ?y ?z}\n  ?y \\<in> {?x--?z} \\<Longrightarrow> {?x--?z} = {?x--?y} \\<union> {?y--?z}\n  ?y \\<in> {?x--?z} \\<Longrightarrow> {?x--?y} \\<inter> {?y--?z} = {?y}\n\ngoal (1 subgoal):\n 1. {x--z} = {x--center x y z} \\<union> {center x y z--z}", "by blast"], ["proof (state)\nthis:\n  {x--z} = {x--center x y z} \\<union> {center x y z--z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "ultimately"], ["proof (chain)\npicking this:\n  {x--y} = {x--center x y z} \\<union> {center x y z--y}\n  {x--z} = {x--center x y z} \\<union> {center x y z--z}", "have \"{x--y} \\<inter> {x--z} = {x--center x y z} \\<union> ({center x y z--y} \\<inter> {x--center x y z}) \\<union> ({center x y z--y} \\<inter> {x--center x y z}) \\<union> ({center x y z--y} \\<inter> {center x y z--z})\""], ["proof (prove)\nusing this:\n  {x--y} = {x--center x y z} \\<union> {center x y z--y}\n  {x--z} = {x--center x y z} \\<union> {center x y z--z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} =\n    {x--center x y z} \\<union>\n    {center x y z--y} \\<inter> {x--center x y z} \\<union>\n    {center x y z--y} \\<inter> {x--center x y z} \\<union>\n    {center x y z--y} \\<inter> {center x y z--z}", "by auto"], ["proof (state)\nthis:\n  {x--y} \\<inter> {x--z} =\n  {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {center x y z--z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "moreover"], ["proof (state)\nthis:\n  {x--y} \\<inter> {x--z} =\n  {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {center x y z--z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "have \"{center x y z--y} \\<inter> {x--center x y z} = {center x y z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {center x y z--y} \\<inter> {x--center x y z} = {center x y z}", "using geodesic_segment_split(2) center_as_intersection[of x y z]"], ["proof (prove)\nusing this:\n  ?y \\<in> {?x--?z} \\<Longrightarrow> {?x--?y} \\<inter> {?y--?z} = {?y}\n  {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}\n\ngoal (1 subgoal):\n 1. {center x y z--y} \\<inter> {x--center x y z} = {center x y z}", "by auto"], ["proof (state)\nthis:\n  {center x y z--y} \\<inter> {x--center x y z} = {center x y z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "moreover"], ["proof (state)\nthis:\n  {center x y z--y} \\<inter> {x--center x y z} = {center x y z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "have \"{center x y z--y} \\<inter> {x--center x y z} = {center x y z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {center x y z--y} \\<inter> {x--center x y z} = {center x y z}", "using geodesic_segment_split(2) center_as_intersection[of x y z]"], ["proof (prove)\nusing this:\n  ?y \\<in> {?x--?z} \\<Longrightarrow> {?x--?y} \\<inter> {?y--?z} = {?y}\n  {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}\n\ngoal (1 subgoal):\n 1. {center x y z--y} \\<inter> {x--center x y z} = {center x y z}", "by auto"], ["proof (state)\nthis:\n  {center x y z--y} \\<inter> {x--center x y z} = {center x y z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "moreover"], ["proof (state)\nthis:\n  {center x y z--y} \\<inter> {x--center x y z} = {center x y z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "have \"{center x y z--y} \\<inter> {center x y z--z} = {center x y z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {center x y z--y} \\<inter> {center x y z--z} = {center x y z}", "using geodesic_segment_split(2)[of \"center x y z\" y z] center_as_intersection[of x y z]"], ["proof (prove)\nusing this:\n  center x y z \\<in> {y--z} \\<Longrightarrow>\n  {y--center x y z} \\<inter> {center x y z--z} = {center x y z}\n  {x--y} \\<inter> {x--z} \\<inter> {y--z} = {center x y z}\n\ngoal (1 subgoal):\n 1. {center x y z--y} \\<inter> {center x y z--z} = {center x y z}", "by (auto simp add: some_geodesic_commute)"], ["proof (state)\nthis:\n  {center x y z--y} \\<inter> {center x y z--z} = {center x y z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "ultimately"], ["proof (chain)\npicking this:\n  {x--y} \\<inter> {x--z} =\n  {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {center x y z--z}\n  {center x y z--y} \\<inter> {x--center x y z} = {center x y z}\n  {center x y z--y} \\<inter> {x--center x y z} = {center x y z}\n  {center x y z--y} \\<inter> {center x y z--z} = {center x y z}", "show \"{x--y} \\<inter> {x--z} = {x--center x y z}\""], ["proof (prove)\nusing this:\n  {x--y} \\<inter> {x--z} =\n  {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {x--center x y z} \\<union>\n  {center x y z--y} \\<inter> {center x y z--z}\n  {center x y z--y} \\<inter> {x--center x y z} = {center x y z}\n  {center x y z--y} \\<inter> {x--center x y z} = {center x y z}\n  {center x y z--y} \\<inter> {center x y z--z} = {center x y z}\n\ngoal (1 subgoal):\n 1. {x--y} \\<inter> {x--z} = {x--center x y z}", "by auto"], ["proof (state)\nthis:\n  {x--y} \\<inter> {x--z} = {x--center x y z}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*of context metric_tree*)"], ["", "text \\<open>We can now prove that a metric tree is Gromov hyperbolic, for $\\delta = 0$. The simplest\nproof goes through the slim triangles property: it suffices to show that, given a geodesic triangle,\nthere is a point at distance at most $0$ of each of its sides. This is the center we have\nconstructed above.\\<close>"], ["", "class metric_tree_with_delta = metric_tree + metric_space_with_deltaG +\n  assumes delta0: \"deltaG(TYPE('a::metric_space)) = 0\""], ["", "class Gromov_hyperbolic_space_0 = Gromov_hyperbolic_space +\n  assumes delta0 [simp]: \"deltaG(TYPE('a::metric_space)) = 0\""], ["", "class Gromov_hyperbolic_space_0_geodesic = Gromov_hyperbolic_space_0 + geodesic_space"], ["", "text \\<open>Isabelle does not accept cycles in the class graph. So, we will show that\n\\verb+metric_tree_with_delta+ is a subclass of \\verb+Gromov_hyperbolic_space_0_geodesic+, and\nconversely that \\verb+Gromov_hyperbolic_space_0_geodesic+ is a subclass of \\verb+metric_tree+.\n\nIn a tree, we have already proved that triangles are $0$-slim (the center is common to all sides\nof the triangle). The $0$-hyperbolicity follows from one of the equivalent characterizations\nof hyperbolicity (the other characterizations could be used as well, but the proofs would be\nless immediate.)\\<close>"], ["", "subclass (in metric_tree_with_delta) Gromov_hyperbolic_space_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.Gromov_hyperbolic_space_0 dist uniformity open deltaG", "proof (standard)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV\n 2. deltaG TYPE('a) = 0", "show \"deltaG TYPE('a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) = 0", "unfolding delta0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0", "by auto"], ["proof (state)\nthis:\n  deltaG TYPE('a) = 0\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "have \"Gromov_hyperbolic_subset (6 * 0) (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (6 * 0) UNIV", "proof (rule slim_triangles_implies_hyperbolic)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z Gxy Gyz Gxz.\n       \\<lbrakk>geodesic_segment_between Gxy x y;\n        geodesic_segment_between Gxz x z;\n        geodesic_segment_between Gyz y z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            infdist w Gxy \\<le> 0 \\<and>\n                            infdist w Gxz \\<le> 0 \\<and>\n                            infdist w Gyz \\<le> 0", "fix x::'a and y z Gxy Gyz Gxz"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y z Gxy Gyz Gxz.\n       \\<lbrakk>geodesic_segment_between Gxy x y;\n        geodesic_segment_between Gxz x z;\n        geodesic_segment_between Gyz y z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            infdist w Gxy \\<le> 0 \\<and>\n                            infdist w Gxz \\<le> 0 \\<and>\n                            infdist w Gyz \\<le> 0", "define w where \"w = center x y z\""], ["proof (state)\nthis:\n  w = center x y z\n\ngoal (1 subgoal):\n 1. \\<And>x y z Gxy Gyz Gxz.\n       \\<lbrakk>geodesic_segment_between Gxy x y;\n        geodesic_segment_between Gxz x z;\n        geodesic_segment_between Gyz y z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            infdist w Gxy \\<le> 0 \\<and>\n                            infdist w Gxz \\<le> 0 \\<and>\n                            infdist w Gyz \\<le> 0", "assume \"geodesic_segment_between Gxy x y\"\n        \"geodesic_segment_between Gxz x z\" \"geodesic_segment_between Gyz y z\""], ["proof (state)\nthis:\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  geodesic_segment_between Gyz y z\n\ngoal (1 subgoal):\n 1. \\<And>x y z Gxy Gyz Gxz.\n       \\<lbrakk>geodesic_segment_between Gxy x y;\n        geodesic_segment_between Gxz x z;\n        geodesic_segment_between Gyz y z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            infdist w Gxy \\<le> 0 \\<and>\n                            infdist w Gxz \\<le> 0 \\<and>\n                            infdist w Gyz \\<le> 0", "then"], ["proof (chain)\npicking this:\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  geodesic_segment_between Gyz y z", "have \"Gxy = {x--y}\" \"Gyz = {y--z}\" \"Gxz = {x--z}\""], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  geodesic_segment_between Gyz y z\n\ngoal (1 subgoal):\n 1. Gxy = {x--y} &&& Gyz = {y--z} &&& Gxz = {x--z}", "by (auto simp add: local.geodesic_segment_unique)"], ["proof (state)\nthis:\n  Gxy = {x--y}\n  Gyz = {y--z}\n  Gxz = {x--z}\n\ngoal (1 subgoal):\n 1. \\<And>x y z Gxy Gyz Gxz.\n       \\<lbrakk>geodesic_segment_between Gxy x y;\n        geodesic_segment_between Gxz x z;\n        geodesic_segment_between Gyz y z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            infdist w Gxy \\<le> 0 \\<and>\n                            infdist w Gxz \\<le> 0 \\<and>\n                            infdist w Gyz \\<le> 0", "then"], ["proof (chain)\npicking this:\n  Gxy = {x--y}\n  Gyz = {y--z}\n  Gxz = {x--z}", "have \"w \\<in> Gxy\" \"w \\<in> Gyz\" \"w \\<in> Gxz\""], ["proof (prove)\nusing this:\n  Gxy = {x--y}\n  Gyz = {y--z}\n  Gxz = {x--z}\n\ngoal (1 subgoal):\n 1. w \\<in> Gxy &&& w \\<in> Gyz &&& w \\<in> Gxz", "unfolding w_def"], ["proof (prove)\nusing this:\n  Gxy = {x--y}\n  Gyz = {y--z}\n  Gxz = {x--z}\n\ngoal (1 subgoal):\n 1. center x y z \\<in> Gxy &&&\n    center x y z \\<in> Gyz &&& center x y z \\<in> Gxz", "by auto"], ["proof (state)\nthis:\n  w \\<in> Gxy\n  w \\<in> Gyz\n  w \\<in> Gxz\n\ngoal (1 subgoal):\n 1. \\<And>x y z Gxy Gyz Gxz.\n       \\<lbrakk>geodesic_segment_between Gxy x y;\n        geodesic_segment_between Gxz x z;\n        geodesic_segment_between Gyz y z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            infdist w Gxy \\<le> 0 \\<and>\n                            infdist w Gxz \\<le> 0 \\<and>\n                            infdist w Gyz \\<le> 0", "then"], ["proof (chain)\npicking this:\n  w \\<in> Gxy\n  w \\<in> Gyz\n  w \\<in> Gxz", "have \"infdist w Gxy \\<le> 0 \\<and> infdist w Gxz \\<le> 0 \\<and> infdist w Gyz \\<le> 0\""], ["proof (prove)\nusing this:\n  w \\<in> Gxy\n  w \\<in> Gyz\n  w \\<in> Gxz\n\ngoal (1 subgoal):\n 1. infdist w Gxy \\<le> 0 \\<and>\n    infdist w Gxz \\<le> 0 \\<and> infdist w Gyz \\<le> 0", "by auto"], ["proof (state)\nthis:\n  infdist w Gxy \\<le> 0 \\<and>\n  infdist w Gxz \\<le> 0 \\<and> infdist w Gyz \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y z Gxy Gyz Gxz.\n       \\<lbrakk>geodesic_segment_between Gxy x y;\n        geodesic_segment_between Gxz x z;\n        geodesic_segment_between Gyz y z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            infdist w Gxy \\<le> 0 \\<and>\n                            infdist w Gxz \\<le> 0 \\<and>\n                            infdist w Gyz \\<le> 0", "then"], ["proof (chain)\npicking this:\n  infdist w Gxy \\<le> 0 \\<and>\n  infdist w Gxz \\<le> 0 \\<and> infdist w Gyz \\<le> 0", "show \"\\<exists>w. infdist w Gxy \\<le> 0 \\<and> infdist w Gxz \\<le> 0 \\<and> infdist w Gyz \\<le> 0\""], ["proof (prove)\nusing this:\n  infdist w Gxy \\<le> 0 \\<and>\n  infdist w Gxz \\<le> 0 \\<and> infdist w Gyz \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>w.\n       infdist w Gxy \\<le> 0 \\<and>\n       infdist w Gxz \\<le> 0 \\<and> infdist w Gyz \\<le> 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>w.\n     infdist w Gxy \\<le> 0 \\<and>\n     infdist w Gxz \\<le> 0 \\<and> infdist w Gyz \\<le> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_hyperbolic_subset (6 * 0) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "then"], ["proof (chain)\npicking this:\n  Gromov_hyperbolic_subset (6 * 0) UNIV", "show \"Gromov_hyperbolic_subset (deltaG TYPE('a)) (UNIV::'a set)\""], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (6 * 0) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV", "unfolding delta0"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (6 * 0) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset 0 UNIV", "by auto"], ["proof (state)\nthis:\n  Gromov_hyperbolic_subset (deltaG TYPE('a)) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>To use the fact that reals are Gromov hyperbolic, given that they are a metric tree,\nwe need to instantiate them as \\verb+metric_tree_with_delta+.\\<close>"], ["", "instantiation real::metric_tree_with_delta\nbegin"], ["", "definition deltaG_real::\"real itself \\<Rightarrow> real\"\n  where \"deltaG_real _ = 0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(real, metric_tree_with_delta_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE(real) = 0", "unfolding deltaG_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0", "by auto"], ["", "end"], ["", "text \\<open>Let us now prove the converse: a geodesic space which is $\\delta$-hyperbolic for $\\delta = 0$\nis a metric tree. For the proof, we consider two geodesic segments $G = [x,y]$ and $H = [y,z]$ with a common\nendpoint, and we have to show that their union is still a geodesic segment from $x$ to $z$. For\nthis, introduce a geodesic segment $L = [x,z]$. By the property of thin triangles, $G$ is included\nin $H \\cup L$. In particular, a point $Y$ close to $y$ but different from $y$ on $G$ is on $L$,\nand therefore realizes the equality $d(x,z) = d(x, Y) + d(Y, z)$. Passing to the limit, $y$\nalso satisfies this equality. The conclusion readily follows thanks to Lemma\n\\verb+geodesic_segment_union+.\n\\<close>"], ["", "subclass (in Gromov_hyperbolic_space_0_geodesic) metric_tree"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.metric_tree dist uniformity open", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G x y H z.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H y z; G \\<inter> H = {y}\\<rbrakk>\n       \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z", "fix G H x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G x y H z.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H y z; G \\<inter> H = {y}\\<rbrakk>\n       \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z", "assume A: \"geodesic_segment_between G x y\" \"geodesic_segment_between H y z\" \"G \\<inter> H = {y::'a}\""], ["proof (state)\nthis:\n  geodesic_segment_between G x y\n  geodesic_segment_between H y z\n  G \\<inter> H = {y}\n\ngoal (1 subgoal):\n 1. \\<And>G x y H z.\n       \\<lbrakk>geodesic_segment_between G x y;\n        geodesic_segment_between H y z; G \\<inter> H = {y}\\<rbrakk>\n       \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z", "show \"geodesic_segment_between (G \\<union> H) x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (G \\<union> H) x z", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z\n 2. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> geodesic_segment_between (G \\<union> H) x z\n 2. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "then"], ["proof (chain)\npicking this:\n  x = y", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. geodesic_segment_between (G \\<union> H) x z", "by (metis A Un_commute geodesic_segment_between_x_x(3) inf.commute sup_inf_absorb)"], ["proof (state)\nthis:\n  geodesic_segment_between (G \\<union> H) x z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "define D::\"nat \\<Rightarrow> real\" where \"D = (\\<lambda>n. dist x y - (dist x y) * (1/(real(n+1))))\""], ["proof (state)\nthis:\n  D = (\\<lambda>n. dist x y - dist x y * (1 / real (n + 1)))\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "have D: \"D n \\<in> {0..< dist x y}\" \"D n \\<in> {0..dist x y}\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. D n \\<in> {0..<dist x y} &&& D n \\<in> {0..dist x y}", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y - dist x y * (1 / real (n + 1)) \\<in> {0..<dist x y} &&&\n    dist x y - dist x y * (1 / real (n + 1)) \\<in> {0..dist x y}", "by (auto simp add: False divide_simps algebra_simps)"], ["proof (state)\nthis:\n  D ?n \\<in> {0..<dist x y}\n  D ?n \\<in> {0..dist x y}\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "have Dlim: \"D \\<longlonglongrightarrow> dist x y - dist x y * 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<longlonglongrightarrow> dist x y - dist x y * 0", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist x y - dist x y * (1 / real (n + 1)))\n    \\<longlonglongrightarrow> dist x y - dist x y * 0", "by (intro tendsto_intros LIMSEQ_ignore_initial_segment[OF lim_1_over_n, of 1])"], ["proof (state)\nthis:\n  D \\<longlonglongrightarrow> dist x y - dist x y * 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "define Y::\"nat \\<Rightarrow> 'a\" where \"Y = (\\<lambda>n. geodesic_segment_param G x (D n))\""], ["proof (state)\nthis:\n  Y = (\\<lambda>n. geodesic_segment_param G x (D n))\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "have *: \"Y \\<longlonglongrightarrow> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<longlonglongrightarrow> y", "unfolding Y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. geodesic_segment_param G x (D n))\n    \\<longlonglongrightarrow> y", "apply (subst geodesic_segment_param(2)[OF A(1), symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. geodesic_segment_param G x (D n))\n    \\<longlonglongrightarrow> geodesic_segment_param G x (dist x y)", "using isometry_on_continuous[OF geodesic_segment_param(4)[OF A(1)]]"], ["proof (prove)\nusing this:\n  continuous_on {0..dist x y} (geodesic_segment_param G x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. geodesic_segment_param G x (D n))\n    \\<longlonglongrightarrow> geodesic_segment_param G x (dist x y)", "unfolding continuous_on_sequentially comp_def"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     \\<forall>a\\<in>{0..dist x y}.\n        (\\<forall>n. xa n \\<in> {0..dist x y}) \\<and>\n        xa \\<longlonglongrightarrow> a \\<longrightarrow>\n        (\\<lambda>xb. geodesic_segment_param G x (xa xb))\n        \\<longlonglongrightarrow> geodesic_segment_param G x a\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. geodesic_segment_param G x (D n))\n    \\<longlonglongrightarrow> geodesic_segment_param G x (dist x y)", "using D(2) Dlim"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     \\<forall>a\\<in>{0..dist x y}.\n        (\\<forall>n. xa n \\<in> {0..dist x y}) \\<and>\n        xa \\<longlonglongrightarrow> a \\<longrightarrow>\n        (\\<lambda>xb. geodesic_segment_param G x (xa xb))\n        \\<longlonglongrightarrow> geodesic_segment_param G x a\n  D ?n \\<in> {0..dist x y}\n  D \\<longlonglongrightarrow> dist x y - dist x y * 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. geodesic_segment_param G x (D n))\n    \\<longlonglongrightarrow> geodesic_segment_param G x (dist x y)", "by auto"], ["proof (state)\nthis:\n  Y \\<longlonglongrightarrow> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "have \"dist x z = dist x (Y n) + dist (Y n) z\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "obtain L where L: \"geodesic_segment_between L x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>L.\n        geodesic_segment_between L x z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using geodesic_subsetD[OF geodesic]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> UNIV; ?y \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> geodesic_segment_between {?x--?y} ?x ?y\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        geodesic_segment_between L x z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  geodesic_segment_between L x z\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "have \"Y n \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y n \\<in> G", "unfolding Y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param G x (D n) \\<in> G", "apply (rule geodesic_segment_param(3)[OF A(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. D n \\<in> {0..dist x y}", "using D[of n]"], ["proof (prove)\nusing this:\n  D n \\<in> {0..<dist x y}\n  D n \\<in> {0..dist x y}\n\ngoal (1 subgoal):\n 1. D n \\<in> {0..dist x y}", "by auto"], ["proof (state)\nthis:\n  Y n \\<in> G\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "have \"dist x (Y n) = D n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (Y n) = D n", "unfolding Y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (geodesic_segment_param G x (D n)) = D n", "apply (rule geodesic_segment_param[OF A(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. D n \\<in> {0..dist x y}", "using D[of n]"], ["proof (prove)\nusing this:\n  D n \\<in> {0..<dist x y}\n  D n \\<in> {0..dist x y}\n\ngoal (1 subgoal):\n 1. D n \\<in> {0..dist x y}", "by auto"], ["proof (state)\nthis:\n  dist x (Y n) = D n\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "then"], ["proof (chain)\npicking this:\n  dist x (Y n) = D n", "have \"Y n \\<noteq> y\""], ["proof (prove)\nusing this:\n  dist x (Y n) = D n\n\ngoal (1 subgoal):\n 1. Y n \\<noteq> y", "using D[of n]"], ["proof (prove)\nusing this:\n  dist x (Y n) = D n\n  D n \\<in> {0..<dist x y}\n  D n \\<in> {0..dist x y}\n\ngoal (1 subgoal):\n 1. Y n \\<noteq> y", "by auto"], ["proof (state)\nthis:\n  Y n \\<noteq> y\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "then"], ["proof (chain)\npicking this:\n  Y n \\<noteq> y", "have \"Y n \\<notin> H\""], ["proof (prove)\nusing this:\n  Y n \\<noteq> y\n\ngoal (1 subgoal):\n 1. Y n \\<notin> H", "using A(3) \\<open>Y n \\<in> G\\<close>"], ["proof (prove)\nusing this:\n  Y n \\<noteq> y\n  G \\<inter> H = {y}\n  Y n \\<in> G\n\ngoal (1 subgoal):\n 1. Y n \\<notin> H", "by auto"], ["proof (state)\nthis:\n  Y n \\<notin> H\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "have \"infdist (Y n) (H \\<union> L) \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (Y n) (H \\<union> L) \\<le> 4 * deltaG TYPE('a)", "apply (rule thin_triangles[OF geodesic_segment_commute[OF A(2)] geodesic_segment_commute[OF L] geodesic_segment_commute[OF A(1)]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Y n \\<in> G", "using \\<open>Y n \\<in> G\\<close>"], ["proof (prove)\nusing this:\n  Y n \\<in> G\n\ngoal (1 subgoal):\n 1. Y n \\<in> G", "by simp"], ["proof (state)\nthis:\n  infdist (Y n) (H \\<union> L) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "then"], ["proof (chain)\npicking this:\n  infdist (Y n) (H \\<union> L) \\<le> 4 * deltaG TYPE('a)", "have \"infdist (Y n) (H \\<union> L) = 0\""], ["proof (prove)\nusing this:\n  infdist (Y n) (H \\<union> L) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist (Y n) (H \\<union> L) = 0", "using infdist_nonneg[of \"Y n\" \"H \\<union> L\"]"], ["proof (prove)\nusing this:\n  infdist (Y n) (H \\<union> L) \\<le> 4 * deltaG TYPE('a)\n  0 \\<le> infdist (Y n) (H \\<union> L)\n\ngoal (1 subgoal):\n 1. infdist (Y n) (H \\<union> L) = 0", "unfolding delta0"], ["proof (prove)\nusing this:\n  infdist (Y n) (H \\<union> L) \\<le> 4 * 0\n  0 \\<le> infdist (Y n) (H \\<union> L)\n\ngoal (1 subgoal):\n 1. infdist (Y n) (H \\<union> L) = 0", "by auto"], ["proof (state)\nthis:\n  infdist (Y n) (H \\<union> L) = 0\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "have \"Y n \\<in> H \\<union> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y n \\<in> H \\<union> L", "proof (subst in_closed_iff_infdist_zero)"], ["proof (state)\ngoal (3 subgoals):\n 1. closed (H \\<union> L)\n 2. H \\<union> L \\<noteq> {}\n 3. infdist (Y n) (H \\<union> L) = 0", "have \"closed H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed H", "using A(2) geodesic_segment_topology geodesic_segment_def"], ["proof (prove)\nusing this:\n  geodesic_segment_between H y z\n  geodesic_segment ?G \\<Longrightarrow> compact ?G\n  geodesic_segment ?G \\<Longrightarrow> connected ?G\n  geodesic_segment ?G \\<Longrightarrow> path_connected ?G\n  geodesic_segment ?G \\<Longrightarrow> bounded ?G\n  geodesic_segment ?G \\<Longrightarrow> closed ?G\n  geodesic_segment ?G \\<Longrightarrow> ?G \\<noteq> {}\n  geodesic_segment ?G \\<Longrightarrow> proper ?G\n  geodesic_segment ?G = (\\<exists>x y. geodesic_segment_between ?G x y)\n\ngoal (1 subgoal):\n 1. closed H", "by fastforce"], ["proof (state)\nthis:\n  closed H\n\ngoal (3 subgoals):\n 1. closed (H \\<union> L)\n 2. H \\<union> L \\<noteq> {}\n 3. infdist (Y n) (H \\<union> L) = 0", "moreover"], ["proof (state)\nthis:\n  closed H\n\ngoal (3 subgoals):\n 1. closed (H \\<union> L)\n 2. H \\<union> L \\<noteq> {}\n 3. infdist (Y n) (H \\<union> L) = 0", "have \"closed L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed L", "using L geodesic_segment_topology geodesic_segment_def"], ["proof (prove)\nusing this:\n  geodesic_segment_between L x z\n  geodesic_segment ?G \\<Longrightarrow> compact ?G\n  geodesic_segment ?G \\<Longrightarrow> connected ?G\n  geodesic_segment ?G \\<Longrightarrow> path_connected ?G\n  geodesic_segment ?G \\<Longrightarrow> bounded ?G\n  geodesic_segment ?G \\<Longrightarrow> closed ?G\n  geodesic_segment ?G \\<Longrightarrow> ?G \\<noteq> {}\n  geodesic_segment ?G \\<Longrightarrow> proper ?G\n  geodesic_segment ?G = (\\<exists>x y. geodesic_segment_between ?G x y)\n\ngoal (1 subgoal):\n 1. closed L", "by fastforce"], ["proof (state)\nthis:\n  closed L\n\ngoal (3 subgoals):\n 1. closed (H \\<union> L)\n 2. H \\<union> L \\<noteq> {}\n 3. infdist (Y n) (H \\<union> L) = 0", "ultimately"], ["proof (chain)\npicking this:\n  closed H\n  closed L", "show \"closed (H \\<union> L)\""], ["proof (prove)\nusing this:\n  closed H\n  closed L\n\ngoal (1 subgoal):\n 1. closed (H \\<union> L)", "by auto"], ["proof (state)\nthis:\n  closed (H \\<union> L)\n\ngoal (2 subgoals):\n 1. H \\<union> L \\<noteq> {}\n 2. infdist (Y n) (H \\<union> L) = 0", "show \"H \\<union> L \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<union> L \\<noteq> {}", "using A(2) geodesic_segment_endpoints(1)"], ["proof (prove)\nusing this:\n  geodesic_segment_between H y z\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> ?x \\<in> ?G\n\ngoal (1 subgoal):\n 1. H \\<union> L \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  H \\<union> L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. infdist (Y n) (H \\<union> L) = 0", "qed (fact)"], ["proof (state)\nthis:\n  Y n \\<in> H \\<union> L\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "then"], ["proof (chain)\npicking this:\n  Y n \\<in> H \\<union> L", "have \"Y n \\<in> L\""], ["proof (prove)\nusing this:\n  Y n \\<in> H \\<union> L\n\ngoal (1 subgoal):\n 1. Y n \\<in> L", "using \\<open>Y n \\<notin> H\\<close>"], ["proof (prove)\nusing this:\n  Y n \\<in> H \\<union> L\n  Y n \\<notin> H\n\ngoal (1 subgoal):\n 1. Y n \\<in> L", "by simp"], ["proof (state)\nthis:\n  Y n \\<in> L\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "using geodesic_segment_dist[OF L \\<open>Y n \\<in> L\\<close>]"], ["proof (prove)\nusing this:\n  dist x (Y n) + dist (Y n) z = dist x z\n\ngoal (1 subgoal):\n 1. dist x z = dist x (Y n) + dist (Y n) z", "by simp"], ["proof (state)\nthis:\n  dist x z = dist x (Y n) + dist (Y n) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist x z = dist x (Y ?n) + dist (Y ?n) z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "moreover"], ["proof (state)\nthis:\n  dist x z = dist x (Y ?n) + dist (Y ?n) z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "have \"(\\<lambda>n. dist x (Y n) + dist (Y n) z) \\<longlonglongrightarrow> dist x y + dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist x (Y n) + dist (Y n) z)\n    \\<longlonglongrightarrow> dist x y + dist y z", "by (intro tendsto_intros *)"], ["proof (state)\nthis:\n  (\\<lambda>n. dist x (Y n) + dist (Y n) z)\n  \\<longlonglongrightarrow> dist x y + dist y z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "ultimately"], ["proof (chain)\npicking this:\n  dist x z = dist x (Y ?n) + dist (Y ?n) z\n  (\\<lambda>n. dist x (Y n) + dist (Y n) z)\n  \\<longlonglongrightarrow> dist x y + dist y z", "have \"(\\<lambda>n. dist x z) \\<longlonglongrightarrow> dist x y + dist y z\""], ["proof (prove)\nusing this:\n  dist x z = dist x (Y ?n) + dist (Y ?n) z\n  (\\<lambda>n. dist x (Y n) + dist (Y n) z)\n  \\<longlonglongrightarrow> dist x y + dist y z\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist x z) \\<longlonglongrightarrow> dist x y + dist y z", "using filterlim_cong eventually_sequentially"], ["proof (prove)\nusing this:\n  dist x z = dist x (Y ?n) + dist (Y ?n) z\n  (\\<lambda>n. dist x (Y n) + dist (Y n) z)\n  \\<longlonglongrightarrow> dist x y + dist y z\n  \\<lbrakk>?F1.0 = ?F1'; ?F2.0 = ?F2';\n   \\<forall>\\<^sub>F x in ?F2.0. ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> filterlim ?f ?F1.0 ?F2.0 = filterlim ?g ?F1' ?F2'\n  eventually ?P sequentially = (\\<exists>N. \\<forall>n\\<ge>N. ?P n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. dist x z) \\<longlonglongrightarrow> dist x y + dist y z", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>n. dist x z) \\<longlonglongrightarrow> dist x y + dist y z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. dist x z) \\<longlonglongrightarrow> dist x y + dist y z", "have *: \"dist x z = dist x y + dist y z\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. dist x z) \\<longlonglongrightarrow> dist x y + dist y z\n\ngoal (1 subgoal):\n 1. dist x z = dist x y + dist y z", "using LIMSEQ_unique"], ["proof (prove)\nusing this:\n  (\\<lambda>n. dist x z) \\<longlonglongrightarrow> dist x y + dist y z\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?a;\n   ?X \\<longlonglongrightarrow> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. dist x z = dist x y + dist y z", "by auto"], ["proof (state)\nthis:\n  dist x z = dist x y + dist y z\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    geodesic_segment_between (G \\<union> H) x z", "show \"geodesic_segment_between (G \\<union> H) x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (G \\<union> H) x z", "by (rule geodesic_segment_union[OF * A(1) A(2)])"], ["proof (state)\nthis:\n  geodesic_segment_between (G \\<union> H) x z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  geodesic_segment_between (G \\<union> H) x z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*of theory Gromov_Hyperbolic*)"]]}