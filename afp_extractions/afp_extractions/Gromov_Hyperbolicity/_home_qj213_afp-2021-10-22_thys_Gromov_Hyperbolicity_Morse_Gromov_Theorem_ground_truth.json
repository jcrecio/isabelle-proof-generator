{"file_name": "/home/qj213/afp-2021-10-22/thys/Gromov_Hyperbolicity/Morse_Gromov_Theorem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gromov_Hyperbolicity", "problem_names": ["lemma quasiconvexD:\n  assumes \"quasiconvex C X\" \"x \\<in> X\" \"y \\<in> X\"\n  shows \"\\<exists>G. geodesic_segment_between G x y \\<and> (\\<forall>z\\<in>G. infdist z X \\<le> C)\"", "lemma quasiconvexC:\n  assumes \"quasiconvex C X\"\n  shows \"C \\<ge> 0\"", "lemma quasiconvexI:\n  assumes \"C \\<ge> 0\"\n          \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> (\\<exists>G. geodesic_segment_between G x y \\<and> (\\<forall>z\\<in>G. infdist z X \\<le> C))\"\n  shows \"quasiconvex C X\"", "lemma quasiconvex_of_geodesic:\n  assumes \"geodesic_segment G\"\n  shows \"quasiconvex 0 G\"", "lemma quasiconvex_empty:\n  assumes \"C \\<ge> 0\"\n  shows \"quasiconvex C {}\"", "lemma quasiconvex_mono:\n  assumes \"C \\<le> D\"\n          \"quasiconvex C G\"\n  shows \"quasiconvex D G\"", "lemma (in Gromov_hyperbolic_space_geodesic) quasiconvex_thickening:\n  assumes \"quasiconvex C (X::'a set)\" \"r \\<ge> 0\"\n  shows \"quasiconvex (C + 8 *deltaG(TYPE('a))) (\\<Union>x\\<in>X. cball x r)\"", "lemma (in Gromov_hyperbolic_space_geodesic) dist_along_quasiconvex:\n  assumes \"quasiconvex C G\" \"p \\<in> proj_set x G\" \"y \\<in> G\"\n  shows \"dist x p + dist p y \\<le> dist x y + 4 * deltaG(TYPE('a)) + 2 * C\"", "lemma (in Gromov_hyperbolic_space_geodesic) proj_along_quasiconvex_contraction:\n  assumes \"quasiconvex C G\" \"px \\<in> proj_set x G\" \"py \\<in> proj_set y G\"\n  shows \"dist px py \\<le> max (5 * deltaG(TYPE('a)) + 2 * C) (dist x y - dist px x - dist py y + 10 * deltaG(TYPE('a)) + 4 * C)\"", "lemma (in Gromov_hyperbolic_space_geodesic) proj_along_quasiconvex_contraction':\n  assumes \"quasiconvex C G\" \"px \\<in> proj_set x G\" \"py \\<in> proj_set y G\"\n  shows \"dist px py \\<le> dist x y + 4 * deltaG(TYPE('a)) + 2 * C\"", "lemma (in Gromov_hyperbolic_space_geodesic) dist_along_geodesic:\n  assumes \"geodesic_segment G\" \"p \\<in> proj_set x G\" \"y \\<in> G\"\n  shows \"dist x p + dist p y \\<le> dist x y + 4 * deltaG(TYPE('a))\"", "lemma (in Gromov_hyperbolic_space_geodesic) proj_along_geodesic_contraction:\n  assumes \"geodesic_segment G\" \"px \\<in> proj_set x G\" \"py \\<in> proj_set y G\"\n  shows \"dist px py \\<le> max (5 * deltaG(TYPE('a))) (dist x y - dist px x - dist py y + 10 * deltaG(TYPE('a)))\"", "lemma (in Gromov_hyperbolic_space_geodesic) proj_along_geodesic_contraction':\n  assumes \"geodesic_segment G\" \"px \\<in> proj_set x G\" \"py \\<in> proj_set y G\"\n  shows \"dist px py \\<le> dist x y + 4 * deltaG(TYPE('a))\"", "lemma (in Gromov_hyperbolic_space_geodesic) quasi_convex_projection_small_gaps:\n  assumes \"continuous_on {a..(b::real)} f\"\n          \"a \\<le> b\"\n          \"quasiconvex C G\"\n          \"\\<And>t. t \\<in> {a..b} \\<Longrightarrow> p t \\<in> proj_set (f t) G\"\n          \"delta > deltaG(TYPE('a))\"\n          \"d \\<in> {4 * delta + 2 * C..dist (p a) (p b)}\"\n  shows \"\\<exists>t \\<in> {a..b}. (dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C .. d})\n                    \\<and> (\\<forall>s \\<in> {a..t}. dist (p a) (p s) \\<le> d)\"", "lemma (in Gromov_hyperbolic_space_geodesic) quasi_convex_projection_small_gaps':\n  assumes \"continuous_on {a..(b::real)} f\"\n          \"a \\<le> b\"\n          \"quasiconvex C G\"\n          \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> p x \\<in> proj_set (f x) G\"\n          \"delta > deltaG(TYPE('a))\"\n          \"d \\<in> {4 * delta + 2 * C..dist (p a) (p b)}\"\n  shows \"\\<exists>t \\<in> {a..b}. dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C .. d}\n                    \\<and> (\\<forall>s \\<in> {t..b}. dist (p b) (p s) \\<le> d)\"", "lemma (in Gromov_hyperbolic_space_geodesic) geodesic_projection_exp_contracting_aux:\n  assumes \"geodesic_segment G\"\n          \"px \\<in> proj_set x G\"\n          \"py \\<in> proj_set y G\"\n          \"delta \\<ge> deltaG(TYPE('a))\"\n          \"dist x y \\<le> 10 * delta + C\"\n          \"M \\<ge> 15/2 * delta\"\n          \"dist px x \\<ge> M + 5 * delta + C/2\"\n          \"dist py y \\<ge> M + 5 * delta + C/2\"\n          \"C \\<ge> 0\"\n  shows \"dist (geodesic_segment_param {px--x} px M)\n              (geodesic_segment_param {py--y} py M) \\<le> 5 * delta\"", "lemma (in Gromov_hyperbolic_space_geodesic) geodesic_projection_exp_contracting:\n  assumes \"geodesic_segment G\"\n          \"\\<And>x y. x \\<in> {a..b} \\<Longrightarrow> y \\<in> {a..b} \\<Longrightarrow> dist (f x) (f y) \\<le> lambda * dist x y + C\"\n          \"a \\<le> b\"\n          \"pa \\<in> proj_set (f a) G\"\n          \"pb \\<in> proj_set (f b) G\"\n          \"\\<And>t. t \\<in> {a..b} \\<Longrightarrow> infdist (f t) G \\<ge> D\"\n          \"D \\<ge> 15/2 * delta + C/2\"\n          \"delta > deltaG(TYPE('a))\"\n          \"C \\<ge> 0\"\n          \"lambda \\<ge> 0\"\n  shows \"dist pa pb \\<le> max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (b-a) * exp(-(D-C/2) * ln 2 / (5 * delta)))\"", "lemma (in Gromov_hyperbolic_space_geodesic) quasiconvex_projection_exp_contracting:\n  assumes \"quasiconvex K G\"\n          \"\\<And>x y. x \\<in> {a..b} \\<Longrightarrow> y \\<in> {a..b} \\<Longrightarrow> dist (f x) (f y) \\<le> lambda * dist x y + C\"\n          \"a \\<le> b\"\n          \"pa \\<in> proj_set (f a) G\"\n          \"pb \\<in> proj_set (f b) G\"\n          \"\\<And>t. t \\<in> {a..b} \\<Longrightarrow> infdist (f t) G \\<ge> D\"\n          \"D \\<ge> 15/2 * delta + K + C/2\"\n          \"delta > deltaG(TYPE('a))\"\n          \"C \\<ge> 0\"\n          \"lambda \\<ge> 0\"\n  shows \"dist pa pb \\<le> 2 * K + 8 * delta + max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (b-a) * exp(-(D - K - C/2) * ln 2 / (5 * delta)))\"", "lemma (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem_aux1:\n  fixes f::\"real \\<Rightarrow> 'a\"\n  assumes \"continuous_on {a..b} f\"\n          \"lambda C-quasi_isometry_on {a..b} f\"\n          \"a \\<le> b\"\n          \"geodesic_segment_between G (f a) (f b)\"\n          \"z \\<in> {a..b}\"\n          \"delta > deltaG(TYPE('a))\"\n  shows \"infdist (f z) G \\<le> lambda^2 * (11/2 * C + 91 * delta)\"", "lemma (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem_aux2:\n  fixes f::\"real \\<Rightarrow> 'a\"\n  assumes \"continuous_on {a..b} f\"\n          \"lambda C-quasi_isometry_on {a..b} f\"\n          \"geodesic_segment_between G (f a) (f b)\"\n  shows \"hausdorff_distance (f`{a..b}) G \\<le> lambda^2 * (11/2 * C + 92 * deltaG(TYPE('a)))\"", "theorem (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem:\n  fixes f::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {a..b} f\"\n          \"geodesic_segment_between G (f a) (f b)\"\n  shows \"hausdorff_distance (f`{a..b}) G \\<le> 92 * lambda^2 * (C + deltaG(TYPE('a)))\"", "theorem (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem2:\n  fixes c d::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {A..B} c\"\n          \"lambda C-quasi_isometry_on {A..B} d\"\n          \"c A = d A\" \"c B = d B\"\n  shows \"hausdorff_distance (c`{A..B}) (d`{A..B}) \\<le> 184 * lambda^2 * (C + deltaG(TYPE('a)))\"", "lemma geodesic_quasi_isometric_image:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::Gromov_hyperbolic_space_geodesic\"\n  assumes \"lambda C-quasi_isometry_on UNIV f\"\n          \"geodesic_segment_between G x y\"\n  shows \"hausdorff_distance (f`G) {f x--f y} \\<le> 92 * lambda^2 * (C + deltaG(TYPE('b)))\"", "lemma Gromov_hyperbolic_invariant_under_quasi_isometry_explicit:\n  fixes f::\"'a::geodesic_space \\<Rightarrow> 'b::Gromov_hyperbolic_space_geodesic\"\n  assumes \"lambda C-quasi_isometry f\"\n  shows \"Gromov_hyperbolic_subset (752 * lambda^3 * (C + deltaG(TYPE('b)))) (UNIV::('a set))\"", "theorem Gromov_hyperbolic_invariant_under_quasi_isometry:\n  assumes \"quasi_isometric (UNIV::('a::geodesic_space) set) (UNIV::('b::Gromov_hyperbolic_space_geodesic) set)\"\n  shows \"\\<exists>delta. Gromov_hyperbolic_subset delta (UNIV::'a set)\"", "theorem (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem_BH_proof:\n  fixes c::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {A..B} c\"\n  shows \"hausdorff_distance (c`{A..B}) {c A--c B} \\<le> 72 * lambda^2 * (C + lambda + deltaG(TYPE('a))^2)\""], "translations": [["", "lemma quasiconvexD:\n  assumes \"quasiconvex C X\" \"x \\<in> X\" \"y \\<in> X\"\n  shows \"\\<exists>G. geodesic_segment_between G x y \\<and> (\\<forall>z\\<in>G. infdist z X \\<le> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>G.\n       geodesic_segment_between G x y \\<and>\n       (\\<forall>z\\<in>G. infdist z X \\<le> C)", "using assms"], ["proof (prove)\nusing this:\n  quasiconvex C X\n  x \\<in> X\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       geodesic_segment_between G x y \\<and>\n       (\\<forall>z\\<in>G. infdist z X \\<le> C)", "unfolding quasiconvex_def"], ["proof (prove)\nusing this:\n  0 \\<le> C \\<and>\n  (\\<forall>x\\<in>X.\n      \\<forall>y\\<in>X.\n         \\<exists>G.\n            geodesic_segment_between G x y \\<and>\n            (\\<forall>z\\<in>G. infdist z X \\<le> C))\n  x \\<in> X\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>G.\n       geodesic_segment_between G x y \\<and>\n       (\\<forall>z\\<in>G. infdist z X \\<le> C)", "by auto"], ["", "lemma quasiconvexC:\n  assumes \"quasiconvex C X\"\n  shows \"C \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C", "using assms"], ["proof (prove)\nusing this:\n  quasiconvex C X\n\ngoal (1 subgoal):\n 1. 0 \\<le> C", "unfolding quasiconvex_def"], ["proof (prove)\nusing this:\n  0 \\<le> C \\<and>\n  (\\<forall>x\\<in>X.\n      \\<forall>y\\<in>X.\n         \\<exists>G.\n            geodesic_segment_between G x y \\<and>\n            (\\<forall>z\\<in>G. infdist z X \\<le> C))\n\ngoal (1 subgoal):\n 1. 0 \\<le> C", "by auto"], ["", "lemma quasiconvexI:\n  assumes \"C \\<ge> 0\"\n          \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> (\\<exists>G. geodesic_segment_between G x y \\<and> (\\<forall>z\\<in>G. infdist z X \\<le> C))\"\n  shows \"quasiconvex C X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex C X", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  \\<lbrakk>?x \\<in> X; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>G.\n                       geodesic_segment_between G ?x ?y \\<and>\n                       (\\<forall>z\\<in>G. infdist z X \\<le> C)\n\ngoal (1 subgoal):\n 1. quasiconvex C X", "unfolding quasiconvex_def"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  \\<lbrakk>?x \\<in> X; ?y \\<in> X\\<rbrakk>\n  \\<Longrightarrow> \\<exists>G.\n                       geodesic_segment_between G ?x ?y \\<and>\n                       (\\<forall>z\\<in>G. infdist z X \\<le> C)\n\ngoal (1 subgoal):\n 1. 0 \\<le> C \\<and>\n    (\\<forall>x\\<in>X.\n        \\<forall>y\\<in>X.\n           \\<exists>G.\n              geodesic_segment_between G x y \\<and>\n              (\\<forall>z\\<in>G. infdist z X \\<le> C))", "by auto"], ["", "lemma quasiconvex_of_geodesic:\n  assumes \"geodesic_segment G\"\n  shows \"quasiconvex 0 G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex 0 G", "proof (rule quasiconvexI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ga.\n                            geodesic_segment_between Ga x y \\<and>\n                            (\\<forall>z\\<in>Ga. infdist z G \\<le> 0)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ga.\n                            geodesic_segment_between Ga x y \\<and>\n                            (\\<forall>z\\<in>Ga. infdist z G \\<le> 0)", "assume *: \"x \\<in> G\" \"y \\<in> G\""], ["proof (state)\nthis:\n  x \\<in> G\n  y \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ga.\n                            geodesic_segment_between Ga x y \\<and>\n                            (\\<forall>z\\<in>Ga. infdist z G \\<le> 0)", "obtain H where H: \"H \\<subseteq> G\" \"geodesic_segment_between H x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>H.\n        \\<lbrakk>H \\<subseteq> G; geodesic_segment_between H x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using geodesic_subsegment_exists[OF assms(1) *]"], ["proof (prove)\nusing this:\n  \\<exists>H\\<subseteq>G. geodesic_segment_between H x y\n\ngoal (1 subgoal):\n 1. (\\<And>H.\n        \\<lbrakk>H \\<subseteq> G; geodesic_segment_between H x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  H \\<subseteq> G\n  geodesic_segment_between H x y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ga.\n                            geodesic_segment_between Ga x y \\<and>\n                            (\\<forall>z\\<in>Ga. infdist z G \\<le> 0)", "have \"infdist z G \\<le> 0\" if \"z \\<in> H\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist z G \\<le> 0", "using H(1) that"], ["proof (prove)\nusing this:\n  H \\<subseteq> G\n  z \\<in> H\n\ngoal (1 subgoal):\n 1. infdist z G \\<le> 0", "by auto"], ["proof (state)\nthis:\n  ?z \\<in> H \\<Longrightarrow> infdist ?z G \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> G; y \\<in> G\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ga.\n                            geodesic_segment_between Ga x y \\<and>\n                            (\\<forall>z\\<in>Ga. infdist z G \\<le> 0)", "then"], ["proof (chain)\npicking this:\n  ?z \\<in> H \\<Longrightarrow> infdist ?z G \\<le> 0", "show \"\\<exists>H. geodesic_segment_between H x y \\<and> (\\<forall>z\\<in>H. infdist z G \\<le> 0)\""], ["proof (prove)\nusing this:\n  ?z \\<in> H \\<Longrightarrow> infdist ?z G \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>H.\n       geodesic_segment_between H x y \\<and>\n       (\\<forall>z\\<in>H. infdist z G \\<le> 0)", "using H(2)"], ["proof (prove)\nusing this:\n  ?z \\<in> H \\<Longrightarrow> infdist ?z G \\<le> 0\n  geodesic_segment_between H x y\n\ngoal (1 subgoal):\n 1. \\<exists>H.\n       geodesic_segment_between H x y \\<and>\n       (\\<forall>z\\<in>H. infdist z G \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>H.\n     geodesic_segment_between H x y \\<and>\n     (\\<forall>z\\<in>H. infdist z G \\<le> 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma quasiconvex_empty:\n  assumes \"C \\<ge> 0\"\n  shows \"quasiconvex C {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex C {}", "unfolding quasiconvex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C \\<and>\n    (\\<forall>x\\<in>{}.\n        \\<forall>y\\<in>{}.\n           \\<exists>G.\n              geodesic_segment_between G x y \\<and>\n              (\\<forall>z\\<in>G. infdist z {} \\<le> C))", "using assms"], ["proof (prove)\nusing this:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> C \\<and>\n    (\\<forall>x\\<in>{}.\n        \\<forall>y\\<in>{}.\n           \\<exists>G.\n              geodesic_segment_between G x y \\<and>\n              (\\<forall>z\\<in>G. infdist z {} \\<le> C))", "by auto"], ["", "lemma quasiconvex_mono:\n  assumes \"C \\<le> D\"\n          \"quasiconvex C G\"\n  shows \"quasiconvex D G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex D G", "using assms"], ["proof (prove)\nusing this:\n  C \\<le> D\n  quasiconvex C G\n\ngoal (1 subgoal):\n 1. quasiconvex D G", "unfolding quasiconvex_def"], ["proof (prove)\nusing this:\n  C \\<le> D\n  0 \\<le> C \\<and>\n  (\\<forall>x\\<in>G.\n      \\<forall>y\\<in>G.\n         \\<exists>Ga.\n            geodesic_segment_between Ga x y \\<and>\n            (\\<forall>z\\<in>Ga. infdist z G \\<le> C))\n\ngoal (1 subgoal):\n 1. 0 \\<le> D \\<and>\n    (\\<forall>x\\<in>G.\n        \\<forall>y\\<in>G.\n           \\<exists>Ga.\n              geodesic_segment_between Ga x y \\<and>\n              (\\<forall>z\\<in>Ga. infdist z G \\<le> D))", "by (auto, fastforce)"], ["", "text \\<open>The $r$-neighborhood of a quasi-convex set is still quasi-convex in a hyperbolic space,\nfor a constant that does not depend on $r$.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) quasiconvex_thickening:\n  assumes \"quasiconvex C (X::'a set)\" \"r \\<ge> 0\"\n  shows \"quasiconvex (C + 8 *deltaG(TYPE('a))) (\\<Union>x\\<in>X. cball x r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (C + 8 * deltaG TYPE('a)) (\\<Union>x\\<in>X. cball x r)", "proof (rule quasiconvexI)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> C + 8 * deltaG TYPE('a)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>x\\<in>X. cball x r);\n        y \\<in> (\\<Union>x\\<in>X. cball x r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>G.\n                            geodesic_segment_between G x y \\<and>\n                            (\\<forall>z\\<in>G.\n                                infdist z (\\<Union>x\\<in>X. cball x r)\n                                \\<le> C + 8 * deltaG TYPE('a))", "show \"C + 8 *deltaG(TYPE('a)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C + 8 * deltaG TYPE('a)", "using quasiconvexC[OF assms(1)]"], ["proof (prove)\nusing this:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> C + 8 * deltaG TYPE('a)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> C + 8 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>x\\<in>X. cball x r);\n        y \\<in> (\\<Union>x\\<in>X. cball x r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>G.\n                            geodesic_segment_between G x y \\<and>\n                            (\\<forall>z\\<in>G.\n                                infdist z (\\<Union>x\\<in>X. cball x r)\n                                \\<le> C + 8 * deltaG TYPE('a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>x\\<in>X. cball x r);\n        y \\<in> (\\<Union>x\\<in>X. cball x r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>G.\n                            geodesic_segment_between G x y \\<and>\n                            (\\<forall>z\\<in>G.\n                                infdist z (\\<Union>x\\<in>X. cball x r)\n                                \\<le> C + 8 * deltaG TYPE('a))", "fix y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>x\\<in>X. cball x r);\n        y \\<in> (\\<Union>x\\<in>X. cball x r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>G.\n                            geodesic_segment_between G x y \\<and>\n                            (\\<forall>z\\<in>G.\n                                infdist z (\\<Union>x\\<in>X. cball x r)\n                                \\<le> C + 8 * deltaG TYPE('a))", "assume *: \"y \\<in> (\\<Union>x\\<in>X. cball x r)\" \"z \\<in> (\\<Union>x\\<in>X. cball x r)\""], ["proof (state)\nthis:\n  y \\<in> (\\<Union>x\\<in>X. cball x r)\n  z \\<in> (\\<Union>x\\<in>X. cball x r)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>x\\<in>X. cball x r);\n        y \\<in> (\\<Union>x\\<in>X. cball x r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>G.\n                            geodesic_segment_between G x y \\<and>\n                            (\\<forall>z\\<in>G.\n                                infdist z (\\<Union>x\\<in>X. cball x r)\n                                \\<le> C + 8 * deltaG TYPE('a))", "have A: \"infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)\" if \"w \\<in> {y--z}\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "obtain py where py: \"py \\<in> X\" \"y \\<in> cball py r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>py.\n        \\<lbrakk>py \\<in> X; y \\<in> cball py r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using *"], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>x\\<in>X. cball x r)\n  z \\<in> (\\<Union>x\\<in>X. cball x r)\n\ngoal (1 subgoal):\n 1. (\\<And>py.\n        \\<lbrakk>py \\<in> X; y \\<in> cball py r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  py \\<in> X\n  y \\<in> cball py r\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "obtain pz where pz: \"pz \\<in> X\" \"z \\<in> cball pz r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pz.\n        \\<lbrakk>pz \\<in> X; z \\<in> cball pz r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using *"], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>x\\<in>X. cball x r)\n  z \\<in> (\\<Union>x\\<in>X. cball x r)\n\ngoal (1 subgoal):\n 1. (\\<And>pz.\n        \\<lbrakk>pz \\<in> X; z \\<in> cball pz r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pz \\<in> X\n  z \\<in> cball pz r\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "obtain G where G: \"geodesic_segment_between G py pz\" \"(\\<forall>p\\<in>G. infdist p X \\<le> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>geodesic_segment_between G py pz;\n         \\<forall>p\\<in>G. infdist p X \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using quasiconvexD[OF assms(1) \\<open>py \\<in> X\\<close> \\<open>pz \\<in> X\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>G.\n     geodesic_segment_between G py pz \\<and>\n     (\\<forall>z\\<in>G. infdist z X \\<le> C)\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>geodesic_segment_between G py pz;\n         \\<forall>p\\<in>G. infdist p X \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between G py pz\n  \\<forall>p\\<in>G. infdist p X \\<le> C\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "have A: \"infdist w ({y--py} \\<union> G \\<union> {pz--z}) \\<le> 8 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w ({y--py} \\<union> G \\<union> {pz--z})\n    \\<le> 8 * deltaG TYPE('a)", "by (rule thin_quadrilaterals[OF _ G(1) _ _ \\<open>w \\<in> {y--z}\\<close>, where ?x = y and ?t = z], auto)"], ["proof (state)\nthis:\n  infdist w ({y--py} \\<union> G \\<union> {pz--z}) \\<le> 8 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "have \"\\<exists>u \\<in> {y--py} \\<union> G \\<union> {pz--z}. infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>{y--py} \\<union> G \\<union> {pz--z}.\n       infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u", "apply (rule infdist_proper_attained, auto intro!: proper_Un simp add: geodesic_segment_topology(7))"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper G", "by (meson G(1) geodesic_segmentI geodesic_segment_topology(7))"], ["proof (state)\nthis:\n  \\<exists>u\\<in>{y--py} \\<union> G \\<union> {pz--z}.\n     infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>{y--py} \\<union> G \\<union> {pz--z}.\n     infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u", "obtain u where u: \"u \\<in> {y--py} \\<union> G \\<union> {pz--z}\" \"infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>{y--py} \\<union> G \\<union> {pz--z}.\n     infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> {y--py} \\<union> G \\<union> {pz--z};\n         infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> {y--py} \\<union> G \\<union> {pz--z}\n  infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  u \\<in> {y--py} \\<union> G \\<union> {pz--z}\n  infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u", "consider \"u \\<in> {y--py}\" | \"u \\<in> G\" | \"u \\<in> {pz--z}\""], ["proof (prove)\nusing this:\n  u \\<in> {y--py} \\<union> G \\<union> {pz--z}\n  infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> {y--py} \\<Longrightarrow> thesis;\n     u \\<in> G \\<Longrightarrow> thesis;\n     u \\<in> {pz--z} \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>u \\<in> {y--py} \\<Longrightarrow> ?thesis;\n   u \\<in> G \\<Longrightarrow> ?thesis;\n   u \\<in> {pz--z} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>u \\<in> {y--py} \\<Longrightarrow> ?thesis;\n   u \\<in> G \\<Longrightarrow> ?thesis;\n   u \\<in> {pz--z} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\""], ["proof (prove)\nusing this:\n  \\<lbrakk>u \\<in> {y--py} \\<Longrightarrow> ?thesis;\n   u \\<in> G \\<Longrightarrow> ?thesis;\n   u \\<in> {pz--z} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. u \\<in> {y--py} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 3. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "case 1"], ["proof (state)\nthis:\n  u \\<in> {y--py}\n\ngoal (3 subgoals):\n 1. u \\<in> {y--py} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 3. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "then"], ["proof (chain)\npicking this:\n  u \\<in> {y--py}", "have \"dist py u \\<le> dist py y\""], ["proof (prove)\nusing this:\n  u \\<in> {y--py}\n\ngoal (1 subgoal):\n 1. dist py u \\<le> dist py y", "using geodesic_segment_dist_le local.some_geodesic_is_geodesic_segment(1) some_geodesic_commute some_geodesic_endpoints(1)"], ["proof (prove)\nusing this:\n  u \\<in> {y--py}\n  \\<lbrakk>geodesic_segment_between ?G ?x ?y; ?a \\<in> ?G;\n   ?b \\<in> ?G\\<rbrakk>\n  \\<Longrightarrow> dist ?a ?b \\<le> dist ?x ?y\n  geodesic_segment_between {?x--?y} ?x ?y\n  {?x--?S--?y} = {?y--?S--?x}\n  ?x \\<in> {?x--?S--?y}\n\ngoal (1 subgoal):\n 1. dist py u \\<le> dist py y", "by blast"], ["proof (state)\nthis:\n  dist py u \\<le> dist py y\n\ngoal (3 subgoals):\n 1. u \\<in> {y--py} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 3. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "also"], ["proof (state)\nthis:\n  dist py u \\<le> dist py y\n\ngoal (3 subgoals):\n 1. u \\<in> {y--py} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 3. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "have \"... \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py y \\<le> r", "using py(2)"], ["proof (prove)\nusing this:\n  y \\<in> cball py r\n\ngoal (1 subgoal):\n 1. dist py y \\<le> r", "by auto"], ["proof (state)\nthis:\n  dist py y \\<le> r\n\ngoal (3 subgoals):\n 1. u \\<in> {y--py} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 3. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "finally"], ["proof (chain)\npicking this:\n  dist py u \\<le> r", "have \"u \\<in> cball py r\""], ["proof (prove)\nusing this:\n  dist py u \\<le> r\n\ngoal (1 subgoal):\n 1. u \\<in> cball py r", "by auto"], ["proof (state)\nthis:\n  u \\<in> cball py r\n\ngoal (3 subgoals):\n 1. u \\<in> {y--py} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 3. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "then"], ["proof (chain)\npicking this:\n  u \\<in> cball py r", "have \"u \\<in> (\\<Union>x\\<in>X. cball x r)\""], ["proof (prove)\nusing this:\n  u \\<in> cball py r\n\ngoal (1 subgoal):\n 1. u \\<in> (\\<Union>x\\<in>X. cball x r)", "using py(1)"], ["proof (prove)\nusing this:\n  u \\<in> cball py r\n  py \\<in> X\n\ngoal (1 subgoal):\n 1. u \\<in> (\\<Union>x\\<in>X. cball x r)", "by auto"], ["proof (state)\nthis:\n  u \\<in> (\\<Union>x\\<in>X. cball x r)\n\ngoal (3 subgoals):\n 1. u \\<in> {y--py} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 3. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "then"], ["proof (chain)\npicking this:\n  u \\<in> (\\<Union>x\\<in>X. cball x r)", "have \"infdist u (\\<Union>x\\<in>X. cball x r) = 0\""], ["proof (prove)\nusing this:\n  u \\<in> (\\<Union>x\\<in>X. cball x r)\n\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) = 0", "by auto"], ["proof (state)\nthis:\n  infdist u (\\<Union>x\\<in>X. cball x r) = 0\n\ngoal (3 subgoals):\n 1. u \\<in> {y--py} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 3. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "then"], ["proof (chain)\npicking this:\n  infdist u (\\<Union>x\\<in>X. cball x r) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist u (\\<Union>x\\<in>X. cball x r) = 0\n\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "using quasiconvexC[OF assms(1)]"], ["proof (prove)\nusing this:\n  infdist u (\\<Union>x\\<in>X. cball x r) = 0\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "by auto"], ["proof (state)\nthis:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n\ngoal (2 subgoals):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "case 3"], ["proof (state)\nthis:\n  u \\<in> {pz--z}\n\ngoal (2 subgoals):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "then"], ["proof (chain)\npicking this:\n  u \\<in> {pz--z}", "have \"dist pz u \\<le> dist pz z\""], ["proof (prove)\nusing this:\n  u \\<in> {pz--z}\n\ngoal (1 subgoal):\n 1. dist pz u \\<le> dist pz z", "using geodesic_segment_dist_le local.some_geodesic_is_geodesic_segment(1) some_geodesic_commute some_geodesic_endpoints(1)"], ["proof (prove)\nusing this:\n  u \\<in> {pz--z}\n  \\<lbrakk>geodesic_segment_between ?G ?x ?y; ?a \\<in> ?G;\n   ?b \\<in> ?G\\<rbrakk>\n  \\<Longrightarrow> dist ?a ?b \\<le> dist ?x ?y\n  geodesic_segment_between {?x--?y} ?x ?y\n  {?x--?S--?y} = {?y--?S--?x}\n  ?x \\<in> {?x--?S--?y}\n\ngoal (1 subgoal):\n 1. dist pz u \\<le> dist pz z", "by blast"], ["proof (state)\nthis:\n  dist pz u \\<le> dist pz z\n\ngoal (2 subgoals):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "also"], ["proof (state)\nthis:\n  dist pz u \\<le> dist pz z\n\ngoal (2 subgoals):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "have \"... \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pz z \\<le> r", "using pz(2)"], ["proof (prove)\nusing this:\n  z \\<in> cball pz r\n\ngoal (1 subgoal):\n 1. dist pz z \\<le> r", "by auto"], ["proof (state)\nthis:\n  dist pz z \\<le> r\n\ngoal (2 subgoals):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "finally"], ["proof (chain)\npicking this:\n  dist pz u \\<le> r", "have \"u \\<in> cball pz r\""], ["proof (prove)\nusing this:\n  dist pz u \\<le> r\n\ngoal (1 subgoal):\n 1. u \\<in> cball pz r", "by auto"], ["proof (state)\nthis:\n  u \\<in> cball pz r\n\ngoal (2 subgoals):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "then"], ["proof (chain)\npicking this:\n  u \\<in> cball pz r", "have \"u \\<in> (\\<Union>x\\<in>X. cball x r)\""], ["proof (prove)\nusing this:\n  u \\<in> cball pz r\n\ngoal (1 subgoal):\n 1. u \\<in> (\\<Union>x\\<in>X. cball x r)", "using pz(1)"], ["proof (prove)\nusing this:\n  u \\<in> cball pz r\n  pz \\<in> X\n\ngoal (1 subgoal):\n 1. u \\<in> (\\<Union>x\\<in>X. cball x r)", "by auto"], ["proof (state)\nthis:\n  u \\<in> (\\<Union>x\\<in>X. cball x r)\n\ngoal (2 subgoals):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "then"], ["proof (chain)\npicking this:\n  u \\<in> (\\<Union>x\\<in>X. cball x r)", "have \"infdist u (\\<Union>x\\<in>X. cball x r) = 0\""], ["proof (prove)\nusing this:\n  u \\<in> (\\<Union>x\\<in>X. cball x r)\n\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) = 0", "by auto"], ["proof (state)\nthis:\n  infdist u (\\<Union>x\\<in>X. cball x r) = 0\n\ngoal (2 subgoals):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n 2. u \\<in> {pz--z} \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "then"], ["proof (chain)\npicking this:\n  infdist u (\\<Union>x\\<in>X. cball x r) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist u (\\<Union>x\\<in>X. cball x r) = 0\n\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "using quasiconvexC[OF assms(1)]"], ["proof (prove)\nusing this:\n  infdist u (\\<Union>x\\<in>X. cball x r) = 0\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "by auto"], ["proof (state)\nthis:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n\ngoal (1 subgoal):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "case 2"], ["proof (state)\nthis:\n  u \\<in> G\n\ngoal (1 subgoal):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "have \"infdist u (\\<Union>x\\<in>X. cball x r) \\<le> infdist u X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) \\<le> infdist u X", "apply (rule infdist_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. X \\<subseteq> (\\<Union>x\\<in>X. cball x r)\n 2. X \\<noteq> {}", "using assms(2) py(1)"], ["proof (prove)\nusing this:\n  0 \\<le> r\n  py \\<in> X\n\ngoal (2 subgoals):\n 1. X \\<subseteq> (\\<Union>x\\<in>X. cball x r)\n 2. X \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> infdist u X\n\ngoal (1 subgoal):\n 1. u \\<in> G \\<Longrightarrow>\n    infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "then"], ["proof (chain)\npicking this:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> infdist u X", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> infdist u X\n\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "using 2 G(2)"], ["proof (prove)\nusing this:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> infdist u X\n  u \\<in> G\n  \\<forall>p\\<in>G. infdist p X \\<le> C\n\ngoal (1 subgoal):\n 1. infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C", "by auto"], ["proof (state)\nthis:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "moreover"], ["proof (state)\nthis:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "have \"infdist w (\\<Union>x\\<in>X. cball x r) \\<le> infdist u (\\<Union>x\\<in>X. cball x r) + dist w u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r)\n    \\<le> infdist u (\\<Union>x\\<in>X. cball x r) + dist w u", "by (intro mono_intros)"], ["proof (state)\nthis:\n  infdist w (\\<Union>x\\<in>X. cball x r)\n  \\<le> infdist u (\\<Union>x\\<in>X. cball x r) + dist w u\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "ultimately"], ["proof (chain)\npicking this:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n  infdist w (\\<Union>x\\<in>X. cball x r)\n  \\<le> infdist u (\\<Union>x\\<in>X. cball x r) + dist w u", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n  infdist w (\\<Union>x\\<in>X. cball x r)\n  \\<le> infdist u (\\<Union>x\\<in>X. cball x r) + dist w u\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "using A u(2)"], ["proof (prove)\nusing this:\n  infdist u (\\<Union>x\\<in>X. cball x r) \\<le> C\n  infdist w (\\<Union>x\\<in>X. cball x r)\n  \\<le> infdist u (\\<Union>x\\<in>X. cball x r) + dist w u\n  infdist w ({y--py} \\<union> G \\<union> {pz--z}) \\<le> 8 * deltaG TYPE('a)\n  infdist w ({y--py} \\<union> G \\<union> {pz--z}) = dist w u\n\ngoal (1 subgoal):\n 1. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?w \\<in> {y--z} \\<Longrightarrow>\n  infdist ?w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> (\\<Union>x\\<in>X. cball x r);\n        y \\<in> (\\<Union>x\\<in>X. cball x r)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>G.\n                            geodesic_segment_between G x y \\<and>\n                            (\\<forall>z\\<in>G.\n                                infdist z (\\<Union>x\\<in>X. cball x r)\n                                \\<le> C + 8 * deltaG TYPE('a))", "show \"\\<exists>G. geodesic_segment_between G y z \\<and> (\\<forall>w\\<in>G. infdist w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>G.\n       geodesic_segment_between G y z \\<and>\n       (\\<forall>w\\<in>G.\n           infdist w (\\<Union>x\\<in>X. cball x r)\n           \\<le> C + 8 * deltaG TYPE('a))", "apply (rule exI[of _ \"{y--z}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between {y--z} y z \\<and>\n    (\\<forall>w\\<in>{y--z}.\n        infdist w (\\<Union>x\\<in>X. cball x r)\n        \\<le> C + 8 * deltaG TYPE('a))", "using A"], ["proof (prove)\nusing this:\n  ?w \\<in> {y--z} \\<Longrightarrow>\n  infdist ?w (\\<Union>x\\<in>X. cball x r) \\<le> C + 8 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. geodesic_segment_between {y--z} y z \\<and>\n    (\\<forall>w\\<in>{y--z}.\n        infdist w (\\<Union>x\\<in>X. cball x r)\n        \\<le> C + 8 * deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  \\<exists>G.\n     geodesic_segment_between G y z \\<and>\n     (\\<forall>w\\<in>G.\n         infdist w (\\<Union>x\\<in>X. cball x r)\n         \\<le> C + 8 * deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If $x$ has a projection $p$ on a quasi-convex set $G$, then all segments from a point in $G$\nto $x$ go close to $p$, i.e., the triangular inequality $d(x,y) \\leq d(x,p) + d(p,y)$ is essentially\nan equality, up to an additive constant.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) dist_along_quasiconvex:\n  assumes \"quasiconvex C G\" \"p \\<in> proj_set x G\" \"y \\<in> G\"\n  shows \"dist x p + dist p y \\<le> dist x y + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "have *: \"p \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> G", "using assms proj_setD"], ["proof (prove)\nusing this:\n  quasiconvex C G\n  p \\<in> proj_set x G\n  y \\<in> G\n  ?y \\<in> proj_set ?x ?A \\<Longrightarrow> ?y \\<in> ?A\n  ?y \\<in> proj_set ?x ?A \\<Longrightarrow> dist ?x ?y = infdist ?x ?A\n\ngoal (1 subgoal):\n 1. p \\<in> G", "by auto"], ["proof (state)\nthis:\n  p \\<in> G\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "obtain H where H: \"geodesic_segment_between H p y\" \"\\<And>q. q \\<in> H \\<Longrightarrow> infdist q G \\<le> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>H.\n        \\<lbrakk>geodesic_segment_between H p y;\n         \\<And>q. q \\<in> H \\<Longrightarrow> infdist q G \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using quasiconvexD[OF assms(1) * assms(3)]"], ["proof (prove)\nusing this:\n  \\<exists>Ga.\n     geodesic_segment_between Ga p y \\<and>\n     (\\<forall>z\\<in>Ga. infdist z G \\<le> C)\n\ngoal (1 subgoal):\n 1. (\\<And>H.\n        \\<lbrakk>geodesic_segment_between H p y;\n         \\<And>q. q \\<in> H \\<Longrightarrow> infdist q G \\<le> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between H p y\n  ?q \\<in> H \\<Longrightarrow> infdist ?q G \\<le> C\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "have \"\\<exists>m\\<in>H. infdist x H = dist x m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>H. infdist x H = dist x m", "apply (rule infdist_proper_attained[of H x])"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper H\n 2. H \\<noteq> {}", "using geodesic_segment_topology[OF geodesic_segmentI[OF H(1)]]"], ["proof (prove)\nusing this:\n  compact H\n  connected H\n  path_connected H\n  bounded H\n  closed H\n  H \\<noteq> {}\n  proper H\n\ngoal (2 subgoals):\n 1. proper H\n 2. H \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<in>H. infdist x H = dist x m\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "then"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>H. infdist x H = dist x m", "obtain m where m: \"m \\<in> H\" \"infdist x H = dist x m\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>H. infdist x H = dist x m\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<in> H; infdist x H = dist x m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m \\<in> H\n  infdist x H = dist x m\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "then"], ["proof (chain)\npicking this:\n  m \\<in> H\n  infdist x H = dist x m", "have I: \"dist x m \\<le> Gromov_product_at x p y + 2 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  m \\<in> H\n  infdist x H = dist x m\n\ngoal (1 subgoal):\n 1. dist x m \\<le> Gromov_product_at x p y + 2 * deltaG TYPE('a)", "using infdist_triangle_side[OF H(1), of x]"], ["proof (prove)\nusing this:\n  m \\<in> H\n  infdist x H = dist x m\n  infdist x H \\<le> Gromov_product_at x p y + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist x m \\<le> Gromov_product_at x p y + 2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist x m \\<le> Gromov_product_at x p y + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "have \"dist x p - dist x m - C \\<le> e\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "have \"\\<exists>r\\<in>G. dist m r < infdist m G + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r\\<in>G. dist m r < infdist m G + e", "apply (rule infdist_almost_attained)"], ["proof (prove)\ngoal (2 subgoals):\n 1. infdist m G < infdist m G + e\n 2. G \\<noteq> {}", "using \\<open>e > 0\\<close> assms(3)"], ["proof (prove)\nusing this:\n  0 < e\n  y \\<in> G\n\ngoal (2 subgoals):\n 1. infdist m G < infdist m G + e\n 2. G \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>r\\<in>G. dist m r < infdist m G + e\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "then"], ["proof (chain)\npicking this:\n  \\<exists>r\\<in>G. dist m r < infdist m G + e", "obtain r where r: \"r \\<in> G\" \"dist m r < infdist m G + e\""], ["proof (prove)\nusing this:\n  \\<exists>r\\<in>G. dist m r < infdist m G + e\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> G; dist m r < infdist m G + e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r \\<in> G\n  dist m r < infdist m G + e\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "then"], ["proof (chain)\npicking this:\n  r \\<in> G\n  dist m r < infdist m G + e", "have *: \"dist m r \\<le> C + e\""], ["proof (prove)\nusing this:\n  r \\<in> G\n  dist m r < infdist m G + e\n\ngoal (1 subgoal):\n 1. dist m r \\<le> C + e", "using H(2)[OF \\<open>m \\<in> H\\<close>]"], ["proof (prove)\nusing this:\n  r \\<in> G\n  dist m r < infdist m G + e\n  infdist m G \\<le> C\n\ngoal (1 subgoal):\n 1. dist m r \\<le> C + e", "by auto"], ["proof (state)\nthis:\n  dist m r \\<le> C + e\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "have \"dist x p \\<le> dist x r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x p \\<le> dist x r", "using \\<open>r \\<in> G\\<close> assms(2) proj_set_dist_le"], ["proof (prove)\nusing this:\n  r \\<in> G\n  p \\<in> proj_set x G\n  \\<lbrakk>?y \\<in> ?A; ?p \\<in> proj_set ?x ?A\\<rbrakk>\n  \\<Longrightarrow> dist ?x ?p \\<le> dist ?x ?y\n\ngoal (1 subgoal):\n 1. dist x p \\<le> dist x r", "by blast"], ["proof (state)\nthis:\n  dist x p \\<le> dist x r\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "also"], ["proof (state)\nthis:\n  dist x p \\<le> dist x r\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "have \"... \\<le> dist x m + dist m r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x r \\<le> dist x m + dist m r", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist x r \\<le> dist x m + dist m r\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "finally"], ["proof (chain)\npicking this:\n  dist x p \\<le> dist x m + dist m r", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x p \\<le> dist x m + dist m r\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "using *"], ["proof (prove)\nusing this:\n  dist x p \\<le> dist x m + dist m r\n  dist m r \\<le> C + e\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> e", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x p - dist x m - C \\<le> e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow> dist x p - dist x m - C \\<le> ?e\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow> dist x p - dist x m - C \\<le> ?e", "have \"dist x p - dist x m - C \\<le> 0\""], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> dist x p - dist x m - C \\<le> ?e\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> 0", "using dense_ge"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> dist x p - dist x m - C \\<le> ?e\n  (\\<And>x. ?z < x \\<Longrightarrow> ?y \\<le> x) \\<Longrightarrow>\n  ?y \\<le> ?z\n\ngoal (1 subgoal):\n 1. dist x p - dist x m - C \\<le> 0", "by blast"], ["proof (state)\nthis:\n  dist x p - dist x m - C \\<le> 0\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "then"], ["proof (chain)\npicking this:\n  dist x p - dist x m - C \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x p - dist x m - C \\<le> 0\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "using I"], ["proof (prove)\nusing this:\n  dist x p - dist x m - C \\<le> 0\n  dist x m \\<le> Gromov_product_at x p y + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist x p - dist x m - C \\<le> 0\n  dist x m \\<le> (dist x p + dist x y - dist p y) / 2 + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next lemma is~\\cite[Proposition 10.2.1]{coornaert_delzant_papadopoulos} with better\nconstants. It states that the distance between the projections\non a quasi-convex set is controlled by the distance of the original points, with a gain given by the\ndistances of the points to the set.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) proj_along_quasiconvex_contraction:\n  assumes \"quasiconvex C G\" \"px \\<in> proj_set x G\" \"py \\<in> proj_set y G\"\n  shows \"dist px py \\<le> max (5 * deltaG(TYPE('a)) + 2 * C) (dist x y - dist px x - dist py y + 10 * deltaG(TYPE('a)) + 4 * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "have \"px \\<in> G\" \"py \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. px \\<in> G &&& py \\<in> G", "using assms proj_setD"], ["proof (prove)\nusing this:\n  quasiconvex C G\n  px \\<in> proj_set x G\n  py \\<in> proj_set y G\n  ?y \\<in> proj_set ?x ?A \\<Longrightarrow> ?y \\<in> ?A\n  ?y \\<in> proj_set ?x ?A \\<Longrightarrow> dist ?x ?y = infdist ?x ?A\n\ngoal (1 subgoal):\n 1. px \\<in> G &&& py \\<in> G", "by auto"], ["proof (state)\nthis:\n  px \\<in> G\n  py \\<in> G\n\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "have \"(dist x px + dist px py - 4 * deltaG(TYPE('a)) - 2 * C) + (dist y py + dist py px - 4 *deltaG(TYPE('a)) - 2 * C)\n        \\<le> dist x py + dist y px\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x px + dist px py - 4 * deltaG TYPE('a) - 2 * C +\n    (dist y py + dist py px - 4 * deltaG TYPE('a) - 2 * C)\n    \\<le> dist x py + dist y px", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x px + dist px py - 4 * deltaG TYPE('a) - 2 * C \\<le> dist x py\n 2. dist y py + dist py px - 4 * deltaG TYPE('a) - 2 * C \\<le> dist y px", "using dist_along_quasiconvex[OF assms(1) assms(2) \\<open>py \\<in> G\\<close>] dist_along_quasiconvex[OF assms(1) assms(3) \\<open>px \\<in> G\\<close>]"], ["proof (prove)\nusing this:\n  dist x px + dist px py \\<le> dist x py + 4 * deltaG TYPE('a) + 2 * C\n  dist y py + dist py px \\<le> dist y px + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (2 subgoals):\n 1. dist x px + dist px py - 4 * deltaG TYPE('a) - 2 * C \\<le> dist x py\n 2. dist y py + dist py px - 4 * deltaG TYPE('a) - 2 * C \\<le> dist y px", "by auto"], ["proof (state)\nthis:\n  dist x px + dist px py - 4 * deltaG TYPE('a) - 2 * C +\n  (dist y py + dist py px - 4 * deltaG TYPE('a) - 2 * C)\n  \\<le> dist x py + dist y px\n\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "also"], ["proof (state)\nthis:\n  dist x px + dist px py - 4 * deltaG TYPE('a) - 2 * C +\n  (dist y py + dist py px - 4 * deltaG TYPE('a) - 2 * C)\n  \\<le> dist x py + dist y px\n\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "have \"... \\<le> max (dist x y + dist py px) (dist x px + dist py y) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x py + dist y px\n    \\<le> max (dist x y + dist py px) (dist x px + dist py y) +\n          2 * deltaG TYPE('a)", "by (rule hyperb_quad_ineq)"], ["proof (state)\nthis:\n  dist x py + dist y px\n  \\<le> max (dist x y + dist py px) (dist x px + dist py y) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "finally"], ["proof (chain)\npicking this:\n  dist x px + dist px py - 4 * deltaG TYPE('a) - 2 * C +\n  (dist y py + dist py px - 4 * deltaG TYPE('a) - 2 * C)\n  \\<le> max (dist x y + dist py px) (dist x px + dist py y) +\n        2 * deltaG TYPE('a)", "have *: \"dist x px + dist y py + 2 * dist px py\n          \\<le> max (dist x y + dist py px) (dist x px + dist py y) + 10 * deltaG(TYPE('a)) + 4 * C\""], ["proof (prove)\nusing this:\n  dist x px + dist px py - 4 * deltaG TYPE('a) - 2 * C +\n  (dist y py + dist py px - 4 * deltaG TYPE('a) - 2 * C)\n  \\<le> max (dist x y + dist py px) (dist x px + dist py y) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist x px + dist y py + 2 * dist px py\n    \\<le> max (dist x y + dist py px) (dist x px + dist py y) +\n          10 * deltaG TYPE('a) +\n          4 * C", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist x px + dist y py + 2 * dist px py\n  \\<le> max (dist x y + dist py px) (dist x px + dist py y) +\n        10 * deltaG TYPE('a) +\n        4 * C\n\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "proof (cases \"dist x y + dist py px \\<ge> dist x px + dist py y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dist x px + dist py y \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)\n 2. \\<not> dist x px + dist py y\n           \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "case True"], ["proof (state)\nthis:\n  dist x px + dist py y \\<le> dist x y + dist py px\n\ngoal (2 subgoals):\n 1. dist x px + dist py y \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)\n 2. \\<not> dist x px + dist py y\n           \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "then"], ["proof (chain)\npicking this:\n  dist x px + dist py y \\<le> dist x y + dist py px", "have \"dist x px + dist y py + 2 * dist px py \\<le> dist x y + dist py px + 10 * deltaG(TYPE('a)) + 4 * C\""], ["proof (prove)\nusing this:\n  dist x px + dist py y \\<le> dist x y + dist py px\n\ngoal (1 subgoal):\n 1. dist x px + dist y py + 2 * dist px py\n    \\<le> dist x y + dist py px + 10 * deltaG TYPE('a) + 4 * C", "using *"], ["proof (prove)\nusing this:\n  dist x px + dist py y \\<le> dist x y + dist py px\n  dist x px + dist y py + 2 * dist px py\n  \\<le> max (dist x y + dist py px) (dist x px + dist py y) +\n        10 * deltaG TYPE('a) +\n        4 * C\n\ngoal (1 subgoal):\n 1. dist x px + dist y py + 2 * dist px py\n    \\<le> dist x y + dist py px + 10 * deltaG TYPE('a) + 4 * C", "by auto"], ["proof (state)\nthis:\n  dist x px + dist y py + 2 * dist px py\n  \\<le> dist x y + dist py px + 10 * deltaG TYPE('a) + 4 * C\n\ngoal (2 subgoals):\n 1. dist x px + dist py y \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)\n 2. \\<not> dist x px + dist py y\n           \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "then"], ["proof (chain)\npicking this:\n  dist x px + dist y py + 2 * dist px py\n  \\<le> dist x y + dist py px + 10 * deltaG TYPE('a) + 4 * C", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x px + dist y py + 2 * dist px py\n  \\<le> dist x y + dist py px + 10 * deltaG TYPE('a) + 4 * C\n\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist px py\n  \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n         (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)\n\ngoal (1 subgoal):\n 1. \\<not> dist x px + dist py y\n           \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dist x px + dist py y\n           \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "case False"], ["proof (state)\nthis:\n  \\<not> dist x px + dist py y \\<le> dist x y + dist py px\n\ngoal (1 subgoal):\n 1. \\<not> dist x px + dist py y\n           \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "then"], ["proof (chain)\npicking this:\n  \\<not> dist x px + dist py y \\<le> dist x y + dist py px", "have \"dist x px + dist y py + 2 * dist px py \\<le> dist x px + dist py y + 10 * deltaG(TYPE('a)) + 4 * C\""], ["proof (prove)\nusing this:\n  \\<not> dist x px + dist py y \\<le> dist x y + dist py px\n\ngoal (1 subgoal):\n 1. dist x px + dist y py + 2 * dist px py\n    \\<le> dist x px + dist py y + 10 * deltaG TYPE('a) + 4 * C", "using *"], ["proof (prove)\nusing this:\n  \\<not> dist x px + dist py y \\<le> dist x y + dist py px\n  dist x px + dist y py + 2 * dist px py\n  \\<le> max (dist x y + dist py px) (dist x px + dist py y) +\n        10 * deltaG TYPE('a) +\n        4 * C\n\ngoal (1 subgoal):\n 1. dist x px + dist y py + 2 * dist px py\n    \\<le> dist x px + dist py y + 10 * deltaG TYPE('a) + 4 * C", "by auto"], ["proof (state)\nthis:\n  dist x px + dist y py + 2 * dist px py\n  \\<le> dist x px + dist py y + 10 * deltaG TYPE('a) + 4 * C\n\ngoal (1 subgoal):\n 1. \\<not> dist x px + dist py y\n           \\<le> dist x y + dist py px \\<Longrightarrow>\n    dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "then"], ["proof (chain)\npicking this:\n  dist x px + dist y py + 2 * dist px py\n  \\<le> dist x px + dist py y + 10 * deltaG TYPE('a) + 4 * C", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x px + dist y py + 2 * dist px py\n  \\<le> dist x px + dist py y + 10 * deltaG TYPE('a) + 4 * C\n\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist px py\n  \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n         (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist px py\n  \\<le> max (5 * deltaG TYPE('a) + 2 * C)\n         (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * C)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The projection on a quasi-convex set is $1$-Lipschitz up to an additive error.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) proj_along_quasiconvex_contraction':\n  assumes \"quasiconvex C G\" \"px \\<in> proj_set x G\" \"py \\<in> proj_set y G\"\n  shows \"dist px py \\<le> dist x y + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "proof (cases \"dist y py \\<le> dist x px\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C\n 2. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "case True"], ["proof (state)\nthis:\n  dist y py \\<le> dist x px\n\ngoal (2 subgoals):\n 1. dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C\n 2. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "have \"dist x px + dist px py \\<le> dist x py + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x px + dist px py \\<le> dist x py + 4 * deltaG TYPE('a) + 2 * C", "by (rule dist_along_quasiconvex[OF assms(1) assms(2) proj_setD(1)[OF assms(3)]])"], ["proof (state)\nthis:\n  dist x px + dist px py \\<le> dist x py + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (2 subgoals):\n 1. dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C\n 2. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "also"], ["proof (state)\nthis:\n  dist x px + dist px py \\<le> dist x py + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (2 subgoals):\n 1. dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C\n 2. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "have \"... \\<le> (dist x y + dist y py) + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x py + 4 * deltaG TYPE('a) + 2 * C\n    \\<le> dist x y + dist y py + 4 * deltaG TYPE('a) + 2 * C", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist x py + 4 * deltaG TYPE('a) + 2 * C\n  \\<le> dist x y + dist y py + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (2 subgoals):\n 1. dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C\n 2. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "finally"], ["proof (chain)\npicking this:\n  dist x px + dist px py\n  \\<le> dist x y + dist y py + 4 * deltaG TYPE('a) + 2 * C", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x px + dist px py\n  \\<le> dist x y + dist y py + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "using True"], ["proof (prove)\nusing this:\n  dist x px + dist px py\n  \\<le> dist x y + dist y py + 4 * deltaG TYPE('a) + 2 * C\n  dist y py \\<le> dist x px\n\ngoal (1 subgoal):\n 1. dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "by auto"], ["proof (state)\nthis:\n  dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "case False"], ["proof (state)\nthis:\n  \\<not> dist y py \\<le> dist x px\n\ngoal (1 subgoal):\n 1. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "have \"dist y py + dist py px \\<le> dist y px + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y py + dist py px \\<le> dist y px + 4 * deltaG TYPE('a) + 2 * C", "by (rule dist_along_quasiconvex[OF assms(1) assms(3) proj_setD(1)[OF assms(2)]])"], ["proof (state)\nthis:\n  dist y py + dist py px \\<le> dist y px + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "also"], ["proof (state)\nthis:\n  dist y py + dist py px \\<le> dist y px + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "have \"... \\<le> (dist y x + dist x px) + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y px + 4 * deltaG TYPE('a) + 2 * C\n    \\<le> dist y x + dist x px + 4 * deltaG TYPE('a) + 2 * C", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist y px + 4 * deltaG TYPE('a) + 2 * C\n  \\<le> dist y x + dist x px + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. \\<not> dist y py \\<le> dist x px \\<Longrightarrow>\n    dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "finally"], ["proof (chain)\npicking this:\n  dist y py + dist py px\n  \\<le> dist y x + dist x px + 4 * deltaG TYPE('a) + 2 * C", "show ?thesis"], ["proof (prove)\nusing this:\n  dist y py + dist py px\n  \\<le> dist y x + dist x px + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "using False"], ["proof (prove)\nusing this:\n  dist y py + dist py px\n  \\<le> dist y x + dist x px + 4 * deltaG TYPE('a) + 2 * C\n  \\<not> dist y py \\<le> dist x px\n\ngoal (1 subgoal):\n 1. dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can in particular specialize the previous statements to geodesics, which are\n$0$-quasi-convex.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) dist_along_geodesic:\n  assumes \"geodesic_segment G\" \"p \\<in> proj_set x G\" \"y \\<in> G\"\n  shows \"dist x p + dist p y \\<le> dist x y + 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a)", "using dist_along_quasiconvex[OF quasiconvex_of_geodesic[OF assms(1)] assms(2) assms(3)]"], ["proof (prove)\nusing this:\n  dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * 0\n\ngoal (1 subgoal):\n 1. dist x p + dist p y \\<le> dist x y + 4 * deltaG TYPE('a)", "by auto"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) proj_along_geodesic_contraction:\n  assumes \"geodesic_segment G\" \"px \\<in> proj_set x G\" \"py \\<in> proj_set y G\"\n  shows \"dist px py \\<le> max (5 * deltaG(TYPE('a))) (dist x y - dist px x - dist py y + 10 * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a))\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a))", "using proj_along_quasiconvex_contraction[OF quasiconvex_of_geodesic[OF assms(1)] assms(2) assms(3)]"], ["proof (prove)\nusing this:\n  dist px py\n  \\<le> max (5 * deltaG TYPE('a) + 2 * 0)\n         (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a) + 4 * 0)\n\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a))\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a))", "by auto"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) proj_along_geodesic_contraction':\n  assumes \"geodesic_segment G\" \"px \\<in> proj_set x G\" \"py \\<in> proj_set y G\"\n  shows \"dist px py \\<le> dist x y + 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px py \\<le> dist x y + 4 * deltaG TYPE('a)", "using proj_along_quasiconvex_contraction'[OF quasiconvex_of_geodesic[OF assms(1)] assms(2) assms(3)]"], ["proof (prove)\nusing this:\n  dist px py \\<le> dist x y + 4 * deltaG TYPE('a) + 2 * 0\n\ngoal (1 subgoal):\n 1. dist px py \\<le> dist x y + 4 * deltaG TYPE('a)", "by auto"], ["", "text \\<open>If one projects a continuous curve on a quasi-convex set, the image does not have to be\nconnected (the projection is discontinuous), but since the projections of nearby points are within\nuniformly bounded distance one can find in the projection a point with almost prescribed distance\nto the starting point, say. For further applications, we also pick the first such point, i.e.,\nall the previous points are also close to the starting point.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) quasi_convex_projection_small_gaps:\n  assumes \"continuous_on {a..(b::real)} f\"\n          \"a \\<le> b\"\n          \"quasiconvex C G\"\n          \"\\<And>t. t \\<in> {a..b} \\<Longrightarrow> p t \\<in> proj_set (f t) G\"\n          \"delta > deltaG(TYPE('a))\"\n          \"d \\<in> {4 * delta + 2 * C..dist (p a) (p b)}\"\n  shows \"\\<exists>t \\<in> {a..b}. (dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C .. d})\n                    \\<and> (\\<forall>s \\<in> {a..t}. dist (p a) (p s) \\<le> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"delta > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < delta", "using assms(5) local.delta_nonneg"], ["proof (prove)\nusing this:\n  deltaG TYPE('a) < delta\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. 0 < delta", "by linarith"], ["proof (state)\nthis:\n  0 < delta\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "moreover"], ["proof (state)\nthis:\n  0 < delta\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"C \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C", "using quasiconvexC[OF assms(3)]"], ["proof (prove)\nusing this:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> C", "by simp"], ["proof (state)\nthis:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "ultimately"], ["proof (chain)\npicking this:\n  0 < delta\n  0 \\<le> C", "have \"d \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 < delta\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> d", "using assms"], ["proof (prove)\nusing this:\n  0 < delta\n  0 \\<le> C\n  continuous_on {a..b} f\n  a \\<le> b\n  quasiconvex C G\n  ?t \\<in> {a..b} \\<Longrightarrow> p ?t \\<in> proj_set (f ?t) G\n  deltaG TYPE('a) < delta\n  d \\<in> {4 * delta + 2 * C..dist (p a) (p b)}\n\ngoal (1 subgoal):\n 1. 0 \\<le> d", "by auto"], ["proof (state)\nthis:\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "text \\<open>The idea is to define the desired point as the last point $u$ for which there is a projection\n  at distance at most $d$ of the starting point. Then the projection can not be much closer to\n  the starting point, or one could point another such point further away by almost continuity, giving\n  a contradiction. The technical implementation requires some care, as the \"last point\" may not\n  satisfy the property, for lack of continuity. If it does, then fine. Otherwise, one should go just\n  a little bit to its left to find the desired point.\\<close>"], ["proof (state)\nthis:\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "define I where \"I = {t \\<in> {a..b}. \\<forall>s \\<in> {a..t}. dist (p a) (p s) \\<le> d}\""], ["proof (state)\nthis:\n  I = {t \\<in> {a..b}. \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d}\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"a \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> I", "using \\<open>a \\<le> b\\<close> \\<open>d \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> b\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. a \\<in> I", "unfolding I_def"], ["proof (prove)\nusing this:\n  a \\<le> b\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. a \\<in> {t \\<in> {a..b}.\n             \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d}", "by auto"], ["proof (state)\nthis:\n  a \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"bdd_above I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above I", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above\n     {t \\<in> {a..b}. \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d}", "by auto"], ["proof (state)\nthis:\n  bdd_above I\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "define u where \"u = Sup I\""], ["proof (state)\nthis:\n  u = Sup I\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"a \\<le> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> u", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> Sup I", "apply (rule cSup_upper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<in> I\n 2. bdd_above I", "using \\<open>a \\<in> I\\<close> \\<open>bdd_above I\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> I\n  bdd_above I\n\ngoal (2 subgoals):\n 1. a \\<in> I\n 2. bdd_above I", "by auto"], ["proof (state)\nthis:\n  a \\<le> u\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"u \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<le> b", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup I \\<le> b", "apply (rule cSup_least)"], ["proof (prove)\ngoal (2 subgoals):\n 1. I \\<noteq> {}\n 2. \\<And>x. x \\<in> I \\<Longrightarrow> x \\<le> b", "using \\<open>a \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> I\n\ngoal (2 subgoals):\n 1. I \\<noteq> {}\n 2. \\<And>x. x \\<in> I \\<Longrightarrow> x \\<le> b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> I; a \\<in> I\\<rbrakk> \\<Longrightarrow> x \\<le> b", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> {t \\<in> {a..b}.\n                         \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d};\n        a \\<in> {t \\<in> {a..b}.\n                 \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d}\\<rbrakk>\n       \\<Longrightarrow> x \\<le> b", "by auto"], ["proof (state)\nthis:\n  u \\<le> b\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have A: \"dist (p a) (p s) \\<le> d\" if \"s < u\" \"a \\<le> s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "have \"\\<exists>t\\<in>I. s < t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>I. s < t", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>I. s < t", "apply (subst less_cSup_iff[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. I \\<noteq> {}\n 2. bdd_above I\n 3. s < Sup I", "using \\<open>a \\<in> I\\<close> \\<open>bdd_above I\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> I\n  bdd_above I\n\ngoal (3 subgoals):\n 1. I \\<noteq> {}\n 2. bdd_above I\n 3. s < Sup I", "using \\<open>s < u\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> I\n  bdd_above I\n  s < u\n\ngoal (3 subgoals):\n 1. I \\<noteq> {}\n 2. bdd_above I\n 3. s < Sup I", "unfolding u_def"], ["proof (prove)\nusing this:\n  a \\<in> I\n  bdd_above I\n  s < Sup I\n\ngoal (3 subgoals):\n 1. I \\<noteq> {}\n 2. bdd_above I\n 3. s < Sup I", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>I. s < t\n\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "then"], ["proof (chain)\npicking this:\n  \\<exists>t\\<in>I. s < t", "obtain t where t: \"t \\<in> I\" \"s < t\""], ["proof (prove)\nusing this:\n  \\<exists>t\\<in>I. s < t\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> I; s < t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> I\n  s < t\n\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "then"], ["proof (chain)\npicking this:\n  t \\<in> I\n  s < t", "have \"s \\<in> {a..t}\""], ["proof (prove)\nusing this:\n  t \\<in> I\n  s < t\n\ngoal (1 subgoal):\n 1. s \\<in> {a..t}", "using \\<open>a \\<le> s\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> I\n  s < t\n  a \\<le> s\n\ngoal (1 subgoal):\n 1. s \\<in> {a..t}", "by auto"], ["proof (state)\nthis:\n  s \\<in> {a..t}\n\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "then"], ["proof (chain)\npicking this:\n  s \\<in> {a..t}", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> {a..t}\n\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "using t(1)"], ["proof (prove)\nusing this:\n  s \\<in> {a..t}\n  t \\<in> I\n\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "unfolding I_def"], ["proof (prove)\nusing this:\n  s \\<in> {a..t}\n  t \\<in> {t \\<in> {a..b}. \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d}\n\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "by auto"], ["proof (state)\nthis:\n  dist (p a) (p s) \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?s < u; a \\<le> ?s\\<rbrakk>\n  \\<Longrightarrow> dist (p a) (p ?s) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"continuous (at u within {a..b}) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at u within {a..b}) f", "using assms(1)"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n\ngoal (1 subgoal):\n 1. continuous (at u within {a..b}) f", "by (simp add: \\<open>a \\<le> u\\<close> \\<open>u \\<le> b\\<close> continuous_on_eq_continuous_within)"], ["proof (state)\nthis:\n  continuous (at u within {a..b}) f\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "then"], ["proof (chain)\npicking this:\n  continuous (at u within {a..b}) f", "have \"\\<exists>i > 0. \\<forall>s\\<in>{a..b}. dist u s < i \\<longrightarrow> dist (f u) (f s) < (delta - deltaG(TYPE('a)))\""], ["proof (prove)\nusing this:\n  continuous (at u within {a..b}) f\n\ngoal (1 subgoal):\n 1. \\<exists>i>0.\n       \\<forall>s\\<in>{a..b}.\n          dist u s < i \\<longrightarrow>\n          dist (f u) (f s) < delta - deltaG TYPE('a)", "unfolding continuous_within_eps_delta"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>d>0.\n        \\<forall>x'\\<in>{a..b}.\n           dist x' u < d \\<longrightarrow> dist (f x') (f u) < e\n\ngoal (1 subgoal):\n 1. \\<exists>i>0.\n       \\<forall>s\\<in>{a..b}.\n          dist u s < i \\<longrightarrow>\n          dist (f u) (f s) < delta - deltaG TYPE('a)", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>e>0.\n     \\<exists>d>0.\n        \\<forall>x'\\<in>{a..b}.\n           dist x' u < d \\<longrightarrow> dist (f x') (f u) < e\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. \\<exists>i>0.\n       \\<forall>s\\<in>{a..b}.\n          dist u s < i \\<longrightarrow>\n          dist (f u) (f s) < delta - deltaG TYPE('a)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  \\<exists>i>0.\n     \\<forall>s\\<in>{a..b}.\n        dist u s < i \\<longrightarrow>\n        dist (f u) (f s) < delta - deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "then"], ["proof (chain)\npicking this:\n  \\<exists>i>0.\n     \\<forall>s\\<in>{a..b}.\n        dist u s < i \\<longrightarrow>\n        dist (f u) (f s) < delta - deltaG TYPE('a)", "obtain e0 where e0: \"e0 > 0\" \"\\<And>s. s \\<in> {a..b} \\<Longrightarrow> dist u s < e0 \\<Longrightarrow> dist (f u) (f s) < (delta - deltaG(TYPE('a)))\""], ["proof (prove)\nusing this:\n  \\<exists>i>0.\n     \\<forall>s\\<in>{a..b}.\n        dist u s < i \\<longrightarrow>\n        dist (f u) (f s) < delta - deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. (\\<And>e0.\n        \\<lbrakk>0 < e0;\n         \\<And>s.\n            \\<lbrakk>s \\<in> {a..b}; dist u s < e0\\<rbrakk>\n            \\<Longrightarrow> dist (f u) (f s)\n                              < delta - deltaG TYPE('a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < e0\n  \\<lbrakk>?s \\<in> {a..b}; dist u ?s < e0\\<rbrakk>\n  \\<Longrightarrow> dist (f u) (f ?s) < delta - deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "proof (cases \"dist (p a) (p u) > d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "text \\<open>First, consider the case where $u$ does not satisfy the defining property. Then the\n    desired point $t$ is taken slightly to its left.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "case True"], ["proof (state)\nthis:\n  d < dist (p a) (p u)\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "then"], ["proof (chain)\npicking this:\n  d < dist (p a) (p u)", "have \"u \\<noteq> a\""], ["proof (prove)\nusing this:\n  d < dist (p a) (p u)\n\ngoal (1 subgoal):\n 1. u \\<noteq> a", "using \\<open>d \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  d < dist (p a) (p u)\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. u \\<noteq> a", "by auto"], ["proof (state)\nthis:\n  u \\<noteq> a\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "then"], ["proof (chain)\npicking this:\n  u \\<noteq> a", "have \"a < u\""], ["proof (prove)\nusing this:\n  u \\<noteq> a\n\ngoal (1 subgoal):\n 1. a < u", "using \\<open>a \\<le> u\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> a\n  a \\<le> u\n\ngoal (1 subgoal):\n 1. a < u", "by auto"], ["proof (state)\nthis:\n  a < u\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "define e::real where \"e = min (e0/2) ((u-a)/2)\""], ["proof (state)\nthis:\n  e = min (e0 / 2) ((u - a) / 2)\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "then"], ["proof (chain)\npicking this:\n  e = min (e0 / 2) ((u - a) / 2)", "have \"e > 0\""], ["proof (prove)\nusing this:\n  e = min (e0 / 2) ((u - a) / 2)\n\ngoal (1 subgoal):\n 1. 0 < e", "using \\<open>a < u\\<close> \\<open>e0 > 0\\<close>"], ["proof (prove)\nusing this:\n  e = min (e0 / 2) ((u - a) / 2)\n  a < u\n  0 < e0\n\ngoal (1 subgoal):\n 1. 0 < e", "by auto"], ["proof (state)\nthis:\n  0 < e\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "define t where \"t = u - e\""], ["proof (state)\nthis:\n  t = u - e\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "then"], ["proof (chain)\npicking this:\n  t = u - e", "have \"t < u\""], ["proof (prove)\nusing this:\n  t = u - e\n\ngoal (1 subgoal):\n 1. t < u", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  t = u - e\n  0 < e\n\ngoal (1 subgoal):\n 1. t < u", "by auto"], ["proof (state)\nthis:\n  t < u\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"u - b \\<le> e\" \"e \\<le> u - a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u - b \\<le> e &&& e \\<le> u - a", "using \\<open>e > 0\\<close> \\<open>u \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  u \\<le> b\n\ngoal (1 subgoal):\n 1. u - b \\<le> e &&& e \\<le> u - a", "unfolding e_def"], ["proof (prove)\nusing this:\n  0 < min (e0 / 2) ((u - a) / 2)\n  u \\<le> b\n\ngoal (1 subgoal):\n 1. u - b \\<le> min (e0 / 2) ((u - a) / 2) &&&\n    min (e0 / 2) ((u - a) / 2) \\<le> u - a", "by (auto simp add: min_def)"], ["proof (state)\nthis:\n  u - b \\<le> e\n  e \\<le> u - a\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "then"], ["proof (chain)\npicking this:\n  u - b \\<le> e\n  e \\<le> u - a", "have \"t \\<in> {a..b}\" \"t \\<in> {a..t}\""], ["proof (prove)\nusing this:\n  u - b \\<le> e\n  e \\<le> u - a\n\ngoal (1 subgoal):\n 1. t \\<in> {a..b} &&& t \\<in> {a..t}", "unfolding t_def"], ["proof (prove)\nusing this:\n  u - b \\<le> e\n  e \\<le> u - a\n\ngoal (1 subgoal):\n 1. u - e \\<in> {a..b} &&& u - e \\<in> {a..u - e}", "by auto"], ["proof (state)\nthis:\n  t \\<in> {a..b}\n  t \\<in> {a..t}\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"dist u t < e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist u t < e0", "unfolding t_def e_def dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>u - (u - min (e0 / 2) ((u - a) / 2))\\<bar> < e0", "using \\<open>e0 > 0\\<close> \\<open>a \\<le> u\\<close>"], ["proof (prove)\nusing this:\n  0 < e0\n  a \\<le> u\n\ngoal (1 subgoal):\n 1. \\<bar>u - (u - min (e0 / 2) ((u - a) / 2))\\<bar> < e0", "by auto"], ["proof (state)\nthis:\n  dist u t < e0\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have *: \"\\<forall>s \\<in> {a..t}. dist (p a) (p s) \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d", "using A \\<open>t < u\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s < u; a \\<le> ?s\\<rbrakk>\n  \\<Longrightarrow> dist (p a) (p ?s) \\<le> d\n  t < u\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d", "by auto"], ["proof (state)\nthis:\n  \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"dist (p t) (p u) \\<le> dist (f t) (f u) + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p t) (p u) \\<le> dist (f t) (f u) + 4 * deltaG TYPE('a) + 2 * C", "apply (rule proj_along_quasiconvex_contraction'[OF \\<open>quasiconvex C G\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p t \\<in> proj_set (f t) G\n 2. p u \\<in> proj_set (f u) G", "using assms (4) \\<open>t \\<in> {a..b}\\<close> \\<open>a \\<le> u\\<close> \\<open>u \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  ?t \\<in> {a..b} \\<Longrightarrow> p ?t \\<in> proj_set (f ?t) G\n  t \\<in> {a..b}\n  a \\<le> u\n  u \\<le> b\n\ngoal (2 subgoals):\n 1. p t \\<in> proj_set (f t) G\n 2. p u \\<in> proj_set (f u) G", "by auto"], ["proof (state)\nthis:\n  dist (p t) (p u) \\<le> dist (f t) (f u) + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "also"], ["proof (state)\nthis:\n  dist (p t) (p u) \\<le> dist (f t) (f u) + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"... \\<le> (delta - deltaG(TYPE('a))) + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f t) (f u) + 4 * deltaG TYPE('a) + 2 * C\n    \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f t) (f u) \\<le> delta - deltaG TYPE('a)", "using e0(2)[OF \\<open>t \\<in> {a..b}\\<close> \\<open>dist u t < e0\\<close>]"], ["proof (prove)\nusing this:\n  dist (f u) (f t) < delta - deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (f t) (f u) \\<le> delta - deltaG TYPE('a)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (f t) (f u) + 4 * deltaG TYPE('a) + 2 * C\n  \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "finally"], ["proof (chain)\npicking this:\n  dist (p t) (p u)\n  \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C", "have I: \"dist (p t) (p u) \\<le> 4 * delta + 2 * C\""], ["proof (prove)\nusing this:\n  dist (p t) (p u)\n  \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. dist (p t) (p u) \\<le> 4 * delta + 2 * C", "using \\<open>delta > deltaG(TYPE('a))\\<close>"], ["proof (prove)\nusing this:\n  dist (p t) (p u)\n  \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. dist (p t) (p u) \\<le> 4 * delta + 2 * C", "by simp"], ["proof (state)\nthis:\n  dist (p t) (p u) \\<le> 4 * delta + 2 * C\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"d \\<le> dist (p a) (p u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> dist (p a) (p u)", "using True"], ["proof (prove)\nusing this:\n  d < dist (p a) (p u)\n\ngoal (1 subgoal):\n 1. d \\<le> dist (p a) (p u)", "by auto"], ["proof (state)\nthis:\n  d \\<le> dist (p a) (p u)\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "also"], ["proof (state)\nthis:\n  d \\<le> dist (p a) (p u)\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"... \\<le> dist (p a) (p t) + dist (p t) (p u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p u) \\<le> dist (p a) (p t) + dist (p t) (p u)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (p a) (p u) \\<le> dist (p a) (p t) + dist (p t) (p u)\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "also"], ["proof (state)\nthis:\n  dist (p a) (p u) \\<le> dist (p a) (p t) + dist (p t) (p u)\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have \"... \\<le> dist (p a) (p t) + 4 * delta + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p t) + dist (p t) (p u)\n    \\<le> dist (p a) (p t) + 4 * delta + 2 * C", "using I"], ["proof (prove)\nusing this:\n  dist (p t) (p u) \\<le> 4 * delta + 2 * C\n\ngoal (1 subgoal):\n 1. dist (p a) (p t) + dist (p t) (p u)\n    \\<le> dist (p a) (p t) + 4 * delta + 2 * C", "by simp"], ["proof (state)\nthis:\n  dist (p a) (p t) + dist (p t) (p u)\n  \\<le> dist (p a) (p t) + 4 * delta + 2 * C\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "finally"], ["proof (chain)\npicking this:\n  d \\<le> dist (p a) (p t) + 4 * delta + 2 * C", "have **: \"d - 4 * delta - 2 * C \\<le> dist (p a) (p t)\""], ["proof (prove)\nusing this:\n  d \\<le> dist (p a) (p t) + 4 * delta + 2 * C\n\ngoal (1 subgoal):\n 1. d - 4 * delta - 2 * C \\<le> dist (p a) (p t)", "by simp"], ["proof (state)\nthis:\n  d - 4 * delta - 2 * C \\<le> dist (p a) (p t)\n\ngoal (2 subgoals):\n 1. d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n 2. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "apply (rule bexI[OF _ \\<open>t \\<in> {a..b}\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n    (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "using * ** \\<open>t \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d\n  d - 4 * delta - 2 * C \\<le> dist (p a) (p t)\n  t \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n    (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{a..b}.\n     dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n     (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n\ngoal (1 subgoal):\n 1. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "text \\<open>Next, consider the case where $u$ satisfies the defining property. Then we will take $t = u$.\n    The only nontrivial point to check is that the distance of $f(u)$ to the starting point is not\n    too small. For this, we need to separate the case where $u = b$ (in which case one argues directly)\n    and the case where $u < b$, where one can use a point slightly to the right of $u$ which has a\n    projection at distance $ > d$ of the starting point, and use almost continuity.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "case False"], ["proof (state)\nthis:\n  \\<not> d < dist (p a) (p u)\n\ngoal (1 subgoal):\n 1. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have B: \"dist (p a) (p s) \\<le> d\" if \"s \\<in> {a..u}\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "proof (cases \"s = u\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = u \\<Longrightarrow> dist (p a) (p s) \\<le> d\n 2. s \\<noteq> u \\<Longrightarrow> dist (p a) (p s) \\<le> d", "case True"], ["proof (state)\nthis:\n  s = u\n\ngoal (2 subgoals):\n 1. s = u \\<Longrightarrow> dist (p a) (p s) \\<le> d\n 2. s \\<noteq> u \\<Longrightarrow> dist (p a) (p s) \\<le> d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p u) \\<le> d", "using False"], ["proof (prove)\nusing this:\n  \\<not> d < dist (p a) (p u)\n\ngoal (1 subgoal):\n 1. dist (p a) (p u) \\<le> d", "by auto"], ["proof (state)\nthis:\n  dist (p a) (p s) \\<le> d\n\ngoal (1 subgoal):\n 1. s \\<noteq> u \\<Longrightarrow> dist (p a) (p s) \\<le> d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> u \\<Longrightarrow> dist (p a) (p s) \\<le> d", "case False"], ["proof (state)\nthis:\n  s \\<noteq> u\n\ngoal (1 subgoal):\n 1. s \\<noteq> u \\<Longrightarrow> dist (p a) (p s) \\<le> d", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> u", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<noteq> u\n\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "using that A"], ["proof (prove)\nusing this:\n  s \\<noteq> u\n  s \\<in> {a..u}\n  \\<lbrakk>?s < u; a \\<le> ?s\\<rbrakk>\n  \\<Longrightarrow> dist (p a) (p ?s) \\<le> d\n\ngoal (1 subgoal):\n 1. dist (p a) (p s) \\<le> d", "by auto"], ["proof (state)\nthis:\n  dist (p a) (p s) \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?s \\<in> {a..u} \\<Longrightarrow> dist (p a) (p ?s) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "have C: \"dist (p a) (p u) \\<ge> d - 4 *delta - 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "proof (cases \"u = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = b \\<Longrightarrow> d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n 2. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "case True"], ["proof (state)\nthis:\n  u = b\n\ngoal (2 subgoals):\n 1. u = b \\<Longrightarrow> d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n 2. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"d \\<le> dist (p a) (p b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> dist (p a) (p b)", "using assms"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n  a \\<le> b\n  quasiconvex C G\n  ?t \\<in> {a..b} \\<Longrightarrow> p ?t \\<in> proj_set (f ?t) G\n  deltaG TYPE('a) < delta\n  d \\<in> {4 * delta + 2 * C..dist (p a) (p b)}\n\ngoal (1 subgoal):\n 1. d \\<le> dist (p a) (p b)", "by auto"], ["proof (state)\nthis:\n  d \\<le> dist (p a) (p b)\n\ngoal (2 subgoals):\n 1. u = b \\<Longrightarrow> d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n 2. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "also"], ["proof (state)\nthis:\n  d \\<le> dist (p a) (p b)\n\ngoal (2 subgoals):\n 1. u = b \\<Longrightarrow> d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n 2. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"... \\<le> dist (p a) (p u) + dist (p u) (p b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p b) \\<le> dist (p a) (p u) + dist (p u) (p b)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (p a) (p b) \\<le> dist (p a) (p u) + dist (p u) (p b)\n\ngoal (2 subgoals):\n 1. u = b \\<Longrightarrow> d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n 2. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "also"], ["proof (state)\nthis:\n  dist (p a) (p b) \\<le> dist (p a) (p u) + dist (p u) (p b)\n\ngoal (2 subgoals):\n 1. u = b \\<Longrightarrow> d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n 2. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"... \\<le> dist (p a) (p u) + (dist (f u) (f b) + 4 * deltaG TYPE('a) + 2 * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p u) + dist (p u) (p b)\n    \\<le> dist (p a) (p u) +\n          (dist (f u) (f b) + 4 * deltaG TYPE('a) + 2 * C)", "apply (intro mono_intros proj_along_quasiconvex_contraction'[OF \\<open>quasiconvex C G\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p u \\<in> proj_set (f u) G\n 2. p b \\<in> proj_set (f b) G", "using assms \\<open>a \\<le> u\\<close> \\<open>u \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n  a \\<le> b\n  quasiconvex C G\n  ?t \\<in> {a..b} \\<Longrightarrow> p ?t \\<in> proj_set (f ?t) G\n  deltaG TYPE('a) < delta\n  d \\<in> {4 * delta + 2 * C..dist (p a) (p b)}\n  a \\<le> u\n  u \\<le> b\n\ngoal (2 subgoals):\n 1. p u \\<in> proj_set (f u) G\n 2. p b \\<in> proj_set (f b) G", "by auto"], ["proof (state)\nthis:\n  dist (p a) (p u) + dist (p u) (p b)\n  \\<le> dist (p a) (p u) + (dist (f u) (f b) + 4 * deltaG TYPE('a) + 2 * C)\n\ngoal (2 subgoals):\n 1. u = b \\<Longrightarrow> d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n 2. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "finally"], ["proof (chain)\npicking this:\n  d \\<le> dist (p a) (p u) +\n          (dist (f u) (f b) + 4 * deltaG TYPE('a) + 2 * C)", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<le> dist (p a) (p u) +\n          (dist (f u) (f b) + 4 * deltaG TYPE('a) + 2 * C)\n\ngoal (1 subgoal):\n 1. d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "unfolding True"], ["proof (prove)\nusing this:\n  d \\<le> dist (p a) (p b) +\n          (dist (f b) (f b) + 4 * deltaG TYPE('a) + 2 * C)\n\ngoal (1 subgoal):\n 1. d - 4 * delta - 2 * C \\<le> dist (p a) (p b)", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  d \\<le> dist (p a) (p b) +\n          (dist (f b) (f b) + 4 * deltaG TYPE('a) + 2 * C)\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. d - 4 * delta - 2 * C \\<le> dist (p a) (p b)", "by auto"], ["proof (state)\nthis:\n  d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "case False"], ["proof (state)\nthis:\n  u \\<noteq> b\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "then"], ["proof (chain)\npicking this:\n  u \\<noteq> b", "have \"u < b\""], ["proof (prove)\nusing this:\n  u \\<noteq> b\n\ngoal (1 subgoal):\n 1. u < b", "using \\<open>u \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  u \\<noteq> b\n  u \\<le> b\n\ngoal (1 subgoal):\n 1. u < b", "by auto"], ["proof (state)\nthis:\n  u < b\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "define e::real where \"e = min (e0/2) ((b-u)/2)\""], ["proof (state)\nthis:\n  e = min (e0 / 2) ((b - u) / 2)\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "then"], ["proof (chain)\npicking this:\n  e = min (e0 / 2) ((b - u) / 2)", "have \"e > 0\""], ["proof (prove)\nusing this:\n  e = min (e0 / 2) ((b - u) / 2)\n\ngoal (1 subgoal):\n 1. 0 < e", "using \\<open>u < b\\<close> \\<open>e0 > 0\\<close>"], ["proof (prove)\nusing this:\n  e = min (e0 / 2) ((b - u) / 2)\n  u < b\n  0 < e0\n\ngoal (1 subgoal):\n 1. 0 < e", "by auto"], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "define v where \"v = u + e\""], ["proof (state)\nthis:\n  v = u + e\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "then"], ["proof (chain)\npicking this:\n  v = u + e", "have \"u < v\""], ["proof (prove)\nusing this:\n  v = u + e\n\ngoal (1 subgoal):\n 1. u < v", "using \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  v = u + e\n  0 < e\n\ngoal (1 subgoal):\n 1. u < v", "by auto"], ["proof (state)\nthis:\n  u < v\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"e \\<le> b - u\" \"a - u \\<le> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<le> b - u &&& a - u \\<le> e", "using \\<open>e > 0\\<close> \\<open>a \\<le> u\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  a \\<le> u\n\ngoal (1 subgoal):\n 1. e \\<le> b - u &&& a - u \\<le> e", "unfolding e_def"], ["proof (prove)\nusing this:\n  0 < min (e0 / 2) ((b - u) / 2)\n  a \\<le> u\n\ngoal (1 subgoal):\n 1. min (e0 / 2) ((b - u) / 2) \\<le> b - u &&&\n    a - u \\<le> min (e0 / 2) ((b - u) / 2)", "by (auto simp add: min_def)"], ["proof (state)\nthis:\n  e \\<le> b - u\n  a - u \\<le> e\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "then"], ["proof (chain)\npicking this:\n  e \\<le> b - u\n  a - u \\<le> e", "have \"v \\<in> {a..b}\""], ["proof (prove)\nusing this:\n  e \\<le> b - u\n  a - u \\<le> e\n\ngoal (1 subgoal):\n 1. v \\<in> {a..b}", "unfolding v_def"], ["proof (prove)\nusing this:\n  e \\<le> b - u\n  a - u \\<le> e\n\ngoal (1 subgoal):\n 1. u + e \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  v \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "moreover"], ["proof (state)\nthis:\n  v \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"v \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> I", "using \\<open>u < v\\<close> \\<open>bdd_above I\\<close> cSup_upper not_le"], ["proof (prove)\nusing this:\n  u < v\n  bdd_above I\n  \\<lbrakk>?x \\<in> ?X; bdd_above ?X\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Sup ?X\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. v \\<notin> I", "unfolding u_def"], ["proof (prove)\nusing this:\n  Sup I < v\n  bdd_above I\n  \\<lbrakk>?x \\<in> ?X; bdd_above ?X\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Sup ?X\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. v \\<notin> I", "by auto"], ["proof (state)\nthis:\n  v \\<notin> I\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> {a..b}\n  v \\<notin> I", "have \"\\<exists>w \\<in> {a..v}. dist (p a) (p w) > d\""], ["proof (prove)\nusing this:\n  v \\<in> {a..b}\n  v \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>{a..v}. d < dist (p a) (p w)", "unfolding I_def"], ["proof (prove)\nusing this:\n  v \\<in> {a..b}\n  v \\<notin> {t \\<in> {a..b}.\n              \\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d}\n\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>{a..v}. d < dist (p a) (p w)", "by force"], ["proof (state)\nthis:\n  \\<exists>w\\<in>{a..v}. d < dist (p a) (p w)\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>{a..v}. d < dist (p a) (p w)", "obtain w where w: \"w \\<in> {a..v}\" \"dist (p a) (p w) > d\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>{a..v}. d < dist (p a) (p w)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> {a..v}; d < dist (p a) (p w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> {a..v}\n  d < dist (p a) (p w)\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "then"], ["proof (chain)\npicking this:\n  w \\<in> {a..v}\n  d < dist (p a) (p w)", "have \"w \\<notin> {a..u}\""], ["proof (prove)\nusing this:\n  w \\<in> {a..v}\n  d < dist (p a) (p w)\n\ngoal (1 subgoal):\n 1. w \\<notin> {a..u}", "using B"], ["proof (prove)\nusing this:\n  w \\<in> {a..v}\n  d < dist (p a) (p w)\n  ?s \\<in> {a..u} \\<Longrightarrow> dist (p a) (p ?s) \\<le> d\n\ngoal (1 subgoal):\n 1. w \\<notin> {a..u}", "by force"], ["proof (state)\nthis:\n  w \\<notin> {a..u}\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "then"], ["proof (chain)\npicking this:\n  w \\<notin> {a..u}", "have \"u < w\""], ["proof (prove)\nusing this:\n  w \\<notin> {a..u}\n\ngoal (1 subgoal):\n 1. u < w", "using w(1)"], ["proof (prove)\nusing this:\n  w \\<notin> {a..u}\n  w \\<in> {a..v}\n\ngoal (1 subgoal):\n 1. u < w", "by auto"], ["proof (state)\nthis:\n  u < w\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"w \\<in> {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> {a..b}", "using w(1) \\<open>v \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  w \\<in> {a..v}\n  v \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. w \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  w \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"dist u w = w - u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist u w = w - u", "unfolding dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>u - w\\<bar> = w - u", "using \\<open>u < w\\<close>"], ["proof (prove)\nusing this:\n  u < w\n\ngoal (1 subgoal):\n 1. \\<bar>u - w\\<bar> = w - u", "by auto"], ["proof (state)\nthis:\n  dist u w = w - u\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "also"], ["proof (state)\nthis:\n  dist u w = w - u\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"... \\<le> v - u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w - u \\<le> v - u", "using w(1)"], ["proof (prove)\nusing this:\n  w \\<in> {a..v}\n\ngoal (1 subgoal):\n 1. w - u \\<le> v - u", "by auto"], ["proof (state)\nthis:\n  w - u \\<le> v - u\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "also"], ["proof (state)\nthis:\n  w - u \\<le> v - u\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"... < e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - u < e0", "unfolding v_def e_def min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u + (if e0 / 2 \\<le> (b - u) / 2 then e0 / 2 else (b - u) / 2) - u < e0", "using \\<open>e0 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < e0\n\ngoal (1 subgoal):\n 1. u + (if e0 / 2 \\<le> (b - u) / 2 then e0 / 2 else (b - u) / 2) - u < e0", "by auto"], ["proof (state)\nthis:\n  v - u < e0\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "finally"], ["proof (chain)\npicking this:\n  dist u w < e0", "have \"dist u w < e0\""], ["proof (prove)\nusing this:\n  dist u w < e0\n\ngoal (1 subgoal):\n 1. dist u w < e0", "by simp"], ["proof (state)\nthis:\n  dist u w < e0\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"dist (p u) (p w) \\<le> dist (f u) (f w) + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p u) (p w) \\<le> dist (f u) (f w) + 4 * deltaG TYPE('a) + 2 * C", "apply (rule proj_along_quasiconvex_contraction'[OF \\<open>quasiconvex C G\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p u \\<in> proj_set (f u) G\n 2. p w \\<in> proj_set (f w) G", "using assms \\<open>a \\<le> u\\<close> \\<open>u \\<le> b\\<close> \\<open>w \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n  a \\<le> b\n  quasiconvex C G\n  ?t \\<in> {a..b} \\<Longrightarrow> p ?t \\<in> proj_set (f ?t) G\n  deltaG TYPE('a) < delta\n  d \\<in> {4 * delta + 2 * C..dist (p a) (p b)}\n  a \\<le> u\n  u \\<le> b\n  w \\<in> {a..b}\n\ngoal (2 subgoals):\n 1. p u \\<in> proj_set (f u) G\n 2. p w \\<in> proj_set (f w) G", "by auto"], ["proof (state)\nthis:\n  dist (p u) (p w) \\<le> dist (f u) (f w) + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "also"], ["proof (state)\nthis:\n  dist (p u) (p w) \\<le> dist (f u) (f w) + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"... \\<le> (delta - deltaG(TYPE('a))) + 4 * deltaG(TYPE('a)) + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f u) (f w) + 4 * deltaG TYPE('a) + 2 * C\n    \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f u) (f w) \\<le> delta - deltaG TYPE('a)", "using e0(2)[OF \\<open>w \\<in> {a..b}\\<close> \\<open>dist u w < e0\\<close>]"], ["proof (prove)\nusing this:\n  dist (f u) (f w) < delta - deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (f u) (f w) \\<le> delta - deltaG TYPE('a)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (f u) (f w) + 4 * deltaG TYPE('a) + 2 * C\n  \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "finally"], ["proof (chain)\npicking this:\n  dist (p u) (p w)\n  \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C", "have I: \"dist (p u) (p w) \\<le> 4 * delta + 2 * C\""], ["proof (prove)\nusing this:\n  dist (p u) (p w)\n  \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C\n\ngoal (1 subgoal):\n 1. dist (p u) (p w) \\<le> 4 * delta + 2 * C", "using \\<open>delta > deltaG(TYPE('a))\\<close>"], ["proof (prove)\nusing this:\n  dist (p u) (p w)\n  \\<le> delta - deltaG TYPE('a) + 4 * deltaG TYPE('a) + 2 * C\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. dist (p u) (p w) \\<le> 4 * delta + 2 * C", "by simp"], ["proof (state)\nthis:\n  dist (p u) (p w) \\<le> 4 * delta + 2 * C\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"d \\<le> dist (p a) (p u) + dist (p u) (p w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<le> dist (p a) (p u) + dist (p u) (p w)", "using w(2) metric_space_class.dist_triangle[of \"p a\" \"p w\" \"p u\"]"], ["proof (prove)\nusing this:\n  d < dist (p a) (p w)\n  dist (p a) (p w) \\<le> dist (p a) (p u) + dist (p u) (p w)\n\ngoal (1 subgoal):\n 1. d \\<le> dist (p a) (p u) + dist (p u) (p w)", "by auto"], ["proof (state)\nthis:\n  d \\<le> dist (p a) (p u) + dist (p u) (p w)\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "also"], ["proof (state)\nthis:\n  d \\<le> dist (p a) (p u) + dist (p u) (p w)\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "have \"... \\<le> dist (p a) (p u) + 4 * delta + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p a) (p u) + dist (p u) (p w)\n    \\<le> dist (p a) (p u) + 4 * delta + 2 * C", "using I"], ["proof (prove)\nusing this:\n  dist (p u) (p w) \\<le> 4 * delta + 2 * C\n\ngoal (1 subgoal):\n 1. dist (p a) (p u) + dist (p u) (p w)\n    \\<le> dist (p a) (p u) + 4 * delta + 2 * C", "by auto"], ["proof (state)\nthis:\n  dist (p a) (p u) + dist (p u) (p w)\n  \\<le> dist (p a) (p u) + 4 * delta + 2 * C\n\ngoal (1 subgoal):\n 1. u \\<noteq> b \\<Longrightarrow>\n    d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "finally"], ["proof (chain)\npicking this:\n  d \\<le> dist (p a) (p u) + 4 * delta + 2 * C", "show ?thesis"], ["proof (prove)\nusing this:\n  d \\<le> dist (p a) (p u) + 4 * delta + 2 * C\n\ngoal (1 subgoal):\n 1. d - 4 * delta - 2 * C \\<le> dist (p a) (p u)", "by simp"], ["proof (state)\nthis:\n  d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n\ngoal (1 subgoal):\n 1. \\<not> d < dist (p a) (p u) \\<Longrightarrow>\n    \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)", "apply (rule bexI[of _ u])"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist (p a) (p u) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n    (\\<forall>s\\<in>{a..u}. dist (p a) (p s) \\<le> d)\n 2. u \\<in> {a..b}", "using B \\<open>a \\<le> u\\<close> \\<open>u \\<le> b\\<close> C"], ["proof (prove)\nusing this:\n  ?s \\<in> {a..u} \\<Longrightarrow> dist (p a) (p ?s) \\<le> d\n  a \\<le> u\n  u \\<le> b\n  d - 4 * delta - 2 * C \\<le> dist (p a) (p u)\n\ngoal (2 subgoals):\n 1. dist (p a) (p u) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n    (\\<forall>s\\<in>{a..u}. dist (p a) (p s) \\<le> d)\n 2. u \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{a..b}.\n     dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n     (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{a..b}.\n     dist (p a) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n     (\\<forall>s\\<in>{a..t}. dist (p a) (p s) \\<le> d)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Same lemma, except that one exchanges the roles of the beginning and the end point.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) quasi_convex_projection_small_gaps':\n  assumes \"continuous_on {a..(b::real)} f\"\n          \"a \\<le> b\"\n          \"quasiconvex C G\"\n          \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> p x \\<in> proj_set (f x) G\"\n          \"delta > deltaG(TYPE('a))\"\n          \"d \\<in> {4 * delta + 2 * C..dist (p a) (p b)}\"\n  shows \"\\<exists>t \\<in> {a..b}. dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C .. d}\n                    \\<and> (\\<forall>s \\<in> {t..b}. dist (p b) (p s) \\<le> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{t..b}. dist (p b) (p s) \\<le> d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{t..b}. dist (p b) (p s) \\<le> d)", "have *: \"continuous_on {-b..-a} (\\<lambda>t. f(-t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {- b..- a} (\\<lambda>t. f (- t))", "using continuous_on_compose[of \"{-b..-a}\" \"\\<lambda>t. -t\" f]"], ["proof (prove)\nusing this:\n  \\<lbrakk>continuous_on {- b..- a} uminus;\n   continuous_on (uminus ` {- b..- a}) f\\<rbrakk>\n  \\<Longrightarrow> continuous_on {- b..- a} (f \\<circ> uminus)\n\ngoal (1 subgoal):\n 1. continuous_on {- b..- a} (\\<lambda>t. f (- t))", "using assms(1) continuous_on_minus[OF continuous_on_id]"], ["proof (prove)\nusing this:\n  \\<lbrakk>continuous_on {- b..- a} uminus;\n   continuous_on (uminus ` {- b..- a}) f\\<rbrakk>\n  \\<Longrightarrow> continuous_on {- b..- a} (f \\<circ> uminus)\n  continuous_on {a..b} f\n  continuous_on ?s uminus\n\ngoal (1 subgoal):\n 1. continuous_on {- b..- a} (\\<lambda>t. f (- t))", "by auto"], ["proof (state)\nthis:\n  continuous_on {- b..- a} (\\<lambda>t. f (- t))\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{t..b}. dist (p b) (p s) \\<le> d)", "define q where \"q = (\\<lambda>t. p(-t))\""], ["proof (state)\nthis:\n  q = (\\<lambda>t. p (- t))\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{t..b}. dist (p b) (p s) \\<le> d)", "have \"\\<exists>t \\<in> {-b..-a}. (dist (q (-b)) (q t) \\<in> {d - 4 * delta - 2 * C .. d})\n                    \\<and> (\\<forall>s \\<in> {-b..t}. dist (q (-b)) (q s) \\<le> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{- b..- a}.\n       dist (q (- b)) (q t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{- b..t}. dist (q (- b)) (q s) \\<le> d)", "apply (rule quasi_convex_projection_small_gaps[where ?f = \"\\<lambda>t. f(-t)\" and ?G = G])"], ["proof (prove)\ngoal (6 subgoals):\n 1. continuous_on {- b..- a} (\\<lambda>t. f (- t))\n 2. - b \\<le> - a\n 3. quasiconvex C G\n 4. \\<And>t.\n       t \\<in> {- b..- a} \\<Longrightarrow> q t \\<in> proj_set (f (- t)) G\n 5. deltaG TYPE('a) < delta\n 6. d \\<in> {4 * delta + 2 * C..dist (q (- b)) (q (- a))}", "unfolding q_def"], ["proof (prove)\ngoal (6 subgoals):\n 1. continuous_on {- b..- a} (\\<lambda>t. f (- t))\n 2. - b \\<le> - a\n 3. quasiconvex C G\n 4. \\<And>t.\n       t \\<in> {- b..- a} \\<Longrightarrow>\n       p (- t) \\<in> proj_set (f (- t)) G\n 5. deltaG TYPE('a) < delta\n 6. d \\<in> {4 * delta + 2 * C..dist (p (- (- b))) (p (- (- a)))}", "using assms *"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n  a \\<le> b\n  quasiconvex C G\n  ?x \\<in> {a..b} \\<Longrightarrow> p ?x \\<in> proj_set (f ?x) G\n  deltaG TYPE('a) < delta\n  d \\<in> {4 * delta + 2 * C..dist (p a) (p b)}\n  continuous_on {- b..- a} (\\<lambda>t. f (- t))\n\ngoal (6 subgoals):\n 1. continuous_on {- b..- a} (\\<lambda>t. f (- t))\n 2. - b \\<le> - a\n 3. quasiconvex C G\n 4. \\<And>t.\n       t \\<in> {- b..- a} \\<Longrightarrow>\n       p (- t) \\<in> proj_set (f (- t)) G\n 5. deltaG TYPE('a) < delta\n 6. d \\<in> {4 * delta + 2 * C..dist (p (- (- b))) (p (- (- a)))}", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{- b..- a}.\n     dist (q (- b)) (q t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n     (\\<forall>s\\<in>{- b..t}. dist (q (- b)) (q s) \\<le> d)\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{t..b}. dist (p b) (p s) \\<le> d)", "then"], ["proof (chain)\npicking this:\n  \\<exists>t\\<in>{- b..- a}.\n     dist (q (- b)) (q t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n     (\\<forall>s\\<in>{- b..t}. dist (q (- b)) (q s) \\<le> d)", "obtain t where t: \"t \\<in> {-b..-a}\" \"dist (q (-b)) (q t) \\<in> {d - 4 * delta - 2 * C .. d}\"\n                      \"\\<And>s. s \\<in> {-b..t} \\<Longrightarrow> dist (q (-b)) (q s) \\<le> d\""], ["proof (prove)\nusing this:\n  \\<exists>t\\<in>{- b..- a}.\n     dist (q (- b)) (q t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n     (\\<forall>s\\<in>{- b..t}. dist (q (- b)) (q s) \\<le> d)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> {- b..- a};\n         dist (q (- b)) (q t) \\<in> {d - 4 * delta - 2 * C..d};\n         \\<And>s.\n            s \\<in> {- b..t} \\<Longrightarrow>\n            dist (q (- b)) (q s) \\<le> d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> {- b..- a}\n  dist (q (- b)) (q t) \\<in> {d - 4 * delta - 2 * C..d}\n  ?s \\<in> {- b..t} \\<Longrightarrow> dist (q (- b)) (q ?s) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{t..b}. dist (p b) (p s) \\<le> d)", "have *: \"dist (p b) (p s) \\<le> d\" if \"s \\<in> {-t..b}\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p b) (p s) \\<le> d", "using t(3)[of \"-s\"] that q_def"], ["proof (prove)\nusing this:\n  - s \\<in> {- b..t} \\<Longrightarrow> dist (q (- b)) (q (- s)) \\<le> d\n  s \\<in> {- t..b}\n  q = (\\<lambda>t. p (- t))\n\ngoal (1 subgoal):\n 1. dist (p b) (p s) \\<le> d", "by auto"], ["proof (state)\nthis:\n  ?s \\<in> {- t..b} \\<Longrightarrow> dist (p b) (p ?s) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{t..b}. dist (p b) (p s) \\<le> d)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{a..b}.\n       dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n       (\\<forall>s\\<in>{t..b}. dist (p b) (p s) \\<le> d)", "apply (rule bexI[of _ \"-t\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist (p b) (p (- t)) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n    (\\<forall>s\\<in>{- t..b}. dist (p b) (p s) \\<le> d)\n 2. - t \\<in> {a..b}", "using t * q_def"], ["proof (prove)\nusing this:\n  t \\<in> {- b..- a}\n  dist (q (- b)) (q t) \\<in> {d - 4 * delta - 2 * C..d}\n  ?s \\<in> {- b..t} \\<Longrightarrow> dist (q (- b)) (q ?s) \\<le> d\n  ?s \\<in> {- t..b} \\<Longrightarrow> dist (p b) (p ?s) \\<le> d\n  q = (\\<lambda>t. p (- t))\n\ngoal (2 subgoals):\n 1. dist (p b) (p (- t)) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n    (\\<forall>s\\<in>{- t..b}. dist (p b) (p s) \\<le> d)\n 2. - t \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{a..b}.\n     dist (p b) (p t) \\<in> {d - 4 * delta - 2 * C..d} \\<and>\n     (\\<forall>s\\<in>{t..b}. dist (p b) (p s) \\<le> d)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>The Morse-Gromov Theorem\\<close>"], ["", "text \\<open>The goal of this section is to prove a central basic result in the theory of hyperbolic spaces,\nusually called the Morse Lemma. It is really\na theorem, and we add the name Gromov the avoid the confusion with the other Morse lemma\non the existence of good coordinates for $C^2$ functions with non-vanishing hessian.\n\nIt states that a quasi-geodesic remains within bounded distance of a geodesic with the same\nendpoints, the error depending only on $\\delta$ and on the parameters $(\\lambda, C)$ of the\nquasi-geodesic, but not on its length.\n\nThere are several proofs of this result. We will follow the one of Shchur~\\cite{shchur}, which\ngets an optimal dependency in terms of the parameters of the quasi-isometry, contrary to all\nprevious proofs. The price to pay is that the proof is more involved (relying in particular on\nthe fact that the closest point projection on quasi-convex sets is exponentially contracting).\n\nWe will also give afterwards for completeness the proof in~\\cite{bridson_haefliger}, as it brings\nup interesting tools, although the dependency it gives is worse.\\<close>"], ["", "text \\<open>The next lemma (for $C = 0$, Lemma 2 in~\\cite{shchur}) asserts that, if two points are not too far apart (at distance at most\n$10 \\delta$), and far enough from a given geodesic segment, then when one moves towards this\ngeodesic segment by a fixed amount (here $5 \\delta$), then the two points become closer (the new\ndistance is at most $5 \\delta$, gaining a factor of $2$). Later, we will iterate this lemma to\nshow that the projection on a geodesic segment is exponentially contracting. For the application,\nwe give a more general version involving an additional constant $C$.\n\nThis lemma holds for $\\delta$ the hyperbolicity constant. We will want to apply it with $\\delta > 0$,\nso to avoid problems in the case $\\delta = 0$ we formulate it not using the hyperbolicity constant of\nthe given type, but any constant which is at least the hyperbolicity constant (this is to work\naround the fact that one can not say or use easily in Isabelle that a type with hyperbolicity\n$\\delta$ is also hyperbolic for any larger constant $\\delta'$.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) geodesic_projection_exp_contracting_aux:\n  assumes \"geodesic_segment G\"\n          \"px \\<in> proj_set x G\"\n          \"py \\<in> proj_set y G\"\n          \"delta \\<ge> deltaG(TYPE('a))\"\n          \"dist x y \\<le> 10 * delta + C\"\n          \"M \\<ge> 15/2 * delta\"\n          \"dist px x \\<ge> M + 5 * delta + C/2\"\n          \"dist py y \\<ge> M + 5 * delta + C/2\"\n          \"C \\<ge> 0\"\n  shows \"dist (geodesic_segment_param {px--x} px M)\n              (geodesic_segment_param {py--y} py M) \\<le> 5 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"dist px x \\<le> dist py x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px x \\<le> dist py x", "using proj_setD(2)[OF assms(2)] infdist_le[OF proj_setD(1)[OF assms(3)], of x]"], ["proof (prove)\nusing this:\n  dist x px = infdist x G\n  infdist x G \\<le> dist x py\n\ngoal (1 subgoal):\n 1. dist px x \\<le> dist py x", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist px x \\<le> dist py x\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"dist py y \\<le> dist px y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py y \\<le> dist px y", "using proj_setD(2)[OF assms(3)] infdist_le[OF proj_setD(1)[OF assms(2)], of y]"], ["proof (prove)\nusing this:\n  dist y py = infdist y G\n  infdist y G \\<le> dist y px\n\ngoal (1 subgoal):\n 1. dist py y \\<le> dist px y", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist py y \\<le> dist px y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"delta \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> delta", "using assms local.delta_nonneg"], ["proof (prove)\nusing this:\n  geodesic_segment G\n  px \\<in> proj_set x G\n  py \\<in> proj_set y G\n  deltaG TYPE('a) \\<le> delta\n  dist x y \\<le> 10 * delta + C\n  15 / 2 * delta \\<le> M\n  M + 5 * delta + C / 2 \\<le> dist px x\n  M + 5 * delta + C / 2 \\<le> dist py y\n  0 \\<le> C\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> delta", "by linarith"], ["proof (state)\nthis:\n  0 \\<le> delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "then"], ["proof (chain)\npicking this:\n  0 \\<le> delta", "have M: \"M \\<ge> 0\" \"M \\<le> dist px x\" \"M \\<le> dist px y\" \"M \\<le> dist py x\" \"M \\<le> dist py y\""], ["proof (prove)\nusing this:\n  0 \\<le> delta\n\ngoal (1 subgoal):\n 1. (0 \\<le> M &&& M \\<le> dist px x) &&&\n    M \\<le> dist px y &&& M \\<le> dist py x &&& M \\<le> dist py y", "using assms \\<open>dist px x \\<le> dist py x\\<close> \\<open>dist py y \\<le> dist px y \\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> delta\n  geodesic_segment G\n  px \\<in> proj_set x G\n  py \\<in> proj_set y G\n  deltaG TYPE('a) \\<le> delta\n  dist x y \\<le> 10 * delta + C\n  15 / 2 * delta \\<le> M\n  M + 5 * delta + C / 2 \\<le> dist px x\n  M + 5 * delta + C / 2 \\<le> dist py y\n  0 \\<le> C\n  dist px x \\<le> dist py x\n  dist py y \\<le> dist px y\n\ngoal (1 subgoal):\n 1. (0 \\<le> M &&& M \\<le> dist px x) &&&\n    M \\<le> dist px y &&& M \\<le> dist py x &&& M \\<le> dist py y", "by auto"], ["proof (state)\nthis:\n  0 \\<le> M\n  M \\<le> dist px x\n  M \\<le> dist px y\n  M \\<le> dist py x\n  M \\<le> dist py y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"px \\<in> G\" \"py \\<in> G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. px \\<in> G &&& py \\<in> G", "using assms proj_setD"], ["proof (prove)\nusing this:\n  geodesic_segment G\n  px \\<in> proj_set x G\n  py \\<in> proj_set y G\n  deltaG TYPE('a) \\<le> delta\n  dist x y \\<le> 10 * delta + C\n  15 / 2 * delta \\<le> M\n  M + 5 * delta + C / 2 \\<le> dist px x\n  M + 5 * delta + C / 2 \\<le> dist py y\n  0 \\<le> C\n  ?y \\<in> proj_set ?x ?A \\<Longrightarrow> ?y \\<in> ?A\n  ?y \\<in> proj_set ?x ?A \\<Longrightarrow> dist ?x ?y = infdist ?x ?A\n\ngoal (1 subgoal):\n 1. px \\<in> G &&& py \\<in> G", "by auto"], ["proof (state)\nthis:\n  px \\<in> G\n  py \\<in> G\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "define x' where \"x' = geodesic_segment_param {px--x} px M\""], ["proof (state)\nthis:\n  x' = geodesic_segment_param {px--x} px M\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "define y' where \"y' = geodesic_segment_param {py--y} py M\""], ["proof (state)\nthis:\n  y' = geodesic_segment_param {py--y} py M\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "text \\<open>First step: the distance between $px$ and $py$ is at most $5\\delta$.\\<close>"], ["proof (state)\nthis:\n  y' = geodesic_segment_param {py--y} py M\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"dist px py \\<le> max (5 * deltaG(TYPE('a))) (dist x y - dist px x - dist py y + 10 * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px py\n    \\<le> max (5 * deltaG TYPE('a))\n           (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a))", "by (rule proj_along_geodesic_contraction[OF assms(1) assms(2) assms(3)])"], ["proof (state)\nthis:\n  dist px py\n  \\<le> max (5 * deltaG TYPE('a))\n         (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  dist px py\n  \\<le> max (5 * deltaG TYPE('a))\n         (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... \\<le> max (5 * deltaG(TYPE('a))) (5 * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (5 * deltaG TYPE('a))\n     (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a))\n    \\<le> max (5 * deltaG TYPE('a)) (5 * deltaG TYPE('a))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. deltaG TYPE('a) \\<le> deltaG TYPE('a)\n 2. 0 \\<le> 5\n 3. dist x y - dist px x - dist py y + 10 * deltaG TYPE('a)\n    \\<le> 5 * deltaG TYPE('a)", "using assms \\<open>delta \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  geodesic_segment G\n  px \\<in> proj_set x G\n  py \\<in> proj_set y G\n  deltaG TYPE('a) \\<le> delta\n  dist x y \\<le> 10 * delta + C\n  15 / 2 * delta \\<le> M\n  M + 5 * delta + C / 2 \\<le> dist px x\n  M + 5 * delta + C / 2 \\<le> dist py y\n  0 \\<le> C\n  0 \\<le> delta\n\ngoal (3 subgoals):\n 1. deltaG TYPE('a) \\<le> deltaG TYPE('a)\n 2. 0 \\<le> 5\n 3. dist x y - dist px x - dist py y + 10 * deltaG TYPE('a)\n    \\<le> 5 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  max (5 * deltaG TYPE('a))\n   (dist x y - dist px x - dist py y + 10 * deltaG TYPE('a))\n  \\<le> max (5 * deltaG TYPE('a)) (5 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "finally"], ["proof (chain)\npicking this:\n  dist px py \\<le> max (5 * deltaG TYPE('a)) (5 * deltaG TYPE('a))", "have \"dist px py \\<le> 5 * delta\""], ["proof (prove)\nusing this:\n  dist px py \\<le> max (5 * deltaG TYPE('a)) (5 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. dist px py \\<le> 5 * delta", "using \\<open>delta \\<ge> deltaG(TYPE('a))\\<close>"], ["proof (prove)\nusing this:\n  dist px py \\<le> max (5 * deltaG TYPE('a)) (5 * deltaG TYPE('a))\n  deltaG TYPE('a) \\<le> delta\n\ngoal (1 subgoal):\n 1. dist px py \\<le> 5 * delta", "by auto"], ["proof (state)\nthis:\n  dist px py \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "text \\<open>Second step: show that all the interesting Gromov products at bounded below by $M$.\\<close>"], ["proof (state)\nthis:\n  dist px py \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have *: \"x' \\<in> {px--x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> {px--x}", "unfolding x'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {px--x} px M \\<in> {px--x}", "by (simp add: geodesic_segment_param_in_segment)"], ["proof (state)\nthis:\n  x' \\<in> {px--x}\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"px \\<in> proj_set x' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. px \\<in> proj_set x' G", "by (rule proj_set_geodesic_same_basepoint[OF \\<open>px \\<in> proj_set x G\\<close> _ *], auto)"], ["proof (state)\nthis:\n  px \\<in> proj_set x' G\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"dist px x' = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px x' = M", "unfolding x'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px (geodesic_segment_param {px--x} px M) = M", "using M"], ["proof (prove)\nusing this:\n  0 \\<le> M\n  M \\<le> dist px x\n  M \\<le> dist px y\n  M \\<le> dist py x\n  M \\<le> dist py y\n\ngoal (1 subgoal):\n 1. dist px (geodesic_segment_param {px--x} px M) = M", "by auto"], ["proof (state)\nthis:\n  dist px x' = M\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"dist px x' \\<le> dist py x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px x' \\<le> dist py x'", "using proj_setD(2)[OF \\<open>px \\<in> proj_set x' G\\<close>] infdist_le[OF proj_setD(1)[OF assms(3)], of x']"], ["proof (prove)\nusing this:\n  dist x' px = infdist x' G\n  infdist x' G \\<le> dist x' py\n\ngoal (1 subgoal):\n 1. dist px x' \\<le> dist py x'", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist px x' \\<le> dist py x'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have **: \"dist px x = dist px x' + dist x' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px x = dist px x' + dist x' x", "using geodesic_segment_dist[OF _ *, of px x]"], ["proof (prove)\nusing this:\n  geodesic_segment_between {px--x} px x \\<Longrightarrow>\n  dist px x' + dist x' x = dist px x\n\ngoal (1 subgoal):\n 1. dist px x = dist px x' + dist x' x", "by auto"], ["proof (state)\nthis:\n  dist px x = dist px x' + dist x' x\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have Ixx: \"Gromov_product_at px x' x = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at px x' x = M", "unfolding Gromov_product_at_def ** x'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist px (geodesic_segment_param {px--x} px M) +\n     (dist px (geodesic_segment_param {px--x} px M) +\n      dist (geodesic_segment_param {px--x} px M) x) -\n     dist (geodesic_segment_param {px--x} px M) x) /\n    2 =\n    M", "using M"], ["proof (prove)\nusing this:\n  0 \\<le> M\n  M \\<le> dist px x\n  M \\<le> dist px y\n  M \\<le> dist py x\n  M \\<le> dist py y\n\ngoal (1 subgoal):\n 1. (dist px (geodesic_segment_param {px--x} px M) +\n     (dist px (geodesic_segment_param {px--x} px M) +\n      dist (geodesic_segment_param {px--x} px M) x) -\n     dist (geodesic_segment_param {px--x} px M) x) /\n    2 =\n    M", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at px x' x = M\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"2 * M = dist px x' + dist px x - dist x' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * M = dist px x' + dist px x - dist x' x", "unfolding ** x'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * M =\n    dist px (geodesic_segment_param {px--x} px M) +\n    (dist px (geodesic_segment_param {px--x} px M) +\n     dist (geodesic_segment_param {px--x} px M) x) -\n    dist (geodesic_segment_param {px--x} px M) x", "using M"], ["proof (prove)\nusing this:\n  0 \\<le> M\n  M \\<le> dist px x\n  M \\<le> dist px y\n  M \\<le> dist py x\n  M \\<le> dist py y\n\ngoal (1 subgoal):\n 1. 2 * M =\n    dist px (geodesic_segment_param {px--x} px M) +\n    (dist px (geodesic_segment_param {px--x} px M) +\n     dist (geodesic_segment_param {px--x} px M) x) -\n    dist (geodesic_segment_param {px--x} px M) x", "by auto"], ["proof (state)\nthis:\n  2 * M = dist px x' + dist px x - dist x' x\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  2 * M = dist px x' + dist px x - dist x' x\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... \\<le> dist py x' + dist py x - dist x' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px x' + dist px x - dist x' x\n    \\<le> dist py x' + dist py x - dist x' x", "apply (intro mono_intros, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist px x' \\<le> dist py x'\n 2. dist px x \\<le> dist py x", "by fact+"], ["proof (state)\nthis:\n  dist px x' + dist px x - dist x' x\n  \\<le> dist py x' + dist py x - dist x' x\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  dist px x' + dist px x - dist x' x\n  \\<le> dist py x' + dist py x - dist x' x\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... = 2 * Gromov_product_at py x x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py x' + dist py x - dist x' x = 2 * Gromov_product_at py x x'", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py x' + dist py x - dist x' x =\n    2 * ((dist py x + dist py x' - dist x x') / 2)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist py x' + dist py x - dist x' x = 2 * Gromov_product_at py x x'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * M \\<le> 2 * Gromov_product_at py x x'", "have Iyx: \"Gromov_product_at py x x' \\<ge> M\""], ["proof (prove)\nusing this:\n  2 * M \\<le> 2 * Gromov_product_at py x x'\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at py x x'", "by auto"], ["proof (state)\nthis:\n  M \\<le> Gromov_product_at py x x'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have *: \"y' \\<in> {py--y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y' \\<in> {py--y}", "unfolding y'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {py--y} py M \\<in> {py--y}", "by (simp add: geodesic_segment_param_in_segment)"], ["proof (state)\nthis:\n  y' \\<in> {py--y}\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"py \\<in> proj_set y' G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. py \\<in> proj_set y' G", "by (rule proj_set_geodesic_same_basepoint[OF \\<open>py \\<in> proj_set y G\\<close> _ *], auto)"], ["proof (state)\nthis:\n  py \\<in> proj_set y' G\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"dist py y' = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py y' = M", "unfolding y'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py (geodesic_segment_param {py--y} py M) = M", "using M"], ["proof (prove)\nusing this:\n  0 \\<le> M\n  M \\<le> dist px x\n  M \\<le> dist px y\n  M \\<le> dist py x\n  M \\<le> dist py y\n\ngoal (1 subgoal):\n 1. dist py (geodesic_segment_param {py--y} py M) = M", "by auto"], ["proof (state)\nthis:\n  dist py y' = M\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"dist py y' \\<le> dist px y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py y' \\<le> dist px y'", "using proj_setD(2)[OF \\<open>py \\<in> proj_set y' G\\<close>] infdist_le[OF proj_setD(1)[OF assms(2)], of y']"], ["proof (prove)\nusing this:\n  dist y' py = infdist y' G\n  infdist y' G \\<le> dist y' px\n\ngoal (1 subgoal):\n 1. dist py y' \\<le> dist px y'", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist py y' \\<le> dist px y'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have **: \"dist py y = dist py y' + dist y' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py y = dist py y' + dist y' y", "using geodesic_segment_dist[OF _ *, of py y]"], ["proof (prove)\nusing this:\n  geodesic_segment_between {py--y} py y \\<Longrightarrow>\n  dist py y' + dist y' y = dist py y\n\ngoal (1 subgoal):\n 1. dist py y = dist py y' + dist y' y", "by auto"], ["proof (state)\nthis:\n  dist py y = dist py y' + dist y' y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have Iyy: \"Gromov_product_at py y' y = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at py y' y = M", "unfolding Gromov_product_at_def ** y'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dist py (geodesic_segment_param {py--y} py M) +\n     (dist py (geodesic_segment_param {py--y} py M) +\n      dist (geodesic_segment_param {py--y} py M) y) -\n     dist (geodesic_segment_param {py--y} py M) y) /\n    2 =\n    M", "using M"], ["proof (prove)\nusing this:\n  0 \\<le> M\n  M \\<le> dist px x\n  M \\<le> dist px y\n  M \\<le> dist py x\n  M \\<le> dist py y\n\ngoal (1 subgoal):\n 1. (dist py (geodesic_segment_param {py--y} py M) +\n     (dist py (geodesic_segment_param {py--y} py M) +\n      dist (geodesic_segment_param {py--y} py M) y) -\n     dist (geodesic_segment_param {py--y} py M) y) /\n    2 =\n    M", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at py y' y = M\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"2 * M = dist py y' + dist py y - dist y' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * M = dist py y' + dist py y - dist y' y", "unfolding ** y'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * M =\n    dist py (geodesic_segment_param {py--y} py M) +\n    (dist py (geodesic_segment_param {py--y} py M) +\n     dist (geodesic_segment_param {py--y} py M) y) -\n    dist (geodesic_segment_param {py--y} py M) y", "using M"], ["proof (prove)\nusing this:\n  0 \\<le> M\n  M \\<le> dist px x\n  M \\<le> dist px y\n  M \\<le> dist py x\n  M \\<le> dist py y\n\ngoal (1 subgoal):\n 1. 2 * M =\n    dist py (geodesic_segment_param {py--y} py M) +\n    (dist py (geodesic_segment_param {py--y} py M) +\n     dist (geodesic_segment_param {py--y} py M) y) -\n    dist (geodesic_segment_param {py--y} py M) y", "by auto"], ["proof (state)\nthis:\n  2 * M = dist py y' + dist py y - dist y' y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  2 * M = dist py y' + dist py y - dist y' y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... \\<le> dist px y' + dist px y - dist y' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py y' + dist py y - dist y' y\n    \\<le> dist px y' + dist px y - dist y' y", "apply (intro mono_intros, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist py y' \\<le> dist px y'\n 2. dist py y \\<le> dist px y", "by fact+"], ["proof (state)\nthis:\n  dist py y' + dist py y - dist y' y\n  \\<le> dist px y' + dist px y - dist y' y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  dist py y' + dist py y - dist y' y\n  \\<le> dist px y' + dist px y - dist y' y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... = 2 * Gromov_product_at px y y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px y' + dist px y - dist y' y = 2 * Gromov_product_at px y y'", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px y' + dist px y - dist y' y =\n    2 * ((dist px y + dist px y' - dist y y') / 2)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist px y' + dist px y - dist y' y = 2 * Gromov_product_at px y y'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * M \\<le> 2 * Gromov_product_at px y y'", "have Ixy: \"Gromov_product_at px y y' \\<ge> M\""], ["proof (prove)\nusing this:\n  2 * M \\<le> 2 * Gromov_product_at px y y'\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at px y y'", "by auto"], ["proof (state)\nthis:\n  M \\<le> Gromov_product_at px y y'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"2 * M \\<le> dist px x + dist py y - dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * M \\<le> dist px x + dist py y - dist x y", "using assms"], ["proof (prove)\nusing this:\n  geodesic_segment G\n  px \\<in> proj_set x G\n  py \\<in> proj_set y G\n  deltaG TYPE('a) \\<le> delta\n  dist x y \\<le> 10 * delta + C\n  15 / 2 * delta \\<le> M\n  M + 5 * delta + C / 2 \\<le> dist px x\n  M + 5 * delta + C / 2 \\<le> dist py y\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 2 * M \\<le> dist px x + dist py y - dist x y", "by auto"], ["proof (state)\nthis:\n  2 * M \\<le> dist px x + dist py y - dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  2 * M \\<le> dist px x + dist py y - dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... \\<le> dist px x + dist px y - dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px x + dist py y - dist x y \\<le> dist px x + dist px y - dist x y", "by (intro mono_intros, fact)"], ["proof (state)\nthis:\n  dist px x + dist py y - dist x y \\<le> dist px x + dist px y - dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  dist px x + dist py y - dist x y \\<le> dist px x + dist px y - dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... = 2 * Gromov_product_at px x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px x + dist px y - dist x y = 2 * Gromov_product_at px x y", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px x + dist px y - dist x y =\n    2 * ((dist px x + dist px y - dist x y) / 2)", "by auto"], ["proof (state)\nthis:\n  dist px x + dist px y - dist x y = 2 * Gromov_product_at px x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * M \\<le> 2 * Gromov_product_at px x y", "have Ix: \"Gromov_product_at px x y \\<ge> M\""], ["proof (prove)\nusing this:\n  2 * M \\<le> 2 * Gromov_product_at px x y\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at px x y", "by auto"], ["proof (state)\nthis:\n  M \\<le> Gromov_product_at px x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"2 * M \\<le> dist px x + dist py y - dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * M \\<le> dist px x + dist py y - dist x y", "using assms"], ["proof (prove)\nusing this:\n  geodesic_segment G\n  px \\<in> proj_set x G\n  py \\<in> proj_set y G\n  deltaG TYPE('a) \\<le> delta\n  dist x y \\<le> 10 * delta + C\n  15 / 2 * delta \\<le> M\n  M + 5 * delta + C / 2 \\<le> dist px x\n  M + 5 * delta + C / 2 \\<le> dist py y\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 2 * M \\<le> dist px x + dist py y - dist x y", "by auto"], ["proof (state)\nthis:\n  2 * M \\<le> dist px x + dist py y - dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  2 * M \\<le> dist px x + dist py y - dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... \\<le> dist py x + dist py y - dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px x + dist py y - dist x y \\<le> dist py x + dist py y - dist x y", "by (intro mono_intros, fact)"], ["proof (state)\nthis:\n  dist px x + dist py y - dist x y \\<le> dist py x + dist py y - dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  dist px x + dist py y - dist x y \\<le> dist py x + dist py y - dist x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... = 2 * Gromov_product_at py x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py x + dist py y - dist x y = 2 * Gromov_product_at py x y", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist py x + dist py y - dist x y =\n    2 * ((dist py x + dist py y - dist x y) / 2)", "by auto"], ["proof (state)\nthis:\n  dist py x + dist py y - dist x y = 2 * Gromov_product_at py x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * M \\<le> 2 * Gromov_product_at py x y", "have Iy: \"Gromov_product_at py x y \\<ge> M\""], ["proof (prove)\nusing this:\n  2 * M \\<le> 2 * Gromov_product_at py x y\n\ngoal (1 subgoal):\n 1. M \\<le> Gromov_product_at py x y", "by auto"], ["proof (state)\nthis:\n  M \\<le> Gromov_product_at py x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "text \\<open>Third step: prove the estimate\\<close>"], ["proof (state)\nthis:\n  M \\<le> Gromov_product_at py x y\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"M - 2 * delta \\<le> Min {Gromov_product_at px x' x, Gromov_product_at px x y, Gromov_product_at px y y'} - 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M - 2 * delta\n    \\<le> Min {Gromov_product_at px x' x, Gromov_product_at px x y,\n               Gromov_product_at px y y'} -\n          2 * deltaG TYPE('a)", "using Ixx Ixy Ix \\<open>delta \\<ge> deltaG(TYPE('a))\\<close>"], ["proof (prove)\nusing this:\n  Gromov_product_at px x' x = M\n  M \\<le> Gromov_product_at px y y'\n  M \\<le> Gromov_product_at px x y\n  deltaG TYPE('a) \\<le> delta\n\ngoal (1 subgoal):\n 1. M - 2 * delta\n    \\<le> Min {Gromov_product_at px x' x, Gromov_product_at px x y,\n               Gromov_product_at px y y'} -\n          2 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  M - 2 * delta\n  \\<le> Min {Gromov_product_at px x' x, Gromov_product_at px x y,\n             Gromov_product_at px y y'} -\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  M - 2 * delta\n  \\<le> Min {Gromov_product_at px x' x, Gromov_product_at px x y,\n             Gromov_product_at px y y'} -\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... \\<le> Gromov_product_at px x' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {Gromov_product_at px x' x, Gromov_product_at px x y,\n         Gromov_product_at px y y'} -\n    2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at px x' y'", "by (intro mono_intros)"], ["proof (state)\nthis:\n  Min {Gromov_product_at px x' x, Gromov_product_at px x y,\n       Gromov_product_at px y y'} -\n  2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at px x' y'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "finally"], ["proof (chain)\npicking this:\n  M - 2 * delta \\<le> Gromov_product_at px x' y'", "have A: \"M - 4 * delta + dist x' y' \\<le> dist px y'\""], ["proof (prove)\nusing this:\n  M - 2 * delta \\<le> Gromov_product_at px x' y'\n\ngoal (1 subgoal):\n 1. M - 4 * delta + dist x' y' \\<le> dist px y'", "unfolding Gromov_product_at_def \\<open>dist px x' = M\\<close>"], ["proof (prove)\nusing this:\n  M - 2 * delta \\<le> (M + dist px y' - dist x' y') / 2\n\ngoal (1 subgoal):\n 1. M - 4 * delta + dist x' y' \\<le> dist px y'", "by auto"], ["proof (state)\nthis:\n  M - 4 * delta + dist x' y' \\<le> dist px y'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"M - 2 * delta \\<le> Min {Gromov_product_at py x' x, Gromov_product_at py x y, Gromov_product_at py y y'} - 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M - 2 * delta\n    \\<le> Min {Gromov_product_at py x' x, Gromov_product_at py x y,\n               Gromov_product_at py y y'} -\n          2 * deltaG TYPE('a)", "using Iyx Iyy Iy \\<open>delta \\<ge> deltaG(TYPE('a))\\<close>"], ["proof (prove)\nusing this:\n  M \\<le> Gromov_product_at py x x'\n  Gromov_product_at py y' y = M\n  M \\<le> Gromov_product_at py x y\n  deltaG TYPE('a) \\<le> delta\n\ngoal (1 subgoal):\n 1. M - 2 * delta\n    \\<le> Min {Gromov_product_at py x' x, Gromov_product_at py x y,\n               Gromov_product_at py y y'} -\n          2 * deltaG TYPE('a)", "by (auto simp add: Gromov_product_commute)"], ["proof (state)\nthis:\n  M - 2 * delta\n  \\<le> Min {Gromov_product_at py x' x, Gromov_product_at py x y,\n             Gromov_product_at py y y'} -\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  M - 2 * delta\n  \\<le> Min {Gromov_product_at py x' x, Gromov_product_at py x y,\n             Gromov_product_at py y y'} -\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... \\<le> Gromov_product_at py x' y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {Gromov_product_at py x' x, Gromov_product_at py x y,\n         Gromov_product_at py y y'} -\n    2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at py x' y'", "by (intro mono_intros)"], ["proof (state)\nthis:\n  Min {Gromov_product_at py x' x, Gromov_product_at py x y,\n       Gromov_product_at py y y'} -\n  2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at py x' y'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "finally"], ["proof (chain)\npicking this:\n  M - 2 * delta \\<le> Gromov_product_at py x' y'", "have B: \"M - 4 * delta + dist x' y' \\<le> dist py x'\""], ["proof (prove)\nusing this:\n  M - 2 * delta \\<le> Gromov_product_at py x' y'\n\ngoal (1 subgoal):\n 1. M - 4 * delta + dist x' y' \\<le> dist py x'", "unfolding Gromov_product_at_def \\<open>dist py y' = M\\<close>"], ["proof (prove)\nusing this:\n  M - 2 * delta \\<le> (dist py x' + M - dist x' y') / 2\n\ngoal (1 subgoal):\n 1. M - 4 * delta + dist x' y' \\<le> dist py x'", "by auto"], ["proof (state)\nthis:\n  M - 4 * delta + dist x' y' \\<le> dist py x'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"dist px py \\<le> 2 * M - 10 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px py \\<le> 2 * M - 10 * delta", "using assms \\<open>dist px py \\<le> 5 * delta\\<close>"], ["proof (prove)\nusing this:\n  geodesic_segment G\n  px \\<in> proj_set x G\n  py \\<in> proj_set y G\n  deltaG TYPE('a) \\<le> delta\n  dist x y \\<le> 10 * delta + C\n  15 / 2 * delta \\<le> M\n  M + 5 * delta + C / 2 \\<le> dist px x\n  M + 5 * delta + C / 2 \\<le> dist py y\n  0 \\<le> C\n  dist px py \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. dist px py \\<le> 2 * M - 10 * delta", "by auto"], ["proof (state)\nthis:\n  dist px py \\<le> 2 * M - 10 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"2 * M - 8 * delta + 2 * dist x' y' \\<le> dist px y' + dist py x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * M - 8 * delta + 2 * dist x' y' \\<le> dist px y' + dist py x'", "using A B"], ["proof (prove)\nusing this:\n  M - 4 * delta + dist x' y' \\<le> dist px y'\n  M - 4 * delta + dist x' y' \\<le> dist py x'\n\ngoal (1 subgoal):\n 1. 2 * M - 8 * delta + 2 * dist x' y' \\<le> dist px y' + dist py x'", "by auto"], ["proof (state)\nthis:\n  2 * M - 8 * delta + 2 * dist x' y' \\<le> dist px y' + dist py x'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  2 * M - 8 * delta + 2 * dist x' y' \\<le> dist px y' + dist py x'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) + 2 * deltaG TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist px y' + dist py x'\n    \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) +\n          2 * deltaG TYPE('a)", "by (rule hyperb_quad_ineq)"], ["proof (state)\nthis:\n  dist px y' + dist py x'\n  \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  dist px y' + dist py x'\n  \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) +\n        2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "have \"... \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) + 2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (dist px py + dist y' x') (dist px x' + dist y' py) +\n    2 * deltaG TYPE('a)\n    \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) +\n          2 * delta", "using \\<open>deltaG(TYPE('a)) \\<le> delta\\<close>"], ["proof (prove)\nusing this:\n  deltaG TYPE('a) \\<le> delta\n\ngoal (1 subgoal):\n 1. max (dist px py + dist y' x') (dist px x' + dist y' py) +\n    2 * deltaG TYPE('a)\n    \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) +\n          2 * delta", "by auto"], ["proof (state)\nthis:\n  max (dist px py + dist y' x') (dist px x' + dist y' py) +\n  2 * deltaG TYPE('a)\n  \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) + 2 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * M - 8 * delta + 2 * dist x' y'\n  \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) + 2 * delta", "have \"2 * M - 10 * delta + 2 * dist x' y' \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py)\""], ["proof (prove)\nusing this:\n  2 * M - 8 * delta + 2 * dist x' y'\n  \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py) + 2 * delta\n\ngoal (1 subgoal):\n 1. 2 * M - 10 * delta + 2 * dist x' y'\n    \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py)", "by auto"], ["proof (state)\nthis:\n  2 * M - 10 * delta + 2 * dist x' y'\n  \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py)\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "then"], ["proof (chain)\npicking this:\n  2 * M - 10 * delta + 2 * dist x' y'\n  \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py)", "have \"2 * M - 10 * delta + 2 * dist x' y' \\<le> dist px x' + dist py y'\""], ["proof (prove)\nusing this:\n  2 * M - 10 * delta + 2 * dist x' y'\n  \\<le> max (dist px py + dist y' x') (dist px x' + dist y' py)\n\ngoal (1 subgoal):\n 1. 2 * M - 10 * delta + 2 * dist x' y' \\<le> dist px x' + dist py y'", "apply (auto simp add: metric_space_class.dist_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * M - 10 * delta + 2 * dist x' y'\n    \\<le> max (dist px py + dist x' y')\n           (dist px x' + dist py y') \\<Longrightarrow>\n    2 * M - 10 * delta + 2 * dist x' y' \\<le> dist px x' + dist py y'", "using \\<open>0 \\<le> delta\\<close> \\<open>dist px py \\<le> 2 * M - 10 * delta\\<close> \\<open>dist px x' = M\\<close> \\<open>dist py y' = M\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> delta\n  dist px py \\<le> 2 * M - 10 * delta\n  dist px x' = M\n  dist py y' = M\n\ngoal (1 subgoal):\n 1. 2 * M - 10 * delta + 2 * dist x' y'\n    \\<le> max (dist px py + dist x' y')\n           (dist px x' + dist py y') \\<Longrightarrow>\n    2 * M - 10 * delta + 2 * dist x' y' \\<le> dist px x' + dist py y'", "by auto"], ["proof (state)\nthis:\n  2 * M - 10 * delta + 2 * dist x' y' \\<le> dist px x' + dist py y'\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "then"], ["proof (chain)\npicking this:\n  2 * M - 10 * delta + 2 * dist x' y' \\<le> dist px x' + dist py y'", "have \"dist x' y' \\<le> 5 * delta\""], ["proof (prove)\nusing this:\n  2 * M - 10 * delta + 2 * dist x' y' \\<le> dist px x' + dist py y'\n\ngoal (1 subgoal):\n 1. dist x' y' \\<le> 5 * delta", "unfolding \\<open>dist px x' = M\\<close> \\<open>dist py y' = M\\<close>"], ["proof (prove)\nusing this:\n  2 * M - 10 * delta + 2 * dist x' y' \\<le> M + M\n\ngoal (1 subgoal):\n 1. dist x' y' \\<le> 5 * delta", "by auto"], ["proof (state)\nthis:\n  dist x' y' \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "then"], ["proof (chain)\npicking this:\n  dist x' y' \\<le> 5 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  dist x' y' \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "unfolding x'_def y'_def"], ["proof (prove)\nusing this:\n  dist (geodesic_segment_param {px--x} px M)\n   (geodesic_segment_param {py--y} py M)\n  \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {px--x} px M)\n     (geodesic_segment_param {py--y} py M)\n    \\<le> 5 * delta", "by auto"], ["proof (state)\nthis:\n  dist (geodesic_segment_param {px--x} px M)\n   (geodesic_segment_param {py--y} py M)\n  \\<le> 5 * delta\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next lemma (Lemma 10 in~\\cite{shchur} for $C = 0$) asserts that the projection on a geodesic segment is\nan exponential contraction.\nMore precisely, if a path of length $L$ is at distance at least $D$ of a geodesic segment $G$,\nthen the projection of the path on $G$ has diameter at most $C L \\exp(-c D/\\delta)$, where $C$ and\n$c$ are universal constants. This is not completely true at one can not go below a fixed size, as\nalways, so the correct bound is $K \\max(\\delta, L \\exp(-c D/\\delta))$. For the application, we\ngive a slightly more general statement involving an additional constant $C$.\n\nThis statement follows from the previous lemma: if one moves towards $G$ by $10 \\delta$, then\nthe distance between points is divided by $2$. Then one iterates this statement as many times\nas possible, gaining a factor $2$ each time and therefore an exponential factor in the end.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) geodesic_projection_exp_contracting:\n  assumes \"geodesic_segment G\"\n          \"\\<And>x y. x \\<in> {a..b} \\<Longrightarrow> y \\<in> {a..b} \\<Longrightarrow> dist (f x) (f y) \\<le> lambda * dist x y + C\"\n          \"a \\<le> b\"\n          \"pa \\<in> proj_set (f a) G\"\n          \"pb \\<in> proj_set (f b) G\"\n          \"\\<And>t. t \\<in> {a..b} \\<Longrightarrow> infdist (f t) G \\<ge> D\"\n          \"D \\<ge> 15/2 * delta + C/2\"\n          \"delta > deltaG(TYPE('a))\"\n          \"C \\<ge> 0\"\n          \"lambda \\<ge> 0\"\n  shows \"dist pa pb \\<le> max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (b-a) * exp(-(D-C/2) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"delta > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < delta", "using assms"], ["proof (prove)\nusing this:\n  geodesic_segment G\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  a \\<le> b\n  pa \\<in> proj_set (f a) G\n  pb \\<in> proj_set (f b) G\n  ?t \\<in> {a..b} \\<Longrightarrow> D \\<le> infdist (f ?t) G\n  15 / 2 * delta + C / 2 \\<le> D\n  deltaG TYPE('a) < delta\n  0 \\<le> C\n  0 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 < delta", "using local.delta_nonneg"], ["proof (prove)\nusing this:\n  geodesic_segment G\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  a \\<le> b\n  pa \\<in> proj_set (f a) G\n  pb \\<in> proj_set (f b) G\n  ?t \\<in> {a..b} \\<Longrightarrow> D \\<le> infdist (f ?t) G\n  15 / 2 * delta + C / 2 \\<le> D\n  deltaG TYPE('a) < delta\n  0 \\<le> C\n  0 \\<le> lambda\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. 0 < delta", "by linarith"], ["proof (state)\nthis:\n  0 < delta\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"exp(15/2/5 * ln 2) = exp(ln 2) * exp(1/2 * ln (2::real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (15 / 2 / 5 * ln 2) = exp (ln 2) * exp (1 / 2 * ln 2)", "unfolding mult_exp_exp"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (15 / 2 / 5 * ln 2) = exp (ln 2 + 1 / 2 * ln 2)", "by simp"], ["proof (state)\nthis:\n  exp (15 / 2 / 5 * ln 2) = exp (ln 2) * exp (1 / 2 * ln 2)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  exp (15 / 2 / 5 * ln 2) = exp (ln 2) * exp (1 / 2 * ln 2)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... = 2 * exp(1/2 * ln 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (ln 2) * exp (1 / 2 * ln 2) = 2 * exp (1 / 2 * ln 2)", "by auto"], ["proof (state)\nthis:\n  exp (ln 2) * exp (1 / 2 * ln 2) = 2 * exp (1 / 2 * ln 2)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "finally"], ["proof (chain)\npicking this:\n  exp (15 / 2 / 5 * ln 2) = 2 * exp (1 / 2 * ln 2)", "have \"exp(15/2/5 * ln 2) = 2 * exp(1/2 * ln (2::real))\""], ["proof (prove)\nusing this:\n  exp (15 / 2 / 5 * ln 2) = 2 * exp (1 / 2 * ln 2)\n\ngoal (1 subgoal):\n 1. exp (15 / 2 / 5 * ln 2) = 2 * exp (1 / 2 * ln 2)", "by simp"], ["proof (state)\nthis:\n  exp (15 / 2 / 5 * ln 2) = 2 * exp (1 / 2 * ln 2)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "text \\<open>The idea of the proof is to start with a sequence of points separated by $10 \\delta + C$ along\n  the original path, and push them by a fixed distance towards $G$ to bring them at distance at most\n  $5 \\delta$, thanks to the previous lemma. Then, discard half the points, and start again. This\n  is possible while one is far enough from $G$. In the first step of the proof, we formalize this\n  in the case where the process can be iterated long enough that, at the end, the projections on $G$\n  are very close together. This is a simple induction, based on the previous lemma.\\<close>"], ["proof (state)\nthis:\n  exp (15 / 2 / 5 * ln 2) = 2 * exp (1 / 2 * ln 2)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have Main: \"\\<And>c g p. (\\<forall>i \\<in> {0..2^k}. p i \\<in> proj_set (g i) G)\n            \\<Longrightarrow> (\\<forall>i \\<in> {0..2^k}. dist (p i) (g i) \\<ge> 5 * delta * k + 15/2 * delta + c/2)\n            \\<Longrightarrow> (\\<forall>i \\<in> {0..<2^k}. dist (g i) (g (Suc i)) \\<le> 10 * delta + c)\n            \\<Longrightarrow> c \\<ge> 0\n            \\<Longrightarrow> dist (p 0) (p (2^k)) \\<le> 5 * deltaG(TYPE('a))\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c g p.\n       \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ k}.\n           5 * delta * real k + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ k)) \\<le> 5 * deltaG TYPE('a)", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c g p.\n       \\<lbrakk>\\<forall>i\\<in>{0..2 ^ 0}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ 0}.\n           5 * delta * real 0 + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ 0}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ 0)) \\<le> 5 * deltaG TYPE('a)\n 2. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "case 0"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..2 ^ 0}. p i \\<in> proj_set (g i) G\n  \\<forall>i\\<in>{0..2 ^ 0}.\n     5 * delta * real 0 + 15 / 2 * delta + c / 2 \\<le> dist (p i) (g i)\n  \\<forall>i\\<in>{0..<2 ^ 0}. dist (g i) (g (Suc i)) \\<le> 10 * delta + c\n  0 \\<le> c\n\ngoal (2 subgoals):\n 1. \\<And>c g p.\n       \\<lbrakk>\\<forall>i\\<in>{0..2 ^ 0}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ 0}.\n           5 * delta * real 0 + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ 0}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ 0)) \\<le> 5 * deltaG TYPE('a)\n 2. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{0..2 ^ 0}. p i \\<in> proj_set (g i) G\n  \\<forall>i\\<in>{0..2 ^ 0}.\n     5 * delta * real 0 + 15 / 2 * delta + c / 2 \\<le> dist (p i) (g i)\n  \\<forall>i\\<in>{0..<2 ^ 0}. dist (g i) (g (Suc i)) \\<le> 10 * delta + c\n  0 \\<le> c", "have H: \"p 0 \\<in> proj_set (g 0) G\"\n                 \"p 1 \\<in> proj_set (g 1) G\"\n                 \"dist (g 0) (g 1) \\<le> 10 * delta + c\"\n                 \"dist (p 0) (g 0) \\<ge> 15/2 * delta + c/2\"\n                 \"dist (p 1) (g 1) \\<ge> 15/2 * delta + c/2\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{0..2 ^ 0}. p i \\<in> proj_set (g i) G\n  \\<forall>i\\<in>{0..2 ^ 0}.\n     5 * delta * real 0 + 15 / 2 * delta + c / 2 \\<le> dist (p i) (g i)\n  \\<forall>i\\<in>{0..<2 ^ 0}. dist (g i) (g (Suc i)) \\<le> 10 * delta + c\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. (p 0 \\<in> proj_set (g 0) G &&& p 1 \\<in> proj_set (g 1) G) &&&\n    dist (g 0) (g 1) \\<le> 10 * delta + c &&&\n    15 / 2 * delta + c / 2 \\<le> dist (p 0) (g 0) &&&\n    15 / 2 * delta + c / 2 \\<le> dist (p 1) (g 1)", "by auto"], ["proof (state)\nthis:\n  p 0 \\<in> proj_set (g 0) G\n  p 1 \\<in> proj_set (g 1) G\n  dist (g 0) (g 1) \\<le> 10 * delta + c\n  15 / 2 * delta + c / 2 \\<le> dist (p 0) (g 0)\n  15 / 2 * delta + c / 2 \\<le> dist (p 1) (g 1)\n\ngoal (2 subgoals):\n 1. \\<And>c g p.\n       \\<lbrakk>\\<forall>i\\<in>{0..2 ^ 0}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ 0}.\n           5 * delta * real 0 + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ 0}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ 0)) \\<le> 5 * deltaG TYPE('a)\n 2. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "have \"dist (p 0) (p 1) \\<le> max (5 * deltaG(TYPE('a))) (dist (g 0) (g 1) - dist (p 0) (g 0) - dist (p 1) (g 1) + 10 * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p 0) (p 1)\n    \\<le> max (5 * deltaG TYPE('a))\n           (dist (g 0) (g 1) - dist (p 0) (g 0) - dist (p 1) (g 1) +\n            10 * deltaG TYPE('a))", "by (rule proj_along_geodesic_contraction[OF \\<open>geodesic_segment G\\<close> \\<open>p 0 \\<in> proj_set (g 0) G\\<close> \\<open>p 1 \\<in> proj_set (g 1) G\\<close>])"], ["proof (state)\nthis:\n  dist (p 0) (p 1)\n  \\<le> max (5 * deltaG TYPE('a))\n         (dist (g 0) (g 1) - dist (p 0) (g 0) - dist (p 1) (g 1) +\n          10 * deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. \\<And>c g p.\n       \\<lbrakk>\\<forall>i\\<in>{0..2 ^ 0}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ 0}.\n           5 * delta * real 0 + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ 0}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ 0)) \\<le> 5 * deltaG TYPE('a)\n 2. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  dist (p 0) (p 1)\n  \\<le> max (5 * deltaG TYPE('a))\n         (dist (g 0) (g 1) - dist (p 0) (g 0) - dist (p 1) (g 1) +\n          10 * deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. \\<And>c g p.\n       \\<lbrakk>\\<forall>i\\<in>{0..2 ^ 0}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ 0}.\n           5 * delta * real 0 + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ 0}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ 0)) \\<le> 5 * deltaG TYPE('a)\n 2. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "have \"... \\<le> max (5 * deltaG(TYPE('a))) (5 * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (5 * deltaG TYPE('a))\n     (dist (g 0) (g 1) - dist (p 0) (g 0) - dist (p 1) (g 1) +\n      10 * deltaG TYPE('a))\n    \\<le> max (5 * deltaG TYPE('a)) (5 * deltaG TYPE('a))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. deltaG TYPE('a) \\<le> deltaG TYPE('a)\n 2. 0 \\<le> 5\n 3. dist (g 0) (g 1) - dist (p 0) (g 0) - dist (p 1) (g 1) +\n    10 * deltaG TYPE('a)\n    \\<le> 5 * deltaG TYPE('a)", "using H \\<open>delta > deltaG(TYPE('a))\\<close>"], ["proof (prove)\nusing this:\n  p 0 \\<in> proj_set (g 0) G\n  p 1 \\<in> proj_set (g 1) G\n  dist (g 0) (g 1) \\<le> 10 * delta + c\n  15 / 2 * delta + c / 2 \\<le> dist (p 0) (g 0)\n  15 / 2 * delta + c / 2 \\<le> dist (p 1) (g 1)\n  deltaG TYPE('a) < delta\n\ngoal (3 subgoals):\n 1. deltaG TYPE('a) \\<le> deltaG TYPE('a)\n 2. 0 \\<le> 5\n 3. dist (g 0) (g 1) - dist (p 0) (g 0) - dist (p 1) (g 1) +\n    10 * deltaG TYPE('a)\n    \\<le> 5 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  max (5 * deltaG TYPE('a))\n   (dist (g 0) (g 1) - dist (p 0) (g 0) - dist (p 1) (g 1) +\n    10 * deltaG TYPE('a))\n  \\<le> max (5 * deltaG TYPE('a)) (5 * deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. \\<And>c g p.\n       \\<lbrakk>\\<forall>i\\<in>{0..2 ^ 0}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ 0}.\n           5 * delta * real 0 + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ 0}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ 0)) \\<le> 5 * deltaG TYPE('a)\n 2. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  dist (p 0) (p 1) \\<le> max (5 * deltaG TYPE('a)) (5 * deltaG TYPE('a))", "show \"dist (p 0) (p (2^0)) \\<le> 5 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  dist (p 0) (p 1) \\<le> max (5 * deltaG TYPE('a)) (5 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ 0)) \\<le> 5 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ 0)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}. ?p i \\<in> proj_set (?g i) G;\n   \\<forall>i\\<in>{0..2 ^ k}.\n      5 * delta * real k + 15 / 2 * delta + ?c / 2 \\<le> dist (?p i) (?g i);\n   \\<forall>i\\<in>{0..<2 ^ k}.\n      dist (?g i) (?g (Suc i)) \\<le> 10 * delta + ?c;\n   0 \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> dist (?p 0) (?p (2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n  \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G\n  \\<forall>i\\<in>{0..2 ^ Suc k}.\n     5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n     \\<le> dist (p i) (g i)\n  \\<forall>i\\<in>{0..<2 ^ Suc k}.\n     dist (g i) (g (Suc i)) \\<le> 10 * delta + c\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "have *: \"5 * delta * real (k + 1) + 5 * delta = 5 * delta * real (Suc k + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * real (k + 1) + 5 * delta = 5 * delta * real (Suc k + 1)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  5 * delta * real (k + 1) + 5 * delta = 5 * delta * real (Suc k + 1)\n\ngoal (1 subgoal):\n 1. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "define h where \"h = (\\<lambda>i. geodesic_segment_param {p i--g i} (p i) (5 * delta * k + 15/2 * delta))\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>i.\n      geodesic_segment_param {p i--g i} (p i)\n       (5 * delta * real k + 15 / 2 * delta))\n\ngoal (1 subgoal):\n 1. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "have h_dist: \"dist (h i) (h (Suc i)) \\<le> 5 * delta\" if \"i \\<in> {0..<2^(Suc k)}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (h i) (h (Suc i)) \\<le> 5 * delta", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist\n     (geodesic_segment_param {p i--g i} (p i)\n       (5 * delta * real k + 15 / 2 * delta))\n     (geodesic_segment_param {p (Suc i)--g (Suc i)} (p (Suc i))\n       (5 * delta * real k + 15 / 2 * delta))\n    \\<le> 5 * delta", "apply (rule geodesic_projection_exp_contracting_aux[OF \\<open>geodesic_segment G\\<close> _ _ less_imp_le[OF \\<open>delta > deltaG(TYPE('a))\\<close>]])"], ["proof (prove)\ngoal (7 subgoals):\n 1. p i \\<in> proj_set (g i) G\n 2. p (Suc i) \\<in> proj_set (g (Suc i)) G\n 3. dist (g i) (g (Suc i)) \\<le> 10 * delta + ?C\n 4. 15 / 2 * delta \\<le> 5 * delta * real k + 15 / 2 * delta\n 5. 5 * delta * real k + 15 / 2 * delta + 5 * delta + ?C / 2\n    \\<le> dist (p i) (g i)\n 6. 5 * delta * real k + 15 / 2 * delta + 5 * delta + ?C / 2\n    \\<le> dist (p (Suc i)) (g (Suc i))\n 7. 0 \\<le> ?C", "unfolding *"], ["proof (prove)\ngoal (7 subgoals):\n 1. p i \\<in> proj_set (g i) G\n 2. p (Suc i) \\<in> proj_set (g (Suc i)) G\n 3. dist (g i) (g (Suc i)) \\<le> 10 * delta + ?C\n 4. 15 / 2 * delta \\<le> 5 * delta * real k + 15 / 2 * delta\n 5. 5 * delta * real k + 15 / 2 * delta + 5 * delta + ?C / 2\n    \\<le> dist (p i) (g i)\n 6. 5 * delta * real k + 15 / 2 * delta + 5 * delta + ?C / 2\n    \\<le> dist (p (Suc i)) (g (Suc i))\n 7. 0 \\<le> ?C", "using Suc.prems that \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G\n  \\<forall>i\\<in>{0..2 ^ Suc k}.\n     5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n     \\<le> dist (p i) (g i)\n  \\<forall>i\\<in>{0..<2 ^ Suc k}.\n     dist (g i) (g (Suc i)) \\<le> 10 * delta + c\n  0 \\<le> c\n  i \\<in> {0..<2 ^ Suc k}\n  0 < delta\n\ngoal (7 subgoals):\n 1. p i \\<in> proj_set (g i) G\n 2. p (Suc i) \\<in> proj_set (g (Suc i)) G\n 3. dist (g i) (g (Suc i)) \\<le> 10 * delta + ?C\n 4. 15 / 2 * delta \\<le> 5 * delta * real k + 15 / 2 * delta\n 5. 5 * delta * real k + 15 / 2 * delta + 5 * delta + ?C / 2\n    \\<le> dist (p i) (g i)\n 6. 5 * delta * real k + 15 / 2 * delta + 5 * delta + ?C / 2\n    \\<le> dist (p (Suc i)) (g (Suc i))\n 7. 0 \\<le> ?C", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  ?i \\<in> {0..<2 ^ Suc k} \\<Longrightarrow>\n  dist (h ?i) (h (Suc ?i)) \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "define g' where \"g' = (\\<lambda>i. h (2 * i))\""], ["proof (state)\nthis:\n  g' = (\\<lambda>i. h (2 * i))\n\ngoal (1 subgoal):\n 1. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "define p' where \"p' = (\\<lambda>i. p (2 * i))\""], ["proof (state)\nthis:\n  p' = (\\<lambda>i. p (2 * i))\n\ngoal (1 subgoal):\n 1. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "have \"dist (p' 0) (p' (2^k)) \\<le> 5 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p' 0) (p' (2 ^ k)) \\<le> 5 * deltaG TYPE('a)", "proof (rule Suc.IH[where ?g = g' and ?c = 0])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>i\\<in>{0..2 ^ k}. p' i \\<in> proj_set (g' i) G\n 2. \\<forall>i\\<in>{0..2 ^ k}.\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)\n 3. \\<forall>i\\<in>{0..<2 ^ k}.\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0\n 4. 0 \\<le> 0", "show \"\\<forall>i\\<in>{0..2 ^ k}. p' i \\<in> proj_set (g' i) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..2 ^ k}. p' i \\<in> proj_set (g' i) G", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow> p' i \\<in> proj_set (g' i) G", "fix i::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow> p' i \\<in> proj_set (g' i) G", "assume \"i \\<in> {0..2^k}\""], ["proof (state)\nthis:\n  i \\<in> {0..2 ^ k}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow> p' i \\<in> proj_set (g' i) G", "then"], ["proof (chain)\npicking this:\n  i \\<in> {0..2 ^ k}", "have *: \"2 * i \\<in> {0..2^(Suc k)}\""], ["proof (prove)\nusing this:\n  i \\<in> {0..2 ^ k}\n\ngoal (1 subgoal):\n 1. 2 * i \\<in> {0..2 ^ Suc k}", "by auto"], ["proof (state)\nthis:\n  2 * i \\<in> {0..2 ^ Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow> p' i \\<in> proj_set (g' i) G", "show \"p' i \\<in> proj_set (g' i) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' i \\<in> proj_set (g' i) G", "unfolding p'_def g'_def h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p (2 * i)\n    \\<in> proj_set\n           (geodesic_segment_param {p (2 * i)--g (2 * i)} (p (2 * i))\n             (5 * delta * real k + 15 / 2 * delta))\n           G", "apply (rule proj_set_geodesic_same_basepoint[of _ \"g (2 * i)\" _ \"{p(2 * i)--g(2 * i)}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. p (2 * i) \\<in> proj_set (g (2 * i)) G\n 2. geodesic_segment_between {p (2 * i)--g (2 * i)} (p (2 * i)) (g (2 * i))\n 3. geodesic_segment_param {p (2 * i)--g (2 * i)} (p (2 * i))\n     (5 * delta * real k + 15 / 2 * delta)\n    \\<in> {p (2 * i)--g (2 * i)}", "using Suc *"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}. ?p i \\<in> proj_set (?g i) G;\n   \\<forall>i\\<in>{0..2 ^ k}.\n      5 * delta * real k + 15 / 2 * delta + ?c / 2 \\<le> dist (?p i) (?g i);\n   \\<forall>i\\<in>{0..<2 ^ k}.\n      dist (?g i) (?g (Suc i)) \\<le> 10 * delta + ?c;\n   0 \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> dist (?p 0) (?p (2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n  \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G\n  \\<forall>i\\<in>{0..2 ^ Suc k}.\n     5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n     \\<le> dist (p i) (g i)\n  \\<forall>i\\<in>{0..<2 ^ Suc k}.\n     dist (g i) (g (Suc i)) \\<le> 10 * delta + c\n  0 \\<le> c\n  2 * i \\<in> {0..2 ^ Suc k}\n\ngoal (3 subgoals):\n 1. p (2 * i) \\<in> proj_set (g (2 * i)) G\n 2. geodesic_segment_between {p (2 * i)--g (2 * i)} (p (2 * i)) (g (2 * i))\n 3. geodesic_segment_param {p (2 * i)--g (2 * i)} (p (2 * i))\n     (5 * delta * real k + 15 / 2 * delta)\n    \\<in> {p (2 * i)--g (2 * i)}", "by (auto simp add: geodesic_segment_param_in_segment)"], ["proof (state)\nthis:\n  p' i \\<in> proj_set (g' i) G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..2 ^ k}. p' i \\<in> proj_set (g' i) G\n\ngoal (3 subgoals):\n 1. \\<forall>i\\<in>{0..2 ^ k}.\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)\n 2. \\<forall>i\\<in>{0..<2 ^ k}.\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0\n 3. 0 \\<le> 0", "show \"\\<forall>i\\<in>{0..2 ^ k}. 5 * delta * k + 15/2 * delta + 0/2 \\<le> dist (p' i) (g' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..2 ^ k}.\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow>\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "fix i::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow>\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "assume \"i \\<in> {0..2^k}\""], ["proof (state)\nthis:\n  i \\<in> {0..2 ^ k}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow>\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "then"], ["proof (chain)\npicking this:\n  i \\<in> {0..2 ^ k}", "have *: \"2 * i \\<in> {0..2^(Suc k)}\""], ["proof (prove)\nusing this:\n  i \\<in> {0..2 ^ k}\n\ngoal (1 subgoal):\n 1. 2 * i \\<in> {0..2 ^ Suc k}", "by auto"], ["proof (state)\nthis:\n  2 * i \\<in> {0..2 ^ Suc k}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow>\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "have \"5 * delta * k + 15/2 * delta \\<le> 5 * delta * Suc k + 15/2 * delta + c/2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta\n    \\<le> 5 * delta * real (Suc k) + 15 / 2 * delta + c / 2", "using \\<open>delta > 0\\<close> \\<open>c \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n  0 \\<le> c\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta\n    \\<le> 5 * delta * real (Suc k) + 15 / 2 * delta + c / 2", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta\n  \\<le> 5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow>\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "also"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta\n  \\<le> 5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow>\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "have \"... \\<le> dist (p (2 * i)) (g (2 * i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n    \\<le> dist (p (2 * i)) (g (2 * i))", "using Suc *"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}. ?p i \\<in> proj_set (?g i) G;\n   \\<forall>i\\<in>{0..2 ^ k}.\n      5 * delta * real k + 15 / 2 * delta + ?c / 2 \\<le> dist (?p i) (?g i);\n   \\<forall>i\\<in>{0..<2 ^ k}.\n      dist (?g i) (?g (Suc i)) \\<le> 10 * delta + ?c;\n   0 \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> dist (?p 0) (?p (2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n  \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G\n  \\<forall>i\\<in>{0..2 ^ Suc k}.\n     5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n     \\<le> dist (p i) (g i)\n  \\<forall>i\\<in>{0..<2 ^ Suc k}.\n     dist (g i) (g (Suc i)) \\<le> 10 * delta + c\n  0 \\<le> c\n  2 * i \\<in> {0..2 ^ Suc k}\n\ngoal (1 subgoal):\n 1. 5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n    \\<le> dist (p (2 * i)) (g (2 * i))", "by auto"], ["proof (state)\nthis:\n  5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n  \\<le> dist (p (2 * i)) (g (2 * i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow>\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "finally"], ["proof (chain)\npicking this:\n  5 * delta * real k + 15 / 2 * delta \\<le> dist (p (2 * i)) (g (2 * i))", "have *: \"5 * delta * k + 15/2 * delta \\<le> dist (p (2 * i)) (g (2 * i))\""], ["proof (prove)\nusing this:\n  5 * delta * real k + 15 / 2 * delta \\<le> dist (p (2 * i)) (g (2 * i))\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta \\<le> dist (p (2 * i)) (g (2 * i))", "by simp"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta \\<le> dist (p (2 * i)) (g (2 * i))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow>\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "have \"dist (p' i) (g' i) = 5 * delta * k + 15/2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p' i) (g' i) = 5 * delta * real k + 15 / 2 * delta", "unfolding p'_def g'_def h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p (2 * i))\n     (geodesic_segment_param {p (2 * i)--g (2 * i)} (p (2 * i))\n       (5 * delta * real k + 15 / 2 * delta)) =\n    5 * delta * real k + 15 / 2 * delta", "apply (rule geodesic_segment_param_in_geodesic_spaces(6))"], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta\n    \\<in> {0..dist (p (2 * i)) (g (2 * i))}", "using * \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  5 * delta * real k + 15 / 2 * delta \\<le> dist (p (2 * i)) (g (2 * i))\n  0 < delta\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta\n    \\<in> {0..dist (p (2 * i)) (g (2 * i))}", "by auto"], ["proof (state)\nthis:\n  dist (p' i) (g' i) = 5 * delta * real k + 15 / 2 * delta\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..2 ^ k} \\<Longrightarrow>\n       5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "then"], ["proof (chain)\npicking this:\n  dist (p' i) (g' i) = 5 * delta * real k + 15 / 2 * delta", "show \"5 * delta * k + 15/2 * delta + 0/2 \\<le> dist (p' i) (g' i)\""], ["proof (prove)\nusing this:\n  dist (p' i) (g' i) = 5 * delta * real k + 15 / 2 * delta\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)", "by simp"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..2 ^ k}.\n     5 * delta * real k + 15 / 2 * delta + 0 / 2 \\<le> dist (p' i) (g' i)\n\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>{0..<2 ^ k}.\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0\n 2. 0 \\<le> 0", "show \"\\<forall>i\\<in>{0..<2 ^ k}. dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{0..<2 ^ k}.\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "fix i::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "assume *: \"i \\<in> {0..<2 ^ k}\""], ["proof (state)\nthis:\n  i \\<in> {0..<2 ^ k}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "have \"dist (g' i) (g' (Suc i)) = dist (h (2 * i)) (h (Suc (Suc (2 * i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (g' i) (g' (Suc i)) = dist (h (2 * i)) (h (Suc (Suc (2 * i))))", "unfolding g'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (h (2 * i)) (h (2 * Suc i)) =\n    dist (h (2 * i)) (h (Suc (Suc (2 * i))))", "by auto"], ["proof (state)\nthis:\n  dist (g' i) (g' (Suc i)) = dist (h (2 * i)) (h (Suc (Suc (2 * i))))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "also"], ["proof (state)\nthis:\n  dist (g' i) (g' (Suc i)) = dist (h (2 * i)) (h (Suc (Suc (2 * i))))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "have \"... \\<le> dist (h (2 * i)) (h (Suc (2 * i))) + dist (h (Suc (2 * i))) (h (Suc (Suc (2 * i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (h (2 * i)) (h (Suc (Suc (2 * i))))\n    \\<le> dist (h (2 * i)) (h (Suc (2 * i))) +\n          dist (h (Suc (2 * i))) (h (Suc (Suc (2 * i))))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (h (2 * i)) (h (Suc (Suc (2 * i))))\n  \\<le> dist (h (2 * i)) (h (Suc (2 * i))) +\n        dist (h (Suc (2 * i))) (h (Suc (Suc (2 * i))))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "also"], ["proof (state)\nthis:\n  dist (h (2 * i)) (h (Suc (Suc (2 * i))))\n  \\<le> dist (h (2 * i)) (h (Suc (2 * i))) +\n        dist (h (Suc (2 * i))) (h (Suc (Suc (2 * i))))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "have \"... \\<le> 5 * delta + 5 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (h (2 * i)) (h (Suc (2 * i))) +\n    dist (h (Suc (2 * i))) (h (Suc (Suc (2 * i))))\n    \\<le> 5 * delta + 5 * delta", "apply (intro mono_intros h_dist)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 2 * i \\<in> {0..<2 ^ Suc k}\n 2. Suc (2 * i) \\<in> {0..<2 ^ Suc k}", "using *"], ["proof (prove)\nusing this:\n  i \\<in> {0..<2 ^ k}\n\ngoal (2 subgoals):\n 1. 2 * i \\<in> {0..<2 ^ Suc k}\n 2. Suc (2 * i) \\<in> {0..<2 ^ Suc k}", "by auto"], ["proof (state)\nthis:\n  dist (h (2 * i)) (h (Suc (2 * i))) +\n  dist (h (Suc (2 * i))) (h (Suc (Suc (2 * i))))\n  \\<le> 5 * delta + 5 * delta\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "finally"], ["proof (chain)\npicking this:\n  dist (g' i) (g' (Suc i)) \\<le> 5 * delta + 5 * delta", "show \"dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0\""], ["proof (prove)\nusing this:\n  dist (g' i) (g' (Suc i)) \\<le> 5 * delta + 5 * delta\n\ngoal (1 subgoal):\n 1. dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0", "by simp"], ["proof (state)\nthis:\n  dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..<2 ^ k}. dist (g' i) (g' (Suc i)) \\<le> 10 * delta + 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> 0", "qed (simp)"], ["proof (state)\nthis:\n  dist (p' 0) (p' (2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>k c g p.\n       \\<lbrakk>\\<And>c g p.\n                   \\<lbrakk>\\<forall>i\\<in>{0..2 ^ k}.\n                               p i \\<in> proj_set (g i) G;\n                    \\<forall>i\\<in>{0..2 ^ k}.\n                       5 * delta * real k + 15 / 2 * delta + c / 2\n                       \\<le> dist (p i) (g i);\n                    \\<forall>i\\<in>{0..<2 ^ k}.\n                       dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n                    0 \\<le> c\\<rbrakk>\n                   \\<Longrightarrow> dist (p 0) (p (2 ^ k))\n                                     \\<le> 5 * deltaG TYPE('a);\n        \\<forall>i\\<in>{0..2 ^ Suc k}. p i \\<in> proj_set (g i) G;\n        \\<forall>i\\<in>{0..2 ^ Suc k}.\n           5 * delta * real (Suc k) + 15 / 2 * delta + c / 2\n           \\<le> dist (p i) (g i);\n        \\<forall>i\\<in>{0..<2 ^ Suc k}.\n           dist (g i) (g (Suc i)) \\<le> 10 * delta + c;\n        0 \\<le> c\\<rbrakk>\n       \\<Longrightarrow> dist (p 0) (p (2 ^ Suc k))\n                         \\<le> 5 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  dist (p' 0) (p' (2 ^ k)) \\<le> 5 * deltaG TYPE('a)", "show \"dist (p 0) (p (2 ^ Suc k)) \\<le> 5 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  dist (p' 0) (p' (2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ Suc k)) \\<le> 5 * deltaG TYPE('a)", "unfolding p'_def"], ["proof (prove)\nusing this:\n  dist (p (2 * 0)) (p (2 * 2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ Suc k)) \\<le> 5 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ Suc k)) \\<le> 5 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i\\<in>{0..2 ^ ?k1}. ?p i \\<in> proj_set (?g i) G;\n   \\<forall>i\\<in>{0..2 ^ ?k1}.\n      5 * delta * real ?k1 + 15 / 2 * delta + ?c / 2\n      \\<le> dist (?p i) (?g i);\n   \\<forall>i\\<in>{0..<2 ^ ?k1}.\n      dist (?g i) (?g (Suc i)) \\<le> 10 * delta + ?c;\n   0 \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> dist (?p 0) (?p (2 ^ ?k1)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "text \\<open>Now, we will apply the previous basic statement to points along our original path. We\n  introduce $k$, the number of steps for which the pushing process can be done -- it only depends on\n  the original distance $D$ to $G$. \\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i\\<in>{0..2 ^ ?k1}. ?p i \\<in> proj_set (?g i) G;\n   \\<forall>i\\<in>{0..2 ^ ?k1}.\n      5 * delta * real ?k1 + 15 / 2 * delta + ?c / 2\n      \\<le> dist (?p i) (?g i);\n   \\<forall>i\\<in>{0..<2 ^ ?k1}.\n      dist (?g i) (?g (Suc i)) \\<le> 10 * delta + ?c;\n   0 \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> dist (?p 0) (?p (2 ^ ?k1)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "define k where \"k = nat(floor((D - C/2 - 15/2 * delta)/(5 * delta)))\""], ["proof (state)\nthis:\n  k = nat \\<lfloor>(D - C / 2 - 15 / 2 * delta) / (5 * delta)\\<rfloor>\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"int k = floor((D - C/2 - 15/2 * delta)/(5 * delta))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int k = \\<lfloor>(D - C / 2 - 15 / 2 * delta) / (5 * delta)\\<rfloor>", "unfolding k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat \\<lfloor>(D - C / 2 - 15 / 2 * delta) / (5 * delta)\\<rfloor>) =\n    \\<lfloor>(D - C / 2 - 15 / 2 * delta) / (5 * delta)\\<rfloor>", "apply (rule nat_0_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lfloor>(D - C / 2 - 15 / 2 * delta) / (5 * delta)\\<rfloor>", "using \\<open>D \\<ge> 15/2 * delta + C/2\\<close> \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  15 / 2 * delta + C / 2 \\<le> D\n  0 < delta\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lfloor>(D - C / 2 - 15 / 2 * delta) / (5 * delta)\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  int k = \\<lfloor>(D - C / 2 - 15 / 2 * delta) / (5 * delta)\\<rfloor>\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  int k = \\<lfloor>(D - C / 2 - 15 / 2 * delta) / (5 * delta)\\<rfloor>", "have \"k \\<le> (D - C/2 - 15/2 * delta)/(5 * delta)\" \"(D - C/2 - 15/2 * delta)/(5 * delta) \\<le> k + 1\""], ["proof (prove)\nusing this:\n  int k = \\<lfloor>(D - C / 2 - 15 / 2 * delta) / (5 * delta)\\<rfloor>\n\ngoal (1 subgoal):\n 1. real k \\<le> (D - C / 2 - 15 / 2 * delta) / (5 * delta) &&&\n    (D - C / 2 - 15 / 2 * delta) / (5 * delta) \\<le> real (k + 1)", "by linarith+"], ["proof (state)\nthis:\n  real k \\<le> (D - C / 2 - 15 / 2 * delta) / (5 * delta)\n  (D - C / 2 - 15 / 2 * delta) / (5 * delta) \\<le> real (k + 1)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  real k \\<le> (D - C / 2 - 15 / 2 * delta) / (5 * delta)\n  (D - C / 2 - 15 / 2 * delta) / (5 * delta) \\<le> real (k + 1)", "have k: \"D \\<ge> 5 * delta * k + 15/2 * delta + C/2\" \"D \\<le> 5 * delta * (k+1) + 15/2 * delta + C/2\""], ["proof (prove)\nusing this:\n  real k \\<le> (D - C / 2 - 15 / 2 * delta) / (5 * delta)\n  (D - C / 2 - 15 / 2 * delta) / (5 * delta) \\<le> real (k + 1)\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D &&&\n    D \\<le> 5 * delta * real (k + 1) + 15 / 2 * delta + C / 2", "using \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  real k \\<le> (D - C / 2 - 15 / 2 * delta) / (5 * delta)\n  (D - C / 2 - 15 / 2 * delta) / (5 * delta) \\<le> real (k + 1)\n  0 < delta\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D &&&\n    D \\<le> 5 * delta * real (k + 1) + 15 / 2 * delta + C / 2", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D\n  D \\<le> 5 * delta * real (k + 1) + 15 / 2 * delta + C / 2\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"exp((D-C/2)/(5 * delta) * ln 2) * exp(-15/2/5 * ln 2) = exp(((D-C/2-15/2 * delta)/(5 * delta)) * ln 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp ((D - C / 2) / (5 * delta) * ln 2) * exp (- 15 / 2 / 5 * ln 2) =\n    exp ((D - C / 2 - 15 / 2 * delta) / (5 * delta) * ln 2)", "unfolding mult_exp_exp"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp ((D - C / 2) / (5 * delta) * ln 2 + - 15 / 2 / 5 * ln 2) =\n    exp ((D - C / 2 - 15 / 2 * delta) / (5 * delta) * ln 2)", "using \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n\ngoal (1 subgoal):\n 1. exp ((D - C / 2) / (5 * delta) * ln 2 + - 15 / 2 / 5 * ln 2) =\n    exp ((D - C / 2 - 15 / 2 * delta) / (5 * delta) * ln 2)", "by (simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  exp ((D - C / 2) / (5 * delta) * ln 2) * exp (- 15 / 2 / 5 * ln 2) =\n  exp ((D - C / 2 - 15 / 2 * delta) / (5 * delta) * ln 2)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  exp ((D - C / 2) / (5 * delta) * ln 2) * exp (- 15 / 2 / 5 * ln 2) =\n  exp ((D - C / 2 - 15 / 2 * delta) / (5 * delta) * ln 2)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... \\<le> exp((k+1) * ln 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp ((D - C / 2 - 15 / 2 * delta) / (5 * delta) * ln 2)\n    \\<le> exp (real (k + 1) * ln 2)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (D - C / 2 - 15 / 2 * delta) / (5 * delta) \\<le> real (k + 1)\n 2. 1 \\<le> 2", "using k(2) \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  D \\<le> 5 * delta * real (k + 1) + 15 / 2 * delta + C / 2\n  0 < delta\n\ngoal (2 subgoals):\n 1. (D - C / 2 - 15 / 2 * delta) / (5 * delta) \\<le> real (k + 1)\n 2. 1 \\<le> 2", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  exp ((D - C / 2 - 15 / 2 * delta) / (5 * delta) * ln 2)\n  \\<le> exp (real (k + 1) * ln 2)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  exp ((D - C / 2 - 15 / 2 * delta) / (5 * delta) * ln 2)\n  \\<le> exp (real (k + 1) * ln 2)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... = 2^(k+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (real (k + 1) * ln 2) = 2 ^ (k + 1)", "by (subst powr_realpow[symmetric], auto simp add: powr_def)"], ["proof (state)\nthis:\n  exp (real (k + 1) * ln 2) = 2 ^ (k + 1)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  exp (real (k + 1) * ln 2) = 2 ^ (k + 1)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... = 2 * 2^k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (k + 1) = 2 * 2 ^ k", "by auto"], ["proof (state)\nthis:\n  2 ^ (k + 1) = 2 * 2 ^ k\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "finally"], ["proof (chain)\npicking this:\n  exp ((D - C / 2) / (5 * delta) * ln 2) * exp (- 15 / 2 / 5 * ln 2)\n  \\<le> 2 * 2 ^ k", "have k': \"1/2^k \\<le> 2 * exp(15/2/5 * ln 2) * exp(- ((D-C/2) * ln 2 / (5 * delta)))\""], ["proof (prove)\nusing this:\n  exp ((D - C / 2) / (5 * delta) * ln 2) * exp (- 15 / 2 / 5 * ln 2)\n  \\<le> 2 * 2 ^ k\n\ngoal (1 subgoal):\n 1. 1 / 2 ^ k\n    \\<le> 2 * exp (15 / 2 / 5 * ln 2) *\n          exp (- ((D - C / 2) * ln 2 / (5 * delta)))", "by (auto simp add: algebra_simps divide_simps exp_minus)"], ["proof (state)\nthis:\n  1 / 2 ^ k\n  \\<le> 2 * exp (15 / 2 / 5 * ln 2) *\n        exp (- ((D - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "text \\<open>We separate the proof into two cases. If the path is not too long, then it can be covered by\n  $2^k$ points at distance at most $10 \\delta + C$. By the basic statement, it follows that the diameter\n  of the projection is at most $5 \\delta$. Otherwise, we subdivide the path into $2^N$ points at\n  distance at most $10 \\delta + C$, with $N \\geq k$, and apply the basic statement to blocks of $2^k$\n  consecutive points. It follows that the projections of $g_0, g_{2^k}, g_{2\\cdot 2^k},\\dotsc$ are\n  at distances at most $5 \\delta$. Hence, the first and last projections are at distance at most\n  $2^{N-k} \\cdot 5 \\delta$, which is the desired bound.\\<close>"], ["proof (state)\nthis:\n  1 / 2 ^ k\n  \\<le> 2 * exp (15 / 2 / 5 * ln 2) *\n        exp (- ((D - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "proof (cases \"lambda * (b-a) \\<le> 10 * delta * 2^k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "text \\<open>First, treat the case where the path is rather short.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "case True"], ["proof (state)\nthis:\n  lambda * (b - a) \\<le> 10 * delta * 2 ^ k\n\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "define g::\"nat \\<Rightarrow> 'a\" where \"g = (\\<lambda>i. f(a + (b-a) * i/2^k))\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. f (a + (b - a) * real x / 2 ^ k))\n\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"g 0 = f a\" \"g(2^k) = f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g 0 = f a &&& g (2 ^ k) = f b", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (a + (b - a) * real 0 / 2 ^ k) = f a &&&\n    f (a + (b - a) * real (2 ^ k) / 2 ^ k) = f b", "by auto"], ["proof (state)\nthis:\n  g 0 = f a\n  g (2 ^ k) = f b\n\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have *: \"a + (b-a) * i/2^k \\<in> {a..b}\" if \"i \\<in> {0..2^k}\" for i::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ k \\<in> {a..b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ k \\<in> {a..b}", "have \"a + (b - a) * (real i / 2 ^ k) \\<le> a + (b-a) * (2^k/2^k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (b - a) * (real i / 2 ^ k) \\<le> a + (b - a) * (2 ^ k / 2 ^ k)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. real i \\<le> 2 ^ k\n 2. 0 \\<le> 2 ^ k\n 3. 0 \\<le> b - a", "using that \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  i \\<in> {0..2 ^ k}\n  a \\<le> b\n\ngoal (3 subgoals):\n 1. real i \\<le> 2 ^ k\n 2. 0 \\<le> 2 ^ k\n 3. 0 \\<le> b - a", "by auto"], ["proof (state)\nthis:\n  a + (b - a) * (real i / 2 ^ k) \\<le> a + (b - a) * (2 ^ k / 2 ^ k)\n\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ k \\<in> {a..b}", "then"], ["proof (chain)\npicking this:\n  a + (b - a) * (real i / 2 ^ k) \\<le> a + (b - a) * (2 ^ k / 2 ^ k)", "show ?thesis"], ["proof (prove)\nusing this:\n  a + (b - a) * (real i / 2 ^ k) \\<le> a + (b - a) * (2 ^ k / 2 ^ k)\n\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ k \\<in> {a..b}", "using \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a + (b - a) * (real i / 2 ^ k) \\<le> a + (b - a) * (2 ^ k / 2 ^ k)\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ k \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  a + (b - a) * real i / 2 ^ k \\<in> {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..2 ^ k} \\<Longrightarrow>\n  a + (b - a) * real ?i / 2 ^ k \\<in> {a..b}\n\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have A: \"dist (g i) (g (Suc i)) \\<le> 10 * delta + C\" if \"i \\<in> {0..<2^k}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "have \"dist (g i) (g (Suc i)) \\<le> lambda * dist (a + (b-a) * i/2^k) (a + (b-a) * (Suc i)/2^k) + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i))\n    \\<le> lambda *\n          dist (a + (b - a) * real i / 2 ^ k)\n           (a + (b - a) * real (Suc i) / 2 ^ k) +\n          C", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f (a + (b - a) * real i / 2 ^ k))\n     (f (a + (b - a) * real (Suc i) / 2 ^ k))\n    \\<le> lambda *\n          dist (a + (b - a) * real i / 2 ^ k)\n           (a + (b - a) * real (Suc i) / 2 ^ k) +\n          C", "apply (intro assms(2) *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i \\<in> {0..2 ^ k}\n 2. Suc i \\<in> {0..2 ^ k}", "using that"], ["proof (prove)\nusing this:\n  i \\<in> {0..<2 ^ k}\n\ngoal (2 subgoals):\n 1. i \\<in> {0..2 ^ k}\n 2. Suc i \\<in> {0..2 ^ k}", "by auto"], ["proof (state)\nthis:\n  dist (g i) (g (Suc i))\n  \\<le> lambda *\n        dist (a + (b - a) * real i / 2 ^ k)\n         (a + (b - a) * real (Suc i) / 2 ^ k) +\n        C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "also"], ["proof (state)\nthis:\n  dist (g i) (g (Suc i))\n  \\<le> lambda *\n        dist (a + (b - a) * real i / 2 ^ k)\n         (a + (b - a) * real (Suc i) / 2 ^ k) +\n        C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "have \"... = lambda * (b-a)/2^k + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    dist (a + (b - a) * real i / 2 ^ k)\n     (a + (b - a) * real (Suc i) / 2 ^ k) +\n    C =\n    lambda * (b - a) / 2 ^ k + C", "unfolding dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    \\<bar>a + (b - a) * real i / 2 ^ k -\n          (a + (b - a) * real (Suc i) / 2 ^ k)\\<bar> +\n    C =\n    lambda * (b - a) / 2 ^ k + C", "using \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. lambda *\n    \\<bar>a + (b - a) * real i / 2 ^ k -\n          (a + (b - a) * real (Suc i) / 2 ^ k)\\<bar> +\n    C =\n    lambda * (b - a) / 2 ^ k + C", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  lambda *\n  dist (a + (b - a) * real i / 2 ^ k) (a + (b - a) * real (Suc i) / 2 ^ k) +\n  C =\n  lambda * (b - a) / 2 ^ k + C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "also"], ["proof (state)\nthis:\n  lambda *\n  dist (a + (b - a) * real i / 2 ^ k) (a + (b - a) * real (Suc i) / 2 ^ k) +\n  C =\n  lambda * (b - a) / 2 ^ k + C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "have \"... \\<le> 10 * delta + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (b - a) / 2 ^ k + C \\<le> 10 * delta + C", "using True"], ["proof (prove)\nusing this:\n  lambda * (b - a) \\<le> 10 * delta * 2 ^ k\n\ngoal (1 subgoal):\n 1. lambda * (b - a) / 2 ^ k + C \\<le> 10 * delta + C", "by (simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  lambda * (b - a) / 2 ^ k + C \\<le> 10 * delta + C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "finally"], ["proof (chain)\npicking this:\n  dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (g i) (g (Suc i)) \\<le> 10 * delta + C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "by simp"], ["proof (state)\nthis:\n  dist (g i) (g (Suc i)) \\<le> 10 * delta + C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n  dist (g ?i) (g (Suc ?i)) \\<le> 10 * delta + C\n\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "define p where \"p = (\\<lambda>i. if i = 0 then pa else if i = 2^k then pb else SOME p. p \\<in> proj_set (g i) G)\""], ["proof (state)\nthis:\n  p =\n  (\\<lambda>i.\n      if i = 0 then pa\n      else if i = 2 ^ k then pb else SOME p. p \\<in> proj_set (g i) G)\n\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have B: \"p i \\<in> proj_set (g i) G\" if \"i \\<in> {0..2^k}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "proof (cases \"i = 0 \\<or> i = 2^k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<or> i = 2 ^ k \\<Longrightarrow> p i \\<in> proj_set (g i) G\n 2. \\<not> (i = 0 \\<or> i = 2 ^ k) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "case True"], ["proof (state)\nthis:\n  i = 0 \\<or> i = 2 ^ k\n\ngoal (2 subgoals):\n 1. i = 0 \\<or> i = 2 ^ k \\<Longrightarrow> p i \\<in> proj_set (g i) G\n 2. \\<not> (i = 0 \\<or> i = 2 ^ k) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "then"], ["proof (chain)\npicking this:\n  i = 0 \\<or> i = 2 ^ k", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0 \\<or> i = 2 ^ k\n\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "using \\<open>pa \\<in> proj_set (f a) G\\<close> \\<open>pb \\<in> proj_set (f b) G\\<close>"], ["proof (prove)\nusing this:\n  i = 0 \\<or> i = 2 ^ k\n  pa \\<in> proj_set (f a) G\n  pb \\<in> proj_set (f b) G\n\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "unfolding p_def g_def"], ["proof (prove)\nusing this:\n  i = 0 \\<or> i = 2 ^ k\n  pa \\<in> proj_set (f a) G\n  pb \\<in> proj_set (f b) G\n\ngoal (1 subgoal):\n 1. (if i = 0 then pa\n     else if i = 2 ^ k then pb\n          else SOME p.\n                  p \\<in> proj_set (f (a + (b - a) * real i / 2 ^ k)) G)\n    \\<in> proj_set (f (a + (b - a) * real i / 2 ^ k)) G", "by auto"], ["proof (state)\nthis:\n  p i \\<in> proj_set (g i) G\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ k) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ k) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "case False"], ["proof (state)\nthis:\n  \\<not> (i = 0 \\<or> i = 2 ^ k)\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ k) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "then"], ["proof (chain)\npicking this:\n  \\<not> (i = 0 \\<or> i = 2 ^ k)", "have \"p i = (SOME p. p \\<in> proj_set (g i) G)\""], ["proof (prove)\nusing this:\n  \\<not> (i = 0 \\<or> i = 2 ^ k)\n\ngoal (1 subgoal):\n 1. p i = (SOME p. p \\<in> proj_set (g i) G)", "unfolding p_def"], ["proof (prove)\nusing this:\n  \\<not> (i = 0 \\<or> i = 2 ^ k)\n\ngoal (1 subgoal):\n 1. (if i = 0 then pa\n     else if i = 2 ^ k then pb else SOME p. p \\<in> proj_set (g i) G) =\n    (SOME p. p \\<in> proj_set (g i) G)", "by auto"], ["proof (state)\nthis:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ k) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "moreover"], ["proof (state)\nthis:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ k) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "have \"proj_set (g i) G \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_set (g i) G \\<noteq> {}", "apply (rule proj_set_nonempty_of_proper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper G\n 2. G \\<noteq> {}", "using geodesic_segment_topology[OF \\<open>geodesic_segment G\\<close>]"], ["proof (prove)\nusing this:\n  compact G\n  connected G\n  path_connected G\n  bounded G\n  closed G\n  G \\<noteq> {}\n  proper G\n\ngoal (2 subgoals):\n 1. proper G\n 2. G \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  proj_set (g i) G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ k) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "ultimately"], ["proof (chain)\npicking this:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n  proj_set (g i) G \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n  proj_set (g i) G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "using some_in_eq"], ["proof (prove)\nusing this:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n  proj_set (g i) G \\<noteq> {}\n  ((SOME x. x \\<in> ?A) \\<in> ?A) = (?A \\<noteq> {})\n\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "by auto"], ["proof (state)\nthis:\n  p i \\<in> proj_set (g i) G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..2 ^ k} \\<Longrightarrow> p ?i \\<in> proj_set (g ?i) G\n\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have C: \"dist (p i) (g i) \\<ge> 5 * delta * k + 15/2 * delta + C/2\" if \"i \\<in> {0..2^k}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "have \"5 * delta * k + 15/2 * delta + C/2 \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D", "using k(1)"], ["proof (prove)\nusing this:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D", "by simp"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "also"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "have \"... \\<le> infdist (g i) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> infdist (g i) G", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> infdist (f (a + (b - a) * real i / 2 ^ k)) G", "apply (rule \\<open>\\<And>t. t \\<in> {a..b} \\<Longrightarrow> infdist (f t) G \\<ge> D\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ k \\<in> {a..b}", "using * that"], ["proof (prove)\nusing this:\n  ?i \\<in> {0..2 ^ k} \\<Longrightarrow>\n  a + (b - a) * real ?i / 2 ^ k \\<in> {a..b}\n  i \\<in> {0..2 ^ k}\n\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ k \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  D \\<le> infdist (g i) G\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "also"], ["proof (state)\nthis:\n  D \\<le> infdist (g i) G\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "have \"... = dist (p i) (g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (g i) G = dist (p i) (g i)", "using that proj_setD(2)[OF B[OF that]]"], ["proof (prove)\nusing this:\n  i \\<in> {0..2 ^ k}\n  dist (g i) (p i) = infdist (g i) G\n\ngoal (1 subgoal):\n 1. infdist (g i) G = dist (p i) (g i)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  infdist (g i) G = dist (p i) (g i)\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "finally"], ["proof (chain)\npicking this:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "show ?thesis"], ["proof (prove)\nusing this:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "by simp"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..2 ^ k} \\<Longrightarrow>\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p ?i) (g ?i)\n\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"dist (p 0) (p (2^k)) \\<le> 5 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ k)) \\<le> 5 * deltaG TYPE('a)", "apply (rule Main[where ?g = g and ?c = C])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>i\\<in>{0..2 ^ k}. p i \\<in> proj_set (g i) G\n 2. \\<forall>i\\<in>{0..2 ^ k}.\n       5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)\n 3. \\<forall>i\\<in>{0..<2 ^ k}. dist (g i) (g (Suc i)) \\<le> 10 * delta + C\n 4. 0 \\<le> C", "using A B C \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  ?i \\<in> {0..<2 ^ k} \\<Longrightarrow>\n  dist (g ?i) (g (Suc ?i)) \\<le> 10 * delta + C\n  ?i \\<in> {0..2 ^ k} \\<Longrightarrow> p ?i \\<in> proj_set (g ?i) G\n  ?i \\<in> {0..2 ^ k} \\<Longrightarrow>\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p ?i) (g ?i)\n  0 \\<le> C\n\ngoal (4 subgoals):\n 1. \\<forall>i\\<in>{0..2 ^ k}. p i \\<in> proj_set (g i) G\n 2. \\<forall>i\\<in>{0..2 ^ k}.\n       5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)\n 3. \\<forall>i\\<in>{0..<2 ^ k}. dist (g i) (g (Suc i)) \\<le> 10 * delta + C\n 4. 0 \\<le> C", "by auto"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))\n 2. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  dist (p 0) (p (2 ^ k)) \\<le> 5 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (p 0) (p (2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "unfolding p_def"], ["proof (prove)\nusing this:\n  dist\n   (if 0 = 0 then pa\n    else if 0 = 2 ^ k then pb else SOME p. p \\<in> proj_set (g 0) G)\n   (if 2 ^ k = 0 then pa\n    else if 2 ^ k = 2 ^ k then pb\n         else SOME p. p \\<in> proj_set (g (2 ^ k)) G)\n  \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "by auto"], ["proof (state)\nthis:\n  dist pa pb\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n          exp (- (D - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "text \\<open>Now, the case where the path is long. We introduce $N$ such that it is roughly of length\n    $2^N \\cdot 10 \\delta$.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "case False"], ["proof (state)\nthis:\n  \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have *: \"10 * delta * 2^k \\<le> lambda * (b-a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 10 * delta * 2 ^ k \\<le> lambda * (b - a)", "using False"], ["proof (prove)\nusing this:\n  \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k\n\ngoal (1 subgoal):\n 1. 10 * delta * 2 ^ k \\<le> lambda * (b - a)", "by simp"], ["proof (state)\nthis:\n  10 * delta * 2 ^ k \\<le> lambda * (b - a)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"lambda * (b-a) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < lambda * (b - a)", "using \\<open>delta > 0\\<close> False \\<open>0 \\<le> lambda\\<close> assms(3) less_eq_real_def mult_le_0_iff"], ["proof (prove)\nusing this:\n  0 < delta\n  \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k\n  0 \\<le> lambda\n  a \\<le> b\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n  (?a * ?b \\<le> (0::?'a)) =\n  ((0::?'a) \\<le> ?a \\<and> ?b \\<le> (0::?'a) \\<or>\n   ?a \\<le> (0::?'a) \\<and> (0::?'a) \\<le> ?b)\n\ngoal (1 subgoal):\n 1. 0 < lambda * (b - a)", "by auto"], ["proof (state)\nthis:\n  0 < lambda * (b - a)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  0 < lambda * (b - a)", "have \"a < b\" \"lambda > 0\""], ["proof (prove)\nusing this:\n  0 < lambda * (b - a)\n\ngoal (1 subgoal):\n 1. a < b &&& 0 < lambda", "using \\<open>a \\<le> b\\<close> \\<open>lambda \\<ge> 0\\<close> less_eq_real_def"], ["proof (prove)\nusing this:\n  0 < lambda * (b - a)\n  a \\<le> b\n  0 \\<le> lambda\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. a < b &&& 0 < lambda", "by auto"], ["proof (state)\nthis:\n  a < b\n  0 < lambda\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "define n where \"n = nat(floor(log 2 (lambda * (b-a)/(10 * delta))))\""], ["proof (state)\nthis:\n  n = nat \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"log 2 (lambda * (b-a)/(10 * delta)) \\<ge> log 2 (2^k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (2 ^ k) \\<le> log 2 (lambda * (b - a) / (10 * delta))", "apply (subst log_le_cancel_iff)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1 < 2\n 2. 0 < 2 ^ k\n 3. 0 < lambda * (b - a) / (10 * delta)\n 4. 2 ^ k \\<le> lambda * (b - a) / (10 * delta)", "using * \\<open>delta > 0\\<close> \\<open>a < b\\<close> \\<open>lambda > 0\\<close>"], ["proof (prove)\nusing this:\n  10 * delta * 2 ^ k \\<le> lambda * (b - a)\n  0 < delta\n  a < b\n  0 < lambda\n\ngoal (4 subgoals):\n 1. 1 < 2\n 2. 0 < 2 ^ k\n 3. 0 < lambda * (b - a) / (10 * delta)\n 4. 2 ^ k \\<le> lambda * (b - a) / (10 * delta)", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  log 2 (2 ^ k) \\<le> log 2 (lambda * (b - a) / (10 * delta))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "moreover"], ["proof (state)\nthis:\n  log 2 (2 ^ k) \\<le> log 2 (lambda * (b - a) / (10 * delta))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"log 2 (2^k) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (2 ^ k) = real k", "by simp"], ["proof (state)\nthis:\n  log 2 (2 ^ k) = real k\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "ultimately"], ["proof (chain)\npicking this:\n  log 2 (2 ^ k) \\<le> log 2 (lambda * (b - a) / (10 * delta))\n  log 2 (2 ^ k) = real k", "have A: \"log 2 (lambda * (b-a)/(10 * delta)) \\<ge> k\""], ["proof (prove)\nusing this:\n  log 2 (2 ^ k) \\<le> log 2 (lambda * (b - a) / (10 * delta))\n  log 2 (2 ^ k) = real k\n\ngoal (1 subgoal):\n 1. real k \\<le> log 2 (lambda * (b - a) / (10 * delta))", "by auto"], ["proof (state)\nthis:\n  real k \\<le> log 2 (lambda * (b - a) / (10 * delta))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have **: \"int n = floor(log 2 (lambda * (b-a)/(10 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n = \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>", "unfolding n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>) =\n    \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>", "apply (rule nat_0_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>", "using A"], ["proof (prove)\nusing this:\n  real k \\<le> log 2 (lambda * (b - a) / (10 * delta))\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>", "by auto"], ["proof (state)\nthis:\n  int n = \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  int n = \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>", "have \"log 2 (2^n) \\<le> log 2 (lambda * (b-a)/(10 * delta))\""], ["proof (prove)\nusing this:\n  int n = \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>\n\ngoal (1 subgoal):\n 1. log 2 (2 ^ n) \\<le> log 2 (lambda * (b - a) / (10 * delta))", "apply (subst log_nat_power, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. int n =\n    \\<lfloor>log 2\n              (lambda * (b - a) / (10 * delta))\\<rfloor> \\<Longrightarrow>\n    real n \\<le> log 2 (lambda * (b - a) / (10 * delta))", "by linarith"], ["proof (state)\nthis:\n  log 2 (2 ^ n) \\<le> log 2 (lambda * (b - a) / (10 * delta))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  log 2 (2 ^ n) \\<le> log 2 (lambda * (b - a) / (10 * delta))", "have I: \"2^n \\<le> lambda * (b-a)/(10 * delta)\""], ["proof (prove)\nusing this:\n  log 2 (2 ^ n) \\<le> log 2 (lambda * (b - a) / (10 * delta))\n\ngoal (1 subgoal):\n 1. 2 ^ n \\<le> lambda * (b - a) / (10 * delta)", "using \\<open>0 < lambda * (b - a)\\<close> \\<open>0 < delta\\<close>"], ["proof (prove)\nusing this:\n  log 2 (2 ^ n) \\<le> log 2 (lambda * (b - a) / (10 * delta))\n  0 < lambda * (b - a)\n  0 < delta\n\ngoal (1 subgoal):\n 1. 2 ^ n \\<le> lambda * (b - a) / (10 * delta)", "by (simp add: le_log_iff powr_realpow)"], ["proof (state)\nthis:\n  2 ^ n \\<le> lambda * (b - a) / (10 * delta)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"log 2 (lambda * (b-a)/(10 * delta)) \\<le> log 2 (2^(n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (lambda * (b - a) / (10 * delta)) \\<le> log 2 (2 ^ (n + 1))", "apply (subst log_nat_power, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (lambda * (b - a) / (10 * delta)) \\<le> 1 + real n", "using **"], ["proof (prove)\nusing this:\n  int n = \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>\n\ngoal (1 subgoal):\n 1. log 2 (lambda * (b - a) / (10 * delta)) \\<le> 1 + real n", "by linarith"], ["proof (state)\nthis:\n  log 2 (lambda * (b - a) / (10 * delta)) \\<le> log 2 (2 ^ (n + 1))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  log 2 (lambda * (b - a) / (10 * delta)) \\<le> log 2 (2 ^ (n + 1))", "have J: \"lambda * (b-a)/(10 * delta) \\<le> 2^(n+1)\""], ["proof (prove)\nusing this:\n  log 2 (lambda * (b - a) / (10 * delta)) \\<le> log 2 (2 ^ (n + 1))\n\ngoal (1 subgoal):\n 1. lambda * (b - a) / (10 * delta) \\<le> 2 ^ (n + 1)", "using \\<open>0 < lambda * (b - a)\\<close> \\<open>0 < delta\\<close>"], ["proof (prove)\nusing this:\n  log 2 (lambda * (b - a) / (10 * delta)) \\<le> log 2 (2 ^ (n + 1))\n  0 < lambda * (b - a)\n  0 < delta\n\ngoal (1 subgoal):\n 1. lambda * (b - a) / (10 * delta) \\<le> 2 ^ (n + 1)", "by auto"], ["proof (state)\nthis:\n  lambda * (b - a) / (10 * delta) \\<le> 2 ^ (n + 1)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have K: \"k \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> n", "using A **"], ["proof (prove)\nusing this:\n  real k \\<le> log 2 (lambda * (b - a) / (10 * delta))\n  int n = \\<lfloor>log 2 (lambda * (b - a) / (10 * delta))\\<rfloor>\n\ngoal (1 subgoal):\n 1. k \\<le> n", "by linarith"], ["proof (state)\nthis:\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "define N where \"N = n+1\""], ["proof (state)\nthis:\n  N = n + 1\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have N: \"k+1 \\<le> N\" \"lambda * (b-a) / 2^N \\<le> 10 *delta\" \"2 ^ N \\<le> lambda * (b - a) / (5 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k + 1 \\<le> N &&&\n    lambda * (b - a) / 2 ^ N \\<le> 10 * delta &&&\n    2 ^ N \\<le> lambda * (b - a) / (5 * delta)", "using I J K \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  2 ^ n \\<le> lambda * (b - a) / (10 * delta)\n  lambda * (b - a) / (10 * delta) \\<le> 2 ^ (n + 1)\n  k \\<le> n\n  0 < delta\n\ngoal (1 subgoal):\n 1. k + 1 \\<le> N &&&\n    lambda * (b - a) / 2 ^ N \\<le> 10 * delta &&&\n    2 ^ N \\<le> lambda * (b - a) / (5 * delta)", "unfolding N_def"], ["proof (prove)\nusing this:\n  2 ^ n \\<le> lambda * (b - a) / (10 * delta)\n  lambda * (b - a) / (10 * delta) \\<le> 2 ^ (n + 1)\n  k \\<le> n\n  0 < delta\n\ngoal (1 subgoal):\n 1. k + 1 \\<le> n + 1 &&&\n    lambda * (b - a) / 2 ^ (n + 1) \\<le> 10 * delta &&&\n    2 ^ (n + 1) \\<le> lambda * (b - a) / (5 * delta)", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  k + 1 \\<le> N\n  lambda * (b - a) / 2 ^ N \\<le> 10 * delta\n  2 ^ N \\<le> lambda * (b - a) / (5 * delta)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  k + 1 \\<le> N\n  lambda * (b - a) / 2 ^ N \\<le> 10 * delta\n  2 ^ N \\<le> lambda * (b - a) / (5 * delta)", "have \"2 ^ k \\<noteq> (0::real)\" \"k \\<le> N\""], ["proof (prove)\nusing this:\n  k + 1 \\<le> N\n  lambda * (b - a) / 2 ^ N \\<le> 10 * delta\n  2 ^ N \\<le> lambda * (b - a) / (5 * delta)\n\ngoal (1 subgoal):\n 1. 2 ^ k \\<noteq> 0 &&& k \\<le> N", "by auto"], ["proof (state)\nthis:\n  2 ^ k \\<noteq> 0\n  k \\<le> N\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  2 ^ k \\<noteq> 0\n  k \\<le> N", "have \"(2^(N-k)::real) = 2^N/2^k\""], ["proof (prove)\nusing this:\n  2 ^ k \\<noteq> 0\n  k \\<le> N\n\ngoal (1 subgoal):\n 1. 2 ^ (N - k) = 2 ^ N / 2 ^ k", "by (metis (no_types) add_diff_cancel_left' le_Suc_ex nonzero_mult_div_cancel_left power_add)"], ["proof (state)\nthis:\n  2 ^ (N - k) = 2 ^ N / 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "text \\<open>Define $2^N$ points along the path, separated by at most $10\\delta$, and their projections.\\<close>"], ["proof (state)\nthis:\n  2 ^ (N - k) = 2 ^ N / 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "define g::\"nat \\<Rightarrow> 'a\" where \"g = (\\<lambda>i. f(a + (b-a) * i/2^N))\""], ["proof (state)\nthis:\n  g = (\\<lambda>x. f (a + (b - a) * real x / 2 ^ N))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"g 0 = f a\" \"g(2^N) = f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g 0 = f a &&& g (2 ^ N) = f b", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (a + (b - a) * real 0 / 2 ^ N) = f a &&&\n    f (a + (b - a) * real (2 ^ N) / 2 ^ N) = f b", "by auto"], ["proof (state)\nthis:\n  g 0 = f a\n  g (2 ^ N) = f b\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have *: \"a + (b-a) * i/2^N \\<in> {a..b}\" if \"i \\<in> {0..2^N}\" for i::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ N \\<in> {a..b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ N \\<in> {a..b}", "have \"a + (b - a) * (real i / 2 ^ N) \\<le> a + (b-a) * (2^N/2^N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (b - a) * (real i / 2 ^ N) \\<le> a + (b - a) * (2 ^ N / 2 ^ N)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. real i \\<le> 2 ^ N\n 2. 0 \\<le> 2 ^ N\n 3. 0 \\<le> b - a", "using that \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  i \\<in> {0..2 ^ N}\n  a \\<le> b\n\ngoal (3 subgoals):\n 1. real i \\<le> 2 ^ N\n 2. 0 \\<le> 2 ^ N\n 3. 0 \\<le> b - a", "by auto"], ["proof (state)\nthis:\n  a + (b - a) * (real i / 2 ^ N) \\<le> a + (b - a) * (2 ^ N / 2 ^ N)\n\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ N \\<in> {a..b}", "then"], ["proof (chain)\npicking this:\n  a + (b - a) * (real i / 2 ^ N) \\<le> a + (b - a) * (2 ^ N / 2 ^ N)", "show ?thesis"], ["proof (prove)\nusing this:\n  a + (b - a) * (real i / 2 ^ N) \\<le> a + (b - a) * (2 ^ N / 2 ^ N)\n\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ N \\<in> {a..b}", "using \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a + (b - a) * (real i / 2 ^ N) \\<le> a + (b - a) * (2 ^ N / 2 ^ N)\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ N \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  a + (b - a) * real i / 2 ^ N \\<in> {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..2 ^ N} \\<Longrightarrow>\n  a + (b - a) * real ?i / 2 ^ N \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have A: \"dist (g i) (g (Suc i)) \\<le> 10 * delta + C\" if \"i \\<in> {0..<2^N}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "have \"dist (g i) (g (Suc i)) \\<le> lambda * dist (a + (b-a) * i/2^N) (a + (b-a) * (Suc i)/2^N) + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i))\n    \\<le> lambda *\n          dist (a + (b - a) * real i / 2 ^ N)\n           (a + (b - a) * real (Suc i) / 2 ^ N) +\n          C", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f (a + (b - a) * real i / 2 ^ N))\n     (f (a + (b - a) * real (Suc i) / 2 ^ N))\n    \\<le> lambda *\n          dist (a + (b - a) * real i / 2 ^ N)\n           (a + (b - a) * real (Suc i) / 2 ^ N) +\n          C", "apply (intro assms(2) *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i \\<in> {0..2 ^ N}\n 2. Suc i \\<in> {0..2 ^ N}", "using that"], ["proof (prove)\nusing this:\n  i \\<in> {0..<2 ^ N}\n\ngoal (2 subgoals):\n 1. i \\<in> {0..2 ^ N}\n 2. Suc i \\<in> {0..2 ^ N}", "by auto"], ["proof (state)\nthis:\n  dist (g i) (g (Suc i))\n  \\<le> lambda *\n        dist (a + (b - a) * real i / 2 ^ N)\n         (a + (b - a) * real (Suc i) / 2 ^ N) +\n        C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "also"], ["proof (state)\nthis:\n  dist (g i) (g (Suc i))\n  \\<le> lambda *\n        dist (a + (b - a) * real i / 2 ^ N)\n         (a + (b - a) * real (Suc i) / 2 ^ N) +\n        C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "have \"... = lambda * (b-a)/2^N + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    dist (a + (b - a) * real i / 2 ^ N)\n     (a + (b - a) * real (Suc i) / 2 ^ N) +\n    C =\n    lambda * (b - a) / 2 ^ N + C", "unfolding dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    \\<bar>a + (b - a) * real i / 2 ^ N -\n          (a + (b - a) * real (Suc i) / 2 ^ N)\\<bar> +\n    C =\n    lambda * (b - a) / 2 ^ N + C", "using \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. lambda *\n    \\<bar>a + (b - a) * real i / 2 ^ N -\n          (a + (b - a) * real (Suc i) / 2 ^ N)\\<bar> +\n    C =\n    lambda * (b - a) / 2 ^ N + C", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  lambda *\n  dist (a + (b - a) * real i / 2 ^ N) (a + (b - a) * real (Suc i) / 2 ^ N) +\n  C =\n  lambda * (b - a) / 2 ^ N + C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "also"], ["proof (state)\nthis:\n  lambda *\n  dist (a + (b - a) * real i / 2 ^ N) (a + (b - a) * real (Suc i) / 2 ^ N) +\n  C =\n  lambda * (b - a) / 2 ^ N + C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "have \"... \\<le> 10 * delta + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (b - a) / 2 ^ N + C \\<le> 10 * delta + C", "using N"], ["proof (prove)\nusing this:\n  k + 1 \\<le> N\n  lambda * (b - a) / 2 ^ N \\<le> 10 * delta\n  2 ^ N \\<le> lambda * (b - a) / (5 * delta)\n\ngoal (1 subgoal):\n 1. lambda * (b - a) / 2 ^ N + C \\<le> 10 * delta + C", "by simp"], ["proof (state)\nthis:\n  lambda * (b - a) / 2 ^ N + C \\<le> 10 * delta + C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "finally"], ["proof (chain)\npicking this:\n  dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (g i) (g (Suc i)) \\<le> 10 * delta + C\n\ngoal (1 subgoal):\n 1. dist (g i) (g (Suc i)) \\<le> 10 * delta + C", "by simp"], ["proof (state)\nthis:\n  dist (g i) (g (Suc i)) \\<le> 10 * delta + C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..<2 ^ N} \\<Longrightarrow>\n  dist (g ?i) (g (Suc ?i)) \\<le> 10 * delta + C\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "define p where \"p = (\\<lambda>i. if i = 0 then pa else if i = 2^N then pb else SOME p. p \\<in> proj_set (g i) G)\""], ["proof (state)\nthis:\n  p =\n  (\\<lambda>i.\n      if i = 0 then pa\n      else if i = 2 ^ N then pb else SOME p. p \\<in> proj_set (g i) G)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have B: \"p i \\<in> proj_set (g i) G\" if \"i \\<in> {0..2^N}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "proof (cases \"i = 0 \\<or> i = 2^N\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<or> i = 2 ^ N \\<Longrightarrow> p i \\<in> proj_set (g i) G\n 2. \\<not> (i = 0 \\<or> i = 2 ^ N) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "case True"], ["proof (state)\nthis:\n  i = 0 \\<or> i = 2 ^ N\n\ngoal (2 subgoals):\n 1. i = 0 \\<or> i = 2 ^ N \\<Longrightarrow> p i \\<in> proj_set (g i) G\n 2. \\<not> (i = 0 \\<or> i = 2 ^ N) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "then"], ["proof (chain)\npicking this:\n  i = 0 \\<or> i = 2 ^ N", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0 \\<or> i = 2 ^ N\n\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "using \\<open>pa \\<in> proj_set (f a) G\\<close> \\<open>pb \\<in> proj_set (f b) G\\<close>"], ["proof (prove)\nusing this:\n  i = 0 \\<or> i = 2 ^ N\n  pa \\<in> proj_set (f a) G\n  pb \\<in> proj_set (f b) G\n\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "unfolding p_def g_def"], ["proof (prove)\nusing this:\n  i = 0 \\<or> i = 2 ^ N\n  pa \\<in> proj_set (f a) G\n  pb \\<in> proj_set (f b) G\n\ngoal (1 subgoal):\n 1. (if i = 0 then pa\n     else if i = 2 ^ N then pb\n          else SOME p.\n                  p \\<in> proj_set (f (a + (b - a) * real i / 2 ^ N)) G)\n    \\<in> proj_set (f (a + (b - a) * real i / 2 ^ N)) G", "by auto"], ["proof (state)\nthis:\n  p i \\<in> proj_set (g i) G\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ N) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ N) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "case False"], ["proof (state)\nthis:\n  \\<not> (i = 0 \\<or> i = 2 ^ N)\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ N) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "then"], ["proof (chain)\npicking this:\n  \\<not> (i = 0 \\<or> i = 2 ^ N)", "have \"p i = (SOME p. p \\<in> proj_set (g i) G)\""], ["proof (prove)\nusing this:\n  \\<not> (i = 0 \\<or> i = 2 ^ N)\n\ngoal (1 subgoal):\n 1. p i = (SOME p. p \\<in> proj_set (g i) G)", "unfolding p_def"], ["proof (prove)\nusing this:\n  \\<not> (i = 0 \\<or> i = 2 ^ N)\n\ngoal (1 subgoal):\n 1. (if i = 0 then pa\n     else if i = 2 ^ N then pb else SOME p. p \\<in> proj_set (g i) G) =\n    (SOME p. p \\<in> proj_set (g i) G)", "by auto"], ["proof (state)\nthis:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ N) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "moreover"], ["proof (state)\nthis:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ N) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "have \"proj_set (g i) G \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proj_set (g i) G \\<noteq> {}", "apply (rule proj_set_nonempty_of_proper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper G\n 2. G \\<noteq> {}", "using geodesic_segment_topology[OF \\<open>geodesic_segment G\\<close>]"], ["proof (prove)\nusing this:\n  compact G\n  connected G\n  path_connected G\n  bounded G\n  closed G\n  G \\<noteq> {}\n  proper G\n\ngoal (2 subgoals):\n 1. proper G\n 2. G \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  proj_set (g i) G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (i = 0 \\<or> i = 2 ^ N) \\<Longrightarrow>\n    p i \\<in> proj_set (g i) G", "ultimately"], ["proof (chain)\npicking this:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n  proj_set (g i) G \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n  proj_set (g i) G \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "using some_in_eq"], ["proof (prove)\nusing this:\n  p i = (SOME p. p \\<in> proj_set (g i) G)\n  proj_set (g i) G \\<noteq> {}\n  ((SOME x. x \\<in> ?A) \\<in> ?A) = (?A \\<noteq> {})\n\ngoal (1 subgoal):\n 1. p i \\<in> proj_set (g i) G", "by auto"], ["proof (state)\nthis:\n  p i \\<in> proj_set (g i) G\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..2 ^ N} \\<Longrightarrow> p ?i \\<in> proj_set (g ?i) G\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have C: \"dist (p i) (g i) \\<ge> 5 * delta * k + 15/2 * delta + C/2\" if \"i \\<in> {0..2^N}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "have \"5 * delta * k + 15/2 * delta + C/2 \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D", "using k(1)"], ["proof (prove)\nusing this:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D", "by simp"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "also"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> D\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "have \"... \\<le> infdist (g i) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> infdist (g i) G", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> infdist (f (a + (b - a) * real i / 2 ^ N)) G", "apply (rule \\<open>\\<And>t. t \\<in> {a..b} \\<Longrightarrow> infdist (f t) G \\<ge> D\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ N \\<in> {a..b}", "using * that"], ["proof (prove)\nusing this:\n  ?i \\<in> {0..2 ^ N} \\<Longrightarrow>\n  a + (b - a) * real ?i / 2 ^ N \\<in> {a..b}\n  i \\<in> {0..2 ^ N}\n\ngoal (1 subgoal):\n 1. a + (b - a) * real i / 2 ^ N \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  D \\<le> infdist (g i) G\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "also"], ["proof (state)\nthis:\n  D \\<le> infdist (g i) G\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "have \"... = dist (p i) (g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (g i) G = dist (p i) (g i)", "using that proj_setD(2)[OF B[OF that]]"], ["proof (prove)\nusing this:\n  i \\<in> {0..2 ^ N}\n  dist (g i) (p i) = infdist (g i) G\n\ngoal (1 subgoal):\n 1. infdist (g i) G = dist (p i) (g i)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  infdist (g i) G = dist (p i) (g i)\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "finally"], ["proof (chain)\npicking this:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "show ?thesis"], ["proof (prove)\nusing this:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)\n\ngoal (1 subgoal):\n 1. 5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)", "by simp"], ["proof (state)\nthis:\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p i) (g i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..2 ^ N} \\<Longrightarrow>\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p ?i) (g ?i)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "text \\<open>Use the basic statement to show that, along packets of size $2^k$, the projections\n    are within $5\\delta$ of each other.\\<close>"], ["proof (state)\nthis:\n  ?i \\<in> {0..2 ^ N} \\<Longrightarrow>\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p ?i) (g ?i)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have I: \"dist (p (2^k * j)) (p (2^k * (Suc j))) \\<le> 5 * delta\" if \"j \\<in> {0..<2^(N-k)}\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "have I: \"i + 2^k * j \\<in> {0..2^N}\" if \"i \\<in> {0..2^k}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..2 ^ N}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..2 ^ N}", "have \"i + 2 ^ k * j \\<le> 2^k + 2^k * (2^(N-k)-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<le> 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i \\<le> 2 ^ k\n 2. j \\<le> 2 ^ (N - k) - 1", "using that \\<open>j \\<in> {0..<2^(N-k)}\\<close>"], ["proof (prove)\nusing this:\n  i \\<in> {0..2 ^ k}\n  j \\<in> {0..<2 ^ (N - k)}\n\ngoal (2 subgoals):\n 1. i \\<le> 2 ^ k\n 2. j \\<le> 2 ^ (N - k) - 1", "by auto"], ["proof (state)\nthis:\n  i + 2 ^ k * j \\<le> 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1)\n\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..2 ^ N}", "also"], ["proof (state)\nthis:\n  i + 2 ^ k * j \\<le> 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1)\n\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..2 ^ N}", "have \"... = 2^N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1) = 2 ^ N", "using \\<open>k +1 \\<le> N\\<close>"], ["proof (prove)\nusing this:\n  k + 1 \\<le> N\n\ngoal (1 subgoal):\n 1. 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1) = 2 ^ N", "by (auto simp add: algebra_simps semiring_normalization_rules(26))"], ["proof (state)\nthis:\n  2 ^ k + 2 ^ k * (2 ^ (N - k) - 1) = 2 ^ N\n\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..2 ^ N}", "finally"], ["proof (chain)\npicking this:\n  i + 2 ^ k * j \\<le> 2 ^ N", "show ?thesis"], ["proof (prove)\nusing this:\n  i + 2 ^ k * j \\<le> 2 ^ N\n\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..2 ^ N}", "by auto"], ["proof (state)\nthis:\n  i + 2 ^ k * j \\<in> {0..2 ^ N}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..2 ^ k} \\<Longrightarrow> ?i + 2 ^ k * j \\<in> {0..2 ^ N}\n\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "have I': \"i + 2^k * j \\<in> {0..<2^N}\" if \"i \\<in> {0..<2^k}\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..<2 ^ N}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..<2 ^ N}", "have \"i + 2 ^ k * j < 2^k + 2^k * (2^(N-k)-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i + 2 ^ k * j < 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < 2 ^ k\n 2. j \\<le> 2 ^ (N - k) - 1", "using that \\<open>j \\<in> {0..<2^(N-k)}\\<close>"], ["proof (prove)\nusing this:\n  i \\<in> {0..<2 ^ k}\n  j \\<in> {0..<2 ^ (N - k)}\n\ngoal (2 subgoals):\n 1. i < 2 ^ k\n 2. j \\<le> 2 ^ (N - k) - 1", "by auto"], ["proof (state)\nthis:\n  i + 2 ^ k * j < 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1)\n\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..<2 ^ N}", "also"], ["proof (state)\nthis:\n  i + 2 ^ k * j < 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1)\n\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..<2 ^ N}", "have \"... = 2^N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1) = 2 ^ N", "using \\<open>k +1 \\<le> N\\<close>"], ["proof (prove)\nusing this:\n  k + 1 \\<le> N\n\ngoal (1 subgoal):\n 1. 2 ^ k + 2 ^ k * (2 ^ (N - k) - 1) = 2 ^ N", "by (auto simp add: algebra_simps semiring_normalization_rules(26))"], ["proof (state)\nthis:\n  2 ^ k + 2 ^ k * (2 ^ (N - k) - 1) = 2 ^ N\n\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..<2 ^ N}", "finally"], ["proof (chain)\npicking this:\n  i + 2 ^ k * j < 2 ^ N", "show ?thesis"], ["proof (prove)\nusing this:\n  i + 2 ^ k * j < 2 ^ N\n\ngoal (1 subgoal):\n 1. i + 2 ^ k * j \\<in> {0..<2 ^ N}", "by auto"], ["proof (state)\nthis:\n  i + 2 ^ k * j \\<in> {0..<2 ^ N}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> {0..<2 ^ k} \\<Longrightarrow> ?i + 2 ^ k * j \\<in> {0..<2 ^ N}\n\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "define g' where \"g' = (\\<lambda>i. g (i + 2^k * j))\""], ["proof (state)\nthis:\n  g' = (\\<lambda>i. g (i + 2 ^ k * j))\n\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "define p' where \"p' = (\\<lambda>i. p (i + 2^k * j))\""], ["proof (state)\nthis:\n  p' = (\\<lambda>i. p (i + 2 ^ k * j))\n\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "have \"dist (p' 0) (p' (2^k)) \\<le> 5 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p' 0) (p' (2 ^ k)) \\<le> 5 * deltaG TYPE('a)", "apply (rule Main[where ?g = g' and ?c = C])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>i\\<in>{0..2 ^ k}. p' i \\<in> proj_set (g' i) G\n 2. \\<forall>i\\<in>{0..2 ^ k}.\n       5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p' i) (g' i)\n 3. \\<forall>i\\<in>{0..<2 ^ k}.\n       dist (g' i) (g' (Suc i)) \\<le> 10 * delta + C\n 4. 0 \\<le> C", "unfolding p'_def g'_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>i\\<in>{0..2 ^ k}.\n       p (i + 2 ^ k * j) \\<in> proj_set (g (i + 2 ^ k * j)) G\n 2. \\<forall>i\\<in>{0..2 ^ k}.\n       5 * delta * real k + 15 / 2 * delta + C / 2\n       \\<le> dist (p (i + 2 ^ k * j)) (g (i + 2 ^ k * j))\n 3. \\<forall>i\\<in>{0..<2 ^ k}.\n       dist (g (i + 2 ^ k * j)) (g (Suc i + 2 ^ k * j)) \\<le> 10 * delta + C\n 4. 0 \\<le> C", "using A B C I I' \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  ?i \\<in> {0..<2 ^ N} \\<Longrightarrow>\n  dist (g ?i) (g (Suc ?i)) \\<le> 10 * delta + C\n  ?i \\<in> {0..2 ^ N} \\<Longrightarrow> p ?i \\<in> proj_set (g ?i) G\n  ?i \\<in> {0..2 ^ N} \\<Longrightarrow>\n  5 * delta * real k + 15 / 2 * delta + C / 2 \\<le> dist (p ?i) (g ?i)\n  ?i \\<in> {0..2 ^ k} \\<Longrightarrow> ?i + 2 ^ k * j \\<in> {0..2 ^ N}\n  ?i \\<in> {0..<2 ^ k} \\<Longrightarrow> ?i + 2 ^ k * j \\<in> {0..<2 ^ N}\n  0 \\<le> C\n\ngoal (4 subgoals):\n 1. \\<forall>i\\<in>{0..2 ^ k}.\n       p (i + 2 ^ k * j) \\<in> proj_set (g (i + 2 ^ k * j)) G\n 2. \\<forall>i\\<in>{0..2 ^ k}.\n       5 * delta * real k + 15 / 2 * delta + C / 2\n       \\<le> dist (p (i + 2 ^ k * j)) (g (i + 2 ^ k * j))\n 3. \\<forall>i\\<in>{0..<2 ^ k}.\n       dist (g (i + 2 ^ k * j)) (g (Suc i + 2 ^ k * j)) \\<le> 10 * delta + C\n 4. 0 \\<le> C", "by auto"], ["proof (state)\nthis:\n  dist (p' 0) (p' (2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "also"], ["proof (state)\nthis:\n  dist (p' 0) (p' (2 ^ k)) \\<le> 5 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "have \"... \\<le> 5 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * deltaG TYPE('a) \\<le> 5 * delta", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. 5 * deltaG TYPE('a) \\<le> 5 * delta", "by auto"], ["proof (state)\nthis:\n  5 * deltaG TYPE('a) \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "finally"], ["proof (chain)\npicking this:\n  dist (p' 0) (p' (2 ^ k)) \\<le> 5 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (p' 0) (p' (2 ^ k)) \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "unfolding p'_def"], ["proof (prove)\nusing this:\n  dist (p (0 + 2 ^ k * j)) (p (2 ^ k + 2 ^ k * j)) \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta", "by auto"], ["proof (state)\nthis:\n  dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) \\<le> 5 * delta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j \\<in> {0..<2 ^ (N - k)} \\<Longrightarrow>\n  dist (p (2 ^ k * ?j)) (p (2 ^ k * Suc ?j)) \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "text \\<open>Control the total distance by adding the contributions of blocks of size $2^k$.\\<close>"], ["proof (state)\nthis:\n  ?j \\<in> {0..<2 ^ (N - k)} \\<Longrightarrow>\n  dist (p (2 ^ k * ?j)) (p (2 ^ k * Suc ?j)) \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have *: \"dist (p 0) (p(2^k * j)) \\<le> (\\<Sum>i<j. dist (p (2^k * i)) (p (2^k * (Suc i))))\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ k * j))\n    \\<le> (\\<Sum>i<j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "proof (induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. dist (p 0) (p (2 ^ k * 0))\n    \\<le> (\\<Sum>i<0. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n 2. \\<And>j.\n       dist (p 0) (p (2 ^ k * j))\n       \\<le> (\\<Sum>i<j.\n                 dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) \\<Longrightarrow>\n       dist (p 0) (p (2 ^ k * Suc j))\n       \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "case (Suc j)"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k * j))\n  \\<le> (\\<Sum>i<j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n\ngoal (2 subgoals):\n 1. dist (p 0) (p (2 ^ k * 0))\n    \\<le> (\\<Sum>i<0. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n 2. \\<And>j.\n       dist (p 0) (p (2 ^ k * j))\n       \\<le> (\\<Sum>i<j.\n                 dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) \\<Longrightarrow>\n       dist (p 0) (p (2 ^ k * Suc j))\n       \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "have \"dist (p 0) (p(2^k * (Suc j))) \\<le> dist (p 0) (p(2^k * j)) + dist (p(2^k * j)) (p(2^k * (Suc j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ k * Suc j))\n    \\<le> dist (p 0) (p (2 ^ k * j)) +\n          dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k * Suc j))\n  \\<le> dist (p 0) (p (2 ^ k * j)) +\n        dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))\n\ngoal (2 subgoals):\n 1. dist (p 0) (p (2 ^ k * 0))\n    \\<le> (\\<Sum>i<0. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n 2. \\<And>j.\n       dist (p 0) (p (2 ^ k * j))\n       \\<le> (\\<Sum>i<j.\n                 dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) \\<Longrightarrow>\n       dist (p 0) (p (2 ^ k * Suc j))\n       \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "also"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k * Suc j))\n  \\<le> dist (p 0) (p (2 ^ k * j)) +\n        dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))\n\ngoal (2 subgoals):\n 1. dist (p 0) (p (2 ^ k * 0))\n    \\<le> (\\<Sum>i<0. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n 2. \\<And>j.\n       dist (p 0) (p (2 ^ k * j))\n       \\<le> (\\<Sum>i<j.\n                 dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) \\<Longrightarrow>\n       dist (p 0) (p (2 ^ k * Suc j))\n       \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "have \"... \\<le> (\\<Sum>i<j. dist (p (2^k * i)) (p (2^k * (Suc i)))) + dist (p(2^k * j)) (p(2^k * (Suc j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ k * j)) + dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))\n    \\<le> (\\<Sum>i<j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) +\n          dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))", "using Suc.IH"], ["proof (prove)\nusing this:\n  dist (p 0) (p (2 ^ k * j))\n  \\<le> (\\<Sum>i<j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ k * j)) + dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))\n    \\<le> (\\<Sum>i<j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) +\n          dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))", "by auto"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k * j)) + dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))\n  \\<le> (\\<Sum>i<j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) +\n        dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))\n\ngoal (2 subgoals):\n 1. dist (p 0) (p (2 ^ k * 0))\n    \\<le> (\\<Sum>i<0. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n 2. \\<And>j.\n       dist (p 0) (p (2 ^ k * j))\n       \\<le> (\\<Sum>i<j.\n                 dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) \\<Longrightarrow>\n       dist (p 0) (p (2 ^ k * Suc j))\n       \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "also"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k * j)) + dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))\n  \\<le> (\\<Sum>i<j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) +\n        dist (p (2 ^ k * j)) (p (2 ^ k * Suc j))\n\ngoal (2 subgoals):\n 1. dist (p 0) (p (2 ^ k * 0))\n    \\<le> (\\<Sum>i<0. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n 2. \\<And>j.\n       dist (p 0) (p (2 ^ k * j))\n       \\<le> (\\<Sum>i<j.\n                 dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) \\<Longrightarrow>\n       dist (p 0) (p (2 ^ k * Suc j))\n       \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "have \"... = (\\<Sum>i<Suc j. dist (p (2^k * i)) (p (2^k * (Suc i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) +\n    dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) =\n    (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) +\n  dist (p (2 ^ k * j)) (p (2 ^ k * Suc j)) =\n  (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n\ngoal (2 subgoals):\n 1. dist (p 0) (p (2 ^ k * 0))\n    \\<le> (\\<Sum>i<0. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n 2. \\<And>j.\n       dist (p 0) (p (2 ^ k * j))\n       \\<le> (\\<Sum>i<j.\n                 dist (p (2 ^ k * i)) (p (2 ^ k * Suc i))) \\<Longrightarrow>\n       dist (p 0) (p (2 ^ k * Suc j))\n       \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "finally"], ["proof (chain)\npicking this:\n  dist (p 0) (p (2 ^ k * Suc j))\n  \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "show ?case"], ["proof (prove)\nusing this:\n  dist (p 0) (p (2 ^ k * Suc j))\n  \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ k * Suc j))\n    \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "by simp"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k * Suc j))\n  \\<le> (\\<Sum>i<Suc j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ k * 0))\n    \\<le> (\\<Sum>i<0. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "qed (auto)"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k * ?j))\n  \\<le> (\\<Sum>i<?j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"dist pa pb = dist (p 0) (p (2^N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pa pb = dist (p 0) (p (2 ^ N))", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pa pb =\n    dist\n     (if 0 = 0 then pa\n      else if 0 = 2 ^ N then pb else SOME p. p \\<in> proj_set (g 0) G)\n     (if 2 ^ N = 0 then pa\n      else if 2 ^ N = 2 ^ N then pb\n           else SOME p. p \\<in> proj_set (g (2 ^ N)) G)", "by auto"], ["proof (state)\nthis:\n  dist pa pb = dist (p 0) (p (2 ^ N))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  dist pa pb = dist (p 0) (p (2 ^ N))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... = dist (p 0) (p (2^k * 2^(N-k)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ N)) = dist (p 0) (p (2 ^ k * 2 ^ (N - k)))", "using \\<open>k +1 \\<le> N\\<close>"], ["proof (prove)\nusing this:\n  k + 1 \\<le> N\n\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ N)) = dist (p 0) (p (2 ^ k * 2 ^ (N - k)))", "by (auto simp add: semiring_normalization_rules(26))"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ N)) = dist (p 0) (p (2 ^ k * 2 ^ (N - k)))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ N)) = dist (p 0) (p (2 ^ k * 2 ^ (N - k)))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... \\<le> (\\<Sum>i<2^(N-k). dist (p (2^k * i)) (p (2^k * (Suc i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ k * 2 ^ (N - k)))\n    \\<le> (\\<Sum>i<2 ^ (N - k). dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "using *"], ["proof (prove)\nusing this:\n  dist (p 0) (p (2 ^ k * ?j))\n  \\<le> (\\<Sum>i<?j. dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n\ngoal (1 subgoal):\n 1. dist (p 0) (p (2 ^ k * 2 ^ (N - k)))\n    \\<le> (\\<Sum>i<2 ^ (N - k). dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))", "by auto"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k * 2 ^ (N - k)))\n  \\<le> (\\<Sum>i<2 ^ (N - k). dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  dist (p 0) (p (2 ^ k * 2 ^ (N - k)))\n  \\<le> (\\<Sum>i<2 ^ (N - k). dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... \\<le> (\\<Sum>(i::nat)<2^(N-k). 5 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<2 ^ (N - k). dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n    \\<le> (\\<Sum>i<2 ^ (N - k). 5 * delta)", "apply (rule sum_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<2 ^ (N - k)} \\<Longrightarrow>\n       dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)) \\<le> 5 * delta", "using I"], ["proof (prove)\nusing this:\n  ?j \\<in> {0..<2 ^ (N - k)} \\<Longrightarrow>\n  dist (p (2 ^ k * ?j)) (p (2 ^ k * Suc ?j)) \\<le> 5 * delta\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<2 ^ (N - k)} \\<Longrightarrow>\n       dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)) \\<le> 5 * delta", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<2 ^ (N - k). dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n  \\<le> (\\<Sum>i<2 ^ (N - k). 5 * delta)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<2 ^ (N - k). dist (p (2 ^ k * i)) (p (2 ^ k * Suc i)))\n  \\<le> (\\<Sum>i<2 ^ (N - k). 5 * delta)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... = 5 * delta * 2^(N-k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<2 ^ (N - k). 5 * delta) = 5 * delta * 2 ^ (N - k)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>i<2 ^ (N - k). 5 * delta) = 5 * delta * 2 ^ (N - k)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<2 ^ (N - k). 5 * delta) = 5 * delta * 2 ^ (N - k)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... = 5 * delta * 2^N * (1/ 2^k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * 2 ^ (N - k) = 5 * delta * 2 ^ N * (1 / 2 ^ k)", "unfolding \\<open>(2^(N-k)::real) = 2^N/2^k\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * (2 ^ N / 2 ^ k) = 5 * delta * 2 ^ N * (1 / 2 ^ k)", "by simp"], ["proof (state)\nthis:\n  5 * delta * 2 ^ (N - k) = 5 * delta * 2 ^ N * (1 / 2 ^ k)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  5 * delta * 2 ^ (N - k) = 5 * delta * 2 ^ N * (1 / 2 ^ k)\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... \\<le> 5 * delta * (2 * lambda * (b-a)/(10 * delta)) * (2 * exp(15/2/5 * ln 2) * exp(- ((D-C/2) * ln 2 / (5 * delta))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * 2 ^ N * (1 / 2 ^ k)\n    \\<le> 5 * delta * (2 * lambda * (b - a) / (10 * delta)) *\n          (2 * exp (15 / 2 / 5 * ln 2) *\n           exp (- ((D - C / 2) * ln 2 / (5 * delta))))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (5 subgoals):\n 1. 2 ^ N \\<le> 2 * lambda * (b - a) / (10 * delta)\n 2. 0 \\<le> 5 * delta\n 3. 1 / 2 ^ k\n    \\<le> 2 * exp (15 / 2 / 5 * ln 2) *\n          exp (- ((D - C / 2) * ln 2 / (5 * delta)))\n 4. 0 \\<le> 5 * delta * (2 * lambda * (b - a) / (10 * delta))\n 5. 0 \\<le> 1 / 2 ^ k", "using \\<open>delta > 0\\<close> \\<open>lambda > 0\\<close> \\<open>a < b\\<close> k' N"], ["proof (prove)\nusing this:\n  0 < delta\n  0 < lambda\n  a < b\n  1 / 2 ^ k\n  \\<le> 2 * exp (15 / 2 / 5 * ln 2) *\n        exp (- ((D - C / 2) * ln 2 / (5 * delta)))\n  k + 1 \\<le> N\n  lambda * (b - a) / 2 ^ N \\<le> 10 * delta\n  2 ^ N \\<le> lambda * (b - a) / (5 * delta)\n\ngoal (5 subgoals):\n 1. 2 ^ N \\<le> 2 * lambda * (b - a) / (10 * delta)\n 2. 0 \\<le> 5 * delta\n 3. 1 / 2 ^ k\n    \\<le> 2 * exp (15 / 2 / 5 * ln 2) *\n          exp (- ((D - C / 2) * ln 2 / (5 * delta)))\n 4. 0 \\<le> 5 * delta * (2 * lambda * (b - a) / (10 * delta))\n 5. 0 \\<le> 1 / 2 ^ k", "by auto"], ["proof (state)\nthis:\n  5 * delta * 2 ^ N * (1 / 2 ^ k)\n  \\<le> 5 * delta * (2 * lambda * (b - a) / (10 * delta)) *\n        (2 * exp (15 / 2 / 5 * ln 2) *\n         exp (- ((D - C / 2) * ln 2 / (5 * delta))))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "also"], ["proof (state)\nthis:\n  5 * delta * 2 ^ N * (1 / 2 ^ k)\n  \\<le> 5 * delta * (2 * lambda * (b - a) / (10 * delta)) *\n        (2 * exp (15 / 2 / 5 * ln 2) *\n         exp (- ((D - C / 2) * ln 2 / (5 * delta))))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "have \"... = (2 * exp(15/2/5 * ln 2)) * lambda * (b-a) * exp(-(D-C/2) * ln 2 / (5 * delta))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta * (2 * lambda * (b - a) / (10 * delta)) *\n    (2 * exp (15 / 2 / 5 * ln 2) *\n     exp (- ((D - C / 2) * ln 2 / (5 * delta)))) =\n    2 * exp (15 / 2 / 5 * ln 2) * lambda * (b - a) *\n    exp (- (D - C / 2) * ln 2 / (5 * delta))", "using \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n\ngoal (1 subgoal):\n 1. 5 * delta * (2 * lambda * (b - a) / (10 * delta)) *\n    (2 * exp (15 / 2 / 5 * ln 2) *\n     exp (- ((D - C / 2) * ln 2 / (5 * delta)))) =\n    2 * exp (15 / 2 / 5 * ln 2) * lambda * (b - a) *\n    exp (- (D - C / 2) * ln 2 / (5 * delta))", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  5 * delta * (2 * lambda * (b - a) / (10 * delta)) *\n  (2 * exp (15 / 2 / 5 * ln 2) *\n   exp (- ((D - C / 2) * ln 2 / (5 * delta)))) =\n  2 * exp (15 / 2 / 5 * ln 2) * lambda * (b - a) *\n  exp (- (D - C / 2) * ln 2 / (5 * delta))\n\ngoal (1 subgoal):\n 1. \\<not> lambda * (b - a) \\<le> 10 * delta * 2 ^ k \\<Longrightarrow>\n    dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "finally"], ["proof (chain)\npicking this:\n  dist pa pb\n  \\<le> 2 * exp (15 / 2 / 5 * ln 2) * lambda * (b - a) *\n        exp (- (D - C / 2) * ln 2 / (5 * delta))", "show ?thesis"], ["proof (prove)\nusing this:\n  dist pa pb\n  \\<le> 2 * exp (15 / 2 / 5 * ln 2) * lambda * (b - a) *\n        exp (- (D - C / 2) * ln 2 / (5 * delta))\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "unfolding \\<open>exp(15/2/5 * ln 2) = 2 * exp(1/2 * ln (2::real))\\<close>"], ["proof (prove)\nusing this:\n  dist pa pb\n  \\<le> 2 * (2 * exp (1 / 2 * ln 2)) * lambda * (b - a) *\n        exp (- (D - C / 2) * ln 2 / (5 * delta))\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - C / 2) * ln 2 / (5 * delta)))", "by auto"], ["proof (state)\nthis:\n  dist pa pb\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n          exp (- (D - C / 2) * ln 2 / (5 * delta)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist pa pb\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n          exp (- (D - C / 2) * ln 2 / (5 * delta)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We deduce from the previous result that a projection on a quasiconvex set is also\nexponentially contracting. To do this, one uses the contraction of a projection on a geodesic, and\none adds up the additional errors due to the quasi-convexity. In particular, the projections on the\noriginal quasiconvex set or the geodesic do not have to coincide, but they are within distance at\nmost $C + 8 \\delta$.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) quasiconvex_projection_exp_contracting:\n  assumes \"quasiconvex K G\"\n          \"\\<And>x y. x \\<in> {a..b} \\<Longrightarrow> y \\<in> {a..b} \\<Longrightarrow> dist (f x) (f y) \\<le> lambda * dist x y + C\"\n          \"a \\<le> b\"\n          \"pa \\<in> proj_set (f a) G\"\n          \"pb \\<in> proj_set (f b) G\"\n          \"\\<And>t. t \\<in> {a..b} \\<Longrightarrow> infdist (f t) G \\<ge> D\"\n          \"D \\<ge> 15/2 * delta + K + C/2\"\n          \"delta > deltaG(TYPE('a))\"\n          \"C \\<ge> 0\"\n          \"lambda \\<ge> 0\"\n  shows \"dist pa pb \\<le> 2 * K + 8 * delta + max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (b-a) * exp(-(D - K - C/2) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "obtain H where H: \"geodesic_segment_between H pa pb\" \"\\<And>q. q \\<in> H \\<Longrightarrow> infdist q G \\<le> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>H.\n        \\<lbrakk>geodesic_segment_between H pa pb;\n         \\<And>q. q \\<in> H \\<Longrightarrow> infdist q G \\<le> K\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using quasiconvexD[OF assms(1) proj_setD(1)[OF \\<open>pa \\<in> proj_set (f a) G\\<close>] proj_setD(1)[OF \\<open>pb \\<in> proj_set (f b) G\\<close>]]"], ["proof (prove)\nusing this:\n  \\<exists>Ga.\n     geodesic_segment_between Ga pa pb \\<and>\n     (\\<forall>z\\<in>Ga. infdist z G \\<le> K)\n\ngoal (1 subgoal):\n 1. (\\<And>H.\n        \\<lbrakk>geodesic_segment_between H pa pb;\n         \\<And>q. q \\<in> H \\<Longrightarrow> infdist q G \\<le> K\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between H pa pb\n  ?q \\<in> H \\<Longrightarrow> infdist ?q G \\<le> K\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "obtain qa where qa: \"qa \\<in> proj_set (f a) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qa.\n        qa \\<in> proj_set (f a) H \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using proj_set_nonempty_of_proper[of H \"f a\"] geodesic_segment_topology[OF geodesic_segmentI[OF H(1)]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper H; H \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> proj_set (f a) H \\<noteq> {}\n  compact H\n  connected H\n  path_connected H\n  bounded H\n  closed H\n  H \\<noteq> {}\n  proper H\n\ngoal (1 subgoal):\n 1. (\\<And>qa.\n        qa \\<in> proj_set (f a) H \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qa \\<in> proj_set (f a) H\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "obtain qb where qb: \"qb \\<in> proj_set (f b) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>qb.\n        qb \\<in> proj_set (f b) H \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using proj_set_nonempty_of_proper[of H \"f b\"] geodesic_segment_topology[OF geodesic_segmentI[OF H(1)]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper H; H \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> proj_set (f b) H \\<noteq> {}\n  compact H\n  connected H\n  path_connected H\n  bounded H\n  closed H\n  H \\<noteq> {}\n  proper H\n\ngoal (1 subgoal):\n 1. (\\<And>qb.\n        qb \\<in> proj_set (f b) H \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  qb \\<in> proj_set (f b) H\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "have I: \"infdist (f t) H \\<ge> D - K\" if \"t \\<in> {a..b}\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. D - K \\<le> infdist (f t) H", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D - K \\<le> infdist (f t) H", "have *: \"D - K \\<le> dist (f t) h\" if \"h \\<in> H\" for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. D - K \\<le> dist (f t) h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D - K \\<le> dist (f t) h", "have \"D - K - dist (f t) h \\<le> e\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "have *: \"infdist h G < K + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist h G < K + e", "using H(2)[OF \\<open>h \\<in> H\\<close>] \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  infdist h G \\<le> K\n  0 < e\n\ngoal (1 subgoal):\n 1. infdist h G < K + e", "by auto"], ["proof (state)\nthis:\n  infdist h G < K + e\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "obtain g where g: \"g \\<in> G\" \"dist h g < K + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; dist h g < K + e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using infdist_almost_attained[OF *] proj_setD(1)[OF \\<open>pa \\<in> proj_set (f a) G\\<close>]"], ["proof (prove)\nusing this:\n  G \\<noteq> {} \\<Longrightarrow> \\<exists>y\\<in>G. dist h y < K + e\n  pa \\<in> G\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; dist h g < K + e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<in> G\n  dist h g < K + e\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "have \"D \\<le> dist (f t) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> dist (f t) g", "using \\<open>\\<And>t. t \\<in> {a..b} \\<Longrightarrow> infdist (f t) G \\<ge> D\\<close>[OF \\<open>t \\<in> {a..b}\\<close>] infdist_le[OF \\<open>g \\<in> G\\<close>, of \"f t\"]"], ["proof (prove)\nusing this:\n  D \\<le> infdist (f t) G\n  infdist (f t) G \\<le> dist (f t) g\n\ngoal (1 subgoal):\n 1. D \\<le> dist (f t) g", "by auto"], ["proof (state)\nthis:\n  D \\<le> dist (f t) g\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "also"], ["proof (state)\nthis:\n  D \\<le> dist (f t) g\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "have \"... \\<le> dist (f t) h + dist h g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f t) g \\<le> dist (f t) h + dist h g", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f t) g \\<le> dist (f t) h + dist h g\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "also"], ["proof (state)\nthis:\n  dist (f t) g \\<le> dist (f t) h + dist h g\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "have \"... \\<le> dist (f t) h + K + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f t) h + dist h g \\<le> dist (f t) h + K + e", "using g(2)"], ["proof (prove)\nusing this:\n  dist h g < K + e\n\ngoal (1 subgoal):\n 1. dist (f t) h + dist h g \\<le> dist (f t) h + K + e", "by auto"], ["proof (state)\nthis:\n  dist (f t) h + dist h g \\<le> dist (f t) h + K + e\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "finally"], ["proof (chain)\npicking this:\n  D \\<le> dist (f t) h + K + e", "show ?thesis"], ["proof (prove)\nusing this:\n  D \\<le> dist (f t) h + K + e\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> e", "by auto"], ["proof (state)\nthis:\n  D - K - dist (f t) h \\<le> e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow> D - K - dist (f t) h \\<le> ?e\n\ngoal (1 subgoal):\n 1. D - K \\<le> dist (f t) h", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow> D - K - dist (f t) h \\<le> ?e", "have *: \"D - K - dist (f t) h \\<le> 0\""], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> D - K - dist (f t) h \\<le> ?e\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> 0", "using dense_ge"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> D - K - dist (f t) h \\<le> ?e\n  (\\<And>x. ?z < x \\<Longrightarrow> ?y \\<le> x) \\<Longrightarrow>\n  ?y \\<le> ?z\n\ngoal (1 subgoal):\n 1. D - K - dist (f t) h \\<le> 0", "by blast"], ["proof (state)\nthis:\n  D - K - dist (f t) h \\<le> 0\n\ngoal (1 subgoal):\n 1. D - K \\<le> dist (f t) h", "then"], ["proof (chain)\npicking this:\n  D - K - dist (f t) h \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  D - K - dist (f t) h \\<le> 0\n\ngoal (1 subgoal):\n 1. D - K \\<le> dist (f t) h", "by simp"], ["proof (state)\nthis:\n  D - K \\<le> dist (f t) h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?h \\<in> H \\<Longrightarrow> D - K \\<le> dist (f t) ?h\n\ngoal (1 subgoal):\n 1. D - K \\<le> infdist (f t) H", "have \"D - K \\<le> Inf (dist (f t) ` H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D - K \\<le> Inf (dist (f t) ` H)", "apply (rule cInf_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist (f t) ` H \\<noteq> {}\n 2. \\<And>x. x \\<in> dist (f t) ` H \\<Longrightarrow> D - K \\<le> x", "using * H(1)"], ["proof (prove)\nusing this:\n  ?h \\<in> H \\<Longrightarrow> D - K \\<le> dist (f t) ?h\n  geodesic_segment_between H pa pb\n\ngoal (2 subgoals):\n 1. dist (f t) ` H \\<noteq> {}\n 2. \\<And>x. x \\<in> dist (f t) ` H \\<Longrightarrow> D - K \\<le> x", "by auto"], ["proof (state)\nthis:\n  D - K \\<le> Inf (dist (f t) ` H)\n\ngoal (1 subgoal):\n 1. D - K \\<le> infdist (f t) H", "then"], ["proof (chain)\npicking this:\n  D - K \\<le> Inf (dist (f t) ` H)", "show \"D - K \\<le> infdist (f t) H\""], ["proof (prove)\nusing this:\n  D - K \\<le> Inf (dist (f t) ` H)\n\ngoal (1 subgoal):\n 1. D - K \\<le> infdist (f t) H", "apply (subst infdist_notempty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. D - K \\<le> Inf (dist (f t) ` H) \\<Longrightarrow> H \\<noteq> {}\n 2. D - K \\<le> Inf (dist (f t) ` H) \\<Longrightarrow>\n    D - K \\<le> Inf (dist (f t) ` H)", "using H(1)"], ["proof (prove)\nusing this:\n  geodesic_segment_between H pa pb\n\ngoal (2 subgoals):\n 1. D - K \\<le> Inf (dist (f t) ` H) \\<Longrightarrow> H \\<noteq> {}\n 2. D - K \\<le> Inf (dist (f t) ` H) \\<Longrightarrow>\n    D - K \\<le> Inf (dist (f t) ` H)", "by auto"], ["proof (state)\nthis:\n  D - K \\<le> infdist (f t) H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> {a..b} \\<Longrightarrow> D - K \\<le> infdist (f ?t) H\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "have Q: \"dist qa qb \\<le> max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (b-a) * exp(-((D - K)-C/2 ) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist qa qb\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "apply (rule geodesic_projection_exp_contracting[OF geodesic_segmentI[OF \\<open>geodesic_segment_between H pa pb\\<close>] assms(2) assms(3)])"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {a..b}; y \\<in> {a..b}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {a..b}\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> {a..b}; y \\<in> {a..b}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {a..b}\n 3. qa \\<in> proj_set (f a) H\n 4. qb \\<in> proj_set (f b) H\n 5. \\<And>t. t \\<in> {a..b} \\<Longrightarrow> D - K \\<le> infdist (f t) H\n 6. 15 / 2 * delta + C / 2 \\<le> D - K\n 7. deltaG TYPE('a) < delta\n 8. 0 \\<le> C\n 9. 0 \\<le> lambda", "using qa qb I assms"], ["proof (prove)\nusing this:\n  qa \\<in> proj_set (f a) H\n  qb \\<in> proj_set (f b) H\n  ?t \\<in> {a..b} \\<Longrightarrow> D - K \\<le> infdist (f ?t) H\n  quasiconvex K G\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  a \\<le> b\n  pa \\<in> proj_set (f a) G\n  pb \\<in> proj_set (f b) G\n  ?t \\<in> {a..b} \\<Longrightarrow> D \\<le> infdist (f ?t) G\n  15 / 2 * delta + K + C / 2 \\<le> D\n  deltaG TYPE('a) < delta\n  0 \\<le> C\n  0 \\<le> lambda\n\ngoal (9 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {a..b}; y \\<in> {a..b}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> {a..b}\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> {a..b}; y \\<in> {a..b}\\<rbrakk>\n       \\<Longrightarrow> y \\<in> {a..b}\n 3. qa \\<in> proj_set (f a) H\n 4. qb \\<in> proj_set (f b) H\n 5. \\<And>t. t \\<in> {a..b} \\<Longrightarrow> D - K \\<le> infdist (f t) H\n 6. 15 / 2 * delta + C / 2 \\<le> D - K\n 7. deltaG TYPE('a) < delta\n 8. 0 \\<le> C\n 9. 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  dist qa qb\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n          exp (- (D - K - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "have A: \"dist pa qa \\<le> 4 * delta + K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pa qa \\<le> 4 * delta + K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist pa qa \\<le> 4 * delta + K", "have \"dist (f a) pa - dist (f a) qa - K \\<le> e\" if \"e > 0\" for e::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "have *: \"infdist qa G < K + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist qa G < K + e", "using H(2)[OF proj_setD(1)[OF qa]] \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  infdist qa G \\<le> K\n  0 < e\n\ngoal (1 subgoal):\n 1. infdist qa G < K + e", "by auto"], ["proof (state)\nthis:\n  infdist qa G < K + e\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "obtain g where g: \"g \\<in> G\" \"dist qa g < K + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; dist qa g < K + e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using infdist_almost_attained[OF *] proj_setD(1)[OF \\<open>pa \\<in> proj_set (f a) G\\<close>]"], ["proof (prove)\nusing this:\n  G \\<noteq> {} \\<Longrightarrow> \\<exists>y\\<in>G. dist qa y < K + e\n  pa \\<in> G\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; dist qa g < K + e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<in> G\n  dist qa g < K + e\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "have \"dist (f a) pa \\<le> dist (f a) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f a) pa \\<le> dist (f a) g", "unfolding proj_setD(2)[OF \\<open>pa \\<in> proj_set (f a) G\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f a) G \\<le> dist (f a) g", "using infdist_le[OF \\<open>g \\<in> G\\<close>, of \"f a\"]"], ["proof (prove)\nusing this:\n  infdist (f a) G \\<le> dist (f a) g\n\ngoal (1 subgoal):\n 1. infdist (f a) G \\<le> dist (f a) g", "by simp"], ["proof (state)\nthis:\n  dist (f a) pa \\<le> dist (f a) g\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "also"], ["proof (state)\nthis:\n  dist (f a) pa \\<le> dist (f a) g\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "have \"... \\<le> dist (f a) qa + dist qa g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f a) g \\<le> dist (f a) qa + dist qa g", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f a) g \\<le> dist (f a) qa + dist qa g\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "also"], ["proof (state)\nthis:\n  dist (f a) g \\<le> dist (f a) qa + dist qa g\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "have \"... \\<le> dist (f a) qa + K + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f a) qa + dist qa g \\<le> dist (f a) qa + K + e", "using g(2)"], ["proof (prove)\nusing this:\n  dist qa g < K + e\n\ngoal (1 subgoal):\n 1. dist (f a) qa + dist qa g \\<le> dist (f a) qa + K + e", "by auto"], ["proof (state)\nthis:\n  dist (f a) qa + dist qa g \\<le> dist (f a) qa + K + e\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "finally"], ["proof (chain)\npicking this:\n  dist (f a) pa \\<le> dist (f a) qa + K + e", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (f a) pa \\<le> dist (f a) qa + K + e\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> e", "by simp"], ["proof (state)\nthis:\n  dist (f a) pa - dist (f a) qa - K \\<le> e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow> dist (f a) pa - dist (f a) qa - K \\<le> ?e\n\ngoal (1 subgoal):\n 1. dist pa qa \\<le> 4 * delta + K", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow> dist (f a) pa - dist (f a) qa - K \\<le> ?e", "have I: \"dist (f a) pa - dist (f a) qa - K \\<le> 0\""], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> dist (f a) pa - dist (f a) qa - K \\<le> ?e\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> 0", "using dense_ge"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> dist (f a) pa - dist (f a) qa - K \\<le> ?e\n  (\\<And>x. ?z < x \\<Longrightarrow> ?y \\<le> x) \\<Longrightarrow>\n  ?y \\<le> ?z\n\ngoal (1 subgoal):\n 1. dist (f a) pa - dist (f a) qa - K \\<le> 0", "by blast"], ["proof (state)\nthis:\n  dist (f a) pa - dist (f a) qa - K \\<le> 0\n\ngoal (1 subgoal):\n 1. dist pa qa \\<le> 4 * delta + K", "have \"dist (f a) qa + dist qa pa \\<le> dist (f a) pa + 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f a) qa + dist qa pa \\<le> dist (f a) pa + 4 * deltaG TYPE('a)", "apply (rule dist_along_geodesic[OF geodesic_segmentI[OF H(1)]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. qa \\<in> proj_set (f a) H\n 2. pa \\<in> H", "using qa H(1)"], ["proof (prove)\nusing this:\n  qa \\<in> proj_set (f a) H\n  geodesic_segment_between H pa pb\n\ngoal (2 subgoals):\n 1. qa \\<in> proj_set (f a) H\n 2. pa \\<in> H", "by auto"], ["proof (state)\nthis:\n  dist (f a) qa + dist qa pa \\<le> dist (f a) pa + 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist pa qa \\<le> 4 * delta + K", "also"], ["proof (state)\nthis:\n  dist (f a) qa + dist qa pa \\<le> dist (f a) pa + 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist pa qa \\<le> 4 * delta + K", "have \"... \\<le> dist (f a) qa + K + 4 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f a) pa + 4 * deltaG TYPE('a) \\<le> dist (f a) qa + K + 4 * delta", "using I assms"], ["proof (prove)\nusing this:\n  dist (f a) pa - dist (f a) qa - K \\<le> 0\n  quasiconvex K G\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  a \\<le> b\n  pa \\<in> proj_set (f a) G\n  pb \\<in> proj_set (f b) G\n  ?t \\<in> {a..b} \\<Longrightarrow> D \\<le> infdist (f ?t) G\n  15 / 2 * delta + K + C / 2 \\<le> D\n  deltaG TYPE('a) < delta\n  0 \\<le> C\n  0 \\<le> lambda\n\ngoal (1 subgoal):\n 1. dist (f a) pa + 4 * deltaG TYPE('a) \\<le> dist (f a) qa + K + 4 * delta", "by auto"], ["proof (state)\nthis:\n  dist (f a) pa + 4 * deltaG TYPE('a) \\<le> dist (f a) qa + K + 4 * delta\n\ngoal (1 subgoal):\n 1. dist pa qa \\<le> 4 * delta + K", "finally"], ["proof (chain)\npicking this:\n  dist (f a) qa + dist qa pa \\<le> dist (f a) qa + K + 4 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (f a) qa + dist qa pa \\<le> dist (f a) qa + K + 4 * delta\n\ngoal (1 subgoal):\n 1. dist pa qa \\<le> 4 * delta + K", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist pa qa \\<le> 4 * delta + K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist pa qa \\<le> 4 * delta + K\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "have B: \"dist qb pb \\<le> 4 * delta + K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist qb pb \\<le> 4 * delta + K", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist qb pb \\<le> 4 * delta + K", "have \"dist (f b) pb - dist (f b) qb - K \\<le> e\" if \"e > 0\" for e::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "have *: \"infdist qb G < K + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist qb G < K + e", "using H(2)[OF proj_setD(1)[OF qb]] \\<open>e > 0\\<close>"], ["proof (prove)\nusing this:\n  infdist qb G \\<le> K\n  0 < e\n\ngoal (1 subgoal):\n 1. infdist qb G < K + e", "by auto"], ["proof (state)\nthis:\n  infdist qb G < K + e\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "obtain g where g: \"g \\<in> G\" \"dist qb g < K + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; dist qb g < K + e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using infdist_almost_attained[OF *] proj_setD(1)[OF \\<open>pa \\<in> proj_set (f a) G\\<close>]"], ["proof (prove)\nusing this:\n  G \\<noteq> {} \\<Longrightarrow> \\<exists>y\\<in>G. dist qb y < K + e\n  pa \\<in> G\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> G; dist qb g < K + e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<in> G\n  dist qb g < K + e\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "have \"dist (f b) pb \\<le> dist (f b) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f b) pb \\<le> dist (f b) g", "unfolding proj_setD(2)[OF \\<open>pb \\<in> proj_set (f b) G\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f b) G \\<le> dist (f b) g", "using infdist_le[OF \\<open>g \\<in> G\\<close>, of \"f b\"]"], ["proof (prove)\nusing this:\n  infdist (f b) G \\<le> dist (f b) g\n\ngoal (1 subgoal):\n 1. infdist (f b) G \\<le> dist (f b) g", "by simp"], ["proof (state)\nthis:\n  dist (f b) pb \\<le> dist (f b) g\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "also"], ["proof (state)\nthis:\n  dist (f b) pb \\<le> dist (f b) g\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "have \"... \\<le> dist (f b) qb + dist qb g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f b) g \\<le> dist (f b) qb + dist qb g", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f b) g \\<le> dist (f b) qb + dist qb g\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "also"], ["proof (state)\nthis:\n  dist (f b) g \\<le> dist (f b) qb + dist qb g\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "have \"... \\<le> dist (f b) qb + K + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f b) qb + dist qb g \\<le> dist (f b) qb + K + e", "using g(2)"], ["proof (prove)\nusing this:\n  dist qb g < K + e\n\ngoal (1 subgoal):\n 1. dist (f b) qb + dist qb g \\<le> dist (f b) qb + K + e", "by auto"], ["proof (state)\nthis:\n  dist (f b) qb + dist qb g \\<le> dist (f b) qb + K + e\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "finally"], ["proof (chain)\npicking this:\n  dist (f b) pb \\<le> dist (f b) qb + K + e", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (f b) pb \\<le> dist (f b) qb + K + e\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> e", "by simp"], ["proof (state)\nthis:\n  dist (f b) pb - dist (f b) qb - K \\<le> e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow> dist (f b) pb - dist (f b) qb - K \\<le> ?e\n\ngoal (1 subgoal):\n 1. dist qb pb \\<le> 4 * delta + K", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow> dist (f b) pb - dist (f b) qb - K \\<le> ?e", "have I: \"dist (f b) pb - dist (f b) qb - K \\<le> 0\""], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> dist (f b) pb - dist (f b) qb - K \\<le> ?e\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> 0", "using dense_ge"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> dist (f b) pb - dist (f b) qb - K \\<le> ?e\n  (\\<And>x. ?z < x \\<Longrightarrow> ?y \\<le> x) \\<Longrightarrow>\n  ?y \\<le> ?z\n\ngoal (1 subgoal):\n 1. dist (f b) pb - dist (f b) qb - K \\<le> 0", "by blast"], ["proof (state)\nthis:\n  dist (f b) pb - dist (f b) qb - K \\<le> 0\n\ngoal (1 subgoal):\n 1. dist qb pb \\<le> 4 * delta + K", "have \"dist (f b) qb + dist qb pb \\<le> dist (f b) pb + 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f b) qb + dist qb pb \\<le> dist (f b) pb + 4 * deltaG TYPE('a)", "apply (rule dist_along_geodesic[OF geodesic_segmentI[OF H(1)]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. qb \\<in> proj_set (f b) H\n 2. pb \\<in> H", "using qb H(1)"], ["proof (prove)\nusing this:\n  qb \\<in> proj_set (f b) H\n  geodesic_segment_between H pa pb\n\ngoal (2 subgoals):\n 1. qb \\<in> proj_set (f b) H\n 2. pb \\<in> H", "by auto"], ["proof (state)\nthis:\n  dist (f b) qb + dist qb pb \\<le> dist (f b) pb + 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist qb pb \\<le> 4 * delta + K", "also"], ["proof (state)\nthis:\n  dist (f b) qb + dist qb pb \\<le> dist (f b) pb + 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist qb pb \\<le> 4 * delta + K", "have \"... \\<le> dist (f b) qb + K + 4 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f b) pb + 4 * deltaG TYPE('a) \\<le> dist (f b) qb + K + 4 * delta", "using I assms"], ["proof (prove)\nusing this:\n  dist (f b) pb - dist (f b) qb - K \\<le> 0\n  quasiconvex K G\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  a \\<le> b\n  pa \\<in> proj_set (f a) G\n  pb \\<in> proj_set (f b) G\n  ?t \\<in> {a..b} \\<Longrightarrow> D \\<le> infdist (f ?t) G\n  15 / 2 * delta + K + C / 2 \\<le> D\n  deltaG TYPE('a) < delta\n  0 \\<le> C\n  0 \\<le> lambda\n\ngoal (1 subgoal):\n 1. dist (f b) pb + 4 * deltaG TYPE('a) \\<le> dist (f b) qb + K + 4 * delta", "by auto"], ["proof (state)\nthis:\n  dist (f b) pb + 4 * deltaG TYPE('a) \\<le> dist (f b) qb + K + 4 * delta\n\ngoal (1 subgoal):\n 1. dist qb pb \\<le> 4 * delta + K", "finally"], ["proof (chain)\npicking this:\n  dist (f b) qb + dist qb pb \\<le> dist (f b) qb + K + 4 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (f b) qb + dist qb pb \\<le> dist (f b) qb + K + 4 * delta\n\ngoal (1 subgoal):\n 1. dist qb pb \\<le> 4 * delta + K", "by simp"], ["proof (state)\nthis:\n  dist qb pb \\<le> 4 * delta + K\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist qb pb \\<le> 4 * delta + K\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "have \"dist pa pb \\<le> dist pa qa + dist qa qb + dist qb pb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pa pb \\<le> dist pa qa + dist qa qb + dist qb pb", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist pa pb \\<le> dist pa qa + dist qa qb + dist qb pb\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  dist pa pb \\<le> dist pa qa + dist qa qb + dist qb pb", "show ?thesis"], ["proof (prove)\nusing this:\n  dist pa pb \\<le> dist pa qa + dist qa qb + dist qb pb\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "using Q A B"], ["proof (prove)\nusing this:\n  dist pa pb \\<le> dist pa qa + dist qa qb + dist qb pb\n  dist qa qb\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n          exp (- (D - K - C / 2) * ln 2 / (5 * delta)))\n  dist pa qa \\<le> 4 * delta + K\n  dist qb pb \\<le> 4 * delta + K\n\ngoal (1 subgoal):\n 1. dist pa pb\n    \\<le> 2 * K + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n            exp (- (D - K - C / 2) * ln 2 / (5 * delta)))", "by auto"], ["proof (state)\nthis:\n  dist pa pb\n  \\<le> 2 * K + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (b - a) *\n          exp (- (D - K - C / 2) * ln 2 / (5 * delta)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next statement is the main step in the proof of the Morse-Gromov theorem given by Shchur\nin~\\cite{shchur}, asserting that a quasi-geodesic and a geodesic with the same endpoints are close.\nWe show that a point on the quasi-geodesic is close to the geodesic -- the other inequality will\nfollow easily later on. We also assume that the quasi-geodesic is parameterized by a Lipschitz map\n-- the general case will follow as any quasi-geodesic can be approximated by a Lipschitz map with\ngood controls.\n\nHere is a sketch of the proof. Fix two large constants $L \\leq D$ (that we will choose carefully\nto optimize the values of the constants at the end of the proof). Consider a quasi-geodesic $f$\nbetween two points $f(u^-)$ and $f(u^+)$, and a geodesic segment $G$ between the same points.\nFix $f(z)$. We want to find a bound on $d(f(z), G)$.\n1 - If this distance is smaller than $L$, we are done (and the bound is $L$).\n2 - Assume it is larger.\nLet $\\pi_z$ be a projection of $f(z)$ on $G$ (at distance $d(f(z),G)$ of $f(z)$), and $H$ a geodesic\nbetween $z$ and $\\pi_z$. The idea will be to project the image of $f$ on $H$, and record how much\nprogress is made towards $f(z)$. In this proof, we will construct several points before and after\n$z$. When necessary, we put an exponent $-$ on the points before $z$, and $+$ on the points after\n$z$. To ease the reading, the points are ordered following the alphabetical order, i.e., $u^- \\leq v\n\\leq w \\leq x \\leq y^- \\leq z$.\n\nOne can find two points $f(y^-)$ and $f(y^+)$ on the left and the right of $f(z)$ that project\non $H$ roughly at distance $L$ of $\\pi_z$ (up to some $O(\\delta)$ -- recall that the closest point\nprojection is not uniquely defined, and not continuous, so we make some choice here).\nLet $d^-$ be the minimal distance of $f([u^-, y^-])$ to $H$, and let $d^+$ be the minimal distance\nof $f([y^+, u^+)]$ to $H$.\n\n2.1 If the two distances $d^-$ and $d^+$ are less than $D$, then the distance between two points\nrealizing the minimum (say $f(c^-)$ and $f(c^+)$) is at most $2D+L$, hence $c^+ - c^-$ is controlled\n(by $\\lambda \\cdot (2D+L) + C$) thanks to the quasi-isometry property. Therefore, $f(z)$ is not far\naway from $f(c^-)$ and $f(c^+)$ (again by the quasi-isometry property). Since the distance from\nthese points to $\\pi_z$ is controlled (by $D+L$), we get a good control on $d(f(z),\\pi_z)$, as\ndesired.\n\n2.2 The interesting case is when $d^-$ and $d^+$ are both $ > D$. Assume also for instance $d^- \\geq\nd^+$, as the other case is analogous. We will construct two points $f(v)$ and $f(x)$ with $u^- \\leq\nv \\leq x \\leq y^-$ with the following property:\n\\begin{equation}\n\\label{eq:xvK}\n  K_1 e^{K_2 d(f(v), H)} \\leq x-v,\n\\end{equation}\nwhere $K_1$ and $K_2$ are some explicit constants (depending on $\\lambda$, $\\delta$, $L$ and $D$).\nLet us show how this will conclude the proof. The distance from $f(v)$ to $f(c^+)$ is at most\n$d(f(v),H) + L + d^+ \\leq 3 d(f(v), H)$. Therefore, $c^+ - v$ is also controlled by $K' d(f(v), H)$\nby the quasi-isometry property. This gives\n\\begin{align*}\n  K &\\leq K (x - v) e^{-K (c^+ - v)} \\leq (e^{K (x-v)} - 1) \\cdot e^{-K(c^+ - v)}\n    \\\\& = e^{-K (c^+ - x)} - e^{-K (c^+ - v)}\n    \\leq e^{-K(c^+ - x)} - e^{-K (u^+ - u^-)}.\n\\end{align*}\nThis shows that, when one goes from the original quasi-geodesic $f([u^-, u^+])$ to the restricted\nquasi-geodesic $f([x, c^+])$, the quantity $e^{-K \\cdot}$ decreases by a fixed amount. In particular,\nthis process can only happen a uniformly bounded number of times, say $n$.\n\nLet $G'$ be a geodesic between $f(x)$ and $f(c^+)$. One checks geometrically that $d(f(z), G) \\leq\nd(f(z), G') + (L + O(\\delta))$, as both projections of $f(x)$ and $f(c^+)$ on $H$ are within\ndistance $L$ of $\\pi_z$. Iterating the process $n$ times, one gets finally $d(f(z), G) \\leq O(1) + n\n(L + O(\\delta))$. This is the desired bound for $d(f(z), G)$.\n\nTo complete the proof, it remains to construct the points $f(v)$ and $f(x)$ satisfying~\\eqref{eq:xvK}.\nThis will be done through an inductive process.\n\nAssume first that there is a point $f(v)$ whose projection on $H$ is close to the projection of\n$f(u^-)$, and with $d(f(v), H) \\leq 2 d^-$. Then the projections of $f(v)$ and $f(y^-)$ are far away\n(at distance at least $L + O(\\delta)$). Since the portion of $f$ between $v$ and $y^-$ is everywhere\nat distance at least $d^-$ of $H$, the projection on $H$ contracts by a factor $e^{-d^-}$. It\nfollows that this portion of $f$ has length at least $e^{d^-} \\cdot (L+O(\\delta))$. Therefore, by\nthe quasi-isometry property, one gets $x - v \\geq K e^{d^-}$. On the other hand, $d(v, H)$ is\nbounded above by $2 d^-$ by assumption. This gives the desired inequality~\\eqref{eq:xvK} with $x =\ny^-$.\n\nOtherwise, all points $f(v)$ whose projection on $H$ is close to the projection of $f(u^-)$ are such\nthat $d(f(v), H) \\geq 2 d^-$. Consider $f(w_1)$ a point whose projection on $H$ is at distance\nroughly $10 \\delta$ of the projection of $f(u^-)$. Let $V_1$ be the set of points at distance at\nmost $d^-$ of $H$, i.e., the $d_1$-neighborhood of $H$. Then the distance between the projections of\n$f(u^-)$ and $f(w_1)$ on $V_1$ is very large (are there is an additional big contraction to go from\n$V_1$ to $H$). And moreover all the intermediate points $f(v)$ are at distance at least $2 d^-$ of\n$H$, and therefore at distance at least $d^-$ of $H$. Then one can play the same game as in the\nfirst case, where $y^-$ replaced by $w_1$ and $H$ replaced by $V_1$. If there is a point $f(v)$\nwhose projection on $V_1$ is close to the projection of $f(u^-)$, then the pair of points $v$ and $x\n= w_1$ works. Otherwise, one lifts everything to $V_2$, the neighborhood of size $2d^-$ of $V_1$,\nand one argues again in the same way.\n\nThe induction goes on like this until one finds a suitable pair of points. The process has indeed to\nstop at one time, as it can only go on while $f(u^-)$ is outside of $V_k$, the $(2^k-1) d^-$\nneighborhood of $H$). This concludes the sketch of the proof, modulo the adjustment of constants.\n\nComments on the formalization below:\n\\begin{itemize}\n\\item The proof is written as an induction on $u^+ - u^-$. This makes it possible to either prove\nthe bound directly (in the cases 1 and 2.1 above), or to use the bound on $d(z, G')$ in case 2.2\nusing the induction assumption, and conclude the proof. Of course, $u^+ - u^-$ is not integer-valued,\nbut in the reduction to $G'$ it decays by a fixed amount, so one can easily write this down as\na genuine induction.\n\\item The main difficulty in the proof is to construct the pair $(v, x)$ in case 2.2. This is again\nwritten as an induction over $k$: either the required bound is true, or one can find a point $f(w)$\nwhose projection on $V_k$ is far enough from the projection of $f(u^-)$. Then, either one can use\nthis point to prove the bound, or one can construct a point with the same property with respect to\n$V_{k+1}$, concluding the induction.\n\\item Instead of writing $u^-$ and $u^+$ (which are not good variable names in Isabelle), we write\n$um$ and $uM$. Similarly for other variables.\n\\item The proof only works when $\\delta > 0$ (as one needs to divide by $\\delta$\nin the exponential gain). Hence, we formulate it for some $\\delta$ which is\nstrictly larger than the hyperbolicity constant. In a subsequent application of\nthe lemma, we will deduce the same statement for the hyperbolicity constant\nby a limiting argument.\n\\item To optimize the value of the constant in the end, there is an additional important trick with\nrespect to the above sketch: in case 2.2, there is an exponential gain. One can spare a fraction\n$(1-\\alpha)$ of this gain to improve the constants, and spend the remaining fraction $\\alpha$ to\nmake the argument work. This makes it possible to reduce the value of the constant roughly from\n$40000$ to $100$, so we do it in the proof below. The values of $L$, $D$ and $\\alpha$ can be chosen\nfreely, and have been chosen to get the best possible constant in the end.\n\\item For another optimization, we do not induce in terms of the distance from $f(z)$ to the geodesic\n$G$, but rather in terms of the Gromov product $(f(u^-), f(u^+))_{f(z)}$ (which is the same up to\n$O(\\delta)$. And we do not take for $H$ a geodesic from $f(z)$ to its projection on $G$, but rather\na geodesic from $f(z)$ to the point $m$ on $[f(u^-), f(u^+)]$ opposite to $f(z)$ in the tripod, i.e.,\nat distance $(f(z), f(u^+))_{f(u^-)}$ of $f(u^-)$, and at distance $(f(z), f(u^-))_{f(u^+)}$ of\n$f(u^+)$. Let $\\pi_z$ denote the point on $[f(z), m]$ at distance $(f(u^-), f(u^+)_{f(z)}$ of $f(z)$.\n(It is within distance $2 \\delta$ of $m$).\nIn both approaches, what we want to control by induction is the distance from $f(z)$ to $\\pi_z$.\nHowever, in the first approach, the points $f(u^-)$ and $f(u^+)$ project on $H$ between $\\pi_z$ and\n$f(z)$, and since the location of their projection is only controlled up to $4\\delta$ one loses\nessentially a $4\\delta$-length of $L$ for the forthcoming argument. In the second approach, the\nprojections on $H$ are on the other side of $\\pi_z$ compared to $f(z)$, so one does not lose\nanything, and in the end it gives genuinely better bounds (making it possible to gain roughly\n$10 \\delta$ in the final estimate).\n\\end{itemize}\n\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem_aux1:\n  fixes f::\"real \\<Rightarrow> 'a\"\n  assumes \"continuous_on {a..b} f\"\n          \"lambda C-quasi_isometry_on {a..b} f\"\n          \"a \\<le> b\"\n          \"geodesic_segment_between G (f a) (f b)\"\n          \"z \\<in> {a..b}\"\n          \"delta > deltaG(TYPE('a))\"\n  shows \"infdist (f z) G \\<le> lambda^2 * (11/2 * C + 91 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"C \\<ge> 0\" \"lambda \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 1 \\<le> lambda", "using quasi_isometry_onD assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?lambda ?C -quasi_isometry_on ?X ?f; ?x \\<in> ?X;\n   ?y \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> dist (?f ?x) (?f ?y) \\<le> ?lambda * dist ?x ?y + ?C\n  \\<lbrakk>?lambda ?C -quasi_isometry_on ?X ?f; ?x \\<in> ?X;\n   ?y \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> 1 / ?lambda * dist ?x ?y - ?C \\<le> dist (?f ?x) (?f ?y)\n  ?lambda ?C -quasi_isometry_on ?X ?f \\<Longrightarrow> 1 \\<le> ?lambda\n  ?lambda ?C -quasi_isometry_on ?X ?f \\<Longrightarrow> 0 \\<le> ?C\n  continuous_on {a..b} f\n  lambda C -quasi_isometry_on {a..b} f\n  a \\<le> b\n  geodesic_segment_between G (f a) (f b)\n  z \\<in> {a..b}\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 1 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"delta > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < delta", "using assms delta_nonneg order_trans"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n  lambda C -quasi_isometry_on {a..b} f\n  a \\<le> b\n  geodesic_segment_between G (f a) (f b)\n  z \\<in> {a..b}\n  deltaG TYPE('a) < delta\n  0 \\<le> deltaG TYPE('a)\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. 0 < delta", "by linarith"], ["proof (state)\nthis:\n  0 < delta\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "text \\<open>We give their values to the parameters $L$, $D$ and $\\alpha$ that we will use in the proof.\n  We also define two constants $K$ and $K_{mult}$ that appear in the precise formulation of the\n  bounds. Their values have no precise meaning, they are just the outcome of the computation\\<close>"], ["proof (state)\nthis:\n  0 < delta\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "define alpha::real where \"alpha = 12/100\""], ["proof (state)\nthis:\n  alpha = 12 / 100\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have alphaaux:\"alpha > 0\" \"alpha \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < alpha &&& alpha \\<le> 1", "unfolding alpha_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 12 / 100 &&& 12 / 100 \\<le> 1", "by auto"], ["proof (state)\nthis:\n  0 < alpha\n  alpha \\<le> 1\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "define L::real where \"L = 18 * delta\""], ["proof (state)\nthis:\n  L = 18 * delta\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "define D::real where \"D = 55 * delta\""], ["proof (state)\nthis:\n  D = 55 * delta\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "define K where \"K = alpha * ln 2 / (5 * (4 + (L + 2 * delta)/D) * delta * lambda)\""], ["proof (state)\nthis:\n  K = alpha * ln 2 / (5 * (4 + (L + 2 * delta) / D) * delta * lambda)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"K > 0\" \"L > 0\" \"D > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < K &&& 0 < L &&& 0 < D", "unfolding K_def L_def D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < alpha * ln 2 /\n        (5 * (4 + (18 * delta + 2 * delta) / (55 * delta)) * delta *\n         lambda) &&&\n    0 < 18 * delta &&& 0 < 55 * delta", "using \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close> alpha_def"], ["proof (prove)\nusing this:\n  0 < delta\n  1 \\<le> lambda\n  alpha = 12 / 100\n\ngoal (1 subgoal):\n 1. 0 < alpha * ln 2 /\n        (5 * (4 + (18 * delta + 2 * delta) / (55 * delta)) * delta *\n         lambda) &&&\n    0 < 18 * delta &&& 0 < 55 * delta", "by auto"], ["proof (state)\nthis:\n  0 < K\n  0 < L\n  0 < D\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have Laux: \"L \\<ge> 18 * delta\" \"D \\<ge> 50 * delta\" \"L \\<le> D\" \"D \\<le> 4 * L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (18 * delta \\<le> L &&& 50 * delta \\<le> D) &&&\n    L \\<le> D &&& D \\<le> 4 * L", "unfolding L_def D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (18 * delta \\<le> 18 * delta &&& 50 * delta \\<le> 55 * delta) &&&\n    18 * delta \\<le> 55 * delta &&& 55 * delta \\<le> 4 * (18 * delta)", "using \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n\ngoal (1 subgoal):\n 1. (18 * delta \\<le> 18 * delta &&& 50 * delta \\<le> 55 * delta) &&&\n    18 * delta \\<le> 55 * delta &&& 55 * delta \\<le> 4 * (18 * delta)", "by auto"], ["proof (state)\nthis:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have Daux: \"8 * delta \\<le> (1 - alpha) * D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 8 * delta \\<le> (1 - alpha) * D", "unfolding alpha_def D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 8 * delta \\<le> (1 - 12 / 100) * (55 * delta)", "using \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n\ngoal (1 subgoal):\n 1. 8 * delta \\<le> (1 - 12 / 100) * (55 * delta)", "by auto"], ["proof (state)\nthis:\n  8 * delta \\<le> (1 - alpha) * D\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "define Kmult where \"Kmult = ((L + 4 * delta)/(L - 13 * delta)) * ((4 * exp(1/2 * ln 2)) * lambda * exp (- (1 - alpha) * D * ln 2 / (5 * delta)) / K)\""], ["proof (state)\nthis:\n  Kmult =\n  (L + 4 * delta) / (L - 13 * delta) *\n  (4 * exp (1 / 2 * ln 2) * lambda *\n   exp (- (1 - alpha) * D * ln 2 / (5 * delta)) /\n   K)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"Kmult > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Kmult", "unfolding Kmult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) /\n         K)", "using Laux \\<open>delta > 0\\<close> \\<open>K > 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < delta\n  0 < K\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 < (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) /\n         K)", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  0 < Kmult\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "text \\<open>We prove that, for any pair of points to the left and to the right of $f(z)$, the distance\n  from $f(z)$ to a geodesic between these points is controlled. We prove this by reducing to a\n  closer pair of points, i.e., this is an inductive argument over real numbers. However, we\n  formalize it as an artificial induction over natural numbers, as this is how induction works\n  best, and since in our reduction step the new pair of points is always significantly closer\n  than the initial one, at least by an amount $\\delta/\\lambda$.\n\n  The main inductive bound that we will prove is the following. In this bound, the first term is\n  what comes from the trivial cases 1 and 2.1 in the description of the proof before the statement\n  of the theorem, while the most interesting term is the second term, corresponding to the induction\n  per se.\\<close>"], ["proof (state)\nthis:\n  0 < Kmult\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have Main: \"\\<And>um uM. um \\<in> {a..z} \\<Longrightarrow> uM \\<in> {z..b}\n          \\<Longrightarrow> uM - um \\<le> n * (1/4) * delta / lambda\n          \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM) \\<le> lambda^2 * (D + (3/2) * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(- K * (uM - um)))\"\n    for n::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real 0 * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Trivial base case of the induction\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real 0 * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "case 0"], ["proof (state)\nthis:\n  um \\<in> {a..z}\n  uM \\<in> {z..b}\n  uM - um \\<le> real 0 * (1 / 4) * delta / lambda\n\ngoal (2 subgoals):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real 0 * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  um \\<in> {a..z}\n  uM \\<in> {z..b}\n  uM - um \\<le> real 0 * (1 / 4) * delta / lambda", "have *: \"z = um\" \"z = uM\""], ["proof (prove)\nusing this:\n  um \\<in> {a..z}\n  uM \\<in> {z..b}\n  uM - um \\<le> real 0 * (1 / 4) * delta / lambda\n\ngoal (1 subgoal):\n 1. z = um &&& z = uM", "by auto"], ["proof (state)\nthis:\n  z = um\n  z = uM\n\ngoal (2 subgoals):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real 0 * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  z = um\n  z = uM", "have \"Gromov_product_at (f z) (f um) (f uM) = 0\""], ["proof (prove)\nusing this:\n  z = um\n  z = uM\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM) = 0", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) = 0\n\ngoal (2 subgoals):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real 0 * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) = 0\n\ngoal (2 subgoals):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real 0 * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "have \"... \\<le> 1 * (D + (3/2) * L + delta + 11/2 * C) - 2 * delta + 0 * (1 - exp(- K * (uM - um)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n            0 * (1 - exp (- K * (uM - um)))", "using Laux \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 \\<le> C\n  0 < delta\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n            0 * (1 - exp (- K * (uM - um)))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n          0 * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real 0 * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  0 \\<le> 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n          0 * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real 0 * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "have \"... \\<le> lambda^2 * (D + (3/2) * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(- K * (uM - um)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    0 * (1 - exp (- K * (uM - um)))\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> D + 3 / 2 * L + delta + 11 / 2 * C\n 3. 0 \\<le> Kmult\n 4. 0 \\<le> 1 - exp (- K * (uM - um))", "using \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close> Laux \\<open>D > 0\\<close> \\<open>K > 0\\<close> \"0.prems\" \\<open>lambda \\<ge> 1\\<close> \\<open>Kmult > 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  0 < delta\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < D\n  0 < K\n  um \\<in> {a..z}\n  uM \\<in> {z..b}\n  uM - um \\<le> real 0 * (1 / 4) * delta / lambda\n  1 \\<le> lambda\n  0 < Kmult\n\ngoal (4 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> D + 3 / 2 * L + delta + 11 / 2 * C\n 3. 0 \\<le> Kmult\n 4. 0 \\<le> 1 - exp (- K * (uM - um))", "by auto"], ["proof (state)\nthis:\n  1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n  0 * (1 - exp (- K * (uM - um)))\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<And>um uM.\n       \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real 0 * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))", "show ?case"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?um \\<in> {a..z}; ?uM \\<in> {z..b};\n   ?uM - ?um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n  \\<Longrightarrow> Gromov_product_at (f z) (f ?um) (f ?uM)\n                    \\<le> lambda\\<^sup>2 *\n                          (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                          2 * delta +\n                          Kmult * (1 - exp (- K * (?uM - ?um)))\n  um \\<in> {a..z}\n  uM \\<in> {z..b}\n  uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\n\ngoal (1 subgoal):\n 1. \\<And>n um uM.\n       \\<lbrakk>\\<And>um uM.\n                   \\<lbrakk>um \\<in> {a..z}; uM \\<in> {z..b};\n                    uM - um \\<le> real n * (1 / 4) * delta / lambda\\<rbrakk>\n                   \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                                     \\<le> lambda\\<^sup>2 *\n     (D + 3 / 2 * L + delta + 11 / 2 * C) -\n     2 * delta +\n     Kmult * (1 - exp (- K * (uM - um)));\n        um \\<in> {a..z}; uM \\<in> {z..b};\n        uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\\<rbrakk>\n       \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                         \\<le> lambda\\<^sup>2 *\n                               (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                               2 * delta +\n                               Kmult * (1 - exp (- K * (uM - um)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "proof (cases \"Gromov_product_at (f z) (f um) (f uM) \\<le> L\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>If $f(z)$ is already close to the geodesic, there is nothing to do, and we do not need\n      the induction assumption. This is case 1 in the description above.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "case True"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> L\n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"L \\<le> 1 * (D + (3/2) * L + delta + 11/2 * C) - 2 * delta + 0 * (1 - exp(- K * (uM - um)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<le> 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n            0 * (1 - exp (- K * (uM - um)))", "using Laux \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 \\<le> C\n  0 < delta\n\ngoal (1 subgoal):\n 1. L \\<le> 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n            0 * (1 - exp (- K * (uM - um)))", "by auto"], ["proof (state)\nthis:\n  L \\<le> 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n          0 * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  L \\<le> 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n          0 * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... \\<le> lambda^2 * (D + (3/2) * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(- K * (uM - um)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    0 * (1 - exp (- K * (uM - um)))\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> D + 3 / 2 * L + delta + 11 / 2 * C\n 3. 0 \\<le> Kmult\n 4. 0 \\<le> 1 - exp (- K * (uM - um))", "using \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close> Laux \\<open>D > 0\\<close> \"Suc.prems\" \\<open>K > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>Kmult > 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  0 < delta\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < D\n  um \\<in> {a..z}\n  uM \\<in> {z..b}\n  uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\n  0 < K\n  1 \\<le> lambda\n  0 < Kmult\n\ngoal (4 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> D + 3 / 2 * L + delta + 11 / 2 * C\n 3. 0 \\<le> Kmult\n 4. 0 \\<le> 1 - exp (- K * (uM - um))", "by auto"], ["proof (state)\nthis:\n  1 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n  0 * (1 - exp (- K * (uM - um)))\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  L \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "show ?thesis"], ["proof (prove)\nusing this:\n  L \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "using True"], ["proof (prove)\nusing this:\n  L \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n  Gromov_product_at (f z) (f um) (f uM) \\<le> L\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>We come to the interesting case where $f(z)$ is far away from a geodesic between\n      $f(um)$ and $f(uM)$. Let $m$ be close to a projection of $f(z)$ on such a geodesic (we use\n      the opposite point of $f(z)$ on the corresponding tripod). On a geodesic between $f(z)$ and $m$,\n      consider the point $pi_z$ at distance $(f(um), f(uM))_{f(z)}$ of $f(z)$. It is very close to\n      $m$ (within distance $2 \\delta$). We will push the points $f(um)$ and $f(uM)$\n      towards $f(z)$ by considering points whose projection on a geodesic $H$ between $m$ and\n      $z$ is roughly at distance $L$ of $pi_z$.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "case False"], ["proof (state)\nthis:\n  \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define m where \"m = geodesic_segment_param {f um--f uM} (f um) (Gromov_product_at (f um) (f z) (f uM))\""], ["proof (state)\nthis:\n  m =\n  geodesic_segment_param {f um--f uM} (f um)\n   (Gromov_product_at (f um) (f z) (f uM))\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"dist (f z) m \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) m\n    \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * deltaG TYPE('a)", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z)\n     (geodesic_segment_param {f um--f uM} (f um)\n       (Gromov_product_at (f um) (f z) (f uM)))\n    \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * deltaG TYPE('a)", "by (rule dist_triangle_side_middle, auto)"], ["proof (state)\nthis:\n  dist (f z) m\n  \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  dist (f z) m\n  \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * deltaG TYPE('a)", "have *: \"dist (f z) m \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * delta\""], ["proof (prove)\nusing this:\n  dist (f z) m\n  \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (f z) m \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * delta", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  dist (f z) m\n  \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * deltaG TYPE('a)\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. dist (f z) m \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * delta", "by auto"], ["proof (state)\nthis:\n  dist (f z) m \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * delta\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"Gromov_product_at (f z) (f um) (f uM) \\<le> infdist (f z) {f um--f uM}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> infdist (f z) {f um--f uM}", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> infdist (f z) {f um--f uM}\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> infdist (f z) {f um--f uM}\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... \\<le> dist (f z) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f z) {f um--f uM} \\<le> dist (f z) m", "apply (rule infdist_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> {f um--f uM}", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {f um--f uM} (f um)\n     (Gromov_product_at (f um) (f z) (f uM))\n    \\<in> {f um--f uM}", "by auto"], ["proof (state)\nthis:\n  infdist (f z) {f um--f uM} \\<le> dist (f z) m\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> dist (f z) m", "have **: \"Gromov_product_at (f z) (f um) (f uM) \\<le> dist (f z) m\""], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> dist (f z) m\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> dist (f z) m", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> dist (f z) m\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define H where \"H = {f z--m}\""], ["proof (state)\nthis:\n  H = {f z--m}\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define pi_z where \"pi_z = geodesic_segment_param H (f z) (Gromov_product_at (f z) (f um) (f uM))\""], ["proof (state)\nthis:\n  pi_z =\n  geodesic_segment_param H (f z) (Gromov_product_at (f z) (f um) (f uM))\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"pi_z \\<in> H\" \"m \\<in> H\" \"f z \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi_z \\<in> H &&& m \\<in> H &&& f z \\<in> H", "unfolding pi_z_def H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {f z--m} (f z)\n     (Gromov_product_at (f z) (f um) (f uM))\n    \\<in> {f z--m} &&&\n    m \\<in> {f z--m} &&& f z \\<in> {f z--m}", "by (auto simp add: geodesic_segment_param_in_segment)"], ["proof (state)\nthis:\n  pi_z \\<in> H\n  m \\<in> H\n  f z \\<in> H\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have H: \"geodesic_segment_between H (f z) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between H (f z) m", "unfolding H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between {f z--m} (f z) m", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between H (f z) m\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have Dpi_z: \"dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)", "unfolding pi_z_def H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z)\n     (geodesic_segment_param {f z--m} (f z)\n       (Gromov_product_at (f z) (f um) (f uM))) =\n    Gromov_product_at (f z) (f um) (f uM)", "by (rule geodesic_segment_param(6)[where ?y = m], auto simp add: **)"], ["proof (state)\nthis:\n  dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "moreover"], ["proof (state)\nthis:\n  dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"dist (f z) m = dist (f z) pi_z + dist pi_z m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) m = dist (f z) pi_z + dist pi_z m", "apply (rule geodesic_segment_dist[of H, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. geodesic_segment_between H (f z) m\n 2. pi_z \\<in> H", "using \\<open>pi_z \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  pi_z \\<in> H\n\ngoal (2 subgoals):\n 1. geodesic_segment_between H (f z) m\n 2. pi_z \\<in> H", "unfolding H_def"], ["proof (prove)\nusing this:\n  pi_z \\<in> {f z--m}\n\ngoal (2 subgoals):\n 1. geodesic_segment_between {f z--m} (f z) m\n 2. pi_z \\<in> {f z--m}", "by auto"], ["proof (state)\nthis:\n  dist (f z) m = dist (f z) pi_z + dist pi_z m\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "ultimately"], ["proof (chain)\npicking this:\n  dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\n  dist (f z) m = dist (f z) pi_z + dist pi_z m", "have \"dist pi_z m \\<le> 2 * delta\""], ["proof (prove)\nusing this:\n  dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\n  dist (f z) m = dist (f z) pi_z + dist pi_z m\n\ngoal (1 subgoal):\n 1. dist pi_z m \\<le> 2 * delta", "using *"], ["proof (prove)\nusing this:\n  dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\n  dist (f z) m = dist (f z) pi_z + dist pi_z m\n  dist (f z) m \\<le> Gromov_product_at (f z) (f um) (f uM) + 2 * delta\n\ngoal (1 subgoal):\n 1. dist pi_z m \\<le> 2 * delta", "by auto"], ["proof (state)\nthis:\n  dist pi_z m \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Introduce the notation $p$ for some projection on the geodesic $H$.\\<close>"], ["proof (state)\nthis:\n  dist pi_z m \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define p where \"p = (\\<lambda>r. SOME x. x \\<in> proj_set (f r) H)\""], ["proof (state)\nthis:\n  p = (\\<lambda>r. SOME x. x \\<in> proj_set (f r) H)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have p: \"p x \\<in> proj_set (f x) H\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. p x \\<in> proj_set (f x) H", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME xa. xa \\<in> proj_set (f x) H) \\<in> proj_set (f x) H", "using proj_set_nonempty_of_proper[of H \"f x\"] geodesic_segment_topology[OF geodesic_segmentI[OF H]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>proper H; H \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> proj_set (f x) H \\<noteq> {}\n  compact H\n  connected H\n  path_connected H\n  bounded H\n  closed H\n  H \\<noteq> {}\n  proper H\n\ngoal (1 subgoal):\n 1. (SOME xa. xa \\<in> proj_set (f x) H) \\<in> proj_set (f x) H", "by (simp add: some_in_eq)"], ["proof (state)\nthis:\n  p ?x \\<in> proj_set (f ?x) H\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  p ?x \\<in> proj_set (f ?x) H", "have pH: \"p x \\<in> H\" for x"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n\ngoal (1 subgoal):\n 1. p x \\<in> H", "using proj_setD(1)"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n  ?y \\<in> proj_set ?x ?A \\<Longrightarrow> ?y \\<in> ?A\n\ngoal (1 subgoal):\n 1. p x \\<in> H", "by auto"], ["proof (state)\nthis:\n  p ?x \\<in> H\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have pz: \"p z = f z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p z = f z", "using p[of z] H"], ["proof (prove)\nusing this:\n  p z \\<in> proj_set (f z) H\n  geodesic_segment_between H (f z) m\n\ngoal (1 subgoal):\n 1. p z = f z", "by auto"], ["proof (state)\nthis:\n  p z = f z\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>The projection of $f(um)$ on $H$ is close to $pi_z$ (but it does not have to be exactly\n      $pi_z$). It is between $pi_z$ and $m$.\\<close>"], ["proof (state)\nthis:\n  p z = f z\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"dist (f um) (f z) \\<le> dist (f um) (p um) + dist (p um) (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f um) (f z) \\<le> dist (f um) (p um) + dist (p um) (f z)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f um) (f z) \\<le> dist (f um) (p um) + dist (p um) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  dist (f um) (f z) \\<le> dist (f um) (p um) + dist (p um) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... \\<le> dist (f um) m + dist (p um) (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f um) (p um) + dist (p um) (f z)\n    \\<le> dist (f um) m + dist (p um) (f z)", "unfolding proj_setD(2)[OF p[of um]] H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f um) {f z--m} + dist (p um) (f z)\n    \\<le> dist (f um) m + dist (p um) (f z)", "by (auto intro!: infdist_le)"], ["proof (state)\nthis:\n  dist (f um) (p um) + dist (p um) (f z)\n  \\<le> dist (f um) m + dist (p um) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  dist (f um) (p um) + dist (p um) (f z)\n  \\<le> dist (f um) m + dist (p um) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... = Gromov_product_at (f um) (f z) (f uM) + dist (p um) (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f um) m + dist (p um) (f z) =\n    Gromov_product_at (f um) (f z) (f uM) + dist (p um) (f z)", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f um)\n     (geodesic_segment_param {f um--f uM} (f um)\n       (Gromov_product_at (f um) (f z) (f uM))) +\n    dist (p um) (f z) =\n    Gromov_product_at (f um) (f z) (f uM) + dist (p um) (f z)", "by simp"], ["proof (state)\nthis:\n  dist (f um) m + dist (p um) (f z) =\n  Gromov_product_at (f um) (f z) (f uM) + dist (p um) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  dist (f um) (f z)\n  \\<le> Gromov_product_at (f um) (f z) (f uM) + dist (p um) (f z)", "have A: \"Gromov_product_at (f z) (f um) (f uM) \\<le> dist (p um) (f z)\""], ["proof (prove)\nusing this:\n  dist (f um) (f z)\n  \\<le> Gromov_product_at (f um) (f z) (f uM) + dist (p um) (f z)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> dist (p um) (f z)", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist (f um) (f z)\n  \\<le> (dist (f um) (f z) + dist (f um) (f uM) - dist (f z) (f uM)) / 2 +\n        dist (p um) (f z)\n\ngoal (1 subgoal):\n 1. (dist (f z) (f um) + dist (f z) (f uM) - dist (f um) (f uM)) / 2\n    \\<le> dist (p um) (f z)", "by (simp add: metric_space_class.dist_commute divide_simps)"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> dist (p um) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"dist (p um) pi_z = abs(dist (p um) (f z) - dist pi_z (f z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p um) pi_z = \\<bar>dist (p um) (f z) - dist pi_z (f z)\\<bar>", "apply (rule dist_along_geodesic_wrt_endpoint[of H _ m])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment_between H (f z) m\n 2. p um \\<in> H\n 3. pi_z \\<in> H", "using pH \\<open>pi_z \\<in> H\\<close> H_def"], ["proof (prove)\nusing this:\n  p ?x \\<in> H\n  pi_z \\<in> H\n  H = {f z--m}\n\ngoal (3 subgoals):\n 1. geodesic_segment_between H (f z) m\n 2. p um \\<in> H\n 3. pi_z \\<in> H", "by auto"], ["proof (state)\nthis:\n  dist (p um) pi_z = \\<bar>dist (p um) (f z) - dist pi_z (f z)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  dist (p um) pi_z = \\<bar>dist (p um) (f z) - dist pi_z (f z)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... = dist (p um) (f z) - dist pi_z (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dist (p um) (f z) - dist pi_z (f z)\\<bar> =\n    dist (p um) (f z) - dist pi_z (f z)", "using A Dpi_z"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> dist (p um) (f z)\n  dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\n\ngoal (1 subgoal):\n 1. \\<bar>dist (p um) (f z) - dist pi_z (f z)\\<bar> =\n    dist (p um) (f z) - dist pi_z (f z)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  \\<bar>dist (p um) (f z) - dist pi_z (f z)\\<bar> =\n  dist (p um) (f z) - dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  dist (p um) pi_z = dist (p um) (f z) - dist pi_z (f z)", "have Dum: \"dist (p um) (f z) = dist (p um) pi_z + dist pi_z (f z)\""], ["proof (prove)\nusing this:\n  dist (p um) pi_z = dist (p um) (f z) - dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. dist (p um) (f z) = dist (p um) pi_z + dist pi_z (f z)", "by auto"], ["proof (state)\nthis:\n  dist (p um) (f z) = dist (p um) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Choose a point $f(ym)$ whose projection on $H$ is roughly at distance $L$ of $pi_z$.\\<close>"], ["proof (state)\nthis:\n  dist (p um) (f z) = dist (p um) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"\\<exists>ym \\<in> {um..z}. (dist (p um) (p ym) \\<in> {(L + dist pi_z (p um)) - 4 * delta - 2 * 0 .. L + dist pi_z (p um)})\n                    \\<and> (\\<forall>r \\<in> {um..ym}. dist (p um) (p r) \\<le> L + dist pi_z (p um))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ym\\<in>{um..z}.\n       dist (p um) (p ym)\n       \\<in> {L + dist pi_z (p um) - 4 * delta -\n              2 * 0..L + dist pi_z (p um)} \\<and>\n       (\\<forall>r\\<in>{um..ym}.\n           dist (p um) (p r) \\<le> L + dist pi_z (p um))", "proof (rule quasi_convex_projection_small_gaps[where ?f = f and ?G = H])"], ["proof (state)\ngoal (6 subgoals):\n 1. continuous_on {um..z} f\n 2. um \\<le> z\n 3. quasiconvex 0 H\n 4. \\<And>ym.\n       ym \\<in> {um..z} \\<Longrightarrow> p ym \\<in> proj_set (f ym) H\n 5. deltaG TYPE('a) < delta\n 6. L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}", "show \"continuous_on {um..z} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {um..z} f", "apply (rule continuous_on_subset[OF \\<open>continuous_on {a..b} f\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {um..z} \\<subseteq> {a..b}", "using \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. {um..z} \\<subseteq> {a..b}", "by auto"], ["proof (state)\nthis:\n  continuous_on {um..z} f\n\ngoal (5 subgoals):\n 1. um \\<le> z\n 2. quasiconvex 0 H\n 3. \\<And>ym.\n       ym \\<in> {um..z} \\<Longrightarrow> p ym \\<in> proj_set (f ym) H\n 4. deltaG TYPE('a) < delta\n 5. L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}", "show \"um \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. um \\<le> z", "using \\<open>um \\<in> {a..z}\\<close>"], ["proof (prove)\nusing this:\n  um \\<in> {a..z}\n\ngoal (1 subgoal):\n 1. um \\<le> z", "by auto"], ["proof (state)\nthis:\n  um \\<le> z\n\ngoal (4 subgoals):\n 1. quasiconvex 0 H\n 2. \\<And>ym.\n       ym \\<in> {um..z} \\<Longrightarrow> p ym \\<in> proj_set (f ym) H\n 3. deltaG TYPE('a) < delta\n 4. L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}", "show \"quasiconvex 0 H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex 0 H", "using quasiconvex_of_geodesic geodesic_segmentI H"], ["proof (prove)\nusing this:\n  geodesic_segment ?G \\<Longrightarrow> quasiconvex 0 ?G\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> geodesic_segment ?G\n  geodesic_segment_between H (f z) m\n\ngoal (1 subgoal):\n 1. quasiconvex 0 H", "by auto"], ["proof (state)\nthis:\n  quasiconvex 0 H\n\ngoal (3 subgoals):\n 1. \\<And>ym.\n       ym \\<in> {um..z} \\<Longrightarrow> p ym \\<in> proj_set (f ym) H\n 2. deltaG TYPE('a) < delta\n 3. L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}", "show \"deltaG TYPE('a) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) < delta", "by fact"], ["proof (state)\nthis:\n  deltaG TYPE('a) < delta\n\ngoal (2 subgoals):\n 1. \\<And>ym.\n       ym \\<in> {um..z} \\<Longrightarrow> p ym \\<in> proj_set (f ym) H\n 2. L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}", "have \"L + dist pi_z (p um) \\<le> dist (f z) pi_z + dist pi_z (p um)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L + dist pi_z (p um) \\<le> dist (f z) pi_z + dist pi_z (p um)", "using False Dpi_z"], ["proof (prove)\nusing this:\n  \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L\n  dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p um) \\<le> dist (f z) pi_z + dist pi_z (p um)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  L + dist pi_z (p um) \\<le> dist (f z) pi_z + dist pi_z (p um)\n\ngoal (2 subgoals):\n 1. \\<And>ym.\n       ym \\<in> {um..z} \\<Longrightarrow> p ym \\<in> proj_set (f ym) H\n 2. L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}", "then"], ["proof (chain)\npicking this:\n  L + dist pi_z (p um) \\<le> dist (f z) pi_z + dist pi_z (p um)", "have \"L + dist pi_z (p um) \\<le> dist (p um) (f z)\""], ["proof (prove)\nusing this:\n  L + dist pi_z (p um) \\<le> dist (f z) pi_z + dist pi_z (p um)\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p um) \\<le> dist (p um) (f z)", "using Dum"], ["proof (prove)\nusing this:\n  L + dist pi_z (p um) \\<le> dist (f z) pi_z + dist pi_z (p um)\n  dist (p um) (f z) = dist (p um) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p um) \\<le> dist (p um) (f z)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  L + dist pi_z (p um) \\<le> dist (p um) (f z)\n\ngoal (2 subgoals):\n 1. \\<And>ym.\n       ym \\<in> {um..z} \\<Longrightarrow> p ym \\<in> proj_set (f ym) H\n 2. L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}", "then"], ["proof (chain)\npicking this:\n  L + dist pi_z (p um) \\<le> dist (p um) (f z)", "show \"L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}\""], ["proof (prove)\nusing this:\n  L + dist pi_z (p um) \\<le> dist (p um) (f z)\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}", "using \\<open>delta > 0\\<close> False L_def pz"], ["proof (prove)\nusing this:\n  L + dist pi_z (p um) \\<le> dist (p um) (f z)\n  0 < delta\n  \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L\n  L = 18 * delta\n  p z = f z\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}", "by auto"], ["proof (state)\nthis:\n  L + dist pi_z (p um) \\<in> {4 * delta + 2 * 0..dist (p um) (p z)}\n\ngoal (1 subgoal):\n 1. \\<And>ym.\n       ym \\<in> {um..z} \\<Longrightarrow> p ym \\<in> proj_set (f ym) H", "show \"p ym \\<in> proj_set (f ym) H\" for ym"], ["proof (prove)\ngoal (1 subgoal):\n 1. p ym \\<in> proj_set (f ym) H", "using p"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n\ngoal (1 subgoal):\n 1. p ym \\<in> proj_set (f ym) H", "by simp"], ["proof (state)\nthis:\n  p ?ym \\<in> proj_set (f ?ym) H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ym\\<in>{um..z}.\n     dist (p um) (p ym)\n     \\<in> {L + dist pi_z (p um) - 4 * delta -\n            2 * 0..L + dist pi_z (p um)} \\<and>\n     (\\<forall>r\\<in>{um..ym}. dist (p um) (p r) \\<le> L + dist pi_z (p um))\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>ym\\<in>{um..z}.\n     dist (p um) (p ym)\n     \\<in> {L + dist pi_z (p um) - 4 * delta -\n            2 * 0..L + dist pi_z (p um)} \\<and>\n     (\\<forall>r\\<in>{um..ym}. dist (p um) (p r) \\<le> L + dist pi_z (p um))", "obtain ym where ym : \"ym \\<in> {um..z}\"\n                                \"dist (p um) (p ym) \\<in> {(L + dist pi_z (p um)) - 4 * delta - 2 * 0 .. L + dist pi_z (p um)}\"\n                                \"\\<And>r. r \\<in> {um..ym} \\<Longrightarrow> dist (p um) (p r) \\<le> L + dist pi_z (p um)\""], ["proof (prove)\nusing this:\n  \\<exists>ym\\<in>{um..z}.\n     dist (p um) (p ym)\n     \\<in> {L + dist pi_z (p um) - 4 * delta -\n            2 * 0..L + dist pi_z (p um)} \\<and>\n     (\\<forall>r\\<in>{um..ym}. dist (p um) (p r) \\<le> L + dist pi_z (p um))\n\ngoal (1 subgoal):\n 1. (\\<And>ym.\n        \\<lbrakk>ym \\<in> {um..z};\n         dist (p um) (p ym)\n         \\<in> {L + dist pi_z (p um) - 4 * delta -\n                2 * 0..L + dist pi_z (p um)};\n         \\<And>r.\n            r \\<in> {um..ym} \\<Longrightarrow>\n            dist (p um) (p r) \\<le> L + dist pi_z (p um)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ym \\<in> {um..z}\n  dist (p um) (p ym)\n  \\<in> {L + dist pi_z (p um) - 4 * delta - 2 * 0..L + dist pi_z (p um)}\n  ?r \\<in> {um..ym} \\<Longrightarrow>\n  dist (p um) (p ?r) \\<le> L + dist pi_z (p um)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have *: \"continuous_on {um..ym} (\\<lambda>r. infdist (f r) H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {um..ym} (\\<lambda>r. infdist (f r) H)", "using continuous_on_infdist[OF continuous_on_subset[OF \\<open>continuous_on {a..b} f\\<close>, of \"{um..ym}\"], of H]\n        \\<open>ym \\<in> {um..z}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  {um..ym} \\<subseteq> {a..b} \\<Longrightarrow>\n  continuous_on {um..ym} (\\<lambda>x. infdist (f x) H)\n  ym \\<in> {um..z}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. continuous_on {um..ym} (\\<lambda>r. infdist (f r) H)", "by auto"], ["proof (state)\nthis:\n  continuous_on {um..ym} (\\<lambda>r. infdist (f r) H)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Choose a point $cm$ between $f(um)$ and $f(ym)$ realizing the minimal distance to $H$.\n      Call this distance $dm$.\\<close>"], ["proof (state)\nthis:\n  continuous_on {um..ym} (\\<lambda>r. infdist (f r) H)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"\\<exists>closestm \\<in> {um..ym}. \\<forall>v \\<in> {um..ym}. infdist (f closestm) H \\<le> infdist (f v) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>closestm\\<in>{um..ym}.\n       \\<forall>v\\<in>{um..ym}. infdist (f closestm) H \\<le> infdist (f v) H", "apply (rule continuous_attains_inf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. compact {um..ym}\n 2. {um..ym} \\<noteq> {}\n 3. continuous_on {um..ym} (\\<lambda>x. infdist (f x) H)", "using ym(1) *"], ["proof (prove)\nusing this:\n  ym \\<in> {um..z}\n  continuous_on {um..ym} (\\<lambda>r. infdist (f r) H)\n\ngoal (3 subgoals):\n 1. compact {um..ym}\n 2. {um..ym} \\<noteq> {}\n 3. continuous_on {um..ym} (\\<lambda>x. infdist (f x) H)", "by auto"], ["proof (state)\nthis:\n  \\<exists>closestm\\<in>{um..ym}.\n     \\<forall>v\\<in>{um..ym}. infdist (f closestm) H \\<le> infdist (f v) H\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>closestm\\<in>{um..ym}.\n     \\<forall>v\\<in>{um..ym}. infdist (f closestm) H \\<le> infdist (f v) H", "obtain closestm where closestm: \"closestm \\<in> {um..ym}\" \"\\<And>v. v \\<in> {um..ym} \\<Longrightarrow> infdist (f closestm) H \\<le> infdist (f v) H\""], ["proof (prove)\nusing this:\n  \\<exists>closestm\\<in>{um..ym}.\n     \\<forall>v\\<in>{um..ym}. infdist (f closestm) H \\<le> infdist (f v) H\n\ngoal (1 subgoal):\n 1. (\\<And>closestm.\n        \\<lbrakk>closestm \\<in> {um..ym};\n         \\<And>v.\n            v \\<in> {um..ym} \\<Longrightarrow>\n            infdist (f closestm) H \\<le> infdist (f v) H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  closestm \\<in> {um..ym}\n  ?v \\<in> {um..ym} \\<Longrightarrow>\n  infdist (f closestm) H \\<le> infdist (f ?v) H\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define dm where \"dm = infdist (f closestm) H\""], ["proof (state)\nthis:\n  dm = infdist (f closestm) H\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have [simp]: \"dm \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> dm", "unfolding dm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> infdist (f closestm) H", "using infdist_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> infdist ?x ?A\n\ngoal (1 subgoal):\n 1. 0 \\<le> infdist (f closestm) H", "by auto"], ["proof (state)\nthis:\n  0 \\<le> dm\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Same things but in the interval $[z, uM]$.\\<close>"], ["proof (state)\nthis:\n  0 \\<le> dm\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have I: \"dist m (f uM) = dist (f um) (f uM) - dist (f um) m\"\n              \"dist (f um) m = Gromov_product_at (f um) (f z) (f uM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m (f uM) = dist (f um) (f uM) - dist (f um) m &&&\n    dist (f um) m = Gromov_product_at (f um) (f z) (f uM)", "using geodesic_segment_dist[of \"{f um--f uM}\" \"f um\" \"f uM\" m] m_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>geodesic_segment_between {f um--f uM} (f um) (f uM);\n   m \\<in> {f um--f uM}\\<rbrakk>\n  \\<Longrightarrow> dist (f um) m + dist m (f uM) = dist (f um) (f uM)\n  m =\n  geodesic_segment_param {f um--f uM} (f um)\n   (Gromov_product_at (f um) (f z) (f uM))\n\ngoal (1 subgoal):\n 1. dist m (f uM) = dist (f um) (f uM) - dist (f um) m &&&\n    dist (f um) m = Gromov_product_at (f um) (f z) (f uM)", "by auto"], ["proof (state)\nthis:\n  dist m (f uM) = dist (f um) (f uM) - dist (f um) m\n  dist (f um) m = Gromov_product_at (f um) (f z) (f uM)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"dist (f uM) (f z) \\<le> dist (f uM) (p uM) + dist (p uM) (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f uM) (f z) \\<le> dist (f uM) (p uM) + dist (p uM) (f z)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f uM) (f z) \\<le> dist (f uM) (p uM) + dist (p uM) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  dist (f uM) (f z) \\<le> dist (f uM) (p uM) + dist (p uM) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... \\<le> dist (f uM) m + dist (p uM) (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f uM) (p uM) + dist (p uM) (f z)\n    \\<le> dist (f uM) m + dist (p uM) (f z)", "unfolding proj_setD(2)[OF p[of uM]] H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f uM) {f z--m} + dist (p uM) (f z)\n    \\<le> dist (f uM) m + dist (p uM) (f z)", "by (auto intro!: infdist_le)"], ["proof (state)\nthis:\n  dist (f uM) (p uM) + dist (p uM) (f z)\n  \\<le> dist (f uM) m + dist (p uM) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  dist (f uM) (p uM) + dist (p uM) (f z)\n  \\<le> dist (f uM) m + dist (p uM) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... = Gromov_product_at (f uM) (f z) (f um) + dist (p uM) (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f uM) m + dist (p uM) (f z) =\n    Gromov_product_at (f uM) (f z) (f um) + dist (p uM) (f z)", "using I"], ["proof (prove)\nusing this:\n  dist m (f uM) = dist (f um) (f uM) - dist (f um) m\n  dist (f um) m = Gromov_product_at (f um) (f z) (f uM)\n\ngoal (1 subgoal):\n 1. dist (f uM) m + dist (p uM) (f z) =\n    Gromov_product_at (f uM) (f z) (f um) + dist (p uM) (f z)", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist m (f uM) = dist (f um) (f uM) - dist (f um) m\n  dist (f um) m =\n  (dist (f um) (f z) + dist (f um) (f uM) - dist (f z) (f uM)) / 2\n\ngoal (1 subgoal):\n 1. dist (f uM) m + dist (p uM) (f z) =\n    (dist (f uM) (f z) + dist (f uM) (f um) - dist (f z) (f um)) / 2 +\n    dist (p uM) (f z)", "by (simp add: divide_simps algebra_simps metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (f uM) m + dist (p uM) (f z) =\n  Gromov_product_at (f uM) (f z) (f um) + dist (p uM) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  dist (f uM) (f z)\n  \\<le> Gromov_product_at (f uM) (f z) (f um) + dist (p uM) (f z)", "have A: \"Gromov_product_at (f z) (f um) (f uM) \\<le> dist (p uM) (f z)\""], ["proof (prove)\nusing this:\n  dist (f uM) (f z)\n  \\<le> Gromov_product_at (f uM) (f z) (f um) + dist (p uM) (f z)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM) \\<le> dist (p uM) (f z)", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist (f uM) (f z)\n  \\<le> (dist (f uM) (f z) + dist (f uM) (f um) - dist (f z) (f um)) / 2 +\n        dist (p uM) (f z)\n\ngoal (1 subgoal):\n 1. (dist (f z) (f um) + dist (f z) (f uM) - dist (f um) (f uM)) / 2\n    \\<le> dist (p uM) (f z)", "by (simp add: metric_space_class.dist_commute divide_simps)"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> dist (p uM) (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"dist (p uM) pi_z = abs(dist (p uM) (f z) - dist pi_z (f z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p uM) pi_z = \\<bar>dist (p uM) (f z) - dist pi_z (f z)\\<bar>", "apply (rule dist_along_geodesic_wrt_endpoint[of H _ m])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment_between H (f z) m\n 2. p uM \\<in> H\n 3. pi_z \\<in> H", "using pH \\<open>pi_z \\<in> H\\<close> H_def"], ["proof (prove)\nusing this:\n  p ?x \\<in> H\n  pi_z \\<in> H\n  H = {f z--m}\n\ngoal (3 subgoals):\n 1. geodesic_segment_between H (f z) m\n 2. p uM \\<in> H\n 3. pi_z \\<in> H", "by auto"], ["proof (state)\nthis:\n  dist (p uM) pi_z = \\<bar>dist (p uM) (f z) - dist pi_z (f z)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  dist (p uM) pi_z = \\<bar>dist (p uM) (f z) - dist pi_z (f z)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... = dist (p uM) (f z) - dist pi_z (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dist (p uM) (f z) - dist pi_z (f z)\\<bar> =\n    dist (p uM) (f z) - dist pi_z (f z)", "using A Dpi_z"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM) \\<le> dist (p uM) (f z)\n  dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\n\ngoal (1 subgoal):\n 1. \\<bar>dist (p uM) (f z) - dist pi_z (f z)\\<bar> =\n    dist (p uM) (f z) - dist pi_z (f z)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  \\<bar>dist (p uM) (f z) - dist pi_z (f z)\\<bar> =\n  dist (p uM) (f z) - dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  dist (p uM) pi_z = dist (p uM) (f z) - dist pi_z (f z)", "have DuM: \"dist (p uM) (f z) = dist (p uM) pi_z + dist pi_z (f z)\""], ["proof (prove)\nusing this:\n  dist (p uM) pi_z = dist (p uM) (f z) - dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. dist (p uM) (f z) = dist (p uM) pi_z + dist pi_z (f z)", "by auto"], ["proof (state)\nthis:\n  dist (p uM) (f z) = dist (p uM) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Choose a point $f(yM)$ whose projection on $H$ is roughly at distance $L$ of $pi_z$.\\<close>"], ["proof (state)\nthis:\n  dist (p uM) (f z) = dist (p uM) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"\\<exists>yM \\<in> {z..uM}. dist (p uM) (p yM) \\<in> {(L + dist pi_z (p uM)) - 4* delta - 2 * 0 .. L + dist pi_z (p uM)}\n                    \\<and> (\\<forall>r \\<in> {yM..uM}. dist (p uM) (p r) \\<le> L + dist pi_z (p uM))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>yM\\<in>{z..uM}.\n       dist (p uM) (p yM)\n       \\<in> {L + dist pi_z (p uM) - 4 * delta -\n              2 * 0..L + dist pi_z (p uM)} \\<and>\n       (\\<forall>r\\<in>{yM..uM}.\n           dist (p uM) (p r) \\<le> L + dist pi_z (p uM))", "proof (rule quasi_convex_projection_small_gaps'[where ?f = f and ?G = H])"], ["proof (state)\ngoal (6 subgoals):\n 1. continuous_on {z..uM} f\n 2. z \\<le> uM\n 3. quasiconvex 0 H\n 4. \\<And>x. x \\<in> {z..uM} \\<Longrightarrow> p x \\<in> proj_set (f x) H\n 5. deltaG TYPE('a) < delta\n 6. L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}", "show \"continuous_on {z..uM} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {z..uM} f", "apply (rule continuous_on_subset[OF \\<open>continuous_on {a..b} f\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {z..uM} \\<subseteq> {a..b}", "using \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. {z..uM} \\<subseteq> {a..b}", "by auto"], ["proof (state)\nthis:\n  continuous_on {z..uM} f\n\ngoal (5 subgoals):\n 1. z \\<le> uM\n 2. quasiconvex 0 H\n 3. \\<And>x. x \\<in> {z..uM} \\<Longrightarrow> p x \\<in> proj_set (f x) H\n 4. deltaG TYPE('a) < delta\n 5. L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}", "show \"z \\<le> uM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> uM", "using \\<open>uM \\<in> {z..b}\\<close>"], ["proof (prove)\nusing this:\n  uM \\<in> {z..b}\n\ngoal (1 subgoal):\n 1. z \\<le> uM", "by auto"], ["proof (state)\nthis:\n  z \\<le> uM\n\ngoal (4 subgoals):\n 1. quasiconvex 0 H\n 2. \\<And>x. x \\<in> {z..uM} \\<Longrightarrow> p x \\<in> proj_set (f x) H\n 3. deltaG TYPE('a) < delta\n 4. L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}", "show \"quasiconvex 0 H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex 0 H", "using quasiconvex_of_geodesic geodesic_segmentI H"], ["proof (prove)\nusing this:\n  geodesic_segment ?G \\<Longrightarrow> quasiconvex 0 ?G\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow> geodesic_segment ?G\n  geodesic_segment_between H (f z) m\n\ngoal (1 subgoal):\n 1. quasiconvex 0 H", "by auto"], ["proof (state)\nthis:\n  quasiconvex 0 H\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> {z..uM} \\<Longrightarrow> p x \\<in> proj_set (f x) H\n 2. deltaG TYPE('a) < delta\n 3. L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}", "show \"deltaG TYPE('a) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) < delta", "by fact"], ["proof (state)\nthis:\n  deltaG TYPE('a) < delta\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {z..uM} \\<Longrightarrow> p x \\<in> proj_set (f x) H\n 2. L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}", "have \"L + dist pi_z (p uM) \\<le> dist (f z) pi_z + dist pi_z (p uM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L + dist pi_z (p uM) \\<le> dist (f z) pi_z + dist pi_z (p uM)", "using False Dpi_z"], ["proof (prove)\nusing this:\n  \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L\n  dist (f z) pi_z = Gromov_product_at (f z) (f um) (f uM)\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p uM) \\<le> dist (f z) pi_z + dist pi_z (p uM)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  L + dist pi_z (p uM) \\<le> dist (f z) pi_z + dist pi_z (p uM)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {z..uM} \\<Longrightarrow> p x \\<in> proj_set (f x) H\n 2. L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}", "then"], ["proof (chain)\npicking this:\n  L + dist pi_z (p uM) \\<le> dist (f z) pi_z + dist pi_z (p uM)", "have \"L + dist pi_z (p uM) \\<le> dist (p uM) (f z)\""], ["proof (prove)\nusing this:\n  L + dist pi_z (p uM) \\<le> dist (f z) pi_z + dist pi_z (p uM)\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p uM) \\<le> dist (p uM) (f z)", "using DuM"], ["proof (prove)\nusing this:\n  L + dist pi_z (p uM) \\<le> dist (f z) pi_z + dist pi_z (p uM)\n  dist (p uM) (f z) = dist (p uM) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p uM) \\<le> dist (p uM) (f z)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  L + dist pi_z (p uM) \\<le> dist (p uM) (f z)\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {z..uM} \\<Longrightarrow> p x \\<in> proj_set (f x) H\n 2. L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}", "then"], ["proof (chain)\npicking this:\n  L + dist pi_z (p uM) \\<le> dist (p uM) (f z)", "show \"L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}\""], ["proof (prove)\nusing this:\n  L + dist pi_z (p uM) \\<le> dist (p uM) (f z)\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}", "using \\<open>delta > 0\\<close> False L_def pz"], ["proof (prove)\nusing this:\n  L + dist pi_z (p uM) \\<le> dist (p uM) (f z)\n  0 < delta\n  \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L\n  L = 18 * delta\n  p z = f z\n\ngoal (1 subgoal):\n 1. L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  L + dist pi_z (p uM) \\<in> {4 * delta + 2 * 0..dist (p z) (p uM)}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {z..uM} \\<Longrightarrow> p x \\<in> proj_set (f x) H", "show \"p yM \\<in> proj_set (f yM) H\" for yM"], ["proof (prove)\ngoal (1 subgoal):\n 1. p yM \\<in> proj_set (f yM) H", "using p"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n\ngoal (1 subgoal):\n 1. p yM \\<in> proj_set (f yM) H", "by simp"], ["proof (state)\nthis:\n  p ?yM \\<in> proj_set (f ?yM) H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>yM\\<in>{z..uM}.\n     dist (p uM) (p yM)\n     \\<in> {L + dist pi_z (p uM) - 4 * delta -\n            2 * 0..L + dist pi_z (p uM)} \\<and>\n     (\\<forall>r\\<in>{yM..uM}. dist (p uM) (p r) \\<le> L + dist pi_z (p uM))\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>yM\\<in>{z..uM}.\n     dist (p uM) (p yM)\n     \\<in> {L + dist pi_z (p uM) - 4 * delta -\n            2 * 0..L + dist pi_z (p uM)} \\<and>\n     (\\<forall>r\\<in>{yM..uM}. dist (p uM) (p r) \\<le> L + dist pi_z (p uM))", "obtain yM where yM: \"yM \\<in> {z..uM}\"\n                              \"dist (p uM) (p yM) \\<in> {(L + dist pi_z (p uM)) - 4* delta - 2 * 0 .. L + dist pi_z (p uM)}\"\n                              \"\\<And>r. r \\<in> {yM..uM} \\<Longrightarrow> dist (p uM) (p r) \\<le> L + dist pi_z (p uM)\""], ["proof (prove)\nusing this:\n  \\<exists>yM\\<in>{z..uM}.\n     dist (p uM) (p yM)\n     \\<in> {L + dist pi_z (p uM) - 4 * delta -\n            2 * 0..L + dist pi_z (p uM)} \\<and>\n     (\\<forall>r\\<in>{yM..uM}. dist (p uM) (p r) \\<le> L + dist pi_z (p uM))\n\ngoal (1 subgoal):\n 1. (\\<And>yM.\n        \\<lbrakk>yM \\<in> {z..uM};\n         dist (p uM) (p yM)\n         \\<in> {L + dist pi_z (p uM) - 4 * delta -\n                2 * 0..L + dist pi_z (p uM)};\n         \\<And>r.\n            r \\<in> {yM..uM} \\<Longrightarrow>\n            dist (p uM) (p r) \\<le> L + dist pi_z (p uM)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  yM \\<in> {z..uM}\n  dist (p uM) (p yM)\n  \\<in> {L + dist pi_z (p uM) - 4 * delta - 2 * 0..L + dist pi_z (p uM)}\n  ?r \\<in> {yM..uM} \\<Longrightarrow>\n  dist (p uM) (p ?r) \\<le> L + dist pi_z (p uM)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have *: \"continuous_on {yM..uM} (\\<lambda>r. infdist (f r) H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {yM..uM} (\\<lambda>r. infdist (f r) H)", "using continuous_on_infdist[OF continuous_on_subset[OF \\<open>continuous_on {a..b} f\\<close>, of \"{yM..uM}\"], of H]\n        \\<open>yM \\<in> {z..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  {yM..uM} \\<subseteq> {a..b} \\<Longrightarrow>\n  continuous_on {yM..uM} (\\<lambda>x. infdist (f x) H)\n  yM \\<in> {z..uM}\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. continuous_on {yM..uM} (\\<lambda>r. infdist (f r) H)", "by auto"], ["proof (state)\nthis:\n  continuous_on {yM..uM} (\\<lambda>r. infdist (f r) H)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"\\<exists>closestM \\<in> {yM..uM}. \\<forall>v \\<in> {yM..uM}. infdist (f closestM) H \\<le> infdist (f v) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>closestM\\<in>{yM..uM}.\n       \\<forall>v\\<in>{yM..uM}. infdist (f closestM) H \\<le> infdist (f v) H", "apply (rule continuous_attains_inf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. compact {yM..uM}\n 2. {yM..uM} \\<noteq> {}\n 3. continuous_on {yM..uM} (\\<lambda>x. infdist (f x) H)", "using yM(1) *"], ["proof (prove)\nusing this:\n  yM \\<in> {z..uM}\n  continuous_on {yM..uM} (\\<lambda>r. infdist (f r) H)\n\ngoal (3 subgoals):\n 1. compact {yM..uM}\n 2. {yM..uM} \\<noteq> {}\n 3. continuous_on {yM..uM} (\\<lambda>x. infdist (f x) H)", "by auto"], ["proof (state)\nthis:\n  \\<exists>closestM\\<in>{yM..uM}.\n     \\<forall>v\\<in>{yM..uM}. infdist (f closestM) H \\<le> infdist (f v) H\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>closestM\\<in>{yM..uM}.\n     \\<forall>v\\<in>{yM..uM}. infdist (f closestM) H \\<le> infdist (f v) H", "obtain closestM where closestM: \"closestM \\<in> {yM..uM}\" \"\\<And>v. v \\<in> {yM..uM} \\<Longrightarrow> infdist (f closestM) H \\<le> infdist (f v) H\""], ["proof (prove)\nusing this:\n  \\<exists>closestM\\<in>{yM..uM}.\n     \\<forall>v\\<in>{yM..uM}. infdist (f closestM) H \\<le> infdist (f v) H\n\ngoal (1 subgoal):\n 1. (\\<And>closestM.\n        \\<lbrakk>closestM \\<in> {yM..uM};\n         \\<And>v.\n            v \\<in> {yM..uM} \\<Longrightarrow>\n            infdist (f closestM) H \\<le> infdist (f v) H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  closestM \\<in> {yM..uM}\n  ?v \\<in> {yM..uM} \\<Longrightarrow>\n  infdist (f closestM) H \\<le> infdist (f ?v) H\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define dM where \"dM = infdist (f closestM) H\""], ["proof (state)\nthis:\n  dM = infdist (f closestM) H\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have [simp]: \"dM \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> dM", "unfolding dM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> infdist (f closestM) H", "using infdist_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> infdist ?x ?A\n\ngoal (1 subgoal):\n 1. 0 \\<le> infdist (f closestM) H", "by auto"], ["proof (state)\nthis:\n  0 \\<le> dM\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Points between $f(um)$ and $f(ym)$, or between $f(yM)$ and $f(uM)$, project within\n      distance at most $L$ of $pi_z$ by construction.\\<close>"], ["proof (state)\nthis:\n  0 \\<le> dM\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have P0: \"dist m (p x) \\<le> dist m pi_z + L\" if \"x \\<in> {um..ym} \\<union> {yM..uM}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m (p x) \\<le> dist m pi_z + L", "proof (cases \"x \\<in> {um..ym}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L\n 2. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "case True"], ["proof (state)\nthis:\n  x \\<in> {um..ym}\n\ngoal (2 subgoals):\n 1. x \\<in> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L\n 2. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "have \"dist m (f z) = dist m (p um) + dist (p um) pi_z + dist pi_z (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m (f z) = dist m (p um) + dist (p um) pi_z + dist pi_z (f z)", "using geodesic_segment_dist[OF H pH[of um]] Dum"], ["proof (prove)\nusing this:\n  dist (f z) (p um) + dist (p um) m = dist (f z) m\n  dist (p um) (f z) = dist (p um) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. dist m (f z) = dist m (p um) + dist (p um) pi_z + dist pi_z (f z)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist m (f z) = dist m (p um) + dist (p um) pi_z + dist pi_z (f z)\n\ngoal (2 subgoals):\n 1. x \\<in> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L\n 2. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "moreover"], ["proof (state)\nthis:\n  dist m (f z) = dist m (p um) + dist (p um) pi_z + dist pi_z (f z)\n\ngoal (2 subgoals):\n 1. x \\<in> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L\n 2. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "have \"dist m (f z) = dist m pi_z + dist pi_z (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m (f z) = dist m pi_z + dist pi_z (f z)", "using geodesic_segment_dist[OF H \\<open>pi_z \\<in> H\\<close>]"], ["proof (prove)\nusing this:\n  dist (f z) pi_z + dist pi_z m = dist (f z) m\n\ngoal (1 subgoal):\n 1. dist m (f z) = dist m pi_z + dist pi_z (f z)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist m (f z) = dist m pi_z + dist pi_z (f z)\n\ngoal (2 subgoals):\n 1. x \\<in> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L\n 2. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "ultimately"], ["proof (chain)\npicking this:\n  dist m (f z) = dist m (p um) + dist (p um) pi_z + dist pi_z (f z)\n  dist m (f z) = dist m pi_z + dist pi_z (f z)", "have *: \"dist m pi_z = dist m (p um) + dist (p um) pi_z\""], ["proof (prove)\nusing this:\n  dist m (f z) = dist m (p um) + dist (p um) pi_z + dist pi_z (f z)\n  dist m (f z) = dist m pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. dist m pi_z = dist m (p um) + dist (p um) pi_z", "by auto"], ["proof (state)\nthis:\n  dist m pi_z = dist m (p um) + dist (p um) pi_z\n\ngoal (2 subgoals):\n 1. x \\<in> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L\n 2. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "have \"dist (p um) (p x) \\<le> L + dist pi_z (p um)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p um) (p x) \\<le> L + dist pi_z (p um)", "using ym(3)[OF \\<open>x \\<in> {um..ym}\\<close>]"], ["proof (prove)\nusing this:\n  dist (p um) (p x) \\<le> L + dist pi_z (p um)\n\ngoal (1 subgoal):\n 1. dist (p um) (p x) \\<le> L + dist pi_z (p um)", "by blast"], ["proof (state)\nthis:\n  dist (p um) (p x) \\<le> L + dist pi_z (p um)\n\ngoal (2 subgoals):\n 1. x \\<in> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L\n 2. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "then"], ["proof (chain)\npicking this:\n  dist (p um) (p x) \\<le> L + dist pi_z (p um)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (p um) (p x) \\<le> L + dist pi_z (p um)\n\ngoal (1 subgoal):\n 1. dist m (p x) \\<le> dist m pi_z + L", "using metric_space_class.dist_triangle[of m \"p x\" \"p um\"] *"], ["proof (prove)\nusing this:\n  dist (p um) (p x) \\<le> L + dist pi_z (p um)\n  dist m (p x) \\<le> dist m (p um) + dist (p um) (p x)\n  dist m pi_z = dist m (p um) + dist (p um) pi_z\n\ngoal (1 subgoal):\n 1. dist m (p x) \\<le> dist m pi_z + L", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist m (p x) \\<le> dist m pi_z + L\n\ngoal (1 subgoal):\n 1. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "case False"], ["proof (state)\nthis:\n  x \\<notin> {um..ym}\n\ngoal (1 subgoal):\n 1. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "then"], ["proof (chain)\npicking this:\n  x \\<notin> {um..ym}", "have \"x \\<in> {yM..uM}\""], ["proof (prove)\nusing this:\n  x \\<notin> {um..ym}\n\ngoal (1 subgoal):\n 1. x \\<in> {yM..uM}", "using that"], ["proof (prove)\nusing this:\n  x \\<notin> {um..ym}\n  x \\<in> {um..ym} \\<union> {yM..uM}\n\ngoal (1 subgoal):\n 1. x \\<in> {yM..uM}", "by auto"], ["proof (state)\nthis:\n  x \\<in> {yM..uM}\n\ngoal (1 subgoal):\n 1. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "have \"dist m (f z) = dist m (p uM) + dist (p uM) pi_z + dist pi_z (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m (f z) = dist m (p uM) + dist (p uM) pi_z + dist pi_z (f z)", "using geodesic_segment_dist[OF H pH[of uM]] DuM"], ["proof (prove)\nusing this:\n  dist (f z) (p uM) + dist (p uM) m = dist (f z) m\n  dist (p uM) (f z) = dist (p uM) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. dist m (f z) = dist m (p uM) + dist (p uM) pi_z + dist pi_z (f z)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist m (f z) = dist m (p uM) + dist (p uM) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "moreover"], ["proof (state)\nthis:\n  dist m (f z) = dist m (p uM) + dist (p uM) pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "have \"dist m (f z) = dist m pi_z + dist pi_z (f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m (f z) = dist m pi_z + dist pi_z (f z)", "using geodesic_segment_dist[OF H \\<open>pi_z \\<in> H\\<close>]"], ["proof (prove)\nusing this:\n  dist (f z) pi_z + dist pi_z m = dist (f z) m\n\ngoal (1 subgoal):\n 1. dist m (f z) = dist m pi_z + dist pi_z (f z)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist m (f z) = dist m pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "ultimately"], ["proof (chain)\npicking this:\n  dist m (f z) = dist m (p uM) + dist (p uM) pi_z + dist pi_z (f z)\n  dist m (f z) = dist m pi_z + dist pi_z (f z)", "have *: \"dist m pi_z = dist m (p uM) + dist (p uM) pi_z\""], ["proof (prove)\nusing this:\n  dist m (f z) = dist m (p uM) + dist (p uM) pi_z + dist pi_z (f z)\n  dist m (f z) = dist m pi_z + dist pi_z (f z)\n\ngoal (1 subgoal):\n 1. dist m pi_z = dist m (p uM) + dist (p uM) pi_z", "by auto"], ["proof (state)\nthis:\n  dist m pi_z = dist m (p uM) + dist (p uM) pi_z\n\ngoal (1 subgoal):\n 1. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "have \"dist (p uM) (p x) \\<le> L + dist pi_z (p uM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p uM) (p x) \\<le> L + dist pi_z (p uM)", "using yM(3)[OF \\<open>x \\<in> {yM..uM}\\<close>]"], ["proof (prove)\nusing this:\n  dist (p uM) (p x) \\<le> L + dist pi_z (p uM)\n\ngoal (1 subgoal):\n 1. dist (p uM) (p x) \\<le> L + dist pi_z (p uM)", "by blast"], ["proof (state)\nthis:\n  dist (p uM) (p x) \\<le> L + dist pi_z (p uM)\n\ngoal (1 subgoal):\n 1. x \\<notin> {um..ym} \\<Longrightarrow> dist m (p x) \\<le> dist m pi_z + L", "then"], ["proof (chain)\npicking this:\n  dist (p uM) (p x) \\<le> L + dist pi_z (p uM)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (p uM) (p x) \\<le> L + dist pi_z (p uM)\n\ngoal (1 subgoal):\n 1. dist m (p x) \\<le> dist m pi_z + L", "using metric_space_class.dist_triangle[of m \"p x\" \"p uM\"] *"], ["proof (prove)\nusing this:\n  dist (p uM) (p x) \\<le> L + dist pi_z (p uM)\n  dist m (p x) \\<le> dist m (p uM) + dist (p uM) (p x)\n  dist m pi_z = dist m (p uM) + dist (p uM) pi_z\n\ngoal (1 subgoal):\n 1. dist m (p x) \\<le> dist m pi_z + L", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist m (p x) \\<le> dist m pi_z + L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist m (p ?x) \\<le> dist m pi_z + L\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have P: \"dist pi_z (p x) \\<le> L\" if \"x \\<in> {um..ym} \\<union> {yM..uM}\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pi_z (p x) \\<le> L", "proof (cases \"dist m (p x) \\<le> dist pi_z m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dist m (p x) \\<le> dist pi_z m \\<Longrightarrow> dist pi_z (p x) \\<le> L\n 2. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "case True"], ["proof (state)\nthis:\n  dist m (p x) \\<le> dist pi_z m\n\ngoal (2 subgoals):\n 1. dist m (p x) \\<le> dist pi_z m \\<Longrightarrow> dist pi_z (p x) \\<le> L\n 2. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "have \"dist pi_z (p x) \\<le> dist pi_z m + dist m (p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pi_z (p x) \\<le> dist pi_z m + dist m (p x)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist pi_z (p x) \\<le> dist pi_z m + dist m (p x)\n\ngoal (2 subgoals):\n 1. dist m (p x) \\<le> dist pi_z m \\<Longrightarrow> dist pi_z (p x) \\<le> L\n 2. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "also"], ["proof (state)\nthis:\n  dist pi_z (p x) \\<le> dist pi_z m + dist m (p x)\n\ngoal (2 subgoals):\n 1. dist m (p x) \\<le> dist pi_z m \\<Longrightarrow> dist pi_z (p x) \\<le> L\n 2. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "have \"... \\<le> 2 * delta + 2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pi_z m + dist m (p x) \\<le> 2 * delta + 2 * delta", "using \\<open>dist pi_z m \\<le> 2 * delta\\<close> True"], ["proof (prove)\nusing this:\n  dist pi_z m \\<le> 2 * delta\n  dist m (p x) \\<le> dist pi_z m\n\ngoal (1 subgoal):\n 1. dist pi_z m + dist m (p x) \\<le> 2 * delta + 2 * delta", "by auto"], ["proof (state)\nthis:\n  dist pi_z m + dist m (p x) \\<le> 2 * delta + 2 * delta\n\ngoal (2 subgoals):\n 1. dist m (p x) \\<le> dist pi_z m \\<Longrightarrow> dist pi_z (p x) \\<le> L\n 2. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "finally"], ["proof (chain)\npicking this:\n  dist pi_z (p x) \\<le> 2 * delta + 2 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  dist pi_z (p x) \\<le> 2 * delta + 2 * delta\n\ngoal (1 subgoal):\n 1. dist pi_z (p x) \\<le> L", "using Laux \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  dist pi_z (p x) \\<le> 2 * delta + 2 * delta\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < delta\n\ngoal (1 subgoal):\n 1. dist pi_z (p x) \\<le> L", "by auto"], ["proof (state)\nthis:\n  dist pi_z (p x) \\<le> L\n\ngoal (1 subgoal):\n 1. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "case False"], ["proof (state)\nthis:\n  \\<not> dist m (p x) \\<le> dist pi_z m\n\ngoal (1 subgoal):\n 1. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "have \"dist pi_z (p x) = abs(dist pi_z m - dist (p x) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist pi_z (p x) = \\<bar>dist pi_z m - dist (p x) m\\<bar>", "apply (rule dist_along_geodesic_wrt_endpoint[OF geodesic_segment_commute[OF H]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. pi_z \\<in> H\n 2. p x \\<in> H", "using pH \\<open>pi_z \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  p ?x \\<in> H\n  pi_z \\<in> H\n\ngoal (2 subgoals):\n 1. pi_z \\<in> H\n 2. p x \\<in> H", "by auto"], ["proof (state)\nthis:\n  dist pi_z (p x) = \\<bar>dist pi_z m - dist (p x) m\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "also"], ["proof (state)\nthis:\n  dist pi_z (p x) = \\<bar>dist pi_z m - dist (p x) m\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "have \"... = dist (p x) m - dist pi_z m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dist pi_z m - dist (p x) m\\<bar> = dist (p x) m - dist pi_z m", "using False"], ["proof (prove)\nusing this:\n  \\<not> dist m (p x) \\<le> dist pi_z m\n\ngoal (1 subgoal):\n 1. \\<bar>dist pi_z m - dist (p x) m\\<bar> = dist (p x) m - dist pi_z m", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  \\<bar>dist pi_z m - dist (p x) m\\<bar> = dist (p x) m - dist pi_z m\n\ngoal (1 subgoal):\n 1. \\<not> dist m (p x) \\<le> dist pi_z m \\<Longrightarrow>\n    dist pi_z (p x) \\<le> L", "finally"], ["proof (chain)\npicking this:\n  dist pi_z (p x) = dist (p x) m - dist pi_z m", "show ?thesis"], ["proof (prove)\nusing this:\n  dist pi_z (p x) = dist (p x) m - dist pi_z m\n\ngoal (1 subgoal):\n 1. dist pi_z (p x) \\<le> L", "using P0[OF that]"], ["proof (prove)\nusing this:\n  dist pi_z (p x) = dist (p x) m - dist pi_z m\n  dist m (p x) \\<le> dist m pi_z + L\n\ngoal (1 subgoal):\n 1. dist pi_z (p x) \\<le> L", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist pi_z (p x) \\<le> L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist pi_z (p ?x) \\<le> L\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Auxiliary fact for later use:\n      The distance between two points in $[um, ym]$ and $[yM, uM]$ can be controlled using\n      the distances of their images under $f$ to $H$, thanks to the quasi-isometry property.\\<close>"], ["proof (state)\nthis:\n  ?x \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist pi_z (p ?x) \\<le> L\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have D: \"dist rm rM \\<le> lambda * (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)\"\n        if \"rm \\<in> {um..ym}\" \"rM \\<in> {yM..uM}\" for rm rM"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "have *: \"dist m (p rm) \\<le> L + dist m pi_z\" \"dist m (p rM) \\<le> L + dist m pi_z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist m (p rm) \\<le> L + dist m pi_z &&&\n    dist m (p rM) \\<le> L + dist m pi_z", "using P0 that"], ["proof (prove)\nusing this:\n  ?x \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist m (p ?x) \\<le> dist m pi_z + L\n  rm \\<in> {um..ym}\n  rM \\<in> {yM..uM}\n\ngoal (1 subgoal):\n 1. dist m (p rm) \\<le> L + dist m pi_z &&&\n    dist m (p rM) \\<le> L + dist m pi_z", "by force+"], ["proof (state)\nthis:\n  dist m (p rm) \\<le> L + dist m pi_z\n  dist m (p rM) \\<le> L + dist m pi_z\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "have \"dist (p rm) (p rM) = abs(dist (p rm) m - dist (p rM) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p rm) (p rM) = \\<bar>dist (p rm) m - dist (p rM) m\\<bar>", "apply (rule dist_along_geodesic_wrt_endpoint[OF geodesic_segment_commute[OF H]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. p rm \\<in> H\n 2. p rM \\<in> H", "using pH"], ["proof (prove)\nusing this:\n  p ?x \\<in> H\n\ngoal (2 subgoals):\n 1. p rm \\<in> H\n 2. p rM \\<in> H", "by auto"], ["proof (state)\nthis:\n  dist (p rm) (p rM) = \\<bar>dist (p rm) m - dist (p rM) m\\<bar>\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "also"], ["proof (state)\nthis:\n  dist (p rm) (p rM) = \\<bar>dist (p rm) m - dist (p rM) m\\<bar>\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "have \"... \\<le> L + dist m pi_z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dist (p rm) m - dist (p rM) m\\<bar> \\<le> L + dist m pi_z", "unfolding abs_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p rm) m - dist (p rM) m \\<le> L + dist m pi_z \\<and>\n    - (dist (p rm) m - dist (p rM) m) \\<le> L + dist m pi_z", "using *"], ["proof (prove)\nusing this:\n  dist m (p rm) \\<le> L + dist m pi_z\n  dist m (p rM) \\<le> L + dist m pi_z\n\ngoal (1 subgoal):\n 1. dist (p rm) m - dist (p rM) m \\<le> L + dist m pi_z \\<and>\n    - (dist (p rm) m - dist (p rM) m) \\<le> L + dist m pi_z", "apply (auto simp add: metric_space_class.dist_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dist m (p rm) \\<le> L + dist m pi_z;\n     dist m (p rM) \\<le> L + dist m pi_z\\<rbrakk>\n    \\<Longrightarrow> dist m (p rm) - dist m (p rM) \\<le> L + dist m pi_z\n 2. \\<lbrakk>dist m (p rm) \\<le> L + dist m pi_z;\n     dist m (p rM) \\<le> L + dist m pi_z\\<rbrakk>\n    \\<Longrightarrow> dist m (p rM) - dist m (p rm) \\<le> L + dist m pi_z", "by (metis diff_add_cancel le_add_same_cancel1 metric_space_class.zero_le_dist order_trans)+"], ["proof (state)\nthis:\n  \\<bar>dist (p rm) m - dist (p rM) m\\<bar> \\<le> L + dist m pi_z\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "finally"], ["proof (chain)\npicking this:\n  dist (p rm) (p rM) \\<le> L + dist m pi_z", "have *: \"dist (p rm) (p rM) \\<le> L + 2 * delta\""], ["proof (prove)\nusing this:\n  dist (p rm) (p rM) \\<le> L + dist m pi_z\n\ngoal (1 subgoal):\n 1. dist (p rm) (p rM) \\<le> L + 2 * delta", "using \\<open>dist pi_z m \\<le> 2 * delta\\<close>"], ["proof (prove)\nusing this:\n  dist (p rm) (p rM) \\<le> L + dist m pi_z\n  dist pi_z m \\<le> 2 * delta\n\ngoal (1 subgoal):\n 1. dist (p rm) (p rM) \\<le> L + 2 * delta", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (p rm) (p rM) \\<le> L + 2 * delta\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "have \"(1/lambda) * dist rm rM - C \\<le> dist (f rm) (f rM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / lambda * dist rm rM - C \\<le> dist (f rm) (f rM)", "apply (rule quasi_isometry_onD(2)[OF \\<open>lambda C-quasi_isometry_on {a..b} f\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. rm \\<in> {a..b}\n 2. rM \\<in> {a..b}", "using \\<open>rm \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>rM \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close>"], ["proof (prove)\nusing this:\n  rm \\<in> {um..ym}\n  ym \\<in> {um..z}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n  rM \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n  uM \\<in> {z..b}\n\ngoal (2 subgoals):\n 1. rm \\<in> {a..b}\n 2. rM \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  1 / lambda * dist rm rM - C \\<le> dist (f rm) (f rM)\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "also"], ["proof (state)\nthis:\n  1 / lambda * dist rm rM - C \\<le> dist (f rm) (f rM)\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "have \"... \\<le> dist (f rm) (p rm) + dist (p rm) (p rM) + dist (p rM) (f rM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f rm) (f rM)\n    \\<le> dist (f rm) (p rm) + dist (p rm) (p rM) + dist (p rM) (f rM)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f rm) (f rM)\n  \\<le> dist (f rm) (p rm) + dist (p rm) (p rM) + dist (p rM) (f rM)\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "also"], ["proof (state)\nthis:\n  dist (f rm) (f rM)\n  \\<le> dist (f rm) (p rm) + dist (p rm) (p rM) + dist (p rM) (f rM)\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "have \"... \\<le> infdist (f rm) H + L + 2 * delta + infdist (f rM) H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f rm) (p rm) + dist (p rm) (p rM) + dist (p rM) (f rM)\n    \\<le> infdist (f rm) H + L + 2 * delta + infdist (f rM) H", "using * proj_setD(2)[OF p]"], ["proof (prove)\nusing this:\n  dist (p rm) (p rM) \\<le> L + 2 * delta\n  dist (f ?x1) (p ?x1) = infdist (f ?x1) H\n\ngoal (1 subgoal):\n 1. dist (f rm) (p rm) + dist (p rm) (p rM) + dist (p rM) (f rM)\n    \\<le> infdist (f rm) H + L + 2 * delta + infdist (f rM) H", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (f rm) (p rm) + dist (p rm) (p rM) + dist (p rM) (f rM)\n  \\<le> infdist (f rm) H + L + 2 * delta + infdist (f rM) H\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "finally"], ["proof (chain)\npicking this:\n  1 / lambda * dist rm rM - C\n  \\<le> infdist (f rm) H + L + 2 * delta + infdist (f rM) H", "show ?thesis"], ["proof (prove)\nusing this:\n  1 / lambda * dist rm rM - C\n  \\<le> infdist (f rm) H + L + 2 * delta + infdist (f rM) H\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "using \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 / lambda * dist rm rM - C\n  \\<le> infdist (f rm) H + L + 2 * delta + infdist (f rM) H\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. dist rm rM\n    \\<le> lambda *\n          (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)", "by (simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  dist rm rM\n  \\<le> lambda * (infdist (f rm) H + (L + C + 2 * delta) + infdist (f rM) H)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?rm \\<in> {um..ym}; ?rM \\<in> {yM..uM}\\<rbrakk>\n  \\<Longrightarrow> dist ?rm ?rM\n                    \\<le> lambda *\n                          (infdist (f ?rm) H + (L + C + 2 * delta) +\n                           infdist (f ?rM) H)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Auxiliary fact for later use in the inductive argument:\n      the distance from $f(z)$ to $pi_z$ is controlled by the distance from $f(z)$ to any\n      intermediate geodesic between points in $f[um, ym]$ and $f[yM, uM]$, up to a constant\n      essentially given by $L$. This is a variation around Lemma 5 in~\\cite{shchur}.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?rm \\<in> {um..ym}; ?rM \\<in> {yM..uM}\\<rbrakk>\n  \\<Longrightarrow> dist ?rm ?rM\n                    \\<le> lambda *\n                          (infdist (f ?rm) H + (L + C + 2 * delta) +\n                           infdist (f ?rM) H)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have Rec: \"Gromov_product_at (f z) (f um) (f uM) \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)\" if \"rm \\<in> {um..ym}\" \"rM \\<in> {yM..uM}\" for rm rM"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "have *: \"dist (f rm) (p rm) + dist (p rm) (f z) \\<le> dist (f rm) (f z) + 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f rm) (p rm) + dist (p rm) (f z)\n    \\<le> dist (f rm) (f z) + 4 * deltaG TYPE('a)", "apply (rule dist_along_geodesic[of H])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment H\n 2. p rm \\<in> proj_set (f rm) H\n 3. f z \\<in> H", "using p H_def"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n  H = {f z--m}\n\ngoal (3 subgoals):\n 1. geodesic_segment H\n 2. p rm \\<in> proj_set (f rm) H\n 3. f z \\<in> H", "by auto"], ["proof (state)\nthis:\n  dist (f rm) (p rm) + dist (p rm) (f z)\n  \\<le> dist (f rm) (f z) + 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "have \"dist (f z) pi_z \\<le> dist (f z) (p rm) + dist (p rm) pi_z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) pi_z \\<le> dist (f z) (p rm) + dist (p rm) pi_z", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f z) pi_z \\<le> dist (f z) (p rm) + dist (p rm) pi_z\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "also"], ["proof (state)\nthis:\n  dist (f z) pi_z \\<le> dist (f z) (p rm) + dist (p rm) pi_z\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "have \"... \\<le> (Gromov_product_at (f z) (f rm) (p rm) + 2 * deltaG(TYPE('a))) + L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) (p rm) + dist (p rm) pi_z\n    \\<le> Gromov_product_at (f z) (f rm) (p rm) + 2 * deltaG TYPE('a) + L", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist (f z) (p rm)\n    \\<le> Gromov_product_at (f z) (f rm) (p rm) + 2 * deltaG TYPE('a)\n 2. dist (p rm) pi_z \\<le> L", "using * P \\<open>rm \\<in> {um..ym}\\<close>"], ["proof (prove)\nusing this:\n  dist (f rm) (p rm) + dist (p rm) (f z)\n  \\<le> dist (f rm) (f z) + 4 * deltaG TYPE('a)\n  ?x \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist pi_z (p ?x) \\<le> L\n  rm \\<in> {um..ym}\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm)\n    \\<le> Gromov_product_at (f z) (f rm) (p rm) + 2 * deltaG TYPE('a)\n 2. dist (p rm) pi_z \\<le> L", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist (f rm) (p rm) + dist (p rm) (f z)\n  \\<le> dist (f rm) (f z) + 4 * deltaG TYPE('a)\n  ?x \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist pi_z (p ?x) \\<le> L\n  rm \\<in> {um..ym}\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm)\n    \\<le> (dist (f z) (f rm) + dist (f z) (p rm) - dist (f rm) (p rm)) / 2 +\n          2 * deltaG TYPE('a)\n 2. dist (p rm) pi_z \\<le> L", "by (auto simp add: metric_space_class.dist_commute algebra_simps divide_simps)"], ["proof (state)\nthis:\n  dist (f z) (p rm) + dist (p rm) pi_z\n  \\<le> Gromov_product_at (f z) (f rm) (p rm) + 2 * deltaG TYPE('a) + L\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "finally"], ["proof (chain)\npicking this:\n  dist (f z) pi_z\n  \\<le> Gromov_product_at (f z) (f rm) (p rm) + 2 * deltaG TYPE('a) + L", "have A: \"dist (f z) pi_z - L - 2 * deltaG(TYPE('a)) \\<le> Gromov_product_at (f z) (f rm) (p rm)\""], ["proof (prove)\nusing this:\n  dist (f z) pi_z\n  \\<le> Gromov_product_at (f z) (f rm) (p rm) + 2 * deltaG TYPE('a) + L\n\ngoal (1 subgoal):\n 1. dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (f rm) (p rm)", "by simp"], ["proof (state)\nthis:\n  dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (f rm) (p rm)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "have *: \"dist (f rM) (p rM) + dist (p rM) (f z) \\<le> dist (f rM) (f z) + 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f rM) (p rM) + dist (p rM) (f z)\n    \\<le> dist (f rM) (f z) + 4 * deltaG TYPE('a)", "apply (rule dist_along_geodesic[of H])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment H\n 2. p rM \\<in> proj_set (f rM) H\n 3. f z \\<in> H", "using p H_def"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n  H = {f z--m}\n\ngoal (3 subgoals):\n 1. geodesic_segment H\n 2. p rM \\<in> proj_set (f rM) H\n 3. f z \\<in> H", "by auto"], ["proof (state)\nthis:\n  dist (f rM) (p rM) + dist (p rM) (f z)\n  \\<le> dist (f rM) (f z) + 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "have \"dist (f z) pi_z \\<le> dist (f z) (p rM) + dist (p rM) pi_z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) pi_z \\<le> dist (f z) (p rM) + dist (p rM) pi_z", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f z) pi_z \\<le> dist (f z) (p rM) + dist (p rM) pi_z\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "also"], ["proof (state)\nthis:\n  dist (f z) pi_z \\<le> dist (f z) (p rM) + dist (p rM) pi_z\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "have \"... \\<le> (Gromov_product_at (f z) (p rM) (f rM) + 2 * deltaG(TYPE('a))) + L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) (p rM) + dist (p rM) pi_z\n    \\<le> Gromov_product_at (f z) (p rM) (f rM) + 2 * deltaG TYPE('a) + L", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist (f z) (p rM)\n    \\<le> Gromov_product_at (f z) (p rM) (f rM) + 2 * deltaG TYPE('a)\n 2. dist (p rM) pi_z \\<le> L", "using * P \\<open>rM \\<in> {yM..uM}\\<close>"], ["proof (prove)\nusing this:\n  dist (f rM) (p rM) + dist (p rM) (f z)\n  \\<le> dist (f rM) (f z) + 4 * deltaG TYPE('a)\n  ?x \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist pi_z (p ?x) \\<le> L\n  rM \\<in> {yM..uM}\n\ngoal (2 subgoals):\n 1. dist (f z) (p rM)\n    \\<le> Gromov_product_at (f z) (p rM) (f rM) + 2 * deltaG TYPE('a)\n 2. dist (p rM) pi_z \\<le> L", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist (f rM) (p rM) + dist (p rM) (f z)\n  \\<le> dist (f rM) (f z) + 4 * deltaG TYPE('a)\n  ?x \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist pi_z (p ?x) \\<le> L\n  rM \\<in> {yM..uM}\n\ngoal (2 subgoals):\n 1. dist (f z) (p rM)\n    \\<le> (dist (f z) (p rM) + dist (f z) (f rM) - dist (p rM) (f rM)) / 2 +\n          2 * deltaG TYPE('a)\n 2. dist (p rM) pi_z \\<le> L", "by (auto simp add: metric_space_class.dist_commute algebra_simps divide_simps)"], ["proof (state)\nthis:\n  dist (f z) (p rM) + dist (p rM) pi_z\n  \\<le> Gromov_product_at (f z) (p rM) (f rM) + 2 * deltaG TYPE('a) + L\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "finally"], ["proof (chain)\npicking this:\n  dist (f z) pi_z\n  \\<le> Gromov_product_at (f z) (p rM) (f rM) + 2 * deltaG TYPE('a) + L", "have B: \"dist (f z) pi_z - L - 2 * deltaG(TYPE('a)) \\<le> Gromov_product_at (f z) (p rM) (f rM)\""], ["proof (prove)\nusing this:\n  dist (f z) pi_z\n  \\<le> Gromov_product_at (f z) (p rM) (f rM) + 2 * deltaG TYPE('a) + L\n\ngoal (1 subgoal):\n 1. dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rM) (f rM)", "by simp"], ["proof (state)\nthis:\n  dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (p rM) (f rM)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "have C: \"dist (f z) pi_z - L - 2 * deltaG(TYPE('a)) \\<le> Gromov_product_at (f z) (p rm) (p rM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "proof (cases \"dist (f z) (p rm) \\<le> dist (f z) (p rM)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)\n 2. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "case True"], ["proof (state)\nthis:\n  dist (f z) (p rm) \\<le> dist (f z) (p rM)\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)\n 2. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "have \"dist (p rm) (p rM) = abs(dist (f z) (p rm) - dist (f z) (p rM))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p rm) (p rM) = \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar>", "using proj_setD(1)[OF p] dist_along_geodesic_wrt_endpoint[OF H, of \"p rm\" \"p rM\"]"], ["proof (prove)\nusing this:\n  p ?x1 \\<in> H\n  \\<lbrakk>p rm \\<in> H; p rM \\<in> H\\<rbrakk>\n  \\<Longrightarrow> dist (p rm) (p rM) =\n                    \\<bar>dist (p rm) (f z) - dist (p rM) (f z)\\<bar>\n\ngoal (1 subgoal):\n 1. dist (p rm) (p rM) = \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar>", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (p rm) (p rM) = \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar>\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)\n 2. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "also"], ["proof (state)\nthis:\n  dist (p rm) (p rM) = \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar>\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)\n 2. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "have \"... = dist (f z) (p rM) - dist (f z) (p rm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar> =\n    dist (f z) (p rM) - dist (f z) (p rm)", "using True"], ["proof (prove)\nusing this:\n  dist (f z) (p rm) \\<le> dist (f z) (p rM)\n\ngoal (1 subgoal):\n 1. \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar> =\n    dist (f z) (p rM) - dist (f z) (p rm)", "by auto"], ["proof (state)\nthis:\n  \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar> =\n  dist (f z) (p rM) - dist (f z) (p rm)\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)\n 2. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "finally"], ["proof (chain)\npicking this:\n  dist (p rm) (p rM) = dist (f z) (p rM) - dist (f z) (p rm)", "have *: \"dist (f z) (p rm) = Gromov_product_at (f z) (p rm) (p rM)\""], ["proof (prove)\nusing this:\n  dist (p rm) (p rM) = dist (f z) (p rM) - dist (f z) (p rm)\n\ngoal (1 subgoal):\n 1. dist (f z) (p rm) = Gromov_product_at (f z) (p rm) (p rM)", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist (p rm) (p rM) = dist (f z) (p rM) - dist (f z) (p rm)\n\ngoal (1 subgoal):\n 1. dist (f z) (p rm) =\n    (dist (f z) (p rm) + dist (f z) (p rM) - dist (p rm) (p rM)) / 2", "by auto"], ["proof (state)\nthis:\n  dist (f z) (p rm) = Gromov_product_at (f z) (p rm) (p rM)\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)\n 2. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "have \"dist (f z) pi_z \\<le> dist (f z) (p rm) + dist (p rm) pi_z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) pi_z \\<le> dist (f z) (p rm) + dist (p rm) pi_z", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f z) pi_z \\<le> dist (f z) (p rm) + dist (p rm) pi_z\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)\n 2. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "also"], ["proof (state)\nthis:\n  dist (f z) pi_z \\<le> dist (f z) (p rm) + dist (p rm) pi_z\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)\n 2. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "have \"... \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) (p rm) + dist (p rm) pi_z\n    \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)", "using * P[of rm] \\<open>rm \\<in> {um..ym}\\<close>"], ["proof (prove)\nusing this:\n  dist (f z) (p rm) = Gromov_product_at (f z) (p rm) (p rM)\n  rm \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist pi_z (p rm) \\<le> L\n  rm \\<in> {um..ym}\n\ngoal (1 subgoal):\n 1. dist (f z) (p rm) + dist (p rm) pi_z\n    \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)", "apply (simp add: metric_space_class.dist_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist (f z) (p rm) = Gromov_product_at (f z) (p rm) (p rM);\n     dist pi_z (p rm) \\<le> L; um \\<le> rm \\<and> rm \\<le> ym\\<rbrakk>\n    \\<Longrightarrow> dist pi_z (p rm) \\<le> L + 2 * deltaG TYPE('a)", "using local.delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dist (f z) (p rm) = Gromov_product_at (f z) (p rm) (p rM);\n     dist pi_z (p rm) \\<le> L; um \\<le> rm \\<and> rm \\<le> ym\\<rbrakk>\n    \\<Longrightarrow> dist pi_z (p rm) \\<le> L + 2 * deltaG TYPE('a)", "by linarith"], ["proof (state)\nthis:\n  dist (f z) (p rm) + dist (p rm) pi_z\n  \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)\n 2. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "finally"], ["proof (chain)\npicking this:\n  dist (f z) pi_z\n  \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (f z) pi_z\n  \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "by simp"], ["proof (state)\nthis:\n  dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (p rm) (p rM)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "case False"], ["proof (state)\nthis:\n  \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "have \"dist (p rm) (p rM) = abs(dist (f z) (p rm) - dist (f z) (p rM))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (p rm) (p rM) = \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar>", "using proj_setD(1)[OF p] dist_along_geodesic_wrt_endpoint[OF H, of \"p rm\" \"p rM\"]"], ["proof (prove)\nusing this:\n  p ?x1 \\<in> H\n  \\<lbrakk>p rm \\<in> H; p rM \\<in> H\\<rbrakk>\n  \\<Longrightarrow> dist (p rm) (p rM) =\n                    \\<bar>dist (p rm) (f z) - dist (p rM) (f z)\\<bar>\n\ngoal (1 subgoal):\n 1. dist (p rm) (p rM) = \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar>", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (p rm) (p rM) = \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "also"], ["proof (state)\nthis:\n  dist (p rm) (p rM) = \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "have \"... = dist (f z) (p rm) - dist (f z) (p rM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar> =\n    dist (f z) (p rm) - dist (f z) (p rM)", "using False"], ["proof (prove)\nusing this:\n  \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM)\n\ngoal (1 subgoal):\n 1. \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar> =\n    dist (f z) (p rm) - dist (f z) (p rM)", "by auto"], ["proof (state)\nthis:\n  \\<bar>dist (f z) (p rm) - dist (f z) (p rM)\\<bar> =\n  dist (f z) (p rm) - dist (f z) (p rM)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "finally"], ["proof (chain)\npicking this:\n  dist (p rm) (p rM) = dist (f z) (p rm) - dist (f z) (p rM)", "have *: \"dist (f z) (p rM) = Gromov_product_at (f z) (p rm) (p rM)\""], ["proof (prove)\nusing this:\n  dist (p rm) (p rM) = dist (f z) (p rm) - dist (f z) (p rM)\n\ngoal (1 subgoal):\n 1. dist (f z) (p rM) = Gromov_product_at (f z) (p rm) (p rM)", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist (p rm) (p rM) = dist (f z) (p rm) - dist (f z) (p rM)\n\ngoal (1 subgoal):\n 1. dist (f z) (p rM) =\n    (dist (f z) (p rm) + dist (f z) (p rM) - dist (p rm) (p rM)) / 2", "by auto"], ["proof (state)\nthis:\n  dist (f z) (p rM) = Gromov_product_at (f z) (p rm) (p rM)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "have \"dist (f z) pi_z \\<le> dist (f z) (p rM) + dist (p rM) pi_z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) pi_z \\<le> dist (f z) (p rM) + dist (p rM) pi_z", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (f z) pi_z \\<le> dist (f z) (p rM) + dist (p rM) pi_z\n\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "also"], ["proof (state)\nthis:\n  dist (f z) pi_z \\<le> dist (f z) (p rM) + dist (p rM) pi_z\n\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "have \"... \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f z) (p rM) + dist (p rM) pi_z\n    \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)", "using * P[of rM] \\<open>rM \\<in> {yM..uM}\\<close>"], ["proof (prove)\nusing this:\n  dist (f z) (p rM) = Gromov_product_at (f z) (p rm) (p rM)\n  rM \\<in> {um..ym} \\<union> {yM..uM} \\<Longrightarrow>\n  dist pi_z (p rM) \\<le> L\n  rM \\<in> {yM..uM}\n\ngoal (1 subgoal):\n 1. dist (f z) (p rM) + dist (p rM) pi_z\n    \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)", "apply (simp add: metric_space_class.dist_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist (f z) (p rM) = Gromov_product_at (f z) (p rm) (p rM);\n     dist pi_z (p rM) \\<le> L; yM \\<le> rM \\<and> rM \\<le> uM\\<rbrakk>\n    \\<Longrightarrow> dist pi_z (p rM) \\<le> L + 2 * deltaG TYPE('a)", "using local.delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dist (f z) (p rM) = Gromov_product_at (f z) (p rm) (p rM);\n     dist pi_z (p rM) \\<le> L; yM \\<le> rM \\<and> rM \\<le> uM\\<rbrakk>\n    \\<Longrightarrow> dist pi_z (p rM) \\<le> L + 2 * deltaG TYPE('a)", "by linarith"], ["proof (state)\nthis:\n  dist (f z) (p rM) + dist (p rM) pi_z\n  \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f z) (p rm) \\<le> dist (f z) (p rM) \\<Longrightarrow>\n    dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "finally"], ["proof (chain)\npicking this:\n  dist (f z) pi_z\n  \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (f z) pi_z\n  \\<le> Gromov_product_at (f z) (p rm) (p rM) + L + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n    \\<le> Gromov_product_at (f z) (p rm) (p rM)", "by simp"], ["proof (state)\nthis:\n  dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (p rm) (p rM)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (p rm) (p rM)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "have \"Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG(TYPE('a)) \\<le> Min {Gromov_product_at (f z) (f rm) (p rm), Gromov_product_at (f z) (p rm) (p rM), Gromov_product_at (f z) (p rM) (f rM)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n    \\<le> Min {Gromov_product_at (f z) (f rm) (p rm),\n               Gromov_product_at (f z) (p rm) (p rM),\n               Gromov_product_at (f z) (p rM) (f rM)}", "using A B C"], ["proof (prove)\nusing this:\n  dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (f rm) (p rm)\n  dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (p rM) (f rM)\n  dist (f z) pi_z - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (p rm) (p rM)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n    \\<le> Min {Gromov_product_at (f z) (f rm) (p rm),\n               Gromov_product_at (f z) (p rm) (p rM),\n               Gromov_product_at (f z) (p rM) (f rM)}", "unfolding Dpi_z"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (f rm) (p rm)\n  Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (p rM) (f rM)\n  Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (p rm) (p rM)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n    \\<le> Min {Gromov_product_at (f z) (f rm) (p rm),\n               Gromov_product_at (f z) (p rm) (p rM),\n               Gromov_product_at (f z) (p rM) (f rM)}", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n  \\<le> Min {Gromov_product_at (f z) (f rm) (p rm),\n             Gromov_product_at (f z) (p rm) (p rM),\n             Gromov_product_at (f z) (p rM) (f rM)}\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "also"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n  \\<le> Min {Gromov_product_at (f z) (f rm) (p rm),\n             Gromov_product_at (f z) (p rm) (p rM),\n             Gromov_product_at (f z) (p rM) (f rM)}\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "have \"... \\<le> Gromov_product_at (f z) (f rm) (f rM) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {Gromov_product_at (f z) (f rm) (p rm),\n         Gromov_product_at (f z) (p rm) (p rM),\n         Gromov_product_at (f z) (p rM) (f rM)}\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + 2 * deltaG TYPE('a)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  Min {Gromov_product_at (f z) (f rm) (p rm),\n       Gromov_product_at (f z) (p rm) (p rM),\n       Gromov_product_at (f z) (p rM) (f rM)}\n  \\<le> Gromov_product_at (f z) (f rm) (f rM) + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "finally"], ["proof (chain)\npicking this:\n  Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (f rm) (f rM) + 2 * deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (f rm) (f rM) + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM) - L - 2 * deltaG TYPE('a)\n  \\<le> Gromov_product_at (f z) (f rm) (f rM) + 2 * deltaG TYPE('a)\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> Gromov_product_at (f z) (f rm) (f rM) + (L + 4 * delta)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?rm \\<in> {um..ym}; ?rM \\<in> {yM..uM}\\<rbrakk>\n  \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                    \\<le> Gromov_product_at (f z) (f ?rm) (f ?rM) +\n                          (L + 4 * delta)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>We have proved the basic facts we will need in the main argument. This argument starts\n      here. It is divided in several cases.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?rm \\<in> {um..ym}; ?rM \\<in> {yM..uM}\\<rbrakk>\n  \\<Longrightarrow> Gromov_product_at (f z) (f um) (f uM)\n                    \\<le> Gromov_product_at (f z) (f ?rm) (f ?rM) +\n                          (L + 4 * delta)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "consider \"dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C\" | \"dm \\<ge> D + 4 * C \\<and> dM \\<le> dm\" | \"dM \\<ge> D + 4 * C \\<and> dm \\<le> dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n             thesis;\n     D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow> thesis;\n     D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n           ?thesis;\n   D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow> ?thesis;\n   D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM) \\<le> L \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n           ?thesis;\n   D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow> ?thesis;\n   D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n           ?thesis;\n   D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow> ?thesis;\n   D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 3. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Case 2.1 of the description before the statement: there are points in $f[um, ym]$ and\n        in $f[yM, uM]$ which are close to $H$. Then one can conclude directly, without relying\n        on the inductive argument, thanks to the quasi-isometry property.\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 3. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "case 1"], ["proof (state)\nthis:\n  dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C\n\ngoal (3 subgoals):\n 1. dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 3. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have I: \"Gromov_product_at (f z) (f closestm) (f closestM) \\<le> lambda^2 * (D + L / 2 + delta + 11/2 * C) - 6 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "proof (cases \"dist (f closestm) (f closestM) \\<le> 12 * delta\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "case True"], ["proof (state)\nthis:\n  dist (f closestm) (f closestM) \\<le> 12 * delta\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"1/lambda * dist closestm closestM - C \\<le> dist (f closestm) (f closestM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / lambda * dist closestm closestM - C\n    \\<le> dist (f closestm) (f closestM)", "using quasi_isometry_onD(2)[OF assms(2)] \\<open>closestm \\<in> {um..ym}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>ym \\<in> {um..z}\\<close>\n            \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>yM \\<in> {z..uM}\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> 1 / lambda * dist ?x ?y - C \\<le> dist (f ?x) (f ?y)\n  closestm \\<in> {um..ym}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n  ym \\<in> {um..z}\n  closestM \\<in> {yM..uM}\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n  yM \\<in> {z..uM}\n\ngoal (1 subgoal):\n 1. 1 / lambda * dist closestm closestM - C\n    \\<le> dist (f closestm) (f closestM)", "by auto"], ["proof (state)\nthis:\n  1 / lambda * dist closestm closestM - C\n  \\<le> dist (f closestm) (f closestM)\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "then"], ["proof (chain)\npicking this:\n  1 / lambda * dist closestm closestM - C\n  \\<le> dist (f closestm) (f closestM)", "have \"dist closestm closestM \\<le> lambda * dist (f closestm) (f closestM) + lambda * C\""], ["proof (prove)\nusing this:\n  1 / lambda * dist closestm closestM - C\n  \\<le> dist (f closestm) (f closestM)\n\ngoal (1 subgoal):\n 1. dist closestm closestM\n    \\<le> lambda * dist (f closestm) (f closestM) + lambda * C", "using \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 / lambda * dist closestm closestM - C\n  \\<le> dist (f closestm) (f closestM)\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. dist closestm closestM\n    \\<le> lambda * dist (f closestm) (f closestM) + lambda * C", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  dist closestm closestM\n  \\<le> lambda * dist (f closestm) (f closestM) + lambda * C\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  dist closestm closestM\n  \\<le> lambda * dist (f closestm) (f closestM) + lambda * C\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... \\<le> lambda * (12 * delta) + lambda * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * dist (f closestm) (f closestM) + lambda * C\n    \\<le> lambda * (12 * delta) + lambda * C", "apply (intro mono_intros True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> lambda", "using \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  lambda * dist (f closestm) (f closestM) + lambda * C\n  \\<le> lambda * (12 * delta) + lambda * C\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist closestm closestM \\<le> lambda * (12 * delta) + lambda * C", "have M: \"dist closestm closestM \\<le> lambda * (12 * delta + C)\""], ["proof (prove)\nusing this:\n  dist closestm closestM \\<le> lambda * (12 * delta) + lambda * C\n\ngoal (1 subgoal):\n 1. dist closestm closestM \\<le> lambda * (12 * delta + C)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist closestm closestM \\<le> lambda * (12 * delta + C)\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"2 * Gromov_product_at (f z) (f closestm) (f closestM) \\<le> dist (f closestm) (f z) + dist (f z) (f (closestM))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> dist (f closestm) (f z) + dist (f z) (f closestM)", "unfolding Gromov_product_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    ((dist (f z) (f closestm) + dist (f z) (f closestM) -\n      dist (f closestm) (f closestM)) /\n     2)\n    \\<le> dist (f closestm) (f z) + dist (f z) (f closestM)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  2 * Gromov_product_at (f z) (f closestm) (f closestM)\n  \\<le> dist (f closestm) (f z) + dist (f z) (f closestM)\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  2 * Gromov_product_at (f z) (f closestm) (f closestM)\n  \\<le> dist (f closestm) (f z) + dist (f z) (f closestM)\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... \\<le> (lambda * dist closestm z + C) + (lambda * dist z closestM + C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f closestm) (f z) + dist (f z) (f closestM)\n    \\<le> lambda * dist closestm z + C + (lambda * dist z closestM + C)", "apply (intro mono_intros quasi_isometry_onD(1)[OF assms(2)])"], ["proof (prove)\ngoal (4 subgoals):\n 1. closestm \\<in> {a..b}\n 2. z \\<in> {a..b}\n 3. z \\<in> {a..b}\n 4. closestM \\<in> {a..b}", "using \\<open>closestm \\<in> {um..ym}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>ym \\<in> {um..z}\\<close>\n            \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>yM \\<in> {z..uM}\\<close>"], ["proof (prove)\nusing this:\n  closestm \\<in> {um..ym}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n  ym \\<in> {um..z}\n  closestM \\<in> {yM..uM}\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n  yM \\<in> {z..uM}\n\ngoal (4 subgoals):\n 1. closestm \\<in> {a..b}\n 2. z \\<in> {a..b}\n 3. z \\<in> {a..b}\n 4. closestM \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda * dist closestm z + C + (lambda * dist z closestM + C)\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda * dist closestm z + C + (lambda * dist z closestM + C)\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... = lambda * dist closestm closestM + 1 * 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * dist closestm z + C + (lambda * dist z closestM + C) =\n    lambda * dist closestm closestM + 1 * 2 * C", "unfolding dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * \\<bar>closestm - z\\<bar> + C +\n    (lambda * \\<bar>z - closestM\\<bar> + C) =\n    lambda * \\<bar>closestm - closestM\\<bar> + 1 * 2 * C", "using \\<open>closestm \\<in> {um..ym}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>ym \\<in> {um..z}\\<close>\n            \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>yM \\<in> {z..uM}\\<close>"], ["proof (prove)\nusing this:\n  closestm \\<in> {um..ym}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n  ym \\<in> {um..z}\n  closestM \\<in> {yM..uM}\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n  yM \\<in> {z..uM}\n\ngoal (1 subgoal):\n 1. lambda * \\<bar>closestm - z\\<bar> + C +\n    (lambda * \\<bar>z - closestM\\<bar> + C) =\n    lambda * \\<bar>closestm - closestM\\<bar> + 1 * 2 * C", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  lambda * dist closestm z + C + (lambda * dist z closestM + C) =\n  lambda * dist closestm closestM + 1 * 2 * C\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  lambda * dist closestm z + C + (lambda * dist z closestM + C) =\n  lambda * dist closestm closestM + 1 * 2 * C\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... \\<le> lambda * (lambda * (12 * delta + C)) + lambda^2 * 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * dist closestm closestM + 1 * 2 * C\n    \\<le> lambda * (lambda * (12 * delta + C)) + lambda\\<^sup>2 * 2 * C", "apply (intro mono_intros M)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<le> lambda\n 2. 1 \\<le> lambda\\<^sup>2\n 3. 0 \\<le> 2\n 4. 0 \\<le> C", "using \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (4 subgoals):\n 1. 0 \\<le> lambda\n 2. 1 \\<le> lambda\\<^sup>2\n 3. 0 \\<le> 2\n 4. 0 \\<le> C", "by auto"], ["proof (state)\nthis:\n  lambda * dist closestm closestM + 1 * 2 * C\n  \\<le> lambda * (lambda * (12 * delta + C)) + lambda\\<^sup>2 * 2 * C\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  lambda * dist closestm closestM + 1 * 2 * C\n  \\<le> lambda * (lambda * (12 * delta + C)) + lambda\\<^sup>2 * 2 * C\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... = lambda^2 * (24 * delta + 3 * C) - lambda^2 * 12 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (lambda * (12 * delta + C)) + lambda\\<^sup>2 * 2 * C =\n    lambda\\<^sup>2 * (24 * delta + 3 * C) - lambda\\<^sup>2 * 12 * delta", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  lambda * (lambda * (12 * delta + C)) + lambda\\<^sup>2 * 2 * C =\n  lambda\\<^sup>2 * (24 * delta + 3 * C) - lambda\\<^sup>2 * 12 * delta\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  lambda * (lambda * (12 * delta + C)) + lambda\\<^sup>2 * 2 * C =\n  lambda\\<^sup>2 * (24 * delta + 3 * C) - lambda\\<^sup>2 * 12 * delta\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... \\<le> lambda^2 * ((2 * D + L + 2 * delta) + 11 * C) - 1 * 12 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (24 * delta + 3 * C) - lambda\\<^sup>2 * 12 * delta\n    \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C) - 1 * 12 * delta", "apply (intro mono_intros)"], ["proof (prove)\ngoal (7 subgoals):\n 1. 24 * delta \\<le> 2 * D + L + 2 * delta\n 2. 3 \\<le> 11\n 3. 0 \\<le> C\n 4. 0 \\<le> lambda\\<^sup>2\n 5. 1 \\<le> lambda\\<^sup>2\n 6. 0 \\<le> 12\n 7. 0 \\<le> delta", "using Laux \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  1 \\<le> lambda\n  0 \\<le> C\n  0 < delta\n\ngoal (7 subgoals):\n 1. 24 * delta \\<le> 2 * D + L + 2 * delta\n 2. 3 \\<le> 11\n 3. 0 \\<le> C\n 4. 0 \\<le> lambda\\<^sup>2\n 5. 1 \\<le> lambda\\<^sup>2\n 6. 0 \\<le> 12\n 7. 0 \\<le> delta", "by auto"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (24 * delta + 3 * C) - lambda\\<^sup>2 * 12 * delta\n  \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C) - 1 * 12 * delta\n\ngoal (2 subgoals):\n 1. dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n 2. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "finally"], ["proof (chain)\npicking this:\n  2 * Gromov_product_at (f z) (f closestm) (f closestM)\n  \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C) - 1 * 12 * delta", "show ?thesis"], ["proof (prove)\nusing this:\n  2 * Gromov_product_at (f z) (f closestm) (f closestM)\n  \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C) - 1 * 12 * delta\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f closestm) (f closestM)\n  \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "case False"], ["proof (state)\nthis:\n  \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"dist closestm closestM \\<le> lambda * (dm + dM + L + 2 * delta + C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist closestm closestM \\<le> lambda * (dm + dM + L + 2 * delta + C)", "using D[OF \\<open>closestm \\<in> {um..ym}\\<close> \\<open>closestM \\<in> {yM..uM}\\<close>] dm_def dM_def"], ["proof (prove)\nusing this:\n  dist closestm closestM\n  \\<le> lambda *\n        (infdist (f closestm) H + (L + C + 2 * delta) +\n         infdist (f closestM) H)\n  dm = infdist (f closestm) H\n  dM = infdist (f closestM) H\n\ngoal (1 subgoal):\n 1. dist closestm closestM \\<le> lambda * (dm + dM + L + 2 * delta + C)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist closestm closestM \\<le> lambda * (dm + dM + L + 2 * delta + C)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  dist closestm closestM \\<le> lambda * (dm + dM + L + 2 * delta + C)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... \\<le> lambda * ((D + 4 * C) + (D + 4 * C) + L + 2 * delta + C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (dm + dM + L + 2 * delta + C)\n    \\<le> lambda * (D + 4 * C + (D + 4 * C) + L + 2 * delta + C)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. dm \\<le> D + 4 * C\n 2. dM \\<le> D + 4 * C\n 3. 0 \\<le> lambda", "using 1 \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C\n  1 \\<le> lambda\n\ngoal (3 subgoals):\n 1. dm \\<le> D + 4 * C\n 2. dM \\<le> D + 4 * C\n 3. 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  lambda * (dm + dM + L + 2 * delta + C)\n  \\<le> lambda * (D + 4 * C + (D + 4 * C) + L + 2 * delta + C)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  lambda * (dm + dM + L + 2 * delta + C)\n  \\<le> lambda * (D + 4 * C + (D + 4 * C) + L + 2 * delta + C)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... \\<le> lambda * (2 * D + L + 2 * delta + 9 * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (D + 4 * C + (D + 4 * C) + L + 2 * delta + C)\n    \\<le> lambda * (2 * D + L + 2 * delta + 9 * C)", "using \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. lambda * (D + 4 * C + (D + 4 * C) + L + 2 * delta + C)\n    \\<le> lambda * (2 * D + L + 2 * delta + 9 * C)", "by auto"], ["proof (state)\nthis:\n  lambda * (D + 4 * C + (D + 4 * C) + L + 2 * delta + C)\n  \\<le> lambda * (2 * D + L + 2 * delta + 9 * C)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist closestm closestM \\<le> lambda * (2 * D + L + 2 * delta + 9 * C)", "have M: \"dist closestm closestM \\<le> lambda * (2 * D + L + 2 * delta + 9 * C)\""], ["proof (prove)\nusing this:\n  dist closestm closestM \\<le> lambda * (2 * D + L + 2 * delta + 9 * C)\n\ngoal (1 subgoal):\n 1. dist closestm closestM \\<le> lambda * (2 * D + L + 2 * delta + 9 * C)", "by (auto simp add: algebra_simps divide_simps metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist closestm closestM \\<le> lambda * (2 * D + L + 2 * delta + 9 * C)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"dist (f closestm) (f z) + dist (f z) (f (closestM)) \\<le> (lambda * dist closestm z + C) + (lambda * dist z closestM + C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f closestm) (f z) + dist (f z) (f closestM)\n    \\<le> lambda * dist closestm z + C + (lambda * dist z closestM + C)", "apply (intro mono_intros quasi_isometry_onD(1)[OF assms(2)])"], ["proof (prove)\ngoal (4 subgoals):\n 1. closestm \\<in> {a..b}\n 2. z \\<in> {a..b}\n 3. z \\<in> {a..b}\n 4. closestM \\<in> {a..b}", "using \\<open>closestm \\<in> {um..ym}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>ym \\<in> {um..z}\\<close>\n            \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>yM \\<in> {z..uM}\\<close>"], ["proof (prove)\nusing this:\n  closestm \\<in> {um..ym}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n  ym \\<in> {um..z}\n  closestM \\<in> {yM..uM}\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n  yM \\<in> {z..uM}\n\ngoal (4 subgoals):\n 1. closestm \\<in> {a..b}\n 2. z \\<in> {a..b}\n 3. z \\<in> {a..b}\n 4. closestM \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda * dist closestm z + C + (lambda * dist z closestM + C)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda * dist closestm z + C + (lambda * dist z closestM + C)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... = lambda * dist closestm closestM + 1 * 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * dist closestm z + C + (lambda * dist z closestM + C) =\n    lambda * dist closestm closestM + 1 * 2 * C", "unfolding dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * \\<bar>closestm - z\\<bar> + C +\n    (lambda * \\<bar>z - closestM\\<bar> + C) =\n    lambda * \\<bar>closestm - closestM\\<bar> + 1 * 2 * C", "using \\<open>closestm \\<in> {um..ym}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>ym \\<in> {um..z}\\<close>\n            \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>yM \\<in> {z..uM}\\<close>"], ["proof (prove)\nusing this:\n  closestm \\<in> {um..ym}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n  ym \\<in> {um..z}\n  closestM \\<in> {yM..uM}\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n  yM \\<in> {z..uM}\n\ngoal (1 subgoal):\n 1. lambda * \\<bar>closestm - z\\<bar> + C +\n    (lambda * \\<bar>z - closestM\\<bar> + C) =\n    lambda * \\<bar>closestm - closestM\\<bar> + 1 * 2 * C", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  lambda * dist closestm z + C + (lambda * dist z closestM + C) =\n  lambda * dist closestm closestM + 1 * 2 * C\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "also"], ["proof (state)\nthis:\n  lambda * dist closestm z + C + (lambda * dist z closestM + C) =\n  lambda * dist closestm closestM + 1 * 2 * C\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "have \"... \\<le> lambda * (lambda * (2 * D + L + 2 * delta + 9 * C)) + lambda^2 * 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * dist closestm closestM + 1 * 2 * C\n    \\<le> lambda * (lambda * (2 * D + L + 2 * delta + 9 * C)) +\n          lambda\\<^sup>2 * 2 * C", "apply (intro mono_intros M)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<le> lambda\n 2. 1 \\<le> lambda\\<^sup>2\n 3. 0 \\<le> 2\n 4. 0 \\<le> C", "using \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (4 subgoals):\n 1. 0 \\<le> lambda\n 2. 1 \\<le> lambda\\<^sup>2\n 3. 0 \\<le> 2\n 4. 0 \\<le> C", "by auto"], ["proof (state)\nthis:\n  lambda * dist closestm closestM + 1 * 2 * C\n  \\<le> lambda * (lambda * (2 * D + L + 2 * delta + 9 * C)) +\n        lambda\\<^sup>2 * 2 * C\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "finally"], ["proof (chain)\npicking this:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda * (lambda * (2 * D + L + 2 * delta + 9 * C)) +\n        lambda\\<^sup>2 * 2 * C", "have \"dist (f closestm) (f z) + dist (f z) (f closestM) \\<le> lambda^2 * (2 * D + L + 2 * delta + 11 * C)\""], ["proof (prove)\nusing this:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda * (lambda * (2 * D + L + 2 * delta + 9 * C)) +\n        lambda\\<^sup>2 * 2 * C\n\ngoal (1 subgoal):\n 1. dist (f closestm) (f z) + dist (f z) (f closestM)\n    \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C)", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C)\n\ngoal (1 subgoal):\n 1. \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta \\<Longrightarrow>\n    Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "then"], ["proof (chain)\npicking this:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C)", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f closestm) (f closestM)\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "unfolding Gromov_product_at_def"], ["proof (prove)\nusing this:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C)\n\ngoal (1 subgoal):\n 1. (dist (f z) (f closestm) + dist (f z) (f closestM) -\n     dist (f closestm) (f closestM)) /\n    2\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "using False"], ["proof (prove)\nusing this:\n  dist (f closestm) (f z) + dist (f z) (f closestM)\n  \\<le> lambda\\<^sup>2 * (2 * D + L + 2 * delta + 11 * C)\n  \\<not> dist (f closestm) (f closestM) \\<le> 12 * delta\n\ngoal (1 subgoal):\n 1. (dist (f z) (f closestm) + dist (f z) (f closestM) -\n     dist (f closestm) (f closestM)) /\n    2\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta", "by (simp add: metric_space_class.dist_commute algebra_simps divide_simps)"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f closestm) (f closestM)\n  \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f closestm) (f closestM)\n  \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta\n\ngoal (3 subgoals):\n 1. dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 3. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"Gromov_product_at (f z) (f um) (f uM) \\<le> Gromov_product_at (f z) (f closestm) (f closestM) + 1 * L + 4 * delta + 0 * (1 - exp (- K * (uM - um)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f closestm) (f closestM) + 1 * L +\n          4 * delta +\n          0 * (1 - exp (- K * (uM - um)))", "using Rec[OF \\<open>closestm \\<in> {um..ym}\\<close> \\<open>closestM \\<in> {yM..uM}\\<close>]"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> Gromov_product_at (f z) (f closestm) (f closestM) + (L + 4 * delta)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f closestm) (f closestM) + 1 * L +\n          4 * delta +\n          0 * (1 - exp (- K * (uM - um)))", "by simp"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> Gromov_product_at (f z) (f closestm) (f closestM) + 1 * L +\n        4 * delta +\n        0 * (1 - exp (- K * (uM - um)))\n\ngoal (3 subgoals):\n 1. dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 3. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> Gromov_product_at (f z) (f closestm) (f closestM) + 1 * L +\n        4 * delta +\n        0 * (1 - exp (- K * (uM - um)))\n\ngoal (3 subgoals):\n 1. dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 3. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... \\<le> (lambda^2 * (D + L / 2 + delta + 11/2 * C) - 6 * delta) + lambda^2 * L + 4 * delta + Kmult * (1 - exp (- K * (uM - um)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f closestm) (f closestM) + 1 * L + 4 * delta +\n    0 * (1 - exp (- K * (uM - um)))\n    \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta +\n          lambda\\<^sup>2 * L +\n          4 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "apply (intro mono_intros I)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> L\n 3. 0 \\<le> Kmult\n 4. 0 \\<le> 1 - exp (- K * (uM - um))", "using Laux \\<open>lambda \\<ge> 1\\<close> \\<open>delta > 0\\<close> \\<open>Kmult > 0\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>K > 0\\<close>"], ["proof (prove)\nusing this:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  1 \\<le> lambda\n  0 < delta\n  0 < Kmult\n  um \\<in> {a..z}\n  uM \\<in> {z..b}\n  0 < K\n\ngoal (4 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> L\n 3. 0 \\<le> Kmult\n 4. 0 \\<le> 1 - exp (- K * (uM - um))", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f closestm) (f closestM) + 1 * L + 4 * delta +\n  0 * (1 - exp (- K * (uM - um)))\n  \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta +\n        lambda\\<^sup>2 * L +\n        4 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (3 subgoals):\n 1. dm \\<le> D + 4 * C \\<and> dM \\<le> D + 4 * C \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 3. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta +\n        lambda\\<^sup>2 * L +\n        4 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + L / 2 + delta + 11 / 2 * C) - 6 * delta +\n        lambda\\<^sup>2 * L +\n        4 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>End of the easy case 2.1\\<close>"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Case 2.2: $dm$ is large, i.e., all points in $f[um, ym]$ are far away from $H$. Moreover,\n        assume that $dm \\geq dM$. Then we will find a pair of points $v$ and $x$ with $um \\leq v\n        \\leq x \\leq ym$ satisfying the estimate~\\eqref{eq:xvK}. We argue by induction: while we\n        have not found such a pair, we can find a point $x_k$ whose projection on $V_k$, the\n        neighborhood of size $(2^k-1) dm$ of $H$, is far enough from the projection of $um$, and\n        such that all points in between are far enough from $V_k$ so that the corresponding\n        projection will have good contraction properties.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "case 2"], ["proof (state)\nthis:\n  D + 4 * C \\<le> dm \\<and> dM \\<le> dm\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  D + 4 * C \\<le> dm \\<and> dM \\<le> dm", "have I: \"D + 4 * C \\<le> dm\" \"dM \\<le> dm\""], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm \\<and> dM \\<le> dm\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dm &&& dM \\<le> dm", "by auto"], ["proof (state)\nthis:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define V where \"V = (\\<lambda>k::nat. (\\<Union>g\\<in>H. cball g ((2^k - 1) * dm)))\""], ["proof (state)\nthis:\n  V = (\\<lambda>k. \\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define QC where \"QC = (\\<lambda>k::nat. if k = 0 then 0 else 8 * delta)\""], ["proof (state)\nthis:\n  QC = (\\<lambda>k. if k = 0 then 0 else 8 * delta)\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"QC k \\<ge> 0\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> QC k", "unfolding QC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (if k = 0 then 0 else 8 * delta)", "using \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n\ngoal (1 subgoal):\n 1. 0 \\<le> (if k = 0 then 0 else 8 * delta)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> QC ?k\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have Q: \"quasiconvex (0 + 8 * deltaG(TYPE('a))) (V k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (0 + 8 * deltaG TYPE('a)) (V k)", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (0 + 8 * deltaG TYPE('a))\n     (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))", "apply (rule quasiconvex_thickening)"], ["proof (prove)\ngoal (2 subgoals):\n 1. quasiconvex 0 H\n 2. 0 \\<le> (2 ^ k - 1) * dm", "using geodesic_segmentI[OF H]"], ["proof (prove)\nusing this:\n  geodesic_segment H\n\ngoal (2 subgoals):\n 1. quasiconvex 0 H\n 2. 0 \\<le> (2 ^ k - 1) * dm", "by (auto simp add: quasiconvex_of_geodesic)"], ["proof (state)\nthis:\n  quasiconvex (0 + 8 * deltaG TYPE('a)) (V ?k)\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"quasiconvex (QC k) (V k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (QC k) (V k)", "apply (cases \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> quasiconvex (QC k) (V k)\n 2. k \\<noteq> 0 \\<Longrightarrow> quasiconvex (QC k) (V k)", "apply (simp add: V_def QC_def quasiconvex_of_geodesic geodesic_segmentI[OF H])"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> quasiconvex (QC k) (V k)", "apply (rule quasiconvex_mono[OF _ Q[of k]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> 0 + 8 * deltaG TYPE('a) \\<le> QC k", "using \\<open>deltaG(TYPE('a)) < delta\\<close> QC_def"], ["proof (prove)\nusing this:\n  deltaG TYPE('a) < delta\n  QC = (\\<lambda>k. if k = 0 then 0 else 8 * delta)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> 0 + 8 * deltaG TYPE('a) \\<le> QC k", "by auto"], ["proof (state)\nthis:\n  quasiconvex (QC ?k) (V ?k)\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>Define $q(k, x)$ to be the projection of $f(x)$ on $V_k$.\\<close>"], ["proof (state)\nthis:\n  quasiconvex (QC ?k) (V ?k)\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define q::\"nat \\<Rightarrow> real \\<Rightarrow> 'a\" where \"q = (\\<lambda>k x. geodesic_segment_param {p x--f x} (p x) ((2^k - 1) * dm))\""], ["proof (state)\nthis:\n  q =\n  (\\<lambda>k x. geodesic_segment_param {p x--f x} (p x) ((2 ^ k - 1) * dm))\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>The inductive argument\\<close>"], ["proof (state)\nthis:\n  q =\n  (\\<lambda>k x. geodesic_segment_param {p x--f x} (p x) ((2 ^ k - 1) * dm))\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have Ind_k: \"(Gromov_product_at (f z) (f um) (f uM) \\<le> lambda^2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(- K * (uM - um))))\n              \\<or> (\\<exists>x \\<in> {um..ym}. (\\<forall>w \\<in> {um..x}. dist (f w) (p w) \\<ge> (2^(k+1)-1) * dm) \\<and> dist (q k um) (q k x) \\<ge> L - 4 * delta + 7 * QC k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x))", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x))\n 2. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k um) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Base case: there is a point far enough from $q 0 um$ on $H$. This is just the point $ym$,\n          by construction.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x))\n 2. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k um) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) um) (q (Suc k) x))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x))\n 2. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k um) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have *: \"\\<exists>x\\<in> {um..ym}. (\\<forall>w \\<in> {um..x}. dist (f w) (p w) \\<ge> (2^(0+1)-1) * dm) \\<and> dist (q 0 um) (q 0 x) \\<ge> L - 4 * delta + 7 * QC 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{um..ym}.\n       (\\<forall>w\\<in>{um..x}.\n           (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n       L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x)", "proof (rule bexI[of _ ym], auto simp add: V_def q_def QC_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>um \\<le> w; w \\<le> ym\\<rbrakk>\n       \\<Longrightarrow> dm \\<le> dist (f w) (p w)\n 2. L - 4 * delta \\<le> dist (p um) (p ym)\n 3. um \\<le> ym", "show \"um \\<le> ym\""], ["proof (prove)\ngoal (1 subgoal):\n 1. um \\<le> ym", "using \\<open>ym \\<in> {um..z}\\<close>"], ["proof (prove)\nusing this:\n  ym \\<in> {um..z}\n\ngoal (1 subgoal):\n 1. um \\<le> ym", "by auto"], ["proof (state)\nthis:\n  um \\<le> ym\n\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>um \\<le> w; w \\<le> ym\\<rbrakk>\n       \\<Longrightarrow> dm \\<le> dist (f w) (p w)\n 2. L - 4 * delta \\<le> dist (p um) (p ym)", "show \"L - 4 * delta \\<le> dist (p um) (p ym)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L - 4 * delta \\<le> dist (p um) (p ym)", "using ym(2)"], ["proof (prove)\nusing this:\n  dist (p um) (p ym)\n  \\<in> {L + dist pi_z (p um) - 4 * delta - 2 * 0..L + dist pi_z (p um)}\n\ngoal (1 subgoal):\n 1. L - 4 * delta \\<le> dist (p um) (p ym)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L + dist pi_z (p um) - 4 * delta \\<le> dist (p um) (p ym);\n     dist (p um) (p ym) \\<le> L + dist pi_z (p um)\\<rbrakk>\n    \\<Longrightarrow> L - 4 * delta \\<le> dist (p um) (p ym)", "using metric_space_class.zero_le_dist[of pi_z \"p um\"]"], ["proof (prove)\nusing this:\n  0 \\<le> dist pi_z (p um)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L + dist pi_z (p um) - 4 * delta \\<le> dist (p um) (p ym);\n     dist (p um) (p ym) \\<le> L + dist pi_z (p um)\\<rbrakk>\n    \\<Longrightarrow> L - 4 * delta \\<le> dist (p um) (p ym)", "by linarith"], ["proof (state)\nthis:\n  L - 4 * delta \\<le> dist (p um) (p ym)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>um \\<le> w; w \\<le> ym\\<rbrakk>\n       \\<Longrightarrow> dm \\<le> dist (f w) (p w)", "show \"\\<And>y. um \\<le> y \\<Longrightarrow> y \\<le> ym \\<Longrightarrow> dm \\<le> dist (f y) (p y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>um \\<le> y; y \\<le> ym\\<rbrakk>\n       \\<Longrightarrow> dm \\<le> dist (f y) (p y)", "using dm_def closestm proj_setD(2)[OF p]"], ["proof (prove)\nusing this:\n  dm = infdist (f closestm) H\n  closestm \\<in> {um..ym}\n  ?v \\<in> {um..ym} \\<Longrightarrow>\n  infdist (f closestm) H \\<le> infdist (f ?v) H\n  dist (f ?x1) (p ?x1) = infdist (f ?x1) H\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>um \\<le> y; y \\<le> ym\\<rbrakk>\n       \\<Longrightarrow> dm \\<le> dist (f y) (p y)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>um \\<le> ?y; ?y \\<le> ym\\<rbrakk>\n  \\<Longrightarrow> dm \\<le> dist (f ?y) (p ?y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{um..ym}.\n     (\\<forall>w\\<in>{um..x}.\n         (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n     L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x)\n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x))\n 2. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k um) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) um) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>{um..ym}.\n     (\\<forall>w\\<in>{um..x}.\n         (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n     L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>{um..ym}.\n     (\\<forall>w\\<in>{um..x}.\n         (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n     L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x))", "by blast"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (0 + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 um) (q 0 x))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k um) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) um) (q (Suc k) x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k um) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>The induction. The inductive assumption claims that, either the desired inequality\n          holds, or one can construct a point with good properties. If the desired inequality holds,\n          there is nothing left to prove. Otherwise, we can start from this point at step $k$,\n          say $x$, and either prove the desired inequality or construct a point with the good\n          properties at step $k+1$.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k um) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) um) (q (Suc k) x))", "case Suck: (Suc k)"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k um) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{um..ym}.\n           (\\<forall>w\\<in>{um..x}.\n               (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) um) (q (Suc k) x))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "proof (cases \"Gromov_product_at (f z) (f um) (f uM) \\<le> lambda\\<^sup>2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp (- K * (uM - um)))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "case True"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "by simp"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) um) (q (Suc k) x))\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "case False"], ["proof (state)\nthis:\n  \\<not> Gromov_product_at (f z) (f um) (f uM)\n         \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n               2 * delta +\n               Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<not> Gromov_product_at (f z) (f um) (f uM)\n         \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n               2 * delta +\n               Kmult * (1 - exp (- K * (uM - um)))", "obtain x where x: \"x \\<in> {um..ym}\" \"dist (q k um) (q k x) \\<ge> L - 4 * delta + 7 * QC k\"\n                                   \"\\<And>w. w \\<in> {um..x} \\<Longrightarrow> dist (f w) (p w) \\<ge> (2^(k+1)-1) * dm\""], ["proof (prove)\nusing this:\n  \\<not> Gromov_product_at (f z) (f um) (f uM)\n         \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n               2 * delta +\n               Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {um..ym};\n         L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x);\n         \\<And>w.\n            w \\<in> {um..x} \\<Longrightarrow>\n            (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suck.IH"], ["proof (prove)\nusing this:\n  \\<not> Gromov_product_at (f z) (f um) (f uM)\n         \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n               2 * delta +\n               Kmult * (1 - exp (- K * (uM - um)))\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {um..ym};\n         L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x);\n         \\<And>w.\n            w \\<in> {um..x} \\<Longrightarrow>\n            (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> {um..ym}\n  L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x)\n  ?w \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f ?w) (p ?w)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Some auxiliary technical inequalities to be used later on.\\<close>"], ["proof (state)\nthis:\n  x \\<in> {um..ym}\n  L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x)\n  ?w \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f ?w) (p ?w)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have aux: \"(2 ^ k - 1) * dm \\<le> (2*2^k-1) * dm\" \"0 \\<le> 2 * 2 ^ k - (1::real)\" \"dm \\<le> dm * 2 ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm &&&\n    0 \\<le> 2 * 2 ^ k - 1 &&& dm \\<le> dm * 2 ^ k", "apply (auto simp add: algebra_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 \\<le> 2 * 2 ^ k\n 2. dm \\<le> dm * 2 ^ k", "apply (metis power.simps(2) two_realpow_ge_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dm \\<le> dm * 2 ^ k", "using \\<open>0 \\<le> dm\\<close> less_eq_real_def"], ["proof (prove)\nusing this:\n  0 \\<le> dm\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. dm \\<le> dm * 2 ^ k", "by fastforce"], ["proof (state)\nthis:\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"L + C = (L/D) * (D + (D/L) * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L + C = L / D * (D + D / L * C)", "using \\<open>L > 0\\<close> \\<open>D > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < L\n  0 < D\n\ngoal (1 subgoal):\n 1. L + C = L / D * (D + D / L * C)", "by (simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  L + C = L / D * (D + D / L * C)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L + C = L / D * (D + D / L * C)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> (L/D) * (D + 4 * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L / D * (D + D / L * C) \\<le> L / D * (D + 4 * C)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. D / L \\<le> 4\n 2. 0 \\<le> C\n 3. 0 \\<le> L / D", "using \\<open>L > 0\\<close> \\<open>D > 0\\<close> \\<open>C \\<ge> 0\\<close> \\<open>D \\<le> 4 * L\\<close>"], ["proof (prove)\nusing this:\n  0 < L\n  0 < D\n  0 \\<le> C\n  D \\<le> 4 * L\n\ngoal (3 subgoals):\n 1. D / L \\<le> 4\n 2. 0 \\<le> C\n 3. 0 \\<le> L / D", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  L / D * (D + D / L * C) \\<le> L / D * (D + 4 * C)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L / D * (D + D / L * C) \\<le> L / D * (D + 4 * C)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> (L/D) * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L / D * (D + 4 * C) \\<le> L / D * dm", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm\n 2. 0 \\<le> L / D", "using I \\<open>L > 0\\<close> \\<open>D > 0\\<close>"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 < L\n  0 < D\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm\n 2. 0 \\<le> L / D", "by auto"], ["proof (state)\nthis:\n  L / D * (D + 4 * C) \\<le> L / D * dm\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L + C \\<le> L / D * dm", "have \"L + C \\<le> (L/D) * dm\""], ["proof (prove)\nusing this:\n  L + C \\<le> L / D * dm\n\ngoal (1 subgoal):\n 1. L + C \\<le> L / D * dm", "by simp"], ["proof (state)\nthis:\n  L + C \\<le> L / D * dm\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "moreover"], ["proof (state)\nthis:\n  L + C \\<le> L / D * dm\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"2 * delta \\<le> (2 * delta)/D * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * delta \\<le> 2 * delta / D * dm", "using I \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close> \\<open>D > 0\\<close>"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 \\<le> C\n  0 < delta\n  0 < D\n\ngoal (1 subgoal):\n 1. 2 * delta \\<le> 2 * delta / D * dm", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  2 * delta \\<le> 2 * delta / D * dm\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "ultimately"], ["proof (chain)\npicking this:\n  L + C \\<le> L / D * dm\n  2 * delta \\<le> 2 * delta / D * dm", "have aux2: \"L + C + 2 * delta \\<le> ((L + 2 * delta)/D) * dm\""], ["proof (prove)\nusing this:\n  L + C \\<le> L / D * dm\n  2 * delta \\<le> 2 * delta / D * dm\n\ngoal (1 subgoal):\n 1. L + C + 2 * delta \\<le> (L + 2 * delta) / D * dm", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  L + C + 2 * delta \\<le> (L + 2 * delta) / D * dm\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have aux3: \"(1-alpha) * D + alpha * 2^k * dm \\<le> dm * 2^k - C/2 - QC k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "using I \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "unfolding True QC_def alpha_def"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (1 - 12 / 100) * D + 12 / 100 * 2 ^ 0 * dm\n    \\<le> dm * 2 ^ 0 - C / 2 - (if 0 = 0 then 0 else 8 * delta)", "by auto"], ["proof (state)\nthis:\n  (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "have \"C/2 + QC k + (1-alpha) * D \\<le> 2 * (1-alpha) * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C / 2 + QC k + (1 - alpha) * D \\<le> 2 * (1 - alpha) * dm", "using I \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. C / 2 + QC k + (1 - alpha) * D \\<le> 2 * (1 - alpha) * dm", "unfolding QC_def alpha_def"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. C / 2 + (if k = 0 then 0 else 8 * delta) + (1 - 12 / 100) * D\n    \\<le> 2 * (1 - 12 / 100) * dm", "using False Laux"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 \\<le> C\n  k \\<noteq> 0\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. C / 2 + (if k = 0 then 0 else 8 * delta) + (1 - 12 / 100) * D\n    \\<le> 2 * (1 - 12 / 100) * dm", "by auto"], ["proof (state)\nthis:\n  C / 2 + QC k + (1 - alpha) * D \\<le> 2 * (1 - alpha) * dm\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "also"], ["proof (state)\nthis:\n  C / 2 + QC k + (1 - alpha) * D \\<le> 2 * (1 - alpha) * dm\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "have \"... \\<le> 2^k * (1-alpha) * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (1 - alpha) * dm \\<le> 2 ^ k * (1 - alpha) * dm", "apply (intro mono_intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1 \\<le> 2\n 2. 0 < k\n 3. 0 \\<le> 1 - alpha\n 4. 0 \\<le> dm", "using False alphaaux I \\<open>D > 0\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  0 < alpha\n  alpha \\<le> 1\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 < D\n  0 \\<le> C\n\ngoal (4 subgoals):\n 1. 1 \\<le> 2\n 2. 0 < k\n 3. 0 \\<le> 1 - alpha\n 4. 0 \\<le> dm", "by auto"], ["proof (state)\nthis:\n  2 * (1 - alpha) * dm \\<le> 2 ^ k * (1 - alpha) * dm\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "finally"], ["proof (chain)\npicking this:\n  C / 2 + QC k + (1 - alpha) * D \\<le> 2 ^ k * (1 - alpha) * dm", "show ?thesis"], ["proof (prove)\nusing this:\n  C / 2 + QC k + (1 - alpha) * D \\<le> 2 ^ k * (1 - alpha) * dm\n\ngoal (1 subgoal):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Construct a point $w$ such that its projection on $V_k$ is close to that of $um$\n            and therefore far away from that of $x$. This is just the intermediate value theorem\n            (with some care as the closest point projection is not continuous).\\<close>"], ["proof (state)\nthis:\n  (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"\\<exists>w \\<in> {um..x}. (dist (q k um) (q k w) \\<in> {(9 * delta + 4 * QC k) - 4 * delta - 2 * QC k .. 9 * delta + 4 * QC k})\n                    \\<and> (\\<forall>v \\<in> {um..w}. dist (q k um) (q k v) \\<le> 9 * delta + 4 * QC k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>{um..x}.\n       dist (q k um) (q k w)\n       \\<in> {9 * delta + 4 * QC k - 4 * delta -\n              2 * QC k..9 * delta + 4 * QC k} \\<and>\n       (\\<forall>v\\<in>{um..w}.\n           dist (q k um) (q k v) \\<le> 9 * delta + 4 * QC k)", "proof (rule quasi_convex_projection_small_gaps[where ?f = f and ?G = \"V k\"])"], ["proof (state)\ngoal (6 subgoals):\n 1. continuous_on {um..x} f\n 2. um \\<le> x\n 3. quasiconvex (QC k) (V k)\n 4. \\<And>w.\n       w \\<in> {um..x} \\<Longrightarrow> q k w \\<in> proj_set (f w) (V k)\n 5. deltaG TYPE('a) < delta\n 6. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k um) (q k x)}", "show \"continuous_on {um..x} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {um..x} f", "apply (rule continuous_on_subset[OF \\<open>continuous_on {a..b} f\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {um..x} \\<subseteq> {a..b}", "using \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>x \\<in> {um..ym}\\<close>"], ["proof (prove)\nusing this:\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n  ym \\<in> {um..z}\n  x \\<in> {um..ym}\n\ngoal (1 subgoal):\n 1. {um..x} \\<subseteq> {a..b}", "by auto"], ["proof (state)\nthis:\n  continuous_on {um..x} f\n\ngoal (5 subgoals):\n 1. um \\<le> x\n 2. quasiconvex (QC k) (V k)\n 3. \\<And>w.\n       w \\<in> {um..x} \\<Longrightarrow> q k w \\<in> proj_set (f w) (V k)\n 4. deltaG TYPE('a) < delta\n 5. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k um) (q k x)}", "show \"um \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. um \\<le> x", "using \\<open>x \\<in> {um..ym}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> {um..ym}\n\ngoal (1 subgoal):\n 1. um \\<le> x", "by auto"], ["proof (state)\nthis:\n  um \\<le> x\n\ngoal (4 subgoals):\n 1. quasiconvex (QC k) (V k)\n 2. \\<And>w.\n       w \\<in> {um..x} \\<Longrightarrow> q k w \\<in> proj_set (f w) (V k)\n 3. deltaG TYPE('a) < delta\n 4. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k um) (q k x)}", "show \"quasiconvex (QC k) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (QC k) (V k)", "by fact"], ["proof (state)\nthis:\n  quasiconvex (QC k) (V k)\n\ngoal (3 subgoals):\n 1. \\<And>w.\n       w \\<in> {um..x} \\<Longrightarrow> q k w \\<in> proj_set (f w) (V k)\n 2. deltaG TYPE('a) < delta\n 3. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k um) (q k x)}", "show \"deltaG TYPE('a) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) < delta", "by fact"], ["proof (state)\nthis:\n  deltaG TYPE('a) < delta\n\ngoal (2 subgoals):\n 1. \\<And>w.\n       w \\<in> {um..x} \\<Longrightarrow> q k w \\<in> proj_set (f w) (V k)\n 2. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k um) (q k x)}", "show \"9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k um) (q k x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k um) (q k x)}", "using x(2) \\<open>delta > 0\\<close> \\<open>QC k \\<ge> 0\\<close> Laux"], ["proof (prove)\nusing this:\n  L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x)\n  0 < delta\n  0 \\<le> QC k\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k um) (q k x)}", "by auto"], ["proof (state)\nthis:\n  9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k um) (q k x)}\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> {um..x} \\<Longrightarrow> q k w \\<in> proj_set (f w) (V k)", "show \"q k w \\<in> proj_set (f w) (V k)\" if \"w \\<in> {um..x}\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. q k w \\<in> proj_set (f w) (V k)", "unfolding V_def q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p w--f w} (p w) ((2 ^ k - 1) * dm)\n    \\<in> proj_set (f w) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p w \\<in> proj_set (f w) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p w) (f w)\n 4. geodesic_segment_between {p w--f w} (p w) (f w)", "using aux p x(3)[OF that]"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n  p ?x \\<in> proj_set (f ?x) H\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)\n\ngoal (4 subgoals):\n 1. p w \\<in> proj_set (f w) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p w) (f w)\n 4. geodesic_segment_between {p w--f w} (p w) (f w)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  ?w \\<in> {um..x} \\<Longrightarrow> q k ?w \\<in> proj_set (f ?w) (V k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w\\<in>{um..x}.\n     dist (q k um) (q k w)\n     \\<in> {9 * delta + 4 * QC k - 4 * delta -\n            2 * QC k..9 * delta + 4 * QC k} \\<and>\n     (\\<forall>v\\<in>{um..w}.\n         dist (q k um) (q k v) \\<le> 9 * delta + 4 * QC k)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>{um..x}.\n     dist (q k um) (q k w)\n     \\<in> {9 * delta + 4 * QC k - 4 * delta -\n            2 * QC k..9 * delta + 4 * QC k} \\<and>\n     (\\<forall>v\\<in>{um..w}.\n         dist (q k um) (q k v) \\<le> 9 * delta + 4 * QC k)", "obtain w where w: \"w \\<in> {um..x}\"\n                                   \"dist (q k um) (q k w) \\<in> {(9 * delta + 4 * QC k) - 4 * delta - 2 * QC k .. 9 * delta + 4 * QC k}\"\n                                   \"\\<And>v. v \\<in> {um..w} \\<Longrightarrow> dist (q k um) (q k v) \\<le> 9 * delta + 4 * QC k\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>{um..x}.\n     dist (q k um) (q k w)\n     \\<in> {9 * delta + 4 * QC k - 4 * delta -\n            2 * QC k..9 * delta + 4 * QC k} \\<and>\n     (\\<forall>v\\<in>{um..w}.\n         dist (q k um) (q k v) \\<le> 9 * delta + 4 * QC k)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> {um..x};\n         dist (q k um) (q k w)\n         \\<in> {9 * delta + 4 * QC k - 4 * delta -\n                2 * QC k..9 * delta + 4 * QC k};\n         \\<And>v.\n            v \\<in> {um..w} \\<Longrightarrow>\n            dist (q k um) (q k v) \\<le> 9 * delta + 4 * QC k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> {um..x}\n  dist (q k um) (q k w)\n  \\<in> {9 * delta + 4 * QC k - 4 * delta - 2 * QC k..9 * delta + 4 * QC k}\n  ?v \\<in> {um..w} \\<Longrightarrow>\n  dist (q k um) (q k ?v) \\<le> 9 * delta + 4 * QC k\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>There are now two cases to be considered: either one can find a point $v$ between\n            $um$ and $w$ which is close enough to $H$. Then this point will satisfy~\\eqref{eq:xvK},\n            and we will be able to prove the desired inequality. Or there is no such point,\n            and then $w$ will have the good properties at step $k+1$\\<close>"], ["proof (state)\nthis:\n  w \\<in> {um..x}\n  dist (q k um) (q k w)\n  \\<in> {9 * delta + 4 * QC k - 4 * delta - 2 * QC k..9 * delta + 4 * QC k}\n  ?v \\<in> {um..w} \\<Longrightarrow>\n  dist (q k um) (q k ?v) \\<le> 9 * delta + 4 * QC k\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "proof (cases \"\\<exists>v \\<in> {um..w}. dist (f v) (p v) \\<le> (2^(k+2)-1) * dm\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>{um..w}. dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>First subcase: there is a good point $v$ between $um$ and $w$. This is the\n              heart of the argument: we will show that the desired inequality holds.\\<close>"], ["proof (state)\nthis:\n  \\<exists>v\\<in>{um..w}. dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>{um..w}. dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm", "obtain v where v: \"v \\<in> {um..w}\" \"dist (f v) (p v) \\<le> (2^(k+2)-1) * dm\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>{um..w}. dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> {um..w};\n         dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> {um..w}\n  dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Auxiliary basic fact to be used later on.\\<close>"], ["proof (state)\nthis:\n  v \\<in> {um..w}\n  dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have aux4: \"dm * 2 ^ k \\<le> infdist (f r) (V k)\" if \"r \\<in> {v..x}\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "have *: \"q k r \\<in> proj_set (f r) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k r \\<in> proj_set (f r) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm)\n    \\<in> proj_set (f r) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p r \\<in> proj_set (f r) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p r) (f r)\n 4. geodesic_segment_between {p r--f r} (p r) (f r)", "using aux p[of r] x(3)[of r] that \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n  p r \\<in> proj_set (f r) H\n  r \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f r) (p r)\n  r \\<in> {v..x}\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n\ngoal (4 subgoals):\n 1. p r \\<in> proj_set (f r) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p r) (f r)\n 4. geodesic_segment_between {p r--f r} (p r) (f r)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k r \\<in> proj_set (f r) (V k)\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "have \"infdist (f r) (V k) = dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r))) (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f r) (V k) =\n    dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n     (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm))", "using proj_setD(2)[OF *]"], ["proof (prove)\nusing this:\n  dist (f r) (q k r) = infdist (f r) (V k)\n\ngoal (1 subgoal):\n 1. infdist (f r) (V k) =\n    dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n     (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm))", "unfolding q_def"], ["proof (prove)\nusing this:\n  dist (f r) (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm)) =\n  infdist (f r) (V k)\n\ngoal (1 subgoal):\n 1. infdist (f r) (V k) =\n    dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n     (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm))", "by auto"], ["proof (state)\nthis:\n  infdist (f r) (V k) =\n  dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n   (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm))\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "also"], ["proof (state)\nthis:\n  infdist (f r) (V k) =\n  dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n   (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm))\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "have \"... = abs(dist (p r) (f r) - (2 ^ k - 1) * dm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n     (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm)) =\n    \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dm\\<bar>", "apply (rule geodesic_segment_param(7)[where ?y = \"f r\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment_between {p r--f r} (p r) (f r)\n 2. dist (p r) (f r) \\<in> {0..dist (p r) (f r)}\n 3. (2 ^ k - 1) * dm \\<in> {0..dist (p r) (f r)}", "using x(3)[of r] \\<open>r \\<in> {v..x}\\<close> \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close> aux"], ["proof (prove)\nusing this:\n  r \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f r) (p r)\n  r \\<in> {v..x}\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n\ngoal (3 subgoals):\n 1. geodesic_segment_between {p r--f r} (p r) (f r)\n 2. dist (p r) (f r) \\<in> {0..dist (p r) (f r)}\n 3. (2 ^ k - 1) * dm \\<in> {0..dist (p r) (f r)}", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n   (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm)) =\n  \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dm\\<bar>\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "also"], ["proof (state)\nthis:\n  dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n   (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dm)) =\n  \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dm\\<bar>\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "have \"... = dist (f r) (p r) - (2 ^ k - 1) * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dm\\<bar> =\n    dist (f r) (p r) - (2 ^ k - 1) * dm", "using x(3)[of r] \\<open>r \\<in> {v..x}\\<close> \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close> aux"], ["proof (prove)\nusing this:\n  r \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f r) (p r)\n  r \\<in> {v..x}\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dm\\<bar> =\n    dist (f r) (p r) - (2 ^ k - 1) * dm", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dm\\<bar> =\n  dist (f r) (p r) - (2 ^ k - 1) * dm\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "finally"], ["proof (chain)\npicking this:\n  infdist (f r) (V k) = dist (f r) (p r) - (2 ^ k - 1) * dm", "have \"dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dm\""], ["proof (prove)\nusing this:\n  infdist (f r) (V k) = dist (f r) (p r) - (2 ^ k - 1) * dm\n\ngoal (1 subgoal):\n 1. dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dm", "by simp"], ["proof (state)\nthis:\n  dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dm\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "moreover"], ["proof (state)\nthis:\n  dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dm\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "have \"(2^(k+1) - 1) * dm \\<le> dist (f r) (p r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ (k + 1) - 1) * dm \\<le> dist (f r) (p r)", "apply (rule x(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> {um..x}", "using \\<open>r \\<in> {v..x}\\<close> \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  r \\<in> {v..x}\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n\ngoal (1 subgoal):\n 1. r \\<in> {um..x}", "by auto"], ["proof (state)\nthis:\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f r) (p r)\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "ultimately"], ["proof (chain)\npicking this:\n  dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dm\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f r) (p r)", "have \"(2^(k+1) - 1) * dm \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dm\""], ["proof (prove)\nusing this:\n  dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dm\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f r) (p r)\n\ngoal (1 subgoal):\n 1. (2 ^ (k + 1) - 1) * dm \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dm", "by simp"], ["proof (state)\nthis:\n  (2 ^ (k + 1) - 1) * dm \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dm\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "then"], ["proof (chain)\npicking this:\n  (2 ^ (k + 1) - 1) * dm \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dm", "show ?thesis"], ["proof (prove)\nusing this:\n  (2 ^ (k + 1) - 1) * dm \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dm\n\ngoal (1 subgoal):\n 1. dm * 2 ^ k \\<le> infdist (f r) (V k)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  dm * 2 ^ k \\<le> infdist (f r) (V k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?r \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f ?r) (V k)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Substep 1: We can control the distance from $f(v)$ to $f(closestM)$ in terms of the distance\n              of the distance of $f(v)$ to $H$, i.e., by $2^k dm$. The same control follows\n              for $closestM - v$ thanks to the quasi-isometry property. Then, we massage this\n              inequality to put it in the form we will need, as an upper bound on $(x-v) \\exp(-2^k dm)$.\\<close>"], ["proof (state)\nthis:\n  ?r \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f ?r) (V k)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"infdist (f v) H \\<le> (2^(k+2)-1) * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f v) H \\<le> (2 ^ (k + 2) - 1) * dm", "using v proj_setD(2)[OF p[of v]]"], ["proof (prove)\nusing this:\n  v \\<in> {um..w}\n  dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm\n  dist (f v) (p v) = infdist (f v) H\n\ngoal (1 subgoal):\n 1. infdist (f v) H \\<le> (2 ^ (k + 2) - 1) * dm", "by auto"], ["proof (state)\nthis:\n  infdist (f v) H \\<le> (2 ^ (k + 2) - 1) * dm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"dist v closestM \\<le> lambda * (infdist (f v) H + (L + C + 2 * delta) + infdist (f closestM) H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist v closestM\n    \\<le> lambda *\n          (infdist (f v) H + (L + C + 2 * delta) + infdist (f closestM) H)", "apply (rule D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. v \\<in> {um..ym}\n 2. closestM \\<in> {yM..uM}", "using \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close> \\<open>x \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n  x \\<in> {um..ym}\n  ym \\<in> {um..z}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n  closestM \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n  uM \\<in> {z..b}\n\ngoal (2 subgoals):\n 1. v \\<in> {um..ym}\n 2. closestM \\<in> {yM..uM}", "by auto"], ["proof (state)\nthis:\n  dist v closestM\n  \\<le> lambda *\n        (infdist (f v) H + (L + C + 2 * delta) + infdist (f closestM) H)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  dist v closestM\n  \\<le> lambda *\n        (infdist (f v) H + (L + C + 2 * delta) + infdist (f closestM) H)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> lambda * ((2^(k+2)-1) * dm + 1 * (L + C + 2 * delta) + dM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    (infdist (f v) H + (L + C + 2 * delta) + infdist (f closestM) H)\n    \\<le> lambda * ((2 ^ (k + 2) - 1) * dm + 1 * (L + C + 2 * delta) + dM)", "apply (intro mono_intros \\<open>infdist (f v) H \\<le> (2^(k+2)-1) * dm\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<le> L + C + 2 * delta\n 2. 1 \\<le> 1\n 3. infdist (f closestM) H \\<le> dM\n 4. 0 \\<le> lambda", "using dM_def \\<open>lambda \\<ge> 1\\<close> \\<open>L > 0\\<close> \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  dM = infdist (f closestM) H\n  1 \\<le> lambda\n  0 < L\n  0 \\<le> C\n  0 < delta\n\ngoal (4 subgoals):\n 1. 0 \\<le> L + C + 2 * delta\n 2. 1 \\<le> 1\n 3. infdist (f closestM) H \\<le> dM\n 4. 0 \\<le> lambda", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  lambda * (infdist (f v) H + (L + C + 2 * delta) + infdist (f closestM) H)\n  \\<le> lambda * ((2 ^ (k + 2) - 1) * dm + 1 * (L + C + 2 * delta) + dM)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  lambda * (infdist (f v) H + (L + C + 2 * delta) + infdist (f closestM) H)\n  \\<le> lambda * ((2 ^ (k + 2) - 1) * dm + 1 * (L + C + 2 * delta) + dM)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> lambda * ((2^(k+2)-1) * dm + 2^k * (((L + 2 * delta)/D) * dm) + dm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * ((2 ^ (k + 2) - 1) * dm + 1 * (L + C + 2 * delta) + dM)\n    \\<le> lambda *\n          ((2 ^ (k + 2) - 1) * dm + 2 ^ k * ((L + 2 * delta) / D * dm) + dm)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. 1 \\<le> 2 ^ k\n 2. L + C + 2 * delta \\<le> (L + 2 * delta) / D * dm\n 3. 0 \\<le> 2 ^ k\n 4. 0 \\<le> L + C + 2 * delta\n 5. dM \\<le> dm\n 6. 0 \\<le> lambda", "using I \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close> \\<open>L > 0\\<close> aux2"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  1 \\<le> lambda\n  0 \\<le> C\n  0 < delta\n  0 < L\n  L + C + 2 * delta \\<le> (L + 2 * delta) / D * dm\n\ngoal (6 subgoals):\n 1. 1 \\<le> 2 ^ k\n 2. L + C + 2 * delta \\<le> (L + 2 * delta) / D * dm\n 3. 0 \\<le> 2 ^ k\n 4. 0 \\<le> L + C + 2 * delta\n 5. dM \\<le> dm\n 6. 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  lambda * ((2 ^ (k + 2) - 1) * dm + 1 * (L + C + 2 * delta) + dM)\n  \\<le> lambda *\n        ((2 ^ (k + 2) - 1) * dm + 2 ^ k * ((L + 2 * delta) / D * dm) + dm)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  lambda * ((2 ^ (k + 2) - 1) * dm + 1 * (L + C + 2 * delta) + dM)\n  \\<le> lambda *\n        ((2 ^ (k + 2) - 1) * dm + 2 ^ k * ((L + 2 * delta) / D * dm) + dm)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... = lambda * 2^k * (4 + (L + 2 * delta)/D) * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    ((2 ^ (k + 2) - 1) * dm + 2 ^ k * ((L + 2 * delta) / D * dm) + dm) =\n    lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dm", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  lambda *\n  ((2 ^ (k + 2) - 1) * dm + 2 ^ k * ((L + 2 * delta) / D * dm) + dm) =\n  lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  dist v closestM \\<le> lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dm", "have *: \"dist v closestM / (lambda * (4 + (L + 2 * delta)/D)) \\<le> 2^k * dm\""], ["proof (prove)\nusing this:\n  dist v closestM \\<le> lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dm\n\ngoal (1 subgoal):\n 1. dist v closestM / (lambda * (4 + (L + 2 * delta) / D)) \\<le> 2 ^ k * dm", "using \\<open>lambda \\<ge> 1\\<close> \\<open>L > 0\\<close> \\<open>D > 0\\<close> \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  dist v closestM \\<le> lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dm\n  1 \\<le> lambda\n  0 < L\n  0 < D\n  0 < delta\n\ngoal (1 subgoal):\n 1. dist v closestM / (lambda * (4 + (L + 2 * delta) / D)) \\<le> 2 ^ k * dm", "by (simp add: divide_simps, simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist v closestM / (lambda * (4 + (L + 2 * delta) / D)) \\<le> 2 ^ k * dm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>We reformulate this control inside of an exponential, as this is the form we\n              will use later on.\\<close>"], ["proof (state)\nthis:\n  dist v closestM / (lambda * (4 + (L + 2 * delta) / D)) \\<le> 2 ^ k * dm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"exp(- (alpha * (2^k * dm) * ln 2 / (5 * delta))) \\<le> exp(-(alpha * (dist v closestM / (lambda * (4 + (L + 2 * delta)/D))) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n    \\<le> exp (- (alpha *\n                  (dist v closestM / (lambda * (4 + (L + 2 * delta) / D))) *\n                  ln 2 /\n                  (5 * delta)))", "apply (intro mono_intros *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> alpha\n 2. 1 \\<le> 2\n 3. 0 \\<le> 5 * delta", "using alphaaux \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < alpha\n  alpha \\<le> 1\n  0 < delta\n\ngoal (3 subgoals):\n 1. 0 \\<le> alpha\n 2. 1 \\<le> 2\n 3. 0 \\<le> 5 * delta", "by auto"], ["proof (state)\nthis:\n  exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- (alpha *\n                (dist v closestM / (lambda * (4 + (L + 2 * delta) / D))) *\n                ln 2 /\n                (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- (alpha *\n                (dist v closestM / (lambda * (4 + (L + 2 * delta) / D))) *\n                ln 2 /\n                (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... = exp(-K * dist v closestM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- (alpha *\n            (dist v closestM / (lambda * (4 + (L + 2 * delta) / D))) *\n            ln 2 /\n            (5 * delta))) =\n    exp (- K * dist v closestM)", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- (alpha *\n            (dist v closestM / (lambda * (4 + (L + 2 * delta) / D))) *\n            ln 2 /\n            (5 * delta))) =\n    exp (- (alpha * ln 2 /\n            (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n         dist v closestM)", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  exp (- (alpha * (dist v closestM / (lambda * (4 + (L + 2 * delta) / D))) *\n          ln 2 /\n          (5 * delta))) =\n  exp (- K * dist v closestM)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  exp (- (alpha * (dist v closestM / (lambda * (4 + (L + 2 * delta) / D))) *\n          ln 2 /\n          (5 * delta))) =\n  exp (- K * dist v closestM)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... = exp(-K * (closestM - v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- K * dist v closestM) = exp (- K * (closestM - v))", "unfolding dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- K * \\<bar>v - closestM\\<bar>) = exp (- K * (closestM - v))", "using \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close> \\<open>x \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>K > 0\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n  x \\<in> {um..ym}\n  ym \\<in> {um..z}\n  yM \\<in> {z..uM}\n  closestM \\<in> {yM..uM}\n  0 < K\n\ngoal (1 subgoal):\n 1. exp (- K * \\<bar>v - closestM\\<bar>) = exp (- K * (closestM - v))", "by auto"], ["proof (state)\nthis:\n  exp (- K * dist v closestM) = exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (closestM - v))", "have \"exp(- (alpha * (2^k * dm) * ln 2 / (5 * delta))) \\<le> exp(-K * (closestM - v))\""], ["proof (prove)\nusing this:\n  exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (closestM - v))\n\ngoal (1 subgoal):\n 1. exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n    \\<le> exp (- K * (closestM - v))", "by simp"], ["proof (state)\nthis:\n  exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Plug in $x-v$ to get the final form of this inequality.\\<close>"], ["proof (state)\nthis:\n  exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (closestM - v))", "have \"K * (x - v) * exp(- (alpha * (2^k * dm) * ln 2 / (5 * delta))) \\<le> K * (x - v) * exp(-K * (closestM - v))\""], ["proof (prove)\nusing this:\n  exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (closestM - v))\n\ngoal (1 subgoal):\n 1. K * (x - v) * exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n    \\<le> K * (x - v) * exp (- K * (closestM - v))", "apply (rule mult_left_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> K * (x - v)", "using \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close> \\<open>K > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n  1 \\<le> lambda\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n  0 < K\n\ngoal (1 subgoal):\n 1. 0 \\<le> K * (x - v)", "by auto"], ["proof (state)\nthis:\n  K * (x - v) * exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> K * (x - v) * exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  K * (x - v) * exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> K * (x - v) * exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... = ((1 + K * (x - v)) - 1) * exp(- K * (closestM - v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K * (x - v) * exp (- K * (closestM - v)) =\n    (1 + K * (x - v) - 1) * exp (- K * (closestM - v))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  K * (x - v) * exp (- K * (closestM - v)) =\n  (1 + K * (x - v) - 1) * exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  K * (x - v) * exp (- K * (closestM - v)) =\n  (1 + K * (x - v) - 1) * exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> (exp (K * (x - v)) - 1) * exp(-K * (closestM - v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + K * (x - v) - 1) * exp (- K * (closestM - v))\n    \\<le> (exp (K * (x - v)) - 1) * exp (- K * (closestM - v))", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  (1 + K * (x - v) - 1) * exp (- K * (closestM - v))\n  \\<le> (exp (K * (x - v)) - 1) * exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  (1 + K * (x - v) - 1) * exp (- K * (closestM - v))\n  \\<le> (exp (K * (x - v)) - 1) * exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... = exp(-K * (closestM - x)) - exp(-K * (closestM - v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exp (K * (x - v)) - 1) * exp (- K * (closestM - v)) =\n    exp (- K * (closestM - x)) - exp (- K * (closestM - v))", "by (simp add: algebra_simps mult_exp_exp)"], ["proof (state)\nthis:\n  (exp (K * (x - v)) - 1) * exp (- K * (closestM - v)) =\n  exp (- K * (closestM - x)) - exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  (exp (K * (x - v)) - 1) * exp (- K * (closestM - v)) =\n  exp (- K * (closestM - x)) - exp (- K * (closestM - v))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> exp(-K * (closestM - x)) - exp(-K * (uM - um))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- K * (closestM - x)) - exp (- K * (closestM - v))\n    \\<le> exp (- K * (closestM - x)) - exp (- K * (uM - um))", "using \\<open>K > 0\\<close> \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close> \\<open>x \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>closestM \\<in> {yM..uM}\\<close>"], ["proof (prove)\nusing this:\n  0 < K\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n  x \\<in> {um..ym}\n  ym \\<in> {um..z}\n  yM \\<in> {z..uM}\n  closestM \\<in> {yM..uM}\n\ngoal (1 subgoal):\n 1. exp (- K * (closestM - x)) - exp (- K * (closestM - v))\n    \\<le> exp (- K * (closestM - x)) - exp (- K * (uM - um))", "by auto"], ["proof (state)\nthis:\n  exp (- K * (closestM - x)) - exp (- K * (closestM - v))\n  \\<le> exp (- K * (closestM - x)) - exp (- K * (uM - um))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  K * (x - v) * exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (closestM - x)) - exp (- K * (uM - um))", "have B: \"(x - v) * exp(- alpha * 2^k * dm * ln 2 / (5 * delta)) \\<le>\n                                  (exp(-K * (closestM - x)) - exp(-K * (uM-um)))/K\""], ["proof (prove)\nusing this:\n  K * (x - v) * exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (closestM - x)) - exp (- K * (uM - um))\n\ngoal (1 subgoal):\n 1. (x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))\n    \\<le> (exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K", "using \\<open>K > 0\\<close>"], ["proof (prove)\nusing this:\n  K * (x - v) * exp (- (alpha * (2 ^ k * dm) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (closestM - x)) - exp (- K * (uM - um))\n  0 < K\n\ngoal (1 subgoal):\n 1. (x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))\n    \\<le> (exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  (x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))\n  \\<le> (exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>End of substep 1\\<close>"], ["proof (state)\nthis:\n  (x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))\n  \\<le> (exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Substep 2: The projections of $f(v)$ and $f(x)$ on the cylinder $V_k$ are well separated,\n              by construction. This implies that $v$ and $x$ themselves are well separated, thanks\n              to the exponential contraction property of the projection on the quasi-convex set $V_k$.\n              This leads to a uniform lower bound for $(x-v) \\exp(-2^k dm)$, which has been upper bounded\n              in Substep 1.\\<close>"], ["proof (state)\nthis:\n  (x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))\n  \\<le> (exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {um..ym}\n  L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x)\n  ?w \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f ?w) (p ?w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x)", "by simp"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> dist (q k um) (q k v) + dist (q k v) (q k x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k um) (q k x) \\<le> dist (q k um) (q k v) + dist (q k v) (q k x)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (q k um) (q k x) \\<le> dist (q k um) (q k v) + dist (q k v) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  dist (q k um) (q k x) \\<le> dist (q k um) (q k v) + dist (q k v) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> (9 * delta + 4 * QC k) + dist (q k v) (q k x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k um) (q k v) + dist (q k v) (q k x)\n    \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)", "using w(3)[of v] \\<open>v \\<in> {um..w}\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {um..w} \\<Longrightarrow>\n  dist (q k um) (q k v) \\<le> 9 * delta + 4 * QC k\n  v \\<in> {um..w}\n\ngoal (1 subgoal):\n 1. dist (q k um) (q k v) + dist (q k v) (q k x)\n    \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)", "by auto"], ["proof (state)\nthis:\n  dist (q k um) (q k v) + dist (q k v) (q k x)\n  \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L - 4 * delta + 7 * QC k \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)", "have \"L - 13 * delta + 3 * QC k \\<le> dist (q k v) (q k x)\""], ["proof (prove)\nusing this:\n  L - 4 * delta + 7 * QC k \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)\n\ngoal (1 subgoal):\n 1. L - 13 * delta + 3 * QC k \\<le> dist (q k v) (q k x)", "by simp"], ["proof (state)\nthis:\n  L - 13 * delta + 3 * QC k \\<le> dist (q k v) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L - 13 * delta + 3 * QC k \\<le> dist (q k v) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> 3 * QC k + max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (x - v) * exp(-(dm * 2^k - C/2 - QC k) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "text \\<open>We use different statements for the projection in the case $k = 0$ (projection on\n                a geodesic) and $k > 0$ (projection on a quasi-convex set) as the bounds are better in\n                the first case, which is the most important one for the final value of the constant.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "have \"dist (q k v) (q k x) \\<le> max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (x - v) * exp(-(dm * 2^k - C/2) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k v) (q k x)\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2) * ln 2 / (5 * delta)))", "proof (rule geodesic_projection_exp_contracting[where ?G = \"V k\" and ?f = f])"], ["proof (state)\ngoal (10 subgoals):\n 1. geodesic_segment (V k)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 3. v \\<le> x\n 4. q k v \\<in> proj_set (f v) (V k)\n 5. q k x \\<in> proj_set (f x) (V k)\n 6. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 7. 15 / 2 * delta + C / 2 \\<le> dm * 2 ^ k\n 8. deltaG TYPE('a) < delta\n 9. 0 \\<le> C\n 10. 0 \\<le> lambda", "show \"geodesic_segment (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment (V k)", "unfolding True V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment (\\<Union>g\\<in>H. cball g ((2 ^ 0 - 1) * dm))", "using geodesic_segmentI[OF H]"], ["proof (prove)\nusing this:\n  geodesic_segment H\n\ngoal (1 subgoal):\n 1. geodesic_segment (\\<Union>g\\<in>H. cball g ((2 ^ 0 - 1) * dm))", "by auto"], ["proof (state)\nthis:\n  geodesic_segment (V k)\n\ngoal (9 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. v \\<le> x\n 3. q k v \\<in> proj_set (f v) (V k)\n 4. q k x \\<in> proj_set (f x) (V k)\n 5. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 6. 15 / 2 * delta + C / 2 \\<le> dm * 2 ^ k\n 7. deltaG TYPE('a) < delta\n 8. 0 \\<le> C\n 9. 0 \\<le> lambda", "show \"v \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<le> x", "using \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n\ngoal (1 subgoal):\n 1. v \\<le> x", "by auto"], ["proof (state)\nthis:\n  v \\<le> x\n\ngoal (8 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. q k v \\<in> proj_set (f v) (V k)\n 3. q k x \\<in> proj_set (f x) (V k)\n 4. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 5. 15 / 2 * delta + C / 2 \\<le> dm * 2 ^ k\n 6. deltaG TYPE('a) < delta\n 7. 0 \\<le> C\n 8. 0 \\<le> lambda", "show \"q k v \\<in> proj_set (f v) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k v \\<in> proj_set (f v) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p v--f v} (p v) ((2 ^ k - 1) * dm)\n    \\<in> proj_set (f v) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p v \\<in> proj_set (f v) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p v) (f v)\n 4. geodesic_segment_between {p v--f v} (p v) (f v)", "using aux p[of v] x(3)[of v] \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n  p v \\<in> proj_set (f v) H\n  v \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f v) (p v)\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n\ngoal (4 subgoals):\n 1. p v \\<in> proj_set (f v) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p v) (f v)\n 4. geodesic_segment_between {p v--f v} (p v) (f v)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k v \\<in> proj_set (f v) (V k)\n\ngoal (7 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. q k x \\<in> proj_set (f x) (V k)\n 3. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 4. 15 / 2 * delta + C / 2 \\<le> dm * 2 ^ k\n 5. deltaG TYPE('a) < delta\n 6. 0 \\<le> C\n 7. 0 \\<le> lambda", "show \"q k x \\<in> proj_set (f x) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k x \\<in> proj_set (f x) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p x--f x} (p x) ((2 ^ k - 1) * dm)\n    \\<in> proj_set (f x) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p x \\<in> proj_set (f x) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p x) (f x)\n 4. geodesic_segment_between {p x--f x} (p x) (f x)", "using aux p[of x] x(3)[of x] \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n  p x \\<in> proj_set (f x) H\n  x \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f x) (p x)\n  w \\<in> {um..x}\n\ngoal (4 subgoals):\n 1. p x \\<in> proj_set (f x) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p x) (f x)\n 4. geodesic_segment_between {p x--f x} (p x) (f x)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k x \\<in> proj_set (f x) (V k)\n\ngoal (6 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 3. 15 / 2 * delta + C / 2 \\<le> dm * 2 ^ k\n 4. deltaG TYPE('a) < delta\n 5. 0 \\<le> C\n 6. 0 \\<le> lambda", "show \"15/2 * delta + C/2 \\<le> dm * 2^k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 15 / 2 * delta + C / 2 \\<le> dm * 2 ^ k", "apply (rule order_trans[of _ dm])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 15 / 2 * delta + C / 2 \\<le> dm\n 2. dm \\<le> dm * 2 ^ k", "using I \\<open>delta > 0\\<close> \\<open>C \\<ge> 0\\<close> Laux"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (2 subgoals):\n 1. 15 / 2 * delta + C / 2 \\<le> dm\n 2. dm \\<le> dm * 2 ^ k", "unfolding QC_def"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (2 subgoals):\n 1. 15 / 2 * delta + C / 2 \\<le> dm\n 2. dm \\<le> dm * 2 ^ k", "by auto"], ["proof (state)\nthis:\n  15 / 2 * delta + C / 2 \\<le> dm * 2 ^ k\n\ngoal (5 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 3. deltaG TYPE('a) < delta\n 4. 0 \\<le> C\n 5. 0 \\<le> lambda", "show \"deltaG TYPE('a) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) < delta", "by fact"], ["proof (state)\nthis:\n  deltaG TYPE('a) < delta\n\ngoal (4 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 3. 0 \\<le> C\n 4. 0 \\<le> lambda", "show \"\\<And>t. t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)", "using aux4"], ["proof (prove)\nusing this:\n  ?r \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f ?r) (V k)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)", "by auto"], ["proof (state)\nthis:\n  ?t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f ?t) (V k)\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. 0 \\<le> C\n 3. 0 \\<le> lambda", "show \"0 \\<le> C\" \"0 \\<le> lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 0 \\<le> lambda", "using \\<open>C \\<ge> 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  0 \\<le> C\n  0 \\<le> lambda\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C", "show \"dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C\" if \"x1 \\<in> {v..x}\" \"x2 \\<in> {v..x}\" for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C", "using quasi_isometry_onD(1)[OF assms(2)] that \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close> \\<open>x \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  x1 \\<in> {v..x}\n  x2 \\<in> {v..x}\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n  x \\<in> {um..ym}\n  ym \\<in> {um..z}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x1.0 \\<in> {v..x}; ?x2.0 \\<in> {v..x}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x1.0) (f ?x2.0)\n                    \\<le> lambda * dist ?x1.0 ?x2.0 + C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist (q k v) (q k x)\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2) * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  dist (q k v) (q k x)\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2) * ln 2 / (5 * delta)))", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (q k v) (q k x)\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "unfolding QC_def True"], ["proof (prove)\nusing this:\n  dist (q 0 v) (q 0 x)\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ 0 - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist (q 0 v) (q 0 x)\n    \\<le> 3 * (if 0 = 0 then 0 else 8 * delta) +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ 0 - C / 2 - (if 0 = 0 then 0 else 8 * delta)) *\n                 ln 2 /\n                 (5 * delta)))", "by auto"], ["proof (state)\nthis:\n  dist (q k v) (q k x)\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "have \"dist (q k v) (q k x) \\<le> 2 * QC k + 8 * delta + max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (x - v) * exp(-(dm * 2^k - QC k -C/2) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k v) (q k x)\n    \\<le> 2 * QC k + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - QC k - C / 2) * ln 2 / (5 * delta)))", "proof (rule quasiconvex_projection_exp_contracting[where ?G = \"V k\" and ?f = f])"], ["proof (state)\ngoal (10 subgoals):\n 1. quasiconvex (QC k) (V k)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 3. v \\<le> x\n 4. q k v \\<in> proj_set (f v) (V k)\n 5. q k x \\<in> proj_set (f x) (V k)\n 6. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 7. 15 / 2 * delta + QC k + C / 2 \\<le> dm * 2 ^ k\n 8. deltaG TYPE('a) < delta\n 9. 0 \\<le> C\n 10. 0 \\<le> lambda", "show \"quasiconvex (QC k) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (QC k) (V k)", "by fact"], ["proof (state)\nthis:\n  quasiconvex (QC k) (V k)\n\ngoal (9 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. v \\<le> x\n 3. q k v \\<in> proj_set (f v) (V k)\n 4. q k x \\<in> proj_set (f x) (V k)\n 5. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 6. 15 / 2 * delta + QC k + C / 2 \\<le> dm * 2 ^ k\n 7. deltaG TYPE('a) < delta\n 8. 0 \\<le> C\n 9. 0 \\<le> lambda", "show \"v \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<le> x", "using \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n\ngoal (1 subgoal):\n 1. v \\<le> x", "by auto"], ["proof (state)\nthis:\n  v \\<le> x\n\ngoal (8 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. q k v \\<in> proj_set (f v) (V k)\n 3. q k x \\<in> proj_set (f x) (V k)\n 4. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 5. 15 / 2 * delta + QC k + C / 2 \\<le> dm * 2 ^ k\n 6. deltaG TYPE('a) < delta\n 7. 0 \\<le> C\n 8. 0 \\<le> lambda", "show \"q k v \\<in> proj_set (f v) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k v \\<in> proj_set (f v) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p v--f v} (p v) ((2 ^ k - 1) * dm)\n    \\<in> proj_set (f v) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p v \\<in> proj_set (f v) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p v) (f v)\n 4. geodesic_segment_between {p v--f v} (p v) (f v)", "using aux p[of v] x(3)[of v] \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n  p v \\<in> proj_set (f v) H\n  v \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f v) (p v)\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n\ngoal (4 subgoals):\n 1. p v \\<in> proj_set (f v) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p v) (f v)\n 4. geodesic_segment_between {p v--f v} (p v) (f v)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k v \\<in> proj_set (f v) (V k)\n\ngoal (7 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. q k x \\<in> proj_set (f x) (V k)\n 3. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 4. 15 / 2 * delta + QC k + C / 2 \\<le> dm * 2 ^ k\n 5. deltaG TYPE('a) < delta\n 6. 0 \\<le> C\n 7. 0 \\<le> lambda", "show \"q k x \\<in> proj_set (f x) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k x \\<in> proj_set (f x) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p x--f x} (p x) ((2 ^ k - 1) * dm)\n    \\<in> proj_set (f x) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p x \\<in> proj_set (f x) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p x) (f x)\n 4. geodesic_segment_between {p x--f x} (p x) (f x)", "using aux p[of x] x(3)[of x] \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n  p x \\<in> proj_set (f x) H\n  x \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f x) (p x)\n  w \\<in> {um..x}\n\ngoal (4 subgoals):\n 1. p x \\<in> proj_set (f x) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> dist (p x) (f x)\n 4. geodesic_segment_between {p x--f x} (p x) (f x)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k x \\<in> proj_set (f x) (V k)\n\ngoal (6 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 3. 15 / 2 * delta + QC k + C / 2 \\<le> dm * 2 ^ k\n 4. deltaG TYPE('a) < delta\n 5. 0 \\<le> C\n 6. 0 \\<le> lambda", "show \"15/2 * delta + QC k + C/2 \\<le> dm * 2^k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 15 / 2 * delta + QC k + C / 2 \\<le> dm * 2 ^ k", "apply (rule order_trans[of _ dm])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 15 / 2 * delta + QC k + C / 2 \\<le> dm\n 2. dm \\<le> dm * 2 ^ k", "using I \\<open>delta > 0\\<close> \\<open>C \\<ge> 0\\<close> Laux"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (2 subgoals):\n 1. 15 / 2 * delta + QC k + C / 2 \\<le> dm\n 2. dm \\<le> dm * 2 ^ k", "unfolding QC_def"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (2 subgoals):\n 1. 15 / 2 * delta + (if k = 0 then 0 else 8 * delta) + C / 2 \\<le> dm\n 2. dm \\<le> dm * 2 ^ k", "by auto"], ["proof (state)\nthis:\n  15 / 2 * delta + QC k + C / 2 \\<le> dm * 2 ^ k\n\ngoal (5 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 3. deltaG TYPE('a) < delta\n 4. 0 \\<le> C\n 5. 0 \\<le> lambda", "show \"deltaG TYPE('a) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) < delta", "by fact"], ["proof (state)\nthis:\n  deltaG TYPE('a) < delta\n\ngoal (4 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\n 3. 0 \\<le> C\n 4. 0 \\<le> lambda", "show \"\\<And>t. t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)", "using aux4"], ["proof (prove)\nusing this:\n  ?r \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f ?r) (V k)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f t) (V k)", "by auto"], ["proof (state)\nthis:\n  ?t \\<in> {v..x} \\<Longrightarrow> dm * 2 ^ k \\<le> infdist (f ?t) (V k)\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. 0 \\<le> C\n 3. 0 \\<le> lambda", "show \"0 \\<le> C\" \"0 \\<le> lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 0 \\<le> lambda", "using \\<open>C \\<ge> 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  0 \\<le> C\n  0 \\<le> lambda\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {v..x}; y \\<in> {v..x}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C", "show \"dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C\" if \"x1 \\<in> {v..x}\" \"x2 \\<in> {v..x}\" for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C", "using quasi_isometry_onD(1)[OF assms(2)] that \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close> \\<open>x \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>z \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  x1 \\<in> {v..x}\n  x2 \\<in> {v..x}\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n  x \\<in> {um..ym}\n  ym \\<in> {um..z}\n  um \\<in> {a..z}\n  z \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x1.0 \\<in> {v..x}; ?x2.0 \\<in> {v..x}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x1.0) (f ?x2.0)\n                    \\<le> lambda * dist ?x1.0 ?x2.0 + C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist (q k v) (q k x)\n  \\<le> 2 * QC k + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - QC k - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  dist (q k v) (q k x)\n  \\<le> 2 * QC k + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - QC k - C / 2) * ln 2 / (5 * delta)))", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (q k v) (q k x)\n  \\<le> 2 * QC k + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - QC k - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist (q k v) (q k x)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "unfolding QC_def"], ["proof (prove)\nusing this:\n  dist (q k v) (q k x)\n  \\<le> 2 * (if k = 0 then 0 else 8 * delta) + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - (if k = 0 then 0 else 8 * delta) - C / 2) *\n               ln 2 /\n               (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist (q k v) (q k x)\n    \\<le> 3 * (if k = 0 then 0 else 8 * delta) +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - (if k = 0 then 0 else 8 * delta)) *\n                 ln 2 /\n                 (5 * delta)))", "using False"], ["proof (prove)\nusing this:\n  dist (q k v) (q k x)\n  \\<le> 2 * (if k = 0 then 0 else 8 * delta) + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - (if k = 0 then 0 else 8 * delta) - C / 2) *\n               ln 2 /\n               (5 * delta)))\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dist (q k v) (q k x)\n    \\<le> 3 * (if k = 0 then 0 else 8 * delta) +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - (if k = 0 then 0 else 8 * delta)) *\n                 ln 2 /\n                 (5 * delta)))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist (q k v) (q k x)\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist (q k v) (q k x)\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L - 13 * delta + 3 * QC k\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "have \"L - 13 * delta \\<le> max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (x - v) * exp(-(dm * 2^k - C/2 - QC k) * ln 2 / (5 * delta)))\""], ["proof (prove)\nusing this:\n  L - 13 * delta + 3 * QC k\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. L - 13 * delta\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n            exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "by auto"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  L - 13 * delta\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "have \"L - 13 * delta \\<le> (4 * exp(1/2 * ln 2)) * lambda * (x - v) * exp(-(dm * 2^k - C/2 - QC k) * ln 2 / (5 * delta))\""], ["proof (prove)\nusing this:\n  L - 13 * delta\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))", "using \\<open>delta > deltaG(TYPE('a))\\<close> Laux"], ["proof (prove)\nusing this:\n  L - 13 * delta\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n  deltaG TYPE('a) < delta\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))", "by auto"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n        exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>We separate the exponential gain coming from the contraction into two parts, one\n              to be spent to improve the constant, and one for the inductive argument.\\<close>"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n        exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n        exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> (4 * exp(1/2 * ln 2)) * lambda * (x - v) * exp(-((1-alpha) * D + alpha * 2^k * dm) * ln 2 / (5 * delta))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n    exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n          exp (- ((1 - alpha) * D + alpha * 2 ^ k * dm) * ln 2 /\n               (5 * delta))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k\n 2. 1 \\<le> 2\n 3. 0 \\<le> 5 * delta\n 4. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v)", "using aux3 \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k\n  0 < delta\n  1 \\<le> lambda\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n\ngoal (4 subgoals):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dm \\<le> dm * 2 ^ k - C / 2 - QC k\n 2. 1 \\<le> 2\n 3. 0 \\<le> 5 * delta\n 4. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v)", "by auto"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n  exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n        exp (- ((1 - alpha) * D + alpha * 2 ^ k * dm) * ln 2 / (5 * delta))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n  exp (- (dm * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n        exp (- ((1 - alpha) * D + alpha * 2 ^ k * dm) * ln 2 / (5 * delta))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... = (4 * exp(1/2 * ln 2)) * lambda * (x - v) * (exp(-(1-alpha) * D * ln 2 / (5 * delta)) * exp(-alpha * 2^k * dm * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n    exp (- ((1 - alpha) * D + alpha * 2 ^ k * dm) * ln 2 / (5 * delta)) =\n    4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n    (exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n     exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))", "unfolding mult_exp_exp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n    exp (- ((1 - alpha) * D + alpha * 2 ^ k * dm) * ln 2 / (5 * delta)) =\n    4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n    exp (- (1 - alpha) * D * ln 2 / (5 * delta) +\n         - alpha * 2 ^ k * dm * ln 2 / (5 * delta))", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n  exp (- ((1 - alpha) * D + alpha * 2 ^ k * dm) * ln 2 / (5 * delta)) =\n  4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n  (exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n   exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n        (exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))", "have A: \"L - 13 * delta \\<le> (4 * exp(1/2 * ln 2)) * lambda * exp(-(1-alpha) * D * ln 2 / (5 * delta)) * ((x - v) * exp(-alpha * 2^k * dm * ln 2 / (5 * delta)))\""], ["proof (prove)\nusing this:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (x - v) *\n        (exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n          exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n          ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n        exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n        ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>This is the end of the second substep.\\<close>"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n        exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n        ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Use the second substep to show that $x-v$ is bounded below, and therefore\n              that $closestM - x$ (the endpoints of the new geodesic we want to consider in the\n              inductive argument) are quantitatively closer than $uM - um$, which means that we\n              will be able to use the inductive assumption over this new geodesic.\\<close>"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n        exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n        ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n        exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n        ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> (4 * exp(1/2 * ln 2)) * lambda * exp 0 * ((x - v) * exp 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda *\n    exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n    ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((x - v) * exp 0)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. - (1 - alpha) * D * ln 2 / (5 * delta) \\<le> 0\n 2. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda\n 3. - alpha * 2 ^ k * dm * ln 2 / (5 * delta) \\<le> 0\n 4. 0 \\<le> x - v\n 5. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0\n 6. 0 \\<le> (x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))", "using \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close> alphaaux \\<open>D > 0\\<close> \\<open>C \\<ge> 0\\<close> I"], ["proof (prove)\nusing this:\n  0 < delta\n  1 \\<le> lambda\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n  0 < alpha\n  alpha \\<le> 1\n  0 < D\n  0 \\<le> C\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n\ngoal (6 subgoals):\n 1. - (1 - alpha) * D * ln 2 / (5 * delta) \\<le> 0\n 2. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda\n 3. - alpha * 2 ^ k * dm * ln 2 / (5 * delta) \\<le> 0\n 4. 0 \\<le> x - v\n 5. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0\n 6. 0 \\<le> (x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))", "by (auto simp add: divide_simps mult_nonpos_nonneg)"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda *\n  exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n  ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((x - v) * exp 0)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda *\n  exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n  ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((x - v) * exp 0)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... = (4 * exp(1/2 * ln 2)) * lambda * (x-v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((x - v) * exp 0) =\n    4 * exp (1 / 2 * ln 2) * lambda * (x - v)", "by simp"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((x - v) * exp 0) =\n  4 * exp (1 / 2 * ln 2) * lambda * (x - v)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((x - v) * exp 0) =\n  4 * exp (1 / 2 * ln 2) * lambda * (x - v)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> 20 * lambda * (x - v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * (x - v) \\<le> 20 * lambda * (x - v)", "apply (intro mono_intros, approximation 10)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> lambda\n 2. 0 \\<le> x - v", "using \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>v \\<in> {um..w}\\<close> \\<open>w \\<in> {um..x}\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n  1 \\<le> lambda\n  v \\<in> {um..w}\n  w \\<in> {um..x}\n\ngoal (2 subgoals):\n 1. 0 \\<le> lambda\n 2. 0 \\<le> x - v", "by auto"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * (x - v) \\<le> 20 * lambda * (x - v)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L - 13 * delta \\<le> 20 * lambda * (x - v)", "have \"x - v \\<ge> (1/4) * delta / lambda\""], ["proof (prove)\nusing this:\n  L - 13 * delta \\<le> 20 * lambda * (x - v)\n\ngoal (1 subgoal):\n 1. 1 / 4 * delta / lambda \\<le> x - v", "using \\<open>lambda \\<ge> 1\\<close> L_def \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  L - 13 * delta \\<le> 20 * lambda * (x - v)\n  1 \\<le> lambda\n  L = 18 * delta\n  0 < delta\n\ngoal (1 subgoal):\n 1. 1 / 4 * delta / lambda \\<le> x - v", "by (simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  1 / 4 * delta / lambda \\<le> x - v\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  1 / 4 * delta / lambda \\<le> x - v", "have \"closestM - x + (1/4) * delta / lambda \\<le> closestM - v\""], ["proof (prove)\nusing this:\n  1 / 4 * delta / lambda \\<le> x - v\n\ngoal (1 subgoal):\n 1. closestM - x + 1 / 4 * delta / lambda \\<le> closestM - v", "by simp"], ["proof (state)\nthis:\n  closestM - x + 1 / 4 * delta / lambda \\<le> closestM - v\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  closestM - x + 1 / 4 * delta / lambda \\<le> closestM - v\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> uM - um\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closestM - v \\<le> uM - um", "using \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>v \\<in> {um..w}\\<close>"], ["proof (prove)\nusing this:\n  closestM \\<in> {yM..uM}\n  v \\<in> {um..w}\n\ngoal (1 subgoal):\n 1. closestM - v \\<le> uM - um", "by auto"], ["proof (state)\nthis:\n  closestM - v \\<le> uM - um\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  closestM - v \\<le> uM - um\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> Suc n * (1/4) * delta / lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda", "by fact"], ["proof (state)\nthis:\n  uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  closestM - x + 1 / 4 * delta / lambda\n  \\<le> real (Suc n) * (1 / 4) * delta / lambda", "have \"closestM - x \\<le> n * (1/4) * delta / lambda\""], ["proof (prove)\nusing this:\n  closestM - x + 1 / 4 * delta / lambda\n  \\<le> real (Suc n) * (1 / 4) * delta / lambda\n\ngoal (1 subgoal):\n 1. closestM - x \\<le> real n * (1 / 4) * delta / lambda", "unfolding Suc_eq_plus1"], ["proof (prove)\nusing this:\n  closestM - x + 1 / 4 * delta / lambda\n  \\<le> real (n + 1) * (1 / 4) * delta / lambda\n\ngoal (1 subgoal):\n 1. closestM - x \\<le> real n * (1 / 4) * delta / lambda", "by (auto simp add: algebra_simps add_divide_distrib)"], ["proof (state)\nthis:\n  closestM - x \\<le> real n * (1 / 4) * delta / lambda\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Conclusion of the proof: combine the lower bound of the second substep with\n              the upper bound of the first substep to get a definite gain when one goes from\n              the old geodesic to the new one. Then, apply the inductive assumption to the new one\n              to conclude the desired inequality for the old one.\\<close>"], ["proof (state)\nthis:\n  closestM - x \\<le> real n * (1 / 4) * delta / lambda\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"L + 4 * delta = ((L + 4 * delta)/(L - 13 * delta)) * (L - 13 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L + 4 * delta = (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)", "using Laux \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < delta\n\ngoal (1 subgoal):\n 1. L + 4 * delta = (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)", "by (simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  L + 4 * delta = (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L + 4 * delta = (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> ((L + 4 * delta)/(L - 13 * delta)) * ((4 * exp(1/2 * ln 2)) * lambda * exp (- (1 - alpha) * D * ln 2 / (5 * delta)) * ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n    \\<le> (L + 4 * delta) / (L - 13 * delta) *\n          (4 * exp (1 / 2 * ln 2) * lambda *\n           exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n           ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))))", "apply (rule mult_left_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n          exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n          ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n 2. 0 \\<le> (L + 4 * delta) / (L - 13 * delta)", "using A Laux \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n        exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n        ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < delta\n\ngoal (2 subgoals):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n          exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n          ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta)))\n 2. 0 \\<le> (L + 4 * delta) / (L - 13 * delta)", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> ((L + 4 * delta)/(L - 13 * delta)) * ((4 * exp(1/2 * ln 2)) * lambda * exp (- (1 - alpha) * D * ln 2 / (5 * delta)) * ((exp(-K * (closestM - x)) - exp(-K * (uM - um)))/K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (L + 4 * delta) / (L - 13 * delta) *\n    (4 * exp (1 / 2 * ln 2) * lambda *\n     exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n     ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))))\n    \\<le> (L + 4 * delta) / (L - 13 * delta) *\n          (4 * exp (1 / 2 * ln 2) * lambda *\n           exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n           ((exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K))", "apply (intro mono_intros B)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n            exp (- (1 - alpha) * D * ln 2 / (5 * delta))\n 2. 0 \\<le> (L + 4 * delta) / (L - 13 * delta)", "using Laux \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < delta\n  1 \\<le> lambda\n\ngoal (2 subgoals):\n 1. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n            exp (- (1 - alpha) * D * ln 2 / (5 * delta))\n 2. 0 \\<le> (L + 4 * delta) / (L - 13 * delta)", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  (L + 4 * delta) / (L - 13 * delta) *\n  (4 * exp (1 / 2 * ln 2) * lambda *\n   exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n   ((x - v) * exp (- alpha * 2 ^ k * dm * ln 2 / (5 * delta))))\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L + 4 * delta\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K))", "have C: \"L + 4 * delta \\<le> Kmult * (exp(-K * (closestM - x)) - exp(-K * (uM - um)))\""], ["proof (prove)\nusing this:\n  L + 4 * delta\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K))\n\ngoal (1 subgoal):\n 1. L + 4 * delta\n    \\<le> Kmult * (exp (- K * (closestM - x)) - exp (- K * (uM - um)))", "unfolding Kmult_def"], ["proof (prove)\nusing this:\n  L + 4 * delta\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((exp (- K * (closestM - x)) - exp (- K * (uM - um))) / K))\n\ngoal (1 subgoal):\n 1. L + 4 * delta\n    \\<le> (L + 4 * delta) / (L - 13 * delta) *\n          (4 * exp (1 / 2 * ln 2) * lambda *\n           exp (- (1 - alpha) * D * ln 2 / (5 * delta)) /\n           K) *\n          (exp (- K * (closestM - x)) - exp (- K * (uM - um)))", "by auto"], ["proof (state)\nthis:\n  L + 4 * delta\n  \\<le> Kmult * (exp (- K * (closestM - x)) - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"Gromov_product_at (f z) (f um) (f uM) \\<le> Gromov_product_at (f z) (f x) (f closestM) + (L + 4 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f x) (f closestM) + (L + 4 * delta)", "apply (rule Rec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> {um..ym}\n 2. closestM \\<in> {yM..uM}", "using \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>x \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close>"], ["proof (prove)\nusing this:\n  closestM \\<in> {yM..uM}\n  x \\<in> {um..ym}\n  ym \\<in> {um..z}\n\ngoal (2 subgoals):\n 1. x \\<in> {um..ym}\n 2. closestM \\<in> {yM..uM}", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> Gromov_product_at (f z) (f x) (f closestM) + (L + 4 * delta)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> Gromov_product_at (f z) (f x) (f closestM) + (L + 4 * delta)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... \\<le> (lambda^2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(- K * (closestM - x)))) + (Kmult * (exp(-K * (closestM - x)) - exp(-K * (uM-um))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f x) (f closestM) + (L + 4 * delta)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (closestM - x))) +\n          Kmult * (exp (- K * (closestM - x)) - exp (- K * (uM - um)))", "apply (intro mono_intros C Suc.IH)"], ["proof (prove)\ngoal (3 subgoals):\n 1. x \\<in> {a..z}\n 2. closestM \\<in> {z..b}\n 3. closestM - x \\<le> real n * (1 / 4) * delta / lambda", "using \\<open>x \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>closestM \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>closestM - x \\<le> n * (1/4) * delta / lambda\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> {um..ym}\n  ym \\<in> {um..z}\n  um \\<in> {a..z}\n  closestM \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n  uM \\<in> {z..b}\n  closestM - x \\<le> real n * (1 / 4) * delta / lambda\n\ngoal (3 subgoals):\n 1. x \\<in> {a..z}\n 2. closestM \\<in> {z..b}\n 3. closestM - x \\<le> real n * (1 / 4) * delta / lambda", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f x) (f closestM) + (L + 4 * delta)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (closestM - x))) +\n        Kmult * (exp (- K * (closestM - x)) - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f x) (f closestM) + (L + 4 * delta)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (closestM - x))) +\n        Kmult * (exp (- K * (closestM - x)) - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"... = (lambda^2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(- K * (uM - um))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    Kmult * (1 - exp (- K * (closestM - x))) +\n    Kmult * (exp (- K * (closestM - x)) - exp (- K * (uM - um))) =\n    lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    Kmult * (1 - exp (- K * (uM - um)))", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    Kmult *\n    (1 -\n     exp (- (alpha * ln 2 /\n             (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n          (closestM - x))) +\n    Kmult *\n    (exp (- (alpha * ln 2 /\n             (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n          (closestM - x)) -\n     exp (- (alpha * ln 2 /\n             (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n          (uM - um))) =\n    lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    Kmult *\n    (1 -\n     exp (- (alpha * ln 2 /\n             (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n          (uM - um)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n  Kmult * (1 - exp (- K * (closestM - x))) +\n  Kmult * (exp (- K * (closestM - x)) - exp (- K * (uM - um))) =\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n  Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{um..w}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) um) (q (Suc k) x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>End of the first subcase, when there is a good point $v$ between $um$ and $w$.\\<close>"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) um) (q (Suc k) x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>{um..w}.\n             dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "text \\<open>Second subcase: between $um$ and $w$, all points are far away from $V_k$. We\n              will show that this implies that $w$ is admissible for the step $k+1$.\\<close>"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>{um..w}.\n             dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "have \"\\<exists>w\\<in>{um..ym}. (\\<forall>v\\<in>{um..w}. (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f v) (p v)) \\<and> L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>{um..ym}.\n       (\\<forall>v\\<in>{um..w}.\n           (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f v) (p v)) \\<and>\n       L - 4 * delta + 7 * QC (Suc k)\n       \\<le> dist (q (Suc k) um) (q (Suc k) w)", "proof (rule bexI[of _ w], auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>um \\<le> v; v \\<le> w\\<rbrakk>\n       \\<Longrightarrow> (4 * 2 ^ k - 1) * dm \\<le> dist (f v) (p v)\n 2. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)\n 3. um \\<le> w\n 4. w \\<le> ym", "show \"um \\<le> w\" \"w \\<le> ym\""], ["proof (prove)\ngoal (1 subgoal):\n 1. um \\<le> w &&& w \\<le> ym", "using \\<open>w \\<in> {um..x}\\<close> \\<open>x \\<in> {um..ym}\\<close>"], ["proof (prove)\nusing this:\n  w \\<in> {um..x}\n  x \\<in> {um..ym}\n\ngoal (1 subgoal):\n 1. um \\<le> w &&& w \\<le> ym", "by auto"], ["proof (state)\nthis:\n  um \\<le> w\n  w \\<le> ym\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>um \\<le> v; v \\<le> w\\<rbrakk>\n       \\<Longrightarrow> (4 * 2 ^ k - 1) * dm \\<le> dist (f v) (p v)\n 2. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "show \"(4 * 2 ^ k - 1) * dm \\<le> dist (f x) (p x)\" if \"um \\<le> x\" \"x \\<le> w\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (4 * 2 ^ k - 1) * dm \\<le> dist (f x) (p x)", "using False \\<open>dm \\<ge> 0\\<close> that"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>{um..w}.\n             dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dm)\n  0 \\<le> dm\n  um \\<le> x\n  x \\<le> w\n\ngoal (1 subgoal):\n 1. (4 * 2 ^ k - 1) * dm \\<le> dist (f x) (p x)", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>um \\<le> ?x; ?x \\<le> w\\<rbrakk>\n  \\<Longrightarrow> (4 * 2 ^ k - 1) * dm \\<le> dist (f ?x) (p ?x)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "have \"dist (q k um) (q (k+1) um) = 2^k * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k um) (q (k + 1) um) = 2 ^ k * dm", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {p um--f um} (p um) ((2 ^ k - 1) * dm))\n     (geodesic_segment_param {p um--f um} (p um) ((2 ^ (k + 1) - 1) * dm)) =\n    2 ^ k * dm", "apply (subst geodesic_segment_param(7)[where ?y = \"f um\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. geodesic_segment_between {p um--f um} (p um) (f um)\n 2. (2 ^ k - 1) * dm \\<in> {0..dist (p um) (f um)}\n 3. (2 ^ (k + 1) - 1) * dm \\<in> {0..dist (p um) (f um)}\n 4. \\<bar>(2 ^ k - 1) * dm - (2 ^ (k + 1) - 1) * dm\\<bar> = 2 ^ k * dm", "using x(3)[of um] \\<open>x \\<in> {um..ym}\\<close> aux"], ["proof (prove)\nusing this:\n  um \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f um) (p um)\n  x \\<in> {um..ym}\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n\ngoal (4 subgoals):\n 1. geodesic_segment_between {p um--f um} (p um) (f um)\n 2. (2 ^ k - 1) * dm \\<in> {0..dist (p um) (f um)}\n 3. (2 ^ (k + 1) - 1) * dm \\<in> {0..dist (p um) (f um)}\n 4. \\<bar>(2 ^ k - 1) * dm - (2 ^ (k + 1) - 1) * dm\\<bar> = 2 ^ k * dm", "by (auto simp add: metric_space_class.dist_commute, simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist (q k um) (q (k + 1) um) = 2 ^ k * dm\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "have \"dist (q k w) (q (k+1) w) = 2^k * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k w) (q (k + 1) w) = 2 ^ k * dm", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {p w--f w} (p w) ((2 ^ k - 1) * dm))\n     (geodesic_segment_param {p w--f w} (p w) ((2 ^ (k + 1) - 1) * dm)) =\n    2 ^ k * dm", "apply (subst geodesic_segment_param(7)[where ?y = \"f w\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. geodesic_segment_between {p w--f w} (p w) (f w)\n 2. (2 ^ k - 1) * dm \\<in> {0..dist (p w) (f w)}\n 3. (2 ^ (k + 1) - 1) * dm \\<in> {0..dist (p w) (f w)}\n 4. \\<bar>(2 ^ k - 1) * dm - (2 ^ (k + 1) - 1) * dm\\<bar> = 2 ^ k * dm", "using x(3)[of w] \\<open>w \\<in> {um..x}\\<close> \\<open>x \\<in> {um..ym}\\<close> aux"], ["proof (prove)\nusing this:\n  w \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)\n  w \\<in> {um..x}\n  x \\<in> {um..ym}\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n\ngoal (4 subgoals):\n 1. geodesic_segment_between {p w--f w} (p w) (f w)\n 2. (2 ^ k - 1) * dm \\<in> {0..dist (p w) (f w)}\n 3. (2 ^ (k + 1) - 1) * dm \\<in> {0..dist (p w) (f w)}\n 4. \\<bar>(2 ^ k - 1) * dm - (2 ^ (k + 1) - 1) * dm\\<bar> = 2 ^ k * dm", "by (auto simp add: metric_space_class.dist_commute, simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist (q k w) (q (k + 1) w) = 2 ^ k * dm\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "have i: \"q k um \\<in> proj_set (q (k+1) um) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k um \\<in> proj_set (q (k + 1) um) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p um--f um} (p um) ((2 ^ k - 1) * dm)\n    \\<in> proj_set\n           (geodesic_segment_param {p um--f um} (p um)\n             ((2 ^ (k + 1) - 1) * dm))\n           (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))", "apply (rule proj_set_thickening'[of _ \"f um\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. p um \\<in> proj_set (f um) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> (2 ^ (k + 1) - 1) * dm\n 4. (2 ^ (k + 1) - 1) * dm \\<le> dist (p um) (f um)\n 5. geodesic_segment_between {p um--f um} (p um) (f um)", "using p x(3)[of um] \\<open>x \\<in> {um..ym}\\<close> aux"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n  um \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f um) (p um)\n  x \\<in> {um..ym}\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n\ngoal (5 subgoals):\n 1. p um \\<in> proj_set (f um) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> (2 ^ (k + 1) - 1) * dm\n 4. (2 ^ (k + 1) - 1) * dm \\<le> dist (p um) (f um)\n 5. geodesic_segment_between {p um--f um} (p um) (f um)", "by (auto simp add: algebra_simps metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k um \\<in> proj_set (q (k + 1) um) (V k)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "have j: \"q k w \\<in> proj_set (q (k+1) w) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k w \\<in> proj_set (q (k + 1) w) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p w--f w} (p w) ((2 ^ k - 1) * dm)\n    \\<in> proj_set\n           (geodesic_segment_param {p w--f w} (p w)\n             ((2 ^ (k + 1) - 1) * dm))\n           (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dm))", "apply (rule proj_set_thickening'[of _ \"f w\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. p w \\<in> proj_set (f w) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> (2 ^ (k + 1) - 1) * dm\n 4. (2 ^ (k + 1) - 1) * dm \\<le> dist (p w) (f w)\n 5. geodesic_segment_between {p w--f w} (p w) (f w)", "using p x(3)[of w] \\<open>x \\<in> {um..ym}\\<close> \\<open>w \\<in> {um..x}\\<close> aux"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n  w \\<in> {um..x} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)\n  x \\<in> {um..ym}\n  w \\<in> {um..x}\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n\ngoal (5 subgoals):\n 1. p w \\<in> proj_set (f w) H\n 2. 0 \\<le> (2 ^ k - 1) * dm\n 3. (2 ^ k - 1) * dm \\<le> (2 ^ (k + 1) - 1) * dm\n 4. (2 ^ (k + 1) - 1) * dm \\<le> dist (p w) (f w)\n 5. geodesic_segment_between {p w--f w} (p w) (f w)", "by (auto simp add: algebra_simps metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k w \\<in> proj_set (q (k + 1) w) (V k)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "have \"5 * delta + 2 * QC k \\<le> dist (q k um) (q k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta + 2 * QC k \\<le> dist (q k um) (q k w)", "using w(2)"], ["proof (prove)\nusing this:\n  dist (q k um) (q k w)\n  \\<in> {9 * delta + 4 * QC k - 4 * delta - 2 * QC k..9 * delta + 4 * QC k}\n\ngoal (1 subgoal):\n 1. 5 * delta + 2 * QC k \\<le> dist (q k um) (q k w)", "by simp"], ["proof (state)\nthis:\n  5 * delta + 2 * QC k \\<le> dist (q k um) (q k w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "also"], ["proof (state)\nthis:\n  5 * delta + 2 * QC k \\<le> dist (q k um) (q k w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "have \"... \\<le> max (5 * deltaG(TYPE('a)) + 2 * QC k)\n                                      (dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) - dist (q k w) (q (k + 1) w) + 10 * deltaG(TYPE('a)) + 4 * QC k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k um) (q k w)\n    \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n           (dist (q (k + 1) um) (q (k + 1) w) -\n            dist (q k um) (q (k + 1) um) -\n            dist (q k w) (q (k + 1) w) +\n            10 * deltaG TYPE('a) +\n            4 * QC k)", "by (rule proj_along_quasiconvex_contraction[OF \\<open>quasiconvex (QC k) (V k)\\<close> i j])"], ["proof (state)\nthis:\n  dist (q k um) (q k w)\n  \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n         (dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "finally"], ["proof (chain)\npicking this:\n  5 * delta + 2 * QC k\n  \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n         (dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k)", "have \"5 * delta + 2 * QC k \\<le> dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) - dist (q k w) (q (k + 1) w) + 10 * deltaG(TYPE('a)) + 4 * QC k\""], ["proof (prove)\nusing this:\n  5 * delta + 2 * QC k\n  \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n         (dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k)\n\ngoal (1 subgoal):\n 1. 5 * delta + 2 * QC k\n    \\<le> dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  5 * delta + 2 * QC k\n  \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n         (dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k)\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. 5 * delta + 2 * QC k\n    \\<le> dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k", "by auto"], ["proof (state)\nthis:\n  5 * delta + 2 * QC k\n  \\<le> dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n        dist (q k w) (q (k + 1) w) +\n        10 * deltaG TYPE('a) +\n        4 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "then"], ["proof (chain)\npicking this:\n  5 * delta + 2 * QC k\n  \\<le> dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n        dist (q k w) (q (k + 1) w) +\n        10 * deltaG TYPE('a) +\n        4 * QC k", "have \"0 \\<le> dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k - dist (q k um) (q (k + 1) um) - dist (q k w) (q (k + 1) w)\""], ["proof (prove)\nusing this:\n  5 * delta + 2 * QC k\n  \\<le> dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n        dist (q k w) (q (k + 1) w) +\n        10 * deltaG TYPE('a) +\n        4 * QC k\n\ngoal (1 subgoal):\n 1. 0 \\<le> dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n            dist (q k um) (q (k + 1) um) -\n            dist (q k w) (q (k + 1) w)", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  5 * delta + 2 * QC k\n  \\<le> dist (q (k + 1) um) (q (k + 1) w) - dist (q k um) (q (k + 1) um) -\n        dist (q k w) (q (k + 1) w) +\n        10 * deltaG TYPE('a) +\n        4 * QC k\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. 0 \\<le> dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n            dist (q k um) (q (k + 1) um) -\n            dist (q k w) (q (k + 1) w)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          dist (q k um) (q (k + 1) um) -\n          dist (q k w) (q (k + 1) w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "also"], ["proof (state)\nthis:\n  0 \\<le> dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          dist (q k um) (q (k + 1) um) -\n          dist (q k w) (q (k + 1) w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "have \"... = dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k - 2^(k+1) * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n    dist (q k um) (q (k + 1) um) -\n    dist (q k w) (q (k + 1) w) =\n    dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n    2 ^ (k + 1) * dm", "by (simp only: \\<open>dist (q k w) (q (k+1) w) = 2^k * dm\\<close> \\<open>dist (q k um) (q (k+1) um) = 2^k * dm\\<close>, auto)"], ["proof (state)\nthis:\n  dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n  dist (q k um) (q (k + 1) um) -\n  dist (q k w) (q (k + 1) w) =\n  dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n  2 ^ (k + 1) * dm\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          2 ^ (k + 1) * dm", "have *: \"2^(k+1) * dm - 5 * delta - 2 * QC k \\<le> dist (q (k+1) um) (q (k+1) w)\""], ["proof (prove)\nusing this:\n  0 \\<le> dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          2 ^ (k + 1) * dm\n\ngoal (1 subgoal):\n 1. 2 ^ (k + 1) * dm - 5 * delta - 2 * QC k\n    \\<le> dist (q (k + 1) um) (q (k + 1) w)", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> dist (q (k + 1) um) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          2 ^ (k + 1) * dm\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. 2 ^ (k + 1) * dm - 5 * delta - 2 * QC k\n    \\<le> dist (q (k + 1) um) (q (k + 1) w)", "by auto"], ["proof (state)\nthis:\n  2 ^ (k + 1) * dm - 5 * delta - 2 * QC k\n  \\<le> dist (q (k + 1) um) (q (k + 1) w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "have \"L - 4 * delta + 7 * QC (k+1) \\<le> 2 * dm - 5 * delta - 2 * QC k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (k + 1) \\<le> 2 * dm - 5 * delta - 2 * QC k", "unfolding QC_def L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 18 * delta - 4 * delta + 7 * (if k + 1 = 0 then 0 else 8 * delta)\n    \\<le> 2 * dm - 5 * delta - 2 * (if k = 0 then 0 else 8 * delta)", "using \\<open>delta > 0\\<close> Laux I \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 18 * delta - 4 * delta + 7 * (if k + 1 = 0 then 0 else 8 * delta)\n    \\<le> 2 * dm - 5 * delta - 2 * (if k = 0 then 0 else 8 * delta)", "by auto"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC (k + 1) \\<le> 2 * dm - 5 * delta - 2 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "also"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC (k + 1) \\<le> 2 * dm - 5 * delta - 2 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "have \"... \\<le> 2^(k+1) * dm - 5 * delta - 2 * QC k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * dm - 5 * delta - 2 * QC k\n    \\<le> 2 ^ (k + 1) * dm - 5 * delta - 2 * QC k", "using aux"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dm \\<le> (2 * 2 ^ k - 1) * dm\n  0 \\<le> 2 * 2 ^ k - 1\n  dm \\<le> dm * 2 ^ k\n\ngoal (1 subgoal):\n 1. 2 * dm - 5 * delta - 2 * QC k\n    \\<le> 2 ^ (k + 1) * dm - 5 * delta - 2 * QC k", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  2 * dm - 5 * delta - 2 * QC k\n  \\<le> 2 ^ (k + 1) * dm - 5 * delta - 2 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "finally"], ["proof (chain)\npicking this:\n  L - 4 * delta + 7 * QC (k + 1)\n  \\<le> 2 ^ (k + 1) * dm - 5 * delta - 2 * QC k", "show \"L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)\""], ["proof (prove)\nusing this:\n  L - 4 * delta + 7 * QC (k + 1)\n  \\<le> 2 ^ (k + 1) * dm - 5 * delta - 2 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "using *"], ["proof (prove)\nusing this:\n  L - 4 * delta + 7 * QC (k + 1)\n  \\<le> 2 ^ (k + 1) * dm - 5 * delta - 2 * QC k\n  2 ^ (k + 1) * dm - 5 * delta - 2 * QC k\n  \\<le> dist (q (k + 1) um) (q (k + 1) w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "by auto"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w\\<in>{um..ym}.\n     (\\<forall>v\\<in>{um..w}.\n         (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f v) (p v)) \\<and>\n     L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{um..w}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dm) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>{um..ym}.\n     (\\<forall>v\\<in>{um..w}.\n         (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f v) (p v)) \\<and>\n     L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>{um..ym}.\n     (\\<forall>v\\<in>{um..w}.\n         (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f v) (p v)) \\<and>\n     L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) um) (q (Suc k) w)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{um..ym}.\n        (\\<forall>w\\<in>{um..x}.\n            (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) um) (q (Suc k) x))", "by simp"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) um) (q (Suc k) x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) um) (q (Suc k) x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (Suc k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) um) (q (Suc k) x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (?k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC ?k \\<le> dist (q ?k um) (q ?k x))\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>This is the end of the main induction over $k$. To conclude, choose $k$ large enough\n        so that the second alternative in this induction is impossible. It follows that the first\n        alternative holds, i.e., the desired inequality is true.\\<close>"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (?k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC ?k \\<le> dist (q ?k um) (q ?k x))\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"dm > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < dm", "using I \\<open>delta > 0\\<close> \\<open>C \\<ge> 0\\<close> Laux"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dm\n  dM \\<le> dm\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. 0 < dm", "by auto"], ["proof (state)\nthis:\n  0 < dm\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"\\<exists>k. 2^k > dist (f um) (p um)/dm + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. dist (f um) (p um) / dm + 1 < 2 ^ k", "by (simp add: real_arch_pow)"], ["proof (state)\nthis:\n  \\<exists>k. dist (f um) (p um) / dm + 1 < 2 ^ k\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>k. dist (f um) (p um) / dm + 1 < 2 ^ k", "obtain k where \"2^k > dist (f um) (p um)/dm + 1\""], ["proof (prove)\nusing this:\n  \\<exists>k. dist (f um) (p um) / dm + 1 < 2 ^ k\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        dist (f um) (p um) / dm + 1 < 2 ^ k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dist (f um) (p um) / dm + 1 < 2 ^ k\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  dist (f um) (p um) / dm + 1 < 2 ^ k", "have \"dist (f um) (p um) < (2^k - 1) * dm\""], ["proof (prove)\nusing this:\n  dist (f um) (p um) / dm + 1 < 2 ^ k\n\ngoal (1 subgoal):\n 1. dist (f um) (p um) < (2 ^ k - 1) * dm", "using \\<open>dm > 0\\<close>"], ["proof (prove)\nusing this:\n  dist (f um) (p um) / dm + 1 < 2 ^ k\n  0 < dm\n\ngoal (1 subgoal):\n 1. dist (f um) (p um) < (2 ^ k - 1) * dm", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  dist (f um) (p um) < (2 ^ k - 1) * dm\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  dist (f um) (p um) < (2 ^ k - 1) * dm\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... \\<le> (2^(Suc k) - 1) * dm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ k - 1) * dm \\<le> (2 ^ Suc k - 1) * dm", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  (2 ^ k - 1) * dm \\<le> (2 ^ Suc k - 1) * dm\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  dist (f um) (p um) < (2 ^ Suc k - 1) * dm", "have \"\\<not>((2 ^ (k + 1) - 1) * dm \\<le> dist (f um) (p um))\""], ["proof (prove)\nusing this:\n  dist (f um) (p um) < (2 ^ Suc k - 1) * dm\n\ngoal (1 subgoal):\n 1. \\<not> (2 ^ (k + 1) - 1) * dm \\<le> dist (f um) (p um)", "by simp"], ["proof (state)\nthis:\n  \\<not> (2 ^ (k + 1) - 1) * dm \\<le> dist (f um) (p um)\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dm \\<and> dM \\<le> dm \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))\n 2. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  \\<not> (2 ^ (k + 1) - 1) * dm \\<le> dist (f um) (p um)", "show \"Gromov_product_at (f z) (f um) (f uM) \\<le> lambda\\<^sup>2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp (- K * (uM - um)))\""], ["proof (prove)\nusing this:\n  \\<not> (2 ^ (k + 1) - 1) * dm \\<le> dist (f um) (p um)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "using Ind_k[of k]"], ["proof (prove)\nusing this:\n  \\<not> (2 ^ (k + 1) - 1) * dm \\<le> dist (f um) (p um)\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{um..ym}.\n      (\\<forall>w\\<in>{um..x}.\n          (2 ^ (k + 1) - 1) * dm \\<le> dist (f w) (p w)) \\<and>\n      L - 4 * delta + 7 * QC k \\<le> dist (q k um) (q k x))\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>end of the case where $D + 4 * C \\leq dm$ and $dM \\leq dm$.\\<close>"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "case 3"], ["proof (state)\nthis:\n  D + 4 * C \\<le> dM \\<and> dm \\<le> dM\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "text \\<open>This is the exact copy of the previous case, except that the roles of the points before\n        and after $z$ are exchanged. In a perfect world, one would use a lemma subsuming both cases,\n        but in practice copy-paste seems to work better here as there are two many details to be\n        changed regarding the direction of inequalities.\\<close>"], ["proof (state)\nthis:\n  D + 4 * C \\<le> dM \\<and> dm \\<le> dM\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  D + 4 * C \\<le> dM \\<and> dm \\<le> dM", "have I: \"D + 4 * C \\<le> dM\" \"dm \\<le> dM\""], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM \\<and> dm \\<le> dM\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM &&& dm \\<le> dM", "by auto"], ["proof (state)\nthis:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define V where \"V = (\\<lambda>k::nat. (\\<Union>g\\<in>H. cball g ((2^k - 1) * dM)))\""], ["proof (state)\nthis:\n  V = (\\<lambda>k. \\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define QC where \"QC = (\\<lambda>k::nat. if k = 0 then 0 else 8 * delta)\""], ["proof (state)\nthis:\n  QC = (\\<lambda>k. if k = 0 then 0 else 8 * delta)\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"QC k \\<ge> 0\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> QC k", "unfolding QC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> (if k = 0 then 0 else 8 * delta)", "using \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n\ngoal (1 subgoal):\n 1. 0 \\<le> (if k = 0 then 0 else 8 * delta)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> QC ?k\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have Q: \"quasiconvex (0 + 8 * deltaG(TYPE('a))) (V k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (0 + 8 * deltaG TYPE('a)) (V k)", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (0 + 8 * deltaG TYPE('a))\n     (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))", "apply (rule quasiconvex_thickening)"], ["proof (prove)\ngoal (2 subgoals):\n 1. quasiconvex 0 H\n 2. 0 \\<le> (2 ^ k - 1) * dM", "using geodesic_segmentI[OF H]"], ["proof (prove)\nusing this:\n  geodesic_segment H\n\ngoal (2 subgoals):\n 1. quasiconvex 0 H\n 2. 0 \\<le> (2 ^ k - 1) * dM", "by (auto simp add: quasiconvex_of_geodesic)"], ["proof (state)\nthis:\n  quasiconvex (0 + 8 * deltaG TYPE('a)) (V ?k)\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"quasiconvex (QC k) (V k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (QC k) (V k)", "apply (cases \"k = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> quasiconvex (QC k) (V k)\n 2. k \\<noteq> 0 \\<Longrightarrow> quasiconvex (QC k) (V k)", "apply (simp add: V_def QC_def quasiconvex_of_geodesic geodesic_segmentI[OF H])"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> quasiconvex (QC k) (V k)", "apply (rule quasiconvex_mono[OF _ Q[of k]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> 0 + 8 * deltaG TYPE('a) \\<le> QC k", "using \\<open>deltaG(TYPE('a)) < delta\\<close> QC_def"], ["proof (prove)\nusing this:\n  deltaG TYPE('a) < delta\n  QC = (\\<lambda>k. if k = 0 then 0 else 8 * delta)\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow> 0 + 8 * deltaG TYPE('a) \\<le> QC k", "by auto"], ["proof (state)\nthis:\n  quasiconvex (QC ?k) (V ?k)\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "define q::\"nat \\<Rightarrow> real \\<Rightarrow> 'a\" where \"q = (\\<lambda>k x. geodesic_segment_param {p x--f x} (p x) ((2^k - 1) * dM))\""], ["proof (state)\nthis:\n  q =\n  (\\<lambda>k x. geodesic_segment_param {p x--f x} (p x) ((2 ^ k - 1) * dM))\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have Ind_k: \"(Gromov_product_at (f z) (f um) (f uM) \\<le> lambda^2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(- K * (uM - um))))\n              \\<or> (\\<exists>x \\<in> {yM..uM}. (\\<forall>y \\<in> {x..uM}. dist (f y) (p y) \\<ge> (2^(k+1)-1) * dM) \\<and> dist (q k uM) (q k x) \\<ge> L - 4 * delta + 7 * QC k)\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x))", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (0 + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 uM) (q 0 x))\n 2. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k uM) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (0 + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 uM) (q 0 x))\n 2. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k uM) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have *: \"\\<exists>x\\<in> {yM..uM}. (\\<forall>y \\<in> {x..uM}. dist (f y) (p y) \\<ge> (2^(0+1)-1) * dM) \\<and> dist (q 0 uM) (q 0 x) \\<ge> L - 4 * delta + 7 * QC 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{yM..uM}.\n       (\\<forall>y\\<in>{x..uM}.\n           (2 ^ (0 + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n       L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 uM) (q 0 x)", "proof (rule bexI[of _ yM], auto simp add: V_def q_def QC_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>yM \\<le> y; y \\<le> uM\\<rbrakk>\n       \\<Longrightarrow> dM \\<le> dist (f y) (p y)\n 2. L - 4 * delta \\<le> dist (p uM) (p yM)\n 3. yM \\<le> uM", "show \"yM \\<le> uM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yM \\<le> uM", "using \\<open>yM \\<in> {z..uM}\\<close>"], ["proof (prove)\nusing this:\n  yM \\<in> {z..uM}\n\ngoal (1 subgoal):\n 1. yM \\<le> uM", "by auto"], ["proof (state)\nthis:\n  yM \\<le> uM\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>yM \\<le> y; y \\<le> uM\\<rbrakk>\n       \\<Longrightarrow> dM \\<le> dist (f y) (p y)\n 2. L - 4 * delta \\<le> dist (p uM) (p yM)", "show \"L -4 * delta \\<le> dist (p uM) (p yM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L - 4 * delta \\<le> dist (p uM) (p yM)", "using yM(2)"], ["proof (prove)\nusing this:\n  dist (p uM) (p yM)\n  \\<in> {L + dist pi_z (p uM) - 4 * delta - 2 * 0..L + dist pi_z (p uM)}\n\ngoal (1 subgoal):\n 1. L - 4 * delta \\<le> dist (p uM) (p yM)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L + dist pi_z (p uM) - 4 * delta \\<le> dist (p uM) (p yM);\n     dist (p uM) (p yM) \\<le> L + dist pi_z (p uM)\\<rbrakk>\n    \\<Longrightarrow> L - 4 * delta \\<le> dist (p uM) (p yM)", "using metric_space_class.zero_le_dist[of pi_z \"p uM\"]"], ["proof (prove)\nusing this:\n  0 \\<le> dist pi_z (p uM)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>L + dist pi_z (p uM) - 4 * delta \\<le> dist (p uM) (p yM);\n     dist (p uM) (p yM) \\<le> L + dist pi_z (p uM)\\<rbrakk>\n    \\<Longrightarrow> L - 4 * delta \\<le> dist (p uM) (p yM)", "by linarith"], ["proof (state)\nthis:\n  L - 4 * delta \\<le> dist (p uM) (p yM)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>yM \\<le> y; y \\<le> uM\\<rbrakk>\n       \\<Longrightarrow> dM \\<le> dist (f y) (p y)", "show \"\\<And>y. y \\<le> uM \\<Longrightarrow> yM \\<le> y \\<Longrightarrow> dM \\<le> dist (f y) (p y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<le> uM; yM \\<le> y\\<rbrakk>\n       \\<Longrightarrow> dM \\<le> dist (f y) (p y)", "using dM_def closestM proj_setD(2)[OF p]"], ["proof (prove)\nusing this:\n  dM = infdist (f closestM) H\n  closestM \\<in> {yM..uM}\n  ?v \\<in> {yM..uM} \\<Longrightarrow>\n  infdist (f closestM) H \\<le> infdist (f ?v) H\n  dist (f ?x1) (p ?x1) = infdist (f ?x1) H\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>y \\<le> uM; yM \\<le> y\\<rbrakk>\n       \\<Longrightarrow> dM \\<le> dist (f y) (p y)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?y \\<le> uM; yM \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> dM \\<le> dist (f ?y) (p ?y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{yM..uM}.\n     (\\<forall>y\\<in>{x..uM}.\n         (2 ^ (0 + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n     L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 uM) (q 0 x)\n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (0 + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 uM) (q 0 x))\n 2. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k uM) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>{yM..uM}.\n     (\\<forall>y\\<in>{x..uM}.\n         (2 ^ (0 + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n     L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 uM) (q 0 x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>{yM..uM}.\n     (\\<forall>y\\<in>{x..uM}.\n         (2 ^ (0 + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n     L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 uM) (q 0 x)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (0 + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 uM) (q 0 x))", "by blast"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (0 + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC 0 \\<le> dist (q 0 uM) (q 0 x))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k uM) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k uM) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "case Suck: (Suc k)"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x))\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC k\n           \\<le> dist (q k uM) (q k x)) \\<Longrightarrow>\n       Gromov_product_at (f z) (f um) (f uM)\n       \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n             2 * delta +\n             Kmult * (1 - exp (- K * (uM - um))) \\<or>\n       (\\<exists>x\\<in>{yM..uM}.\n           (\\<forall>y\\<in>{x..uM}.\n               (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n           L - 4 * delta + 7 * QC (Suc k)\n           \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "proof (cases \"Gromov_product_at (f z) (f um) (f uM) \\<le> lambda\\<^sup>2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp (- K * (uM - um)))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "case True"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "by simp"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "case False"], ["proof (state)\nthis:\n  \\<not> Gromov_product_at (f z) (f um) (f uM)\n         \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n               2 * delta +\n               Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<not> Gromov_product_at (f z) (f um) (f uM)\n         \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n               2 * delta +\n               Kmult * (1 - exp (- K * (uM - um)))", "obtain x where x: \"x \\<in> {yM..uM}\" \"dist (q k uM) (q k x) \\<ge> L - 4 * delta + 7 * QC k\"\n                                   \"\\<And>w. w \\<in> {x..uM} \\<Longrightarrow> dist (f w) (p w) \\<ge> (2^(k+1)-1) * dM\""], ["proof (prove)\nusing this:\n  \\<not> Gromov_product_at (f z) (f um) (f uM)\n         \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n               2 * delta +\n               Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {yM..uM};\n         L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x);\n         \\<And>w.\n            w \\<in> {x..uM} \\<Longrightarrow>\n            (2 ^ (k + 1) - 1) * dM \\<le> dist (f w) (p w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suck.IH"], ["proof (prove)\nusing this:\n  \\<not> Gromov_product_at (f z) (f um) (f uM)\n         \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n               2 * delta +\n               Kmult * (1 - exp (- K * (uM - um)))\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {yM..uM};\n         L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x);\n         \\<And>w.\n            w \\<in> {x..uM} \\<Longrightarrow>\n            (2 ^ (k + 1) - 1) * dM \\<le> dist (f w) (p w)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> {yM..uM}\n  L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x)\n  ?w \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f ?w) (p ?w)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have aux: \"(2 ^ k - 1) * dM \\<le> (2*2^k-1) * dM\" \"0 \\<le> 2 * 2 ^ k - (1::real)\" \"dM \\<le> dM * 2 ^ k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM &&&\n    0 \\<le> 2 * 2 ^ k - 1 &&& dM \\<le> dM * 2 ^ k", "apply (auto simp add: algebra_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 \\<le> 2 * 2 ^ k\n 2. dM \\<le> dM * 2 ^ k", "apply (metis power.simps(2) two_realpow_ge_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dM \\<le> dM * 2 ^ k", "using \\<open>0 \\<le> dM\\<close> less_eq_real_def"], ["proof (prove)\nusing this:\n  0 \\<le> dM\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. dM \\<le> dM * 2 ^ k", "by fastforce"], ["proof (state)\nthis:\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"L + C = (L/D) * (D + (D/L) * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L + C = L / D * (D + D / L * C)", "using \\<open>L > 0\\<close> \\<open>D > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < L\n  0 < D\n\ngoal (1 subgoal):\n 1. L + C = L / D * (D + D / L * C)", "by (simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  L + C = L / D * (D + D / L * C)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L + C = L / D * (D + D / L * C)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> (L/D) * (D + 4 * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L / D * (D + D / L * C) \\<le> L / D * (D + 4 * C)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. D / L \\<le> 4\n 2. 0 \\<le> C\n 3. 0 \\<le> L / D", "using \\<open>L > 0\\<close> \\<open>D > 0\\<close> \\<open>C \\<ge> 0\\<close> \\<open>D \\<le> 4 * L\\<close>"], ["proof (prove)\nusing this:\n  0 < L\n  0 < D\n  0 \\<le> C\n  D \\<le> 4 * L\n\ngoal (3 subgoals):\n 1. D / L \\<le> 4\n 2. 0 \\<le> C\n 3. 0 \\<le> L / D", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  L / D * (D + D / L * C) \\<le> L / D * (D + 4 * C)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L / D * (D + D / L * C) \\<le> L / D * (D + 4 * C)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> (L/D) * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L / D * (D + 4 * C) \\<le> L / D * dM", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dM\n 2. 0 \\<le> L / D", "using I \\<open>L > 0\\<close> \\<open>D > 0\\<close>"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 < L\n  0 < D\n\ngoal (2 subgoals):\n 1. D + 4 * C \\<le> dM\n 2. 0 \\<le> L / D", "by auto"], ["proof (state)\nthis:\n  L / D * (D + 4 * C) \\<le> L / D * dM\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L + C \\<le> L / D * dM", "have \"L + C \\<le> (L/D) * dM\""], ["proof (prove)\nusing this:\n  L + C \\<le> L / D * dM\n\ngoal (1 subgoal):\n 1. L + C \\<le> L / D * dM", "by simp"], ["proof (state)\nthis:\n  L + C \\<le> L / D * dM\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "moreover"], ["proof (state)\nthis:\n  L + C \\<le> L / D * dM\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"2 * delta \\<le> (2 * delta)/D * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * delta \\<le> 2 * delta / D * dM", "using I \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close> \\<open>D > 0\\<close>"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 \\<le> C\n  0 < delta\n  0 < D\n\ngoal (1 subgoal):\n 1. 2 * delta \\<le> 2 * delta / D * dM", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  2 * delta \\<le> 2 * delta / D * dM\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "ultimately"], ["proof (chain)\npicking this:\n  L + C \\<le> L / D * dM\n  2 * delta \\<le> 2 * delta / D * dM", "have aux2: \"L + C + 2 * delta \\<le> ((L + 2 * delta)/D) * dM\""], ["proof (prove)\nusing this:\n  L + C \\<le> L / D * dM\n  2 * delta \\<le> 2 * delta / D * dM\n\ngoal (1 subgoal):\n 1. L + C + 2 * delta \\<le> (L + 2 * delta) / D * dM", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  L + C + 2 * delta \\<le> (L + 2 * delta) / D * dM\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have aux3: \"(1-alpha) * D + alpha * 2^k * dM \\<le> dM * 2^k - C/2 - QC k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "using I \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "unfolding True QC_def alpha_def"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (1 - 12 / 100) * D + 12 / 100 * 2 ^ 0 * dM\n    \\<le> dM * 2 ^ 0 - C / 2 - (if 0 = 0 then 0 else 8 * delta)", "by auto"], ["proof (state)\nthis:\n  (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "have \"C/2 + QC k + (1-alpha) * D \\<le> 2 * (1-alpha) * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C / 2 + QC k + (1 - alpha) * D \\<le> 2 * (1 - alpha) * dM", "using I \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. C / 2 + QC k + (1 - alpha) * D \\<le> 2 * (1 - alpha) * dM", "unfolding QC_def alpha_def"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. C / 2 + (if k = 0 then 0 else 8 * delta) + (1 - 12 / 100) * D\n    \\<le> 2 * (1 - 12 / 100) * dM", "using False Laux"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 \\<le> C\n  k \\<noteq> 0\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. C / 2 + (if k = 0 then 0 else 8 * delta) + (1 - 12 / 100) * D\n    \\<le> 2 * (1 - 12 / 100) * dM", "by auto"], ["proof (state)\nthis:\n  C / 2 + QC k + (1 - alpha) * D \\<le> 2 * (1 - alpha) * dM\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "also"], ["proof (state)\nthis:\n  C / 2 + QC k + (1 - alpha) * D \\<le> 2 * (1 - alpha) * dM\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "have \"... \\<le> 2^k * (1-alpha) * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * (1 - alpha) * dM \\<le> 2 ^ k * (1 - alpha) * dM", "apply (intro mono_intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 1 \\<le> 2\n 2. 0 < k\n 3. 0 \\<le> 1 - alpha\n 4. 0 \\<le> dM", "using False alphaaux I \\<open>D > 0\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n  0 < alpha\n  alpha \\<le> 1\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 < D\n  0 \\<le> C\n\ngoal (4 subgoals):\n 1. 1 \\<le> 2\n 2. 0 < k\n 3. 0 \\<le> 1 - alpha\n 4. 0 \\<le> dM", "by auto"], ["proof (state)\nthis:\n  2 * (1 - alpha) * dM \\<le> 2 ^ k * (1 - alpha) * dM\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "finally"], ["proof (chain)\npicking this:\n  C / 2 + QC k + (1 - alpha) * D \\<le> 2 ^ k * (1 - alpha) * dM", "show ?thesis"], ["proof (prove)\nusing this:\n  C / 2 + QC k + (1 - alpha) * D \\<le> 2 ^ k * (1 - alpha) * dM\n\ngoal (1 subgoal):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"\\<exists>w \\<in> {x..uM}. (dist (q k uM) (q k w) \\<in> {(9 * delta + 4 * QC k) - 4 * delta - 2 * QC k .. 9 * delta + 4 * QC k})\n                    \\<and> (\\<forall>v \\<in> {w..uM}. dist (q k uM) (q k v) \\<le> 9 * delta + 4 * QC k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>{x..uM}.\n       dist (q k uM) (q k w)\n       \\<in> {9 * delta + 4 * QC k - 4 * delta -\n              2 * QC k..9 * delta + 4 * QC k} \\<and>\n       (\\<forall>v\\<in>{w..uM}.\n           dist (q k uM) (q k v) \\<le> 9 * delta + 4 * QC k)", "proof (rule quasi_convex_projection_small_gaps'[where ?f = f and ?G = \"V k\"])"], ["proof (state)\ngoal (6 subgoals):\n 1. continuous_on {x..uM} f\n 2. x \\<le> uM\n 3. quasiconvex (QC k) (V k)\n 4. \\<And>xa.\n       xa \\<in> {x..uM} \\<Longrightarrow> q k xa \\<in> proj_set (f xa) (V k)\n 5. deltaG TYPE('a) < delta\n 6. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k x) (q k uM)}", "show \"continuous_on {x..uM} f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {x..uM} f", "apply (rule continuous_on_subset[OF \\<open>continuous_on {a..b} f\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x..uM} \\<subseteq> {a..b}", "using \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>x \\<in> {yM..uM}\\<close>"], ["proof (prove)\nusing this:\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n  yM \\<in> {z..uM}\n  x \\<in> {yM..uM}\n\ngoal (1 subgoal):\n 1. {x..uM} \\<subseteq> {a..b}", "by auto"], ["proof (state)\nthis:\n  continuous_on {x..uM} f\n\ngoal (5 subgoals):\n 1. x \\<le> uM\n 2. quasiconvex (QC k) (V k)\n 3. \\<And>xa.\n       xa \\<in> {x..uM} \\<Longrightarrow> q k xa \\<in> proj_set (f xa) (V k)\n 4. deltaG TYPE('a) < delta\n 5. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k x) (q k uM)}", "show \"x \\<le> uM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> uM", "using \\<open>x \\<in> {yM..uM}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> {yM..uM}\n\ngoal (1 subgoal):\n 1. x \\<le> uM", "by auto"], ["proof (state)\nthis:\n  x \\<le> uM\n\ngoal (4 subgoals):\n 1. quasiconvex (QC k) (V k)\n 2. \\<And>xa.\n       xa \\<in> {x..uM} \\<Longrightarrow> q k xa \\<in> proj_set (f xa) (V k)\n 3. deltaG TYPE('a) < delta\n 4. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k x) (q k uM)}", "show \"quasiconvex (QC k) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (QC k) (V k)", "by fact"], ["proof (state)\nthis:\n  quasiconvex (QC k) (V k)\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       xa \\<in> {x..uM} \\<Longrightarrow> q k xa \\<in> proj_set (f xa) (V k)\n 2. deltaG TYPE('a) < delta\n 3. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k x) (q k uM)}", "show \"deltaG TYPE('a) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) < delta", "by fact"], ["proof (state)\nthis:\n  deltaG TYPE('a) < delta\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> {x..uM} \\<Longrightarrow> q k xa \\<in> proj_set (f xa) (V k)\n 2. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k x) (q k uM)}", "show \"9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k x) (q k uM)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k x) (q k uM)}", "using x(2) \\<open>delta > 0\\<close> \\<open>QC k \\<ge> 0\\<close> Laux"], ["proof (prove)\nusing this:\n  L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x)\n  0 < delta\n  0 \\<le> QC k\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. 9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k x) (q k uM)}", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  9 * delta + 4 * QC k \\<in> {4 * delta + 2 * QC k..dist (q k x) (q k uM)}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {x..uM} \\<Longrightarrow> q k xa \\<in> proj_set (f xa) (V k)", "show \"q k w \\<in> proj_set (f w) (V k)\" if \"w \\<in> {x..uM}\" for w"], ["proof (prove)\ngoal (1 subgoal):\n 1. q k w \\<in> proj_set (f w) (V k)", "unfolding V_def q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p w--f w} (p w) ((2 ^ k - 1) * dM)\n    \\<in> proj_set (f w) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p w \\<in> proj_set (f w) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p w) (f w)\n 4. geodesic_segment_between {p w--f w} (p w) (f w)", "using aux p x(3)[OF that]"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n  p ?x \\<in> proj_set (f ?x) H\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f w) (p w)\n\ngoal (4 subgoals):\n 1. p w \\<in> proj_set (f w) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p w) (f w)\n 4. geodesic_segment_between {p w--f w} (p w) (f w)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  ?w \\<in> {x..uM} \\<Longrightarrow> q k ?w \\<in> proj_set (f ?w) (V k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w\\<in>{x..uM}.\n     dist (q k uM) (q k w)\n     \\<in> {9 * delta + 4 * QC k - 4 * delta -\n            2 * QC k..9 * delta + 4 * QC k} \\<and>\n     (\\<forall>v\\<in>{w..uM}.\n         dist (q k uM) (q k v) \\<le> 9 * delta + 4 * QC k)\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>{x..uM}.\n     dist (q k uM) (q k w)\n     \\<in> {9 * delta + 4 * QC k - 4 * delta -\n            2 * QC k..9 * delta + 4 * QC k} \\<and>\n     (\\<forall>v\\<in>{w..uM}.\n         dist (q k uM) (q k v) \\<le> 9 * delta + 4 * QC k)", "obtain w where w: \"w \\<in> {x..uM}\"\n                                   \"dist (q k uM) (q k w) \\<in> {(9 * delta + 4 * QC k) - 4 * delta - 2 * QC k .. 9 * delta + 4 * QC k}\"\n                                   \"\\<And>v. v \\<in> {w..uM} \\<Longrightarrow> dist (q k uM) (q k v) \\<le> 9 * delta + 4 * QC k\""], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>{x..uM}.\n     dist (q k uM) (q k w)\n     \\<in> {9 * delta + 4 * QC k - 4 * delta -\n            2 * QC k..9 * delta + 4 * QC k} \\<and>\n     (\\<forall>v\\<in>{w..uM}.\n         dist (q k uM) (q k v) \\<le> 9 * delta + 4 * QC k)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> {x..uM};\n         dist (q k uM) (q k w)\n         \\<in> {9 * delta + 4 * QC k - 4 * delta -\n                2 * QC k..9 * delta + 4 * QC k};\n         \\<And>v.\n            v \\<in> {w..uM} \\<Longrightarrow>\n            dist (q k uM) (q k v) \\<le> 9 * delta + 4 * QC k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> {x..uM}\n  dist (q k uM) (q k w)\n  \\<in> {9 * delta + 4 * QC k - 4 * delta - 2 * QC k..9 * delta + 4 * QC k}\n  ?v \\<in> {w..uM} \\<Longrightarrow>\n  dist (q k uM) (q k ?v) \\<le> 9 * delta + 4 * QC k\n\ngoal (1 subgoal):\n 1. \\<not> Gromov_product_at (f z) (f um) (f uM)\n           \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                 2 * delta +\n                 Kmult * (1 - exp (- K * (uM - um))) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "proof (cases \"\\<exists>v \\<in> {w..uM}. dist (f v) (p v) \\<le> (2^(k+2)-1) * dM\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>{w..uM}. dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>{w..uM}. dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM", "obtain v where v: \"v \\<in> {w..uM}\" \"dist (f v) (p v) \\<le> (2^(k+2)-1) * dM\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>{w..uM}. dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> {w..uM};\n         dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> {w..uM}\n  dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have aux4: \"dM * 2 ^ k \\<le> infdist (f r) (V k)\" if \"r \\<in> {x..v}\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "have *: \"q k r \\<in> proj_set (f r) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k r \\<in> proj_set (f r) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM)\n    \\<in> proj_set (f r) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p r \\<in> proj_set (f r) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p r) (f r)\n 4. geodesic_segment_between {p r--f r} (p r) (f r)", "using aux p[of r] x(3)[of r] that \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n  p r \\<in> proj_set (f r) H\n  r \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f r) (p r)\n  r \\<in> {x..v}\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n\ngoal (4 subgoals):\n 1. p r \\<in> proj_set (f r) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p r) (f r)\n 4. geodesic_segment_between {p r--f r} (p r) (f r)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k r \\<in> proj_set (f r) (V k)\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "have \"infdist (f r) (V k) = dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r))) (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f r) (V k) =\n    dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n     (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM))", "using proj_setD(2)[OF *]"], ["proof (prove)\nusing this:\n  dist (f r) (q k r) = infdist (f r) (V k)\n\ngoal (1 subgoal):\n 1. infdist (f r) (V k) =\n    dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n     (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM))", "unfolding q_def"], ["proof (prove)\nusing this:\n  dist (f r) (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM)) =\n  infdist (f r) (V k)\n\ngoal (1 subgoal):\n 1. infdist (f r) (V k) =\n    dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n     (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM))", "by auto"], ["proof (state)\nthis:\n  infdist (f r) (V k) =\n  dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n   (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM))\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "also"], ["proof (state)\nthis:\n  infdist (f r) (V k) =\n  dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n   (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM))\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "have \"... = abs(dist (p r) (f r) - (2 ^ k - 1) * dM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n     (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM)) =\n    \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dM\\<bar>", "apply (rule geodesic_segment_param(7)[where ?y = \"f r\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. geodesic_segment_between {p r--f r} (p r) (f r)\n 2. dist (p r) (f r) \\<in> {0..dist (p r) (f r)}\n 3. (2 ^ k - 1) * dM \\<in> {0..dist (p r) (f r)}", "using x(3)[of r] \\<open>r \\<in> {x..v}\\<close> \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> aux"], ["proof (prove)\nusing this:\n  r \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f r) (p r)\n  r \\<in> {x..v}\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n\ngoal (3 subgoals):\n 1. geodesic_segment_between {p r--f r} (p r) (f r)\n 2. dist (p r) (f r) \\<in> {0..dist (p r) (f r)}\n 3. (2 ^ k - 1) * dM \\<in> {0..dist (p r) (f r)}", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n   (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM)) =\n  \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dM\\<bar>\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "also"], ["proof (state)\nthis:\n  dist (geodesic_segment_param {p r--f r} (p r) (dist (p r) (f r)))\n   (geodesic_segment_param {p r--f r} (p r) ((2 ^ k - 1) * dM)) =\n  \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dM\\<bar>\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "have \"... = dist (f r) (p r) - (2 ^ k - 1) * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dM\\<bar> =\n    dist (f r) (p r) - (2 ^ k - 1) * dM", "using x(3)[of r] \\<open>r \\<in> {x..v}\\<close> \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> aux"], ["proof (prove)\nusing this:\n  r \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f r) (p r)\n  r \\<in> {x..v}\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dM\\<bar> =\n    dist (f r) (p r) - (2 ^ k - 1) * dM", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  \\<bar>dist (p r) (f r) - (2 ^ k - 1) * dM\\<bar> =\n  dist (f r) (p r) - (2 ^ k - 1) * dM\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "finally"], ["proof (chain)\npicking this:\n  infdist (f r) (V k) = dist (f r) (p r) - (2 ^ k - 1) * dM", "have \"dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dM\""], ["proof (prove)\nusing this:\n  infdist (f r) (V k) = dist (f r) (p r) - (2 ^ k - 1) * dM\n\ngoal (1 subgoal):\n 1. dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dM", "by simp"], ["proof (state)\nthis:\n  dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dM\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "moreover"], ["proof (state)\nthis:\n  dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dM\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "have \"(2^(k+1) - 1) * dM \\<le> dist (f r) (p r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ (k + 1) - 1) * dM \\<le> dist (f r) (p r)", "apply (rule x(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> {x..uM}", "using \\<open>r \\<in> {x..v}\\<close> \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  r \\<in> {x..v}\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n\ngoal (1 subgoal):\n 1. r \\<in> {x..uM}", "by auto"], ["proof (state)\nthis:\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f r) (p r)\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "ultimately"], ["proof (chain)\npicking this:\n  dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dM\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f r) (p r)", "have \"(2^(k+1) - 1) * dM \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dM\""], ["proof (prove)\nusing this:\n  dist (f r) (p r) = infdist (f r) (V k) + (2 ^ k - 1) * dM\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f r) (p r)\n\ngoal (1 subgoal):\n 1. (2 ^ (k + 1) - 1) * dM \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dM", "by simp"], ["proof (state)\nthis:\n  (2 ^ (k + 1) - 1) * dM \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dM\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "then"], ["proof (chain)\npicking this:\n  (2 ^ (k + 1) - 1) * dM \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dM", "show ?thesis"], ["proof (prove)\nusing this:\n  (2 ^ (k + 1) - 1) * dM \\<le> infdist (f r) (V k) + (2 ^ k - 1) * dM\n\ngoal (1 subgoal):\n 1. dM * 2 ^ k \\<le> infdist (f r) (V k)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  dM * 2 ^ k \\<le> infdist (f r) (V k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?r \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f ?r) (V k)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"infdist (f v) H \\<le> (2^(k+2)-1) * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f v) H \\<le> (2 ^ (k + 2) - 1) * dM", "using v proj_setD(2)[OF p[of v]]"], ["proof (prove)\nusing this:\n  v \\<in> {w..uM}\n  dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM\n  dist (f v) (p v) = infdist (f v) H\n\ngoal (1 subgoal):\n 1. infdist (f v) H \\<le> (2 ^ (k + 2) - 1) * dM", "by auto"], ["proof (state)\nthis:\n  infdist (f v) H \\<le> (2 ^ (k + 2) - 1) * dM\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"dist closestm v \\<le> lambda * (infdist (f closestm) H + (L + C + 2 * delta) + infdist (f v) H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist closestm v\n    \\<le> lambda *\n          (infdist (f closestm) H + (L + C + 2 * delta) + infdist (f v) H)", "apply (rule D)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closestm \\<in> {um..ym}\n 2. v \\<in> {yM..uM}", "using \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> \\<open>x \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close> \\<open>closestm \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>um \\<in> {a..z}\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n  x \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n  closestm \\<in> {um..ym}\n  ym \\<in> {um..z}\n  um \\<in> {a..z}\n\ngoal (2 subgoals):\n 1. closestm \\<in> {um..ym}\n 2. v \\<in> {yM..uM}", "by auto"], ["proof (state)\nthis:\n  dist closestm v\n  \\<le> lambda *\n        (infdist (f closestm) H + (L + C + 2 * delta) + infdist (f v) H)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  dist closestm v\n  \\<le> lambda *\n        (infdist (f closestm) H + (L + C + 2 * delta) + infdist (f v) H)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> lambda * (dm + 1 * (L + C + 2 * delta) + (2^(k+2)-1) * dM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    (infdist (f closestm) H + (L + C + 2 * delta) + infdist (f v) H)\n    \\<le> lambda * (dm + 1 * (L + C + 2 * delta) + (2 ^ (k + 2) - 1) * dM)", "apply (intro mono_intros \\<open>infdist (f v) H \\<le> (2^(k+2)-1) * dM\\<close>)"], ["proof (prove)\ngoal (4 subgoals):\n 1. infdist (f closestm) H \\<le> dm\n 2. 0 \\<le> L + C + 2 * delta\n 3. 1 \\<le> 1\n 4. 0 \\<le> lambda", "using dm_def \\<open>lambda \\<ge> 1\\<close> \\<open>L > 0\\<close> \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  dm = infdist (f closestm) H\n  1 \\<le> lambda\n  0 < L\n  0 \\<le> C\n  0 < delta\n\ngoal (4 subgoals):\n 1. infdist (f closestm) H \\<le> dm\n 2. 0 \\<le> L + C + 2 * delta\n 3. 1 \\<le> 1\n 4. 0 \\<le> lambda", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  lambda * (infdist (f closestm) H + (L + C + 2 * delta) + infdist (f v) H)\n  \\<le> lambda * (dm + 1 * (L + C + 2 * delta) + (2 ^ (k + 2) - 1) * dM)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  lambda * (infdist (f closestm) H + (L + C + 2 * delta) + infdist (f v) H)\n  \\<le> lambda * (dm + 1 * (L + C + 2 * delta) + (2 ^ (k + 2) - 1) * dM)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> lambda * (dM + 2^k * (((L + 2 * delta)/D) * dM) + (2^(k+2)-1) * dM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (dm + 1 * (L + C + 2 * delta) + (2 ^ (k + 2) - 1) * dM)\n    \\<le> lambda *\n          (dM + 2 ^ k * ((L + 2 * delta) / D * dM) + (2 ^ (k + 2) - 1) * dM)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. dm \\<le> dM\n 2. 1 \\<le> 2 ^ k\n 3. L + C + 2 * delta \\<le> (L + 2 * delta) / D * dM\n 4. 0 \\<le> 2 ^ k\n 5. 0 \\<le> L + C + 2 * delta\n 6. 0 \\<le> lambda", "using I \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close> \\<open>delta > 0\\<close> \\<open>L > 0\\<close> aux2"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  1 \\<le> lambda\n  0 \\<le> C\n  0 < delta\n  0 < L\n  L + C + 2 * delta \\<le> (L + 2 * delta) / D * dM\n\ngoal (6 subgoals):\n 1. dm \\<le> dM\n 2. 1 \\<le> 2 ^ k\n 3. L + C + 2 * delta \\<le> (L + 2 * delta) / D * dM\n 4. 0 \\<le> 2 ^ k\n 5. 0 \\<le> L + C + 2 * delta\n 6. 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  lambda * (dm + 1 * (L + C + 2 * delta) + (2 ^ (k + 2) - 1) * dM)\n  \\<le> lambda *\n        (dM + 2 ^ k * ((L + 2 * delta) / D * dM) + (2 ^ (k + 2) - 1) * dM)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  lambda * (dm + 1 * (L + C + 2 * delta) + (2 ^ (k + 2) - 1) * dM)\n  \\<le> lambda *\n        (dM + 2 ^ k * ((L + 2 * delta) / D * dM) + (2 ^ (k + 2) - 1) * dM)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... = lambda * 2^k * (4 + (L + 2 * delta)/D) * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    (dM + 2 ^ k * ((L + 2 * delta) / D * dM) + (2 ^ (k + 2) - 1) * dM) =\n    lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dM", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  lambda *\n  (dM + 2 ^ k * ((L + 2 * delta) / D * dM) + (2 ^ (k + 2) - 1) * dM) =\n  lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dM\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  dist closestm v \\<le> lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dM", "have *: \"dist closestm v / (lambda * (4 + (L + 2 * delta)/D)) \\<le> 2^k * dM\""], ["proof (prove)\nusing this:\n  dist closestm v \\<le> lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dM\n\ngoal (1 subgoal):\n 1. dist closestm v / (lambda * (4 + (L + 2 * delta) / D)) \\<le> 2 ^ k * dM", "using \\<open>lambda \\<ge> 1\\<close> \\<open>L > 0\\<close> \\<open>D > 0\\<close> \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  dist closestm v \\<le> lambda * 2 ^ k * (4 + (L + 2 * delta) / D) * dM\n  1 \\<le> lambda\n  0 < L\n  0 < D\n  0 < delta\n\ngoal (1 subgoal):\n 1. dist closestm v / (lambda * (4 + (L + 2 * delta) / D)) \\<le> 2 ^ k * dM", "by (simp add: divide_simps, simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist closestm v / (lambda * (4 + (L + 2 * delta) / D)) \\<le> 2 ^ k * dM\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"exp(- (alpha * (2^k * dM) * ln 2 / (5 * delta))) \\<le> exp(-(alpha * (dist closestm v / (lambda * (4 + (L + 2 * delta)/D))) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n    \\<le> exp (- (alpha *\n                  (dist closestm v / (lambda * (4 + (L + 2 * delta) / D))) *\n                  ln 2 /\n                  (5 * delta)))", "apply (intro mono_intros *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> alpha\n 2. 1 \\<le> 2\n 3. 0 \\<le> 5 * delta", "using alphaaux \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < alpha\n  alpha \\<le> 1\n  0 < delta\n\ngoal (3 subgoals):\n 1. 0 \\<le> alpha\n 2. 1 \\<le> 2\n 3. 0 \\<le> 5 * delta", "by auto"], ["proof (state)\nthis:\n  exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- (alpha *\n                (dist closestm v / (lambda * (4 + (L + 2 * delta) / D))) *\n                ln 2 /\n                (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- (alpha *\n                (dist closestm v / (lambda * (4 + (L + 2 * delta) / D))) *\n                ln 2 /\n                (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... = exp(-K * dist closestm v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- (alpha *\n            (dist closestm v / (lambda * (4 + (L + 2 * delta) / D))) *\n            ln 2 /\n            (5 * delta))) =\n    exp (- K * dist closestm v)", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- (alpha *\n            (dist closestm v / (lambda * (4 + (L + 2 * delta) / D))) *\n            ln 2 /\n            (5 * delta))) =\n    exp (- (alpha * ln 2 /\n            (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n         dist closestm v)", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  exp (- (alpha * (dist closestm v / (lambda * (4 + (L + 2 * delta) / D))) *\n          ln 2 /\n          (5 * delta))) =\n  exp (- K * dist closestm v)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  exp (- (alpha * (dist closestm v / (lambda * (4 + (L + 2 * delta) / D))) *\n          ln 2 /\n          (5 * delta))) =\n  exp (- K * dist closestm v)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... = exp(-K * (v - closestm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- K * dist closestm v) = exp (- K * (v - closestm))", "unfolding dist_real_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- K * \\<bar>closestm - v\\<bar>) = exp (- K * (v - closestm))", "using \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> \\<open>x \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>closestm \\<in> {um..ym}\\<close> \\<open>K > 0\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n  x \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n  ym \\<in> {um..z}\n  closestm \\<in> {um..ym}\n  0 < K\n\ngoal (1 subgoal):\n 1. exp (- K * \\<bar>closestm - v\\<bar>) = exp (- K * (v - closestm))", "by auto"], ["proof (state)\nthis:\n  exp (- K * dist closestm v) = exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (v - closestm))", "have \"exp(- (alpha * (2^k * dM) * ln 2 / (5 * delta))) \\<le> exp(-K * (v - closestm))\""], ["proof (prove)\nusing this:\n  exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (v - closestm))\n\ngoal (1 subgoal):\n 1. exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n    \\<le> exp (- K * (v - closestm))", "by simp"], ["proof (state)\nthis:\n  exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (v - closestm))", "have \"K * (v - x) * exp(- (alpha * (2^k * dM) * ln 2 / (5 * delta))) \\<le> K * (v - x) * exp(-K * (v - closestm))\""], ["proof (prove)\nusing this:\n  exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (v - closestm))\n\ngoal (1 subgoal):\n 1. K * (v - x) * exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n    \\<le> K * (v - x) * exp (- K * (v - closestm))", "apply (rule mult_left_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> K * (v - x)", "using \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> \\<open>K > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n  1 \\<le> lambda\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n  0 < K\n\ngoal (1 subgoal):\n 1. 0 \\<le> K * (v - x)", "by auto"], ["proof (state)\nthis:\n  K * (v - x) * exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> K * (v - x) * exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  K * (v - x) * exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> K * (v - x) * exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... = ((1 + K * (v - x)) - 1) * exp(- K * (v - closestm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K * (v - x) * exp (- K * (v - closestm)) =\n    (1 + K * (v - x) - 1) * exp (- K * (v - closestm))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  K * (v - x) * exp (- K * (v - closestm)) =\n  (1 + K * (v - x) - 1) * exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  K * (v - x) * exp (- K * (v - closestm)) =\n  (1 + K * (v - x) - 1) * exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> (exp (K * (v - x)) - 1) * exp(-K * (v - closestm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + K * (v - x) - 1) * exp (- K * (v - closestm))\n    \\<le> (exp (K * (v - x)) - 1) * exp (- K * (v - closestm))", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  (1 + K * (v - x) - 1) * exp (- K * (v - closestm))\n  \\<le> (exp (K * (v - x)) - 1) * exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  (1 + K * (v - x) - 1) * exp (- K * (v - closestm))\n  \\<le> (exp (K * (v - x)) - 1) * exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... = exp(-K * (x - closestm)) - exp(-K * (v - closestm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (exp (K * (v - x)) - 1) * exp (- K * (v - closestm)) =\n    exp (- K * (x - closestm)) - exp (- K * (v - closestm))", "by (simp add: algebra_simps mult_exp_exp)"], ["proof (state)\nthis:\n  (exp (K * (v - x)) - 1) * exp (- K * (v - closestm)) =\n  exp (- K * (x - closestm)) - exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  (exp (K * (v - x)) - 1) * exp (- K * (v - closestm)) =\n  exp (- K * (x - closestm)) - exp (- K * (v - closestm))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> exp(-K * (x - closestm)) - exp(-K * (uM - um))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (- K * (x - closestm)) - exp (- K * (v - closestm))\n    \\<le> exp (- K * (x - closestm)) - exp (- K * (uM - um))", "using \\<open>K > 0\\<close> \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> \\<open>x \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>closestm \\<in> {um..ym}\\<close>"], ["proof (prove)\nusing this:\n  0 < K\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n  x \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n  ym \\<in> {um..z}\n  closestm \\<in> {um..ym}\n\ngoal (1 subgoal):\n 1. exp (- K * (x - closestm)) - exp (- K * (v - closestm))\n    \\<le> exp (- K * (x - closestm)) - exp (- K * (uM - um))", "by auto"], ["proof (state)\nthis:\n  exp (- K * (x - closestm)) - exp (- K * (v - closestm))\n  \\<le> exp (- K * (x - closestm)) - exp (- K * (uM - um))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  K * (v - x) * exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (x - closestm)) - exp (- K * (uM - um))", "have B: \"(v - x) * exp(- alpha * 2^k * dM * ln 2 / (5 * delta)) \\<le>\n                                  (exp(-K * (x - closestm)) - exp(-K * (uM - um)))/K\""], ["proof (prove)\nusing this:\n  K * (v - x) * exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (x - closestm)) - exp (- K * (uM - um))\n\ngoal (1 subgoal):\n 1. (v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))\n    \\<le> (exp (- K * (x - closestm)) - exp (- K * (uM - um))) / K", "using \\<open>K > 0\\<close>"], ["proof (prove)\nusing this:\n  K * (v - x) * exp (- (alpha * (2 ^ k * dM) * ln 2 / (5 * delta)))\n  \\<le> exp (- K * (x - closestm)) - exp (- K * (uM - um))\n  0 < K\n\ngoal (1 subgoal):\n 1. (v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))\n    \\<le> (exp (- K * (x - closestm)) - exp (- K * (uM - um))) / K", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  (v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))\n  \\<le> (exp (- K * (x - closestm)) - exp (- K * (uM - um))) / K\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "text \\<open>The projections of $f(v)$ and $f(x)$ on the cylinder $V_k$ are well separated,\n              by construction. This implies that $v$ and $x$ themselves are well separated.\\<close>"], ["proof (state)\nthis:\n  (v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))\n  \\<le> (exp (- K * (x - closestm)) - exp (- K * (uM - um))) / K\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {yM..uM}\n  L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x)\n  ?w \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f ?w) (p ?w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x)", "by simp"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> dist (q k uM) (q k v) + dist (q k v) (q k x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k uM) (q k x) \\<le> dist (q k uM) (q k v) + dist (q k v) (q k x)", "by (intro mono_intros)"], ["proof (state)\nthis:\n  dist (q k uM) (q k x) \\<le> dist (q k uM) (q k v) + dist (q k v) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  dist (q k uM) (q k x) \\<le> dist (q k uM) (q k v) + dist (q k v) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> (9 * delta + 4 * QC k) + dist (q k v) (q k x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k uM) (q k v) + dist (q k v) (q k x)\n    \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)", "using w(3)[of v] \\<open>v \\<in> {w..uM}\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {w..uM} \\<Longrightarrow>\n  dist (q k uM) (q k v) \\<le> 9 * delta + 4 * QC k\n  v \\<in> {w..uM}\n\ngoal (1 subgoal):\n 1. dist (q k uM) (q k v) + dist (q k v) (q k x)\n    \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)", "by auto"], ["proof (state)\nthis:\n  dist (q k uM) (q k v) + dist (q k v) (q k x)\n  \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L - 4 * delta + 7 * QC k \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)", "have \"L - 13 * delta + 3 * QC k \\<le> dist (q k x) (q k v)\""], ["proof (prove)\nusing this:\n  L - 4 * delta + 7 * QC k \\<le> 9 * delta + 4 * QC k + dist (q k v) (q k x)\n\ngoal (1 subgoal):\n 1. L - 13 * delta + 3 * QC k \\<le> dist (q k x) (q k v)", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  L - 13 * delta + 3 * QC k \\<le> dist (q k x) (q k v)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L - 13 * delta + 3 * QC k \\<le> dist (q k x) (q k v)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> 3 * QC k + max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (v - x) * exp(-(dM * 2^k - C/2 - QC k) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "proof (cases \"k = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "case True"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "have \"dist (q k x) (q k v) \\<le> max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (v - x) * exp(-(dM * 2^k - C/2) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k x) (q k v)\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2) * ln 2 / (5 * delta)))", "proof (rule geodesic_projection_exp_contracting[where ?G = \"V k\" and ?f = f])"], ["proof (state)\ngoal (10 subgoals):\n 1. geodesic_segment (V k)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 3. x \\<le> v\n 4. q k x \\<in> proj_set (f x) (V k)\n 5. q k v \\<in> proj_set (f v) (V k)\n 6. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 7. 15 / 2 * delta + C / 2 \\<le> dM * 2 ^ k\n 8. deltaG TYPE('a) < delta\n 9. 0 \\<le> C\n 10. 0 \\<le> lambda", "show \"geodesic_segment (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment (V k)", "unfolding V_def True"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment (\\<Union>g\\<in>H. cball g ((2 ^ 0 - 1) * dM))", "using geodesic_segmentI[OF H]"], ["proof (prove)\nusing this:\n  geodesic_segment H\n\ngoal (1 subgoal):\n 1. geodesic_segment (\\<Union>g\\<in>H. cball g ((2 ^ 0 - 1) * dM))", "by auto"], ["proof (state)\nthis:\n  geodesic_segment (V k)\n\ngoal (9 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. x \\<le> v\n 3. q k x \\<in> proj_set (f x) (V k)\n 4. q k v \\<in> proj_set (f v) (V k)\n 5. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 6. 15 / 2 * delta + C / 2 \\<le> dM * 2 ^ k\n 7. deltaG TYPE('a) < delta\n 8. 0 \\<le> C\n 9. 0 \\<le> lambda", "show \"x \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> v", "using \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n\ngoal (1 subgoal):\n 1. x \\<le> v", "by auto"], ["proof (state)\nthis:\n  x \\<le> v\n\ngoal (8 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. q k x \\<in> proj_set (f x) (V k)\n 3. q k v \\<in> proj_set (f v) (V k)\n 4. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 5. 15 / 2 * delta + C / 2 \\<le> dM * 2 ^ k\n 6. deltaG TYPE('a) < delta\n 7. 0 \\<le> C\n 8. 0 \\<le> lambda", "show \"q k v \\<in> proj_set (f v) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k v \\<in> proj_set (f v) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p v--f v} (p v) ((2 ^ k - 1) * dM)\n    \\<in> proj_set (f v) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p v \\<in> proj_set (f v) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p v) (f v)\n 4. geodesic_segment_between {p v--f v} (p v) (f v)", "using aux p[of v] x(3)[of v] \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n  p v \\<in> proj_set (f v) H\n  v \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f v) (p v)\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n\ngoal (4 subgoals):\n 1. p v \\<in> proj_set (f v) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p v) (f v)\n 4. geodesic_segment_between {p v--f v} (p v) (f v)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k v \\<in> proj_set (f v) (V k)\n\ngoal (7 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. q k x \\<in> proj_set (f x) (V k)\n 3. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 4. 15 / 2 * delta + C / 2 \\<le> dM * 2 ^ k\n 5. deltaG TYPE('a) < delta\n 6. 0 \\<le> C\n 7. 0 \\<le> lambda", "show \"q k x \\<in> proj_set (f x) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k x \\<in> proj_set (f x) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p x--f x} (p x) ((2 ^ k - 1) * dM)\n    \\<in> proj_set (f x) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p x \\<in> proj_set (f x) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p x) (f x)\n 4. geodesic_segment_between {p x--f x} (p x) (f x)", "using aux p[of x] x(3)[of x] \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n  p x \\<in> proj_set (f x) H\n  x \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f x) (p x)\n  w \\<in> {x..uM}\n\ngoal (4 subgoals):\n 1. p x \\<in> proj_set (f x) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p x) (f x)\n 4. geodesic_segment_between {p x--f x} (p x) (f x)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k x \\<in> proj_set (f x) (V k)\n\ngoal (6 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 3. 15 / 2 * delta + C / 2 \\<le> dM * 2 ^ k\n 4. deltaG TYPE('a) < delta\n 5. 0 \\<le> C\n 6. 0 \\<le> lambda", "show \"15/2 * delta + C/2 \\<le> dM * 2^k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 15 / 2 * delta + C / 2 \\<le> dM * 2 ^ k", "using I \\<open>delta > 0\\<close> \\<open>C \\<ge> 0\\<close> Laux"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. 15 / 2 * delta + C / 2 \\<le> dM * 2 ^ k", "unfolding QC_def True"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. 15 / 2 * delta + C / 2 \\<le> dM * 2 ^ 0", "by auto"], ["proof (state)\nthis:\n  15 / 2 * delta + C / 2 \\<le> dM * 2 ^ k\n\ngoal (5 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 3. deltaG TYPE('a) < delta\n 4. 0 \\<le> C\n 5. 0 \\<le> lambda", "show \"deltaG TYPE('a) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) < delta", "by fact"], ["proof (state)\nthis:\n  deltaG TYPE('a) < delta\n\ngoal (4 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 3. 0 \\<le> C\n 4. 0 \\<le> lambda", "show \"\\<And>t. t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)", "using aux4"], ["proof (prove)\nusing this:\n  ?r \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f ?r) (V k)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)", "by auto"], ["proof (state)\nthis:\n  ?t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f ?t) (V k)\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. 0 \\<le> C\n 3. 0 \\<le> lambda", "show \"0 \\<le> C\" \"0 \\<le> lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 0 \\<le> lambda", "using \\<open>C \\<ge> 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  0 \\<le> C\n  0 \\<le> lambda\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C", "show \"dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C\" if \"x1 \\<in> {x..v}\" \"x2 \\<in> {x..v}\" for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C", "using quasi_isometry_onD(1)[OF assms(2)] that \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> \\<open>x \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  x1 \\<in> {x..v}\n  x2 \\<in> {x..v}\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n  x \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x1.0 \\<in> {x..v}; ?x2.0 \\<in> {x..v}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x1.0) (f ?x2.0)\n                    \\<le> lambda * dist ?x1.0 ?x2.0 + C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist (q k x) (q k v)\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2) * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n 2. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  dist (q k x) (q k v)\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2) * ln 2 / (5 * delta)))", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (q k x) (q k v)\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "unfolding QC_def True"], ["proof (prove)\nusing this:\n  dist (q 0 x) (q 0 v)\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ 0 - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist (q 0 x) (q 0 v)\n    \\<le> 3 * (if 0 = 0 then 0 else 8 * delta) +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ 0 - C / 2 - (if 0 = 0 then 0 else 8 * delta)) *\n                 ln 2 /\n                 (5 * delta)))", "by auto"], ["proof (state)\nthis:\n  dist (q k x) (q k v)\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "case False"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "have \"dist (q k x) (q k v) \\<le> 2 * QC k + 8 * delta + max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (v - x) * exp(-(dM * 2^k - QC k - C/2) * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k x) (q k v)\n    \\<le> 2 * QC k + 8 * delta +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - QC k - C / 2) * ln 2 / (5 * delta)))", "proof (rule quasiconvex_projection_exp_contracting[where ?G = \"V k\" and ?f = f])"], ["proof (state)\ngoal (10 subgoals):\n 1. quasiconvex (QC k) (V k)\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 3. x \\<le> v\n 4. q k x \\<in> proj_set (f x) (V k)\n 5. q k v \\<in> proj_set (f v) (V k)\n 6. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 7. 15 / 2 * delta + QC k + C / 2 \\<le> dM * 2 ^ k\n 8. deltaG TYPE('a) < delta\n 9. 0 \\<le> C\n 10. 0 \\<le> lambda", "show \"quasiconvex (QC k) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quasiconvex (QC k) (V k)", "by fact"], ["proof (state)\nthis:\n  quasiconvex (QC k) (V k)\n\ngoal (9 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. x \\<le> v\n 3. q k x \\<in> proj_set (f x) (V k)\n 4. q k v \\<in> proj_set (f v) (V k)\n 5. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 6. 15 / 2 * delta + QC k + C / 2 \\<le> dM * 2 ^ k\n 7. deltaG TYPE('a) < delta\n 8. 0 \\<le> C\n 9. 0 \\<le> lambda", "show \"x \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> v", "using \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n\ngoal (1 subgoal):\n 1. x \\<le> v", "by auto"], ["proof (state)\nthis:\n  x \\<le> v\n\ngoal (8 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. q k x \\<in> proj_set (f x) (V k)\n 3. q k v \\<in> proj_set (f v) (V k)\n 4. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 5. 15 / 2 * delta + QC k + C / 2 \\<le> dM * 2 ^ k\n 6. deltaG TYPE('a) < delta\n 7. 0 \\<le> C\n 8. 0 \\<le> lambda", "show \"q k v \\<in> proj_set (f v) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k v \\<in> proj_set (f v) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p v--f v} (p v) ((2 ^ k - 1) * dM)\n    \\<in> proj_set (f v) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p v \\<in> proj_set (f v) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p v) (f v)\n 4. geodesic_segment_between {p v--f v} (p v) (f v)", "using aux p[of v] x(3)[of v] \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n  p v \\<in> proj_set (f v) H\n  v \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f v) (p v)\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n\ngoal (4 subgoals):\n 1. p v \\<in> proj_set (f v) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p v) (f v)\n 4. geodesic_segment_between {p v--f v} (p v) (f v)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k v \\<in> proj_set (f v) (V k)\n\ngoal (7 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. q k x \\<in> proj_set (f x) (V k)\n 3. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 4. 15 / 2 * delta + QC k + C / 2 \\<le> dM * 2 ^ k\n 5. deltaG TYPE('a) < delta\n 6. 0 \\<le> C\n 7. 0 \\<le> lambda", "show \"q k x \\<in> proj_set (f x) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k x \\<in> proj_set (f x) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p x--f x} (p x) ((2 ^ k - 1) * dM)\n    \\<in> proj_set (f x) (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))", "apply (rule proj_set_thickening)"], ["proof (prove)\ngoal (4 subgoals):\n 1. p x \\<in> proj_set (f x) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p x) (f x)\n 4. geodesic_segment_between {p x--f x} (p x) (f x)", "using aux p[of x] x(3)[of x] \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n  p x \\<in> proj_set (f x) H\n  x \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f x) (p x)\n  w \\<in> {x..uM}\n\ngoal (4 subgoals):\n 1. p x \\<in> proj_set (f x) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> dist (p x) (f x)\n 4. geodesic_segment_between {p x--f x} (p x) (f x)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k x \\<in> proj_set (f x) (V k)\n\ngoal (6 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 3. 15 / 2 * delta + QC k + C / 2 \\<le> dM * 2 ^ k\n 4. deltaG TYPE('a) < delta\n 5. 0 \\<le> C\n 6. 0 \\<le> lambda", "show \"15/2 * delta + QC k + C/2 \\<le> dM * 2^k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 15 / 2 * delta + QC k + C / 2 \\<le> dM * 2 ^ k", "apply (rule order_trans[of _ dM])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 15 / 2 * delta + QC k + C / 2 \\<le> dM\n 2. dM \\<le> dM * 2 ^ k", "using I \\<open>delta > 0\\<close> \\<open>C \\<ge> 0\\<close> Laux"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (2 subgoals):\n 1. 15 / 2 * delta + QC k + C / 2 \\<le> dM\n 2. dM \\<le> dM * 2 ^ k", "unfolding QC_def"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (2 subgoals):\n 1. 15 / 2 * delta + (if k = 0 then 0 else 8 * delta) + C / 2 \\<le> dM\n 2. dM \\<le> dM * 2 ^ k", "by auto"], ["proof (state)\nthis:\n  15 / 2 * delta + QC k + C / 2 \\<le> dM * 2 ^ k\n\ngoal (5 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 3. deltaG TYPE('a) < delta\n 4. 0 \\<le> C\n 5. 0 \\<le> lambda", "show \"deltaG TYPE('a) < delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) < delta", "by fact"], ["proof (state)\nthis:\n  deltaG TYPE('a) < delta\n\ngoal (4 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\n 3. 0 \\<le> C\n 4. 0 \\<le> lambda", "show \"\\<And>t. t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)", "using aux4"], ["proof (prove)\nusing this:\n  ?r \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f ?r) (V k)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f t) (V k)", "by auto"], ["proof (state)\nthis:\n  ?t \\<in> {x..v} \\<Longrightarrow> dM * 2 ^ k \\<le> infdist (f ?t) (V k)\n\ngoal (3 subgoals):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C\n 2. 0 \\<le> C\n 3. 0 \\<le> lambda", "show \"0 \\<le> C\" \"0 \\<le> lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 0 \\<le> lambda", "using \\<open>C \\<ge> 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  0 \\<le> C\n  0 \\<le> lambda\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> {x..v}; y \\<in> {x..v}\\<rbrakk>\n       \\<Longrightarrow> dist (f xa) (f y) \\<le> lambda * dist xa y + C", "show \"dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C\" if \"x1 \\<in> {x..v}\" \"x2 \\<in> {x..v}\" for x1 x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C", "using quasi_isometry_onD(1)[OF assms(2)] that \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> \\<open>x \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>z \\<in> {a..b}\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  x1 \\<in> {x..v}\n  x2 \\<in> {x..v}\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n  x \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n  uM \\<in> {z..b}\n  z \\<in> {a..b}\n\ngoal (1 subgoal):\n 1. dist (f x1) (f x2) \\<le> lambda * dist x1 x2 + C", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?x1.0 \\<in> {x..v}; ?x2.0 \\<in> {x..v}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x1.0) (f ?x2.0)\n                    \\<le> lambda * dist ?x1.0 ?x2.0 + C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist (q k x) (q k v)\n  \\<le> 2 * QC k + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - QC k - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. k \\<noteq> 0 \\<Longrightarrow>\n    dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "then"], ["proof (chain)\npicking this:\n  dist (q k x) (q k v)\n  \\<le> 2 * QC k + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - QC k - C / 2) * ln 2 / (5 * delta)))", "show ?thesis"], ["proof (prove)\nusing this:\n  dist (q k x) (q k v)\n  \\<le> 2 * QC k + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - QC k - C / 2) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist (q k x) (q k v)\n    \\<le> 3 * QC k +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "unfolding QC_def"], ["proof (prove)\nusing this:\n  dist (q k x) (q k v)\n  \\<le> 2 * (if k = 0 then 0 else 8 * delta) + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - (if k = 0 then 0 else 8 * delta) - C / 2) *\n               ln 2 /\n               (5 * delta)))\n\ngoal (1 subgoal):\n 1. dist (q k x) (q k v)\n    \\<le> 3 * (if k = 0 then 0 else 8 * delta) +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - (if k = 0 then 0 else 8 * delta)) *\n                 ln 2 /\n                 (5 * delta)))", "using False"], ["proof (prove)\nusing this:\n  dist (q k x) (q k v)\n  \\<le> 2 * (if k = 0 then 0 else 8 * delta) + 8 * delta +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - (if k = 0 then 0 else 8 * delta) - C / 2) *\n               ln 2 /\n               (5 * delta)))\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dist (q k x) (q k v)\n    \\<le> 3 * (if k = 0 then 0 else 8 * delta) +\n          max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - (if k = 0 then 0 else 8 * delta)) *\n                 ln 2 /\n                 (5 * delta)))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist (q k x) (q k v)\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dist (q k x) (q k v)\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L - 13 * delta + 3 * QC k\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "have \"L - 13 * delta \\<le> max (5 * deltaG(TYPE('a))) ((4 * exp(1/2 * ln 2)) * lambda * (v - x) * exp(-(dM * 2^k - C/2 - QC k) * ln 2 / (5 * delta)))\""], ["proof (prove)\nusing this:\n  L - 13 * delta + 3 * QC k\n  \\<le> 3 * QC k +\n        max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. L - 13 * delta\n    \\<le> max (5 * deltaG TYPE('a))\n           (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n            exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "by auto"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  L - 13 * delta\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))", "have \"L - 13 * delta \\<le> (4 * exp(1/2 * ln 2)) * lambda * (v - x) * exp(-(dM * 2^k - C/2 - QC k) * ln 2 / (5 * delta))\""], ["proof (prove)\nusing this:\n  L - 13 * delta\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))", "using \\<open>delta > deltaG(TYPE('a))\\<close> Laux"], ["proof (prove)\nusing this:\n  L - 13 * delta\n  \\<le> max (5 * deltaG TYPE('a))\n         (4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta)))\n  deltaG TYPE('a) < delta\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))", "by auto"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n        exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n        exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> (4 * exp(1/2 * ln 2)) * lambda * (v - x) * exp(-((1-alpha) * D + alpha * 2^k * dM) * ln 2 / (5 * delta))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n    exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n          exp (- ((1 - alpha) * D + alpha * 2 ^ k * dM) * ln 2 /\n               (5 * delta))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k\n 2. 1 \\<le> 2\n 3. 0 \\<le> 5 * delta\n 4. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x)", "using aux3 \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k\n  0 < delta\n  1 \\<le> lambda\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n\ngoal (4 subgoals):\n 1. (1 - alpha) * D + alpha * 2 ^ k * dM \\<le> dM * 2 ^ k - C / 2 - QC k\n 2. 1 \\<le> 2\n 3. 0 \\<le> 5 * delta\n 4. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x)", "by auto"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n  exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n        exp (- ((1 - alpha) * D + alpha * 2 ^ k * dM) * ln 2 / (5 * delta))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n  exp (- (dM * 2 ^ k - C / 2 - QC k) * ln 2 / (5 * delta))\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n        exp (- ((1 - alpha) * D + alpha * 2 ^ k * dM) * ln 2 / (5 * delta))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... = (4 * exp(1/2 * ln 2)) * lambda * (v - x) * (exp(-(1-alpha) * D * ln 2 / (5 * delta)) * exp(-alpha * 2^k * dM * ln 2 / (5 * delta)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n    exp (- ((1 - alpha) * D + alpha * 2 ^ k * dM) * ln 2 / (5 * delta)) =\n    4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n    (exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n     exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))", "unfolding mult_exp_exp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n    exp (- ((1 - alpha) * D + alpha * 2 ^ k * dM) * ln 2 / (5 * delta)) =\n    4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n    exp (- (1 - alpha) * D * ln 2 / (5 * delta) +\n         - alpha * 2 ^ k * dM * ln 2 / (5 * delta))", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n  exp (- ((1 - alpha) * D + alpha * 2 ^ k * dM) * ln 2 / (5 * delta)) =\n  4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n  (exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n   exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n        (exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))", "have A: \"L - 13 * delta \\<le> (4 * exp(1/2 * ln 2)) * lambda * exp(-(1-alpha) * D * ln 2 / (5 * delta)) * ((v - x) * exp(-alpha * 2^k * dM * ln 2 / (5 * delta)))\""], ["proof (prove)\nusing this:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * (v - x) *\n        (exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n\ngoal (1 subgoal):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n          exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n          ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n        exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n        ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n        exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n        ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> (4 * exp(1/2 * ln 2)) * lambda * exp 0 * ((v - x) * exp 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda *\n    exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n    ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((v - x) * exp 0)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. - (1 - alpha) * D * ln 2 / (5 * delta) \\<le> 0\n 2. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda\n 3. - alpha * 2 ^ k * dM * ln 2 / (5 * delta) \\<le> 0\n 4. 0 \\<le> v - x\n 5. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0\n 6. 0 \\<le> (v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))", "using \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> alphaaux \\<open>D > 0\\<close> \\<open>C \\<ge> 0\\<close> I"], ["proof (prove)\nusing this:\n  0 < delta\n  1 \\<le> lambda\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n  0 < alpha\n  alpha \\<le> 1\n  0 < D\n  0 \\<le> C\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n\ngoal (6 subgoals):\n 1. - (1 - alpha) * D * ln 2 / (5 * delta) \\<le> 0\n 2. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda\n 3. - alpha * 2 ^ k * dM * ln 2 / (5 * delta) \\<le> 0\n 4. 0 \\<le> v - x\n 5. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0\n 6. 0 \\<le> (v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))", "by (auto simp add: divide_simps mult_nonpos_nonneg)"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda *\n  exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n  ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((v - x) * exp 0)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda *\n  exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n  ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((v - x) * exp 0)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... = (4 * exp(1/2 * ln 2)) * lambda * (v - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((v - x) * exp 0) =\n    4 * exp (1 / 2 * ln 2) * lambda * (v - x)", "by simp"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((v - x) * exp 0) =\n  4 * exp (1 / 2 * ln 2) * lambda * (v - x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * exp 0 * ((v - x) * exp 0) =\n  4 * exp (1 / 2 * ln 2) * lambda * (v - x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> 20 * lambda * (v - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * exp (1 / 2 * ln 2) * lambda * (v - x) \\<le> 20 * lambda * (v - x)", "apply (intro mono_intros, approximation 10)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> lambda\n 2. 0 \\<le> v - x", "using \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>v \\<in> {w..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n  1 \\<le> lambda\n  v \\<in> {w..uM}\n  w \\<in> {x..uM}\n\ngoal (2 subgoals):\n 1. 0 \\<le> lambda\n 2. 0 \\<le> v - x", "by auto"], ["proof (state)\nthis:\n  4 * exp (1 / 2 * ln 2) * lambda * (v - x) \\<le> 20 * lambda * (v - x)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L - 13 * delta \\<le> 20 * lambda * (v - x)", "have \"v - x \\<ge> (1/4) * delta / lambda\""], ["proof (prove)\nusing this:\n  L - 13 * delta \\<le> 20 * lambda * (v - x)\n\ngoal (1 subgoal):\n 1. 1 / 4 * delta / lambda \\<le> v - x", "using \\<open>lambda \\<ge> 1\\<close> L_def \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  L - 13 * delta \\<le> 20 * lambda * (v - x)\n  1 \\<le> lambda\n  L = 18 * delta\n  0 < delta\n\ngoal (1 subgoal):\n 1. 1 / 4 * delta / lambda \\<le> v - x", "by (simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  1 / 4 * delta / lambda \\<le> v - x\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  1 / 4 * delta / lambda \\<le> v - x", "have \"x - closestm + (1/4) * delta / lambda \\<le> v - closestm\""], ["proof (prove)\nusing this:\n  1 / 4 * delta / lambda \\<le> v - x\n\ngoal (1 subgoal):\n 1. x - closestm + 1 / 4 * delta / lambda \\<le> v - closestm", "by simp"], ["proof (state)\nthis:\n  x - closestm + 1 / 4 * delta / lambda \\<le> v - closestm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  x - closestm + 1 / 4 * delta / lambda \\<le> v - closestm\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> uM - um\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v - closestm \\<le> uM - um", "using \\<open>closestm \\<in> {um..ym}\\<close> \\<open>v \\<in> {w..uM}\\<close>"], ["proof (prove)\nusing this:\n  closestm \\<in> {um..ym}\n  v \\<in> {w..uM}\n\ngoal (1 subgoal):\n 1. v - closestm \\<le> uM - um", "by auto"], ["proof (state)\nthis:\n  v - closestm \\<le> uM - um\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  v - closestm \\<le> uM - um\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> Suc n * (1/4) * delta / lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda", "by fact"], ["proof (state)\nthis:\n  uM - um \\<le> real (Suc n) * (1 / 4) * delta / lambda\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  x - closestm + 1 / 4 * delta / lambda\n  \\<le> real (Suc n) * (1 / 4) * delta / lambda", "have \"x - closestm \\<le> n * (1/4) * delta / lambda\""], ["proof (prove)\nusing this:\n  x - closestm + 1 / 4 * delta / lambda\n  \\<le> real (Suc n) * (1 / 4) * delta / lambda\n\ngoal (1 subgoal):\n 1. x - closestm \\<le> real n * (1 / 4) * delta / lambda", "unfolding Suc_eq_plus1"], ["proof (prove)\nusing this:\n  x - closestm + 1 / 4 * delta / lambda\n  \\<le> real (n + 1) * (1 / 4) * delta / lambda\n\ngoal (1 subgoal):\n 1. x - closestm \\<le> real n * (1 / 4) * delta / lambda", "by (auto simp add: algebra_simps add_divide_distrib)"], ["proof (state)\nthis:\n  x - closestm \\<le> real n * (1 / 4) * delta / lambda\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"L + 4 * delta = ((L + 4 * delta)/(L - 13 * delta)) * (L - 13 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L + 4 * delta = (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)", "using Laux \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < delta\n\ngoal (1 subgoal):\n 1. L + 4 * delta = (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)", "by (simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  L + 4 * delta = (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  L + 4 * delta = (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> ((L + 4 * delta)/(L - 13 * delta)) * ((4 * exp(1/2 * ln 2)) * lambda * exp (- (1 - alpha) * D * ln 2 / (5 * delta)) * ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n    \\<le> (L + 4 * delta) / (L - 13 * delta) *\n          (4 * exp (1 / 2 * ln 2) * lambda *\n           exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n           ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))))", "apply (rule mult_left_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n          exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n          ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n 2. 0 \\<le> (L + 4 * delta) / (L - 13 * delta)", "using A Laux \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  L - 13 * delta\n  \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n        exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n        ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < delta\n\ngoal (2 subgoals):\n 1. L - 13 * delta\n    \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n          exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n          ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta)))\n 2. 0 \\<le> (L + 4 * delta) / (L - 13 * delta)", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  (L + 4 * delta) / (L - 13 * delta) * (L - 13 * delta)\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> ((L + 4 * delta)/(L - 13 * delta)) * ((4 * exp(1/2 * ln 2)) * lambda * exp (- (1 - alpha) * D * ln 2 / (5 * delta)) * ((exp(-K * (x - closestm)) - exp(-K * (uM - um)))/K))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (L + 4 * delta) / (L - 13 * delta) *\n    (4 * exp (1 / 2 * ln 2) * lambda *\n     exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n     ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))))\n    \\<le> (L + 4 * delta) / (L - 13 * delta) *\n          (4 * exp (1 / 2 * ln 2) * lambda *\n           exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n           ((exp (- K * (x - closestm)) - exp (- K * (uM - um))) / K))", "apply (intro mono_intros B)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n            exp (- (1 - alpha) * D * ln 2 / (5 * delta))\n 2. 0 \\<le> (L + 4 * delta) / (L - 13 * delta)", "using Laux \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  0 < delta\n  1 \\<le> lambda\n\ngoal (2 subgoals):\n 1. 0 \\<le> 4 * exp (1 / 2 * ln 2) * lambda *\n            exp (- (1 - alpha) * D * ln 2 / (5 * delta))\n 2. 0 \\<le> (L + 4 * delta) / (L - 13 * delta)", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  (L + 4 * delta) / (L - 13 * delta) *\n  (4 * exp (1 / 2 * ln 2) * lambda *\n   exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n   ((v - x) * exp (- alpha * 2 ^ k * dM * ln 2 / (5 * delta))))\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((exp (- K * (x - closestm)) - exp (- K * (uM - um))) / K))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  L + 4 * delta\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((exp (- K * (x - closestm)) - exp (- K * (uM - um))) / K))", "have C: \"L + 4 * delta \\<le> Kmult * (exp(-K * (x - closestm)) - exp(-K * (uM - um)))\""], ["proof (prove)\nusing this:\n  L + 4 * delta\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((exp (- K * (x - closestm)) - exp (- K * (uM - um))) / K))\n\ngoal (1 subgoal):\n 1. L + 4 * delta\n    \\<le> Kmult * (exp (- K * (x - closestm)) - exp (- K * (uM - um)))", "unfolding Kmult_def"], ["proof (prove)\nusing this:\n  L + 4 * delta\n  \\<le> (L + 4 * delta) / (L - 13 * delta) *\n        (4 * exp (1 / 2 * ln 2) * lambda *\n         exp (- (1 - alpha) * D * ln 2 / (5 * delta)) *\n         ((exp (- K * (x - closestm)) - exp (- K * (uM - um))) / K))\n\ngoal (1 subgoal):\n 1. L + 4 * delta\n    \\<le> (L + 4 * delta) / (L - 13 * delta) *\n          (4 * exp (1 / 2 * ln 2) * lambda *\n           exp (- (1 - alpha) * D * ln 2 / (5 * delta)) /\n           K) *\n          (exp (- K * (x - closestm)) - exp (- K * (uM - um)))", "by argo"], ["proof (state)\nthis:\n  L + 4 * delta\n  \\<le> Kmult * (exp (- K * (x - closestm)) - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"Gromov_product_at (f z) (f um) (f uM) \\<le> Gromov_product_at (f z) (f closestm) (f x) + (L + 4 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> Gromov_product_at (f z) (f closestm) (f x) + (L + 4 * delta)", "apply (rule Rec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closestm \\<in> {um..ym}\n 2. x \\<in> {yM..uM}", "using \\<open>closestm \\<in> {um..ym}\\<close> \\<open>x \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close>"], ["proof (prove)\nusing this:\n  closestm \\<in> {um..ym}\n  x \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n\ngoal (2 subgoals):\n 1. closestm \\<in> {um..ym}\n 2. x \\<in> {yM..uM}", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> Gromov_product_at (f z) (f closestm) (f x) + (L + 4 * delta)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> Gromov_product_at (f z) (f closestm) (f x) + (L + 4 * delta)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... \\<le> (lambda^2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(- K * (x - closestm)))) + (Kmult * (exp(-K * (x - closestm)) - exp(-K * (uM-um))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f closestm) (f x) + (L + 4 * delta)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (x - closestm))) +\n          Kmult * (exp (- K * (x - closestm)) - exp (- K * (uM - um)))", "apply (intro mono_intros C Suc.IH)"], ["proof (prove)\ngoal (3 subgoals):\n 1. closestm \\<in> {a..z}\n 2. x \\<in> {z..b}\n 3. x - closestm \\<le> real n * (1 / 4) * delta / lambda", "using \\<open>x \\<in> {yM..uM}\\<close> \\<open>yM \\<in> {z..uM}\\<close> \\<open>um \\<in> {a..z}\\<close> \\<open>closestm \\<in> {um..ym}\\<close> \\<open>ym \\<in> {um..z}\\<close> \\<open>uM \\<in> {z..b}\\<close> \\<open>x - closestm \\<le> n * (1/4) * delta / lambda\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> {yM..uM}\n  yM \\<in> {z..uM}\n  um \\<in> {a..z}\n  closestm \\<in> {um..ym}\n  ym \\<in> {um..z}\n  uM \\<in> {z..b}\n  x - closestm \\<le> real n * (1 / 4) * delta / lambda\n\ngoal (3 subgoals):\n 1. closestm \\<in> {a..z}\n 2. x \\<in> {z..b}\n 3. x - closestm \\<le> real n * (1 / 4) * delta / lambda", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f closestm) (f x) + (L + 4 * delta)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (x - closestm))) +\n        Kmult * (exp (- K * (x - closestm)) - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "also"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f closestm) (f x) + (L + 4 * delta)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (x - closestm))) +\n        Kmult * (exp (- K * (x - closestm)) - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"... = (lambda^2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(- K * (uM - um))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    Kmult * (1 - exp (- K * (x - closestm))) +\n    Kmult * (exp (- K * (x - closestm)) - exp (- K * (uM - um))) =\n    lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    Kmult * (1 - exp (- K * (uM - um)))", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    Kmult *\n    (1 -\n     exp (- (alpha * ln 2 /\n             (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n          (x - closestm))) +\n    Kmult *\n    (exp (- (alpha * ln 2 /\n             (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n          (x - closestm)) -\n     exp (- (alpha * ln 2 /\n             (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n          (uM - um))) =\n    lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    Kmult *\n    (1 -\n     exp (- (alpha * ln 2 /\n             (5 * (4 + (L + 2 * delta) / D) * delta * lambda)) *\n          (uM - um)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n  Kmult * (1 - exp (- K * (x - closestm))) +\n  Kmult * (exp (- K * (x - closestm)) - exp (- K * (uM - um))) =\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n  Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>{w..uM}.\n       dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n 2. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "finally"], ["proof (chain)\npicking this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>{w..uM}.\n             dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "have \"\\<exists>w\\<in>{yM..uM}. (\\<forall>r\\<in>{w..uM}. (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f r) (p r)) \\<and> L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>w\\<in>{yM..uM}.\n       (\\<forall>r\\<in>{w..uM}.\n           (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f r) (p r)) \\<and>\n       L - 4 * delta + 7 * QC (Suc k)\n       \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "proof (rule bexI[of _ w], auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>w \\<le> r; r \\<le> uM\\<rbrakk>\n       \\<Longrightarrow> (4 * 2 ^ k - 1) * dM \\<le> dist (f r) (p r)\n 2. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)\n 3. yM \\<le> w\n 4. w \\<le> uM", "show \"w \\<le> uM\" \"yM \\<le> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<le> uM &&& yM \\<le> w", "using \\<open>w \\<in> {x..uM}\\<close> \\<open>x \\<in> {yM..uM}\\<close>"], ["proof (prove)\nusing this:\n  w \\<in> {x..uM}\n  x \\<in> {yM..uM}\n\ngoal (1 subgoal):\n 1. w \\<le> uM &&& yM \\<le> w", "by auto"], ["proof (state)\nthis:\n  w \\<le> uM\n  yM \\<le> w\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>w \\<le> r; r \\<le> uM\\<rbrakk>\n       \\<Longrightarrow> (4 * 2 ^ k - 1) * dM \\<le> dist (f r) (p r)\n 2. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "show \"(4 * 2 ^ k - 1) * dM \\<le> dist (f x) (p x)\" if \"x \\<le> uM\" \"w \\<le> x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (4 * 2 ^ k - 1) * dM \\<le> dist (f x) (p x)", "using False \\<open>dM \\<ge> 0\\<close> that"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>{w..uM}.\n             dist (f v) (p v) \\<le> (2 ^ (k + 2) - 1) * dM)\n  0 \\<le> dM\n  x \\<le> uM\n  w \\<le> x\n\ngoal (1 subgoal):\n 1. (4 * 2 ^ k - 1) * dM \\<le> dist (f x) (p x)", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<le> uM; w \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> (4 * 2 ^ k - 1) * dM \\<le> dist (f ?x) (p ?x)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "have \"dist (q k uM) (q (k+1) uM) = 2^k * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k uM) (q (k + 1) uM) = 2 ^ k * dM", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {p uM--f uM} (p uM) ((2 ^ k - 1) * dM))\n     (geodesic_segment_param {p uM--f uM} (p uM) ((2 ^ (k + 1) - 1) * dM)) =\n    2 ^ k * dM", "apply (subst geodesic_segment_param(7)[where ?y = \"f uM\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. geodesic_segment_between {p uM--f uM} (p uM) (f uM)\n 2. (2 ^ k - 1) * dM \\<in> {0..dist (p uM) (f uM)}\n 3. (2 ^ (k + 1) - 1) * dM \\<in> {0..dist (p uM) (f uM)}\n 4. \\<bar>(2 ^ k - 1) * dM - (2 ^ (k + 1) - 1) * dM\\<bar> = 2 ^ k * dM", "using x(3)[of uM] \\<open>x \\<in> {yM..uM}\\<close> aux"], ["proof (prove)\nusing this:\n  uM \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f uM) (p uM)\n  x \\<in> {yM..uM}\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n\ngoal (4 subgoals):\n 1. geodesic_segment_between {p uM--f uM} (p uM) (f uM)\n 2. (2 ^ k - 1) * dM \\<in> {0..dist (p uM) (f uM)}\n 3. (2 ^ (k + 1) - 1) * dM \\<in> {0..dist (p uM) (f uM)}\n 4. \\<bar>(2 ^ k - 1) * dM - (2 ^ (k + 1) - 1) * dM\\<bar> = 2 ^ k * dM", "by (auto simp add: metric_space_class.dist_commute, simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist (q k uM) (q (k + 1) uM) = 2 ^ k * dM\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "have \"dist (q k w) (q (k+1) w) = 2^k * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k w) (q (k + 1) w) = 2 ^ k * dM", "unfolding q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {p w--f w} (p w) ((2 ^ k - 1) * dM))\n     (geodesic_segment_param {p w--f w} (p w) ((2 ^ (k + 1) - 1) * dM)) =\n    2 ^ k * dM", "apply (subst geodesic_segment_param(7)[where ?y = \"f w\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. geodesic_segment_between {p w--f w} (p w) (f w)\n 2. (2 ^ k - 1) * dM \\<in> {0..dist (p w) (f w)}\n 3. (2 ^ (k + 1) - 1) * dM \\<in> {0..dist (p w) (f w)}\n 4. \\<bar>(2 ^ k - 1) * dM - (2 ^ (k + 1) - 1) * dM\\<bar> = 2 ^ k * dM", "using x(3)[of w] \\<open>w \\<in> {x..uM}\\<close> \\<open>x \\<in> {yM..uM}\\<close> aux"], ["proof (prove)\nusing this:\n  w \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f w) (p w)\n  w \\<in> {x..uM}\n  x \\<in> {yM..uM}\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n\ngoal (4 subgoals):\n 1. geodesic_segment_between {p w--f w} (p w) (f w)\n 2. (2 ^ k - 1) * dM \\<in> {0..dist (p w) (f w)}\n 3. (2 ^ (k + 1) - 1) * dM \\<in> {0..dist (p w) (f w)}\n 4. \\<bar>(2 ^ k - 1) * dM - (2 ^ (k + 1) - 1) * dM\\<bar> = 2 ^ k * dM", "by (auto simp add: metric_space_class.dist_commute, simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist (q k w) (q (k + 1) w) = 2 ^ k * dM\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "have i: \"q k uM \\<in> proj_set (q (k+1) uM) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k uM \\<in> proj_set (q (k + 1) uM) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p uM--f uM} (p uM) ((2 ^ k - 1) * dM)\n    \\<in> proj_set\n           (geodesic_segment_param {p uM--f uM} (p uM)\n             ((2 ^ (k + 1) - 1) * dM))\n           (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))", "apply (rule proj_set_thickening'[of _ \"f uM\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. p uM \\<in> proj_set (f uM) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> (2 ^ (k + 1) - 1) * dM\n 4. (2 ^ (k + 1) - 1) * dM \\<le> dist (p uM) (f uM)\n 5. geodesic_segment_between {p uM--f uM} (p uM) (f uM)", "using p x(3)[of uM] \\<open>x \\<in> {yM..uM}\\<close> aux"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n  uM \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f uM) (p uM)\n  x \\<in> {yM..uM}\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n\ngoal (5 subgoals):\n 1. p uM \\<in> proj_set (f uM) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> (2 ^ (k + 1) - 1) * dM\n 4. (2 ^ (k + 1) - 1) * dM \\<le> dist (p uM) (f uM)\n 5. geodesic_segment_between {p uM--f uM} (p uM) (f uM)", "by (auto simp add: algebra_simps metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k uM \\<in> proj_set (q (k + 1) uM) (V k)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "have j: \"q k w \\<in> proj_set (q (k+1) w) (V k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q k w \\<in> proj_set (q (k + 1) w) (V k)", "unfolding q_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {p w--f w} (p w) ((2 ^ k - 1) * dM)\n    \\<in> proj_set\n           (geodesic_segment_param {p w--f w} (p w)\n             ((2 ^ (k + 1) - 1) * dM))\n           (\\<Union>g\\<in>H. cball g ((2 ^ k - 1) * dM))", "apply (rule proj_set_thickening'[of _ \"f w\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. p w \\<in> proj_set (f w) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> (2 ^ (k + 1) - 1) * dM\n 4. (2 ^ (k + 1) - 1) * dM \\<le> dist (p w) (f w)\n 5. geodesic_segment_between {p w--f w} (p w) (f w)", "using p x(3)[of w] \\<open>x \\<in> {yM..uM}\\<close> \\<open>w \\<in> {x..uM}\\<close> aux"], ["proof (prove)\nusing this:\n  p ?x \\<in> proj_set (f ?x) H\n  w \\<in> {x..uM} \\<Longrightarrow>\n  (2 ^ (k + 1) - 1) * dM \\<le> dist (f w) (p w)\n  x \\<in> {yM..uM}\n  w \\<in> {x..uM}\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n\ngoal (5 subgoals):\n 1. p w \\<in> proj_set (f w) H\n 2. 0 \\<le> (2 ^ k - 1) * dM\n 3. (2 ^ k - 1) * dM \\<le> (2 ^ (k + 1) - 1) * dM\n 4. (2 ^ (k + 1) - 1) * dM \\<le> dist (p w) (f w)\n 5. geodesic_segment_between {p w--f w} (p w) (f w)", "by (auto simp add: algebra_simps metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  q k w \\<in> proj_set (q (k + 1) w) (V k)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "have \"5 * delta + 2 * QC k \\<le> dist (q k uM) (q k w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 5 * delta + 2 * QC k \\<le> dist (q k uM) (q k w)", "using w(2)"], ["proof (prove)\nusing this:\n  dist (q k uM) (q k w)\n  \\<in> {9 * delta + 4 * QC k - 4 * delta - 2 * QC k..9 * delta + 4 * QC k}\n\ngoal (1 subgoal):\n 1. 5 * delta + 2 * QC k \\<le> dist (q k uM) (q k w)", "by simp"], ["proof (state)\nthis:\n  5 * delta + 2 * QC k \\<le> dist (q k uM) (q k w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "also"], ["proof (state)\nthis:\n  5 * delta + 2 * QC k \\<le> dist (q k uM) (q k w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "have \"... \\<le> max (5 * deltaG(TYPE('a)) + 2 * QC k)\n                                      (dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) - dist (q k w) (q (k + 1) w) + 10 * deltaG(TYPE('a)) + 4 * QC k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q k uM) (q k w)\n    \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n           (dist (q (k + 1) uM) (q (k + 1) w) -\n            dist (q k uM) (q (k + 1) uM) -\n            dist (q k w) (q (k + 1) w) +\n            10 * deltaG TYPE('a) +\n            4 * QC k)", "by (rule proj_along_quasiconvex_contraction[OF \\<open>quasiconvex (QC k) (V k)\\<close> i j])"], ["proof (state)\nthis:\n  dist (q k uM) (q k w)\n  \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n         (dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "finally"], ["proof (chain)\npicking this:\n  5 * delta + 2 * QC k\n  \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n         (dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k)", "have \"5 * delta + 2 * QC k \\<le> dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) - dist (q k w) (q (k + 1) w) + 10 * deltaG(TYPE('a)) + 4 * QC k\""], ["proof (prove)\nusing this:\n  5 * delta + 2 * QC k\n  \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n         (dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k)\n\ngoal (1 subgoal):\n 1. 5 * delta + 2 * QC k\n    \\<le> dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  5 * delta + 2 * QC k\n  \\<le> max (5 * deltaG TYPE('a) + 2 * QC k)\n         (dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k)\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. 5 * delta + 2 * QC k\n    \\<le> dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n          dist (q k w) (q (k + 1) w) +\n          10 * deltaG TYPE('a) +\n          4 * QC k", "by auto"], ["proof (state)\nthis:\n  5 * delta + 2 * QC k\n  \\<le> dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n        dist (q k w) (q (k + 1) w) +\n        10 * deltaG TYPE('a) +\n        4 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "then"], ["proof (chain)\npicking this:\n  5 * delta + 2 * QC k\n  \\<le> dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n        dist (q k w) (q (k + 1) w) +\n        10 * deltaG TYPE('a) +\n        4 * QC k", "have \"0 \\<le> dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k - dist (q k uM) (q (k + 1) uM) - dist (q k w) (q (k + 1) w)\""], ["proof (prove)\nusing this:\n  5 * delta + 2 * QC k\n  \\<le> dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n        dist (q k w) (q (k + 1) w) +\n        10 * deltaG TYPE('a) +\n        4 * QC k\n\ngoal (1 subgoal):\n 1. 0 \\<le> dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n            dist (q k uM) (q (k + 1) uM) -\n            dist (q k w) (q (k + 1) w)", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  5 * delta + 2 * QC k\n  \\<le> dist (q (k + 1) uM) (q (k + 1) w) - dist (q k uM) (q (k + 1) uM) -\n        dist (q k w) (q (k + 1) w) +\n        10 * deltaG TYPE('a) +\n        4 * QC k\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. 0 \\<le> dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n            dist (q k uM) (q (k + 1) uM) -\n            dist (q k w) (q (k + 1) w)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          dist (q k uM) (q (k + 1) uM) -\n          dist (q k w) (q (k + 1) w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "also"], ["proof (state)\nthis:\n  0 \\<le> dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          dist (q k uM) (q (k + 1) uM) -\n          dist (q k w) (q (k + 1) w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "have \"... = dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k - 2^(k+1) * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n    dist (q k uM) (q (k + 1) uM) -\n    dist (q k w) (q (k + 1) w) =\n    dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n    2 ^ (k + 1) * dM", "by (simp only: \\<open>dist (q k w) (q (k+1) w) = 2^k * dM\\<close> \\<open>dist (q k uM) (q (k+1) uM) = 2^k * dM\\<close>, auto)"], ["proof (state)\nthis:\n  dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n  dist (q k uM) (q (k + 1) uM) -\n  dist (q k w) (q (k + 1) w) =\n  dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n  2 ^ (k + 1) * dM\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          2 ^ (k + 1) * dM", "have *: \"2^(k+1) * dM - 5 * delta - 2 * QC k \\<le> dist (q (k+1) uM) (q (k+1) w)\""], ["proof (prove)\nusing this:\n  0 \\<le> dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          2 ^ (k + 1) * dM\n\ngoal (1 subgoal):\n 1. 2 ^ (k + 1) * dM - 5 * delta - 2 * QC k\n    \\<le> dist (q (k + 1) uM) (q (k + 1) w)", "using \\<open>deltaG(TYPE('a)) < delta\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> dist (q (k + 1) uM) (q (k + 1) w) + 5 * delta + 2 * QC k -\n          2 ^ (k + 1) * dM\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. 2 ^ (k + 1) * dM - 5 * delta - 2 * QC k\n    \\<le> dist (q (k + 1) uM) (q (k + 1) w)", "by auto"], ["proof (state)\nthis:\n  2 ^ (k + 1) * dM - 5 * delta - 2 * QC k\n  \\<le> dist (q (k + 1) uM) (q (k + 1) w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "have \"L - 4 * delta + 7 * QC (k+1) \\<le> 2 * dM - 5 * delta - 2 * QC k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (k + 1) \\<le> 2 * dM - 5 * delta - 2 * QC k", "unfolding QC_def L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 18 * delta - 4 * delta + 7 * (if k + 1 = 0 then 0 else 8 * delta)\n    \\<le> 2 * dM - 5 * delta - 2 * (if k = 0 then 0 else 8 * delta)", "using \\<open>delta > 0\\<close> Laux I \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 18 * delta - 4 * delta + 7 * (if k + 1 = 0 then 0 else 8 * delta)\n    \\<le> 2 * dM - 5 * delta - 2 * (if k = 0 then 0 else 8 * delta)", "by auto"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC (k + 1) \\<le> 2 * dM - 5 * delta - 2 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "also"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC (k + 1) \\<le> 2 * dM - 5 * delta - 2 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "have \"... \\<le> 2^(k+1) * dM - 5 * delta - 2 * QC k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * dM - 5 * delta - 2 * QC k\n    \\<le> 2 ^ (k + 1) * dM - 5 * delta - 2 * QC k", "using aux"], ["proof (prove)\nusing this:\n  (2 ^ k - 1) * dM \\<le> (2 * 2 ^ k - 1) * dM\n  0 \\<le> 2 * 2 ^ k - 1\n  dM \\<le> dM * 2 ^ k\n\ngoal (1 subgoal):\n 1. 2 * dM - 5 * delta - 2 * QC k\n    \\<le> 2 ^ (k + 1) * dM - 5 * delta - 2 * QC k", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  2 * dM - 5 * delta - 2 * QC k\n  \\<le> 2 ^ (k + 1) * dM - 5 * delta - 2 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "finally"], ["proof (chain)\npicking this:\n  L - 4 * delta + 7 * QC (k + 1)\n  \\<le> 2 ^ (k + 1) * dM - 5 * delta - 2 * QC k", "show \"L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)\""], ["proof (prove)\nusing this:\n  L - 4 * delta + 7 * QC (k + 1)\n  \\<le> 2 ^ (k + 1) * dM - 5 * delta - 2 * QC k\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "using *"], ["proof (prove)\nusing this:\n  L - 4 * delta + 7 * QC (k + 1)\n  \\<le> 2 ^ (k + 1) * dM - 5 * delta - 2 * QC k\n  2 ^ (k + 1) * dM - 5 * delta - 2 * QC k\n  \\<le> dist (q (k + 1) uM) (q (k + 1) w)\n\ngoal (1 subgoal):\n 1. L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "by auto"], ["proof (state)\nthis:\n  L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>w\\<in>{yM..uM}.\n     (\\<forall>r\\<in>{w..uM}.\n         (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f r) (p r)) \\<and>\n     L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>{w..uM}.\n               dist (f v) (p v)\n               \\<le> (2 ^ (k + 2) - 1) * dM) \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "then"], ["proof (chain)\npicking this:\n  \\<exists>w\\<in>{yM..uM}.\n     (\\<forall>r\\<in>{w..uM}.\n         (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f r) (p r)) \\<and>\n     L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>w\\<in>{yM..uM}.\n     (\\<forall>r\\<in>{w..uM}.\n         (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f r) (p r)) \\<and>\n     L - 4 * delta + 7 * QC (Suc k) \\<le> dist (q (Suc k) uM) (q (Suc k) w)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um))) \\<or>\n    (\\<exists>x\\<in>{yM..uM}.\n        (\\<forall>y\\<in>{x..uM}.\n            (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n        L - 4 * delta + 7 * QC (Suc k)\n        \\<le> dist (q (Suc k) uM) (q (Suc k) x))", "by simp"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (Suc k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC (Suc k)\n      \\<le> dist (q (Suc k) uM) (q (Suc k) x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (?k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC ?k \\<le> dist (q ?k uM) (q ?k x))\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"dM > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < dM", "using I \\<open>delta > 0\\<close> \\<open>C \\<ge> 0\\<close> Laux"], ["proof (prove)\nusing this:\n  D + 4 * C \\<le> dM\n  dm \\<le> dM\n  0 < delta\n  0 \\<le> C\n  18 * delta \\<le> L\n  50 * delta \\<le> D\n  L \\<le> D\n  D \\<le> 4 * L\n\ngoal (1 subgoal):\n 1. 0 < dM", "by auto"], ["proof (state)\nthis:\n  0 < dM\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"\\<exists>k. 2^k > dist (f uM) (p uM)/dM + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. dist (f uM) (p uM) / dM + 1 < 2 ^ k", "by (simp add: real_arch_pow)"], ["proof (state)\nthis:\n  \\<exists>k. dist (f uM) (p uM) / dM + 1 < 2 ^ k\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>k. dist (f uM) (p uM) / dM + 1 < 2 ^ k", "obtain k where \"2^k > dist (f uM) (p uM)/dM + 1\""], ["proof (prove)\nusing this:\n  \\<exists>k. dist (f uM) (p uM) / dM + 1 < 2 ^ k\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        dist (f uM) (p uM) / dM + 1 < 2 ^ k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dist (f uM) (p uM) / dM + 1 < 2 ^ k\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  dist (f uM) (p uM) / dM + 1 < 2 ^ k", "have \"dist (f uM) (p uM) < (2^k - 1) * dM\""], ["proof (prove)\nusing this:\n  dist (f uM) (p uM) / dM + 1 < 2 ^ k\n\ngoal (1 subgoal):\n 1. dist (f uM) (p uM) < (2 ^ k - 1) * dM", "using \\<open>dM > 0\\<close>"], ["proof (prove)\nusing this:\n  dist (f uM) (p uM) / dM + 1 < 2 ^ k\n  0 < dM\n\ngoal (1 subgoal):\n 1. dist (f uM) (p uM) < (2 ^ k - 1) * dM", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  dist (f uM) (p uM) < (2 ^ k - 1) * dM\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "also"], ["proof (state)\nthis:\n  dist (f uM) (p uM) < (2 ^ k - 1) * dM\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "have \"... \\<le> (2^(Suc k) - 1) * dM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ k - 1) * dM \\<le> (2 ^ Suc k - 1) * dM", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  (2 ^ k - 1) * dM \\<le> (2 ^ Suc k - 1) * dM\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "finally"], ["proof (chain)\npicking this:\n  dist (f uM) (p uM) < (2 ^ Suc k - 1) * dM", "have \"\\<not>((2 ^ (k + 1) - 1) * dM \\<le> dist (f uM) (p uM))\""], ["proof (prove)\nusing this:\n  dist (f uM) (p uM) < (2 ^ Suc k - 1) * dM\n\ngoal (1 subgoal):\n 1. \\<not> (2 ^ (k + 1) - 1) * dM \\<le> dist (f uM) (p uM)", "by simp"], ["proof (state)\nthis:\n  \\<not> (2 ^ (k + 1) - 1) * dM \\<le> dist (f uM) (p uM)\n\ngoal (1 subgoal):\n 1. D + 4 * C \\<le> dM \\<and> dm \\<le> dM \\<Longrightarrow>\n    Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "then"], ["proof (chain)\npicking this:\n  \\<not> (2 ^ (k + 1) - 1) * dM \\<le> dist (f uM) (p uM)", "show \"Gromov_product_at (f z) (f um) (f uM) \\<le> lambda\\<^sup>2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp (- K * (uM - um)))\""], ["proof (prove)\nusing this:\n  \\<not> (2 ^ (k + 1) - 1) * dM \\<le> dist (f uM) (p uM)\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "using Ind_k[of k]"], ["proof (prove)\nusing this:\n  \\<not> (2 ^ (k + 1) - 1) * dM \\<le> dist (f uM) (p uM)\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um))) \\<or>\n  (\\<exists>x\\<in>{yM..uM}.\n      (\\<forall>y\\<in>{x..uM}.\n          (2 ^ (k + 1) - 1) * dM \\<le> dist (f y) (p y)) \\<and>\n      L - 4 * delta + 7 * QC k \\<le> dist (q k uM) (q k x))\n\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f um) (f uM)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (uM - um)))", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f um) (f uM)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (uM - um)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?um \\<in> {a..z}; ?uM \\<in> {z..b};\n   ?uM - ?um \\<le> real ?n1 * (1 / 4) * delta / lambda\\<rbrakk>\n  \\<Longrightarrow> Gromov_product_at (f z) (f ?um) (f ?uM)\n                    \\<le> lambda\\<^sup>2 *\n                          (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                          2 * delta +\n                          Kmult * (1 - exp (- K * (?uM - ?um)))\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "text \\<open>The main induction is over. To conclude, one should apply its result to the original\n  geodesic segment joining the points $f(a)$ and $f(b)$.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?um \\<in> {a..z}; ?uM \\<in> {z..b};\n   ?uM - ?um \\<le> real ?n1 * (1 / 4) * delta / lambda\\<rbrakk>\n  \\<Longrightarrow> Gromov_product_at (f z) (f ?um) (f ?uM)\n                    \\<le> lambda\\<^sup>2 *\n                          (D + 3 / 2 * L + delta + 11 / 2 * C) -\n                          2 * delta +\n                          Kmult * (1 - exp (- K * (?uM - ?um)))\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "obtain n::nat where \"(b - a)/((1/4) * delta / lambda) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (b - a) / (1 / 4 * delta / lambda) \\<le> real n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using real_arch_simple"], ["proof (prove)\nusing this:\n  \\<exists>n. ?x \\<le> of_nat n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        (b - a) / (1 / 4 * delta / lambda) \\<le> real n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (b - a) / (1 / 4 * delta / lambda) \\<le> real n\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "then"], ["proof (chain)\npicking this:\n  (b - a) / (1 / 4 * delta / lambda) \\<le> real n", "have \"b - a \\<le> n * (1/4) * delta / lambda\""], ["proof (prove)\nusing this:\n  (b - a) / (1 / 4 * delta / lambda) \\<le> real n\n\ngoal (1 subgoal):\n 1. b - a \\<le> real n * (1 / 4) * delta / lambda", "using \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  (b - a) / (1 / 4 * delta / lambda) \\<le> real n\n  0 < delta\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. b - a \\<le> real n * (1 / 4) * delta / lambda", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  b - a \\<le> real n * (1 / 4) * delta / lambda\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"infdist (f z) G \\<le> Gromov_product_at (f z) (f a) (f b) + 2 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f z) G\n    \\<le> Gromov_product_at (f z) (f a) (f b) + 2 * deltaG TYPE('a)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between G (f a) (f b)", "using assms"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n  lambda C -quasi_isometry_on {a..b} f\n  a \\<le> b\n  geodesic_segment_between G (f a) (f b)\n  z \\<in> {a..b}\n  deltaG TYPE('a) < delta\n\ngoal (1 subgoal):\n 1. geodesic_segment_between G (f a) (f b)", "by auto"], ["proof (state)\nthis:\n  infdist (f z) G\n  \\<le> Gromov_product_at (f z) (f a) (f b) + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "also"], ["proof (state)\nthis:\n  infdist (f z) G\n  \\<le> Gromov_product_at (f z) (f a) (f b) + 2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"... \\<le> (lambda^2 * (D + 3/2 * L + delta + 11/2 * C) - 2 * delta + Kmult * (1 - exp(-K * (b - a)))) + 2 * delta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_product_at (f z) (f a) (f b) + 2 * deltaG TYPE('a)\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) -\n          2 * delta +\n          Kmult * (1 - exp (- K * (b - a))) +\n          2 * delta", "apply (intro mono_intros Main[OF _ _ \\<open>b - a \\<le> n * (1/4) * delta / lambda\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. a \\<in> {a..z}\n 2. b \\<in> {z..b}\n 3. deltaG TYPE('a) \\<le> delta\n 4. 0 \\<le> 2", "using assms"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n  lambda C -quasi_isometry_on {a..b} f\n  a \\<le> b\n  geodesic_segment_between G (f a) (f b)\n  z \\<in> {a..b}\n  deltaG TYPE('a) < delta\n\ngoal (4 subgoals):\n 1. a \\<in> {a..z}\n 2. b \\<in> {z..b}\n 3. deltaG TYPE('a) \\<le> delta\n 4. 0 \\<le> 2", "by auto"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f a) (f b) + 2 * deltaG TYPE('a)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (b - a))) +\n        2 * delta\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "also"], ["proof (state)\nthis:\n  Gromov_product_at (f z) (f a) (f b) + 2 * deltaG TYPE('a)\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n        Kmult * (1 - exp (- K * (b - a))) +\n        2 * delta\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"... = lambda^2 * (D + 3/2 * L + delta + 11/2 * C) + Kmult * (1 - exp(-K * (b - a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n    Kmult * (1 - exp (- K * (b - a))) +\n    2 * delta =\n    lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n    Kmult * (1 - exp (- K * (b - a)))", "by simp"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n  Kmult * (1 - exp (- K * (b - a))) +\n  2 * delta =\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n  Kmult * (1 - exp (- K * (b - a)))\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "also"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) - 2 * delta +\n  Kmult * (1 - exp (- K * (b - a))) +\n  2 * delta =\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n  Kmult * (1 - exp (- K * (b - a)))\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"... \\<le> lambda^2 * (D + 3/2 * L + delta + 11/2 * C) + Kmult * (1 - 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n    Kmult * (1 - exp (- K * (b - a)))\n    \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n          Kmult * (1 - 0)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> exp (- K * (b - a))\n 2. 0 \\<le> Kmult", "using \\<open>Kmult > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < Kmult\n\ngoal (2 subgoals):\n 1. 0 \\<le> exp (- K * (b - a))\n 2. 0 \\<le> Kmult", "by auto"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n  Kmult * (1 - exp (- K * (b - a)))\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n        Kmult * (1 - 0)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "also"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n  Kmult * (1 - exp (- K * (b - a)))\n  \\<le> lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n        Kmult * (1 - 0)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"... = lambda^2 * (11/2 * C + (3200*exp(-459/50*ln 2)/ln 2 + 83) * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) +\n    Kmult * (1 - 0) =\n    lambda\\<^sup>2 *\n    (11 / 2 * C + (3200 * exp (- 459 / 50 * ln 2) / ln 2 + 83) * delta)", "unfolding Kmult_def K_def L_def alpha_def D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 *\n    (55 * delta + 3 / 2 * (18 * delta) + delta + 11 / 2 * C) +\n    (18 * delta + 4 * delta) / (18 * delta - 13 * delta) *\n    (4 * exp (1 / 2 * ln 2) * lambda *\n     exp (- (1 - 12 / 100) * (55 * delta) * ln 2 / (5 * delta)) /\n     (12 / 100 * ln 2 /\n      (5 * (4 + (18 * delta + 2 * delta) / (55 * delta)) * delta *\n       lambda))) *\n    (1 - 0) =\n    lambda\\<^sup>2 *\n    (11 / 2 * C + (3200 * exp (- 459 / 50 * ln 2) / ln 2 + 83) * delta)", "using \\<open>delta > 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 *\n    (55 * delta + 3 / 2 * (18 * delta) + delta + 11 / 2 * C) +\n    (18 * delta + 4 * delta) / (18 * delta - 13 * delta) *\n    (4 * exp (1 / 2 * ln 2) * lambda *\n     exp (- (1 - 12 / 100) * (55 * delta) * ln 2 / (5 * delta)) /\n     (12 / 100 * ln 2 /\n      (5 * (4 + (18 * delta + 2 * delta) / (55 * delta)) * delta *\n       lambda))) *\n    (1 - 0) =\n    lambda\\<^sup>2 *\n    (11 / 2 * C + (3200 * exp (- 459 / 50 * ln 2) / ln 2 + 83) * delta)", "by (simp add: algebra_simps divide_simps power2_eq_square mult_exp_exp)"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) + Kmult * (1 - 0) =\n  lambda\\<^sup>2 *\n  (11 / 2 * C + (3200 * exp (- 459 / 50 * ln 2) / ln 2 + 83) * delta)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "also"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (D + 3 / 2 * L + delta + 11 / 2 * C) + Kmult * (1 - 0) =\n  lambda\\<^sup>2 *\n  (11 / 2 * C + (3200 * exp (- 459 / 50 * ln 2) / ln 2 + 83) * delta)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "have \"... \\<le> lambda^2 * (11/2 * C + 91 * delta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 *\n    (11 / 2 * C + (3200 * exp (- 459 / 50 * ln 2) / ln 2 + 83) * delta)\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "apply (intro mono_intros, simp add: divide_simps, approximation 14)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> delta\n 2. 0 \\<le> lambda\\<^sup>2", "using \\<open>delta > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < delta\n\ngoal (2 subgoals):\n 1. 0 \\<le> delta\n 2. 0 \\<le> lambda\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  lambda\\<^sup>2 *\n  (11 / 2 * C + (3200 * exp (- 459 / 50 * ln 2) / ln 2 + 83) * delta)\n  \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "finally"], ["proof (chain)\npicking this:\n  infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Still assuming that our quasi-isometry is Lipschitz, we will improve slightly on the previous\nresult, first going down to the hyperbolicity constant of the space, and also showing that,\nconversely, the geodesic is contained in a neighborhood of the quasi-geodesic. The argument for this\nlast point goes as follows. Consider a point $x$ on the geodesic. Define two sets to\nbe the $D$-thickenings of $[a,x]$ and $[x,b]$ respectively, where $D$ is such that any point on the\nquasi-geodesic is within distance $D$ of the geodesic (as given by the previous theorem). The union\nof these two sets covers the quasi-geodesic, and they are both closed and nonempty. By connectedness,\nthere is a point $z$ in their intersection, $D$-close both to a point $x^-$ before $x$ and to a point\n$x^+$ after $x$. Then $x$ belongs to a geodesic between $x^-$ and $x^+$, which is contained in a\n$4\\delta$-neighborhood of geodesics from $x^+$ to $z$ and from $x^-$ to $z$ by hyperbolicity. It\nfollows that $x$ is at distance at most $D + 4\\delta$ of $z$, concluding the proof.\\<close>"], ["", "lemma (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem_aux2:\n  fixes f::\"real \\<Rightarrow> 'a\"\n  assumes \"continuous_on {a..b} f\"\n          \"lambda C-quasi_isometry_on {a..b} f\"\n          \"geodesic_segment_between G (f a) (f b)\"\n  shows \"hausdorff_distance (f`{a..b}) G \\<le> lambda^2 * (11/2 * C + 92 * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "proof (cases \"a \\<le> b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "case True"], ["proof (state)\nthis:\n  a \\<le> b\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "have \"lambda \\<ge> 1\" \"C \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> lambda &&& 0 \\<le> C", "using quasi_isometry_onD[OF assms(2)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> 1 / lambda * dist ?x ?y - C \\<le> dist (f ?x) (f ?y)\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 1 \\<le> lambda &&& 0 \\<le> C", "by auto"], ["proof (state)\nthis:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "have *: \"infdist (f z) G \\<le> lambda^2 * (11/2 * C + 91 * delta)\" if \"z \\<in> {a..b}\" \"delta > deltaG(TYPE('a))\" for z delta"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)", "by (rule Morse_Gromov_theorem_aux1[OF assms(1) assms(2) True assms(3) that])"], ["proof (state)\nthis:\n  \\<lbrakk>?z \\<in> {a..b}; deltaG TYPE('a) < ?delta\\<rbrakk>\n  \\<Longrightarrow> infdist (f ?z) G\n                    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * ?delta)\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "define D where \"D = lambda^2 * (11/2 * C + 91 * deltaG(TYPE('a)))\""], ["proof (state)\nthis:\n  D = lambda\\<^sup>2 * (11 / 2 * C + 91 * deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "have \"D \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * deltaG TYPE('a))", "using \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> D\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "have I: \"infdist (f z) G \\<le> D\" if \"z \\<in> {a..b}\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> D", "have \"(infdist (f z) G/ lambda^2 - 11/2 * C)/91 \\<le> delta\" if \"delta > deltaG(TYPE('a))\" for delta"], ["proof (prove)\ngoal (1 subgoal):\n 1. (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> delta", "using *[OF \\<open>z \\<in> {a..b}\\<close> that] \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  infdist (f z) G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * delta)\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> delta", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  deltaG TYPE('a) < ?delta \\<Longrightarrow>\n  (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> ?delta\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> D", "then"], ["proof (chain)\npicking this:\n  deltaG TYPE('a) < ?delta \\<Longrightarrow>\n  (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> ?delta", "have \"(infdist (f z) G/ lambda^2 - 11/2 * C)/91 \\<le> deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  deltaG TYPE('a) < ?delta \\<Longrightarrow>\n  (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> ?delta\n\ngoal (1 subgoal):\n 1. (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91\n    \\<le> deltaG TYPE('a)", "using dense_ge"], ["proof (prove)\nusing this:\n  deltaG TYPE('a) < ?delta \\<Longrightarrow>\n  (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> ?delta\n  (\\<And>x. ?z < x \\<Longrightarrow> ?y \\<le> x) \\<Longrightarrow>\n  ?y \\<le> ?z\n\ngoal (1 subgoal):\n 1. (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91\n    \\<le> deltaG TYPE('a)", "by blast"], ["proof (state)\nthis:\n  (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> D", "then"], ["proof (chain)\npicking this:\n  (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist (f z) G \\<le> D", "unfolding D_def"], ["proof (prove)\nusing this:\n  (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist (f z) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * deltaG TYPE('a))", "using \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  (infdist (f z) G / lambda\\<^sup>2 - 11 / 2 * C) / 91 \\<le> deltaG TYPE('a)\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. infdist (f z) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * deltaG TYPE('a))", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  infdist (f z) G \\<le> D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> {a..b} \\<Longrightarrow> infdist (f ?z) G \\<le> D\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "proof (rule hausdorff_distanceI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       infdist x G\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 3. 0 \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "show \"0 \\<le> lambda\\<^sup>2 * (11/2 * C + 92 * deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "using \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       infdist x G\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       infdist x G\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "assume \"x \\<in> f`{a..b}\""], ["proof (state)\nthis:\n  x \\<in> f ` {a..b}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       infdist x G\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  x \\<in> f ` {a..b}", "obtain z where z: \"x = f z\" \"z \\<in> {a..b}\""], ["proof (prove)\nusing this:\n  x \\<in> f ` {a..b}\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>x = f z; z \\<in> {a..b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = f z\n  z \\<in> {a..b}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       infdist x G\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "show \"infdist x G \\<le> lambda\\<^sup>2 * (11/2 * C + 92 * deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "unfolding z(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f z) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "by (rule order_trans[OF I[OF \\<open>z \\<in> {a..b}\\<close>]], auto simp add: algebra_simps D_def)"], ["proof (state)\nthis:\n  infdist x G \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "assume \"x \\<in> G\""], ["proof (state)\nthis:\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "have \"infdist x (f`{a..b}) \\<le> D + 1 * deltaG TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "define p where \"p = geodesic_segment_param G (f a)\""], ["proof (state)\nthis:\n  p = geodesic_segment_param G (f a)\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  p = geodesic_segment_param G (f a)", "have p: \"p 0 = f a\" \"p (dist (f a) (f b)) = f b\""], ["proof (prove)\nusing this:\n  p = geodesic_segment_param G (f a)\n\ngoal (1 subgoal):\n 1. p 0 = f a &&& p (dist (f a) (f b)) = f b", "unfolding p_def"], ["proof (prove)\nusing this:\n  geodesic_segment_param G (f a) = geodesic_segment_param G (f a)\n\ngoal (1 subgoal):\n 1. geodesic_segment_param G (f a) 0 = f a &&&\n    geodesic_segment_param G (f a) (dist (f a) (f b)) = f b", "using assms(3)"], ["proof (prove)\nusing this:\n  geodesic_segment_param G (f a) = geodesic_segment_param G (f a)\n  geodesic_segment_between G (f a) (f b)\n\ngoal (1 subgoal):\n 1. geodesic_segment_param G (f a) 0 = f a &&&\n    geodesic_segment_param G (f a) (dist (f a) (f b)) = f b", "by auto"], ["proof (state)\nthis:\n  p 0 = f a\n  p (dist (f a) (f b)) = f b\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "obtain t where t: \"x = p t\" \"t \\<in> {0..dist (f a) (f b)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x = p t; t \\<in> {0..dist (f a) (f b)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x = geodesic_segment_param G (f a) t;\n         t \\<in> {0..dist (f a) (f b)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>x \\<in> G\\<close> \\<open>geodesic_segment_between G (f a) (f b)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> G\n  geodesic_segment_between G (f a) (f b)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x = geodesic_segment_param G (f a) t;\n         t \\<in> {0..dist (f a) (f b)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis geodesic_segment_param(5) imageE)"], ["proof (state)\nthis:\n  x = p t\n  t \\<in> {0..dist (f a) (f b)}\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "define Km where \"Km = (\\<Union>z \\<in> p`{0..t}. cball z D)\""], ["proof (state)\nthis:\n  Km = (\\<Union>z\\<in>p ` {0..t}. cball z D)\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "define KM where \"KM = (\\<Union>z \\<in> p`{t..dist (f a) (f b)}. cball z D)\""], ["proof (state)\nthis:\n  KM = (\\<Union>z\\<in>p ` {t..dist (f a) (f b)}. cball z D)\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "have \"f`{a..b} \\<subseteq> Km \\<union> KM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {a..b} \\<subseteq> Km \\<union> KM", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` {a..b} \\<Longrightarrow> x \\<in> Km \\<union> KM", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` {a..b} \\<Longrightarrow> x \\<in> Km \\<union> KM", "assume x: \"x \\<in> f`{a..b}\""], ["proof (state)\nthis:\n  x \\<in> f ` {a..b}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` {a..b} \\<Longrightarrow> x \\<in> Km \\<union> KM", "have \"\\<exists>z \\<in> G. infdist x G = dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>G. infdist x G = dist x z", "apply (rule infdist_proper_attained)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper G\n 2. G \\<noteq> {}", "using geodesic_segment_topology[OF geodesic_segmentI[OF assms(3)]]"], ["proof (prove)\nusing this:\n  compact G\n  connected G\n  path_connected G\n  bounded G\n  closed G\n  G \\<noteq> {}\n  proper G\n\ngoal (2 subgoals):\n 1. proper G\n 2. G \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>z\\<in>G. infdist x G = dist x z\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` {a..b} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  \\<exists>z\\<in>G. infdist x G = dist x z", "obtain z where z: \"z \\<in> G\" \"infdist x G = dist x z\""], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>G. infdist x G = dist x z\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> G; infdist x G = dist x z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> G\n  infdist x G = dist x z\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` {a..b} \\<Longrightarrow> x \\<in> Km \\<union> KM", "obtain tz where tz: \"z = p tz\" \"tz \\<in> {0..dist (f a) (f b)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tz.\n        \\<lbrakk>z = p tz; tz \\<in> {0..dist (f a) (f b)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tz.\n        \\<lbrakk>z = geodesic_segment_param G (f a) tz;\n         tz \\<in> {0..dist (f a) (f b)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>z \\<in> G\\<close> \\<open>geodesic_segment_between G (f a) (f b)\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> G\n  geodesic_segment_between G (f a) (f b)\n\ngoal (1 subgoal):\n 1. (\\<And>tz.\n        \\<lbrakk>z = geodesic_segment_param G (f a) tz;\n         tz \\<in> {0..dist (f a) (f b)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis geodesic_segment_param(5) imageE)"], ["proof (state)\nthis:\n  z = p tz\n  tz \\<in> {0..dist (f a) (f b)}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` {a..b} \\<Longrightarrow> x \\<in> Km \\<union> KM", "have \"infdist x G \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x G \\<le> D", "using I \\<open>x \\<in> f`{a..b}\\<close>"], ["proof (prove)\nusing this:\n  ?z \\<in> {a..b} \\<Longrightarrow> infdist (f ?z) G \\<le> D\n  x \\<in> f ` {a..b}\n\ngoal (1 subgoal):\n 1. infdist x G \\<le> D", "by auto"], ["proof (state)\nthis:\n  infdist x G \\<le> D\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` {a..b} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  infdist x G \\<le> D", "have \"dist z x \\<le> D\""], ["proof (prove)\nusing this:\n  infdist x G \\<le> D\n\ngoal (1 subgoal):\n 1. dist z x \\<le> D", "using z(2)"], ["proof (prove)\nusing this:\n  infdist x G \\<le> D\n  infdist x G = dist x z\n\ngoal (1 subgoal):\n 1. dist z x \\<le> D", "by (simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist z x \\<le> D\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> f ` {a..b} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  dist z x \\<le> D", "show \"x \\<in> Km \\<union> KM\""], ["proof (prove)\nusing this:\n  dist z x \\<le> D\n\ngoal (1 subgoal):\n 1. x \\<in> Km \\<union> KM", "unfolding Km_def KM_def"], ["proof (prove)\nusing this:\n  dist z x \\<le> D\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>z\\<in>p ` {0..t}. cball z D) \\<union>\n            (\\<Union>z\\<in>p ` {t..dist (f a) (f b)}. cball z D)", "using tz"], ["proof (prove)\nusing this:\n  dist z x \\<le> D\n  z = p tz\n  tz \\<in> {0..dist (f a) (f b)}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>z\\<in>p ` {0..t}. cball z D) \\<union>\n            (\\<Union>z\\<in>p ` {t..dist (f a) (f b)}. cball z D)", "by force"], ["proof (state)\nthis:\n  x \\<in> Km \\<union> KM\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f ` {a..b} \\<subseteq> Km \\<union> KM\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  f ` {a..b} \\<subseteq> Km \\<union> KM", "have *: \"f`{a..b} = (Km \\<inter> f`{a..b}) \\<union> (KM \\<inter> f`{a..b})\""], ["proof (prove)\nusing this:\n  f ` {a..b} \\<subseteq> Km \\<union> KM\n\ngoal (1 subgoal):\n 1. f ` {a..b} = Km \\<inter> f ` {a..b} \\<union> KM \\<inter> f ` {a..b}", "by auto"], ["proof (state)\nthis:\n  f ` {a..b} = Km \\<inter> f ` {a..b} \\<union> KM \\<inter> f ` {a..b}\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "have \"(Km \\<inter> f`{a..b}) \\<inter> (KM \\<inter> f`{a..b}) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Km \\<inter> f ` {a..b} \\<inter> (KM \\<inter> f ` {a..b}) \\<noteq> {}", "proof (rule connected_as_closed_union[OF _ *])"], ["proof (state)\ngoal (5 subgoals):\n 1. connected (f ` {a..b})\n 2. closed (Km \\<inter> f ` {a..b})\n 3. closed (KM \\<inter> f ` {a..b})\n 4. Km \\<inter> f ` {a..b} \\<noteq> {}\n 5. KM \\<inter> f ` {a..b} \\<noteq> {}", "have \"closed (f ` {a..b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (f ` {a..b})", "apply (intro compact_imp_closed compact_continuous_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {a..b} f\n 2. compact {a..b}", "using assms(1)"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n\ngoal (2 subgoals):\n 1. continuous_on {a..b} f\n 2. compact {a..b}", "by auto"], ["proof (state)\nthis:\n  closed (f ` {a..b})\n\ngoal (5 subgoals):\n 1. connected (f ` {a..b})\n 2. closed (Km \\<inter> f ` {a..b})\n 3. closed (KM \\<inter> f ` {a..b})\n 4. Km \\<inter> f ` {a..b} \\<noteq> {}\n 5. KM \\<inter> f ` {a..b} \\<noteq> {}", "have \"closed Km\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed Km", "unfolding Km_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (\\<Union>z\\<in>p ` {0..t}. cball z D)", "apply (intro compact_has_closed_thickening compact_continuous_image)"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {0..t} p\n 2. compact {0..t}\n 3. continuous_on (p ` {0..t}) (\\<lambda>x. D)", "apply (rule continuous_on_subset[of \"{0..dist (f a) (f b)}\" p])"], ["proof (prove)\ngoal (4 subgoals):\n 1. continuous_on {0..dist (f a) (f b)} p\n 2. {0..t} \\<subseteq> {0..dist (f a) (f b)}\n 3. compact {0..t}\n 4. continuous_on (p ` {0..t}) (\\<lambda>x. D)", "unfolding p_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. continuous_on {0..dist (f a) (f b)} (geodesic_segment_param G (f a))\n 2. {0..t} \\<subseteq> {0..dist (f a) (f b)}\n 3. compact {0..t}\n 4. continuous_on (geodesic_segment_param G (f a) ` {0..t}) (\\<lambda>x. D)", "using assms(3) \\<open>t \\<in> {0..dist (f a) (f b)}\\<close>"], ["proof (prove)\nusing this:\n  geodesic_segment_between G (f a) (f b)\n  t \\<in> {0..dist (f a) (f b)}\n\ngoal (4 subgoals):\n 1. continuous_on {0..dist (f a) (f b)} (geodesic_segment_param G (f a))\n 2. {0..t} \\<subseteq> {0..dist (f a) (f b)}\n 3. compact {0..t}\n 4. continuous_on (geodesic_segment_param G (f a) ` {0..t}) (\\<lambda>x. D)", "by (auto simp add: isometry_on_continuous)"], ["proof (state)\nthis:\n  closed Km\n\ngoal (5 subgoals):\n 1. connected (f ` {a..b})\n 2. closed (Km \\<inter> f ` {a..b})\n 3. closed (KM \\<inter> f ` {a..b})\n 4. Km \\<inter> f ` {a..b} \\<noteq> {}\n 5. KM \\<inter> f ` {a..b} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  closed Km", "show \"closed (Km \\<inter> f`{a..b})\""], ["proof (prove)\nusing this:\n  closed Km\n\ngoal (1 subgoal):\n 1. closed (Km \\<inter> f ` {a..b})", "by (rule topological_space_class.closed_Int) fact"], ["proof (state)\nthis:\n  closed (Km \\<inter> f ` {a..b})\n\ngoal (4 subgoals):\n 1. connected (f ` {a..b})\n 2. closed (KM \\<inter> f ` {a..b})\n 3. Km \\<inter> f ` {a..b} \\<noteq> {}\n 4. KM \\<inter> f ` {a..b} \\<noteq> {}", "have \"closed KM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed KM", "unfolding KM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (\\<Union>z\\<in>p ` {t..dist (f a) (f b)}. cball z D)", "apply (intro compact_has_closed_thickening compact_continuous_image)"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {t..dist (f a) (f b)} p\n 2. compact {t..dist (f a) (f b)}\n 3. continuous_on (p ` {t..dist (f a) (f b)}) (\\<lambda>x. D)", "apply (rule continuous_on_subset[of \"{0..dist (f a) (f b)}\" p])"], ["proof (prove)\ngoal (4 subgoals):\n 1. continuous_on {0..dist (f a) (f b)} p\n 2. {t..dist (f a) (f b)} \\<subseteq> {0..dist (f a) (f b)}\n 3. compact {t..dist (f a) (f b)}\n 4. continuous_on (p ` {t..dist (f a) (f b)}) (\\<lambda>x. D)", "unfolding p_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. continuous_on {0..dist (f a) (f b)} (geodesic_segment_param G (f a))\n 2. {t..dist (f a) (f b)} \\<subseteq> {0..dist (f a) (f b)}\n 3. compact {t..dist (f a) (f b)}\n 4. continuous_on (geodesic_segment_param G (f a) ` {t..dist (f a) (f b)})\n     (\\<lambda>x. D)", "using assms(3) \\<open>t \\<in> {0..dist (f a) (f b)}\\<close>"], ["proof (prove)\nusing this:\n  geodesic_segment_between G (f a) (f b)\n  t \\<in> {0..dist (f a) (f b)}\n\ngoal (4 subgoals):\n 1. continuous_on {0..dist (f a) (f b)} (geodesic_segment_param G (f a))\n 2. {t..dist (f a) (f b)} \\<subseteq> {0..dist (f a) (f b)}\n 3. compact {t..dist (f a) (f b)}\n 4. continuous_on (geodesic_segment_param G (f a) ` {t..dist (f a) (f b)})\n     (\\<lambda>x. D)", "by (auto simp add: isometry_on_continuous)"], ["proof (state)\nthis:\n  closed KM\n\ngoal (4 subgoals):\n 1. connected (f ` {a..b})\n 2. closed (KM \\<inter> f ` {a..b})\n 3. Km \\<inter> f ` {a..b} \\<noteq> {}\n 4. KM \\<inter> f ` {a..b} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  closed KM", "show \"closed (KM \\<inter> f`{a..b})\""], ["proof (prove)\nusing this:\n  closed KM\n\ngoal (1 subgoal):\n 1. closed (KM \\<inter> f ` {a..b})", "by (rule topological_space_class.closed_Int) fact"], ["proof (state)\nthis:\n  closed (KM \\<inter> f ` {a..b})\n\ngoal (3 subgoals):\n 1. connected (f ` {a..b})\n 2. Km \\<inter> f ` {a..b} \\<noteq> {}\n 3. KM \\<inter> f ` {a..b} \\<noteq> {}", "show \"connected (f`{a..b})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected (f ` {a..b})", "apply (rule connected_continuous_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. continuous_on {a..b} f\n 2. connected {a..b}", "using assms(1)"], ["proof (prove)\nusing this:\n  continuous_on {a..b} f\n\ngoal (2 subgoals):\n 1. continuous_on {a..b} f\n 2. connected {a..b}", "by auto"], ["proof (state)\nthis:\n  connected (f ` {a..b})\n\ngoal (2 subgoals):\n 1. Km \\<inter> f ` {a..b} \\<noteq> {}\n 2. KM \\<inter> f ` {a..b} \\<noteq> {}", "have \"f a \\<in> Km \\<inter> f`{a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f a \\<in> Km \\<inter> f ` {a..b}", "using True"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. f a \\<in> Km \\<inter> f ` {a..b}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> f a \\<in> Km", "unfolding Km_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    f a \\<in> (\\<Union>z\\<in>p ` {0..t}. cball z D)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow>\n    \\<exists>x\\<in>{0..t}. dist (p x) (f a) \\<le> D", "apply (rule bexI[of _ 0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow> dist (p 0) (f a) \\<le> D\n 2. a \\<le> b \\<Longrightarrow> 0 \\<in> {0..t}", "unfolding p"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow> dist (f a) (f a) \\<le> D\n 2. a \\<le> b \\<Longrightarrow> 0 \\<in> {0..t}", "using \\<open>D \\<ge> 0\\<close> t(2)"], ["proof (prove)\nusing this:\n  0 \\<le> D\n  t \\<in> {0..dist (f a) (f b)}\n\ngoal (2 subgoals):\n 1. a \\<le> b \\<Longrightarrow> dist (f a) (f a) \\<le> D\n 2. a \\<le> b \\<Longrightarrow> 0 \\<in> {0..t}", "by auto"], ["proof (state)\nthis:\n  f a \\<in> Km \\<inter> f ` {a..b}\n\ngoal (2 subgoals):\n 1. Km \\<inter> f ` {a..b} \\<noteq> {}\n 2. KM \\<inter> f ` {a..b} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  f a \\<in> Km \\<inter> f ` {a..b}", "show \"Km \\<inter> f`{a..b} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  f a \\<in> Km \\<inter> f ` {a..b}\n\ngoal (1 subgoal):\n 1. Km \\<inter> f ` {a..b} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Km \\<inter> f ` {a..b} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. KM \\<inter> f ` {a..b} \\<noteq> {}", "have \"f b \\<in> KM \\<inter> f`{a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f b \\<in> KM \\<inter> f ` {a..b}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. f b \\<in> KM\n 2. f b \\<in> f ` {a..b}", "unfolding KM_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. f b \\<in> (\\<Union>z\\<in>p ` {t..dist (f a) (f b)}. cball z D)\n 2. f b \\<in> f ` {a..b}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x\\<in>{t..dist (f a) (f b)}. dist (p x) (f b) \\<le> D\n 2. f b \\<in> f ` {a..b}", "apply (rule bexI[of _ \"dist (f a) (f b)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. dist (p (dist (f a) (f b))) (f b) \\<le> D\n 2. dist (f a) (f b) \\<in> {t..dist (f a) (f b)}\n 3. f b \\<in> f ` {a..b}", "unfolding p"], ["proof (prove)\ngoal (3 subgoals):\n 1. dist (f b) (f b) \\<le> D\n 2. dist (f a) (f b) \\<in> {t..dist (f a) (f b)}\n 3. f b \\<in> f ` {a..b}", "using \\<open>D \\<ge> 0\\<close> t(2) True"], ["proof (prove)\nusing this:\n  0 \\<le> D\n  t \\<in> {0..dist (f a) (f b)}\n  a \\<le> b\n\ngoal (3 subgoals):\n 1. dist (f b) (f b) \\<le> D\n 2. dist (f a) (f b) \\<in> {t..dist (f a) (f b)}\n 3. f b \\<in> f ` {a..b}", "by auto"], ["proof (state)\nthis:\n  f b \\<in> KM \\<inter> f ` {a..b}\n\ngoal (1 subgoal):\n 1. KM \\<inter> f ` {a..b} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  f b \\<in> KM \\<inter> f ` {a..b}", "show \"KM \\<inter> f`{a..b} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  f b \\<in> KM \\<inter> f ` {a..b}\n\ngoal (1 subgoal):\n 1. KM \\<inter> f ` {a..b} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  KM \\<inter> f ` {a..b} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Km \\<inter> f ` {a..b} \\<inter> (KM \\<inter> f ` {a..b}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "then"], ["proof (chain)\npicking this:\n  Km \\<inter> f ` {a..b} \\<inter> (KM \\<inter> f ` {a..b}) \\<noteq> {}", "obtain y where y: \"y \\<in> f`{a..b}\" \"y \\<in> Km\" \"y \\<in> KM\""], ["proof (prove)\nusing this:\n  Km \\<inter> f ` {a..b} \\<inter> (KM \\<inter> f ` {a..b}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> f ` {a..b}; y \\<in> Km; y \\<in> KM\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> f ` {a..b}\n  y \\<in> Km\n  y \\<in> KM\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "obtain tm where tm: \"tm \\<in> {0..t}\" \"dist (p tm) y \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tm.\n        \\<lbrakk>tm \\<in> {0..t}; dist (p tm) y \\<le> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using y(2)"], ["proof (prove)\nusing this:\n  y \\<in> Km\n\ngoal (1 subgoal):\n 1. (\\<And>tm.\n        \\<lbrakk>tm \\<in> {0..t}; dist (p tm) y \\<le> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Km_def"], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>z\\<in>p ` {0..t}. cball z D)\n\ngoal (1 subgoal):\n 1. (\\<And>tm.\n        \\<lbrakk>tm \\<in> {0..t}; dist (p tm) y \\<le> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tm \\<in> {0..t}\n  dist (p tm) y \\<le> D\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "obtain tM where tM: \"tM \\<in> {t..dist (f a) (f b)}\" \"dist (p tM) y \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tM.\n        \\<lbrakk>tM \\<in> {t..dist (f a) (f b)};\n         dist (p tM) y \\<le> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using y(3)"], ["proof (prove)\nusing this:\n  y \\<in> KM\n\ngoal (1 subgoal):\n 1. (\\<And>tM.\n        \\<lbrakk>tM \\<in> {t..dist (f a) (f b)};\n         dist (p tM) y \\<le> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding KM_def"], ["proof (prove)\nusing this:\n  y \\<in> (\\<Union>z\\<in>p ` {t..dist (f a) (f b)}. cball z D)\n\ngoal (1 subgoal):\n 1. (\\<And>tM.\n        \\<lbrakk>tM \\<in> {t..dist (f a) (f b)};\n         dist (p tM) y \\<le> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tM \\<in> {t..dist (f a) (f b)}\n  dist (p tM) y \\<le> D\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "define H where \"H = p`{tm..tM}\""], ["proof (state)\nthis:\n  H = p ` {tm..tM}\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "have *: \"geodesic_segment_between H (p tm) (p tM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between H (p tm) (p tM)", "unfolding H_def p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (geodesic_segment_param G (f a) ` {tm..tM})\n     (geodesic_segment_param G (f a) tm) (geodesic_segment_param G (f a) tM)", "apply (rule geodesic_segmentI2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. isometry_on {tm..tM} (geodesic_segment_param G (f a))\n 2. tm \\<le> tM", "using assms(3) \\<open>tm \\<in> {0..t}\\<close> \\<open>tM \\<in> {t..dist (f a) (f b)}\\<close> isometry_on_subset"], ["proof (prove)\nusing this:\n  geodesic_segment_between G (f a) (f b)\n  tm \\<in> {0..t}\n  tM \\<in> {t..dist (f a) (f b)}\n  \\<lbrakk>isometry_on ?X ?f; ?Y \\<subseteq> ?X\\<rbrakk>\n  \\<Longrightarrow> isometry_on ?Y ?f\n\ngoal (2 subgoals):\n 1. isometry_on {tm..tM} (geodesic_segment_param G (f a))\n 2. tm \\<le> tM", "using assms(3) geodesic_segment_param(4)"], ["proof (prove)\nusing this:\n  geodesic_segment_between G (f a) (f b)\n  tm \\<in> {0..t}\n  tM \\<in> {t..dist (f a) (f b)}\n  \\<lbrakk>isometry_on ?X ?f; ?Y \\<subseteq> ?X\\<rbrakk>\n  \\<Longrightarrow> isometry_on ?Y ?f\n  geodesic_segment_between G (f a) (f b)\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow>\n  isometry_on {0..dist ?x ?y} (geodesic_segment_param ?G ?x)\n\ngoal (2 subgoals):\n 1. isometry_on {tm..tM} (geodesic_segment_param G (f a))\n 2. tm \\<le> tM", "by (auto) fastforce"], ["proof (state)\nthis:\n  geodesic_segment_between H (p tm) (p tM)\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "have \"x \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> H", "unfolding t(1) H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p t \\<in> p ` {tm..tM}", "using \\<open>tm \\<in> {0..t}\\<close> \\<open>tM \\<in> {t..dist (f a) (f b)}\\<close>"], ["proof (prove)\nusing this:\n  tm \\<in> {0..t}\n  tM \\<in> {t..dist (f a) (f b)}\n\ngoal (1 subgoal):\n 1. p t \\<in> p ` {tm..tM}", "by auto"], ["proof (state)\nthis:\n  x \\<in> H\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "have \"infdist x (f ` {a..b}) \\<le> dist x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> dist x y", "by (rule infdist_le[OF y(1)])"], ["proof (state)\nthis:\n  infdist x (f ` {a..b}) \\<le> dist x y\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "also"], ["proof (state)\nthis:\n  infdist x (f ` {a..b}) \\<le> dist x y\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "have \"... \\<le> max (dist (p tm) y) (dist (p tM) y) + deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x y \\<le> max (dist (p tm) y) (dist (p tM) y) + deltaG TYPE('a)", "by (rule dist_le_max_dist_triangle[OF * \\<open>x \\<in> H\\<close>])"], ["proof (state)\nthis:\n  dist x y \\<le> max (dist (p tm) y) (dist (p tM) y) + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "finally"], ["proof (chain)\npicking this:\n  infdist x (f ` {a..b})\n  \\<le> max (dist (p tm) y) (dist (p tM) y) + deltaG TYPE('a)", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist x (f ` {a..b})\n  \\<le> max (dist (p tm) y) (dist (p tM) y) + deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "using tm(2) tM(2)"], ["proof (prove)\nusing this:\n  infdist x (f ` {a..b})\n  \\<le> max (dist (p tm) y) (dist (p tM) y) + deltaG TYPE('a)\n  dist (p tm) y \\<le> D\n  dist (p tM) y \\<le> D\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  infdist x (f ` {a..b}) \\<le> D + 1 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "have \"... \\<le> D + lambda^2 * deltaG TYPE('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D + 1 * deltaG TYPE('a) \\<le> D + lambda\\<^sup>2 * deltaG TYPE('a)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> lambda\\<^sup>2", "using \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 1 \\<le> lambda\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  D + 1 * deltaG TYPE('a) \\<le> D + lambda\\<^sup>2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       infdist x (f ` {a..b})\n       \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "finally"], ["proof (chain)\npicking this:\n  infdist x (f ` {a..b}) \\<le> D + lambda\\<^sup>2 * deltaG TYPE('a)", "show \"infdist x (f ` {a..b}) \\<le> lambda\\<^sup>2 * (11/2 * C + 92 * deltaG TYPE('a))\""], ["proof (prove)\nusing this:\n  infdist x (f ` {a..b}) \\<le> D + lambda\\<^sup>2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b})\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "unfolding D_def"], ["proof (prove)\nusing this:\n  infdist x (f ` {a..b})\n  \\<le> lambda\\<^sup>2 * (11 / 2 * C + 91 * deltaG TYPE('a)) +\n        lambda\\<^sup>2 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist x (f ` {a..b})\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  infdist x (f ` {a..b})\n  \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "case False"], ["proof (state)\nthis:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  \\<not> a \\<le> b", "have \"f`{a..b} = {}\""], ["proof (prove)\nusing this:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. f ` {a..b} = {}", "by auto"], ["proof (state)\nthis:\n  f ` {a..b} = {}\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  f ` {a..b} = {}", "have \"hausdorff_distance (f ` {a..b}) G = 0\""], ["proof (prove)\nusing this:\n  f ` {a..b} = {}\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G = 0", "unfolding hausdorff_distance_def"], ["proof (prove)\nusing this:\n  f ` {a..b} = {}\n\ngoal (1 subgoal):\n 1. (if f ` {a..b} = {} \\<or>\n        G = {} \\<or> \\<not> bounded (f ` {a..b}) \\<or> \\<not> bounded G\n     then 0\n     else max (SUP x\\<in>f ` {a..b}. infdist x G)\n           (SUP x\\<in>G. infdist x (f ` {a..b}))) =\n    0", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G = 0\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  hausdorff_distance (f ` {a..b}) G = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  hausdorff_distance (f ` {a..b}) G = 0\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "using quasi_isometry_onD(4)[OF assms(2)]"], ["proof (prove)\nusing this:\n  hausdorff_distance (f ` {a..b}) G = 0\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> lambda\\<^sup>2 * (11 / 2 * C + 92 * deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The full statement of the Morse-Gromov Theorem, asserting that a quasi-geodesic is\nwithin controlled distance of a geodesic with the same endpoints. It is given in the formulation\nof Shchur~\\cite{shchur}, with optimal control in terms of the parameters of the quasi-isometry.\nThis statement follows readily from the previous one and from the fact that quasi-geodesics can be\napproximated by Lipschitz ones.\\<close>"], ["", "theorem (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem:\n  fixes f::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {a..b} f\"\n          \"geodesic_segment_between G (f a) (f b)\"\n  shows \"hausdorff_distance (f`{a..b}) G \\<le> 92 * lambda^2 * (C + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have C: \"C \\<ge> 0\" \"lambda \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 1 \\<le> lambda", "using quasi_isometry_onD[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  \\<lbrakk>?x \\<in> {a..b}; ?y \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> 1 / lambda * dist ?x ?y - C \\<le> dist (f ?x) (f ?y)\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 1 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "consider \"dist (f a) (f b) \\<ge> 2 * C \\<and> a \\<le> b\" | \"dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\" | \"b < a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n             thesis;\n     dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow> thesis;\n     b < a \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n           ?thesis;\n   dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow> ?thesis;\n   b < a \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n           ?thesis;\n   dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow> ?thesis;\n   b < a \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n           ?thesis;\n   dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow> ?thesis;\n   b < a \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "case 1"], ["proof (state)\nthis:\n  2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"\\<exists>d. continuous_on {a..b} d \\<and> d a = f a \\<and> d b = f b\n                \\<and> (\\<forall>x\\<in>{a..b}. dist (f x) (d x) \\<le> 4 * C)\n                \\<and> lambda (4 * C)-quasi_isometry_on {a..b} d\n                \\<and> (2 * lambda)-lipschitz_on {a..b} d\n                \\<and> hausdorff_distance (f`{a..b}) (d`{a..b}) \\<le> 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       continuous_on {a..b} d \\<and>\n       d a = f a \\<and>\n       d b = f b \\<and>\n       (\\<forall>x\\<in>{a..b}. dist (f x) (d x) \\<le> 4 * C) \\<and>\n       lambda (4 * C) -quasi_isometry_on {a..b} d \\<and>\n       (2 * lambda)-lipschitz_on {a..b} d \\<and>\n       hausdorff_distance (f ` {a..b}) (d ` {a..b}) \\<le> 2 * C", "apply (rule quasi_geodesic_made_lipschitz[OF assms(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * C \\<le> dist (f a) (f b)", "using 1"], ["proof (prove)\nusing this:\n  2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b\n\ngoal (1 subgoal):\n 1. 2 * C \\<le> dist (f a) (f b)", "by auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     continuous_on {a..b} d \\<and>\n     d a = f a \\<and>\n     d b = f b \\<and>\n     (\\<forall>x\\<in>{a..b}. dist (f x) (d x) \\<le> 4 * C) \\<and>\n     lambda (4 * C) -quasi_isometry_on {a..b} d \\<and>\n     (2 * lambda)-lipschitz_on {a..b} d \\<and>\n     hausdorff_distance (f ` {a..b}) (d ` {a..b}) \\<le> 2 * C\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  \\<exists>d.\n     continuous_on {a..b} d \\<and>\n     d a = f a \\<and>\n     d b = f b \\<and>\n     (\\<forall>x\\<in>{a..b}. dist (f x) (d x) \\<le> 4 * C) \\<and>\n     lambda (4 * C) -quasi_isometry_on {a..b} d \\<and>\n     (2 * lambda)-lipschitz_on {a..b} d \\<and>\n     hausdorff_distance (f ` {a..b}) (d ` {a..b}) \\<le> 2 * C", "obtain d where d: \"d a = f a\" \"d b = f b\"\n                        \"\\<And>x. x \\<in> {a..b} \\<Longrightarrow> dist (f x) (d x) \\<le> 4 * C\"\n                        \"lambda (4 * C)-quasi_isometry_on {a..b} d\"\n                        \"(2 * lambda)-lipschitz_on {a..b} d\"\n                        \"hausdorff_distance (f`{a..b}) (d`{a..b}) \\<le> 2 * C\""], ["proof (prove)\nusing this:\n  \\<exists>d.\n     continuous_on {a..b} d \\<and>\n     d a = f a \\<and>\n     d b = f b \\<and>\n     (\\<forall>x\\<in>{a..b}. dist (f x) (d x) \\<le> 4 * C) \\<and>\n     lambda (4 * C) -quasi_isometry_on {a..b} d \\<and>\n     (2 * lambda)-lipschitz_on {a..b} d \\<and>\n     hausdorff_distance (f ` {a..b}) (d ` {a..b}) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d a = f a; d b = f b;\n         \\<And>x.\n            x \\<in> {a..b} \\<Longrightarrow> dist (f x) (d x) \\<le> 4 * C;\n         lambda (4 * C) -quasi_isometry_on {a..b} d;\n         (2 * lambda)-lipschitz_on {a..b} d;\n         hausdorff_distance (f ` {a..b}) (d ` {a..b}) \\<le> 2 * C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d a = f a\n  d b = f b\n  ?x \\<in> {a..b} \\<Longrightarrow> dist (f ?x) (d ?x) \\<le> 4 * C\n  lambda (4 * C) -quasi_isometry_on {a..b} d\n  (2 * lambda)-lipschitz_on {a..b} d\n  hausdorff_distance (f ` {a..b}) (d ` {a..b}) \\<le> 2 * C\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have a: \"hausdorff_distance (d`{a..b}) G \\<le> lambda^2 * ((11/2) * (4 * C) + 92 * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (d ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a))", "apply (rule Morse_Gromov_theorem_aux2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {a..b} d\n 2. lambda (4 * C) -quasi_isometry_on {a..b} d\n 3. geodesic_segment_between G (d a) (d b)", "using d assms lipschitz_on_continuous_on"], ["proof (prove)\nusing this:\n  d a = f a\n  d b = f b\n  ?x \\<in> {a..b} \\<Longrightarrow> dist (f ?x) (d ?x) \\<le> 4 * C\n  lambda (4 * C) -quasi_isometry_on {a..b} d\n  (2 * lambda)-lipschitz_on {a..b} d\n  hausdorff_distance (f ` {a..b}) (d ` {a..b}) \\<le> 2 * C\n  lambda C -quasi_isometry_on {a..b} f\n  geodesic_segment_between G (f a) (f b)\n  ?L-lipschitz_on ?X ?f \\<Longrightarrow> continuous_on ?X ?f\n\ngoal (3 subgoals):\n 1. continuous_on {a..b} d\n 2. lambda (4 * C) -quasi_isometry_on {a..b} d\n 3. geodesic_segment_between G (d a) (d b)", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (d ` {a..b}) G\n  \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a))\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"hausdorff_distance (f`{a..b}) G \\<le>\n          hausdorff_distance (f`{a..b}) (d`{a..b}) + hausdorff_distance (d`{a..b}) G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> hausdorff_distance (f ` {a..b}) (d ` {a..b}) +\n          hausdorff_distance (d ` {a..b}) G", "apply (rule hausdorff_distance_triangle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d ` {a..b} \\<noteq> {}\n 2. bounded (d ` {a..b})", "using 1"], ["proof (prove)\nusing this:\n  2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b\n\ngoal (2 subgoals):\n 1. d ` {a..b} \\<noteq> {}\n 2. bounded (d ` {a..b})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (d ` {a..b})", "by (rule quasi_isometry_on_bounded[OF d(4)], auto)"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> hausdorff_distance (f ` {a..b}) (d ` {a..b}) +\n        hausdorff_distance (d ` {a..b}) G\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> hausdorff_distance (f ` {a..b}) (d ` {a..b}) +\n        hausdorff_distance (d ` {a..b}) G\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> lambda^2 * ((11/2) * (4 * C) + 92 * deltaG(TYPE('a))) + 1 * 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) (d ` {a..b}) +\n    hausdorff_distance (d ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n          1 * 2 * C", "using a d"], ["proof (prove)\nusing this:\n  hausdorff_distance (d ` {a..b}) G\n  \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a))\n  d a = f a\n  d b = f b\n  ?x \\<in> {a..b} \\<Longrightarrow> dist (f ?x) (d ?x) \\<le> 4 * C\n  lambda (4 * C) -quasi_isometry_on {a..b} d\n  (2 * lambda)-lipschitz_on {a..b} d\n  hausdorff_distance (f ` {a..b}) (d ` {a..b}) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) (d ` {a..b}) +\n    hausdorff_distance (d ` {a..b}) G\n    \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n          1 * 2 * C", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) (d ` {a..b}) +\n  hausdorff_distance (d ` {a..b}) G\n  \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n        1 * 2 * C\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) (d ` {a..b}) +\n  hausdorff_distance (d ` {a..b}) G\n  \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n        1 * 2 * C\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> lambda^2 * ((11/2) * (4 * C) + 92 * deltaG(TYPE('a))) + lambda^2 * 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) + 1 * 2 * C\n    \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n          lambda\\<^sup>2 * 2 * C", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> 2\n 3. 0 \\<le> C", "using \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (3 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> 2\n 3. 0 \\<le> C", "by auto"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) + 1 * 2 * C\n  \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n        lambda\\<^sup>2 * 2 * C\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) + 1 * 2 * C\n  \\<le> lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n        lambda\\<^sup>2 * 2 * C\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... = lambda^2 * (24 * C + 92 * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n    lambda\\<^sup>2 * 2 * C =\n    lambda\\<^sup>2 * (24 * C + 92 * deltaG TYPE('a))", "by (simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n  lambda\\<^sup>2 * 2 * C =\n  lambda\\<^sup>2 * (24 * C + 92 * deltaG TYPE('a))\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (11 / 2 * (4 * C) + 92 * deltaG TYPE('a)) +\n  lambda\\<^sup>2 * 2 * C =\n  lambda\\<^sup>2 * (24 * C + 92 * deltaG TYPE('a))\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> lambda^2 * (92 * C + 92 * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda\\<^sup>2 * (24 * C + 92 * deltaG TYPE('a))\n    \\<le> lambda\\<^sup>2 * (92 * C + 92 * deltaG TYPE('a))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 24 \\<le> 92\n 2. 0 \\<le> C\n 3. 0 \\<le> lambda\\<^sup>2", "using \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (3 subgoals):\n 1. 24 \\<le> 92\n 2. 0 \\<le> C\n 3. 0 \\<le> lambda\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  lambda\\<^sup>2 * (24 * C + 92 * deltaG TYPE('a))\n  \\<le> lambda\\<^sup>2 * (92 * C + 92 * deltaG TYPE('a))\n\ngoal (3 subgoals):\n 1. 2 * C \\<le> dist (f a) (f b) \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "finally"], ["proof (chain)\npicking this:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> lambda\\<^sup>2 * (92 * C + 92 * deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\nusing this:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> lambda\\<^sup>2 * (92 * C + 92 * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "case 2"], ["proof (state)\nthis:\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n\ngoal (2 subgoals):\n 1. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"(1/lambda) * dist a b - C \\<le> dist (f a) (f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / lambda * dist a b - C \\<le> dist (f a) (f b)", "apply (rule quasi_isometry_onD[OF assms(1)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. a \\<in> {a..b}\n 2. b \\<in> {a..b}", "using 2"], ["proof (prove)\nusing this:\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n\ngoal (2 subgoals):\n 1. a \\<in> {a..b}\n 2. b \\<in> {a..b}", "by auto"], ["proof (state)\nthis:\n  1 / lambda * dist a b - C \\<le> dist (f a) (f b)\n\ngoal (2 subgoals):\n 1. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  1 / lambda * dist a b - C \\<le> dist (f a) (f b)\n\ngoal (2 subgoals):\n 1. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f a) (f b) \\<le> 2 * C", "using 2"], ["proof (prove)\nusing this:\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n\ngoal (1 subgoal):\n 1. dist (f a) (f b) \\<le> 2 * C", "by auto"], ["proof (state)\nthis:\n  dist (f a) (f b) \\<le> 2 * C\n\ngoal (2 subgoals):\n 1. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "finally"], ["proof (chain)\npicking this:\n  1 / lambda * dist a b - C \\<le> 2 * C", "have \"dist a b \\<le> 3 * lambda * C\""], ["proof (prove)\nusing this:\n  1 / lambda * dist a b - C \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. dist a b \\<le> 3 * lambda * C", "using C"], ["proof (prove)\nusing this:\n  1 / lambda * dist a b - C \\<le> 2 * C\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. dist a b \\<le> 3 * lambda * C", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  dist a b \\<le> 3 * lambda * C\n\ngoal (2 subgoals):\n 1. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  dist a b \\<le> 3 * lambda * C", "have *: \"b - a \\<le> 3 * lambda * C\""], ["proof (prove)\nusing this:\n  dist a b \\<le> 3 * lambda * C\n\ngoal (1 subgoal):\n 1. b - a \\<le> 3 * lambda * C", "using 2"], ["proof (prove)\nusing this:\n  dist a b \\<le> 3 * lambda * C\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n\ngoal (1 subgoal):\n 1. b - a \\<le> 3 * lambda * C", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  \\<bar>a - b\\<bar> \\<le> 3 * lambda * C\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n\ngoal (1 subgoal):\n 1. b - a \\<le> 3 * lambda * C", "by auto"], ["proof (state)\nthis:\n  b - a \\<le> 3 * lambda * C\n\ngoal (2 subgoals):\n 1. dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "proof (rule hausdorff_distanceI2)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 3. 0 \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "show \"0 \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  0 \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "assume \"x \\<in> f`{a..b}\""], ["proof (state)\nthis:\n  x \\<in> f ` {a..b}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  x \\<in> f ` {a..b}", "obtain t where t: \"x = f t\" \"t \\<in> {a..b}\""], ["proof (prove)\nusing this:\n  x \\<in> f ` {a..b}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x = f t; t \\<in> {a..b}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = f t\n  t \\<in> {a..b}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"dist x (f a) \\<le> lambda * dist t a + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (f a) \\<le> lambda * dist t a + C", "unfolding t(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f t) (f a) \\<le> lambda * dist t a + C", "using quasi_isometry_onD(1)[OF assms(1) t(2)] 2"], ["proof (prove)\nusing this:\n  ?y \\<in> {a..b} \\<Longrightarrow>\n  dist (f t) (f ?y) \\<le> lambda * dist t ?y + C\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n\ngoal (1 subgoal):\n 1. dist (f t) (f a) \\<le> lambda * dist t a + C", "by auto"], ["proof (state)\nthis:\n  dist x (f a) \\<le> lambda * dist t a + C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  dist x (f a) \\<le> lambda * dist t a + C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> lambda * (b - a) + 1 * 1 * C + 0 * 0 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * dist t a + C\n    \\<le> lambda * (b - a) + 1 * 1 * C + 0 * 0 * deltaG TYPE('a)", "using t(2) 2 C"], ["proof (prove)\nusing this:\n  t \\<in> {a..b}\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. lambda * dist t a + C\n    \\<le> lambda * (b - a) + 1 * 1 * C + 0 * 0 * deltaG TYPE('a)", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  t \\<in> {a..b}\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. lambda * \\<bar>t - a\\<bar> + C\n    \\<le> lambda * (b - a) + 1 * 1 * C + 0 * 0 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  lambda * dist t a + C\n  \\<le> lambda * (b - a) + 1 * 1 * C + 0 * 0 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  lambda * dist t a + C\n  \\<le> lambda * (b - a) + 1 * 1 * C + 0 * 0 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> lambda * (3 * lambda * C) + lambda^2 * (92-3) * C + lambda^2 * 92 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (b - a) + 1 * 1 * C + 0 * 0 * deltaG TYPE('a)\n    \\<le> lambda * (3 * lambda * C) + lambda\\<^sup>2 * (92 - 3) * C +\n          lambda\\<^sup>2 * 92 * deltaG TYPE('a)", "apply (intro mono_intros *)"], ["proof (prove)\ngoal (10 subgoals):\n 1. 0 \\<le> lambda\n 2. 1 \\<le> lambda\\<^sup>2\n 3. 1 \\<le> 92 - 3\n 4. 0 \\<le> lambda\\<^sup>2\n 5. 0 \\<le> 1\n 6. 0 \\<le> C\n 7. 0 \\<le> lambda\\<^sup>2\n 8. 0 \\<le> 92\n 9. 0 \\<le> lambda\\<^sup>2\n 10. 0 \\<le> 0", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (10 subgoals):\n 1. 0 \\<le> lambda\n 2. 1 \\<le> lambda\\<^sup>2\n 3. 1 \\<le> 92 - 3\n 4. 0 \\<le> lambda\\<^sup>2\n 5. 0 \\<le> 1\n 6. 0 \\<le> C\n 7. 0 \\<le> lambda\\<^sup>2\n 8. 0 \\<le> 92\n 9. 0 \\<le> lambda\\<^sup>2\n 10. 0 \\<le> 0", "by auto"], ["proof (state)\nthis:\n  lambda * (b - a) + 1 * 1 * C + 0 * 0 * deltaG TYPE('a)\n  \\<le> lambda * (3 * lambda * C) + lambda\\<^sup>2 * (92 - 3) * C +\n        lambda\\<^sup>2 * 92 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "finally"], ["proof (chain)\npicking this:\n  dist x (f a)\n  \\<le> lambda * (3 * lambda * C) + lambda\\<^sup>2 * (92 - 3) * C +\n        lambda\\<^sup>2 * 92 * deltaG TYPE('a)", "have *: \"dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\""], ["proof (prove)\nusing this:\n  dist x (f a)\n  \\<le> lambda * (3 * lambda * C) + lambda\\<^sup>2 * (92 - 3) * C +\n        lambda\\<^sup>2 * 92 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> f ` {a..b} \\<Longrightarrow>\n       \\<exists>y\\<in>G.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "show \"\\<exists>y\\<in>G. dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>G.\n       dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "apply (rule bexI[of _ \"f a\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. f a \\<in> G", "using * 2 assms(2)"], ["proof (prove)\nusing this:\n  dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n  geodesic_segment_between G (f a) (f b)\n\ngoal (2 subgoals):\n 1. dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. f a \\<in> G", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>G.\n     dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "assume \"x \\<in> G\""], ["proof (state)\nthis:\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  x \\<in> G", "have \"dist x (f a) \\<le> dist (f a) (f b)\""], ["proof (prove)\nusing this:\n  x \\<in> G\n\ngoal (1 subgoal):\n 1. dist x (f a) \\<le> dist (f a) (f b)", "by (meson assms geodesic_segment_dist_le geodesic_segment_endpoints(1) local.some_geodesic_is_geodesic_segment(1))"], ["proof (state)\nthis:\n  dist x (f a) \\<le> dist (f a) (f b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  dist x (f a) \\<le> dist (f a) (f b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> 1 * 2 * C + lambda^2 * 0 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f a) (f b) \\<le> 1 * 2 * C + lambda\\<^sup>2 * 0 * deltaG TYPE('a)", "using 2"], ["proof (prove)\nusing this:\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n\ngoal (1 subgoal):\n 1. dist (f a) (f b) \\<le> 1 * 2 * C + lambda\\<^sup>2 * 0 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  dist (f a) (f b) \\<le> 1 * 2 * C + lambda\\<^sup>2 * 0 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "also"], ["proof (state)\nthis:\n  dist (f a) (f b) \\<le> 1 * 2 * C + lambda\\<^sup>2 * 0 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"... \\<le> lambda^2 * 92 * C + lambda^2 * 92 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 2 * C + lambda\\<^sup>2 * 0 * deltaG TYPE('a)\n    \\<le> lambda\\<^sup>2 * 92 * C + lambda\\<^sup>2 * 92 * deltaG TYPE('a)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (7 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 2 \\<le> 92\n 3. 0 \\<le> lambda\\<^sup>2\n 4. 0 \\<le> 2\n 5. 0 \\<le> C\n 6. 0 \\<le> 92\n 7. 0 \\<le> lambda\\<^sup>2", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (7 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 2 \\<le> 92\n 3. 0 \\<le> lambda\\<^sup>2\n 4. 0 \\<le> 2\n 5. 0 \\<le> C\n 6. 0 \\<le> 92\n 7. 0 \\<le> lambda\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  1 * 2 * C + lambda\\<^sup>2 * 0 * deltaG TYPE('a)\n  \\<le> lambda\\<^sup>2 * 92 * C + lambda\\<^sup>2 * 92 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "finally"], ["proof (chain)\npicking this:\n  dist x (f a)\n  \\<le> lambda\\<^sup>2 * 92 * C + lambda\\<^sup>2 * 92 * deltaG TYPE('a)", "have *: \"dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\""], ["proof (prove)\nusing this:\n  dist x (f a)\n  \\<le> lambda\\<^sup>2 * 92 * C + lambda\\<^sup>2 * 92 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> G \\<Longrightarrow>\n       \\<exists>y\\<in>f ` {a..b}.\n          dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "show \"\\<exists>y\\<in>f`{a..b}. dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>f ` {a..b}.\n       dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "apply (rule bexI[of _ \"f a\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. f a \\<in> f ` {a..b}", "using * 2"], ["proof (prove)\nusing this:\n  dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n  dist (f a) (f b) \\<le> 2 * C \\<and> a \\<le> b\n\ngoal (2 subgoals):\n 1. dist x (f a) \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. f a \\<in> f ` {a..b}", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>f ` {a..b}.\n     dist x y \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "case 3"], ["proof (state)\nthis:\n  b < a\n\ngoal (1 subgoal):\n 1. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  b < a", "have \"hausdorff_distance (f ` {a..b}) G = 0\""], ["proof (prove)\nusing this:\n  b < a\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G = 0", "unfolding hausdorff_distance_def"], ["proof (prove)\nusing this:\n  b < a\n\ngoal (1 subgoal):\n 1. (if f ` {a..b} = {} \\<or>\n        G = {} \\<or> \\<not> bounded (f ` {a..b}) \\<or> \\<not> bounded G\n     then 0\n     else max (SUP x\\<in>f ` {a..b}. infdist x G)\n           (SUP x\\<in>G. infdist x (f ` {a..b}))) =\n    0", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G = 0\n\ngoal (1 subgoal):\n 1. b < a \\<Longrightarrow>\n    hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  hausdorff_distance (f ` {a..b}) G = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  hausdorff_distance (f ` {a..b}) G = 0\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "using C"], ["proof (prove)\nusing this:\n  hausdorff_distance (f ` {a..b}) G = 0\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` {a..b}) G\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hausdorff_distance (f ` {a..b}) G\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This theorem implies the same statement for two quasi-geodesics sharing their endpoints.\\<close>"], ["", "theorem (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem2:\n  fixes c d::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {A..B} c\"\n          \"lambda C-quasi_isometry_on {A..B} d\"\n          \"c A = d A\" \"c B = d B\"\n  shows \"hausdorff_distance (c`{A..B}) (d`{A..B}) \\<le> 184 * lambda^2 * (C + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "proof (cases \"A \\<le> B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<not> A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "case False"], ["proof (state)\nthis:\n  \\<not> A \\<le> B\n\ngoal (2 subgoals):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<not> A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  \\<not> A \\<le> B", "have \"hausdorff_distance (c`{A..B}) (d`{A..B}) = 0\""], ["proof (prove)\nusing this:\n  \\<not> A \\<le> B\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B}) = 0", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) = 0\n\ngoal (2 subgoals):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n 2. \\<not> A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "then"], ["proof (chain)\npicking this:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) = 0\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "using quasi_isometry_onD[OF assms(1)] delta_nonneg"], ["proof (prove)\nusing this:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) = 0\n  \\<lbrakk>?x \\<in> {A..B}; ?y \\<in> {A..B}\\<rbrakk>\n  \\<Longrightarrow> dist (c ?x) (c ?y) \\<le> lambda * dist ?x ?y + C\n  \\<lbrakk>?x \\<in> {A..B}; ?y \\<in> {A..B}\\<rbrakk>\n  \\<Longrightarrow> 1 / lambda * dist ?x ?y - C \\<le> dist (c ?x) (c ?y)\n  1 \\<le> lambda\n  0 \\<le> C\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B})\n  \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "case True"], ["proof (state)\nthis:\n  A \\<le> B\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"hausdorff_distance (c`{A..B}) {c A--c B} \\<le> 92 * lambda^2 * (C + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by (rule Morse_Gromov_theorem[OF assms(1)], auto)"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "moreover"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"hausdorff_distance {c A--c B} (d`{A..B}) \\<le> 92 * lambda^2 * (C + deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance {c A--c B} (d ` {A..B})\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "unfolding \\<open>c A = d A\\<close> \\<open>c B = d B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance {d A--d B} (d ` {A..B})\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "apply (subst hausdorff_distance_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (d ` {A..B}) {d A--d B}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by (rule Morse_Gromov_theorem[OF assms(2)], auto)"], ["proof (state)\nthis:\n  hausdorff_distance {c A--c B} (d ` {A..B})\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "moreover"], ["proof (state)\nthis:\n  hausdorff_distance {c A--c B} (d ` {A..B})\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "have \"hausdorff_distance (c`{A..B}) (d`{A..B}) \\<le> hausdorff_distance (c`{A..B}) {c A--c B} + hausdorff_distance {c A--c B} (d`{A..B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> hausdorff_distance (c ` {A..B}) {c A--c B} +\n          hausdorff_distance {c A--c B} (d ` {A..B})", "apply (rule hausdorff_distance_triangle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {c A--c B} \\<noteq> {}\n 2. bounded {c A--c B}", "using True compact_imp_bounded[OF some_geodesic_compact]"], ["proof (prove)\nusing this:\n  A \\<le> B\n  bounded {?x1--?S1--?y1}\n\ngoal (2 subgoals):\n 1. {c A--c B} \\<noteq> {}\n 2. bounded {c A--c B}", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B})\n  \\<le> hausdorff_distance (c ` {A..B}) {c A--c B} +\n        hausdorff_distance {c A--c B} (d ` {A..B})\n\ngoal (1 subgoal):\n 1. A \\<le> B \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "ultimately"], ["proof (chain)\npicking this:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n  hausdorff_distance {c A--c B} (d ` {A..B})\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n  hausdorff_distance (c ` {A..B}) (d ` {A..B})\n  \\<le> hausdorff_distance (c ` {A..B}) {c A--c B} +\n        hausdorff_distance {c A--c B} (d ` {A..B})", "show ?thesis"], ["proof (prove)\nusing this:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n  hausdorff_distance {c A--c B} (d ` {A..B})\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n  hausdorff_distance (c ` {A..B}) (d ` {A..B})\n  \\<le> hausdorff_distance (c ` {A..B}) {c A--c B} +\n        hausdorff_distance {c A--c B} (d ` {A..B})\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B})\n    \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B})\n  \\<le> 184 * lambda\\<^sup>2 * (C + deltaG TYPE('a))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We deduce from the Morse lemma that hyperbolicity is invariant under quasi-isometry.\\<close>"], ["", "text \\<open>First, we note that the image of a geodesic segment under a quasi-isometry is close to\na geodesic segment in Hausdorff distance, as it is a quasi-geodesic.\\<close>"], ["", "lemma geodesic_quasi_isometric_image:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::Gromov_hyperbolic_space_geodesic\"\n  assumes \"lambda C-quasi_isometry_on UNIV f\"\n          \"geodesic_segment_between G x y\"\n  shows \"hausdorff_distance (f`G) {f x--f y} \\<le> 92 * lambda^2 * (C + deltaG(TYPE('b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "define c where \"c = f o (geodesic_segment_param G x)\""], ["proof (state)\nthis:\n  c = f \\<circ> geodesic_segment_param G x\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "have *: \"(1 * lambda) (0 * lambda + C)-quasi_isometry_on {0..dist x y} c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 * lambda) (0 * lambda + C) -quasi_isometry_on {0..dist x y} c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 * lambda) (0 * lambda + C) -quasi_isometry_on {0..dist x y}\n     (f \\<circ> geodesic_segment_param G x)", "by (rule quasi_isometry_on_compose[where Y = UNIV], auto intro!: isometry_quasi_isometry_on simp add: assms)"], ["proof (state)\nthis:\n  (1 * lambda) (0 * lambda + C) -quasi_isometry_on {0..dist x y} c\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "have \"hausdorff_distance (c`{0..dist x y}) {c 0--c (dist x y)} \\<le> 92 * lambda^2 * (C + deltaG(TYPE('b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {0..dist x y}) {c 0--c (dist x y)}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "apply (rule Morse_Gromov_theorem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. lambda C -quasi_isometry_on {0..dist x y} c\n 2. geodesic_segment_between {c 0--c (dist x y)} (c 0) (c (dist x y))", "using *"], ["proof (prove)\nusing this:\n  (1 * lambda) (0 * lambda + C) -quasi_isometry_on {0..dist x y} c\n\ngoal (2 subgoals):\n 1. lambda C -quasi_isometry_on {0..dist x y} c\n 2. geodesic_segment_between {c 0--c (dist x y)} (c 0) (c (dist x y))", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {0..dist x y}) {c 0--c (dist x y)}\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "moreover"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {0..dist x y}) {c 0--c (dist x y)}\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "have \"c`{0..dist x y} = f`G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ` {0..dist x y} = f ` G", "unfolding c_def image_comp[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` geodesic_segment_param G x ` {0..dist x y} = f ` G", "using assms(2)"], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n\ngoal (1 subgoal):\n 1. f ` geodesic_segment_param G x ` {0..dist x y} = f ` G", "by auto"], ["proof (state)\nthis:\n  c ` {0..dist x y} = f ` G\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "moreover"], ["proof (state)\nthis:\n  c ` {0..dist x y} = f ` G\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "have \"c 0 = f x\" \"c (dist x y) = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c 0 = f x &&& c (dist x y) = f y", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> geodesic_segment_param G x) 0 = f x &&&\n    (f \\<circ> geodesic_segment_param G x) (dist x y) = f y", "using assms(2)"], ["proof (prove)\nusing this:\n  geodesic_segment_between G x y\n\ngoal (1 subgoal):\n 1. (f \\<circ> geodesic_segment_param G x) 0 = f x &&&\n    (f \\<circ> geodesic_segment_param G x) (dist x y) = f y", "by auto"], ["proof (state)\nthis:\n  c 0 = f x\n  c (dist x y) = f y\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "ultimately"], ["proof (chain)\npicking this:\n  hausdorff_distance (c ` {0..dist x y}) {c 0--c (dist x y)}\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))\n  c ` {0..dist x y} = f ` G\n  c 0 = f x\n  c (dist x y) = f y", "show ?thesis"], ["proof (prove)\nusing this:\n  hausdorff_distance (c ` {0..dist x y}) {c 0--c (dist x y)}\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))\n  c ` {0..dist x y} = f ` G\n  c 0 = f x\n  c (dist x y) = f y\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f x--f y}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (f ` G) {f x--f y}\n  \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We deduce that hyperbolicity is invariant under quasi-isometry. The proof goes as follows:\nwe want to see that a geodesic triangle is delta-thin, i.e., a point on a side $Gxy$ is close to the\nunion of the two other sides $Gxz$ and $Gyz$. Pull everything back by the quasi-isometry: we obtain\nthree quasi-geodesic, each of which is close to the corresponding geodesic segment by the Morse lemma.\nAs the geodesic triangle is thin, it follows that the quasi-geodesic triangle is also thin, i.e.,\na point on $f^{-1}Gxy$ is close to $f^{-1}Gxz \\cup f^{-1}Gyz$ (for some explicit, albeit large,\nconstant). Then push everything forward by $f$: as it is a quasi-isometry, it will again distort\ndistances by a bounded amount.\\<close>"], ["", "lemma Gromov_hyperbolic_invariant_under_quasi_isometry_explicit:\n  fixes f::\"'a::geodesic_space \\<Rightarrow> 'b::Gromov_hyperbolic_space_geodesic\"\n  assumes \"lambda C-quasi_isometry f\"\n  shows \"Gromov_hyperbolic_subset (752 * lambda^3 * (C + deltaG(TYPE('b)))) (UNIV::('a set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "have C: \"lambda \\<ge> 1\" \"C \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> lambda &&& 0 \\<le> C", "using quasi_isometry_onD[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> UNIV; ?y \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  \\<lbrakk>?x \\<in> UNIV; ?y \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> 1 / lambda * dist ?x ?y - C \\<le> dist (f ?x) (f ?y)\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 1 \\<le> lambda &&& 0 \\<le> C", "by auto"], ["proof (state)\nthis:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "text \\<open>The Morse lemma gives a control bounded by $K$ below. Following the proof, we deduce\n  a bound on the thinness of triangles by an ugly constant $L$. We bound it by a more tractable\n  (albeit still ugly) constant $M$.\\<close>"], ["proof (state)\nthis:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "define K where \"K = 92 * lambda^2 * (C + deltaG(TYPE('b)))\""], ["proof (state)\nthis:\n  K = 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "have HD: \"hausdorff_distance (f`G) {f a--f b} \\<le> K\" if \"geodesic_segment_between G a b\" for G a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f a--f b} \\<le> K", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` G) {f a--f b}\n    \\<le> 92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))", "by (rule geodesic_quasi_isometric_image[OF assms that])"], ["proof (state)\nthis:\n  geodesic_segment_between ?G ?a ?b \\<Longrightarrow>\n  hausdorff_distance (f ` ?G) {f ?a--f ?b} \\<le> K\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "define L where \"L = lambda * (4 * 1 * deltaG(TYPE('b)) + 1 * 1 * C + 2 * K)\""], ["proof (state)\nthis:\n  L = lambda * (4 * 1 * deltaG TYPE('b) + 1 * 1 * C + 2 * K)\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "define M where \"M = 188 * lambda^3 * (C + deltaG(TYPE('b)))\""], ["proof (state)\nthis:\n  M = 188 * lambda ^ 3 * (C + deltaG TYPE('b))\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "have \"L \\<le> lambda * (4 * lambda^2 * deltaG(TYPE('b)) + 4 * lambda^2 * C + 2 * K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<le> lambda *\n            (4 * lambda\\<^sup>2 * deltaG TYPE('b) + 4 * lambda\\<^sup>2 * C +\n             2 * K)", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (4 * 1 * deltaG TYPE('b) + 1 * 1 * C + 2 * K)\n    \\<le> lambda *\n          (4 * lambda\\<^sup>2 * deltaG TYPE('b) + 4 * lambda\\<^sup>2 * C +\n           2 * K)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (8 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> 4\n 3. 1 \\<le> 4\n 4. 1 \\<le> lambda\\<^sup>2\n 5. 0 \\<le> 4\n 6. 0 \\<le> 1\n 7. 0 \\<le> C\n 8. 0 \\<le> lambda", "using C"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (8 subgoals):\n 1. 1 \\<le> lambda\\<^sup>2\n 2. 0 \\<le> 4\n 3. 1 \\<le> 4\n 4. 1 \\<le> lambda\\<^sup>2\n 5. 0 \\<le> 4\n 6. 0 \\<le> 1\n 7. 0 \\<le> C\n 8. 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  L \\<le> lambda *\n          (4 * lambda\\<^sup>2 * deltaG TYPE('b) + 4 * lambda\\<^sup>2 * C +\n           2 * K)\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "also"], ["proof (state)\nthis:\n  L \\<le> lambda *\n          (4 * lambda\\<^sup>2 * deltaG TYPE('b) + 4 * lambda\\<^sup>2 * C +\n           2 * K)\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "have \"... = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    (4 * lambda\\<^sup>2 * deltaG TYPE('b) + 4 * lambda\\<^sup>2 * C +\n     2 * K) =\n    M", "unfolding M_def K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    (4 * lambda\\<^sup>2 * deltaG TYPE('b) + 4 * lambda\\<^sup>2 * C +\n     2 * (92 * lambda\\<^sup>2 * (C + deltaG TYPE('b)))) =\n    188 * lambda ^ 3 * (C + deltaG TYPE('b))", "by (auto simp add: algebra_simps power2_eq_square power3_eq_cube)"], ["proof (state)\nthis:\n  lambda *\n  (4 * lambda\\<^sup>2 * deltaG TYPE('b) + 4 * lambda\\<^sup>2 * C + 2 * K) =\n  M\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "finally"], ["proof (chain)\npicking this:\n  L \\<le> M", "have \"L \\<le> M\""], ["proof (prove)\nusing this:\n  L \\<le> M\n\ngoal (1 subgoal):\n 1. L \\<le> M", "by simp"], ["proof (state)\nthis:\n  L \\<le> M\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "text \\<open>After these preliminaries, we start the real argument per se, showing that triangles\n  are thin in the type b.\\<close>"], ["proof (state)\nthis:\n  L \\<le> M\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "have Thin: \"infdist w (Gxz \\<union> Gyz) \\<le> M\" if\n    H: \"geodesic_segment_between Gxy x y\" \"geodesic_segment_between Gxz x z\" \"geodesic_segment_between Gyz y z\" \"w \\<in> Gxy\"\n    for w x y z::'a and Gxy Gyz Gxz"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "obtain w2 where w2: \"w2 \\<in> {f x--f y}\" \"infdist (f w) {f x--f y} = dist (f w) w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w2.\n        \\<lbrakk>w2 \\<in> {f x--f y};\n         infdist (f w) {f x--f y} = dist (f w) w2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using infdist_proper_attained[OF proper_of_compact, of \"{f x--f y}\" \"f w\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>compact {f x--f y}; {f x--f y} \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>{f x--f y}.\n                       infdist (f w) {f x--f y} = dist (f w) c\n\ngoal (1 subgoal):\n 1. (\\<And>w2.\n        \\<lbrakk>w2 \\<in> {f x--f y};\n         infdist (f w) {f x--f y} = dist (f w) w2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w2 \\<in> {f x--f y}\n  infdist (f w) {f x--f y} = dist (f w) w2\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "have \"dist (f w) w2 = infdist (f w) {f x-- f y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (f w) w2 = infdist (f w) {f x--f y}", "using w2"], ["proof (prove)\nusing this:\n  w2 \\<in> {f x--f y}\n  infdist (f w) {f x--f y} = dist (f w) w2\n\ngoal (1 subgoal):\n 1. dist (f w) w2 = infdist (f w) {f x--f y}", "by simp"], ["proof (state)\nthis:\n  dist (f w) w2 = infdist (f w) {f x--f y}\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "also"], ["proof (state)\nthis:\n  dist (f w) w2 = infdist (f w) {f x--f y}\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "have \"... \\<le> hausdorff_distance (f`Gxy) {f x-- f y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f w) {f x--f y} \\<le> hausdorff_distance (f ` Gxy) {f x--f y}", "using geodesic_segment_topology(4)[OF geodesic_segmentI] H"], ["proof (prove)\nusing this:\n  geodesic_segment_between ?G ?x1 ?y1 \\<Longrightarrow> bounded ?G\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  geodesic_segment_between Gyz y z\n  w \\<in> Gxy\n\ngoal (1 subgoal):\n 1. infdist (f w) {f x--f y} \\<le> hausdorff_distance (f ` Gxy) {f x--f y}", "by (auto intro!: quasi_isometry_on_bounded[OF quasi_isometry_on_subset[OF assms]] infdist_le_hausdorff_distance)"], ["proof (state)\nthis:\n  infdist (f w) {f x--f y} \\<le> hausdorff_distance (f ` Gxy) {f x--f y}\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "also"], ["proof (state)\nthis:\n  infdist (f w) {f x--f y} \\<le> hausdorff_distance (f ` Gxy) {f x--f y}\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "have \"... \\<le> K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` Gxy) {f x--f y} \\<le> K", "using HD[OF H(1)]"], ["proof (prove)\nusing this:\n  hausdorff_distance (f ` Gxy) {f x--f y} \\<le> K\n\ngoal (1 subgoal):\n 1. hausdorff_distance (f ` Gxy) {f x--f y} \\<le> K", "by simp"], ["proof (state)\nthis:\n  hausdorff_distance (f ` Gxy) {f x--f y} \\<le> K\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "finally"], ["proof (chain)\npicking this:\n  dist (f w) w2 \\<le> K", "have *: \"dist (f w) w2 \\<le> K\""], ["proof (prove)\nusing this:\n  dist (f w) w2 \\<le> K\n\ngoal (1 subgoal):\n 1. dist (f w) w2 \\<le> K", "by simp"], ["proof (state)\nthis:\n  dist (f w) w2 \\<le> K\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "have \"infdist w2 (f`Gxz \\<union> f`Gyz) \\<le> infdist w2 ({f x--f z} \\<union> {f y--f z})\n                + hausdorff_distance ({f x--f z} \\<union> {f y--f z}) (f`Gxz \\<union> f`Gyz)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w2 (f ` Gxz \\<union> f ` Gyz)\n    \\<le> infdist w2 ({f x--f z} \\<union> {f y--f z}) +\n          hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n           (f ` Gxz \\<union> f ` Gyz)", "apply (rule hausdorff_distance_infdist_triangle)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {f x--f z} \\<union> {f y--f z} \\<noteq> {}\n 2. bounded ({f x--f z} \\<union> {f y--f z})\n 3. bounded (f ` Gxz \\<union> f ` Gyz)", "using geodesic_segment_topology(4)[OF geodesic_segmentI] H"], ["proof (prove)\nusing this:\n  geodesic_segment_between ?G ?x1 ?y1 \\<Longrightarrow> bounded ?G\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  geodesic_segment_between Gyz y z\n  w \\<in> Gxy\n\ngoal (3 subgoals):\n 1. {f x--f z} \\<union> {f y--f z} \\<noteq> {}\n 2. bounded ({f x--f z} \\<union> {f y--f z})\n 3. bounded (f ` Gxz \\<union> f ` Gyz)", "by (auto intro!: quasi_isometry_on_bounded[OF quasi_isometry_on_subset[OF assms]])"], ["proof (state)\nthis:\n  infdist w2 (f ` Gxz \\<union> f ` Gyz)\n  \\<le> infdist w2 ({f x--f z} \\<union> {f y--f z}) +\n        hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n         (f ` Gxz \\<union> f ` Gyz)\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "also"], ["proof (state)\nthis:\n  infdist w2 (f ` Gxz \\<union> f ` Gyz)\n  \\<le> infdist w2 ({f x--f z} \\<union> {f y--f z}) +\n        hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n         (f ` Gxz \\<union> f ` Gyz)\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "have \"... \\<le> 4 * deltaG(TYPE('b)) + hausdorff_distance ({f x--f z} \\<union> {f y--f z}) (f`Gxz \\<union> f`Gyz)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w2 ({f x--f z} \\<union> {f y--f z}) +\n    hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n     (f ` Gxz \\<union> f ` Gyz)\n    \\<le> 4 * deltaG TYPE('b) +\n          hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n           (f ` Gxz \\<union> f ` Gyz)", "apply (simp, rule thin_triangles[of \"{f x--f z}\" \"f z\" \"f x\" \"{f y--f z}\" \"f y\" \"{f x--f y}\" w2])"], ["proof (prove)\ngoal (4 subgoals):\n 1. geodesic_segment_between {f x--f z} (f z) (f x)\n 2. geodesic_segment_between {f y--f z} (f z) (f y)\n 3. geodesic_segment_between {f x--f y} (f x) (f y)\n 4. w2 \\<in> {f x--f y}", "using w2"], ["proof (prove)\nusing this:\n  w2 \\<in> {f x--f y}\n  infdist (f w) {f x--f y} = dist (f w) w2\n\ngoal (4 subgoals):\n 1. geodesic_segment_between {f x--f z} (f z) (f x)\n 2. geodesic_segment_between {f y--f z} (f z) (f y)\n 3. geodesic_segment_between {f x--f y} (f x) (f y)\n 4. w2 \\<in> {f x--f y}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w2 \\<in> {f x--f y};\n     infdist (f w) {f x--f y} = dist (f w) w2\\<rbrakk>\n    \\<Longrightarrow> geodesic_segment_between {f x--f z} (f z) (f x)\n 2. \\<lbrakk>w2 \\<in> {f x--f y};\n     infdist (f w) {f x--f y} = dist (f w) w2\\<rbrakk>\n    \\<Longrightarrow> geodesic_segment_between {f y--f z} (f z) (f y)", "using geodesic_segment_commute some_geodesic_is_geodesic_segment(1)"], ["proof (prove)\nusing this:\n  geodesic_segment_between ?G ?x ?y \\<Longrightarrow>\n  geodesic_segment_between ?G ?y ?x\n  geodesic_segment_between {?x--?y} ?x ?y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w2 \\<in> {f x--f y};\n     infdist (f w) {f x--f y} = dist (f w) w2\\<rbrakk>\n    \\<Longrightarrow> geodesic_segment_between {f x--f z} (f z) (f x)\n 2. \\<lbrakk>w2 \\<in> {f x--f y};\n     infdist (f w) {f x--f y} = dist (f w) w2\\<rbrakk>\n    \\<Longrightarrow> geodesic_segment_between {f y--f z} (f z) (f y)", "by blast+"], ["proof (state)\nthis:\n  infdist w2 ({f x--f z} \\<union> {f y--f z}) +\n  hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n   (f ` Gxz \\<union> f ` Gyz)\n  \\<le> 4 * deltaG TYPE('b) +\n        hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n         (f ` Gxz \\<union> f ` Gyz)\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "also"], ["proof (state)\nthis:\n  infdist w2 ({f x--f z} \\<union> {f y--f z}) +\n  hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n   (f ` Gxz \\<union> f ` Gyz)\n  \\<le> 4 * deltaG TYPE('b) +\n        hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n         (f ` Gxz \\<union> f ` Gyz)\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "have \"... \\<le> 4 * deltaG(TYPE('b)) + max (hausdorff_distance {f x--f z} (f`Gxz)) (hausdorff_distance {f y--f z} (f`Gyz))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * deltaG TYPE('b) +\n    hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n     (f ` Gxz \\<union> f ` Gyz)\n    \\<le> 4 * deltaG TYPE('b) +\n          max (hausdorff_distance {f x--f z} (f ` Gxz))\n           (hausdorff_distance {f y--f z} (f ` Gyz))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. {f x--f z} \\<noteq> {}\n 2. {f y--f z} \\<noteq> {}\n 3. f ` Gxz \\<noteq> {}\n 4. f ` Gyz \\<noteq> {}", "using H"], ["proof (prove)\nusing this:\n  geodesic_segment_between Gxy x y\n  geodesic_segment_between Gxz x z\n  geodesic_segment_between Gyz y z\n  w \\<in> Gxy\n\ngoal (4 subgoals):\n 1. {f x--f z} \\<noteq> {}\n 2. {f y--f z} \\<noteq> {}\n 3. f ` Gxz \\<noteq> {}\n 4. f ` Gyz \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  4 * deltaG TYPE('b) +\n  hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n   (f ` Gxz \\<union> f ` Gyz)\n  \\<le> 4 * deltaG TYPE('b) +\n        max (hausdorff_distance {f x--f z} (f ` Gxz))\n         (hausdorff_distance {f y--f z} (f ` Gyz))\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "also"], ["proof (state)\nthis:\n  4 * deltaG TYPE('b) +\n  hausdorff_distance ({f x--f z} \\<union> {f y--f z})\n   (f ` Gxz \\<union> f ` Gyz)\n  \\<le> 4 * deltaG TYPE('b) +\n        max (hausdorff_distance {f x--f z} (f ` Gxz))\n         (hausdorff_distance {f y--f z} (f ` Gyz))\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "have \"... \\<le> 4 * deltaG(TYPE('b)) + K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * deltaG TYPE('b) +\n    max (hausdorff_distance {f x--f z} (f ` Gxz))\n     (hausdorff_distance {f y--f z} (f ` Gyz))\n    \\<le> 4 * deltaG TYPE('b) + K", "using HD[OF H(2)] HD[OF H(3)]"], ["proof (prove)\nusing this:\n  hausdorff_distance (f ` Gxz) {f x--f z} \\<le> K\n  hausdorff_distance (f ` Gyz) {f y--f z} \\<le> K\n\ngoal (1 subgoal):\n 1. 4 * deltaG TYPE('b) +\n    max (hausdorff_distance {f x--f z} (f ` Gxz))\n     (hausdorff_distance {f y--f z} (f ` Gyz))\n    \\<le> 4 * deltaG TYPE('b) + K", "by (auto simp add: hausdorff_distance_sym)"], ["proof (state)\nthis:\n  4 * deltaG TYPE('b) +\n  max (hausdorff_distance {f x--f z} (f ` Gxz))\n   (hausdorff_distance {f y--f z} (f ` Gyz))\n  \\<le> 4 * deltaG TYPE('b) + K\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "finally"], ["proof (chain)\npicking this:\n  infdist w2 (f ` Gxz \\<union> f ` Gyz) \\<le> 4 * deltaG TYPE('b) + K", "have **: \"infdist w2 (f`Gxz \\<union> f`Gyz) \\<le> 4 * deltaG(TYPE('b)) + K\""], ["proof (prove)\nusing this:\n  infdist w2 (f ` Gxz \\<union> f ` Gyz) \\<le> 4 * deltaG TYPE('b) + K\n\ngoal (1 subgoal):\n 1. infdist w2 (f ` Gxz \\<union> f ` Gyz) \\<le> 4 * deltaG TYPE('b) + K", "by simp"], ["proof (state)\nthis:\n  infdist w2 (f ` Gxz \\<union> f ` Gyz) \\<le> 4 * deltaG TYPE('b) + K\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "have \"infdist (f w) (f`Gxz \\<union> f`Gyz) \\<le> infdist w2 (f`Gxz \\<union> f`Gyz) + dist (f w) w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (f w) (f ` Gxz \\<union> f ` Gyz)\n    \\<le> infdist w2 (f ` Gxz \\<union> f ` Gyz) + dist (f w) w2", "by (rule infdist_triangle)"], ["proof (state)\nthis:\n  infdist (f w) (f ` Gxz \\<union> f ` Gyz)\n  \\<le> infdist w2 (f ` Gxz \\<union> f ` Gyz) + dist (f w) w2\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "then"], ["proof (chain)\npicking this:\n  infdist (f w) (f ` Gxz \\<union> f ` Gyz)\n  \\<le> infdist w2 (f ` Gxz \\<union> f ` Gyz) + dist (f w) w2", "have A: \"infdist (f w) (f`(Gxz \\<union> Gyz)) \\<le> 4 * deltaG(TYPE('b)) + 2 * K\""], ["proof (prove)\nusing this:\n  infdist (f w) (f ` Gxz \\<union> f ` Gyz)\n  \\<le> infdist w2 (f ` Gxz \\<union> f ` Gyz) + dist (f w) w2\n\ngoal (1 subgoal):\n 1. infdist (f w) (f ` (Gxz \\<union> Gyz)) \\<le> 4 * deltaG TYPE('b) + 2 * K", "using * **"], ["proof (prove)\nusing this:\n  infdist (f w) (f ` Gxz \\<union> f ` Gyz)\n  \\<le> infdist w2 (f ` Gxz \\<union> f ` Gyz) + dist (f w) w2\n  dist (f w) w2 \\<le> K\n  infdist w2 (f ` Gxz \\<union> f ` Gyz) \\<le> 4 * deltaG TYPE('b) + K\n\ngoal (1 subgoal):\n 1. infdist (f w) (f ` (Gxz \\<union> Gyz)) \\<le> 4 * deltaG TYPE('b) + 2 * K", "by (auto simp add: image_Un)"], ["proof (state)\nthis:\n  infdist (f w) (f ` (Gxz \\<union> Gyz)) \\<le> 4 * deltaG TYPE('b) + 2 * K\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "have \"infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon\" if \"epsilon > 0\" for epsilon"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "have *: \"epsilon/lambda > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < epsilon / lambda", "using that C"], ["proof (prove)\nusing this:\n  0 < epsilon\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 < epsilon / lambda", "by auto"], ["proof (state)\nthis:\n  0 < epsilon / lambda\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "have \"\\<exists>z \\<in> f`(Gxz \\<union> Gyz). dist (f w) z < 4 * deltaG(TYPE('b)) + 2 * K + epsilon/lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>f ` (Gxz \\<union> Gyz).\n       dist (f w) z < 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda", "apply (rule infdist_almost_attained)"], ["proof (prove)\ngoal (2 subgoals):\n 1. infdist (f w) (f ` (Gxz \\<union> Gyz))\n    < 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda\n 2. f ` (Gxz \\<union> Gyz) \\<noteq> {}", "using A * H(2)"], ["proof (prove)\nusing this:\n  infdist (f w) (f ` (Gxz \\<union> Gyz)) \\<le> 4 * deltaG TYPE('b) + 2 * K\n  0 < epsilon / lambda\n  geodesic_segment_between Gxz x z\n\ngoal (2 subgoals):\n 1. infdist (f w) (f ` (Gxz \\<union> Gyz))\n    < 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda\n 2. f ` (Gxz \\<union> Gyz) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>z\\<in>f ` (Gxz \\<union> Gyz).\n     dist (f w) z < 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "then"], ["proof (chain)\npicking this:\n  \\<exists>z\\<in>f ` (Gxz \\<union> Gyz).\n     dist (f w) z < 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda", "obtain z where z: \"z \\<in> Gxz \\<union> Gyz\" \"dist (f w) (f z) < 4 * deltaG(TYPE('b)) + 2 * K + epsilon/lambda\""], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>f ` (Gxz \\<union> Gyz).\n     dist (f w) z < 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> Gxz \\<union> Gyz;\n         dist (f w) (f z)\n         < 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> Gxz \\<union> Gyz\n  dist (f w) (f z) < 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "have \"infdist w (Gxz \\<union> Gyz) \\<le> dist w z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> dist w z", "by (auto intro!: infdist_le z(1))"], ["proof (state)\nthis:\n  infdist w (Gxz \\<union> Gyz) \\<le> dist w z\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "also"], ["proof (state)\nthis:\n  infdist w (Gxz \\<union> Gyz) \\<le> dist w z\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "have \"... \\<le> lambda * dist (f w) (f z) + C * lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist w z \\<le> lambda * dist (f w) (f z) + C * lambda", "using quasi_isometry_onD[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> UNIV; ?y \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> dist (f ?x) (f ?y) \\<le> lambda * dist ?x ?y + C\n  \\<lbrakk>?x \\<in> UNIV; ?y \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> 1 / lambda * dist ?x ?y - C \\<le> dist (f ?x) (f ?y)\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. dist w z \\<le> lambda * dist (f w) (f z) + C * lambda", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  dist w z \\<le> lambda * dist (f w) (f z) + C * lambda\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "also"], ["proof (state)\nthis:\n  dist w z \\<le> lambda * dist (f w) (f z) + C * lambda\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "have \"... \\<le> lambda * (4 * deltaG(TYPE('b)) + 2 * K + epsilon/lambda) + C * lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * dist (f w) (f z) + C * lambda\n    \\<le> lambda * (4 * deltaG TYPE('b) + 2 * K + epsilon / lambda) +\n          C * lambda", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist (f w) (f z) \\<le> 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda\n 2. 0 \\<le> lambda", "using z(2) C"], ["proof (prove)\nusing this:\n  dist (f w) (f z) < 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (2 subgoals):\n 1. dist (f w) (f z) \\<le> 4 * deltaG TYPE('b) + 2 * K + epsilon / lambda\n 2. 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  lambda * dist (f w) (f z) + C * lambda\n  \\<le> lambda * (4 * deltaG TYPE('b) + 2 * K + epsilon / lambda) +\n        C * lambda\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "also"], ["proof (state)\nthis:\n  lambda * dist (f w) (f z) + C * lambda\n  \\<le> lambda * (4 * deltaG TYPE('b) + 2 * K + epsilon / lambda) +\n        C * lambda\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "have \"... = L + epsilon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (4 * deltaG TYPE('b) + 2 * K + epsilon / lambda) + C * lambda =\n    L + epsilon", "unfolding K_def L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda *\n    (4 * deltaG TYPE('b) +\n     2 * (92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))) +\n     epsilon / lambda) +\n    C * lambda =\n    lambda *\n    (4 * 1 * deltaG TYPE('b) + 1 * 1 * C +\n     2 * (92 * lambda\\<^sup>2 * (C + deltaG TYPE('b)))) +\n    epsilon", "using C"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. lambda *\n    (4 * deltaG TYPE('b) +\n     2 * (92 * lambda\\<^sup>2 * (C + deltaG TYPE('b))) +\n     epsilon / lambda) +\n    C * lambda =\n    lambda *\n    (4 * 1 * deltaG TYPE('b) + 1 * 1 * C +\n     2 * (92 * lambda\\<^sup>2 * (C + deltaG TYPE('b)))) +\n    epsilon", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  lambda * (4 * deltaG TYPE('b) + 2 * K + epsilon / lambda) + C * lambda =\n  L + epsilon\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "finally"], ["proof (chain)\npicking this:\n  infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon", "by simp"], ["proof (state)\nthis:\n  infdist w (Gxz \\<union> Gyz) \\<le> L + epsilon\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?epsilon \\<Longrightarrow>\n  infdist w (Gxz \\<union> Gyz) \\<le> L + ?epsilon\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "then"], ["proof (chain)\npicking this:\n  0 < ?epsilon \\<Longrightarrow>\n  infdist w (Gxz \\<union> Gyz) \\<le> L + ?epsilon", "have \"infdist w (Gxz \\<union> Gyz) \\<le> L\""], ["proof (prove)\nusing this:\n  0 < ?epsilon \\<Longrightarrow>\n  infdist w (Gxz \\<union> Gyz) \\<le> L + ?epsilon\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L", "using field_le_epsilon"], ["proof (prove)\nusing this:\n  0 < ?epsilon \\<Longrightarrow>\n  infdist w (Gxz \\<union> Gyz) \\<le> L + ?epsilon\n  (\\<And>e.\n      (0::?'a) < e \\<Longrightarrow> ?x \\<le> ?y + e) \\<Longrightarrow>\n  ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> L", "by blast"], ["proof (state)\nthis:\n  infdist w (Gxz \\<union> Gyz) \\<le> L\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "then"], ["proof (chain)\npicking this:\n  infdist w (Gxz \\<union> Gyz) \\<le> L", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist w (Gxz \\<union> Gyz) \\<le> L\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "using \\<open>L \\<le> M\\<close>"], ["proof (prove)\nusing this:\n  infdist w (Gxz \\<union> Gyz) \\<le> L\n  L \\<le> M\n\ngoal (1 subgoal):\n 1. infdist w (Gxz \\<union> Gyz) \\<le> M", "by auto"], ["proof (state)\nthis:\n  infdist w (Gxz \\<union> Gyz) \\<le> M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z; geodesic_segment_between ?Gyz ?y ?z;\n   ?w \\<in> ?Gxy\\<rbrakk>\n  \\<Longrightarrow> infdist ?w (?Gxz \\<union> ?Gyz) \\<le> M\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z; geodesic_segment_between ?Gyz ?y ?z;\n   ?w \\<in> ?Gxy\\<rbrakk>\n  \\<Longrightarrow> infdist ?w (?Gxz \\<union> ?Gyz) \\<le> M", "have \"Gromov_hyperbolic_subset (4 * M) (UNIV::'a set)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z; geodesic_segment_between ?Gyz ?y ?z;\n   ?w \\<in> ?Gxy\\<rbrakk>\n  \\<Longrightarrow> infdist ?w (?Gxz \\<union> ?Gyz) \\<le> M\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (4 * M) UNIV", "using thin_triangles_implies_hyperbolic[OF Thin]"], ["proof (prove)\nusing this:\n  \\<lbrakk>geodesic_segment_between ?Gxy ?x ?y;\n   geodesic_segment_between ?Gxz ?x ?z; geodesic_segment_between ?Gyz ?y ?z;\n   ?w \\<in> ?Gxy\\<rbrakk>\n  \\<Longrightarrow> infdist ?w (?Gxz \\<union> ?Gyz) \\<le> M\n  \\<lbrakk>\\<And>x y z w Gxy Gyz Gxz.\n              \\<lbrakk>geodesic_segment_between Gxy x y;\n               geodesic_segment_between Gxz x z;\n               geodesic_segment_between Gyz y z; w \\<in> Gxy\\<rbrakk>\n              \\<Longrightarrow> geodesic_segment_between\n                                 (?Gxy1 x y z w Gxy Gyz Gxz)\n                                 (?x1 x y z w Gxy Gyz Gxz)\n                                 (?y1 x y z w Gxy Gyz Gxz);\n   \\<And>x y z w Gxy Gyz Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z; geodesic_segment_between Gyz y z;\n       w \\<in> Gxy\\<rbrakk>\n      \\<Longrightarrow> geodesic_segment_between Gxz\n                         (?x1 x y z w Gxy Gyz Gxz)\n                         (?z1 x y z w Gxy Gyz Gxz);\n   \\<And>x y z w Gxy Gyz Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z; geodesic_segment_between Gyz y z;\n       w \\<in> Gxy\\<rbrakk>\n      \\<Longrightarrow> geodesic_segment_between Gyz\n                         (?y1 x y z w Gxy Gyz Gxz)\n                         (?z1 x y z w Gxy Gyz Gxz);\n   \\<And>x y z w Gxy Gyz Gxz.\n      \\<lbrakk>geodesic_segment_between Gxy x y;\n       geodesic_segment_between Gxz x z; geodesic_segment_between Gyz y z;\n       w \\<in> Gxy\\<rbrakk>\n      \\<Longrightarrow> w \\<in> ?Gxy1 x y z w Gxy Gyz Gxz\\<rbrakk>\n  \\<Longrightarrow> Gromov_hyperbolic_subset (4 * M) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (4 * M) UNIV", "by auto"], ["proof (state)\nthis:\n  Gromov_hyperbolic_subset (4 * M) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "then"], ["proof (chain)\npicking this:\n  Gromov_hyperbolic_subset (4 * M) UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (4 * M) UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "unfolding M_def"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (4 * (188 * lambda ^ 3 * (C + deltaG TYPE('b))))\n   UNIV\n\ngoal (1 subgoal):\n 1. Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Most often, the precise value of the constant in the previous theorem is irrelevant,\nit is used in the following form.\\<close>"], ["", "theorem Gromov_hyperbolic_invariant_under_quasi_isometry:\n  assumes \"quasi_isometric (UNIV::('a::geodesic_space) set) (UNIV::('b::Gromov_hyperbolic_space_geodesic) set)\"\n  shows \"\\<exists>delta. Gromov_hyperbolic_subset delta (UNIV::'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "obtain C lambda f where f: \"lambda C-quasi_isometry_between (UNIV::'a set) (UNIV::'b set) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lambda C f.\n        lambda C -quasi_isometry_between UNIV UNIV f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  quasi_isometric UNIV UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>lambda C f.\n        lambda C -quasi_isometry_between UNIV UNIV f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding quasi_isometric_def"], ["proof (prove)\nusing this:\n  \\<exists>lambda C. Ex (lambda C -quasi_isometry_between UNIV UNIV)\n\ngoal (1 subgoal):\n 1. (\\<And>lambda C f.\n        lambda C -quasi_isometry_between UNIV UNIV f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  lambda C -quasi_isometry_between UNIV UNIV f\n\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "using Gromov_hyperbolic_invariant_under_quasi_isometry_explicit[OF quasi_isometry_betweenD(1)[OF f]]"], ["proof (prove)\nusing this:\n  Gromov_hyperbolic_subset (752 * lambda ^ 3 * (C + deltaG TYPE('b))) UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>delta. Gromov_hyperbolic_subset delta UNIV", "by blast"], ["proof (state)\nthis:\n  \\<exists>delta. Gromov_hyperbolic_subset delta UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A central feature of hyperbolic spaces is that a path from $x$ to $y$ can not deviate\ntoo much from a geodesic from $x$ to $y$ unless it is extremely long (exponentially long in\nterms of the distance from $x$ to $y$). This is useful both to ensure that short paths (for instance\nquasi-geodesics) stay close to geodesics, see the Morse lemme below, and to ensure that paths\nthat avoid a given large ball of radius $R$ have to be exponentially long in terms of $R$ (this\nis extremely useful for random walks). This proposition is the first non-trivial result\non hyperbolic spaces in~\\cite{bridson_haefliger} (Proposition III.H.1.6). We follow their proof.\n\nThe proof is geometric, and uses the existence of geodesics and the fact that geodesic\ntriangles are thin. In fact, the result still holds if the space is not geodesic, as\nit can be deduced by embedding the hyperbolic space in a geodesic hyperbolic space and using\nthe result there.\\<close>"], ["", "proposition (in Gromov_hyperbolic_space_geodesic) lipschitz_path_close_to_geodesic:\n  fixes c::\"real \\<Rightarrow> 'a\"\n  assumes \"M-lipschitz_on {A..B} c\"\n          \"geodesic_segment_between G (c A) (c B)\"\n          \"x \\<in> G\"\n  shows \"infdist x (c`{A..B}) \\<le> (4/ln 2) * deltaG(TYPE('a)) * max 0 (ln (B-A)) + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have \"M \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> M", "by (rule lipschitz_on_nonneg[OF assms(1)])"], ["proof (state)\nthis:\n  0 \\<le> M\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have Main: \"a \\<in> {A..B} \\<Longrightarrow> b \\<in> {A..B} \\<Longrightarrow> a \\<le> b \\<Longrightarrow> b-a \\<le> 2^(n+1) \\<Longrightarrow> geodesic_segment_between H (c a) (c b)\n        \\<Longrightarrow> y \\<in> H \\<Longrightarrow> infdist y (c`{A..B}) \\<le> 4 * deltaG(TYPE('a)) * n + M\" for a b H y n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n     b - a \\<le> 2 ^ (n + 1); geodesic_segment_between H (c a) (c b);\n     y \\<in> H\\<rbrakk>\n    \\<Longrightarrow> infdist y (c ` {A..B})\n                      \\<le> 4 * deltaG TYPE('a) * real n + M", "proof (induction n arbitrary: a b H y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "case 0"], ["proof (state)\nthis:\n  a \\<in> {A..B}\n  b \\<in> {A..B}\n  a \\<le> b\n  b - a \\<le> 2 ^ (0 + 1)\n  geodesic_segment_between H (c a) (c b)\n  y \\<in> H\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"infdist y (c ` {A..B}) \\<le> dist y (c b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist y (c ` {A..B}) \\<le> dist y (c b)", "apply (rule infdist_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. c b \\<in> c ` {A..B}", "using \\<open>b \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  b \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. c b \\<in> c ` {A..B}", "by auto"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> dist y (c b)\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "moreover"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> dist y (c b)\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"infdist y (c ` {A..B}) \\<le> dist y (c a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist y (c ` {A..B}) \\<le> dist y (c a)", "apply (rule infdist_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. c a \\<in> c ` {A..B}", "using \\<open>a \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. c a \\<in> c ` {A..B}", "by auto"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> dist y (c a)\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "ultimately"], ["proof (chain)\npicking this:\n  infdist y (c ` {A..B}) \\<le> dist y (c b)\n  infdist y (c ` {A..B}) \\<le> dist y (c a)", "have \"2 * infdist y (c ` {A..B}) \\<le> dist (c a) y + dist y (c b)\""], ["proof (prove)\nusing this:\n  infdist y (c ` {A..B}) \\<le> dist y (c b)\n  infdist y (c ` {A..B}) \\<le> dist y (c a)\n\ngoal (1 subgoal):\n 1. 2 * infdist y (c ` {A..B}) \\<le> dist (c a) y + dist y (c b)", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  2 * infdist y (c ` {A..B}) \\<le> dist (c a) y + dist y (c b)\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "also"], ["proof (state)\nthis:\n  2 * infdist y (c ` {A..B}) \\<le> dist (c a) y + dist y (c b)\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"... = dist (c a) (c b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (c a) y + dist y (c b) = dist (c a) (c b)", "by (rule geodesic_segment_dist[OF \\<open>geodesic_segment_between H (c a) (c b)\\<close> \\<open>y \\<in> H\\<close>])"], ["proof (state)\nthis:\n  dist (c a) y + dist y (c b) = dist (c a) (c b)\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "also"], ["proof (state)\nthis:\n  dist (c a) y + dist y (c b) = dist (c a) (c b)\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"... \\<le> M * abs(b - a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (c a) (c b) \\<le> M * \\<bar>b - a\\<bar>", "using lipschitz_onD(1)[OF assms(1) \\<open>a \\<in> {A..B}\\<close> \\<open>b \\<in> {A..B}\\<close>]"], ["proof (prove)\nusing this:\n  dist (c a) (c b) \\<le> M * dist a b\n\ngoal (1 subgoal):\n 1. dist (c a) (c b) \\<le> M * \\<bar>b - a\\<bar>", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  dist (c a) (c b) \\<le> M * \\<bar>a - b\\<bar>\n\ngoal (1 subgoal):\n 1. dist (c a) (c b) \\<le> M * \\<bar>b - a\\<bar>", "by (simp add: abs_minus_commute)"], ["proof (state)\nthis:\n  dist (c a) (c b) \\<le> M * \\<bar>b - a\\<bar>\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "also"], ["proof (state)\nthis:\n  dist (c a) (c b) \\<le> M * \\<bar>b - a\\<bar>\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"... \\<le> M * 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M * \\<bar>b - a\\<bar> \\<le> M * 2", "using \\<open>a \\<le> b\\<close> \\<open>b - a \\<le> 2^(0 + 1)\\<close> \\<open>M \\<ge> 0\\<close> mult_left_mono"], ["proof (prove)\nusing this:\n  a \\<le> b\n  b - a \\<le> 2 ^ (0 + 1)\n  0 \\<le> M\n  \\<lbrakk>?a \\<le> ?b; (0::?'a) \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> ?c * ?a \\<le> ?c * ?b\n\ngoal (1 subgoal):\n 1. M * \\<bar>b - a\\<bar> \\<le> M * 2", "by auto"], ["proof (state)\nthis:\n  M * \\<bar>b - a\\<bar> \\<le> M * 2\n\ngoal (2 subgoals):\n 1. \\<And>a b H y.\n       \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (0 + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real 0 + M\n 2. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "finally"], ["proof (chain)\npicking this:\n  2 * infdist y (c ` {A..B}) \\<le> M * 2", "show ?case"], ["proof (prove)\nusing this:\n  2 * infdist y (c ` {A..B}) \\<le> M * 2\n\ngoal (1 subgoal):\n 1. infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real 0 + M", "by simp"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real 0 + M\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> {A..B}; ?b \\<in> {A..B}; ?a \\<le> ?b;\n   ?b - ?a \\<le> 2 ^ (n + 1); geodesic_segment_between ?H (c ?a) (c ?b);\n   ?y \\<in> ?H\\<rbrakk>\n  \\<Longrightarrow> infdist ?y (c ` {A..B})\n                    \\<le> 4 * deltaG TYPE('a) * real n + M\n  a \\<in> {A..B}\n  b \\<in> {A..B}\n  a \\<le> b\n  b - a \\<le> 2 ^ (Suc n + 1)\n  geodesic_segment_between H (c a) (c b)\n  y \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "define m where \"m = (a + b)/2\""], ["proof (state)\nthis:\n  m = (a + b) / 2\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"m \\<in> {A..B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> {A..B}", "using \\<open>a \\<in> {A..B}\\<close> \\<open>b \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> {A..B}\n  b \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. m \\<in> {A..B}", "unfolding m_def"], ["proof (prove)\nusing this:\n  a \\<in> {A..B}\n  b \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. (a + b) / 2 \\<in> {A..B}", "by auto"], ["proof (state)\nthis:\n  m \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "define Ha where \"Ha = {c m--c a}\""], ["proof (state)\nthis:\n  Ha = {c m--c a}\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "define Hb where \"Hb = {c m--c b}\""], ["proof (state)\nthis:\n  Hb = {c m--c b}\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have I: \"geodesic_segment_between Ha (c m) (c a)\" \"geodesic_segment_between Hb (c m) (c b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between Ha (c m) (c a) &&&\n    geodesic_segment_between Hb (c m) (c b)", "unfolding Ha_def Hb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between {c m--c a} (c m) (c a) &&&\n    geodesic_segment_between {c m--c b} (c m) (c b)", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between Ha (c m) (c a)\n  geodesic_segment_between Hb (c m) (c b)\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "then"], ["proof (chain)\npicking this:\n  geodesic_segment_between Ha (c m) (c a)\n  geodesic_segment_between Hb (c m) (c b)", "have \"Ha \\<noteq> {}\" \"Hb \\<noteq> {}\" \"compact Ha\" \"compact Hb\""], ["proof (prove)\nusing this:\n  geodesic_segment_between Ha (c m) (c a)\n  geodesic_segment_between Hb (c m) (c b)\n\ngoal (1 subgoal):\n 1. (Ha \\<noteq> {} &&& Hb \\<noteq> {}) &&& compact Ha &&& compact Hb", "by (auto intro: geodesic_segment_topology)"], ["proof (state)\nthis:\n  Ha \\<noteq> {}\n  Hb \\<noteq> {}\n  compact Ha\n  compact Hb\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have *: \"infdist y (Ha \\<union> Hb) \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist y (Ha \\<union> Hb) \\<le> 4 * deltaG TYPE('a)", "by (rule thin_triangles[OF I \\<open>geodesic_segment_between H (c a) (c b)\\<close> \\<open>y \\<in> H\\<close>])"], ["proof (state)\nthis:\n  infdist y (Ha \\<union> Hb) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "then"], ["proof (chain)\npicking this:\n  infdist y (Ha \\<union> Hb) \\<le> 4 * deltaG TYPE('a)", "have \"infdist y Ha \\<le> 4 * deltaG(TYPE('a)) \\<or> infdist y Hb \\<le> 4 * deltaG(TYPE('a))\""], ["proof (prove)\nusing this:\n  infdist y (Ha \\<union> Hb) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<or>\n    infdist y Hb \\<le> 4 * deltaG TYPE('a)", "unfolding infdist_union_min[OF \\<open>Ha \\<noteq> {}\\<close> \\<open>Hb \\<noteq> {}\\<close>]"], ["proof (prove)\nusing this:\n  min (infdist y Ha) (infdist y Hb) \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<or>\n    infdist y Hb \\<le> 4 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<or>\n  infdist y Hb \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. \\<And>n a b H y.\n       \\<lbrakk>\\<And>a b H y.\n                   \\<lbrakk>a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n                    b - a \\<le> 2 ^ (n + 1);\n                    geodesic_segment_between H (c a) (c b);\n                    y \\<in> H\\<rbrakk>\n                   \\<Longrightarrow> infdist y (c ` {A..B})\n                                     \\<le> 4 * deltaG TYPE('a) * real n + M;\n        a \\<in> {A..B}; b \\<in> {A..B}; a \\<le> b;\n        b - a \\<le> 2 ^ (Suc n + 1); geodesic_segment_between H (c a) (c b);\n        y \\<in> H\\<rbrakk>\n       \\<Longrightarrow> infdist y (c ` {A..B})\n                         \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "then"], ["proof (chain)\npicking this:\n  infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<or>\n  infdist y Hb \\<le> 4 * deltaG TYPE('a)", "show ?case"], ["proof (prove)\nusing this:\n  infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<or>\n  infdist y Hb \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n 2. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "assume H: \"infdist y Ha \\<le> 4 * deltaG TYPE('a)\""], ["proof (state)\nthis:\n  infdist y Ha \\<le> 4 * deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n 2. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "obtain z where z: \"z \\<in> Ha\" \"infdist y Ha = dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> Ha; infdist y Ha = dist y z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using infdist_proper_attained[OF proper_of_compact[OF \\<open>compact Ha\\<close>] \\<open>Ha \\<noteq> {}\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>Ha. infdist ?x Ha = dist ?x c\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> Ha; infdist y Ha = dist y z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> Ha\n  infdist y Ha = dist y z\n\ngoal (2 subgoals):\n 1. infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n 2. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have Iz: \"infdist z (c`{A..B}) \\<le> 4 * deltaG(TYPE('a)) * n + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist z (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real n + M", "proof (rule Suc.IH[OF \\<open>a \\<in> {A..B}\\<close> \\<open>m \\<in> {A..B}\\<close>, of Ha])"], ["proof (state)\ngoal (4 subgoals):\n 1. a \\<le> m\n 2. m - a \\<le> 2 ^ (n + 1)\n 3. geodesic_segment_between Ha (c a) (c m)\n 4. z \\<in> Ha", "show \"a \\<le> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> m", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> (a + b) / 2", "using \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. a \\<le> (a + b) / 2", "by auto"], ["proof (state)\nthis:\n  a \\<le> m\n\ngoal (3 subgoals):\n 1. m - a \\<le> 2 ^ (n + 1)\n 2. geodesic_segment_between Ha (c a) (c m)\n 3. z \\<in> Ha", "show \"m - a \\<le> 2^(n+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m - a \\<le> 2 ^ (n + 1)", "using \\<open>b - a \\<le> 2^(Suc n + 1)\\<close> \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  b - a \\<le> 2 ^ (Suc n + 1)\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. m - a \\<le> 2 ^ (n + 1)", "unfolding m_def"], ["proof (prove)\nusing this:\n  b - a \\<le> 2 ^ (Suc n + 1)\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. (a + b) / 2 - a \\<le> 2 ^ (n + 1)", "by auto"], ["proof (state)\nthis:\n  m - a \\<le> 2 ^ (n + 1)\n\ngoal (2 subgoals):\n 1. geodesic_segment_between Ha (c a) (c m)\n 2. z \\<in> Ha", "show \"geodesic_segment_between Ha (c a) (c m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between Ha (c a) (c m)", "by (simp add: I(1) geodesic_segment_commute)"], ["proof (state)\nthis:\n  geodesic_segment_between Ha (c a) (c m)\n\ngoal (1 subgoal):\n 1. z \\<in> Ha", "show \"z \\<in> Ha\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> Ha", "using z"], ["proof (prove)\nusing this:\n  z \\<in> Ha\n  infdist y Ha = dist y z\n\ngoal (1 subgoal):\n 1. z \\<in> Ha", "by auto"], ["proof (state)\nthis:\n  z \\<in> Ha\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infdist z (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real n + M\n\ngoal (2 subgoals):\n 1. infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n 2. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"infdist y (c`{A..B}) \\<le> dist y z + infdist z (c`{A..B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist y (c ` {A..B}) \\<le> dist y z + infdist z (c ` {A..B})", "by (metis add.commute infdist_triangle)"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> dist y z + infdist z (c ` {A..B})\n\ngoal (2 subgoals):\n 1. infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n 2. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "also"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> dist y z + infdist z (c ` {A..B})\n\ngoal (2 subgoals):\n 1. infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n 2. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"... \\<le> 4 * deltaG TYPE('a) + (4 * deltaG(TYPE('a)) * n + M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y z + infdist z (c ` {A..B})\n    \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)", "using H z Iz"], ["proof (prove)\nusing this:\n  infdist y Ha \\<le> 4 * deltaG TYPE('a)\n  z \\<in> Ha\n  infdist y Ha = dist y z\n  infdist z (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real n + M\n\ngoal (1 subgoal):\n 1. dist y z + infdist z (c ` {A..B})\n    \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)", "by (auto intro: add_mono)"], ["proof (state)\nthis:\n  dist y z + infdist z (c ` {A..B})\n  \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)\n\ngoal (2 subgoals):\n 1. infdist y Ha \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n 2. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "finally"], ["proof (chain)\npicking this:\n  infdist y (c ` {A..B})\n  \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)", "show \"infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\""], ["proof (prove)\nusing this:\n  infdist y (c ` {A..B})\n  \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)\n\ngoal (1 subgoal):\n 1. infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n\ngoal (1 subgoal):\n 1. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "assume H: \"infdist y Hb \\<le> 4 * deltaG TYPE('a)\""], ["proof (state)\nthis:\n  infdist y Hb \\<le> 4 * deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "obtain z where z: \"z \\<in> Hb\" \"infdist y Hb = dist y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> Hb; infdist y Hb = dist y z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using infdist_proper_attained[OF proper_of_compact[OF \\<open>compact Hb\\<close>] \\<open>Hb \\<noteq> {}\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>Hb. infdist ?x Hb = dist ?x c\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> Hb; infdist y Hb = dist y z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> Hb\n  infdist y Hb = dist y z\n\ngoal (1 subgoal):\n 1. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have Iz: \"infdist z (c`{A..B}) \\<le> 4 * deltaG(TYPE('a)) * n + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist z (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real n + M", "proof (rule Suc.IH[OF \\<open>m \\<in> {A..B}\\<close> \\<open>b \\<in> {A..B}\\<close>, of Hb])"], ["proof (state)\ngoal (4 subgoals):\n 1. m \\<le> b\n 2. b - m \\<le> 2 ^ (n + 1)\n 3. geodesic_segment_between Hb (c m) (c b)\n 4. z \\<in> Hb", "show \"m \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> b", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + b) / 2 \\<le> b", "using \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. (a + b) / 2 \\<le> b", "by auto"], ["proof (state)\nthis:\n  m \\<le> b\n\ngoal (3 subgoals):\n 1. b - m \\<le> 2 ^ (n + 1)\n 2. geodesic_segment_between Hb (c m) (c b)\n 3. z \\<in> Hb", "show \"b - m \\<le> 2^(n+1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b - m \\<le> 2 ^ (n + 1)", "using \\<open>b - a \\<le> 2^(Suc n + 1)\\<close> \\<open>a \\<le> b\\<close>"], ["proof (prove)\nusing this:\n  b - a \\<le> 2 ^ (Suc n + 1)\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. b - m \\<le> 2 ^ (n + 1)", "unfolding m_def"], ["proof (prove)\nusing this:\n  b - a \\<le> 2 ^ (Suc n + 1)\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. b - (a + b) / 2 \\<le> 2 ^ (n + 1)", "by (auto simp add: divide_simps)"], ["proof (state)\nthis:\n  b - m \\<le> 2 ^ (n + 1)\n\ngoal (2 subgoals):\n 1. geodesic_segment_between Hb (c m) (c b)\n 2. z \\<in> Hb", "show \"geodesic_segment_between Hb (c m) (c b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between Hb (c m) (c b)", "by (simp add: I(2))"], ["proof (state)\nthis:\n  geodesic_segment_between Hb (c m) (c b)\n\ngoal (1 subgoal):\n 1. z \\<in> Hb", "show \"z \\<in> Hb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> Hb", "using z"], ["proof (prove)\nusing this:\n  z \\<in> Hb\n  infdist y Hb = dist y z\n\ngoal (1 subgoal):\n 1. z \\<in> Hb", "by auto"], ["proof (state)\nthis:\n  z \\<in> Hb\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infdist z (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real n + M\n\ngoal (1 subgoal):\n 1. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"infdist y (c`{A..B}) \\<le> dist y z + infdist z (c`{A..B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist y (c ` {A..B}) \\<le> dist y z + infdist z (c ` {A..B})", "by (metis add.commute infdist_triangle)"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> dist y z + infdist z (c ` {A..B})\n\ngoal (1 subgoal):\n 1. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "also"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> dist y z + infdist z (c ` {A..B})\n\ngoal (1 subgoal):\n 1. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "have \"... \\<le> 4 * deltaG TYPE('a) + (4 * deltaG(TYPE('a)) * n + M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist y z + infdist z (c ` {A..B})\n    \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)", "using H z Iz"], ["proof (prove)\nusing this:\n  infdist y Hb \\<le> 4 * deltaG TYPE('a)\n  z \\<in> Hb\n  infdist y Hb = dist y z\n  infdist z (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real n + M\n\ngoal (1 subgoal):\n 1. dist y z + infdist z (c ` {A..B})\n    \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)", "by (auto intro: add_mono)"], ["proof (state)\nthis:\n  dist y z + infdist z (c ` {A..B})\n  \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)\n\ngoal (1 subgoal):\n 1. infdist y Hb \\<le> 4 * deltaG TYPE('a) \\<Longrightarrow>\n    infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "finally"], ["proof (chain)\npicking this:\n  infdist y (c ` {A..B})\n  \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)", "show \"infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\""], ["proof (prove)\nusing this:\n  infdist y (c ` {A..B})\n  \\<le> 4 * deltaG TYPE('a) + (4 * deltaG TYPE('a) * real n + M)\n\ngoal (1 subgoal):\n 1. infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infdist y (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real (Suc n) + M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> {A..B}; ?b \\<in> {A..B}; ?a \\<le> ?b;\n   ?b - ?a \\<le> 2 ^ (?n + 1); geodesic_segment_between ?H (c ?a) (c ?b);\n   ?y \\<in> ?H\\<rbrakk>\n  \\<Longrightarrow> infdist ?y (c ` {A..B})\n                    \\<le> 4 * deltaG TYPE('a) * real ?n + M\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "consider \"B-A <0\" | \"B-A \\<ge> 0 \\<and> B-A \\<le> 2\" | \"B-A > 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B - A < 0 \\<Longrightarrow> thesis;\n     0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow> thesis;\n     2 < B - A \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>B - A < 0 \\<Longrightarrow> ?thesis;\n   0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow> ?thesis;\n   2 < B - A \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>B - A < 0 \\<Longrightarrow> ?thesis;\n   0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow> ?thesis;\n   2 < B - A \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>B - A < 0 \\<Longrightarrow> ?thesis;\n   0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow> ?thesis;\n   2 < B - A \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. B - A < 0 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 2. 0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 3. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "case 1"], ["proof (state)\nthis:\n  B - A < 0\n\ngoal (3 subgoals):\n 1. B - A < 0 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 2. 0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 3. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "then"], ["proof (chain)\npicking this:\n  B - A < 0", "have \"c`{A..B} = {}\""], ["proof (prove)\nusing this:\n  B - A < 0\n\ngoal (1 subgoal):\n 1. c ` {A..B} = {}", "by auto"], ["proof (state)\nthis:\n  c ` {A..B} = {}\n\ngoal (3 subgoals):\n 1. B - A < 0 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 2. 0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 3. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "then"], ["proof (chain)\npicking this:\n  c ` {A..B} = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  c ` {A..B} = {}\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "unfolding infdist_def"], ["proof (prove)\nusing this:\n  c ` {A..B} = {}\n\ngoal (1 subgoal):\n 1. (if c ` {A..B} = {} then 0 else Inf (dist x ` c ` {A..B}))\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "using \\<open>M \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  c ` {A..B} = {}\n  0 \\<le> M\n\ngoal (1 subgoal):\n 1. (if c ` {A..B} = {} then 0 else Inf (dist x ` c ` {A..B}))\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "by auto"], ["proof (state)\nthis:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 2. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 2. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "case 2"], ["proof (state)\nthis:\n  0 \\<le> B - A \\<and> B - A \\<le> 2\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 2. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have \"infdist x (c`{A..B}) \\<le> 4 * deltaG(TYPE('a)) * real 0 + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real 0 + M", "apply (rule Main[OF _ _ _ _ \\<open>geodesic_segment_between G (c A) (c B)\\<close> \\<open>x \\<in> G\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. A \\<in> {A..B}\n 2. B \\<in> {A..B}\n 3. A \\<le> B\n 4. B - A \\<le> 2 ^ (0 + 1)", "using 2"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> B - A \\<le> 2\n\ngoal (4 subgoals):\n 1. A \\<in> {A..B}\n 2. B \\<in> {A..B}\n 3. A \\<le> B\n 4. B - A \\<le> 2 ^ (0 + 1)", "by auto"], ["proof (state)\nthis:\n  infdist x (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real 0 + M\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 2. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "also"], ["proof (state)\nthis:\n  infdist x (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real 0 + M\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 2. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have \"... \\<le> (4/ln 2) * deltaG(TYPE('a)) * max 0 (ln (B-A)) + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * deltaG TYPE('a) * real 0 + M\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "using delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. 4 * deltaG TYPE('a) * real 0 + M\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "by auto"], ["proof (state)\nthis:\n  4 * deltaG TYPE('a) * real 0 + M\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> B - A \\<le> 2 \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n 2. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "finally"], ["proof (chain)\npicking this:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "by auto"], ["proof (state)\nthis:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "case 3"], ["proof (state)\nthis:\n  2 < B - A\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "define n::nat where \"n = nat(floor (log 2 (B-A)))\""], ["proof (state)\nthis:\n  n = nat \\<lfloor>log 2 (B - A)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have \"log 2 (B-A) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < log 2 (B - A)", "using 3"], ["proof (prove)\nusing this:\n  2 < B - A\n\ngoal (1 subgoal):\n 1. 0 < log 2 (B - A)", "by auto"], ["proof (state)\nthis:\n  0 < log 2 (B - A)\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "then"], ["proof (chain)\npicking this:\n  0 < log 2 (B - A)", "have n: \"n \\<le> log 2 (B-A)\" \"log 2 (B-A) < n+1\""], ["proof (prove)\nusing this:\n  0 < log 2 (B - A)\n\ngoal (1 subgoal):\n 1. real n \\<le> log 2 (B - A) &&& log 2 (B - A) < real (n + 1)", "unfolding n_def"], ["proof (prove)\nusing this:\n  0 < log 2 (B - A)\n\ngoal (1 subgoal):\n 1. real (nat \\<lfloor>log 2 (B - A)\\<rfloor>) \\<le> log 2 (B - A) &&&\n    log 2 (B - A) < real (nat \\<lfloor>log 2 (B - A)\\<rfloor> + 1)", "by (auto simp add: floor_less_cancel)"], ["proof (state)\nthis:\n  real n \\<le> log 2 (B - A)\n  log 2 (B - A) < real (n + 1)\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "then"], ["proof (chain)\npicking this:\n  real n \\<le> log 2 (B - A)\n  log 2 (B - A) < real (n + 1)", "have *: \"B-A \\<le> 2^(n+1)\""], ["proof (prove)\nusing this:\n  real n \\<le> log 2 (B - A)\n  log 2 (B - A) < real (n + 1)\n\ngoal (1 subgoal):\n 1. B - A \\<le> 2 ^ (n + 1)", "by (meson le_log_of_power linear not_less one_less_numeral_iff semiring_norm(76))"], ["proof (state)\nthis:\n  B - A \\<le> 2 ^ (n + 1)\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have \"n \\<le> ln (B-A) * (1/ln 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real n \\<le> ln (B - A) * (1 / ln 2)", "using n"], ["proof (prove)\nusing this:\n  real n \\<le> log 2 (B - A)\n  log 2 (B - A) < real (n + 1)\n\ngoal (1 subgoal):\n 1. real n \\<le> ln (B - A) * (1 / ln 2)", "unfolding log_def"], ["proof (prove)\nusing this:\n  real n \\<le> ln (B - A) / ln 2\n  ln (B - A) / ln 2 < real (n + 1)\n\ngoal (1 subgoal):\n 1. real n \\<le> ln (B - A) * (1 / ln 2)", "by auto"], ["proof (state)\nthis:\n  real n \\<le> ln (B - A) * (1 / ln 2)\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "then"], ["proof (chain)\npicking this:\n  real n \\<le> ln (B - A) * (1 / ln 2)", "have \"n \\<le> (1/ln 2) * max 0 (ln (B-A))\""], ["proof (prove)\nusing this:\n  real n \\<le> ln (B - A) * (1 / ln 2)\n\ngoal (1 subgoal):\n 1. real n \\<le> 1 / ln 2 * max 0 (ln (B - A))", "using 3"], ["proof (prove)\nusing this:\n  real n \\<le> ln (B - A) * (1 / ln 2)\n  2 < B - A\n\ngoal (1 subgoal):\n 1. real n \\<le> 1 / ln 2 * max 0 (ln (B - A))", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  real n \\<le> 1 / ln 2 * max 0 (ln (B - A))\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have \"infdist x (c`{A..B}) \\<le> 4 * deltaG(TYPE('a)) * n + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real n + M", "apply (rule Main[OF _ _ _ _ \\<open>geodesic_segment_between G (c A) (c B)\\<close> \\<open>x \\<in> G\\<close>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. A \\<in> {A..B}\n 2. B \\<in> {A..B}\n 3. A \\<le> B\n 4. B - A \\<le> 2 ^ (n + 1)", "using * 3"], ["proof (prove)\nusing this:\n  B - A \\<le> 2 ^ (n + 1)\n  2 < B - A\n\ngoal (4 subgoals):\n 1. A \\<in> {A..B}\n 2. B \\<in> {A..B}\n 3. A \\<le> B\n 4. B - A \\<le> 2 ^ (n + 1)", "by auto"], ["proof (state)\nthis:\n  infdist x (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real n + M\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "also"], ["proof (state)\nthis:\n  infdist x (c ` {A..B}) \\<le> 4 * deltaG TYPE('a) * real n + M\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "have \"... \\<le> 4 * deltaG(TYPE('a)) * ((1/ln 2) * max 0 (ln (B-A))) + M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * deltaG TYPE('a) * real n + M\n    \\<le> 4 * deltaG TYPE('a) * (1 / ln 2 * max 0 (ln (B - A))) + M", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. real n \\<le> 1 / ln 2 * max 0 (ln (B - A))\n 2. 0 \\<le> 4 * deltaG TYPE('a)", "using \\<open>n \\<le> (1/ln 2) * max 0 (ln (B-A))\\<close> delta_nonneg"], ["proof (prove)\nusing this:\n  real n \\<le> 1 / ln 2 * max 0 (ln (B - A))\n  0 \\<le> deltaG TYPE('a)\n\ngoal (2 subgoals):\n 1. real n \\<le> 1 / ln 2 * max 0 (ln (B - A))\n 2. 0 \\<le> 4 * deltaG TYPE('a)", "by auto"], ["proof (state)\nthis:\n  4 * deltaG TYPE('a) * real n + M\n  \\<le> 4 * deltaG TYPE('a) * (1 / ln 2 * max 0 (ln (B - A))) + M\n\ngoal (1 subgoal):\n 1. 2 < B - A \\<Longrightarrow>\n    infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "finally"], ["proof (chain)\npicking this:\n  infdist x (c ` {A..B})\n  \\<le> 4 * deltaG TYPE('a) * (1 / ln 2 * max 0 (ln (B - A))) + M", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist x (c ` {A..B})\n  \\<le> 4 * deltaG TYPE('a) * (1 / ln 2 * max 0 (ln (B - A))) + M\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M", "by auto"], ["proof (state)\nthis:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (B - A)) + M\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>By rescaling coordinates at the origin, one obtains a variation around the previous\nstatement.\\<close>"], ["", "proposition (in Gromov_hyperbolic_space_geodesic) lipschitz_path_close_to_geodesic':\n  fixes c::\"real \\<Rightarrow> 'a\"\n  assumes \"M-lipschitz_on {A..B} c\"\n          \"geodesic_segment_between G (c A) (c B)\"\n          \"x \\<in> G\"\n          \"a > 0\"\n  shows \"infdist x (c`{A..B}) \\<le> (4/ln 2) * deltaG(TYPE('a)) * max 0 (ln (a * (B-A))) + M/a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a", "define d where \"d = c o (\\<lambda>t. (1/a) * t)\""], ["proof (state)\nthis:\n  d = c \\<circ> (*) (1 / a)\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a", "have *: \"(M * ((1/a)* 1))-lipschitz_on {a * A..a * B} d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M * (1 / a * 1))-lipschitz_on {a * A..a * B} d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M * (1 / a * 1))-lipschitz_on {a * A..a * B} (c \\<circ> (*) (1 / a))", "apply (rule lipschitz_on_compose, intro lipschitz_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> 1 / a\n 2. M-lipschitz_on ((*) (1 / a) ` {a * A..a * B}) c", "using assms"], ["proof (prove)\nusing this:\n  M-lipschitz_on {A..B} c\n  geodesic_segment_between G (c A) (c B)\n  x \\<in> G\n  0 < a\n\ngoal (2 subgoals):\n 1. 0 \\<le> 1 / a\n 2. M-lipschitz_on ((*) (1 / a) ` {a * A..a * B}) c", "by auto"], ["proof (state)\nthis:\n  (M * (1 / a * 1))-lipschitz_on {a * A..a * B} d\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a", "have \"d`{a * A..a * B} = c`{A..B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d ` {a * A..a * B} = c ` {A..B}", "unfolding d_def image_comp[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. c ` (*) (1 / a) ` {a * A..a * B} = c ` {A..B}", "apply (rule arg_cong[where ?f = \"image c\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*) (1 / a) ` {a * A..a * B} = {A..B}", "using \\<open>a > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. (*) (1 / a) ` {a * A..a * B} = {A..B}", "by auto"], ["proof (state)\nthis:\n  d ` {a * A..a * B} = c ` {A..B}\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a", "then"], ["proof (chain)\npicking this:\n  d ` {a * A..a * B} = c ` {A..B}", "have \"infdist x (c`{A..B}) = infdist x (d`{a * A..a * B})\""], ["proof (prove)\nusing this:\n  d ` {a * A..a * B} = c ` {A..B}\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B}) = infdist x (d ` {a * A..a * B})", "by auto"], ["proof (state)\nthis:\n  infdist x (c ` {A..B}) = infdist x (d ` {a * A..a * B})\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a", "also"], ["proof (state)\nthis:\n  infdist x (c ` {A..B}) = infdist x (d ` {a * A..a * B})\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a", "have \"... \\<le> (4/ln 2) * deltaG(TYPE('a)) * max 0 (ln ((a * B)- (a * A))) + M/a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (d ` {a * A..a * B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * B - a * A)) + M / a", "apply (rule lipschitz_path_close_to_geodesic[OF _ _ \\<open>x \\<in> G\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (M / a)-lipschitz_on {a * A..a * B} d\n 2. geodesic_segment_between G (d (a * A)) (d (a * B))", "using * assms"], ["proof (prove)\nusing this:\n  (M * (1 / a * 1))-lipschitz_on {a * A..a * B} d\n  M-lipschitz_on {A..B} c\n  geodesic_segment_between G (c A) (c B)\n  x \\<in> G\n  0 < a\n\ngoal (2 subgoals):\n 1. (M / a)-lipschitz_on {a * A..a * B} d\n 2. geodesic_segment_between G (d (a * A)) (d (a * B))", "unfolding d_def"], ["proof (prove)\nusing this:\n  (M * (1 / a * 1))-lipschitz_on {a * A..a * B} (c \\<circ> (*) (1 / a))\n  M-lipschitz_on {A..B} c\n  geodesic_segment_between G (c A) (c B)\n  x \\<in> G\n  0 < a\n\ngoal (2 subgoals):\n 1. (M / a)-lipschitz_on {a * A..a * B} (c \\<circ> (*) (1 / a))\n 2. geodesic_segment_between G ((c \\<circ> (*) (1 / a)) (a * A))\n     ((c \\<circ> (*) (1 / a)) (a * B))", "by auto"], ["proof (state)\nthis:\n  infdist x (d ` {a * A..a * B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * B - a * A)) + M / a\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a", "finally"], ["proof (chain)\npicking this:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * B - a * A)) + M / a", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * B - a * A)) + M / a\n\ngoal (1 subgoal):\n 1. infdist x (c ` {A..B})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  infdist x (c ` {A..B})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (B - A))) + M / a\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can now give another proof of the Morse-Gromov Theorem, as described\nin~\\cite{bridson_haefliger}. It is more direct than the one we have given above, but it gives\na worse dependence in terms of the quasi-isometry constants. In particular, when $C = \\delta = 0$,\nit does not recover the fact that a quasi-geodesic has to coincide with a geodesic.\\<close>"], ["", "theorem (in Gromov_hyperbolic_space_geodesic) Morse_Gromov_theorem_BH_proof:\n  fixes c::\"real \\<Rightarrow> 'a\"\n  assumes \"lambda C-quasi_isometry_on {A..B} c\"\n  shows \"hausdorff_distance (c`{A..B}) {c A--c B} \\<le> 72 * lambda^2 * (C + lambda + deltaG(TYPE('a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have C: \"C \\<ge> 0\" \"lambda \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 1 \\<le> lambda", "using quasi_isometry_onD[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {A..B}; ?y \\<in> {A..B}\\<rbrakk>\n  \\<Longrightarrow> dist (c ?x) (c ?y) \\<le> lambda * dist ?x ?y + C\n  \\<lbrakk>?x \\<in> {A..B}; ?y \\<in> {A..B}\\<rbrakk>\n  \\<Longrightarrow> 1 / lambda * dist ?x ?y - C \\<le> dist (c ?x) (c ?y)\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> C &&& 1 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "consider \"B-A < 0\" | \"B-A \\<ge> 0 \\<and> dist (c A) (c B) \\<le> 2 * C\" | \"B-A \\<ge> 0 \\<and> dist (c A) (c B) > 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>B - A < 0 \\<Longrightarrow> thesis;\n     0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n     thesis;\n     0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>B - A < 0 \\<Longrightarrow> ?thesis;\n   0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n   ?thesis;\n   0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>B - A < 0 \\<Longrightarrow> ?thesis;\n   0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n   ?thesis;\n   0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>B - A < 0 \\<Longrightarrow> ?thesis;\n   0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n   ?thesis;\n   0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. B - A < 0 \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 3. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "case 1"], ["proof (state)\nthis:\n  B - A < 0\n\ngoal (3 subgoals):\n 1. B - A < 0 \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 3. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  B - A < 0", "have \"c`{A..B} = {}\""], ["proof (prove)\nusing this:\n  B - A < 0\n\ngoal (1 subgoal):\n 1. c ` {A..B} = {}", "by auto"], ["proof (state)\nthis:\n  c ` {A..B} = {}\n\ngoal (3 subgoals):\n 1. B - A < 0 \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 3. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  c ` {A..B} = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  c ` {A..B} = {}\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "unfolding hausdorff_distance_def"], ["proof (prove)\nusing this:\n  c ` {A..B} = {}\n\ngoal (1 subgoal):\n 1. (if c ` {A..B} = {} \\<or>\n        {c A--c B} = {} \\<or>\n        \\<not> bounded (c ` {A..B}) \\<or> \\<not> bounded {c A--c B}\n     then 0\n     else max (SUP x\\<in>c ` {A..B}. infdist x {c A--c B})\n           (SUP x\\<in>{c A--c B}. infdist x (c ` {A..B})))\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "using delta_nonneg C"], ["proof (prove)\nusing this:\n  c ` {A..B} = {}\n  0 \\<le> deltaG TYPE('a)\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. (if c ` {A..B} = {} \\<or>\n        {c A--c B} = {} \\<or>\n        \\<not> bounded (c ` {A..B}) \\<or> \\<not> bounded {c A--c B}\n     then 0\n     else max (SUP x\\<in>c ` {A..B}. infdist x {c A--c B})\n           (SUP x\\<in>{c A--c B}. infdist x (c ` {A..B})))\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "case 2"], ["proof (state)\nthis:\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"(1/lambda) * dist A B - C \\<le> dist (c A) (c B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / lambda * dist A B - C \\<le> dist (c A) (c B)", "apply (rule quasi_isometry_onD[OF assms])"], ["proof (prove)\ngoal (2 subgoals):\n 1. A \\<in> {A..B}\n 2. B \\<in> {A..B}", "using 2"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n\ngoal (2 subgoals):\n 1. A \\<in> {A..B}\n 2. B \\<in> {A..B}", "by auto"], ["proof (state)\nthis:\n  1 / lambda * dist A B - C \\<le> dist (c A) (c B)\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  1 / lambda * dist A B - C \\<le> dist (c A) (c B)\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (c A) (c B) \\<le> 2 * C", "using 2"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. dist (c A) (c B) \\<le> 2 * C", "by auto"], ["proof (state)\nthis:\n  dist (c A) (c B) \\<le> 2 * C\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  1 / lambda * dist A B - C \\<le> 2 * C", "have \"dist A B \\<le> 3 * lambda * C\""], ["proof (prove)\nusing this:\n  1 / lambda * dist A B - C \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. dist A B \\<le> 3 * lambda * C", "using C"], ["proof (prove)\nusing this:\n  1 / lambda * dist A B - C \\<le> 2 * C\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. dist A B \\<le> 3 * lambda * C", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  dist A B \\<le> 3 * lambda * C\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  dist A B \\<le> 3 * lambda * C", "have *: \"B - A \\<le> 3 * lambda * C\""], ["proof (prove)\nusing this:\n  dist A B \\<le> 3 * lambda * C\n\ngoal (1 subgoal):\n 1. B - A \\<le> 3 * lambda * C", "using 2"], ["proof (prove)\nusing this:\n  dist A B \\<le> 3 * lambda * C\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. B - A \\<le> 3 * lambda * C", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  \\<bar>A - B\\<bar> \\<le> 3 * lambda * C\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. B - A \\<le> 3 * lambda * C", "by auto"], ["proof (state)\nthis:\n  B - A \\<le> 3 * lambda * C\n\ngoal (2 subgoals):\n 1. 0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "proof (rule hausdorff_distanceI2)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 3. 0 \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "show \"0 \\<le> 72 * lambda^2 * (C + lambda + deltaG(TYPE('a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "assume \"x \\<in> c`{A..B}\""], ["proof (state)\nthis:\n  x \\<in> c ` {A..B}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  x \\<in> c ` {A..B}", "obtain t where t: \"x = c t\" \"t \\<in> {A..B}\""], ["proof (prove)\nusing this:\n  x \\<in> c ` {A..B}\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>x = c t; t \\<in> {A..B}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = c t\n  t \\<in> {A..B}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"dist x (c A) \\<le> lambda * dist t A + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist x (c A) \\<le> lambda * dist t A + C", "unfolding t(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (c t) (c A) \\<le> lambda * dist t A + C", "using quasi_isometry_onD(1)[OF assms t(2), of A] 2"], ["proof (prove)\nusing this:\n  A \\<in> {A..B} \\<Longrightarrow>\n  dist (c t) (c A) \\<le> lambda * dist t A + C\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. dist (c t) (c A) \\<le> lambda * dist t A + C", "by auto"], ["proof (state)\nthis:\n  dist x (c A) \\<le> lambda * dist t A + C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  dist x (c A) \\<le> lambda * dist t A + C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> lambda * (B-A) + C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * dist t A + C \\<le> lambda * (B - A) + C", "using t(2) 2 C"], ["proof (prove)\nusing this:\n  t \\<in> {A..B}\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. lambda * dist t A + C \\<le> lambda * (B - A) + C", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  t \\<in> {A..B}\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. lambda * \\<bar>t - A\\<bar> + C \\<le> lambda * (B - A) + C", "by auto"], ["proof (state)\nthis:\n  lambda * dist t A + C \\<le> lambda * (B - A) + C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  lambda * dist t A + C \\<le> lambda * (B - A) + C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> 3 * lambda * lambda * C + 1 * 1 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (B - A) + C \\<le> 3 * lambda * lambda * C + 1 * 1 * C", "using * C"], ["proof (prove)\nusing this:\n  B - A \\<le> 3 * lambda * C\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. lambda * (B - A) + C \\<le> 3 * lambda * lambda * C + 1 * 1 * C", "by auto"], ["proof (state)\nthis:\n  lambda * (B - A) + C \\<le> 3 * lambda * lambda * C + 1 * 1 * C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  lambda * (B - A) + C \\<le> 3 * lambda * lambda * C + 1 * 1 * C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> 3 * lambda * lambda * C + lambda * lambda * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * lambda * lambda * C + 1 * 1 * C\n    \\<le> 3 * lambda * lambda * C + lambda * lambda * C", "apply (intro mono_intros)"], ["proof (prove)\ngoal (5 subgoals):\n 1. 1 \\<le> lambda\n 2. 1 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> 1\n 5. 0 \\<le> C", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (5 subgoals):\n 1. 1 \\<le> lambda\n 2. 1 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> 1\n 5. 0 \\<le> C", "by auto"], ["proof (state)\nthis:\n  3 * lambda * lambda * C + 1 * 1 * C\n  \\<le> 3 * lambda * lambda * C + lambda * lambda * C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  3 * lambda * lambda * C + 1 * 1 * C\n  \\<le> 3 * lambda * lambda * C + lambda * lambda * C\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... = 4 * lambda * lambda * (C + 0 + 0^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * lambda * lambda * C + lambda * lambda * C =\n    4 * lambda * lambda * (C + 0 + 0\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  3 * lambda * lambda * C + lambda * lambda * C =\n  4 * lambda * lambda * (C + 0 + 0\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  3 * lambda * lambda * C + lambda * lambda * C =\n  4 * lambda * lambda * (C + 0 + 0\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> 72 * lambda * lambda * (C + lambda + deltaG(TYPE('a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * lambda * lambda * (C + 0 + 0\\<^sup>2)\n    \\<le> 72 * lambda * lambda * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (7 subgoals):\n 1. 4 \\<le> 72\n 2. 0 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> lambda\n 5. 0 \\<le> 0\n 6. 0 \\<le> 72 * lambda * lambda\n 7. 0 \\<le> C + 0 + 0\\<^sup>2", "using C delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  0 \\<le> deltaG TYPE('a)\n\ngoal (7 subgoals):\n 1. 4 \\<le> 72\n 2. 0 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> lambda\n 5. 0 \\<le> 0\n 6. 0 \\<le> 72 * lambda * lambda\n 7. 0 \\<le> C + 0 + 0\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  4 * lambda * lambda * (C + 0 + 0\\<^sup>2)\n  \\<le> 72 * lambda * lambda * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  dist x (c A)\n  \\<le> 72 * lambda * lambda * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have *: \"dist x (c A) \\<le> 72 * lambda^2 * (C + lambda + deltaG(TYPE('a))^2)\""], ["proof (prove)\nusing this:\n  dist x (c A)\n  \\<le> 72 * lambda * lambda * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist x (c A)\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "unfolding power2_eq_square"], ["proof (prove)\nusing this:\n  dist x (c A)\n  \\<le> 72 * lambda * lambda *\n        (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. dist x (c A)\n    \\<le> 72 * (lambda * lambda) *\n          (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))", "by simp"], ["proof (state)\nthis:\n  dist x (c A)\n  \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> c ` {A..B} \\<Longrightarrow>\n       \\<exists>y\\<in>{c A--c B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "show \"\\<exists>y\\<in>{c A--c B}. dist x y \\<le> 72 * lambda^2 * (C + lambda + deltaG(TYPE('a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>{c A--c B}.\n       dist x y\n       \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "apply (rule bexI[of _ \"c A\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x (c A)\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. c A \\<in> {c A--c B}", "using *"], ["proof (prove)\nusing this:\n  dist x (c A)\n  \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (2 subgoals):\n 1. dist x (c A)\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. c A \\<in> {c A--c B}", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>{c A--c B}.\n     dist x y\n     \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "assume \"x \\<in> {c A-- c B}\""], ["proof (state)\nthis:\n  x \\<in> {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  x \\<in> {c A--c B}", "have \"dist x (c A) \\<le> dist (c A) (c B)\""], ["proof (prove)\nusing this:\n  x \\<in> {c A--c B}\n\ngoal (1 subgoal):\n 1. dist x (c A) \\<le> dist (c A) (c B)", "by (meson geodesic_segment_dist_le geodesic_segment_endpoints(1) local.some_geodesic_is_geodesic_segment(1))"], ["proof (state)\nthis:\n  dist x (c A) \\<le> dist (c A) (c B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  dist x (c A) \\<le> dist (c A) (c B)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (c A) (c B) \\<le> 2 * C", "using 2"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. dist (c A) (c B) \\<le> 2 * C", "by auto"], ["proof (state)\nthis:\n  dist (c A) (c B) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  dist (c A) (c B) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> 2 * 1 * 1 * (C + lambda + 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * C \\<le> 2 * 1 * 1 * (C + lambda + 0)", "using 2 C"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 2 * C \\<le> 2 * 1 * 1 * (C + lambda + 0)", "unfolding dist_real_def"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 2 * C \\<le> 2 * 1 * 1 * (C + lambda + 0)", "by auto"], ["proof (state)\nthis:\n  2 * C \\<le> 2 * 1 * 1 * (C + lambda + 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  2 * C \\<le> 2 * 1 * 1 * (C + lambda + 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> 72 * lambda * lambda * (C + lambda + deltaG(TYPE('a)) * deltaG(TYPE('a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * 1 * 1 * (C + lambda + 0)\n    \\<le> 72 * lambda * lambda *\n          (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (10 subgoals):\n 1. 2 \\<le> 72\n 2. 1 \\<le> lambda\n 3. 0 \\<le> 72\n 4. 0 \\<le> 1\n 5. 1 \\<le> lambda\n 6. 0 \\<le> 72 * lambda\n 7. 0 \\<le> 1\n 8. 0 \\<le> deltaG TYPE('a) * deltaG TYPE('a)\n 9. 0 \\<le> 72 * lambda * lambda\n 10. 0 \\<le> C + lambda + 0", "using C delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  0 \\<le> deltaG TYPE('a)\n\ngoal (10 subgoals):\n 1. 2 \\<le> 72\n 2. 1 \\<le> lambda\n 3. 0 \\<le> 72\n 4. 0 \\<le> 1\n 5. 1 \\<le> lambda\n 6. 0 \\<le> 72 * lambda\n 7. 0 \\<le> 1\n 8. 0 \\<le> deltaG TYPE('a) * deltaG TYPE('a)\n 9. 0 \\<le> 72 * lambda * lambda\n 10. 0 \\<le> C + lambda + 0", "by auto"], ["proof (state)\nthis:\n  2 * 1 * 1 * (C + lambda + 0)\n  \\<le> 72 * lambda * lambda *\n        (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  dist x (c A)\n  \\<le> 72 * lambda * lambda *\n        (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))", "have *: \"dist x (c A) \\<le> 72 * lambda * lambda * (C + lambda + deltaG(TYPE('a)) * deltaG(TYPE('a)))\""], ["proof (prove)\nusing this:\n  dist x (c A)\n  \\<le> 72 * lambda * lambda *\n        (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. dist x (c A)\n    \\<le> 72 * lambda * lambda *\n          (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))", "by simp"], ["proof (state)\nthis:\n  dist x (c A)\n  \\<le> 72 * lambda * lambda *\n        (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow>\n       \\<exists>y\\<in>c ` {A..B}.\n          dist x y\n          \\<le> 72 * lambda\\<^sup>2 *\n                (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "show \"\\<exists>y\\<in>c`{A..B}. dist x y \\<le> 72 * lambda^2 * (C + lambda + deltaG(TYPE('a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>c ` {A..B}.\n       dist x y\n       \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "apply (rule bexI[of _ \"c A\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x (c A)\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n 2. c A \\<in> c ` {A..B}", "unfolding power2_eq_square"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x (c A)\n    \\<le> 72 * (lambda * lambda) *\n          (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))\n 2. c A \\<in> c ` {A..B}", "using * 2"], ["proof (prove)\nusing this:\n  dist x (c A)\n  \\<le> 72 * lambda * lambda *\n        (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))\n  0 \\<le> B - A \\<and> dist (c A) (c B) \\<le> 2 * C\n\ngoal (2 subgoals):\n 1. dist x (c A)\n    \\<le> 72 * (lambda * lambda) *\n          (C + lambda + deltaG TYPE('a) * deltaG TYPE('a))\n 2. c A \\<in> c ` {A..B}", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>c ` {A..B}.\n     dist x y\n     \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "case 3"], ["proof (state)\nthis:\n  0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B)", "obtain d where d: \"continuous_on {A..B} d\" \"d A = c A\" \"d B = c B\"\n              \"\\<And>x. x \\<in> {A..B} \\<Longrightarrow> dist (c x) (d x) \\<le> 4 *C\"\n              \"lambda (4 * C)-quasi_isometry_on {A..B} d\"\n              \"(2 * lambda)-lipschitz_on {A..B} d\"\n              \"hausdorff_distance (c`{A..B}) (d`{A..B}) \\<le> 2 * C\""], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>continuous_on {A..B} d; d A = c A; d B = c B;\n         \\<And>x.\n            x \\<in> {A..B} \\<Longrightarrow> dist (c x) (d x) \\<le> 4 * C;\n         lambda (4 * C) -quasi_isometry_on {A..B} d;\n         (2 * lambda)-lipschitz_on {A..B} d;\n         hausdorff_distance (c ` {A..B}) (d ` {A..B}) \\<le> 2 * C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using quasi_geodesic_made_lipschitz[OF assms] C(1)"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B)\n  2 * C \\<le> dist (c A) (c B) \\<Longrightarrow>\n  \\<exists>d.\n     continuous_on {A..B} d \\<and>\n     d A = c A \\<and>\n     d B = c B \\<and>\n     (\\<forall>x\\<in>{A..B}. dist (c x) (d x) \\<le> 4 * C) \\<and>\n     lambda (4 * C) -quasi_isometry_on {A..B} d \\<and>\n     (2 * lambda)-lipschitz_on {A..B} d \\<and>\n     hausdorff_distance (c ` {A..B}) (d ` {A..B}) \\<le> 2 * C\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>continuous_on {A..B} d; d A = c A; d B = c B;\n         \\<And>x.\n            x \\<in> {A..B} \\<Longrightarrow> dist (c x) (d x) \\<le> 4 * C;\n         lambda (4 * C) -quasi_isometry_on {A..B} d;\n         (2 * lambda)-lipschitz_on {A..B} d;\n         hausdorff_distance (c ` {A..B}) (d ` {A..B}) \\<le> 2 * C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  continuous_on {A..B} d\n  d A = c A\n  d B = c B\n  ?x \\<in> {A..B} \\<Longrightarrow> dist (c ?x) (d ?x) \\<le> 4 * C\n  lambda (4 * C) -quasi_isometry_on {A..B} d\n  (2 * lambda)-lipschitz_on {A..B} d\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"A \\<in> {A..B}\" \"B \\<in> {A..B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> {A..B} &&& B \\<in> {A..B}", "using 3"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B)\n\ngoal (1 subgoal):\n 1. A \\<in> {A..B} &&& B \\<in> {A..B}", "by auto"], ["proof (state)\nthis:\n  A \\<in> {A..B}\n  B \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "text \\<open>We show that the distance of any point in the geodesic from $c(A)$ to $c(B)$ is a bounded\n    distance away from the quasi-geodesic $d$, by considering a point $x$ where the distance $D$ is\n    maximal and arguing around this point.\n\n    Consider the point $x_m$ on the geodesic $[c(A), c(B)]$ at distance $2D$ from $x$, and the closest\n    point $y_m$ on the image of $d$. Then the distance between $x_m$ and $y_m$ is at most $D$. Hence\n    a point on $[x_m,y_m]$ is at distance at least $2D - D = D$ of $x$. In the same way, define $x_M$\n    and $y_M$ on the other side of $x$. Then the excursion from $x_m$ to $y_m$, then to $y_M$ along\n    $d$, then to $x_M$, has length at most $D + (\\lambda \\cdot 6D + C) + D$ and is always at distance\n    at least $D$ from $x$. It follows from the previous lemma that $D \\leq \\log(length)$, which\n    implies a bound on $D$.\n\n    This argument has to be amended if $x$ is at distance $ < 2D$ from $c(A)$ or $c(B)$. In this case,\n    simply use $x_m = y_m = c(A)$ or $x_M = y_M = c(B)$, then everything goes through.\\<close>"], ["proof (state)\nthis:\n  A \\<in> {A..B}\n  B \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"\\<exists>x \\<in> {c A--c B}. \\<forall>y \\<in> {c A--c B}. infdist y (d`{A..B}) \\<le> infdist x (d`{A..B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{c A--c B}.\n       \\<forall>y\\<in>{c A--c B}.\n          infdist y (d ` {A..B}) \\<le> infdist x (d ` {A..B})", "by (rule continuous_attains_sup, auto intro: continuous_intros)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{c A--c B}.\n     \\<forall>y\\<in>{c A--c B}.\n        infdist y (d ` {A..B}) \\<le> infdist x (d ` {A..B})\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>{c A--c B}.\n     \\<forall>y\\<in>{c A--c B}.\n        infdist y (d ` {A..B}) \\<le> infdist x (d ` {A..B})", "obtain x where x: \"x \\<in> {c A--c B}\" \"\\<And>y. y \\<in> {c A--c B} \\<Longrightarrow> infdist y (d`{A..B}) \\<le> infdist x (d`{A..B})\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>{c A--c B}.\n     \\<forall>y\\<in>{c A--c B}.\n        infdist y (d ` {A..B}) \\<le> infdist x (d ` {A..B})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {c A--c B};\n         \\<And>y.\n            y \\<in> {c A--c B} \\<Longrightarrow>\n            infdist y (d ` {A..B}) \\<le> infdist x (d ` {A..B})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> {c A--c B}\n  ?y \\<in> {c A--c B} \\<Longrightarrow>\n  infdist ?y (d ` {A..B}) \\<le> infdist x (d ` {A..B})\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "define D where \"D = infdist x (d`{A..B})\""], ["proof (state)\nthis:\n  D = infdist x (d ` {A..B})\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"D \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> infdist x (d ` {A..B})", "by (rule infdist_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have D_bound: \"D \\<le> 24 * lambda + 12 * C + 24 * deltaG(TYPE('a))^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "proof (cases \"D \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n 2. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "case True"], ["proof (state)\nthis:\n  D \\<le> 1\n\ngoal (2 subgoals):\n 1. D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n 2. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"1 * 1 + 1 * 0 + 0 * 0 \\<le> 24 * lambda + 12 * C + 24 * deltaG(TYPE('a))^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 1 + 1 * 0 + 0 * 0\n    \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "apply (intro mono_intros)"], ["proof (prove)\ngoal (12 subgoals):\n 1. 1 \\<le> 24\n 2. 1 \\<le> lambda\n 3. 0 \\<le> 24\n 4. 0 \\<le> 1\n 5. 1 \\<le> 12\n 6. 0 \\<le> C\n 7. 0 \\<le> 12\n 8. 0 \\<le> 0\n 9. 0 \\<le> 24\n 10. 0 \\<le> (deltaG TYPE('a))\\<^sup>2\nA total of 12 subgoals...", "using C delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  0 \\<le> deltaG TYPE('a)\n\ngoal (12 subgoals):\n 1. 1 \\<le> 24\n 2. 1 \\<le> lambda\n 3. 0 \\<le> 24\n 4. 0 \\<le> 1\n 5. 1 \\<le> 12\n 6. 0 \\<le> C\n 7. 0 \\<le> 12\n 8. 0 \\<le> 0\n 9. 0 \\<le> 24\n 10. 0 \\<le> (deltaG TYPE('a))\\<^sup>2\nA total of 12 subgoals...", "by auto"], ["proof (state)\nthis:\n  1 * 1 + 1 * 0 + 0 * 0\n  \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n\ngoal (2 subgoals):\n 1. D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n 2. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  1 * 1 + 1 * 0 + 0 * 0\n  \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  1 * 1 + 1 * 0 + 0 * 0\n  \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n\ngoal (1 subgoal):\n 1. D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "using True"], ["proof (prove)\nusing this:\n  1 * 1 + 1 * 0 + 0 * 0\n  \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n  D \\<le> 1\n\ngoal (1 subgoal):\n 1. D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "case False"], ["proof (state)\nthis:\n  \\<not> D \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<not> D \\<le> 1", "have \"D \\<ge> 1\""], ["proof (prove)\nusing this:\n  \\<not> D \\<le> 1\n\ngoal (1 subgoal):\n 1. 1 \\<le> D", "by auto"], ["proof (state)\nthis:\n  1 \\<le> D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have ln2mult: \"2 * ln t = ln (t * t)\" if \"t > 0\" for t::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * ln t = ln (t * t)", "by (simp add: that ln_mult)"], ["proof (state)\nthis:\n  0 < ?t \\<Longrightarrow> 2 * ln ?t = ln (?t * ?t)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"infdist (c A) (d`{A..B}) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (c A) (d ` {A..B}) = 0", "using \\<open>d A = c A\\<close>"], ["proof (prove)\nusing this:\n  d A = c A\n\ngoal (1 subgoal):\n 1. infdist (c A) (d ` {A..B}) = 0", "by (metis \\<open>A \\<in> {A..B}\\<close> image_eqI infdist_zero)"], ["proof (state)\nthis:\n  infdist (c A) (d ` {A..B}) = 0\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  infdist (c A) (d ` {A..B}) = 0", "have \"x \\<noteq> c A\""], ["proof (prove)\nusing this:\n  infdist (c A) (d ` {A..B}) = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> c A", "using \\<open>D \\<ge> 1\\<close> D_def"], ["proof (prove)\nusing this:\n  infdist (c A) (d ` {A..B}) = 0\n  1 \\<le> D\n  D = infdist x (d ` {A..B})\n\ngoal (1 subgoal):\n 1. x \\<noteq> c A", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> c A\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "define tx where \"tx = dist (c A) x\""], ["proof (state)\nthis:\n  tx = dist (c A) x\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  tx = dist (c A) x", "have \"tx \\<in> {0..dist (c A) (c B)}\""], ["proof (prove)\nusing this:\n  tx = dist (c A) x\n\ngoal (1 subgoal):\n 1. tx \\<in> {0..dist (c A) (c B)}", "using \\<open>x \\<in> {c A--c B}\\<close>"], ["proof (prove)\nusing this:\n  tx = dist (c A) x\n  x \\<in> {c A--c B}\n\ngoal (1 subgoal):\n 1. tx \\<in> {0..dist (c A) (c B)}", "by (meson atLeastAtMost_iff geodesic_segment_dist_le some_geodesic_is_geodesic_segment(1) metric_space_class.zero_le_dist some_geodesic_endpoints(1))"], ["proof (state)\nthis:\n  tx \\<in> {0..dist (c A) (c B)}\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"tx > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < tx", "using \\<open>x \\<noteq> c A\\<close> tx_def"], ["proof (prove)\nusing this:\n  x \\<noteq> c A\n  tx = dist (c A) x\n\ngoal (1 subgoal):\n 1. 0 < tx", "by auto"], ["proof (state)\nthis:\n  0 < tx\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have x_param: \"x = geodesic_segment_param {c A--c B} (c A) tx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = geodesic_segment_param {c A--c B} (c A) tx", "using \\<open>x \\<in> {c A--c B}\\<close> geodesic_segment_param[OF some_geodesic_is_geodesic_segment(1)] tx_def"], ["proof (prove)\nusing this:\n  x \\<in> {c A--c B}\n  geodesic_segment_param {?x--?y} ?x 0 = ?x\n  geodesic_segment_param {?x--?y} ?x (dist ?x ?y) = ?y\n  ?t \\<in> {0..dist ?x ?y} \\<Longrightarrow>\n  geodesic_segment_param {?x--?y} ?x ?t \\<in> {?x--?y}\n  isometry_on {0..dist ?x ?y} (geodesic_segment_param {?x--?y} ?x)\n  geodesic_segment_param {?x--?y} ?x ` {0..dist ?x ?y} = {?x--?y}\n  ?t \\<in> {0..dist ?x ?y} \\<Longrightarrow>\n  dist ?x (geodesic_segment_param {?x--?y} ?x ?t) = ?t\n  \\<lbrakk>?s \\<in> {0..dist ?x ?y}; ?t \\<in> {0..dist ?x ?y}\\<rbrakk>\n  \\<Longrightarrow> dist (geodesic_segment_param {?x--?y} ?x ?s)\n                     (geodesic_segment_param {?x--?y} ?x ?t) =\n                    \\<bar>?s - ?t\\<bar>\n  ?z \\<in> {?x--?y} \\<Longrightarrow>\n  ?z = geodesic_segment_param {?x--?y} ?x (dist ?x ?z)\n  tx = dist (c A) x\n\ngoal (1 subgoal):\n 1. x = geodesic_segment_param {c A--c B} (c A) tx", "by auto"], ["proof (state)\nthis:\n  x = geodesic_segment_param {c A--c B} (c A) tx\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "define tm where \"tm = max (tx - 2 * D) 0\""], ["proof (state)\nthis:\n  tm = max (tx - 2 * D) 0\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"tm \\<in> {0..dist (c A) (c B)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm \\<in> {0..dist (c A) (c B)}", "unfolding tm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (tx - 2 * D) 0 \\<in> {0..dist (c A) (c B)}", "using \\<open>tx \\<in> {0..dist (c A) (c B)}\\<close> \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  tx \\<in> {0..dist (c A) (c B)}\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. max (tx - 2 * D) 0 \\<in> {0..dist (c A) (c B)}", "by auto"], ["proof (state)\nthis:\n  tm \\<in> {0..dist (c A) (c B)}\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "define xm where \"xm = geodesic_segment_param {c A--c B} (c A) tm\""], ["proof (state)\nthis:\n  xm = geodesic_segment_param {c A--c B} (c A) tm\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"xm \\<in> {c A--c B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xm \\<in> {c A--c B}", "using \\<open>tm \\<in> {0..dist (c A) (c B)}\\<close>"], ["proof (prove)\nusing this:\n  tm \\<in> {0..dist (c A) (c B)}\n\ngoal (1 subgoal):\n 1. xm \\<in> {c A--c B}", "by (metis geodesic_segment_param(3) local.some_geodesic_is_geodesic_segment(1) xm_def)"], ["proof (state)\nthis:\n  xm \\<in> {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"dist xm x = abs((max (tx - 2 * D) 0) - tx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xm x = \\<bar>max (tx - 2 * D) 0 - tx\\<bar>", "unfolding xm_def tm_def x_param"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {c A--c B} (c A) (max (tx - 2 * D) 0))\n     (geodesic_segment_param {c A--c B} (c A) tx) =\n    \\<bar>max (tx - 2 * D) 0 - tx\\<bar>", "apply (rule geodesic_segment_param[of _ _ \"c B\"], auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. tx - 2 * D \\<le> dist (c A) (c B)\n 2. 0 \\<le> tx\n 3. tx \\<le> dist (c A) (c B)", "using \\<open>tx \\<in> {0..dist (c A) (c B)}\\<close> \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  tx \\<in> {0..dist (c A) (c B)}\n  0 \\<le> D\n\ngoal (3 subgoals):\n 1. tx - 2 * D \\<le> dist (c A) (c B)\n 2. 0 \\<le> tx\n 3. tx \\<le> dist (c A) (c B)", "by auto"], ["proof (state)\nthis:\n  dist xm x = \\<bar>max (tx - 2 * D) 0 - tx\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  dist xm x = \\<bar>max (tx - 2 * D) 0 - tx\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> 2 * D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>max (tx - 2 * D) 0 - tx\\<bar> \\<le> 2 * D", "by (simp add: \\<open>0 \\<le> D\\<close> tx_def)"], ["proof (state)\nthis:\n  \\<bar>max (tx - 2 * D) 0 - tx\\<bar> \\<le> 2 * D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  dist xm x \\<le> 2 * D", "have \"dist xm x \\<le> 2 * D\""], ["proof (prove)\nusing this:\n  dist xm x \\<le> 2 * D\n\ngoal (1 subgoal):\n 1. dist xm x \\<le> 2 * D", "by auto"], ["proof (state)\nthis:\n  dist xm x \\<le> 2 * D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"\\<exists>ym\\<in>d`{A..B}. infdist xm (d`{A..B}) = dist xm ym\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ym\\<in>d ` {A..B}. infdist xm (d ` {A..B}) = dist xm ym", "apply (rule infdist_proper_attained)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper (d ` {A..B})\n 2. d ` {A..B} \\<noteq> {}", "using 3 d(1) proper_of_compact compact_continuous_image"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B)\n  continuous_on {A..B} d\n  compact ?S \\<Longrightarrow> proper ?S\n  \\<lbrakk>continuous_on ?s ?f; compact ?s\\<rbrakk>\n  \\<Longrightarrow> compact (?f ` ?s)\n\ngoal (2 subgoals):\n 1. proper (d ` {A..B})\n 2. d ` {A..B} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>ym\\<in>d ` {A..B}. infdist xm (d ` {A..B}) = dist xm ym\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<exists>ym\\<in>d ` {A..B}. infdist xm (d ` {A..B}) = dist xm ym", "obtain ym where ym: \"ym \\<in> d`{A..B}\" \"dist xm ym = infdist xm (d`{A..B})\""], ["proof (prove)\nusing this:\n  \\<exists>ym\\<in>d ` {A..B}. infdist xm (d ` {A..B}) = dist xm ym\n\ngoal (1 subgoal):\n 1. (\\<And>ym.\n        \\<lbrakk>ym \\<in> d ` {A..B};\n         dist xm ym = infdist xm (d ` {A..B})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ym \\<in> d ` {A..B}\n  dist xm ym = infdist xm (d ` {A..B})\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  ym \\<in> d ` {A..B}\n  dist xm ym = infdist xm (d ` {A..B})", "obtain um where um: \"um \\<in> {A..B}\" \"ym = d um\""], ["proof (prove)\nusing this:\n  ym \\<in> d ` {A..B}\n  dist xm ym = infdist xm (d ` {A..B})\n\ngoal (1 subgoal):\n 1. (\\<And>um.\n        \\<lbrakk>um \\<in> {A..B}; ym = d um\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  um \\<in> {A..B}\n  ym = d um\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"dist xm ym \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xm ym \\<le> D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xm ym \\<le> infdist x (d ` {A..B})", "using x ym"], ["proof (prove)\nusing this:\n  x \\<in> {c A--c B}\n  ?y \\<in> {c A--c B} \\<Longrightarrow>\n  infdist ?y (d ` {A..B}) \\<le> infdist x (d ` {A..B})\n  ym \\<in> d ` {A..B}\n  dist xm ym = infdist xm (d ` {A..B})\n\ngoal (1 subgoal):\n 1. dist xm ym \\<le> infdist x (d ` {A..B})", "by (simp add: \\<open>xm \\<in> {c A--c B}\\<close>)"], ["proof (state)\nthis:\n  dist xm ym \\<le> D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have D1: \"dist x z \\<ge> D\" if \"z \\<in> {xm--ym}\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "proof (cases \"tx - 2 * D < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "case True"], ["proof (state)\nthis:\n  tx - 2 * D < 0\n\ngoal (2 subgoals):\n 1. tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  tx - 2 * D < 0", "have \"tm = 0\""], ["proof (prove)\nusing this:\n  tx - 2 * D < 0\n\ngoal (1 subgoal):\n 1. tm = 0", "unfolding tm_def"], ["proof (prove)\nusing this:\n  tx - 2 * D < 0\n\ngoal (1 subgoal):\n 1. max (tx - 2 * D) 0 = 0", "by auto"], ["proof (state)\nthis:\n  tm = 0\n\ngoal (2 subgoals):\n 1. tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  tm = 0", "have \"xm = c A\""], ["proof (prove)\nusing this:\n  tm = 0\n\ngoal (1 subgoal):\n 1. xm = c A", "unfolding xm_def"], ["proof (prove)\nusing this:\n  tm = 0\n\ngoal (1 subgoal):\n 1. geodesic_segment_param {c A--c B} (c A) tm = c A", "by (meson geodesic_segment_param(1) local.some_geodesic_is_geodesic_segment(1))"], ["proof (state)\nthis:\n  xm = c A\n\ngoal (2 subgoals):\n 1. tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  xm = c A", "have \"infdist xm (d`{A..B}) = 0\""], ["proof (prove)\nusing this:\n  xm = c A\n\ngoal (1 subgoal):\n 1. infdist xm (d ` {A..B}) = 0", "using \\<open>d A = c A\\<close> \\<open>A \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  xm = c A\n  d A = c A\n  A \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. infdist xm (d ` {A..B}) = 0", "by (metis image_eqI infdist_zero)"], ["proof (state)\nthis:\n  infdist xm (d ` {A..B}) = 0\n\ngoal (2 subgoals):\n 1. tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  infdist xm (d ` {A..B}) = 0", "have \"ym = xm\""], ["proof (prove)\nusing this:\n  infdist xm (d ` {A..B}) = 0\n\ngoal (1 subgoal):\n 1. ym = xm", "using ym(2)"], ["proof (prove)\nusing this:\n  infdist xm (d ` {A..B}) = 0\n  dist xm ym = infdist xm (d ` {A..B})\n\ngoal (1 subgoal):\n 1. ym = xm", "by auto"], ["proof (state)\nthis:\n  ym = xm\n\ngoal (2 subgoals):\n 1. tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  ym = xm", "have \"z = xm\""], ["proof (prove)\nusing this:\n  ym = xm\n\ngoal (1 subgoal):\n 1. z = xm", "using \\<open>z \\<in> {xm--ym}\\<close> geodesic_segment_between_x_x(3)"], ["proof (prove)\nusing this:\n  ym = xm\n  z \\<in> {xm--ym}\n  geodesic_segment_between ?G ?x ?x = (?G = {?x})\n\ngoal (1 subgoal):\n 1. z = xm", "by (metis empty_iff insert_iff some_geodesic_is_geodesic_segment(1))"], ["proof (state)\nthis:\n  z = xm\n\ngoal (2 subgoals):\n 1. tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  z = xm", "have \"z \\<in> d`{A..B}\""], ["proof (prove)\nusing this:\n  z = xm\n\ngoal (1 subgoal):\n 1. z \\<in> d ` {A..B}", "using \\<open>ym = xm\\<close> ym(1)"], ["proof (prove)\nusing this:\n  z = xm\n  ym = xm\n  ym \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. z \\<in> d ` {A..B}", "by blast"], ["proof (state)\nthis:\n  z \\<in> d ` {A..B}\n\ngoal (2 subgoals):\n 1. tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  z \\<in> d ` {A..B}", "show \"dist x z \\<ge> D\""], ["proof (prove)\nusing this:\n  z \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "unfolding D_def"], ["proof (prove)\nusing this:\n  z \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. infdist x (d ` {A..B}) \\<le> dist x z", "by (simp add: infdist_le)"], ["proof (state)\nthis:\n  D \\<le> dist x z\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "case False"], ["proof (state)\nthis:\n  \\<not> tx - 2 * D < 0\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  \\<not> tx - 2 * D < 0", "have *: \"tm = tx - 2 * D\""], ["proof (prove)\nusing this:\n  \\<not> tx - 2 * D < 0\n\ngoal (1 subgoal):\n 1. tm = tx - 2 * D", "unfolding tm_def"], ["proof (prove)\nusing this:\n  \\<not> tx - 2 * D < 0\n\ngoal (1 subgoal):\n 1. max (tx - 2 * D) 0 = tx - 2 * D", "by auto"], ["proof (state)\nthis:\n  tm = tx - 2 * D\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "have \"dist xm x = abs((tx - 2 * D) - tx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xm x = \\<bar>tx - 2 * D - tx\\<bar>", "unfolding xm_def x_param *"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {c A--c B} (c A) (tx - 2 * D))\n     (geodesic_segment_param {c A--c B} (c A) tx) =\n    \\<bar>tx - 2 * D - tx\\<bar>", "apply (rule geodesic_segment_param[of _ _ \"c B\"], auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 2 * D \\<le> tx\n 2. tx - 2 * D \\<le> dist (c A) (c B)\n 3. 0 \\<le> tx\n 4. tx \\<le> dist (c A) (c B)", "using False \\<open>tx \\<in> {0..dist (c A) (c B)}\\<close> \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> tx - 2 * D < 0\n  tx \\<in> {0..dist (c A) (c B)}\n  0 \\<le> D\n\ngoal (4 subgoals):\n 1. 2 * D \\<le> tx\n 2. tx - 2 * D \\<le> dist (c A) (c B)\n 3. 0 \\<le> tx\n 4. tx \\<le> dist (c A) (c B)", "by auto"], ["proof (state)\nthis:\n  dist xm x = \\<bar>tx - 2 * D - tx\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  dist xm x = \\<bar>tx - 2 * D - tx\\<bar>", "have \"2 * D = dist xm x\""], ["proof (prove)\nusing this:\n  dist xm x = \\<bar>tx - 2 * D - tx\\<bar>\n\ngoal (1 subgoal):\n 1. 2 * D = dist xm x", "using \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  dist xm x = \\<bar>tx - 2 * D - tx\\<bar>\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. 2 * D = dist xm x", "by auto"], ["proof (state)\nthis:\n  2 * D = dist xm x\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "also"], ["proof (state)\nthis:\n  2 * D = dist xm x\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "have \"... \\<le> dist xm z + dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xm x \\<le> dist xm z + dist x z", "using metric_space_class.dist_triangle2"], ["proof (prove)\nusing this:\n  dist ?x ?y \\<le> dist ?x ?z + dist ?y ?z\n\ngoal (1 subgoal):\n 1. dist xm x \\<le> dist xm z + dist x z", "by auto"], ["proof (state)\nthis:\n  dist xm x \\<le> dist xm z + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "also"], ["proof (state)\nthis:\n  dist xm x \\<le> dist xm z + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "have \"... \\<le> dist xm ym + dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xm z + dist x z \\<le> dist xm ym + dist x z", "using \\<open>z \\<in> {xm--ym}\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> {xm--ym}\n\ngoal (1 subgoal):\n 1. dist xm z + dist x z \\<le> dist xm ym + dist x z", "by (auto, meson geodesic_segment_dist_le some_geodesic_is_geodesic_segment(1) some_geodesic_endpoints(1))"], ["proof (state)\nthis:\n  dist xm z + dist x z \\<le> dist xm ym + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "also"], ["proof (state)\nthis:\n  dist xm z + dist x z \\<le> dist xm ym + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "have \"... \\<le> D + dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xm ym + dist x z \\<le> D + dist x z", "using \\<open>dist xm ym \\<le> D\\<close>"], ["proof (prove)\nusing this:\n  dist xm ym \\<le> D\n\ngoal (1 subgoal):\n 1. dist xm ym + dist x z \\<le> D + dist x z", "by simp"], ["proof (state)\nthis:\n  dist xm ym + dist x z \\<le> D + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> tx - 2 * D < 0 \\<Longrightarrow> D \\<le> dist x z", "finally"], ["proof (chain)\npicking this:\n  2 * D \\<le> D + dist x z", "show \"dist x z \\<ge> D\""], ["proof (prove)\nusing this:\n  2 * D \\<le> D + dist x z\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "by auto"], ["proof (state)\nthis:\n  D \\<le> dist x z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> {xm--ym} \\<Longrightarrow> D \\<le> dist x ?z\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "define tM where \"tM = min (tx + 2 * D) (dist (c A) (c B))\""], ["proof (state)\nthis:\n  tM = min (tx + 2 * D) (dist (c A) (c B))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"tM \\<in> {0..dist (c A) (c B)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tM \\<in> {0..dist (c A) (c B)}", "unfolding tM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. min (tx + 2 * D) (dist (c A) (c B)) \\<in> {0..dist (c A) (c B)}", "using \\<open>tx \\<in> {0..dist (c A) (c B)}\\<close> \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  tx \\<in> {0..dist (c A) (c B)}\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. min (tx + 2 * D) (dist (c A) (c B)) \\<in> {0..dist (c A) (c B)}", "by auto"], ["proof (state)\nthis:\n  tM \\<in> {0..dist (c A) (c B)}\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"tm \\<le> tM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm \\<le> tM", "unfolding tM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tm \\<le> min (tx + 2 * D) (dist (c A) (c B))", "using \\<open>D \\<ge> 0\\<close> \\<open>tm \\<in> {0..dist (c A) (c B)}\\<close> \\<open>tx \\<equiv> dist (c A) x\\<close> tm_def"], ["proof (prove)\nusing this:\n  0 \\<le> D\n  tm \\<in> {0..dist (c A) (c B)}\n  tx \\<equiv> dist (c A) x\n  tm = max (tx - 2 * D) 0\n\ngoal (1 subgoal):\n 1. tm \\<le> min (tx + 2 * D) (dist (c A) (c B))", "by auto"], ["proof (state)\nthis:\n  tm \\<le> tM\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "define xM where \"xM = geodesic_segment_param {c A--c B} (c A) tM\""], ["proof (state)\nthis:\n  xM = geodesic_segment_param {c A--c B} (c A) tM\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"xM \\<in> {c A--c B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xM \\<in> {c A--c B}", "using \\<open>tM \\<in> {0..dist (c A) (c B)}\\<close>"], ["proof (prove)\nusing this:\n  tM \\<in> {0..dist (c A) (c B)}\n\ngoal (1 subgoal):\n 1. xM \\<in> {c A--c B}", "by (metis geodesic_segment_param(3) local.some_geodesic_is_geodesic_segment(1) xM_def)"], ["proof (state)\nthis:\n  xM \\<in> {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"dist xM x = abs((min (tx + 2 * D) (dist (c A) (c B))) - tx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xM x = \\<bar>min (tx + 2 * D) (dist (c A) (c B)) - tx\\<bar>", "unfolding xM_def tM_def x_param"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist\n     (geodesic_segment_param {c A--c B} (c A)\n       (min (tx + 2 * D) (dist (c A) (c B))))\n     (geodesic_segment_param {c A--c B} (c A) tx) =\n    \\<bar>min (tx + 2 * D) (dist (c A) (c B)) - tx\\<bar>", "apply (rule geodesic_segment_param[of _ _ \"c B\"], auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 \\<le> tx + 2 * D\n 2. 0 \\<le> tx\n 3. tx \\<le> dist (c A) (c B)", "using \\<open>tx \\<in> {0..dist (c A) (c B)}\\<close> \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  tx \\<in> {0..dist (c A) (c B)}\n  0 \\<le> D\n\ngoal (3 subgoals):\n 1. 0 \\<le> tx + 2 * D\n 2. 0 \\<le> tx\n 3. tx \\<le> dist (c A) (c B)", "by auto"], ["proof (state)\nthis:\n  dist xM x = \\<bar>min (tx + 2 * D) (dist (c A) (c B)) - tx\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  dist xM x = \\<bar>min (tx + 2 * D) (dist (c A) (c B)) - tx\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> 2 * D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>min (tx + 2 * D) (dist (c A) (c B)) - tx\\<bar> \\<le> 2 * D", "using \\<open>0 \\<le> D\\<close> \\<open>tx \\<in> {0..dist (c A) (c B)}\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> D\n  tx \\<in> {0..dist (c A) (c B)}\n\ngoal (1 subgoal):\n 1. \\<bar>min (tx + 2 * D) (dist (c A) (c B)) - tx\\<bar> \\<le> 2 * D", "by auto"], ["proof (state)\nthis:\n  \\<bar>min (tx + 2 * D) (dist (c A) (c B)) - tx\\<bar> \\<le> 2 * D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  dist xM x \\<le> 2 * D", "have \"dist xM x \\<le> 2 * D\""], ["proof (prove)\nusing this:\n  dist xM x \\<le> 2 * D\n\ngoal (1 subgoal):\n 1. dist xM x \\<le> 2 * D", "by auto"], ["proof (state)\nthis:\n  dist xM x \\<le> 2 * D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"\\<exists>yM\\<in>d`{A..B}. infdist xM (d`{A..B}) = dist xM yM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>yM\\<in>d ` {A..B}. infdist xM (d ` {A..B}) = dist xM yM", "apply (rule infdist_proper_attained)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper (d ` {A..B})\n 2. d ` {A..B} \\<noteq> {}", "using 3 d(1) proper_of_compact compact_continuous_image"], ["proof (prove)\nusing this:\n  0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B)\n  continuous_on {A..B} d\n  compact ?S \\<Longrightarrow> proper ?S\n  \\<lbrakk>continuous_on ?s ?f; compact ?s\\<rbrakk>\n  \\<Longrightarrow> compact (?f ` ?s)\n\ngoal (2 subgoals):\n 1. proper (d ` {A..B})\n 2. d ` {A..B} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>yM\\<in>d ` {A..B}. infdist xM (d ` {A..B}) = dist xM yM\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<exists>yM\\<in>d ` {A..B}. infdist xM (d ` {A..B}) = dist xM yM", "obtain yM where yM: \"yM \\<in> d`{A..B}\" \"dist xM yM = infdist xM (d`{A..B})\""], ["proof (prove)\nusing this:\n  \\<exists>yM\\<in>d ` {A..B}. infdist xM (d ` {A..B}) = dist xM yM\n\ngoal (1 subgoal):\n 1. (\\<And>yM.\n        \\<lbrakk>yM \\<in> d ` {A..B};\n         dist xM yM = infdist xM (d ` {A..B})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  yM \\<in> d ` {A..B}\n  dist xM yM = infdist xM (d ` {A..B})\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  yM \\<in> d ` {A..B}\n  dist xM yM = infdist xM (d ` {A..B})", "obtain uM where uM: \"uM \\<in> {A..B}\" \"yM = d uM\""], ["proof (prove)\nusing this:\n  yM \\<in> d ` {A..B}\n  dist xM yM = infdist xM (d ` {A..B})\n\ngoal (1 subgoal):\n 1. (\\<And>uM.\n        \\<lbrakk>uM \\<in> {A..B}; yM = d uM\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  uM \\<in> {A..B}\n  yM = d uM\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"dist xM yM \\<le> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xM yM \\<le> D", "unfolding D_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xM yM \\<le> infdist x (d ` {A..B})", "using x yM"], ["proof (prove)\nusing this:\n  x \\<in> {c A--c B}\n  ?y \\<in> {c A--c B} \\<Longrightarrow>\n  infdist ?y (d ` {A..B}) \\<le> infdist x (d ` {A..B})\n  yM \\<in> d ` {A..B}\n  dist xM yM = infdist xM (d ` {A..B})\n\ngoal (1 subgoal):\n 1. dist xM yM \\<le> infdist x (d ` {A..B})", "by (simp add: \\<open>xM \\<in> {c A--c B}\\<close>)"], ["proof (state)\nthis:\n  dist xM yM \\<le> D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have D3: \"dist x z \\<ge> D\" if \"z \\<in> {xM--yM}\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "proof (cases \"tx + 2 * D > dist (c A) (c B)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "case True"], ["proof (state)\nthis:\n  dist (c A) (c B) < tx + 2 * D\n\ngoal (2 subgoals):\n 1. dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  dist (c A) (c B) < tx + 2 * D", "have \"tM = dist (c A) (c B)\""], ["proof (prove)\nusing this:\n  dist (c A) (c B) < tx + 2 * D\n\ngoal (1 subgoal):\n 1. tM = dist (c A) (c B)", "unfolding tM_def"], ["proof (prove)\nusing this:\n  dist (c A) (c B) < tx + 2 * D\n\ngoal (1 subgoal):\n 1. min (tx + 2 * D) (dist (c A) (c B)) = dist (c A) (c B)", "by auto"], ["proof (state)\nthis:\n  tM = dist (c A) (c B)\n\ngoal (2 subgoals):\n 1. dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  tM = dist (c A) (c B)", "have \"xM = c B\""], ["proof (prove)\nusing this:\n  tM = dist (c A) (c B)\n\ngoal (1 subgoal):\n 1. xM = c B", "unfolding xM_def"], ["proof (prove)\nusing this:\n  tM = dist (c A) (c B)\n\ngoal (1 subgoal):\n 1. geodesic_segment_param {c A--c B} (c A) tM = c B", "by (meson geodesic_segment_param(2) local.some_geodesic_is_geodesic_segment(1))"], ["proof (state)\nthis:\n  xM = c B\n\ngoal (2 subgoals):\n 1. dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  xM = c B", "have \"infdist xM (d`{A..B}) = 0\""], ["proof (prove)\nusing this:\n  xM = c B\n\ngoal (1 subgoal):\n 1. infdist xM (d ` {A..B}) = 0", "using \\<open>d B = c B\\<close> \\<open>B \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  xM = c B\n  d B = c B\n  B \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. infdist xM (d ` {A..B}) = 0", "by (metis image_eqI infdist_zero)"], ["proof (state)\nthis:\n  infdist xM (d ` {A..B}) = 0\n\ngoal (2 subgoals):\n 1. dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  infdist xM (d ` {A..B}) = 0", "have \"yM = xM\""], ["proof (prove)\nusing this:\n  infdist xM (d ` {A..B}) = 0\n\ngoal (1 subgoal):\n 1. yM = xM", "using yM(2)"], ["proof (prove)\nusing this:\n  infdist xM (d ` {A..B}) = 0\n  dist xM yM = infdist xM (d ` {A..B})\n\ngoal (1 subgoal):\n 1. yM = xM", "by auto"], ["proof (state)\nthis:\n  yM = xM\n\ngoal (2 subgoals):\n 1. dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  yM = xM", "have \"z = xM\""], ["proof (prove)\nusing this:\n  yM = xM\n\ngoal (1 subgoal):\n 1. z = xM", "using \\<open>z \\<in> {xM--yM}\\<close> geodesic_segment_between_x_x(3)"], ["proof (prove)\nusing this:\n  yM = xM\n  z \\<in> {xM--yM}\n  geodesic_segment_between ?G ?x ?x = (?G = {?x})\n\ngoal (1 subgoal):\n 1. z = xM", "by (metis empty_iff insert_iff some_geodesic_is_geodesic_segment(1))"], ["proof (state)\nthis:\n  z = xM\n\ngoal (2 subgoals):\n 1. dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  z = xM", "have \"z \\<in> d`{A..B}\""], ["proof (prove)\nusing this:\n  z = xM\n\ngoal (1 subgoal):\n 1. z \\<in> d ` {A..B}", "using \\<open>yM = xM\\<close> yM(1)"], ["proof (prove)\nusing this:\n  z = xM\n  yM = xM\n  yM \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. z \\<in> d ` {A..B}", "by blast"], ["proof (state)\nthis:\n  z \\<in> d ` {A..B}\n\ngoal (2 subgoals):\n 1. dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z\n 2. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  z \\<in> d ` {A..B}", "show \"dist x z \\<ge> D\""], ["proof (prove)\nusing this:\n  z \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "unfolding D_def"], ["proof (prove)\nusing this:\n  z \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. infdist x (d ` {A..B}) \\<le> dist x z", "by (simp add: infdist_le)"], ["proof (state)\nthis:\n  D \\<le> dist x z\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "case False"], ["proof (state)\nthis:\n  \\<not> dist (c A) (c B) < tx + 2 * D\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  \\<not> dist (c A) (c B) < tx + 2 * D", "have *: \"tM = tx + 2 * D\""], ["proof (prove)\nusing this:\n  \\<not> dist (c A) (c B) < tx + 2 * D\n\ngoal (1 subgoal):\n 1. tM = tx + 2 * D", "unfolding tM_def"], ["proof (prove)\nusing this:\n  \\<not> dist (c A) (c B) < tx + 2 * D\n\ngoal (1 subgoal):\n 1. min (tx + 2 * D) (dist (c A) (c B)) = tx + 2 * D", "by auto"], ["proof (state)\nthis:\n  tM = tx + 2 * D\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "have \"dist xM x = abs((tx + 2 * D) - tx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xM x = \\<bar>tx + 2 * D - tx\\<bar>", "unfolding xM_def x_param *"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (geodesic_segment_param {c A--c B} (c A) (tx + 2 * D))\n     (geodesic_segment_param {c A--c B} (c A) tx) =\n    \\<bar>tx + 2 * D - tx\\<bar>", "apply (rule geodesic_segment_param[of _ _ \"c B\"], auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<le> tx + 2 * D\n 2. tx + 2 * D \\<le> dist (c A) (c B)\n 3. 0 \\<le> tx\n 4. tx \\<le> dist (c A) (c B)", "using False \\<open>tx \\<in> {0..dist (c A) (c B)}\\<close> \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> dist (c A) (c B) < tx + 2 * D\n  tx \\<in> {0..dist (c A) (c B)}\n  0 \\<le> D\n\ngoal (4 subgoals):\n 1. 0 \\<le> tx + 2 * D\n 2. tx + 2 * D \\<le> dist (c A) (c B)\n 3. 0 \\<le> tx\n 4. tx \\<le> dist (c A) (c B)", "by auto"], ["proof (state)\nthis:\n  dist xM x = \\<bar>tx + 2 * D - tx\\<bar>\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  dist xM x = \\<bar>tx + 2 * D - tx\\<bar>", "have \"2 * D = dist xM x\""], ["proof (prove)\nusing this:\n  dist xM x = \\<bar>tx + 2 * D - tx\\<bar>\n\ngoal (1 subgoal):\n 1. 2 * D = dist xM x", "using \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  dist xM x = \\<bar>tx + 2 * D - tx\\<bar>\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. 2 * D = dist xM x", "by auto"], ["proof (state)\nthis:\n  2 * D = dist xM x\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "also"], ["proof (state)\nthis:\n  2 * D = dist xM x\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "have \"... \\<le> dist xM z + dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xM x \\<le> dist xM z + dist x z", "using metric_space_class.dist_triangle2"], ["proof (prove)\nusing this:\n  dist ?x ?y \\<le> dist ?x ?z + dist ?y ?z\n\ngoal (1 subgoal):\n 1. dist xM x \\<le> dist xM z + dist x z", "by auto"], ["proof (state)\nthis:\n  dist xM x \\<le> dist xM z + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "also"], ["proof (state)\nthis:\n  dist xM x \\<le> dist xM z + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "have \"... \\<le> dist xM yM + dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xM z + dist x z \\<le> dist xM yM + dist x z", "using \\<open>z \\<in> {xM--yM}\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> {xM--yM}\n\ngoal (1 subgoal):\n 1. dist xM z + dist x z \\<le> dist xM yM + dist x z", "by (auto, meson geodesic_segment_dist_le local.some_geodesic_is_geodesic_segment(1) some_geodesic_endpoints(1))"], ["proof (state)\nthis:\n  dist xM z + dist x z \\<le> dist xM yM + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "also"], ["proof (state)\nthis:\n  dist xM z + dist x z \\<le> dist xM yM + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "have \"... \\<le> D + dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist xM yM + dist x z \\<le> D + dist x z", "using \\<open>dist xM yM \\<le> D\\<close>"], ["proof (prove)\nusing this:\n  dist xM yM \\<le> D\n\ngoal (1 subgoal):\n 1. dist xM yM + dist x z \\<le> D + dist x z", "by simp"], ["proof (state)\nthis:\n  dist xM yM + dist x z \\<le> D + dist x z\n\ngoal (1 subgoal):\n 1. \\<not> dist (c A) (c B) < tx + 2 * D \\<Longrightarrow> D \\<le> dist x z", "finally"], ["proof (chain)\npicking this:\n  2 * D \\<le> D + dist x z", "show \"dist x z \\<ge> D\""], ["proof (prove)\nusing this:\n  2 * D \\<le> D + dist x z\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "by auto"], ["proof (state)\nthis:\n  D \\<le> dist x z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> {xM--yM} \\<Longrightarrow> D \\<le> dist x ?z\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "define excursion:: \"real\\<Rightarrow>'a\" where \"excursion = (\\<lambda>t.\n        if t \\<in> {0..dist xm ym} then (geodesic_segment_param {xm--ym} xm t)\n        else if t \\<in> {dist xm ym..dist xm ym + abs(uM - um)} then d (um + sgn(uM-um) * (t - dist xm ym))\n        else geodesic_segment_param {yM--xM} yM (t - dist xm ym - abs (uM -um)))\""], ["proof (state)\nthis:\n  excursion =\n  (\\<lambda>t.\n      if t \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm t\n      else if t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n           then d (um + sgn (uM - um) * (t - dist xm ym))\n           else geodesic_segment_param {yM--xM} yM\n                 (t - dist xm ym - \\<bar>uM - um\\<bar>))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "define L where \"L = dist xm ym + abs(uM - um) + dist yM xM\""], ["proof (state)\nthis:\n  L = dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have E1: \"excursion t = geodesic_segment_param {xm--ym} xm t\" if \"t \\<in> {0..dist xm ym}\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. excursion t = geodesic_segment_param {xm--ym} xm t", "unfolding excursion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if t \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm t\n     else if t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (t - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (t - dist xm ym - \\<bar>uM - um\\<bar>)) =\n    geodesic_segment_param {xm--ym} xm t", "using that"], ["proof (prove)\nusing this:\n  t \\<in> {0..dist xm ym}\n\ngoal (1 subgoal):\n 1. (if t \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm t\n     else if t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (t - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (t - dist xm ym - \\<bar>uM - um\\<bar>)) =\n    geodesic_segment_param {xm--ym} xm t", "by auto"], ["proof (state)\nthis:\n  ?t \\<in> {0..dist xm ym} \\<Longrightarrow>\n  excursion ?t = geodesic_segment_param {xm--ym} xm ?t\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have E2: \"excursion t = d (um + sgn(uM-um) * (t - dist xm ym))\" if \"t \\<in> {dist xm ym..dist xm ym + abs(uM - um)}\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. excursion t = d (um + sgn (uM - um) * (t - dist xm ym))", "unfolding excursion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if t \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm t\n     else if t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (t - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (t - dist xm ym - \\<bar>uM - um\\<bar>)) =\n    d (um + sgn (uM - um) * (t - dist xm ym))", "using that"], ["proof (prove)\nusing this:\n  t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n\ngoal (1 subgoal):\n 1. (if t \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm t\n     else if t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (t - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (t - dist xm ym - \\<bar>uM - um\\<bar>)) =\n    d (um + sgn (uM - um) * (t - dist xm ym))", "by (auto simp add: \\<open>ym = d um\\<close>)"], ["proof (state)\nthis:\n  ?t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n  excursion ?t = d (um + sgn (uM - um) * (?t - dist xm ym))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have E3: \"excursion t = geodesic_segment_param {yM--xM} yM (t - dist xm ym - abs (uM -um))\"\n        if \"t \\<in> {dist xm ym + \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. excursion t =\n    geodesic_segment_param {yM--xM} yM\n     (t - dist xm ym - \\<bar>uM - um\\<bar>)", "unfolding excursion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if t \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm t\n     else if t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (t - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (t - dist xm ym - \\<bar>uM - um\\<bar>)) =\n    geodesic_segment_param {yM--xM} yM\n     (t - dist xm ym - \\<bar>uM - um\\<bar>)", "using that \\<open>yM = d uM\\<close> \\<open>ym = d um\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> {dist xm ym +\n           \\<bar>uM -\n                 um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n  yM = d uM\n  ym = d um\n\ngoal (1 subgoal):\n 1. (if t \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm t\n     else if t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (t - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (t - dist xm ym - \\<bar>uM - um\\<bar>)) =\n    geodesic_segment_param {yM--xM} yM\n     (t - dist xm ym - \\<bar>uM - um\\<bar>)", "by (auto simp add: sgn_mult_abs)"], ["proof (state)\nthis:\n  ?t \\<in> {dist xm ym +\n            \\<bar>uM -\n                  um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> +\n                            dist yM xM} \\<Longrightarrow>\n  excursion ?t =\n  geodesic_segment_param {yM--xM} yM (?t - dist xm ym - \\<bar>uM - um\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have E0: \"excursion 0 = xm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. excursion 0 = xm", "unfolding excursion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm 0\n     else if 0 \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (0 - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (0 - dist xm ym - \\<bar>uM - um\\<bar>)) =\n    xm", "by auto"], ["proof (state)\nthis:\n  excursion 0 = xm\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have EL: \"excursion L = xM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. excursion L = xM", "unfolding excursion_def L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM \\<in> {0..dist xm ym}\n     then geodesic_segment_param {xm--ym} xm\n           (dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM)\n     else if dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM\n             \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um +\n                  sgn (uM - um) *\n                  (dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM -\n                   dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM -\n                 dist xm ym -\n                 \\<bar>uM - um\\<bar>)) =\n    xM", "apply (auto simp add: uM(2) um(2) sgn_mult_abs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>d uM \\<noteq> xM;\n     \\<bar>uM - um\\<bar> + dist (d uM) xM \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> geodesic_segment_param {xm--d um} xm\n                       (dist xm (d um) + \\<bar>uM - um\\<bar> +\n                        dist (d uM) xM) =\n                      xM", "by (metis (mono_tags, hide_lams) add.left_neutral add_increasing2 add_le_same_cancel1 dist_real_def\n              Gromov_product_e_x_x Gromov_product_nonneg metric_space_class.dist_le_zero_iff)"], ["proof (state)\nthis:\n  excursion L = xM\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have [simp]: \"L \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> L", "unfolding L_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM", "by auto"], ["proof (state)\nthis:\n  0 \\<le> L\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"L > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < L", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < L \\<Longrightarrow> False", "assume \"\\<not>(L > 0)\""], ["proof (state)\nthis:\n  \\<not> 0 < L\n\ngoal (1 subgoal):\n 1. \\<not> 0 < L \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < L", "have \"L = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < L\n\ngoal (1 subgoal):\n 1. L = 0", "using \\<open>L \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<not> 0 < L\n  0 \\<le> L\n\ngoal (1 subgoal):\n 1. L = 0", "by simp"], ["proof (state)\nthis:\n  L = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < L \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  L = 0", "have \"xm = xM\""], ["proof (prove)\nusing this:\n  L = 0\n\ngoal (1 subgoal):\n 1. xm = xM", "using E0 EL"], ["proof (prove)\nusing this:\n  L = 0\n  excursion 0 = xm\n  excursion L = xM\n\ngoal (1 subgoal):\n 1. xm = xM", "by auto"], ["proof (state)\nthis:\n  xm = xM\n\ngoal (1 subgoal):\n 1. \\<not> 0 < L \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  xm = xM", "have \"tM = tm\""], ["proof (prove)\nusing this:\n  xm = xM\n\ngoal (1 subgoal):\n 1. tM = tm", "unfolding xm_def xM_def"], ["proof (prove)\nusing this:\n  geodesic_segment_param {c A--c B} (c A) tm =\n  geodesic_segment_param {c A--c B} (c A) tM\n\ngoal (1 subgoal):\n 1. tM = tm", "using \\<open>tM \\<in> {0..dist (c A) (c B)}\\<close> \\<open>tm \\<in> {0..dist (c A) (c B)}\\<close> local.geodesic_segment_param_in_geodesic_spaces(6)"], ["proof (prove)\nusing this:\n  geodesic_segment_param {c A--c B} (c A) tm =\n  geodesic_segment_param {c A--c B} (c A) tM\n  tM \\<in> {0..dist (c A) (c B)}\n  tm \\<in> {0..dist (c A) (c B)}\n  ?t \\<in> {0..dist ?x ?y} \\<Longrightarrow>\n  dist ?x (geodesic_segment_param {?x--?y} ?x ?t) = ?t\n\ngoal (1 subgoal):\n 1. tM = tm", "by fastforce"], ["proof (state)\nthis:\n  tM = tm\n\ngoal (1 subgoal):\n 1. \\<not> 0 < L \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  tM = tm\n\ngoal (1 subgoal):\n 1. \\<not> 0 < L \\<Longrightarrow> False", "have \"... < tx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm < tx", "unfolding tm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. max (tx - 2 * D) 0 < tx", "using \\<open>tx > 0\\<close> \\<open>D \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 < tx\n  1 \\<le> D\n\ngoal (1 subgoal):\n 1. max (tx - 2 * D) 0 < tx", "by auto"], ["proof (state)\nthis:\n  tm < tx\n\ngoal (1 subgoal):\n 1. \\<not> 0 < L \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  tm < tx\n\ngoal (1 subgoal):\n 1. \\<not> 0 < L \\<Longrightarrow> False", "have \"... \\<le> tM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tx \\<le> tM", "unfolding tM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. tx \\<le> min (tx + 2 * D) (dist (c A) (c B))", "using \\<open>D \\<ge> 0\\<close> \\<open>tx \\<in> {0..dist (c A) (c B)}\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> D\n  tx \\<in> {0..dist (c A) (c B)}\n\ngoal (1 subgoal):\n 1. tx \\<le> min (tx + 2 * D) (dist (c A) (c B))", "by auto"], ["proof (state)\nthis:\n  tx \\<le> tM\n\ngoal (1 subgoal):\n 1. \\<not> 0 < L \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  tM < tM", "show False"], ["proof (prove)\nusing this:\n  tM < tM\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < L\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"(1/lambda) * dist um uM - (4 * C) \\<le> dist (d um) (d uM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / lambda * dist um uM - 4 * C \\<le> dist (d um) (d uM)", "by (rule quasi_isometry_onD(2)[OF \\<open>lambda (4 * C)-quasi_isometry_on {A..B} d\\<close> \\<open>um \\<in> {A..B}\\<close> \\<open>uM \\<in> {A..B}\\<close>])"], ["proof (state)\nthis:\n  1 / lambda * dist um uM - 4 * C \\<le> dist (d um) (d uM)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  1 / lambda * dist um uM - 4 * C \\<le> dist (d um) (d uM)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> dist ym xm + dist xm x + dist x xM + dist xM yM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (d um) (d uM) \\<le> dist ym xm + dist xm x + dist x xM + dist xM yM", "unfolding um(2)[symmetric] uM(2)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist ym yM \\<le> dist ym xm + dist xm x + dist x xM + dist xM yM", "by (rule dist_triangle5)"], ["proof (state)\nthis:\n  dist (d um) (d uM) \\<le> dist ym xm + dist xm x + dist x xM + dist xM yM\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  dist (d um) (d uM) \\<le> dist ym xm + dist xm x + dist x xM + dist xM yM\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> D + (2*D) + (2*D) + D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist ym xm + dist xm x + dist x xM + dist xM yM\n    \\<le> D + 2 * D + 2 * D + D", "using \\<open>dist xm ym \\<le> D\\<close> \\<open>dist xm x \\<le> 2*D\\<close> \\<open>dist xM x \\<le> 2*D\\<close> \\<open>dist xM yM \\<le> D\\<close>"], ["proof (prove)\nusing this:\n  dist xm ym \\<le> D\n  dist xm x \\<le> 2 * D\n  dist xM x \\<le> 2 * D\n  dist xM yM \\<le> D\n\ngoal (1 subgoal):\n 1. dist ym xm + dist xm x + dist x xM + dist xM yM\n    \\<le> D + 2 * D + 2 * D + D", "by (auto simp add: metric_space_class.dist_commute intro: add_mono)"], ["proof (state)\nthis:\n  dist ym xm + dist xm x + dist x xM + dist xM yM\n  \\<le> D + 2 * D + 2 * D + D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  1 / lambda * dist um uM - 4 * C \\<le> D + 2 * D + 2 * D + D", "have \"(1/lambda) * dist um uM \\<le> 6*D + 4*C\""], ["proof (prove)\nusing this:\n  1 / lambda * dist um uM - 4 * C \\<le> D + 2 * D + 2 * D + D\n\ngoal (1 subgoal):\n 1. 1 / lambda * dist um uM \\<le> 6 * D + 4 * C", "by auto"], ["proof (state)\nthis:\n  1 / lambda * dist um uM \\<le> 6 * D + 4 * C\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  1 / lambda * dist um uM \\<le> 6 * D + 4 * C", "have \"dist um uM \\<le> 6*D*lambda + 4*C*lambda\""], ["proof (prove)\nusing this:\n  1 / lambda * dist um uM \\<le> 6 * D + 4 * C\n\ngoal (1 subgoal):\n 1. dist um uM \\<le> 6 * D * lambda + 4 * C * lambda", "using C"], ["proof (prove)\nusing this:\n  1 / lambda * dist um uM \\<le> 6 * D + 4 * C\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. dist um uM \\<le> 6 * D * lambda + 4 * C * lambda", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  dist um uM \\<le> 6 * D * lambda + 4 * C * lambda\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  dist um uM \\<le> 6 * D * lambda + 4 * C * lambda", "have \"L \\<le> D + (6*D*lambda + 4*C*lambda) + D\""], ["proof (prove)\nusing this:\n  dist um uM \\<le> 6 * D * lambda + 4 * C * lambda\n\ngoal (1 subgoal):\n 1. L \\<le> D + (6 * D * lambda + 4 * C * lambda) + D", "unfolding L_def dist_real_def"], ["proof (prove)\nusing this:\n  \\<bar>um - uM\\<bar> \\<le> 6 * D * lambda + 4 * C * lambda\n\ngoal (1 subgoal):\n 1. dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM\n    \\<le> D + (6 * D * lambda + 4 * C * lambda) + D", "using \\<open>dist xm ym \\<le> D\\<close> \\<open>dist xM yM \\<le> D\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>um - uM\\<bar> \\<le> 6 * D * lambda + 4 * C * lambda\n  dist xm ym \\<le> D\n  dist xM yM \\<le> D\n\ngoal (1 subgoal):\n 1. dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM\n    \\<le> D + (6 * D * lambda + 4 * C * lambda) + D", "by (auto simp add: metric_space_class.dist_commute intro: add_mono)"], ["proof (state)\nthis:\n  L \\<le> D + (6 * D * lambda + 4 * C * lambda) + D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  L \\<le> D + (6 * D * lambda + 4 * C * lambda) + D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> 8 * D * lambda + 4*C*lambda\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D + (6 * D * lambda + 4 * C * lambda) + D\n    \\<le> 8 * D * lambda + 4 * C * lambda", "using C \\<open>D \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. D + (6 * D * lambda + 4 * C * lambda) + D\n    \\<le> 8 * D * lambda + 4 * C * lambda", "by (auto intro: mono_intros)"], ["proof (state)\nthis:\n  D + (6 * D * lambda + 4 * C * lambda) + D\n  \\<le> 8 * D * lambda + 4 * C * lambda\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  L \\<le> 8 * D * lambda + 4 * C * lambda", "have L_bound: \"L \\<le> lambda * (8 * D + 4 * C)\""], ["proof (prove)\nusing this:\n  L \\<le> 8 * D * lambda + 4 * C * lambda\n\ngoal (1 subgoal):\n 1. L \\<le> lambda * (8 * D + 4 * C)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  L \\<le> lambda * (8 * D + 4 * C)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"1 * (1 * 1 + 0) \\<le> lambda * (8 * D + 4 * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * (1 * 1 + 0) \\<le> lambda * (8 * D + 4 * C)", "using C \\<open>D \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  1 \\<le> D\n\ngoal (1 subgoal):\n 1. 1 * (1 * 1 + 0) \\<le> lambda * (8 * D + 4 * C)", "by (intro mono_intros, auto)"], ["proof (state)\nthis:\n  1 * (1 * 1 + 0) \\<le> lambda * (8 * D + 4 * C)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "consider \"um < uM\" | \"um = uM\" | \"um > uM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>um < uM \\<Longrightarrow> thesis;\n     um = uM \\<Longrightarrow> thesis;\n     uM < um \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>um < uM \\<Longrightarrow> ?thesis;\n   um = uM \\<Longrightarrow> ?thesis;\n   uM < um \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>um < uM \\<Longrightarrow> ?thesis;\n   um = uM \\<Longrightarrow> ?thesis;\n   uM < um \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "have \"((\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) ` {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}) \\<subseteq> {min um uM..max um uM}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>um < uM \\<Longrightarrow> ?thesis;\n   um = uM \\<Longrightarrow> ?thesis;\n   uM < um \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) `\n    {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n    \\<subseteq> {min um uM..max um uM}", "by (cases, auto)"], ["proof (state)\nthis:\n  (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) `\n  {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n  \\<subseteq> {min um uM..max um uM}\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) `\n  {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n  \\<subseteq> {min um uM..max um uM}\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<subseteq> {A..B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {min um uM..max um uM} \\<subseteq> {A..B}", "using \\<open>um \\<in> {A..B}\\<close> \\<open>uM \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  um \\<in> {A..B}\n  uM \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. {min um uM..max um uM} \\<subseteq> {A..B}", "by auto"], ["proof (state)\nthis:\n  {min um uM..max um uM} \\<subseteq> {A..B}\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) `\n  {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n  \\<subseteq> {A..B}", "have middle: \"((\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) ` {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}) \\<subseteq> {A..B}\""], ["proof (prove)\nusing this:\n  (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) `\n  {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n  \\<subseteq> {A..B}\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) `\n    {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n    \\<subseteq> {A..B}", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) `\n  {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n  \\<subseteq> {A..B}\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"(2 * lambda)-lipschitz_on {0..L} excursion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {0..L} excursion", "proof (unfold L_def, rule lipschitz_on_closed_Union[of \"{{0..dist xm ym}, {dist xm ym..dist xm ym + abs(uM - um)}, {dist xm ym + abs(uM - um)..dist xm ym + abs(uM - um) + dist yM xM}}\" _ \"\\<lambda> i. i\"], auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. (2 * lambda)-lipschitz_on {0..dist xm ym} excursion\n 2. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion\n 3. (2 * lambda)-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     excursion\n 4. 0 \\<le> lambda", "show \"lambda \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> lambda", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 \\<le> lambda", "by auto"], ["proof (state)\nthis:\n  0 \\<le> lambda\n\ngoal (3 subgoals):\n 1. (2 * lambda)-lipschitz_on {0..dist xm ym} excursion\n 2. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion\n 3. (2 * lambda)-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     excursion", "have *: \"1-lipschitz_on {0..dist xm ym} (geodesic_segment_param {xm--ym} xm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1-lipschitz_on {0..dist xm ym} (geodesic_segment_param {xm--ym} xm)", "by (rule isometry_on_lipschitz, simp)"], ["proof (state)\nthis:\n  1-lipschitz_on {0..dist xm ym} (geodesic_segment_param {xm--ym} xm)\n\ngoal (3 subgoals):\n 1. (2 * lambda)-lipschitz_on {0..dist xm ym} excursion\n 2. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion\n 3. (2 * lambda)-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     excursion", "have **: \"1-lipschitz_on {0..dist xm ym} excursion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1-lipschitz_on {0..dist xm ym} excursion", "using lipschitz_on_transform[OF * E1]"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      x \\<in> {0..dist xm ym} \\<Longrightarrow>\n      x \\<in> {0..dist xm ym}) \\<Longrightarrow>\n  1-lipschitz_on {0..dist xm ym} excursion\n\ngoal (1 subgoal):\n 1. 1-lipschitz_on {0..dist xm ym} excursion", "by simp"], ["proof (state)\nthis:\n  1-lipschitz_on {0..dist xm ym} excursion\n\ngoal (3 subgoals):\n 1. (2 * lambda)-lipschitz_on {0..dist xm ym} excursion\n 2. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion\n 3. (2 * lambda)-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     excursion", "show \"(2 * lambda)-lipschitz_on {0..dist xm ym} excursion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {0..dist xm ym} excursion", "apply (rule lipschitz_on_mono[OF **])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {0..dist xm ym} \\<subseteq> {0..dist xm ym}\n 2. 1 \\<le> 2 * lambda", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (2 subgoals):\n 1. {0..dist xm ym} \\<subseteq> {0..dist xm ym}\n 2. 1 \\<le> 2 * lambda", "by auto"], ["proof (state)\nthis:\n  (2 * lambda)-lipschitz_on {0..dist xm ym} excursion\n\ngoal (2 subgoals):\n 1. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion\n 2. (2 * lambda)-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     excursion", "have *: \"(1*(1+0))-lipschitz_on {dist xm ym + \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n                ((geodesic_segment_param {yM--xM} yM) o (\\<lambda>t. t - (dist xm ym + abs (uM -um))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 * (1 + 0))-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     (geodesic_segment_param {yM--xM} yM \\<circ>\n      (\\<lambda>t. t - (dist xm ym + \\<bar>uM - um\\<bar>)))", "by (intro lipschitz_intros, rule isometry_on_lipschitz, auto)"], ["proof (state)\nthis:\n  (1 * (1 + 0))-lipschitz_on\n   {dist xm ym +\n    \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n   (geodesic_segment_param {yM--xM} yM \\<circ>\n    (\\<lambda>t. t - (dist xm ym + \\<bar>uM - um\\<bar>)))\n\ngoal (2 subgoals):\n 1. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion\n 2. (2 * lambda)-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     excursion", "have **: \"(1*(1+0))-lipschitz_on {dist xm ym + \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM} excursion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 * (1 + 0))-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     excursion", "apply (rule lipschitz_on_transform[OF *])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dist xm ym +\n                \\<bar>uM -\n                      um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> +\n                                dist yM xM} \\<Longrightarrow>\n       excursion x =\n       (geodesic_segment_param {yM--xM} yM \\<circ>\n        (\\<lambda>t. t - (dist xm ym + \\<bar>uM - um\\<bar>)))\n        x", "using E3"], ["proof (prove)\nusing this:\n  ?t \\<in> {dist xm ym +\n            \\<bar>uM -\n                  um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> +\n                            dist yM xM} \\<Longrightarrow>\n  excursion ?t =\n  geodesic_segment_param {yM--xM} yM (?t - dist xm ym - \\<bar>uM - um\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dist xm ym +\n                \\<bar>uM -\n                      um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> +\n                                dist yM xM} \\<Longrightarrow>\n       excursion x =\n       (geodesic_segment_param {yM--xM} yM \\<circ>\n        (\\<lambda>t. t - (dist xm ym + \\<bar>uM - um\\<bar>)))\n        x", "unfolding comp_def"], ["proof (prove)\nusing this:\n  ?t \\<in> {dist xm ym +\n            \\<bar>uM -\n                  um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> +\n                            dist yM xM} \\<Longrightarrow>\n  excursion ?t =\n  geodesic_segment_param {yM--xM} yM (?t - dist xm ym - \\<bar>uM - um\\<bar>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dist xm ym +\n                \\<bar>uM -\n                      um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> +\n                                dist yM xM} \\<Longrightarrow>\n       excursion x =\n       geodesic_segment_param {yM--xM} yM\n        (x - (dist xm ym + \\<bar>uM - um\\<bar>))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  (1 * (1 + 0))-lipschitz_on\n   {dist xm ym +\n    \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n   excursion\n\ngoal (2 subgoals):\n 1. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion\n 2. (2 * lambda)-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     excursion", "show \"(2 * lambda)-lipschitz_on {dist xm ym + \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM} excursion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on\n     {dist xm ym +\n      \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n     excursion", "apply (rule lipschitz_on_mono[OF **])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {dist xm ym +\n     \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n    \\<subseteq> {dist xm ym +\n                 \\<bar>uM -\n                       um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> +\n                                 dist yM xM}\n 2. 1 * (1 + 0) \\<le> 2 * lambda", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (2 subgoals):\n 1. {dist xm ym +\n     \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n    \\<subseteq> {dist xm ym +\n                 \\<bar>uM -\n                       um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> +\n                                 dist yM xM}\n 2. 1 * (1 + 0) \\<le> 2 * lambda", "by auto"], ["proof (state)\nthis:\n  (2 * lambda)-lipschitz_on\n   {dist xm ym +\n    \\<bar>uM - um\\<bar>..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n   excursion\n\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion", "have **: \"((2 * lambda) * (0 + abs(sgn (uM - um)) * (1 + 0)))-lipschitz_on {dist xm ym..dist xm ym + abs(uM - um)} (d o (\\<lambda>t. um + sgn(uM-um) * (t - dist xm ym)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * lambda * (0 + \\<bar>sgn (uM - um)\\<bar> * (1 + 0)))-lipschitz_on\n     {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     (d \\<circ> (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)))", "apply (intro lipschitz_intros, rule lipschitz_on_subset[OF _ middle])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {A..B} d", "using \\<open>(2 * lambda)-lipschitz_on {A..B} d\\<close>"], ["proof (prove)\nusing this:\n  (2 * lambda)-lipschitz_on {A..B} d\n\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {A..B} d", "by simp"], ["proof (state)\nthis:\n  (2 * lambda * (0 + \\<bar>sgn (uM - um)\\<bar> * (1 + 0)))-lipschitz_on\n   {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n   (d \\<circ> (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)))\n\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion", "have ***: \"(2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + abs(uM - um)} (d o (\\<lambda>t. um + sgn(uM-um) * (t - dist xm ym)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     (d \\<circ> (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)))", "apply (rule lipschitz_on_mono[OF **])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n    \\<subseteq> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n 2. 2 * lambda * (0 + \\<bar>sgn (uM - um)\\<bar> * (1 + 0)) \\<le> 2 * lambda", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (2 subgoals):\n 1. {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n    \\<subseteq> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n 2. 2 * lambda * (0 + \\<bar>sgn (uM - um)\\<bar> * (1 + 0)) \\<le> 2 * lambda", "by auto"], ["proof (state)\nthis:\n  (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n   (d \\<circ> (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)))\n\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion", "show \"(2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + abs(uM - um)} excursion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n     excursion", "apply (rule lipschitz_on_transform[OF ***])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dist xm\n                 ym..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n       excursion x =\n       (d \\<circ> (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym))) x", "using E2"], ["proof (prove)\nusing this:\n  ?t \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n  excursion ?t = d (um + sgn (uM - um) * (?t - dist xm ym))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {dist xm\n                 ym..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n       excursion x =\n       (d \\<circ> (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym))) x", "by auto"], ["proof (state)\nthis:\n  (2 * lambda)-lipschitz_on {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n   excursion\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (2 * lambda)-lipschitz_on {0..L} excursion\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have *: \"dist x z \\<ge> D\" if z: \"z \\<in> excursion`{0..L}\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "obtain tz where tz: \"z = excursion tz\" \"tz \\<in> {0..dist xm ym + abs(uM - um) + dist yM xM}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tz.\n        \\<lbrakk>z = excursion tz;\n         tz \\<in> {0..dist xm ym + \\<bar>uM - um\\<bar> +\n                      dist yM xM}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using z L_def"], ["proof (prove)\nusing this:\n  z \\<in> excursion ` {0..L}\n  L = dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM\n\ngoal (1 subgoal):\n 1. (\\<And>tz.\n        \\<lbrakk>z = excursion tz;\n         tz \\<in> {0..dist xm ym + \\<bar>uM - um\\<bar> +\n                      dist yM xM}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z = excursion tz\n  tz \\<in> {0..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "consider \"tz \\<in> {0..dist xm ym}\" | \"tz \\<in> {dist xm ym<..dist xm ym + abs(uM - um)}\" | \"tz \\<in> {dist xm ym + abs(uM - um)<..dist xm ym + abs(uM - um) + dist yM xM}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tz \\<in> {0..dist xm ym} \\<Longrightarrow> thesis;\n     tz \\<in> {dist xm\n                ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n     thesis;\n     tz \\<in> {dist xm ym +\n               \\<bar>uM -\n                     um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                                dist yM xM} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using tz"], ["proof (prove)\nusing this:\n  z = excursion tz\n  tz \\<in> {0..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tz \\<in> {0..dist xm ym} \\<Longrightarrow> thesis;\n     tz \\<in> {dist xm\n                ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n     thesis;\n     tz \\<in> {dist xm ym +\n               \\<bar>uM -\n                     um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                                dist yM xM} \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by force"], ["proof (state)\nthis:\n  \\<lbrakk>tz \\<in> {0..dist xm ym} \\<Longrightarrow> ?thesis;\n   tz \\<in> {dist xm\n              ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n   ?thesis;\n   tz \\<in> {dist xm ym +\n             \\<bar>uM -\n                   um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                              dist yM xM} \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tz \\<in> {0..dist xm ym} \\<Longrightarrow> ?thesis;\n   tz \\<in> {dist xm\n              ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n   ?thesis;\n   tz \\<in> {dist xm ym +\n             \\<bar>uM -\n                   um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                              dist yM xM} \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>tz \\<in> {0..dist xm ym} \\<Longrightarrow> ?thesis;\n   tz \\<in> {dist xm\n              ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n   ?thesis;\n   tz \\<in> {dist xm ym +\n             \\<bar>uM -\n                   um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                              dist yM xM} \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. tz \\<in> {0..dist xm ym} \\<Longrightarrow> D \\<le> dist x z\n 2. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z\n 3. tz \\<in> {dist xm ym +\n              \\<bar>uM -\n                    um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                               dist yM xM} \\<Longrightarrow>\n    D \\<le> dist x z", "case 1"], ["proof (state)\nthis:\n  tz \\<in> {0..dist xm ym}\n\ngoal (3 subgoals):\n 1. tz \\<in> {0..dist xm ym} \\<Longrightarrow> D \\<le> dist x z\n 2. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z\n 3. tz \\<in> {dist xm ym +\n              \\<bar>uM -\n                    um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                               dist yM xM} \\<Longrightarrow>\n    D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  tz \\<in> {0..dist xm ym}", "have \"z \\<in> {xm--ym}\""], ["proof (prove)\nusing this:\n  tz \\<in> {0..dist xm ym}\n\ngoal (1 subgoal):\n 1. z \\<in> {xm--ym}", "unfolding tz(1) excursion_def"], ["proof (prove)\nusing this:\n  tz \\<in> {0..dist xm ym}\n\ngoal (1 subgoal):\n 1. (if tz \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm tz\n     else if tz \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (tz - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (tz - dist xm ym - \\<bar>uM - um\\<bar>))\n    \\<in> {xm--ym}", "by auto"], ["proof (state)\nthis:\n  z \\<in> {xm--ym}\n\ngoal (3 subgoals):\n 1. tz \\<in> {0..dist xm ym} \\<Longrightarrow> D \\<le> dist x z\n 2. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z\n 3. tz \\<in> {dist xm ym +\n              \\<bar>uM -\n                    um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                               dist yM xM} \\<Longrightarrow>\n    D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  z \\<in> {xm--ym}", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> {xm--ym}\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "using D1"], ["proof (prove)\nusing this:\n  z \\<in> {xm--ym}\n  ?z \\<in> {xm--ym} \\<Longrightarrow> D \\<le> dist x ?z\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "by auto"], ["proof (state)\nthis:\n  D \\<le> dist x z\n\ngoal (2 subgoals):\n 1. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z\n 2. tz \\<in> {dist xm ym +\n              \\<bar>uM -\n                    um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                               dist yM xM} \\<Longrightarrow>\n    D \\<le> dist x z", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z\n 2. tz \\<in> {dist xm ym +\n              \\<bar>uM -\n                    um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                               dist yM xM} \\<Longrightarrow>\n    D \\<le> dist x z", "case 3"], ["proof (state)\nthis:\n  tz \\<in> {dist xm ym +\n            \\<bar>uM -\n                  um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n\ngoal (2 subgoals):\n 1. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z\n 2. tz \\<in> {dist xm ym +\n              \\<bar>uM -\n                    um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                               dist yM xM} \\<Longrightarrow>\n    D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  tz \\<in> {dist xm ym +\n            \\<bar>uM -\n                  um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}", "have \"z \\<in> {yM--xM}\""], ["proof (prove)\nusing this:\n  tz \\<in> {dist xm ym +\n            \\<bar>uM -\n                  um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n\ngoal (1 subgoal):\n 1. z \\<in> {yM--xM}", "unfolding tz(1) excursion_def"], ["proof (prove)\nusing this:\n  tz \\<in> {dist xm ym +\n            \\<bar>uM -\n                  um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n\ngoal (1 subgoal):\n 1. (if tz \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm tz\n     else if tz \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (tz - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (tz - dist xm ym - \\<bar>uM - um\\<bar>))\n    \\<in> {yM--xM}", "using tz(2)"], ["proof (prove)\nusing this:\n  tz \\<in> {dist xm ym +\n            \\<bar>uM -\n                  um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n  tz \\<in> {0..dist xm ym + \\<bar>uM - um\\<bar> + dist yM xM}\n\ngoal (1 subgoal):\n 1. (if tz \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm tz\n     else if tz \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (tz - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (tz - dist xm ym - \\<bar>uM - um\\<bar>))\n    \\<in> {yM--xM}", "by auto"], ["proof (state)\nthis:\n  z \\<in> {yM--xM}\n\ngoal (2 subgoals):\n 1. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z\n 2. tz \\<in> {dist xm ym +\n              \\<bar>uM -\n                    um\\<bar><..dist xm ym + \\<bar>uM - um\\<bar> +\n                               dist yM xM} \\<Longrightarrow>\n    D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  z \\<in> {yM--xM}", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> {yM--xM}\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "using D3"], ["proof (prove)\nusing this:\n  z \\<in> {yM--xM}\n  ?z \\<in> {xM--yM} \\<Longrightarrow> D \\<le> dist x ?z\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "by (simp add: some_geodesic_commute)"], ["proof (state)\nthis:\n  D \\<le> dist x z\n\ngoal (1 subgoal):\n 1. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z", "case 2"], ["proof (state)\nthis:\n  tz \\<in> {dist xm ym<..dist xm ym + \\<bar>uM - um\\<bar>}\n\ngoal (1 subgoal):\n 1. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  tz \\<in> {dist xm ym<..dist xm ym + \\<bar>uM - um\\<bar>}", "have \"z \\<in> d`{A..B}\""], ["proof (prove)\nusing this:\n  tz \\<in> {dist xm ym<..dist xm ym + \\<bar>uM - um\\<bar>}\n\ngoal (1 subgoal):\n 1. z \\<in> d ` {A..B}", "unfolding tz(1) excursion_def"], ["proof (prove)\nusing this:\n  tz \\<in> {dist xm ym<..dist xm ym + \\<bar>uM - um\\<bar>}\n\ngoal (1 subgoal):\n 1. (if tz \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm tz\n     else if tz \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (tz - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (tz - dist xm ym - \\<bar>uM - um\\<bar>))\n    \\<in> d ` {A..B}", "using middle"], ["proof (prove)\nusing this:\n  tz \\<in> {dist xm ym<..dist xm ym + \\<bar>uM - um\\<bar>}\n  (\\<lambda>t. um + sgn (uM - um) * (t - dist xm ym)) `\n  {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n  \\<subseteq> {A..B}\n\ngoal (1 subgoal):\n 1. (if tz \\<in> {0..dist xm ym} then geodesic_segment_param {xm--ym} xm tz\n     else if tz \\<in> {dist xm ym..dist xm ym + \\<bar>uM - um\\<bar>}\n          then d (um + sgn (uM - um) * (tz - dist xm ym))\n          else geodesic_segment_param {yM--xM} yM\n                (tz - dist xm ym - \\<bar>uM - um\\<bar>))\n    \\<in> d ` {A..B}", "by force"], ["proof (state)\nthis:\n  z \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. tz \\<in> {dist xm\n               ym<..dist xm ym + \\<bar>uM - um\\<bar>} \\<Longrightarrow>\n    D \\<le> dist x z", "then"], ["proof (chain)\npicking this:\n  z \\<in> d ` {A..B}", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. D \\<le> dist x z", "unfolding D_def"], ["proof (prove)\nusing this:\n  z \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. infdist x (d ` {A..B}) \\<le> dist x z", "by (simp add: infdist_le)"], ["proof (state)\nthis:\n  D \\<le> dist x z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D \\<le> dist x z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> excursion ` {0..L} \\<Longrightarrow> D \\<le> dist x ?z\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "text \\<open>Now comes the main point: the excursion is always at distance at least $D$ of $x$,\n      but this distance is also bounded by the log of its length, i.e., essentially $\\log D$. To\n      have an efficient estimate, we use a rescaled version, to get rid of one term on the right\n      hand side.\\<close>"], ["proof (state)\nthis:\n  ?z \\<in> excursion ` {0..L} \\<Longrightarrow> D \\<le> dist x ?z\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"1 * 1 * 1 * (1 + 0/1) \\<le> 512 * lambda * lambda * (1+C/D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 1 * 1 * (1 + 0 / 1) \\<le> 512 * lambda * lambda * (1 + C / D)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (10 subgoals):\n 1. 1 \\<le> 512\n 2. 1 \\<le> lambda\n 3. 0 \\<le> 512\n 4. 0 \\<le> 1\n 5. 1 \\<le> lambda\n 6. 0 \\<le> 512 * lambda\n 7. 0 \\<le> 1\n 8. 0 / 1 \\<le> C / D\n 9. 0 \\<le> 512 * lambda * lambda\n 10. 0 \\<le> 1 + 0 / 1", "using \\<open>lambda \\<ge> 1\\<close> \\<open>D \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  1 \\<le> D\n  0 \\<le> C\n\ngoal (10 subgoals):\n 1. 1 \\<le> 512\n 2. 1 \\<le> lambda\n 3. 0 \\<le> 512\n 4. 0 \\<le> 1\n 5. 1 \\<le> lambda\n 6. 0 \\<le> 512 * lambda\n 7. 0 \\<le> 1\n 8. 0 / 1 \\<le> C / D\n 9. 0 \\<le> 512 * lambda * lambda\n 10. 0 \\<le> 1 + 0 / 1", "by auto"], ["proof (state)\nthis:\n  1 * 1 * 1 * (1 + 0 / 1) \\<le> 512 * lambda * lambda * (1 + C / D)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  1 * 1 * 1 * (1 + 0 / 1) \\<le> 512 * lambda * lambda * (1 + C / D)", "have \"ln (512 * lambda * lambda * (1+C/D)) \\<ge> 0\""], ["proof (prove)\nusing this:\n  1 * 1 * 1 * (1 + 0 / 1) \\<le> 512 * lambda * lambda * (1 + C / D)\n\ngoal (1 subgoal):\n 1. 0 \\<le> ln (512 * lambda * lambda * (1 + C / D))", "apply (subst ln_ge_zero_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 1 * 1 * 1 * (1 + 0 / 1)\n    \\<le> 512 * lambda * lambda * (1 + C / D) \\<Longrightarrow>\n    0 < 512 * lambda * lambda * (1 + C / D)\n 2. 1 * 1 * 1 * (1 + 0 / 1)\n    \\<le> 512 * lambda * lambda * (1 + C / D) \\<Longrightarrow>\n    1 \\<le> 512 * lambda * lambda * (1 + C / D)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> ln (512 * lambda * lambda * (1 + C / D))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "define a where \"a = 64 * lambda/D\""], ["proof (state)\nthis:\n  a = 64 * lambda / D\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"a > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 64 * lambda / D", "using \\<open>D \\<ge> 1\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> D\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 0 < 64 * lambda / D", "by auto"], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"D \\<le> infdist x (excursion`{0..L})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> infdist x (excursion ` {0..L})", "unfolding infdist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> (if excursion ` {0..L} = {} then 0\n             else Inf (dist x ` excursion ` {0..L}))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<le> Inf (dist x ` excursion ` {0..L})", "apply (rule cInf_greatest)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist x ` excursion ` {0..L} \\<noteq> {}\n 2. \\<And>xa.\n       xa \\<in> dist x ` excursion ` {0..L} \\<Longrightarrow> D \\<le> xa", "using *"], ["proof (prove)\nusing this:\n  ?z \\<in> excursion ` {0..L} \\<Longrightarrow> D \\<le> dist x ?z\n\ngoal (2 subgoals):\n 1. dist x ` excursion ` {0..L} \\<noteq> {}\n 2. \\<And>xa.\n       xa \\<in> dist x ` excursion ` {0..L} \\<Longrightarrow> D \\<le> xa", "by auto"], ["proof (state)\nthis:\n  D \\<le> infdist x (excursion ` {0..L})\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  D \\<le> infdist x (excursion ` {0..L})\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> (4/ln 2) * deltaG(TYPE('a)) * max 0 (ln (a * (L-0))) + (2 * lambda) / a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist x (excursion ` {0..L})\n    \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (L - 0))) +\n          2 * lambda / a", "proof (rule lipschitz_path_close_to_geodesic'[of _ _ _ _ \"geodesic_subsegment {c A--c B} (c A) tm tM\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. (2 * lambda)-lipschitz_on {0..L} excursion\n 2. geodesic_segment_between (geodesic_subsegment {c A--c B} (c A) tm tM)\n     (excursion 0) (excursion L)\n 3. x \\<in> geodesic_subsegment {c A--c B} (c A) tm tM\n 4. 0 < a", "show \"(2 * lambda)-lipschitz_on {0..L} excursion\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * lambda)-lipschitz_on {0..L} excursion", "by fact"], ["proof (state)\nthis:\n  (2 * lambda)-lipschitz_on {0..L} excursion\n\ngoal (3 subgoals):\n 1. geodesic_segment_between (geodesic_subsegment {c A--c B} (c A) tm tM)\n     (excursion 0) (excursion L)\n 2. x \\<in> geodesic_subsegment {c A--c B} (c A) tm tM\n 3. 0 < a", "have *: \"geodesic_subsegment {c A--c B} (c A) tm tM = geodesic_segment_param {c A--c B} (c A) ` {tm..tM} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_subsegment {c A--c B} (c A) tm tM =\n    geodesic_segment_param {c A--c B} (c A) ` {tm..tM}", "apply (rule geodesic_subsegment(1)[of _ _ \"c B\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. geodesic_segment_between {c A--c B} (c A) (c B)\n 2. 0 \\<le> tm\n 3. tm \\<le> tM\n 4. tM \\<le> dist (c A) (c B)", "using \\<open>tm \\<in> {0..dist (c A) (c B)}\\<close> \\<open>tM \\<in> {0..dist (c A) (c B)}\\<close> \\<open>tm \\<le> tM\\<close>"], ["proof (prove)\nusing this:\n  tm \\<in> {0..dist (c A) (c B)}\n  tM \\<in> {0..dist (c A) (c B)}\n  tm \\<le> tM\n\ngoal (4 subgoals):\n 1. geodesic_segment_between {c A--c B} (c A) (c B)\n 2. 0 \\<le> tm\n 3. tm \\<le> tM\n 4. tM \\<le> dist (c A) (c B)", "by auto"], ["proof (state)\nthis:\n  geodesic_subsegment {c A--c B} (c A) tm tM =\n  geodesic_segment_param {c A--c B} (c A) ` {tm..tM}\n\ngoal (3 subgoals):\n 1. geodesic_segment_between (geodesic_subsegment {c A--c B} (c A) tm tM)\n     (excursion 0) (excursion L)\n 2. x \\<in> geodesic_subsegment {c A--c B} (c A) tm tM\n 3. 0 < a", "show \"x \\<in> geodesic_subsegment {c A--c B} (c A) tm tM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> geodesic_subsegment {c A--c B} (c A) tm tM", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> geodesic_segment_param {c A--c B} (c A) ` {tm..tM}", "unfolding x_param tm_def tM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_param {c A--c B} (c A) tx\n    \\<in> geodesic_segment_param {c A--c B} (c A) `\n          {max (tx - 2 * D) 0..min (tx + 2 * D) (dist (c A) (c B))}", "using \\<open>tx \\<in> {0..dist (c A) (c B)}\\<close> \\<open>0 \\<le> D\\<close>"], ["proof (prove)\nusing this:\n  tx \\<in> {0..dist (c A) (c B)}\n  0 \\<le> D\n\ngoal (1 subgoal):\n 1. geodesic_segment_param {c A--c B} (c A) tx\n    \\<in> geodesic_segment_param {c A--c B} (c A) `\n          {max (tx - 2 * D) 0..min (tx + 2 * D) (dist (c A) (c B))}", "by simp"], ["proof (state)\nthis:\n  x \\<in> geodesic_subsegment {c A--c B} (c A) tm tM\n\ngoal (2 subgoals):\n 1. geodesic_segment_between (geodesic_subsegment {c A--c B} (c A) tm tM)\n     (excursion 0) (excursion L)\n 2. 0 < a", "show \"geodesic_segment_between (geodesic_subsegment {c A--c B} (c A) tm tM) (excursion 0) (excursion L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (geodesic_subsegment {c A--c B} (c A) tm tM)\n     (excursion 0) (excursion L)", "unfolding E0 EL xm_def xM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. geodesic_segment_between (geodesic_subsegment {c A--c B} (c A) tm tM)\n     (geodesic_segment_param {c A--c B} (c A) tm)\n     (geodesic_segment_param {c A--c B} (c A) tM)", "apply (rule geodesic_subsegment[of _ _ \"c B\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. geodesic_segment_between {c A--c B} (c A) (c B)\n 2. 0 \\<le> tm\n 3. tm \\<le> tM\n 4. tM \\<le> dist (c A) (c B)", "using \\<open>tm \\<in> {0..dist (c A) (c B)}\\<close> \\<open>tM \\<in> {0..dist (c A) (c B)}\\<close> \\<open>tm \\<le> tM\\<close>"], ["proof (prove)\nusing this:\n  tm \\<in> {0..dist (c A) (c B)}\n  tM \\<in> {0..dist (c A) (c B)}\n  tm \\<le> tM\n\ngoal (4 subgoals):\n 1. geodesic_segment_between {c A--c B} (c A) (c B)\n 2. 0 \\<le> tm\n 3. tm \\<le> tM\n 4. tM \\<le> dist (c A) (c B)", "by auto"], ["proof (state)\nthis:\n  geodesic_segment_between (geodesic_subsegment {c A--c B} (c A) tm tM)\n   (excursion 0) (excursion L)\n\ngoal (1 subgoal):\n 1. 0 < a", "qed (fact)"], ["proof (state)\nthis:\n  infdist x (excursion ` {0..L})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (L - 0))) +\n        2 * lambda / a\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  infdist x (excursion ` {0..L})\n  \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (L - 0))) +\n        2 * lambda / a\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... = (4/ln 2) * deltaG(TYPE('a)) * max 0 (ln (a *L)) + D/32\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (L - 0))) + 2 * lambda / a =\n    4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * L)) + D / 32", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (64 * lambda / D * (L - 0))) +\n    2 * lambda / (64 * lambda / D) =\n    4 / ln 2 * deltaG TYPE('a) * max 0 (ln (64 * lambda / D * L)) + D / 32", "using \\<open>D \\<ge> 1\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> D\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (64 * lambda / D * (L - 0))) +\n    2 * lambda / (64 * lambda / D) =\n    4 / ln 2 * deltaG TYPE('a) * max 0 (ln (64 * lambda / D * L)) + D / 32", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * (L - 0))) + 2 * lambda / a =\n  4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * L)) + D / 32\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  D \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * L)) + D / 32", "have \"(31 * ln 2 / 128) * D \\<le> deltaG(TYPE('a)) * max 0 (ln (a * L))\""], ["proof (prove)\nusing this:\n  D \\<le> 4 / ln 2 * deltaG TYPE('a) * max 0 (ln (a * L)) + D / 32\n\ngoal (1 subgoal):\n 1. 31 * ln 2 / 128 * D \\<le> deltaG TYPE('a) * max 0 (ln (a * L))", "by (auto simp add: algebra_simps divide_simps)"], ["proof (state)\nthis:\n  31 * ln 2 / 128 * D \\<le> deltaG TYPE('a) * max 0 (ln (a * L))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  31 * ln 2 / 128 * D \\<le> deltaG TYPE('a) * max 0 (ln (a * L))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> deltaG(TYPE('a)) * max 0 (ln ((64 * lambda/D) * (lambda * (8 * D + 4 * C))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * max 0 (ln (a * L))\n    \\<le> deltaG TYPE('a) *\n          max 0 (ln (64 * lambda / D * (lambda * (8 * D + 4 * C))))", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * max 0 (ln (64 * lambda / D * L))\n    \\<le> deltaG TYPE('a) *\n          max 0 (ln (64 * lambda / D * (lambda * (8 * D + 4 * C))))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 \\<le> 0\n 2. 0 < 64 * lambda / D * L\n 3. L \\<le> lambda * (8 * D + 4 * C)\n 4. 0 \\<le> 64 * lambda / D", "using L_bound \\<open>L > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>D \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  L \\<le> lambda * (8 * D + 4 * C)\n  0 < L\n  1 \\<le> lambda\n  1 \\<le> D\n\ngoal (4 subgoals):\n 1. 0 \\<le> 0\n 2. 0 < 64 * lambda / D * L\n 3. L \\<le> lambda * (8 * D + 4 * C)\n 4. 0 \\<le> 64 * lambda / D", "by auto"], ["proof (state)\nthis:\n  deltaG TYPE('a) * max 0 (ln (a * L))\n  \\<le> deltaG TYPE('a) *\n        max 0 (ln (64 * lambda / D * (lambda * (8 * D + 4 * C))))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  deltaG TYPE('a) * max 0 (ln (a * L))\n  \\<le> deltaG TYPE('a) *\n        max 0 (ln (64 * lambda / D * (lambda * (8 * D + 4 * C))))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> deltaG(TYPE('a)) * max 0 (ln ((64 * lambda/D) * (lambda * (8 * D + 8 * C))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) *\n    max 0 (ln (64 * lambda / D * (lambda * (8 * D + 4 * C))))\n    \\<le> deltaG TYPE('a) *\n          max 0 (ln (64 * lambda / D * (lambda * (8 * D + 8 * C))))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. 0 \\<le> 0\n 2. 0 < 64 * lambda / D * (lambda * (8 * D + 4 * C))\n 3. 4 \\<le> 8\n 4. 0 \\<le> C\n 5. 0 \\<le> lambda\n 6. 0 \\<le> 64 * lambda / D", "using L_bound \\<open>L > 0\\<close> \\<open>lambda \\<ge> 1\\<close> \\<open>D \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  L \\<le> lambda * (8 * D + 4 * C)\n  0 < L\n  1 \\<le> lambda\n  1 \\<le> D\n  0 \\<le> C\n\ngoal (6 subgoals):\n 1. 0 \\<le> 0\n 2. 0 < 64 * lambda / D * (lambda * (8 * D + 4 * C))\n 3. 4 \\<le> 8\n 4. 0 \\<le> C\n 5. 0 \\<le> lambda\n 6. 0 \\<le> 64 * lambda / D", "by auto"], ["proof (state)\nthis:\n  deltaG TYPE('a) *\n  max 0 (ln (64 * lambda / D * (lambda * (8 * D + 4 * C))))\n  \\<le> deltaG TYPE('a) *\n        max 0 (ln (64 * lambda / D * (lambda * (8 * D + 8 * C))))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  deltaG TYPE('a) *\n  max 0 (ln (64 * lambda / D * (lambda * (8 * D + 4 * C))))\n  \\<le> deltaG TYPE('a) *\n        max 0 (ln (64 * lambda / D * (lambda * (8 * D + 8 * C))))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... = deltaG(TYPE('a)) * max 0 (ln (512 * lambda * lambda * (1+C/D)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) *\n    max 0 (ln (64 * lambda / D * (lambda * (8 * D + 8 * C)))) =\n    deltaG TYPE('a) * max 0 (ln (512 * lambda * lambda * (1 + C / D)))", "using \\<open>D \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> D\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) *\n    max 0 (ln (64 * lambda / D * (lambda * (8 * D + 8 * C)))) =\n    deltaG TYPE('a) * max 0 (ln (512 * lambda * lambda * (1 + C / D)))", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  deltaG TYPE('a) *\n  max 0 (ln (64 * lambda / D * (lambda * (8 * D + 8 * C)))) =\n  deltaG TYPE('a) * max 0 (ln (512 * lambda * lambda * (1 + C / D)))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  deltaG TYPE('a) *\n  max 0 (ln (64 * lambda / D * (lambda * (8 * D + 8 * C)))) =\n  deltaG TYPE('a) * max 0 (ln (512 * lambda * lambda * (1 + C / D)))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... = deltaG(TYPE('a)) * ln (512 * lambda * lambda * (1+C/D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * max 0 (ln (512 * lambda * lambda * (1 + C / D))) =\n    deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / D))", "using \\<open>ln (512 * lambda * lambda * (1+C/D)) \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> ln (512 * lambda * lambda * (1 + C / D))\n\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * max 0 (ln (512 * lambda * lambda * (1 + C / D))) =\n    deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / D))", "by auto"], ["proof (state)\nthis:\n  deltaG TYPE('a) * max 0 (ln (512 * lambda * lambda * (1 + C / D))) =\n  deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / D))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  deltaG TYPE('a) * max 0 (ln (512 * lambda * lambda * (1 + C / D))) =\n  deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / D))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> deltaG(TYPE('a)) * ln (512 * lambda * lambda * (1+C/1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / D))\n    \\<le> deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1))", "apply (intro mono_intros)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < 512 * lambda * lambda * (1 + C / D)\n 2. C / D \\<le> C / 1\n 3. 0 \\<le> 512 * lambda * lambda", "using \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close> \\<open>D \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n  1 \\<le> D\n\ngoal (3 subgoals):\n 1. 0 < 512 * lambda * lambda * (1 + C / D)\n 2. C / D \\<le> C / 1\n 3. 0 \\<le> 512 * lambda * lambda", "by (auto simp add: divide_simps mult_ge1_mono(1))"], ["proof (state)\nthis:\n  deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / D))\n  \\<le> deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "text \\<open>We have obtained a bound on $D$, of the form $D \\leq M \\delta \\ln(M \\lambda^2(1+C))$.\n      This is a nice bound, but we tweak it a little bit to obtain something more manageable,\n      without the logarithm.\\<close>"], ["proof (state)\nthis:\n  deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / D))\n  \\<le> deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / D))\n  \\<le> deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... = deltaG(TYPE('a)) * (ln 512 + 2 * ln lambda + ln (1+C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * (ln 512 + 2 * ln lambda + ln (1 + C))", "apply (subst ln2mult)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < lambda\n 2. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * (ln 512 + ln (lambda * lambda) + ln (1 + C))", "using \\<open>C \\<ge> 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (2 subgoals):\n 1. 0 < lambda\n 2. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * (ln 512 + ln (lambda * lambda) + ln (1 + C))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * (ln 512 + ln (lambda * lambda) + ln (1 + C))", "apply (subst ln_mult[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < 512\n 2. 0 < lambda * lambda\n 3. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * (ln (512 * (lambda * lambda)) + ln (1 + C))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < lambda * lambda\n 2. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * (ln (512 * (lambda * lambda)) + ln (1 + C))", "using \\<open>C \\<ge> 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (2 subgoals):\n 1. 0 < lambda * lambda\n 2. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * (ln (512 * (lambda * lambda)) + ln (1 + C))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * (ln (512 * (lambda * lambda)) + ln (1 + C))", "apply (subst ln_mult[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < 512 * (lambda * lambda)\n 2. 0 < 1 + C\n 3. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * ln (512 * (lambda * lambda) * (1 + C))", "using \\<open>C \\<ge> 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (3 subgoals):\n 1. 0 < 512 * (lambda * lambda)\n 2. 0 < 1 + C\n 3. deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n    deltaG TYPE('a) * ln (512 * (lambda * lambda) * (1 + C))", "by auto"], ["proof (state)\nthis:\n  deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n  deltaG TYPE('a) * (ln 512 + 2 * ln lambda + ln (1 + C))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  deltaG TYPE('a) * ln (512 * lambda * lambda * (1 + C / 1)) =\n  deltaG TYPE('a) * (ln 512 + 2 * ln lambda + ln (1 + C))\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... = (deltaG(TYPE('a)) * 1) * ln 512 + 2 * (deltaG(TYPE('a)) * ln lambda) + (deltaG(TYPE('a)) * ln (1+C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * (ln 512 + 2 * ln lambda + ln (1 + C)) =\n    deltaG TYPE('a) * 1 * ln 512 + 2 * (deltaG TYPE('a) * ln lambda) +\n    deltaG TYPE('a) * ln (1 + C)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  deltaG TYPE('a) * (ln 512 + 2 * ln lambda + ln (1 + C)) =\n  deltaG TYPE('a) * 1 * ln 512 + 2 * (deltaG TYPE('a) * ln lambda) +\n  deltaG TYPE('a) * ln (1 + C)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "text \\<open>For each term, of the form $\\delta \\ln c$, we bound it by $(\\delta^2 + (\\ln c)^2)/2$, and\n      then bound $(\\ln c)^2$ by $2c-2$. In fact, to get coefficients of the same order of\n      magnitude on $\\delta^2$ and $\\lambda$, we tweak a little bit the inequality for the last two\n      terms, using rather $uv \\leq (u^2/2 + 2v^2)/2$. We also bound $\\ln(32)$ by a good\n      approximation $16/3$.\\<close>"], ["proof (state)\nthis:\n  deltaG TYPE('a) * (ln 512 + 2 * ln lambda + ln (1 + C)) =\n  deltaG TYPE('a) * 1 * ln 512 + 2 * (deltaG TYPE('a) * ln lambda) +\n  deltaG TYPE('a) * ln (1 + C)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  deltaG TYPE('a) * (ln 512 + 2 * ln lambda + ln (1 + C)) =\n  deltaG TYPE('a) * 1 * ln 512 + 2 * (deltaG TYPE('a) * ln lambda) +\n  deltaG TYPE('a) * ln (1 + C)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> (deltaG(TYPE('a))^2/2 + 1^2/2) * (25/4)\n            + 2 * ((1/2) * deltaG(TYPE('a))^2/2 + 2 * (ln lambda)^2 / 2) + ((1/2) * deltaG(TYPE('a))^2/2 + 2 * (ln (1+C))^2 / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deltaG TYPE('a) * 1 * ln 512 + 2 * (deltaG TYPE('a) * ln lambda) +\n    deltaG TYPE('a) * ln (1 + C)\n    \\<le> ((deltaG TYPE('a))\\<^sup>2 / 2 + 1\\<^sup>2 / 2) * (25 / 4) +\n          2 *\n          (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 +\n           2 * (ln lambda)\\<^sup>2 / 2) +\n          (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 +\n           2 * (ln (1 + C))\\<^sup>2 / 2)", "by (intro mono_intros, auto, approximation 10)"], ["proof (state)\nthis:\n  deltaG TYPE('a) * 1 * ln 512 + 2 * (deltaG TYPE('a) * ln lambda) +\n  deltaG TYPE('a) * ln (1 + C)\n  \\<le> ((deltaG TYPE('a))\\<^sup>2 / 2 + 1\\<^sup>2 / 2) * (25 / 4) +\n        2 *\n        (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 +\n         2 * (ln lambda)\\<^sup>2 / 2) +\n        (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 +\n         2 * (ln (1 + C))\\<^sup>2 / 2)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  deltaG TYPE('a) * 1 * ln 512 + 2 * (deltaG TYPE('a) * ln lambda) +\n  deltaG TYPE('a) * ln (1 + C)\n  \\<le> ((deltaG TYPE('a))\\<^sup>2 / 2 + 1\\<^sup>2 / 2) * (25 / 4) +\n        2 *\n        (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 +\n         2 * (ln lambda)\\<^sup>2 / 2) +\n        (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 +\n         2 * (ln (1 + C))\\<^sup>2 / 2)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... = (31/8) * deltaG(TYPE('a))^2 + 25/8 + 2 * (ln lambda)^2 + (ln (1+C))^2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((deltaG TYPE('a))\\<^sup>2 / 2 + 1\\<^sup>2 / 2) * (25 / 4) +\n    2 *\n    (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 + 2 * (ln lambda)\\<^sup>2 / 2) +\n    (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 + 2 * (ln (1 + C))\\<^sup>2 / 2) =\n    31 / 8 * (deltaG TYPE('a))\\<^sup>2 + 25 / 8 + 2 * (ln lambda)\\<^sup>2 +\n    (ln (1 + C))\\<^sup>2", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  ((deltaG TYPE('a))\\<^sup>2 / 2 + 1\\<^sup>2 / 2) * (25 / 4) +\n  2 *\n  (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 + 2 * (ln lambda)\\<^sup>2 / 2) +\n  (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 + 2 * (ln (1 + C))\\<^sup>2 / 2) =\n  31 / 8 * (deltaG TYPE('a))\\<^sup>2 + 25 / 8 + 2 * (ln lambda)\\<^sup>2 +\n  (ln (1 + C))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  ((deltaG TYPE('a))\\<^sup>2 / 2 + 1\\<^sup>2 / 2) * (25 / 4) +\n  2 *\n  (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 + 2 * (ln lambda)\\<^sup>2 / 2) +\n  (1 / 2 * (deltaG TYPE('a))\\<^sup>2 / 2 + 2 * (ln (1 + C))\\<^sup>2 / 2) =\n  31 / 8 * (deltaG TYPE('a))\\<^sup>2 + 25 / 8 + 2 * (ln lambda)\\<^sup>2 +\n  (ln (1 + C))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> 4 * deltaG(TYPE('a))^2 + 4 + 2 * (2 * lambda - 2) + (2 * (1+C) - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 31 / 8 * (deltaG TYPE('a))\\<^sup>2 + 25 / 8 + 2 * (ln lambda)\\<^sup>2 +\n    (ln (1 + C))\\<^sup>2\n    \\<le> 4 * (deltaG TYPE('a))\\<^sup>2 + 4 + 2 * (2 * lambda - 2) +\n          (2 * (1 + C) - 2)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (6 subgoals):\n 1. 31 / 8 \\<le> 4\n 2. 0 \\<le> (deltaG TYPE('a))\\<^sup>2\n 3. 25 / 8 \\<le> 4\n 4. 1 \\<le> lambda\n 5. 0 \\<le> 2\n 6. 1 \\<le> 1 + C", "using \\<open>C \\<ge> 0\\<close> \\<open>lambda \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (6 subgoals):\n 1. 31 / 8 \\<le> 4\n 2. 0 \\<le> (deltaG TYPE('a))\\<^sup>2\n 3. 25 / 8 \\<le> 4\n 4. 1 \\<le> lambda\n 5. 0 \\<le> 2\n 6. 1 \\<le> 1 + C", "by auto"], ["proof (state)\nthis:\n  31 / 8 * (deltaG TYPE('a))\\<^sup>2 + 25 / 8 + 2 * (ln lambda)\\<^sup>2 +\n  (ln (1 + C))\\<^sup>2\n  \\<le> 4 * (deltaG TYPE('a))\\<^sup>2 + 4 + 2 * (2 * lambda - 2) +\n        (2 * (1 + C) - 2)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  31 / 8 * (deltaG TYPE('a))\\<^sup>2 + 25 / 8 + 2 * (ln lambda)\\<^sup>2 +\n  (ln (1 + C))\\<^sup>2\n  \\<le> 4 * (deltaG TYPE('a))\\<^sup>2 + 4 + 2 * (2 * lambda - 2) +\n        (2 * (1 + C) - 2)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> 4 * deltaG(TYPE('a))^2 + 4 * lambda + 2 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * (deltaG TYPE('a))\\<^sup>2 + 4 + 2 * (2 * lambda - 2) +\n    (2 * (1 + C) - 2)\n    \\<le> 4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C", "by auto"], ["proof (state)\nthis:\n  4 * (deltaG TYPE('a))\\<^sup>2 + 4 + 2 * (2 * lambda - 2) +\n  (2 * (1 + C) - 2)\n  \\<le> 4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  31 * ln 2 / 128 * D\n  \\<le> 4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C", "have \"D \\<le> (128 / (31 * ln 2)) * (4 * deltaG(TYPE('a))^2 + 4 * lambda + 2 * C)\""], ["proof (prove)\nusing this:\n  31 * ln 2 / 128 * D\n  \\<le> 4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C\n\ngoal (1 subgoal):\n 1. D \\<le> 128 / (31 * ln 2) *\n            (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  D \\<le> 128 / (31 * ln 2) *\n          (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  D \\<le> 128 / (31 * ln 2) *\n          (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> 6 * (4 * deltaG(TYPE('a))^2 + 4 * lambda + 2 * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 128 / (31 * ln 2) * (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n    \\<le> 6 * (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)", "apply (intro mono_intros, approximation 10)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C", "using \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 0 \\<le> 4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C", "by auto"], ["proof (state)\nthis:\n  128 / (31 * ln 2) * (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n  \\<le> 6 * (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "also"], ["proof (state)\nthis:\n  128 / (31 * ln 2) * (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n  \\<le> 6 * (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "have \"... \\<le> 24 * deltaG(TYPE('a))^2 + 24 * lambda + 12 * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 6 * (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n    \\<le> 24 * (deltaG TYPE('a))\\<^sup>2 + 24 * lambda + 12 * C", "using \\<open>lambda \\<ge> 1\\<close> \\<open>C \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> lambda\n  0 \\<le> C\n\ngoal (1 subgoal):\n 1. 6 * (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n    \\<le> 24 * (deltaG TYPE('a))\\<^sup>2 + 24 * lambda + 12 * C", "by auto"], ["proof (state)\nthis:\n  6 * (4 * (deltaG TYPE('a))\\<^sup>2 + 4 * lambda + 2 * C)\n  \\<le> 24 * (deltaG TYPE('a))\\<^sup>2 + 24 * lambda + 12 * C\n\ngoal (1 subgoal):\n 1. \\<not> D \\<le> 1 \\<Longrightarrow>\n    D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  D \\<le> 24 * (deltaG TYPE('a))\\<^sup>2 + 24 * lambda + 12 * C", "show ?thesis"], ["proof (prove)\nusing this:\n  D \\<le> 24 * (deltaG TYPE('a))\\<^sup>2 + 24 * lambda + 12 * C\n\ngoal (1 subgoal):\n 1. D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "define D0 where \"D0 = 24 * lambda + 12 * C + 24 * deltaG(TYPE('a))^2\""], ["proof (state)\nthis:\n  D0 = 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have first_step: \"infdist y (d`{A..B}) \\<le> D0\" if \"y \\<in> {c A--c B}\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist y (d ` {A..B}) \\<le> D0", "using x(2)[OF that] D_bound"], ["proof (prove)\nusing this:\n  infdist y (d ` {A..B}) \\<le> infdist x (d ` {A..B})\n  D \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n\ngoal (1 subgoal):\n 1. infdist y (d ` {A..B}) \\<le> D0", "unfolding D0_def D_def"], ["proof (prove)\nusing this:\n  infdist y (d ` {A..B}) \\<le> infdist x (d ` {A..B})\n  infdist x (d ` {A..B})\n  \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n\ngoal (1 subgoal):\n 1. infdist y (d ` {A..B})\n    \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  ?y \\<in> {c A--c B} \\<Longrightarrow> infdist ?y (d ` {A..B}) \\<le> D0\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"1 * 1 + 4 * 0 + 24 * 0 \\<le> D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 1 + 4 * 0 + 24 * 0 \\<le> D0", "unfolding D0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 1 + 4 * 0 + 24 * 0\n    \\<le> 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2", "apply (intro mono_intros)"], ["proof (prove)\ngoal (10 subgoals):\n 1. 1 \\<le> 24\n 2. 1 \\<le> lambda\n 3. 0 \\<le> 24\n 4. 0 \\<le> 1\n 5. 4 \\<le> 12\n 6. 0 \\<le> C\n 7. 0 \\<le> 12\n 8. 0 \\<le> 0\n 9. 0 \\<le> (deltaG TYPE('a))\\<^sup>2\n 10. 0 \\<le> 24", "using C delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  0 \\<le> deltaG TYPE('a)\n\ngoal (10 subgoals):\n 1. 1 \\<le> 24\n 2. 1 \\<le> lambda\n 3. 0 \\<le> 24\n 4. 0 \\<le> 1\n 5. 4 \\<le> 12\n 6. 0 \\<le> C\n 7. 0 \\<le> 12\n 8. 0 \\<le> 0\n 9. 0 \\<le> (deltaG TYPE('a))\\<^sup>2\n 10. 0 \\<le> 24", "by auto"], ["proof (state)\nthis:\n  1 * 1 + 4 * 0 + 24 * 0 \\<le> D0\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  1 * 1 + 4 * 0 + 24 * 0 \\<le> D0", "have \"D0 > 0\""], ["proof (prove)\nusing this:\n  1 * 1 + 4 * 0 + 24 * 0 \\<le> D0\n\ngoal (1 subgoal):\n 1. 0 < D0", "by simp"], ["proof (state)\nthis:\n  0 < D0\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "text \\<open>This is the end of the first step, i.e., showing that $[c(A), c(B)]$ is included in\n    the neighborhood of size $D0$ of the quasi-geodesic.\\<close>"], ["proof (state)\nthis:\n  0 < D0\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "text \\<open>Now, we start the second step: we show that the quasi-geodesic is included in the\n    neighborhood of size $D1$ of the geodesic, where $D1 \\geq D0$ is the constant defined below.\n    The argument goes as follows. Assume that a point $y$ on the quasi-geodesic is at distance $ > D0$\n    of the geodesic. Consider the last point $y_m$ before $y$ which is at distance $D0$ of the\n    geodesic, and the first point $y_M$ after $y$ likewise. On $(y_m, y_M)$, one is always at distance\n    $ > D0$ of the geodesic. However, by the first step, the geodesic is covered by the balls of radius\n    $D0$ centered at points on the quasi-geodesic -- and only the points before $y_m$ or after $y_M$\n    can be used. Let $K_m$ be the points on the geodesics that are at distance $\\leq D0$ of a point\n    on the quasi-geodesic before $y_m$, and likewise define $K_M$. These are two closed subsets of\n    the geodesic. By connectedness, they have to intersect. This implies that some points before $y_m$\n    and after $y_M$ are at distance at most $2D0$. Since we are dealing with a quasi-geodesic, this\n    gives a bound on the distance between $y_m$ and $y_M$, and therefore a bound between $y$ and the\n    geodesic, as desired.\\<close>"], ["proof (state)\nthis:\n  0 < D0\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "define D1 where \"D1 = lambda * lambda * (72 * lambda + 44 * C + 72 * deltaG(TYPE('a))^2)\""], ["proof (state)\nthis:\n  D1 =\n  lambda * lambda * (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"1 * 1 * (24 * lambda + 12 * C + 24 * deltaG(TYPE('a))^2)\n            \\<le> lambda * lambda * (72 * lambda + 44 * C + 72 * deltaG(TYPE('a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 1 * (24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2)\n    \\<le> lambda * lambda *\n          (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (12 subgoals):\n 1. 1 \\<le> lambda\n 2. 1 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> 1\n 5. 24 \\<le> 72\n 6. 0 \\<le> lambda\n 7. 12 \\<le> 44\n 8. 0 \\<le> C\n 9. 24 \\<le> 72\n 10. 0 \\<le> (deltaG TYPE('a))\\<^sup>2\nA total of 12 subgoals...", "using C"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (12 subgoals):\n 1. 1 \\<le> lambda\n 2. 1 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> 1\n 5. 24 \\<le> 72\n 6. 0 \\<le> lambda\n 7. 12 \\<le> 44\n 8. 0 \\<le> C\n 9. 24 \\<le> 72\n 10. 0 \\<le> (deltaG TYPE('a))\\<^sup>2\nA total of 12 subgoals...", "by auto"], ["proof (state)\nthis:\n  1 * 1 * (24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2)\n  \\<le> lambda * lambda *\n        (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "then"], ["proof (chain)\npicking this:\n  1 * 1 * (24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2)\n  \\<le> lambda * lambda *\n        (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)", "have \"D0 \\<le> D1\""], ["proof (prove)\nusing this:\n  1 * 1 * (24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2)\n  \\<le> lambda * lambda *\n        (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. D0 \\<le> D1", "unfolding D0_def D1_def"], ["proof (prove)\nusing this:\n  1 * 1 * (24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2)\n  \\<le> lambda * lambda *\n        (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2\n    \\<le> lambda * lambda *\n          (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  D0 \\<le> D1\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have second_step: \"infdist y {c A--c B} \\<le> D1\" if \"y \\<in> d`{A..B}\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist y {c A--c B} \\<le> D1", "proof (cases \"infdist y {c A--c B} \\<le> D0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1\n 2. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "case True"], ["proof (state)\nthis:\n  infdist y {c A--c B} \\<le> D0\n\ngoal (2 subgoals):\n 1. infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1\n 2. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "then"], ["proof (chain)\npicking this:\n  infdist y {c A--c B} \\<le> D0", "show ?thesis"], ["proof (prove)\nusing this:\n  infdist y {c A--c B} \\<le> D0\n\ngoal (1 subgoal):\n 1. infdist y {c A--c B} \\<le> D1", "using \\<open>D0 \\<le> D1\\<close>"], ["proof (prove)\nusing this:\n  infdist y {c A--c B} \\<le> D0\n  D0 \\<le> D1\n\ngoal (1 subgoal):\n 1. infdist y {c A--c B} \\<le> D1", "by auto"], ["proof (state)\nthis:\n  infdist y {c A--c B} \\<le> D1\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "case False"], ["proof (state)\nthis:\n  \\<not> infdist y {c A--c B} \\<le> D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "obtain ty where \"ty \\<in> {A..B}\" \"y = d ty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ty.\n        \\<lbrakk>ty \\<in> {A..B}; y = d ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>y \\<in> d`{A..B}\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. (\\<And>ty.\n        \\<lbrakk>ty \\<in> {A..B}; y = d ty\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ty \\<in> {A..B}\n  y = d ty\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "define tm where \"tm = Sup ((\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {A..ty})\""], ["proof (state)\nthis:\n  tm =\n  Sup ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have tm: \"tm \\<in> (\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {A..ty}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n             {A..ty}", "unfolding tm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})\n    \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}", "proof (rule closed_contains_Sup)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n    {A..ty} \\<noteq>\n    {}\n 2. bdd_above\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})\n 3. closed\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})", "show \"closed ((\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {A..ty})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})", "apply (rule closed_vimage_Int, auto, intro continuous_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {A..ty} d", "apply (rule continuous_on_subset[OF d(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {A..ty} \\<subseteq> {A..B}", "using \\<open>ty \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  ty \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. {A..ty} \\<subseteq> {A..B}", "by auto"], ["proof (state)\nthis:\n  closed ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})\n\ngoal (2 subgoals):\n 1. (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n    {A..ty} \\<noteq>\n    {}\n 2. bdd_above\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})", "have \"A \\<in> (\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {A..ty}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {A..ty}", "using \\<open>D0 > 0\\<close> \\<open>ty \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  0 < D0\n  ty \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. A \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {A..ty}", "by (auto simp add: \\<open>d A = c A\\<close>)"], ["proof (state)\nthis:\n  A \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n\ngoal (2 subgoals):\n 1. (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n    {A..ty} \\<noteq>\n    {}\n 2. bdd_above\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})", "then"], ["proof (chain)\npicking this:\n  A \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}", "show \"(\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {A..ty} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  A \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n    {A..ty} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. bdd_above\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})", "show \"bdd_above ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_above\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})", "by auto"], ["proof (state)\nthis:\n  bdd_above\n   ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tm \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have *: \"infdist (d t) {c A--c B} > D0\" if \"t \\<in> {tm<..ty}\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. D0 < infdist (d t) {c A--c B}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> D0 < infdist (d t) {c A--c B} \\<Longrightarrow> False", "assume \"\\<not>(infdist (d t) {c A--c B} > D0)\""], ["proof (state)\nthis:\n  \\<not> D0 < infdist (d t) {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<not> D0 < infdist (d t) {c A--c B} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> D0 < infdist (d t) {c A--c B}", "have *: \"t \\<in> (\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {A..ty}\""], ["proof (prove)\nusing this:\n  \\<not> D0 < infdist (d t) {c A--c B}\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {A..ty}", "using that tm"], ["proof (prove)\nusing this:\n  \\<not> D0 < infdist (d t) {c A--c B}\n  t \\<in> {tm<..ty}\n  tm \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {A..ty}", "by auto"], ["proof (state)\nthis:\n  t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n\ngoal (1 subgoal):\n 1. \\<not> D0 < infdist (d t) {c A--c B} \\<Longrightarrow> False", "have \"t \\<le> tm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> tm", "unfolding tm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> Sup ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n                 {A..ty})", "apply (rule cSup_upper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {A..ty}\n 2. bdd_above\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})", "using *"], ["proof (prove)\nusing this:\n  t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n\ngoal (2 subgoals):\n 1. t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {A..ty}\n 2. bdd_above\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty})", "by auto"], ["proof (state)\nthis:\n  t \\<le> tm\n\ngoal (1 subgoal):\n 1. \\<not> D0 < infdist (d t) {c A--c B} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t \\<le> tm", "show False"], ["proof (prove)\nusing this:\n  t \\<le> tm\n\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  t \\<le> tm\n  t \\<in> {tm<..ty}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> {tm<..ty} \\<Longrightarrow> D0 < infdist (d ?t) {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "define tM where \"tM = Inf ((\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {ty..B})\""], ["proof (state)\nthis:\n  tM =\n  Inf ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have tM: \"tM \\<in> (\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {ty..B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tM \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n             {ty..B}", "unfolding tM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})\n    \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}", "proof (rule closed_contains_Inf)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n    {ty..B} \\<noteq>\n    {}\n 2. bdd_below\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})\n 3. closed\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})", "show \"closed ((\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {ty..B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})", "apply (rule closed_vimage_Int, auto, intro continuous_intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {ty..B} d", "apply (rule continuous_on_subset[OF d(1)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ty..B} \\<subseteq> {A..B}", "using \\<open>ty \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  ty \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. {ty..B} \\<subseteq> {A..B}", "by auto"], ["proof (state)\nthis:\n  closed ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})\n\ngoal (2 subgoals):\n 1. (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n    {ty..B} \\<noteq>\n    {}\n 2. bdd_below\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})", "have \"B \\<in> (\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {ty..B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {ty..B}", "using \\<open>D0 > 0\\<close> \\<open>ty \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  0 < D0\n  ty \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. B \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {ty..B}", "by (auto simp add: \\<open>d B = c B\\<close>)"], ["proof (state)\nthis:\n  B \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n\ngoal (2 subgoals):\n 1. (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n    {ty..B} \\<noteq>\n    {}\n 2. bdd_below\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})", "then"], ["proof (chain)\npicking this:\n  B \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}", "show \"(\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {ty..B} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  B \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n    {ty..B} \\<noteq>\n    {}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B} \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. bdd_below\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})", "show \"bdd_below ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdd_below\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})", "by auto"], ["proof (state)\nthis:\n  bdd_below\n   ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tM \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"infdist (d t) {c A--c B} > D0\" if \"t \\<in> {ty..<tM}\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. D0 < infdist (d t) {c A--c B}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> D0 < infdist (d t) {c A--c B} \\<Longrightarrow> False", "assume \"\\<not>(infdist (d t) {c A--c B} > D0)\""], ["proof (state)\nthis:\n  \\<not> D0 < infdist (d t) {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<not> D0 < infdist (d t) {c A--c B} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> D0 < infdist (d t) {c A--c B}", "have *: \"t \\<in> (\\<lambda>t. infdist (d t) {c A--c B})-`{..D0} \\<inter> {ty..B}\""], ["proof (prove)\nusing this:\n  \\<not> D0 < infdist (d t) {c A--c B}\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {ty..B}", "using that tM"], ["proof (prove)\nusing this:\n  \\<not> D0 < infdist (d t) {c A--c B}\n  t \\<in> {ty..<tM}\n  tM \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n\ngoal (1 subgoal):\n 1. t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {ty..B}", "by auto"], ["proof (state)\nthis:\n  t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n\ngoal (1 subgoal):\n 1. \\<not> D0 < infdist (d t) {c A--c B} \\<Longrightarrow> False", "have \"t \\<ge> tM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tM \\<le> t", "unfolding tM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})\n    \\<le> t", "apply (rule cInf_lower)"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {ty..B}\n 2. bdd_below\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})", "using *"], ["proof (prove)\nusing this:\n  t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n\ngoal (2 subgoals):\n 1. t \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter>\n            {ty..B}\n 2. bdd_below\n     ((\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B})", "by auto"], ["proof (state)\nthis:\n  tM \\<le> t\n\ngoal (1 subgoal):\n 1. \\<not> D0 < infdist (d t) {c A--c B} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  tM \\<le> t", "show False"], ["proof (prove)\nusing this:\n  tM \\<le> t\n\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  tM \\<le> t\n  t \\<in> {ty..<tM}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> {ty..<tM} \\<Longrightarrow> D0 < infdist (d ?t) {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "then"], ["proof (chain)\npicking this:\n  ?t \\<in> {ty..<tM} \\<Longrightarrow> D0 < infdist (d ?t) {c A--c B}", "have lower_tm_tM: \"infdist (d t) {c A--c B} > D0\" if \"t \\<in> {tm<..<tM}\" for t"], ["proof (prove)\nusing this:\n  ?t \\<in> {ty..<tM} \\<Longrightarrow> D0 < infdist (d ?t) {c A--c B}\n\ngoal (1 subgoal):\n 1. D0 < infdist (d t) {c A--c B}", "using * that"], ["proof (prove)\nusing this:\n  ?t \\<in> {ty..<tM} \\<Longrightarrow> D0 < infdist (d ?t) {c A--c B}\n  ?t \\<in> {tm<..ty} \\<Longrightarrow> D0 < infdist (d ?t) {c A--c B}\n  t \\<in> {tm<..<tM}\n\ngoal (1 subgoal):\n 1. D0 < infdist (d t) {c A--c B}", "by (cases \"t \\<ge> ty\", auto)"], ["proof (state)\nthis:\n  ?t \\<in> {tm<..<tM} \\<Longrightarrow> D0 < infdist (d ?t) {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "define Km where \"Km = (\\<Union>z \\<in> d`{A..tm}. cball z D0)\""], ["proof (state)\nthis:\n  Km = (\\<Union>z\\<in>d ` {A..tm}. cball z D0)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "define KM where \"KM = (\\<Union>z \\<in> d`{tM..B}. cball z D0)\""], ["proof (state)\nthis:\n  KM = (\\<Union>z\\<in>d ` {tM..B}. cball z D0)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"{c A--c B} \\<subseteq> Km \\<union> KM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {c A--c B} \\<subseteq> Km \\<union> KM", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {c A--c B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {c A--c B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "assume \"x \\<in> {c A--c B}\""], ["proof (state)\nthis:\n  x \\<in> {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {c A--c B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "have \"\\<exists>z \\<in> d`{A..B}. infdist x (d`{A..B}) = dist x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<in>d ` {A..B}. infdist x (d ` {A..B}) = dist x z", "apply (rule infdist_proper_attained[OF proper_of_compact], rule compact_continuous_image[OF \\<open>continuous_on {A..B} d\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. compact {A..B}\n 2. d ` {A..B} \\<noteq> {}", "using that"], ["proof (prove)\nusing this:\n  y \\<in> d ` {A..B}\n\ngoal (2 subgoals):\n 1. compact {A..B}\n 2. d ` {A..B} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>z\\<in>d ` {A..B}. infdist x (d ` {A..B}) = dist x z\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {c A--c B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  \\<exists>z\\<in>d ` {A..B}. infdist x (d ` {A..B}) = dist x z", "obtain tx where \"tx \\<in> {A..B}\" \"infdist x (d`{A..B}) = dist x (d tx)\""], ["proof (prove)\nusing this:\n  \\<exists>z\\<in>d ` {A..B}. infdist x (d ` {A..B}) = dist x z\n\ngoal (1 subgoal):\n 1. (\\<And>tx.\n        \\<lbrakk>tx \\<in> {A..B};\n         infdist x (d ` {A..B}) = dist x (d tx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  tx \\<in> {A..B}\n  infdist x (d ` {A..B}) = dist x (d tx)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {c A--c B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  tx \\<in> {A..B}\n  infdist x (d ` {A..B}) = dist x (d tx)", "have \"dist x (d tx) \\<le> D0\""], ["proof (prove)\nusing this:\n  tx \\<in> {A..B}\n  infdist x (d ` {A..B}) = dist x (d tx)\n\ngoal (1 subgoal):\n 1. dist x (d tx) \\<le> D0", "using first_step[OF \\<open>x \\<in> {c A--c B}\\<close>]"], ["proof (prove)\nusing this:\n  tx \\<in> {A..B}\n  infdist x (d ` {A..B}) = dist x (d tx)\n  infdist x (d ` {A..B}) \\<le> D0\n\ngoal (1 subgoal):\n 1. dist x (d tx) \\<le> D0", "by auto"], ["proof (state)\nthis:\n  dist x (d tx) \\<le> D0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {c A--c B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  dist x (d tx) \\<le> D0", "have \"x \\<in> cball (d tx) D0\""], ["proof (prove)\nusing this:\n  dist x (d tx) \\<le> D0\n\ngoal (1 subgoal):\n 1. x \\<in> cball (d tx) D0", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  x \\<in> cball (d tx) D0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {c A--c B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "consider \"tx \\<in> {A..tm}\" | \"tx \\<in> {tm<..<tM}\" | \"tx \\<in> {tM..B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tx \\<in> {A..tm} \\<Longrightarrow> thesis;\n     tx \\<in> {tm<..<tM} \\<Longrightarrow> thesis;\n     tx \\<in> {tM..B} \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \\<open>tx \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  tx \\<in> {A..B}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>tx \\<in> {A..tm} \\<Longrightarrow> thesis;\n     tx \\<in> {tm<..<tM} \\<Longrightarrow> thesis;\n     tx \\<in> {tM..B} \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>tx \\<in> {A..tm} \\<Longrightarrow> ?thesis;\n   tx \\<in> {tm<..<tM} \\<Longrightarrow> ?thesis;\n   tx \\<in> {tM..B} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {c A--c B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>tx \\<in> {A..tm} \\<Longrightarrow> ?thesis;\n   tx \\<in> {tm<..<tM} \\<Longrightarrow> ?thesis;\n   tx \\<in> {tM..B} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"x \\<in> Km \\<union> KM\""], ["proof (prove)\nusing this:\n  \\<lbrakk>tx \\<in> {A..tm} \\<Longrightarrow> ?thesis;\n   tx \\<in> {tm<..<tM} \\<Longrightarrow> ?thesis;\n   tx \\<in> {tM..B} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x \\<in> Km \\<union> KM", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. tx \\<in> {A..tm} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 2. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 3. tx \\<in> {tM..B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "case 1"], ["proof (state)\nthis:\n  tx \\<in> {A..tm}\n\ngoal (3 subgoals):\n 1. tx \\<in> {A..tm} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 2. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 3. tx \\<in> {tM..B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  tx \\<in> {A..tm}", "have \"x \\<in> Km\""], ["proof (prove)\nusing this:\n  tx \\<in> {A..tm}\n\ngoal (1 subgoal):\n 1. x \\<in> Km", "unfolding Km_def"], ["proof (prove)\nusing this:\n  tx \\<in> {A..tm}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>z\\<in>d ` {A..tm}. cball z D0)", "using \\<open>x \\<in> cball (d tx) D0\\<close>"], ["proof (prove)\nusing this:\n  tx \\<in> {A..tm}\n  x \\<in> cball (d tx) D0\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>z\\<in>d ` {A..tm}. cball z D0)", "by auto"], ["proof (state)\nthis:\n  x \\<in> Km\n\ngoal (3 subgoals):\n 1. tx \\<in> {A..tm} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 2. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 3. tx \\<in> {tM..B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  x \\<in> Km", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Km\n\ngoal (1 subgoal):\n 1. x \\<in> Km \\<union> KM", "by simp"], ["proof (state)\nthis:\n  x \\<in> Km \\<union> KM\n\ngoal (2 subgoals):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 2. tx \\<in> {tM..B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 2. tx \\<in> {tM..B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "case 3"], ["proof (state)\nthis:\n  tx \\<in> {tM..B}\n\ngoal (2 subgoals):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 2. tx \\<in> {tM..B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  tx \\<in> {tM..B}", "have \"x \\<in> KM\""], ["proof (prove)\nusing this:\n  tx \\<in> {tM..B}\n\ngoal (1 subgoal):\n 1. x \\<in> KM", "unfolding KM_def"], ["proof (prove)\nusing this:\n  tx \\<in> {tM..B}\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>z\\<in>d ` {tM..B}. cball z D0)", "using \\<open>x \\<in> cball (d tx) D0\\<close>"], ["proof (prove)\nusing this:\n  tx \\<in> {tM..B}\n  x \\<in> cball (d tx) D0\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>z\\<in>d ` {tM..B}. cball z D0)", "by auto"], ["proof (state)\nthis:\n  x \\<in> KM\n\ngoal (2 subgoals):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM\n 2. tx \\<in> {tM..B} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  x \\<in> KM", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> KM\n\ngoal (1 subgoal):\n 1. x \\<in> Km \\<union> KM", "by simp"], ["proof (state)\nthis:\n  x \\<in> Km \\<union> KM\n\ngoal (1 subgoal):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM", "case 2"], ["proof (state)\nthis:\n  tx \\<in> {tm<..<tM}\n\ngoal (1 subgoal):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM", "have \"infdist (d tx) {c A--c B} \\<le> dist (d tx) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infdist (d tx) {c A--c B} \\<le> dist (d tx) x", "using \\<open>x \\<in> {c A--c B}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> {c A--c B}\n\ngoal (1 subgoal):\n 1. infdist (d tx) {c A--c B} \\<le> dist (d tx) x", "by (rule infdist_le)"], ["proof (state)\nthis:\n  infdist (d tx) {c A--c B} \\<le> dist (d tx) x\n\ngoal (1 subgoal):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM", "also"], ["proof (state)\nthis:\n  infdist (d tx) {c A--c B} \\<le> dist (d tx) x\n\ngoal (1 subgoal):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM", "have \"... \\<le> D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (d tx) x \\<le> D0", "using \\<open>x \\<in> cball (d tx) D0\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> cball (d tx) D0\n\ngoal (1 subgoal):\n 1. dist (d tx) x \\<le> D0", "by auto"], ["proof (state)\nthis:\n  dist (d tx) x \\<le> D0\n\ngoal (1 subgoal):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM", "finally"], ["proof (chain)\npicking this:\n  infdist (d tx) {c A--c B} \\<le> D0", "have False"], ["proof (prove)\nusing this:\n  infdist (d tx) {c A--c B} \\<le> D0\n\ngoal (1 subgoal):\n 1. False", "using lower_tm_tM[OF 2]"], ["proof (prove)\nusing this:\n  infdist (d tx) {c A--c B} \\<le> D0\n  D0 < infdist (d tx) {c A--c B}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. tx \\<in> {tm<..<tM} \\<Longrightarrow> x \\<in> Km \\<union> KM", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x \\<in> Km \\<union> KM", "by simp"], ["proof (state)\nthis:\n  x \\<in> Km \\<union> KM\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> Km \\<union> KM\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {c A--c B} \\<subseteq> Km \\<union> KM\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "then"], ["proof (chain)\npicking this:\n  {c A--c B} \\<subseteq> Km \\<union> KM", "have *: \"{c A--c B} = (Km \\<inter> {c A--c B}) \\<union> (KM \\<inter> {c A--c B})\""], ["proof (prove)\nusing this:\n  {c A--c B} \\<subseteq> Km \\<union> KM\n\ngoal (1 subgoal):\n 1. {c A--c B} = Km \\<inter> {c A--c B} \\<union> KM \\<inter> {c A--c B}", "by auto"], ["proof (state)\nthis:\n  {c A--c B} = Km \\<inter> {c A--c B} \\<union> KM \\<inter> {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"(Km \\<inter> {c A--c B}) \\<inter> (KM \\<inter> {c A--c B}) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Km \\<inter> {c A--c B} \\<inter> (KM \\<inter> {c A--c B}) \\<noteq> {}", "proof (rule connected_as_closed_union[OF _ *])"], ["proof (state)\ngoal (5 subgoals):\n 1. connected {c A--c B}\n 2. closed (Km \\<inter> {c A--c B})\n 3. closed (KM \\<inter> {c A--c B})\n 4. Km \\<inter> {c A--c B} \\<noteq> {}\n 5. KM \\<inter> {c A--c B} \\<noteq> {}", "have \"closed Km\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed Km", "unfolding Km_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (\\<Union>z\\<in>d ` {A..tm}. cball z D0)", "apply (rule compact_has_closed_thickening)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compact (d ` {A..tm})\n 2. continuous_on (d ` {A..tm}) (\\<lambda>x. D0)", "apply (rule compact_continuous_image)"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {A..tm} d\n 2. compact {A..tm}\n 3. continuous_on (d ` {A..tm}) (\\<lambda>x. D0)", "apply (rule continuous_on_subset[OF \\<open>continuous_on {A..B} d\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {A..tm} \\<subseteq> {A..B}\n 2. compact {A..tm}\n 3. continuous_on (d ` {A..tm}) (\\<lambda>x. D0)", "using tm \\<open>ty \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  tm \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n  ty \\<in> {A..B}\n\ngoal (3 subgoals):\n 1. {A..tm} \\<subseteq> {A..B}\n 2. compact {A..tm}\n 3. continuous_on (d ` {A..tm}) (\\<lambda>x. D0)", "by auto"], ["proof (state)\nthis:\n  closed Km\n\ngoal (5 subgoals):\n 1. connected {c A--c B}\n 2. closed (Km \\<inter> {c A--c B})\n 3. closed (KM \\<inter> {c A--c B})\n 4. Km \\<inter> {c A--c B} \\<noteq> {}\n 5. KM \\<inter> {c A--c B} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  closed Km", "show \"closed (Km \\<inter> {c A--c B})\""], ["proof (prove)\nusing this:\n  closed Km\n\ngoal (1 subgoal):\n 1. closed (Km \\<inter> {c A--c B})", "by (rule topological_space_class.closed_Int, auto)"], ["proof (state)\nthis:\n  closed (Km \\<inter> {c A--c B})\n\ngoal (4 subgoals):\n 1. connected {c A--c B}\n 2. closed (KM \\<inter> {c A--c B})\n 3. Km \\<inter> {c A--c B} \\<noteq> {}\n 4. KM \\<inter> {c A--c B} \\<noteq> {}", "have \"closed KM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed KM", "unfolding KM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (\\<Union>z\\<in>d ` {tM..B}. cball z D0)", "apply (rule compact_has_closed_thickening)"], ["proof (prove)\ngoal (2 subgoals):\n 1. compact (d ` {tM..B})\n 2. continuous_on (d ` {tM..B}) (\\<lambda>x. D0)", "apply (rule compact_continuous_image)"], ["proof (prove)\ngoal (3 subgoals):\n 1. continuous_on {tM..B} d\n 2. compact {tM..B}\n 3. continuous_on (d ` {tM..B}) (\\<lambda>x. D0)", "apply (rule continuous_on_subset[OF \\<open>continuous_on {A..B} d\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {tM..B} \\<subseteq> {A..B}\n 2. compact {tM..B}\n 3. continuous_on (d ` {tM..B}) (\\<lambda>x. D0)", "using tM \\<open>ty \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  tM \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n  ty \\<in> {A..B}\n\ngoal (3 subgoals):\n 1. {tM..B} \\<subseteq> {A..B}\n 2. compact {tM..B}\n 3. continuous_on (d ` {tM..B}) (\\<lambda>x. D0)", "by auto"], ["proof (state)\nthis:\n  closed KM\n\ngoal (4 subgoals):\n 1. connected {c A--c B}\n 2. closed (KM \\<inter> {c A--c B})\n 3. Km \\<inter> {c A--c B} \\<noteq> {}\n 4. KM \\<inter> {c A--c B} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  closed KM", "show \"closed (KM \\<inter> {c A--c B})\""], ["proof (prove)\nusing this:\n  closed KM\n\ngoal (1 subgoal):\n 1. closed (KM \\<inter> {c A--c B})", "by (rule topological_space_class.closed_Int, auto)"], ["proof (state)\nthis:\n  closed (KM \\<inter> {c A--c B})\n\ngoal (3 subgoals):\n 1. connected {c A--c B}\n 2. Km \\<inter> {c A--c B} \\<noteq> {}\n 3. KM \\<inter> {c A--c B} \\<noteq> {}", "show \"connected {c A--c B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected {c A--c B}", "by simp"], ["proof (state)\nthis:\n  connected {c A--c B}\n\ngoal (2 subgoals):\n 1. Km \\<inter> {c A--c B} \\<noteq> {}\n 2. KM \\<inter> {c A--c B} \\<noteq> {}", "have \"c A \\<in> Km \\<inter> {c A--c B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c A \\<in> Km \\<inter> {c A--c B}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. c A \\<in> Km", "unfolding Km_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c A \\<in> (\\<Union>z\\<in>d ` {A..tm}. cball z D0)", "using tm \\<open>d A = c A\\<close> \\<open>D0 > 0\\<close>"], ["proof (prove)\nusing this:\n  tm \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n  d A = c A\n  0 < D0\n\ngoal (1 subgoal):\n 1. c A \\<in> (\\<Union>z\\<in>d ` {A..tm}. cball z D0)", "by (auto) (rule bexI[of _ A], auto)"], ["proof (state)\nthis:\n  c A \\<in> Km \\<inter> {c A--c B}\n\ngoal (2 subgoals):\n 1. Km \\<inter> {c A--c B} \\<noteq> {}\n 2. KM \\<inter> {c A--c B} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  c A \\<in> Km \\<inter> {c A--c B}", "show \"Km \\<inter> {c A--c B} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  c A \\<in> Km \\<inter> {c A--c B}\n\ngoal (1 subgoal):\n 1. Km \\<inter> {c A--c B} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Km \\<inter> {c A--c B} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. KM \\<inter> {c A--c B} \\<noteq> {}", "have \"c B \\<in> KM \\<inter> {c A--c B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c B \\<in> KM \\<inter> {c A--c B}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. c B \\<in> KM", "unfolding KM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c B \\<in> (\\<Union>z\\<in>d ` {tM..B}. cball z D0)", "using tM \\<open>d B = c B\\<close> \\<open>D0 > 0\\<close>"], ["proof (prove)\nusing this:\n  tM \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n  d B = c B\n  0 < D0\n\ngoal (1 subgoal):\n 1. c B \\<in> (\\<Union>z\\<in>d ` {tM..B}. cball z D0)", "by (auto) (rule bexI[of _ B], auto)"], ["proof (state)\nthis:\n  c B \\<in> KM \\<inter> {c A--c B}\n\ngoal (1 subgoal):\n 1. KM \\<inter> {c A--c B} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  c B \\<in> KM \\<inter> {c A--c B}", "show \"KM \\<inter> {c A--c B} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  c B \\<in> KM \\<inter> {c A--c B}\n\ngoal (1 subgoal):\n 1. KM \\<inter> {c A--c B} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  KM \\<inter> {c A--c B} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Km \\<inter> {c A--c B} \\<inter> (KM \\<inter> {c A--c B}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "then"], ["proof (chain)\npicking this:\n  Km \\<inter> {c A--c B} \\<inter> (KM \\<inter> {c A--c B}) \\<noteq> {}", "obtain w where \"w \\<in> {c A--c B}\" \"w \\<in> Km\" \"w \\<in> KM\""], ["proof (prove)\nusing this:\n  Km \\<inter> {c A--c B} \\<inter> (KM \\<inter> {c A--c B}) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> {c A--c B}; w \\<in> Km; w \\<in> KM\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<in> {c A--c B}\n  w \\<in> Km\n  w \\<in> KM\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "then"], ["proof (chain)\npicking this:\n  w \\<in> {c A--c B}\n  w \\<in> Km\n  w \\<in> KM", "obtain twm twM where tw: \"twm \\<in> {A..tm}\" \"w \\<in> cball (d twm) D0\" \"twM \\<in> {tM..B}\" \"w \\<in> cball (d twM) D0\""], ["proof (prove)\nusing this:\n  w \\<in> {c A--c B}\n  w \\<in> Km\n  w \\<in> KM\n\ngoal (1 subgoal):\n 1. (\\<And>twm twM.\n        \\<lbrakk>twm \\<in> {A..tm}; w \\<in> cball (d twm) D0;\n         twM \\<in> {tM..B}; w \\<in> cball (d twM) D0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Km_def KM_def"], ["proof (prove)\nusing this:\n  w \\<in> {c A--c B}\n  w \\<in> (\\<Union>z\\<in>d ` {A..tm}. cball z D0)\n  w \\<in> (\\<Union>z\\<in>d ` {tM..B}. cball z D0)\n\ngoal (1 subgoal):\n 1. (\\<And>twm twM.\n        \\<lbrakk>twm \\<in> {A..tm}; w \\<in> cball (d twm) D0;\n         twM \\<in> {tM..B}; w \\<in> cball (d twM) D0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  twm \\<in> {A..tm}\n  w \\<in> cball (d twm) D0\n  twM \\<in> {tM..B}\n  w \\<in> cball (d twM) D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"(1/lambda) * dist twm twM - (4*C) \\<le> dist (d twm) (d twM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / lambda * dist twm twM - 4 * C \\<le> dist (d twm) (d twM)", "apply (rule quasi_isometry_onD(2)[OF d(5)])"], ["proof (prove)\ngoal (2 subgoals):\n 1. twm \\<in> {A..B}\n 2. twM \\<in> {A..B}", "using tw tm tM"], ["proof (prove)\nusing this:\n  twm \\<in> {A..tm}\n  w \\<in> cball (d twm) D0\n  twM \\<in> {tM..B}\n  w \\<in> cball (d twM) D0\n  tm \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n  tM \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n\ngoal (2 subgoals):\n 1. twm \\<in> {A..B}\n 2. twM \\<in> {A..B}", "by auto"], ["proof (state)\nthis:\n  1 / lambda * dist twm twM - 4 * C \\<le> dist (d twm) (d twM)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "also"], ["proof (state)\nthis:\n  1 / lambda * dist twm twM - 4 * C \\<le> dist (d twm) (d twM)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"... \\<le> dist (d twm) w + dist w (d twM)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (d twm) (d twM) \\<le> dist (d twm) w + dist w (d twM)", "by (rule metric_space_class.dist_triangle)"], ["proof (state)\nthis:\n  dist (d twm) (d twM) \\<le> dist (d twm) w + dist w (d twM)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "also"], ["proof (state)\nthis:\n  dist (d twm) (d twM) \\<le> dist (d twm) w + dist w (d twM)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"... \\<le> 2 * D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (d twm) w + dist w (d twM) \\<le> 2 * D0", "using tw"], ["proof (prove)\nusing this:\n  twm \\<in> {A..tm}\n  w \\<in> cball (d twm) D0\n  twM \\<in> {tM..B}\n  w \\<in> cball (d twM) D0\n\ngoal (1 subgoal):\n 1. dist (d twm) w + dist w (d twM) \\<le> 2 * D0", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  dist (d twm) w + dist w (d twM) \\<le> 2 * D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "finally"], ["proof (chain)\npicking this:\n  1 / lambda * dist twm twM - 4 * C \\<le> 2 * D0", "have \"dist twm twM \\<le> lambda * (4*C + 2*D0)\""], ["proof (prove)\nusing this:\n  1 / lambda * dist twm twM - 4 * C \\<le> 2 * D0\n\ngoal (1 subgoal):\n 1. dist twm twM \\<le> lambda * (4 * C + 2 * D0)", "using C"], ["proof (prove)\nusing this:\n  1 / lambda * dist twm twM - 4 * C \\<le> 2 * D0\n  0 \\<le> C\n  1 \\<le> lambda\n\ngoal (1 subgoal):\n 1. dist twm twM \\<le> lambda * (4 * C + 2 * D0)", "by (auto simp add: divide_simps algebra_simps)"], ["proof (state)\nthis:\n  dist twm twM \\<le> lambda * (4 * C + 2 * D0)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "then"], ["proof (chain)\npicking this:\n  dist twm twM \\<le> lambda * (4 * C + 2 * D0)", "have *: \"dist twm ty \\<le> lambda * (4*C + 2*D0)\""], ["proof (prove)\nusing this:\n  dist twm twM \\<le> lambda * (4 * C + 2 * D0)\n\ngoal (1 subgoal):\n 1. dist twm ty \\<le> lambda * (4 * C + 2 * D0)", "using tw tm tM dist_real_def"], ["proof (prove)\nusing this:\n  dist twm twM \\<le> lambda * (4 * C + 2 * D0)\n  twm \\<in> {A..tm}\n  w \\<in> cball (d twm) D0\n  twM \\<in> {tM..B}\n  w \\<in> cball (d twM) D0\n  tm \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n  tM \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n  dist ?x ?y = \\<bar>?x - ?y\\<bar>\n\ngoal (1 subgoal):\n 1. dist twm ty \\<le> lambda * (4 * C + 2 * D0)", "by auto"], ["proof (state)\nthis:\n  dist twm ty \\<le> lambda * (4 * C + 2 * D0)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"dist (d ty) w \\<le> dist (d ty) (d twm) + dist (d twm) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (d ty) w \\<le> dist (d ty) (d twm) + dist (d twm) w", "by (rule metric_space_class.dist_triangle)"], ["proof (state)\nthis:\n  dist (d ty) w \\<le> dist (d ty) (d twm) + dist (d twm) w\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "also"], ["proof (state)\nthis:\n  dist (d ty) w \\<le> dist (d ty) (d twm) + dist (d twm) w\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"... \\<le> (lambda * dist ty twm + (4*C)) + D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist (d ty) (d twm) + dist (d twm) w\n    \\<le> lambda * dist ty twm + 4 * C + D0", "apply (intro add_mono, rule quasi_isometry_onD(1)[OF d(5)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ty \\<in> {A..B}\n 2. twm \\<in> {A..B}\n 3. dist (d twm) w \\<le> D0", "using tw tm tM"], ["proof (prove)\nusing this:\n  twm \\<in> {A..tm}\n  w \\<in> cball (d twm) D0\n  twM \\<in> {tM..B}\n  w \\<in> cball (d twM) D0\n  tm \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {A..ty}\n  tM \\<in> (\\<lambda>t. infdist (d t) {c A--c B}) -` {..D0} \\<inter> {ty..B}\n\ngoal (3 subgoals):\n 1. ty \\<in> {A..B}\n 2. twm \\<in> {A..B}\n 3. dist (d twm) w \\<le> D0", "by auto"], ["proof (state)\nthis:\n  dist (d ty) (d twm) + dist (d twm) w\n  \\<le> lambda * dist ty twm + 4 * C + D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "also"], ["proof (state)\nthis:\n  dist (d ty) (d twm) + dist (d twm) w\n  \\<le> lambda * dist ty twm + 4 * C + D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"... \\<le> (lambda * (lambda * (4*C + 2*D0))) + (4*C) + D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * dist ty twm + 4 * C + D0\n    \\<le> lambda * (lambda * (4 * C + 2 * D0)) + 4 * C + D0", "apply (intro mono_intros)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dist ty twm \\<le> lambda * (4 * C + 2 * D0)\n 2. 0 \\<le> lambda", "using C *"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  dist twm ty \\<le> lambda * (4 * C + 2 * D0)\n\ngoal (2 subgoals):\n 1. dist ty twm \\<le> lambda * (4 * C + 2 * D0)\n 2. 0 \\<le> lambda", "by (auto simp add: metric_space_class.dist_commute)"], ["proof (state)\nthis:\n  lambda * dist ty twm + 4 * C + D0\n  \\<le> lambda * (lambda * (4 * C + 2 * D0)) + 4 * C + D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "also"], ["proof (state)\nthis:\n  lambda * dist ty twm + 4 * C + D0\n  \\<le> lambda * (lambda * (4 * C + 2 * D0)) + 4 * C + D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"... = lambda * lambda * (4*C + 2*D0) + 1 * 1 * (4 * C) + 1 * 1 * D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * (lambda * (4 * C + 2 * D0)) + 4 * C + D0 =\n    lambda * lambda * (4 * C + 2 * D0) + 1 * 1 * (4 * C) + 1 * 1 * D0", "by simp"], ["proof (state)\nthis:\n  lambda * (lambda * (4 * C + 2 * D0)) + 4 * C + D0 =\n  lambda * lambda * (4 * C + 2 * D0) + 1 * 1 * (4 * C) + 1 * 1 * D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "also"], ["proof (state)\nthis:\n  lambda * (lambda * (4 * C + 2 * D0)) + 4 * C + D0 =\n  lambda * lambda * (4 * C + 2 * D0) + 1 * 1 * (4 * C) + 1 * 1 * D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"... \\<le> lambda * lambda * (4*C + 2*D0) + lambda * lambda * (4 * C) + lambda * lambda * D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * lambda * (4 * C + 2 * D0) + 1 * 1 * (4 * C) + 1 * 1 * D0\n    \\<le> lambda * lambda * (4 * C + 2 * D0) + lambda * lambda * (4 * C) +\n          lambda * lambda * D0", "apply (intro mono_intros)"], ["proof (prove)\ngoal (10 subgoals):\n 1. 1 \\<le> lambda\n 2. 1 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> 1\n 5. 0 \\<le> 4 * C\n 6. 1 \\<le> lambda\n 7. 1 \\<le> lambda\n 8. 0 \\<le> lambda\n 9. 0 \\<le> 1\n 10. 0 \\<le> D0", "using C * \\<open>D0 > 0\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  dist twm ty \\<le> lambda * (4 * C + 2 * D0)\n  0 < D0\n\ngoal (10 subgoals):\n 1. 1 \\<le> lambda\n 2. 1 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> 1\n 5. 0 \\<le> 4 * C\n 6. 1 \\<le> lambda\n 7. 1 \\<le> lambda\n 8. 0 \\<le> lambda\n 9. 0 \\<le> 1\n 10. 0 \\<le> D0", "by auto"], ["proof (state)\nthis:\n  lambda * lambda * (4 * C + 2 * D0) + 1 * 1 * (4 * C) + 1 * 1 * D0\n  \\<le> lambda * lambda * (4 * C + 2 * D0) + lambda * lambda * (4 * C) +\n        lambda * lambda * D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "also"], ["proof (state)\nthis:\n  lambda * lambda * (4 * C + 2 * D0) + 1 * 1 * (4 * C) + 1 * 1 * D0\n  \\<le> lambda * lambda * (4 * C + 2 * D0) + lambda * lambda * (4 * C) +\n        lambda * lambda * D0\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"... = lambda * lambda * (8 * C + 3 * D0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * lambda * (4 * C + 2 * D0) + lambda * lambda * (4 * C) +\n    lambda * lambda * D0 =\n    lambda * lambda * (8 * C + 3 * D0)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  lambda * lambda * (4 * C + 2 * D0) + lambda * lambda * (4 * C) +\n  lambda * lambda * D0 =\n  lambda * lambda * (8 * C + 3 * D0)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "also"], ["proof (state)\nthis:\n  lambda * lambda * (4 * C + 2 * D0) + lambda * lambda * (4 * C) +\n  lambda * lambda * D0 =\n  lambda * lambda * (8 * C + 3 * D0)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "have \"... = lambda * lambda * (44 * C + 72 * lambda + 72 * deltaG(TYPE('a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * lambda * (8 * C + 3 * D0) =\n    lambda * lambda *\n    (44 * C + 72 * lambda + 72 * (deltaG TYPE('a))\\<^sup>2)", "unfolding D0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * lambda *\n    (8 * C + 3 * (24 * lambda + 12 * C + 24 * (deltaG TYPE('a))\\<^sup>2)) =\n    lambda * lambda *\n    (44 * C + 72 * lambda + 72 * (deltaG TYPE('a))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  lambda * lambda * (8 * C + 3 * D0) =\n  lambda * lambda * (44 * C + 72 * lambda + 72 * (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "finally"], ["proof (chain)\npicking this:\n  dist (d ty) w\n  \\<le> lambda * lambda *\n        (44 * C + 72 * lambda + 72 * (deltaG TYPE('a))\\<^sup>2)", "have \"dist y w \\<le> D1\""], ["proof (prove)\nusing this:\n  dist (d ty) w\n  \\<le> lambda * lambda *\n        (44 * C + 72 * lambda + 72 * (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist y w \\<le> D1", "unfolding D1_def \\<open>y = d ty\\<close>"], ["proof (prove)\nusing this:\n  dist (d ty) w\n  \\<le> lambda * lambda *\n        (44 * C + 72 * lambda + 72 * (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. dist (d ty) w\n    \\<le> lambda * lambda *\n          (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  dist y w \\<le> D1\n\ngoal (1 subgoal):\n 1. \\<not> infdist y {c A--c B} \\<le> D0 \\<Longrightarrow>\n    infdist y {c A--c B} \\<le> D1", "then"], ["proof (chain)\npicking this:\n  dist y w \\<le> D1", "show \"infdist y {c A--c B} \\<le> D1\""], ["proof (prove)\nusing this:\n  dist y w \\<le> D1\n\ngoal (1 subgoal):\n 1. infdist y {c A--c B} \\<le> D1", "using infdist_le[OF \\<open>w \\<in> {c A--c B}\\<close>, of y]"], ["proof (prove)\nusing this:\n  dist y w \\<le> D1\n  infdist y {c A--c B} \\<le> dist y w\n\ngoal (1 subgoal):\n 1. infdist y {c A--c B} \\<le> D1", "by auto"], ["proof (state)\nthis:\n  infdist y {c A--c B} \\<le> D1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y \\<in> d ` {A..B} \\<Longrightarrow> infdist ?y {c A--c B} \\<le> D1\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "text \\<open>This concludes the second step.\\<close>"], ["proof (state)\nthis:\n  ?y \\<in> d ` {A..B} \\<Longrightarrow> infdist ?y {c A--c B} \\<le> D1\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "text \\<open>Putting the two steps together, we deduce that the Hausdorff distance between the\n    geodesic and the quasi-geodesic is bounded by $D1$. A bound between the geodesic and\n    the original (untamed) quasi-geodesic follows.\\<close>"], ["proof (state)\nthis:\n  ?y \\<in> d ` {A..B} \\<Longrightarrow> infdist ?y {c A--c B} \\<le> D1\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have a: \"hausdorff_distance (d`{A..B}) {c A--c B} \\<le> D1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (d ` {A..B}) {c A--c B} \\<le> D1", "proof (rule hausdorff_distanceI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> d ` {A..B} \\<Longrightarrow> infdist x {c A--c B} \\<le> D1\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow> infdist x (d ` {A..B}) \\<le> D1\n 3. 0 \\<le> D1", "show \"D1 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> D1", "unfolding D1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> lambda * lambda *\n            (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)", "using C delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  0 \\<le> deltaG TYPE('a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> lambda * lambda *\n            (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> D1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> d ` {A..B} \\<Longrightarrow> infdist x {c A--c B} \\<le> D1\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow> infdist x (d ` {A..B}) \\<le> D1", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> d ` {A..B} \\<Longrightarrow> infdist x {c A--c B} \\<le> D1\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow> infdist x (d ` {A..B}) \\<le> D1", "assume \"x \\<in> d ` {A..B}\""], ["proof (state)\nthis:\n  x \\<in> d ` {A..B}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> d ` {A..B} \\<Longrightarrow> infdist x {c A--c B} \\<le> D1\n 2. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow> infdist x (d ` {A..B}) \\<le> D1", "then"], ["proof (chain)\npicking this:\n  x \\<in> d ` {A..B}", "show \"infdist x {c A--c B} \\<le> D1\""], ["proof (prove)\nusing this:\n  x \\<in> d ` {A..B}\n\ngoal (1 subgoal):\n 1. infdist x {c A--c B} \\<le> D1", "using second_step"], ["proof (prove)\nusing this:\n  x \\<in> d ` {A..B}\n  ?y \\<in> d ` {A..B} \\<Longrightarrow> infdist ?y {c A--c B} \\<le> D1\n\ngoal (1 subgoal):\n 1. infdist x {c A--c B} \\<le> D1", "by auto"], ["proof (state)\nthis:\n  infdist x {c A--c B} \\<le> D1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow> infdist x (d ` {A..B}) \\<le> D1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow> infdist x (d ` {A..B}) \\<le> D1", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow> infdist x (d ` {A..B}) \\<le> D1", "assume \"x \\<in> {c A--c B}\""], ["proof (state)\nthis:\n  x \\<in> {c A--c B}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {c A--c B} \\<Longrightarrow> infdist x (d ` {A..B}) \\<le> D1", "then"], ["proof (chain)\npicking this:\n  x \\<in> {c A--c B}", "show \"infdist x (d`{A..B}) \\<le> D1\""], ["proof (prove)\nusing this:\n  x \\<in> {c A--c B}\n\ngoal (1 subgoal):\n 1. infdist x (d ` {A..B}) \\<le> D1", "using first_step \\<open>D0 \\<le> D1\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> {c A--c B}\n  ?y \\<in> {c A--c B} \\<Longrightarrow> infdist ?y (d ` {A..B}) \\<le> D0\n  D0 \\<le> D1\n\ngoal (1 subgoal):\n 1. infdist x (d ` {A..B}) \\<le> D1", "by force"], ["proof (state)\nthis:\n  infdist x (d ` {A..B}) \\<le> D1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hausdorff_distance (d ` {A..B}) {c A--c B} \\<le> D1\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"hausdorff_distance (c`{A..B}) {c A--c B} \\<le>\n        hausdorff_distance (c`{A..B}) (d`{A..B}) + hausdorff_distance (d`{A..B}) {c A--c B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> hausdorff_distance (c ` {A..B}) (d ` {A..B}) +\n          hausdorff_distance (d ` {A..B}) {c A--c B}", "apply (rule hausdorff_distance_triangle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. d ` {A..B} \\<noteq> {}\n 2. bounded (d ` {A..B})", "using \\<open>A \\<in> {A..B}\\<close>"], ["proof (prove)\nusing this:\n  A \\<in> {A..B}\n\ngoal (2 subgoals):\n 1. d ` {A..B} \\<noteq> {}\n 2. bounded (d ` {A..B})", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded (d ` {A..B})", "by (rule quasi_isometry_on_bounded[OF d(5)], auto)"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> hausdorff_distance (c ` {A..B}) (d ` {A..B}) +\n        hausdorff_distance (d ` {A..B}) {c A--c B}\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> hausdorff_distance (c ` {A..B}) (d ` {A..B}) +\n        hausdorff_distance (d ` {A..B}) {c A--c B}\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> D1 + 2*C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B}) +\n    hausdorff_distance (d ` {A..B}) {c A--c B}\n    \\<le> D1 + 2 * C", "using a d"], ["proof (prove)\nusing this:\n  hausdorff_distance (d ` {A..B}) {c A--c B} \\<le> D1\n  continuous_on {A..B} d\n  d A = c A\n  d B = c B\n  ?x \\<in> {A..B} \\<Longrightarrow> dist (c ?x) (d ?x) \\<le> 4 * C\n  lambda (4 * C) -quasi_isometry_on {A..B} d\n  (2 * lambda)-lipschitz_on {A..B} d\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) \\<le> 2 * C\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) (d ` {A..B}) +\n    hausdorff_distance (d ` {A..B}) {c A--c B}\n    \\<le> D1 + 2 * C", "by auto"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) +\n  hausdorff_distance (d ` {A..B}) {c A--c B}\n  \\<le> D1 + 2 * C\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) (d ` {A..B}) +\n  hausdorff_distance (d ` {A..B}) {c A--c B}\n  \\<le> D1 + 2 * C\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... = lambda * lambda * (72 * lambda + 44 * C + 72 * deltaG(TYPE('a))^2) + 1 * 1 * (2 * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D1 + 2 * C =\n    lambda * lambda *\n    (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n    1 * 1 * (2 * C)", "unfolding D1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * lambda *\n    (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n    2 * C =\n    lambda * lambda *\n    (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n    1 * 1 * (2 * C)", "by auto"], ["proof (state)\nthis:\n  D1 + 2 * C =\n  lambda * lambda *\n  (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n  1 * 1 * (2 * C)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  D1 + 2 * C =\n  lambda * lambda *\n  (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n  1 * 1 * (2 * C)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... \\<le> lambda * lambda * (72 * lambda + 44 * C + 72 * deltaG(TYPE('a))^2)\n                      + lambda * lambda * (28 * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * lambda *\n    (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n    1 * 1 * (2 * C)\n    \\<le> lambda * lambda *\n          (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n          lambda * lambda * (28 * C)", "apply (intro mono_intros)"], ["proof (prove)\ngoal (8 subgoals):\n 1. 1 \\<le> lambda\n 2. 1 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> 1\n 5. 2 \\<le> 28\n 6. 0 \\<le> C\n 7. 0 \\<le> lambda * lambda\n 8. 0 \\<le> 2 * C", "using C delta_nonneg"], ["proof (prove)\nusing this:\n  0 \\<le> C\n  1 \\<le> lambda\n  0 \\<le> deltaG TYPE('a)\n\ngoal (8 subgoals):\n 1. 1 \\<le> lambda\n 2. 1 \\<le> lambda\n 3. 0 \\<le> lambda\n 4. 0 \\<le> 1\n 5. 2 \\<le> 28\n 6. 0 \\<le> C\n 7. 0 \\<le> lambda * lambda\n 8. 0 \\<le> 2 * C", "by auto"], ["proof (state)\nthis:\n  lambda * lambda *\n  (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n  1 * 1 * (2 * C)\n  \\<le> lambda * lambda *\n        (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n        lambda * lambda * (28 * C)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "also"], ["proof (state)\nthis:\n  lambda * lambda *\n  (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n  1 * 1 * (2 * C)\n  \\<le> lambda * lambda *\n        (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n        lambda * lambda * (28 * C)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "have \"... = 72 * lambda^2 * (lambda + C + deltaG(TYPE('a))^2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lambda * lambda *\n    (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n    lambda * lambda * (28 * C) =\n    72 * lambda\\<^sup>2 * (lambda + C + (deltaG TYPE('a))\\<^sup>2)", "by (auto simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  lambda * lambda *\n  (72 * lambda + 44 * C + 72 * (deltaG TYPE('a))\\<^sup>2) +\n  lambda * lambda * (28 * C) =\n  72 * lambda\\<^sup>2 * (lambda + C + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 0 \\<le> B - A \\<and> 2 * C < dist (c A) (c B) \\<Longrightarrow>\n    hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "finally"], ["proof (chain)\npicking this:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 72 * lambda\\<^sup>2 * (lambda + C + (deltaG TYPE('a))\\<^sup>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 72 * lambda\\<^sup>2 * (lambda + C + (deltaG TYPE('a))\\<^sup>2)\n\ngoal (1 subgoal):\n 1. hausdorff_distance (c ` {A..B}) {c A--c B}\n    \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)", "by (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hausdorff_distance (c ` {A..B}) {c A--c B}\n  \\<le> 72 * lambda\\<^sup>2 * (C + lambda + (deltaG TYPE('a))\\<^sup>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(*of theory Morse_Gromov_Theorem*)"]]}